[2024-01-09 12:29:54 INFO] **[Preprocessing]**

**ChatDev Starts** (20240901122954)

**Timestamp**: 20240901122954

**config_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/ChatChainConfig.json

**config_phase_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/PhaseConfig.json

**config_role_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/RoleConfig.json

**task_prompt**: // SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.10;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";
import "@openzeppelin/contracts/utils/math/SafeCast.sol";

import "../../../interfaces/IGasBank.sol";
import "../../../interfaces/pool/ILiquidityPool.sol";
import "../../../interfaces/IController.sol";
import "../../../interfaces/IStakerVault.sol";
import "../../../interfaces/actions/topup/ITopUpHandler.sol";
import "../../../interfaces/actions/topup/ITopUpAction.sol";
import "../../../interfaces/actions/IActionFeeHandler.sol";

import "../../../libraries/AddressProviderHelpers.sol";
import "../../../libraries/Errors.sol";
import "../../../libraries/ScaledMath.sol";
import "../../../libraries/EnumerableExtensions.sol";
import "../../../libraries/UncheckedMath.sol";

import "../../access/Authorization.sol";
import "../../utils/Preparable.sol";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param stakerVaultAddress The address of the staker vault
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > lockAmount ? lockAmount : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            _approve(token, stakerVaultAddress);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            lockAmount -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (lockAmount > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= lockAmount) {
                stakerVault.transferFrom(payer, address(this), lockAmount);
                stakerVault.increaseActionLockedBalance(payer, lockAmount);
                lockAmount = 0;
            }
        }

        require(lockAmount == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        require(underlying == actionToken, Error.TOKEN_NOT_USABLE);
        return amount.scaledDivRoundUp(rate);
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) private {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using UncheckedMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;
    using SafeCast for uint256;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being "too deep"
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
        address topUpHandler;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 550_000;

    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";
    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        for (uint256 i; i < protocols.length; i = i.uncheckedInc()) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount`, once converted to units of `actionToken`, must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param protocol Protocol which holds position to be topped up.
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable override returns (bool) {
        require(record.maxFee != 0, Error.INVALID_MAX_FEE);
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.registeredAt = uint64(block.timestamp);
        record.depositTokenBalance = totalLockAmount.toUint128();
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        IAddressProvider addressProvider_ = addressProvider;
        address vault = addressProvider_.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider_.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external override onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee)
        external
        override
        onlyGovernance
        returns (bool)
    {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external override onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external override onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external override onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage)
        external
        override
        onlyGovernance
        returns (bool)
    {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external override returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external override onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i; i < howMany; i = i.uncheckedInc()) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);
        require(block.timestamp > position.registeredAt, Error.CANNOT_EXECUTE_IN_SAME_BLOCK);

        vars.topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(vars.topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IAddressProvider addressProvider_ = addressProvider;
        IGasBank gasBank = addressProvider_.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider_.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider_.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        uint256 value_;
        if (position.actionToken == address(0)) {
            value_ = vars.actionTokenAmount;
        } else {
            _approve(position.actionToken, vars.topUpHandler);
        }
        vars.topupResult = ITopUpHandler(vars.topUpHandler).topUp{value: value_}(
            account,
            position.actionToken,
            vars.actionTokenAmount,
            position.extra
        );

        require(vars.topupResult, Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new "balance" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= vars.totalActionTokenAmount.toUint128();
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= vars.depositAmountWithFees.toUint128();

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the address to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        override
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes calldata extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view override returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the `actionToken`.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        return pool.getUnderlying() == toToken;
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}


**project_name**: RealWorld_BA_131_TopUpAction

**Log File**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/WareHouse/RealWorld_BA_131_TopUpAction_RealWord_20240901122954.log

**ChatDevConfig**:
ChatEnvConfig.with_memory: False
ChatEnvConfig.clear_structure: True
ChatEnvConfig.git_management: False
ChatEnvConfig.gui_design: True
ChatEnvConfig.incremental_develop: False
ChatEnvConfig.background_prompt: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.


**ChatGPTConfig**:
ChatGPTConfig(temperature=0.2, top_p=1.0, n=1, stream=False, stop=None, max_tokens=None, presence_penalty=0.0, frequency_penalty=0.0, logit_bias={}, user='')



[2024-01-09 12:29:54 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.10; import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol"; import "@openzeppelin/contracts/utils/math/SafeCast.sol"; import "../../../interfaces/IGasBank.sol"; import "../../../interfaces/pool/ILiquidityPool.sol"; import "../../../interfaces/IController.sol"; import "../../../interfaces/IStakerVault.sol"; import "../../../interfaces/actions/topup/ITopUpHandler.sol"; import "../../../interfaces/actions/topup/ITopUpAction.sol"; import "../../../interfaces/actions/IActionFeeHandler.sol"; import "../../../libraries/AddressProviderHelpers.sol"; import "../../../libraries/Errors.sol"; import "../../../libraries/ScaledMath.sol"; import "../../../libraries/EnumerableExtensions.sol"; import "../../../libraries/UncheckedMath.sol"; import "../../access/Authorization.sol"; import "../../utils/Preparable.sol"; /*  * @notice The logic here should really be part of the top-up action  * but is split in a library to circumvent the byte-code size limit  / library TopUpActionLibrary {     using SafeERC20 for IERC20;     using ScaledMath for uint256;     using AddressProviderHelpers for IAddressProvider; /**  * @dev "Locks" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param stakerVaultAddress The address of the staker vault  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function lockFunds(     address stakerVaultAddress,     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) external {     IStakerVault stakerVault = IStakerVault(stakerVaultAddress);      // stake deposit amount     if (depositAmount &gt; 0) {         depositAmount = depositAmount &gt; lockAmount ? lockAmount : depositAmount;         IERC20(token).safeTransferFrom(payer, address(this), depositAmount);         _approve(token, stakerVaultAddress);         stakerVault.stake(depositAmount);         stakerVault.increaseActionLockedBalance(payer, depositAmount);         lockAmount -= depositAmount;     }      // use stake vault allowance if available and required     if (lockAmount &gt; 0) {         uint256 balance = stakerVault.balanceOf(payer);         uint256 allowance = stakerVault.allowance(payer, address(this));         uint256 availableFunds = balance &lt; allowance ? balance : allowance;         if (availableFunds &gt;= lockAmount) {             stakerVault.transferFrom(payer, address(this), lockAmount);             stakerVault.increaseActionLockedBalance(payer, lockAmount);             lockAmount = 0;         }     }      require(lockAmount == 0, Error.INSUFFICIENT_UPDATE_BALANCE); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function calcExchangeAmount(     IAddressProvider addressProvider,     address token,     address actionToken,     uint256 amount ) external view returns (uint256) {     ILiquidityPool pool = addressProvider.getPoolForToken(token);     uint256 rate = pool.exchangeRate();     address underlying = pool.getUnderlying();     require(underlying == actionToken, Error.TOKEN_NOT_USABLE);     return amount.scaledDivRoundUp(rate); }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) private {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  } contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {     using ScaledMath for uint256;     using UncheckedMath for uint256;     using ScaledMath for uint128;     using SafeERC20 for IERC20;     using EnumerableSet for EnumerableSet.AddressSet;     using EnumerableSet for EnumerableSet.Bytes32Set;     using EnumerableExtensions for EnumerableSet.AddressSet;     using AddressProviderHelpers for IAddressProvider;     using SafeCast for uint256; /**  * @dev Temporary struct to hold local variables in execute  * and avoid the stack being "too deep"  */ struct ExecuteLocalVars {     uint256 minActionAmountToTopUp;     uint256 actionTokenAmount;     uint256 depositTotalFeesAmount;     uint256 actionAmountWithFees;     uint256 userFactor;     uint256 rate;     uint256 depositAmountWithFees;     uint256 depositAmountWithoutFees;     uint256 actionFee;     uint256 totalActionTokenAmount;     uint128 totalTopUpAmount;     bool topupResult;     uint256 gasBankBalance;     uint256 initialGas;     uint256 gasConsumed;     uint256 userGasPrice;     uint256 estimatedRequiredGas;     uint256 estimatedRequiredWeiForGas;     uint256 requiredWeiForGas;     uint256 reimbursedWeiForGas;     address underlying;     bool removePosition;     address topUpHandler; }  EnumerableSet.AddressSet private _usableTokens;  uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 550_000;  bytes32 internal constant _ACTION_FEE_KEY = "ActionFee"; bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler"; bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler"; bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";  uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;  IController public immutable controller; IAddressProvider public immutable addressProvider;  EnumerableSet.Bytes32Set internal _supportedProtocols;  /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record) mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;  mapping(address =&gt; RecordMeta[]) internal _userPositions;  EnumerableSet.AddressSet internal _usersWithPositions;  constructor(IController _controller)     Authorization(_controller.addressProvider().getRoleManager()) {     controller = _controller;     addressProvider = controller.addressProvider();     _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE); }  receive() external payable {     // solhint-disable-previous-line no-empty-blocks }  function initialize(     address feeHandler,     bytes32[] calldata protocols,     address[] calldata handlers ) external initializer onlyGovernance {     require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);     _setConfig(_FEE_HANDLER_KEY, feeHandler);     for (uint256 i; i &lt; protocols.length; i = i.uncheckedInc()) {         bytes32 protocolKey = _getProtocolKey(protocols[i]);         _setConfig(protocolKey, handlers[i]);         _updateTopUpHandler(protocols[i], address(0), handlers[i]);     } }  /**  * @notice Register a top up action.  * @dev The `depositAmount`, once converted to units of `actionToken`, must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).  * @param account Account to be topped up (first 20 bytes will typically be the address).  * @param protocol Protocol which holds position to be topped up.  * @param depositAmount Amount of `depositToken` that will be locked.  * @param record containing the data for the position to register  */ function register(     bytes32 account,     bytes32 protocol,     uint128 depositAmount,     Record memory record ) external payable override returns (bool) {     require(record.maxFee != 0, Error.INVALID_MAX_FEE);     require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);     require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);     require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);     require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);     require(         _positions[msg.sender][account][protocol].threshold == 0,         Error.POSITION_ALREADY_EXISTS     );     require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);     require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);      uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *         record.maxFee *         getEstimatedGasUsage();      require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);      uint256 totalLockAmount = _calcExchangeAmount(         record.depositToken,         record.actionToken,         record.totalTopUpAmount     );     _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);      addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);      record.registeredAt = uint64(block.timestamp);     record.depositTokenBalance = totalLockAmount.toUint128();     _positions[msg.sender][account][protocol] = record;     _userPositions[msg.sender].push(RecordMeta(account, protocol));     _usersWithPositions.add(msg.sender);      emit Register(         account,         protocol,         record.threshold,         msg.sender,         record.depositToken,         totalLockAmount,         record.actionToken,         record.singleTopUpAmount,         record.totalTopUpAmount,         record.maxFee,         record.extra     );     return true; }  /**  * @notice See overloaded version of `execute` for more details.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol ) external override returns (bool) {     return execute(payer, account, beneficiary, protocol, 0); }  /**  * @notice Delete a position to back on the given protocol for `account`.  * @param account Account holding the position.  * @param protocol Protocol the position is held on.  * @param unstake If the tokens should be unstaked from vault.  * @return `true` if successful.  */ function resetPosition(     bytes32 account,     bytes32 protocol,     bool unstake ) external override returns (bool) {     address payer = msg.sender;     Record memory position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);      IAddressProvider addressProvider_ = addressProvider;     address vault = addressProvider_.getStakerVault(position.depositToken); // will revert if vault does not exist     IStakerVault staker = IStakerVault(vault);     staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);     if (unstake) {         staker.unstake(position.depositTokenBalance);         IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);     } else {         staker.transfer(payer, position.depositTokenBalance);     }      _removePosition(payer, account, protocol);     addressProvider_.getGasBank().withdrawUnused(payer);     return true; }  /**  * @notice Execute top up handler update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @param protocol Protocol for which a new handler should be executed.  * @return Address of new handler.  */ function executeTopUpHandler(bytes32 protocol) external override returns (address) {     address oldHandler = _getHandler(protocol, false);     address newHandler = _executeAddress(_getProtocolKey(protocol));      _updateTopUpHandler(protocol, oldHandler, newHandler);     return newHandler; }  /**  * @notice Reset new top up handler deadline for a protocol.  * @param protocol Protocol for which top up handler deadline should be reset.  * @return `true` if successful.  */ function resetTopUpHandler(bytes32 protocol) external override onlyGovernance returns (bool) {     return _resetAddressConfig(_getProtocolKey(protocol)); }  /**  * @notice Prepare action fee update.  * @param newActionFee New fee to set.  * @return `true` if success.  */ function prepareActionFee(uint256 newActionFee)     external     override     onlyGovernance     returns (bool) {     require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);     return _prepare(_ACTION_FEE_KEY, newActionFee); }  /**  * @notice Execute action fee update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeActionFee() external override returns (uint256) {     return _executeUInt256(_ACTION_FEE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetActionFee() external override onlyGovernance returns (bool) {     return _resetUInt256Config(_ACTION_FEE_KEY); }  /** Set fee handler */ /**  * @notice Prepare update of fee handler.  * @param handler New fee handler.  * @return `true` if success.  */ function prepareFeeHandler(address handler) external override onlyGovernance returns (bool) {     return _prepare(_FEE_HANDLER_KEY, handler); }  /**  * @notice Execute update of fee handler (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeFeeHandler() external override returns (address) {     return _executeAddress(_FEE_HANDLER_KEY); }  /**  * @notice Reset the handler deadline.  * @return `true` if success.  */ function resetFeeHandler() external override onlyGovernance returns (bool) {     return _resetAddressConfig(_FEE_HANDLER_KEY); }  /**  * @notice Prepare update of estimated gas usage.  * @param gasUsage New estimated gas usage.  * @return `true` if success.  */ function prepareEstimatedGasUsage(uint256 gasUsage)     external     override     onlyGovernance     returns (bool) {     return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage); }  /**  * @notice Execute update of gas usage (with time delay enforced).  * @return `true` if successful.  */ function executeEstimatedGasUsage() external override returns (uint256) {     return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Reset the gas usage deadline.  * @return `true` if success.  */ function resetGasUsage() external override onlyGovernance returns (bool) {     return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Add a new deposit token that is supported by the action.  * @dev There is a separate check for whether the usable token (i.e. deposit token)  *      is swappable for some action token.  * @param token Address of deposit token that can be used by the action.  */ function addUsableToken(address token) external override onlyGovernance returns (bool) {     return _usableTokens.add(token); }  /**  * @notice Computes the total amount of ETH (as wei) required to pay for all  * the top-ups assuming the maximum gas price and the current estimated gas  * usage of a top-up  */ function getEthRequiredForGas(address payer) external view override returns (uint256) {     uint256 totalEthRequired;     RecordMeta[] memory userRecordsMeta = _userPositions[payer];     uint256 gasUsagePerCall = getEstimatedGasUsage();     uint256 length = userRecordsMeta.length;     for (uint256 i; i &lt; length; i = i.uncheckedInc()) {         RecordMeta memory meta = userRecordsMeta[i];         Record memory record = _positions[payer][meta.account][meta.protocol];         uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);         totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;     }     return totalEthRequired; }  /**  * @notice Returns a list of positions for the given payer  */ function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {     return _userPositions[payer]; }  /**  * @notice Get a list supported protocols.  * @return List of supported protocols.  */ function getSupportedProtocols() external view override returns (bytes32[] memory) {     uint256 length = _supportedProtocols.length();     bytes32[] memory protocols = new bytes32[](length);     for (uint256 i; i &lt; length; i = i.uncheckedInc()) {         protocols[i] = _supportedProtocols.at(i);     }     return protocols; }  /*  * @notice Gets a list of users that have an active position.  * @dev Uses cursor pagination.  * @param cursor The cursor for pagination (should start at 0 for first call).  * @param howMany Maximum number of users to return in this pagination request.  * @return users List of users that have an active position.  * @return nextCursor The cursor to use for the next pagination request.  */ function usersWithPositions(uint256 cursor, uint256 howMany)     external     view     override     returns (address[] memory users, uint256 nextCursor) {     uint256 length = _usersWithPositions.length();     if (cursor &gt;= length) return (new address[](0), 0);     if (howMany &gt;= length - cursor) {         howMany = length - cursor;     }      address[] memory usersWithPositions_ = new address[](howMany);     for (uint256 i; i &lt; howMany; i = i.uncheckedInc()) {         usersWithPositions_[i] = _usersWithPositions.at(i + cursor);     }      return (usersWithPositions_, cursor + howMany); }  /**  * @notice Get a list of all tokens usable for this action.  * @dev This refers to all tokens that can be used as deposit tokens.  * @return Array of addresses of usable tokens.  */ function getUsableTokens() external view override returns (address[] memory) {     return _usableTokens.toArray(); }  /**  * @notice Retrieves the topup handler for the given `protocol`  */ function getTopUpHandler(bytes32 protocol) external view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice Successfully tops up a position if it's conditions are met.  * @dev pool and vault funds are rebalanced after withdrawal for top up  * @param payer Account that pays for the top up.  * @param account Account owning the position for top up.  * @param beneficiary Address of the keeper's wallet for fee accrual.  * @param protocol Protocol of the top up position.  * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas  * @return `true` if successful.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol,     uint256 maxWeiForGas ) public override returns (bool) {     require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);      ExecuteLocalVars memory vars;      vars.initialGas = gasleft();      Record storage position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);     require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);     require(block.timestamp &gt; position.registeredAt, Error.CANNOT_EXECUTE_IN_SAME_BLOCK);      vars.topUpHandler = _getHandler(protocol, true);     vars.userFactor = ITopUpHandler(vars.topUpHandler).getUserFactor(account, position.extra);      // ensure that the position is actually below its set user factor threshold     require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);      IAddressProvider addressProvider_ = addressProvider;     IGasBank gasBank = addressProvider_.getGasBank();      // fail early if the user does not have enough funds in the gas bank     // to cover the cost of the transaction     vars.estimatedRequiredGas = getEstimatedGasUsage();     vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;      // compute the gas price that the user will be paying     vars.userGasPrice = block.basefee + position.priorityFee;     if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;     if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;      // ensure the current position allows for the gas to be paid     require(         vars.estimatedRequiredWeiForGas &lt;=             vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,         Error.ESTIMATED_GAS_TOO_HIGH     );      vars.gasBankBalance = gasBank.balanceOf(payer);     // ensure the user has enough funds in the gas bank to cover the gas     require(         vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,         Error.GAS_BANK_BALANCE_TOO_LOW     );      vars.totalTopUpAmount = position.totalTopUpAmount;     vars.actionFee = getActionFee();     // add top-up fees to top-up amount     vars.minActionAmountToTopUp = position.singleTopUpAmount;     vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(         ScaledMath.ONE + vars.actionFee     );      // if the amount that we want to top-up (including fees) is higher than     // the available topup amount, we lower this down to what is left of the position     if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {         vars.actionAmountWithFees = vars.totalTopUpAmount;         vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(             ScaledMath.ONE + vars.actionFee         );     }     ILiquidityPool pool = addressProvider_.getPoolForToken(position.depositToken);     vars.underlying = pool.getUnderlying();     vars.rate = pool.exchangeRate();      // compute the deposit tokens amount with and without fees     // we will need to unstake the amount with fees and to     // swap the amount without fees into action tokens     vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);     if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {         vars.depositAmountWithFees = position.depositTokenBalance;         vars.minActionAmountToTopUp =             (vars.depositAmountWithFees * vars.rate) /             (ScaledMath.ONE + vars.actionFee);     }      // compute amount of LP tokens needed to pay for action     // rate is expressed in actionToken per depositToken     vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);     vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;      // will revert if vault does not exist     address vault = addressProvider_.getStakerVault(position.depositToken);      // unstake deposit tokens including fees     IStakerVault(vault).unstake(vars.depositAmountWithFees);     IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);      // swap the amount without the fees     // as the fees are paid in deposit token, not in action token     vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);      // compute how much of action token was actually redeemed and add fees to it     // this is to ensure that no funds get locked inside the contract     vars.totalActionTokenAmount =         vars.actionTokenAmount +         vars.depositTotalFeesAmount.scaledMul(vars.rate);      // at this point, we have exactly `vars.actionTokenAmount`     // (at least `position.singleTopUpAmount`) of action token     // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract     // solhint-disable-next-line avoid-low-level-calls     uint256 value_;     if (position.actionToken == address(0)) {         value_ = vars.actionTokenAmount;     } else {         _approve(position.actionToken, vars.topUpHandler);     }     vars.topupResult = ITopUpHandler(vars.topUpHandler).topUp{value: value_}(         account,         position.actionToken,         vars.actionTokenAmount,         position.extra     );      require(vars.topupResult, Error.TOP_UP_FAILED);      // totalTopUpAmount is updated to reflect the new "balance" of the position     if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {         position.totalTopUpAmount -= vars.totalActionTokenAmount.toUint128();     } else {         position.totalTopUpAmount = 0;     }      position.depositTokenBalance -= vars.depositAmountWithFees.toUint128();      vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;     _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);     if (vars.removePosition) {         if (position.depositTokenBalance &gt; 0) {             // transfer any unused locked tokens to the payer             IStakerVault(vault).transfer(payer, position.depositTokenBalance);             IStakerVault(vault).decreaseActionLockedBalance(                 payer,                 position.depositTokenBalance             );         }         _removePosition(payer, account, protocol);     }      emit TopUp(         account,         protocol,         payer,         position.depositToken,         vars.depositAmountWithFees,         position.actionToken,         vars.actionTokenAmount     );      // compute gas used and reimburse the keeper by using the     // funds of payer in the gas bank     // TODO: add constant gas consumed for transfer and tx prologue     vars.gasConsumed = vars.initialGas - gasleft();      vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;     if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {         vars.reimbursedWeiForGas = vars.gasBankBalance;     }      // ensure that the keeper is not overpaying     vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;     require(         vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,         Error.GAS_TOO_HIGH     );     gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);     if (vars.removePosition) {         gasBank.withdrawUnused(payer);     }      return true; }  /**  * @notice Prepare new top up handler fee update.  * @dev Setting the address to 0 means that the protocol will no longer be supported.  * @param protocol Protocol for which a new handler should be prepared.  * @param newHandler Address of new handler.  * @return `true` if success.  */ function prepareTopUpHandler(bytes32 protocol, address newHandler)     public     override     onlyGovernance     returns (bool) {     return _prepare(_getProtocolKey(protocol), newHandler); }  /**  * @notice Check if action can be executed.  * @param protocol for which to get the health factor  * @param account for which to get the health factor  * @param extra data to be used by the topup handler  * @return healthFactor of the position  */ function getHealthFactor(     bytes32 protocol,     bytes32 account,     bytes calldata extra ) public view override returns (uint256 healthFactor) {     ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));     return topUpHandler.getUserFactor(account, extra); }  function getHandler(bytes32 protocol) public view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice returns the current estimated gas usage  */ function getEstimatedGasUsage() public view override returns (uint256) {     return currentUInts256[_ESTIMATED_GAS_USAGE_KEY]; }  /**  * @notice Returns the current action fee  */ function getActionFee() public view override returns (uint256) {     return currentUInts256[_ACTION_FEE_KEY]; }  /**  * @notice Returns the current fee handler  */ function getFeeHandler() public view override returns (address) {     return currentAddresses[_FEE_HANDLER_KEY]; }  /**  * @notice Get the record for a position.  * @param payer Registered payer of the position.  * @param account Address holding the position.  * @param protocol Protocol where the position is held.  */ function getPosition(     address payer,     bytes32 account,     bytes32 protocol ) public view override returns (Record memory) {     return _positions[payer][account][protocol]; }  /**  * @notice Check whether a token is usable as a deposit token.  * @param token Address of token to check.  * @return True if token is usable as a deposit token for this action.  */ function isUsable(address token) public view override returns (bool) {     return _usableTokens.contains(token); }  function _updateTopUpHandler(     bytes32 protocol,     address oldHandler,     address newHandler ) internal {     if (newHandler == address(0)) {         _supportedProtocols.remove(protocol);     } else if (oldHandler == address(0)) {         _supportedProtocols.add(protocol);     } }  /**  * @dev Pays fees to the feeHandler  * @param payer The account who's position the fees are charged on  * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)  * @param feeAmount The amount in tokens to pay as fees  * @param depositToken The LpToken used to pay the fees  */ function _payFees(     address payer,     address beneficiary,     uint256 feeAmount,     address depositToken ) internal {     address feeHandler = getFeeHandler();     IERC20(depositToken).safeApprove(feeHandler, feeAmount);     IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken); }  /**  * @dev "Locks" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function _lockFunds(     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) internal {     address stakerVaultAddress = addressProvider.getStakerVault(token);     TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount); }  function _removePosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     delete _positions[payer][account][protocol];     _removeUserPosition(payer, account, protocol);     if (_userPositions[payer].length == 0) {         _usersWithPositions.remove(payer);     }     emit Deregister(payer, account, protocol); }  function _removeUserPosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     RecordMeta[] storage positionsMeta = _userPositions[payer];     uint256 length = positionsMeta.length;     for (uint256 i; i &lt; length; i = i.uncheckedInc()) {         RecordMeta storage positionMeta = positionsMeta[i];         if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {             positionsMeta[i] = positionsMeta[length - 1];             positionsMeta.pop();             return;         }     } }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) internal {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the `actionToken`.  */ function _calcExchangeAmount(     address token,     address actionToken,     uint256 amount ) internal view returns (uint256) {     return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount); }  function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {     address handler = currentAddresses[_getProtocolKey(protocol)];     require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);     return handler; }  function _isSwappable(address depositToken, address toToken) internal view returns (bool) {     ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);     return pool.getUnderlying() == toToken; }  function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {     return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol)); }  } |
| **need_reflect** | True |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **phase_prompt** | We excel in generating innovative approaches and enhancements for Solidity smart contract code. Here's a Solidity contract provided by the user: "{task}". As the {assistant_role}, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user. Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions". |
| **phase_name** | ContractAnalysis |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': '// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";\nimport "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\nimport "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";\nimport "@openzeppelin/contracts/utils/math/SafeCast.sol";\n\nimport "../../../interfaces/IGasBank.sol";\nimport "../../../interfaces/pool/ILiquidityPool.sol";\nimport "../../../interfaces/IController.sol";\nimport "../../../interfaces/IStakerVault.sol";\nimport "../../../interfaces/actions/topup/ITopUpHandler.sol";\nimport "../../../interfaces/actions/topup/ITopUpAction.sol";\nimport "../../../interfaces/actions/IActionFeeHandler.sol";\n\nimport "../../../libraries/AddressProviderHelpers.sol";\nimport "../../../libraries/Errors.sol";\nimport "../../../libraries/ScaledMath.sol";\nimport "../../../libraries/EnumerableExtensions.sol";\nimport "../../../libraries/UncheckedMath.sol";\n\nimport "../../access/Authorization.sol";\nimport "../../utils/Preparable.sol";\n\n/\n * @notice The logic here should really be part of the top-up action\n * but is split in a library to circumvent the byte-code size limit\n */\nlibrary TopUpActionLibrary {\n    using SafeERC20 for IERC20;\n    using ScaledMath for uint256;\n    using AddressProviderHelpers for IAddressProvider;\n\n    /\n     * @dev "Locks" an amount of tokens on behalf of the TopUpAction\n     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.\n     * @param stakerVaultAddress The address of the staker vault\n     * @param payer Owner of the funds to be locked\n     * @param token Token to lock\n     * @param lockAmount Minimum amount of token to lock\n     * @param depositAmount Amount of token that was deposited.\n     *                      If this is 0 then the staker vault allowance should be used.\n     *                      If this is greater than requiredAmount more tokens will be locked.\n     /\n    function lockFunds(\n        address stakerVaultAddress,\n        address payer,\n        address token,\n        uint256 lockAmount,\n        uint256 depositAmount\n    ) external {\n        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);\n\n        // stake deposit amount\n        if (depositAmount &gt; 0) {\n            depositAmount = depositAmount &gt; lockAmount ? lockAmount : depositAmount;\n            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);\n            _approve(token, stakerVaultAddress);\n            stakerVault.stake(depositAmount);\n            stakerVault.increaseActionLockedBalance(payer, depositAmount);\n            lockAmount -= depositAmount;\n        }\n\n        // use stake vault allowance if available and required\n        if (lockAmount &gt; 0) {\n            uint256 balance = stakerVault.balanceOf(payer);\n            uint256 allowance = stakerVault.allowance(payer, address(this));\n            uint256 availableFunds = balance &lt; allowance ? balance : allowance;\n            if (availableFunds &gt;= lockAmount) {\n                stakerVault.transferFrom(payer, address(this), lockAmount);\n                stakerVault.increaseActionLockedBalance(payer, lockAmount);\n                lockAmount = 0;\n            }\n        }\n\n        require(lockAmount == 0, Error.INSUFFICIENT_UPDATE_BALANCE);\n    }\n\n    /\n     * @dev Computes and returns the amount of LP tokens of type token that will be received in exchange for an amount of the underlying.\n     /\n    function calcExchangeAmount(\n        IAddressProvider addressProvider,\n        address token,\n        address actionToken,\n        uint256 amount\n    ) external view returns (uint256) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(token);\n        uint256 rate = pool.exchangeRate();\n        address underlying = pool.getUnderlying();\n        require(underlying == actionToken, Error.TOKEN_NOT_USABLE);\n        return amount.scaledDivRoundUp(rate);\n    }\n\n    /\n     * @dev Approves infinite spending for the given spender.\n     * @param token The token to approve for.\n     * @param spender The spender to approve.\n     */\n    function _approve(address token, address spender) private {\n        if (IERC20(token).allowance(address(this), spender) &gt; 0) return;\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n}\n\ncontract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {\n    using ScaledMath for uint256;\n    using UncheckedMath for uint256;\n    using ScaledMath for uint128;\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using EnumerableExtensions for EnumerableSet.AddressSet;\n    using AddressProviderHelpers for IAddressProvider;\n    using SafeCast for uint256;\n\n    /\n     * @dev Temporary struct to hold local variables in execute\n     * and avoid the stack being "too deep"\n     /\n    struct ExecuteLocalVars {\n        uint256 minActionAmountToTopUp;\n        uint256 actionTokenAmount;\n        uint256 depositTotalFeesAmount;\n        uint256 actionAmountWithFees;\n        uint256 userFactor;\n        uint256 rate;\n        uint256 depositAmountWithFees;\n        uint256 depositAmountWithoutFees;\n        uint256 actionFee;\n        uint256 totalActionTokenAmount;\n        uint128 totalTopUpAmount;\n        bool topupResult;\n        uint256 gasBankBalance;\n        uint256 initialGas;\n        uint256 gasConsumed;\n        uint256 userGasPrice;\n        uint256 estimatedRequiredGas;\n        uint256 estimatedRequiredWeiForGas;\n        uint256 requiredWeiForGas;\n        uint256 reimbursedWeiForGas;\n        address underlying;\n        bool removePosition;\n        address topUpHandler;\n    }\n\n    EnumerableSet.AddressSet private _usableTokens;\n\n    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 550_000;\n\n    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";\n    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";\n    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";\n    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";\n\n    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;\n\n    IController public immutable controller;\n    IAddressProvider public immutable addressProvider;\n\n    EnumerableSet.Bytes32Set internal _supportedProtocols;\n\n    /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record)\n    mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;\n\n    mapping(address =&gt; RecordMeta[]) internal _userPositions;\n\n    EnumerableSet.AddressSet internal _usersWithPositions;\n\n    constructor(IController _controller)\n        Authorization(_controller.addressProvider().getRoleManager())\n    {\n        controller = _controller;\n        addressProvider = controller.addressProvider();\n        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);\n    }\n\n    receive() external payable {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    function initialize(\n        address feeHandler,\n        bytes32[] calldata protocols,\n        address[] calldata handlers\n    ) external initializer onlyGovernance {\n        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);\n        _setConfig(_FEE_HANDLER_KEY, feeHandler);\n        for (uint256 i; i &lt; protocols.length; i = i.uncheckedInc()) {\n            bytes32 protocolKey = _getProtocolKey(protocols[i]);\n            _setConfig(protocolKey, handlers[i]);\n            _updateTopUpHandler(protocols[i], address(0), handlers[i]);\n        }\n    }\n\n    /\n     * @notice Register a top up action.\n     * @dev The depositAmount, once converted to units of actionToken, must be greater or equal to the totalTopUpAmount (which is denominated in actionToken).\n     * @param account Account to be topped up (first 20 bytes will typically be the address).\n     * @param protocol Protocol which holds position to be topped up.\n     * @param depositAmount Amount of depositToken that will be locked.\n     * @param record containing the data for the position to register\n     /\n    function register(\n        bytes32 account,\n        bytes32 protocol,\n        uint128 depositAmount,\n        Record memory record\n    ) external payable override returns (bool) {\n        require(record.maxFee != 0, Error.INVALID_MAX_FEE);\n        require(supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);\n        require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);\n        require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);\n        require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);\n        require(\n            _positions[msg.sender][account][protocol].threshold == 0,\n            Error.POSITION_ALREADY_EXISTS\n        );\n        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);\n        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);\n\n        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) \n            record.maxFee \n            getEstimatedGasUsage();\n\n        require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);\n\n        uint256 totalLockAmount = _calcExchangeAmount(\n            record.depositToken,\n            record.actionToken,\n            record.totalTopUpAmount\n        );\n        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);\n\n        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);\n\n        record.registeredAt = uint64(block.timestamp);\n        record.depositTokenBalance = totalLockAmount.toUint128();\n        _positions[msg.sender][account][protocol] = record;\n        _userPositions[msg.sender].push(RecordMeta(account, protocol));\n        _usersWithPositions.add(msg.sender);\n\n        emit Register(\n            account,\n            protocol,\n            record.threshold,\n            msg.sender,\n            record.depositToken,\n            totalLockAmount,\n            record.actionToken,\n            record.singleTopUpAmount,\n            record.totalTopUpAmount,\n            record.maxFee,\n            record.extra\n        );\n        return true;\n    }\n\n    /\n     * @notice See overloaded version of execute for more details.\n     */\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol\n    ) external override returns (bool) {\n        return execute(payer, account, beneficiary, protocol, 0);\n    }\n\n    /\n     * @notice Delete a position to back on the given protocol for account.\n     * @param account Account holding the position.\n     * @param protocol Protocol the position is held on.\n     * @param unstake If the tokens should be unstaked from vault.\n     * @return true if successful.\n     /\n    function resetPosition(\n        bytes32 account,\n        bytes32 protocol,\n        bool unstake\n    ) external override returns (bool) {\n        address payer = msg.sender;\n        Record memory position = positions[payer][account][protocol];\n        require(position.threshold != 0, Error.NO_POSITION_EXISTS);\n\n        IAddressProvider addressProvider = addressProvider;\n        address vault = addressProvider_.getStakerVault(position.depositToken); // will revert if vault does not exist\n        IStakerVault staker = IStakerVault(vault);\n        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);\n        if (unstake) {\n            staker.unstake(position.depositTokenBalance);\n            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);\n        } else {\n            staker.transfer(payer, position.depositTokenBalance);\n        }\n\n        removePosition(payer, account, protocol);\n        addressProvider.getGasBank().withdrawUnused(payer);\n        return true;\n    }\n\n    /\n     * @notice Execute top up handler update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @param protocol Protocol for which a new handler should be executed.\n     * @return Address of new handler.\n     /\n    function executeTopUpHandler(bytes32 protocol) external override returns (address) {\n        address oldHandler = _getHandler(protocol, false);\n        address newHandler = _executeAddress(_getProtocolKey(protocol));\n\n        _updateTopUpHandler(protocol, oldHandler, newHandler);\n        return newHandler;\n    }\n\n    /\n     * @notice Reset new top up handler deadline for a protocol.\n     * @param protocol Protocol for which top up handler deadline should be reset.\n     * @return true if successful.\n     */\n    function resetTopUpHandler(bytes32 protocol) external override onlyGovernance returns (bool) {\n        return _resetAddressConfig(_getProtocolKey(protocol));\n    }\n\n    /\n     * @notice Prepare action fee update.\n     * @param newActionFee New fee to set.\n     * @return true if success.\n     /\n    function prepareActionFee(uint256 newActionFee)\n        external\n        override\n        onlyGovernance\n        returns (bool)\n    {\n        require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);\n        return _prepare(_ACTION_FEE_KEY, newActionFee);\n    }\n\n    /\n     * @notice Execute action fee update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return true if successful.\n     /\n    function executeActionFee() external override returns (uint256) {\n        return _executeUInt256(_ACTION_FEE_KEY);\n    }\n\n    /\n     * @notice Reset action fee deadline.\n     * @return true if successful.\n     */\n    function resetActionFee() external override onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ACTION_FEE_KEY);\n    }\n\n    / Set fee handler /\n    /\n     * @notice Prepare update of fee handler.\n     * @param handler New fee handler.\n     * @return true if success.\n     /\n    function prepareFeeHandler(address handler) external override onlyGovernance returns (bool) {\n        return _prepare(_FEE_HANDLER_KEY, handler);\n    }\n\n    /\n     * @notice Execute update of fee handler (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return true if successful.\n     */\n    function executeFeeHandler() external override returns (address) {\n        return _executeAddress(_FEE_HANDLER_KEY);\n    }\n\n    /\n     * @notice Reset the handler deadline.\n     * @return true if success.\n     /\n    function resetFeeHandler() external override onlyGovernance returns (bool) {\n        return _resetAddressConfig(_FEE_HANDLER_KEY);\n    }\n\n    /\n     * @notice Prepare update of estimated gas usage.\n     * @param gasUsage New estimated gas usage.\n     * @return true if success.\n     /\n    function prepareEstimatedGasUsage(uint256 gasUsage)\n        external\n        override\n        onlyGovernance\n        returns (bool)\n    {\n        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);\n    }\n\n    /\n     * @notice Execute update of gas usage (with time delay enforced).\n     * @return true if successful.\n     */\n    function executeEstimatedGasUsage() external override returns (uint256) {\n        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);\n    }\n\n    /\n     * @notice Reset the gas usage deadline.\n     * @return true if success.\n     /\n    function resetGasUsage() external override onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);\n    }\n\n    /\n     * @notice Add a new deposit token that is supported by the action.\n     * @dev There is a separate check for whether the usable token (i.e. deposit token)\n     *      is swappable for some action token.\n     * @param token Address of deposit token that can be used by the action.\n     /\n    function addUsableToken(address token) external override onlyGovernance returns (bool) {\n        return _usableTokens.add(token);\n    }\n\n    /\n     * @notice Computes the total amount of ETH (as wei) required to pay for all\n     * the top-ups assuming the maximum gas price and the current estimated gas\n     * usage of a top-up\n     */\n    function getEthRequiredForGas(address payer) external view override returns (uint256) {\n        uint256 totalEthRequired;\n        RecordMeta[] memory userRecordsMeta = _userPositions[payer];\n        uint256 gasUsagePerCall = getEstimatedGasUsage();\n        uint256 length = userRecordsMeta.length;\n        for (uint256 i; i &lt; length; i = i.uncheckedInc()) {\n            RecordMeta memory meta = userRecordsMeta[i];\n            Record memory record = _positions[payer][meta.account][meta.protocol];\n            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);\n            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;\n        }\n        return totalEthRequired;\n    }\n\n    /\n     * @notice Returns a list of positions for the given payer\n     /\n    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {\n        return _userPositions[payer];\n    }\n\n    /\n     * @notice Get a list supported protocols.\n     * @return List of supported protocols.\n     /\n    function getSupportedProtocols() external view override returns (bytes32[] memory) {\n        uint256 length = _supportedProtocols.length();\n        bytes32[] memory protocols = new bytes32;\n        for (uint256 i; i &lt; length; i = i.uncheckedInc()) {\n            protocols[i] = _supportedProtocols.at(i);\n        }\n        return protocols;\n    }\n\n    /\n     * @notice Gets a list of users that have an active position.\n     * @dev Uses cursor pagination.\n     * @param cursor The cursor for pagination (should start at 0 for first call).\n     * @param howMany Maximum number of users to return in this pagination request.\n     * @return users List of users that have an active position.\n     * @return nextCursor The cursor to use for the next pagination request.\n     /\n    function usersWithPositions(uint256 cursor, uint256 howMany)\n        external\n        view\n        override\n        returns (address[] memory users, uint256 nextCursor)\n    {\n        uint256 length = _usersWithPositions.length();\n        if (cursor &gt;= length) return (new address, 0);\n        if (howMany &gt;= length - cursor) {\n            howMany = length - cursor;\n        }\n\n        address[] memory usersWithPositions = new address;\n        for (uint256 i; i &lt; howMany; i = i.uncheckedInc()) {\n            usersWithPositions_[i] = usersWithPositions.at(i + cursor);\n        }\n\n        return (usersWithPositions, cursor + howMany);\n    }\n\n    /\n     * @notice Get a list of all tokens usable for this action.\n     * @dev This refers to all tokens that can be used as deposit tokens.\n     * @return Array of addresses of usable tokens.\n     */\n    function getUsableTokens() external view override returns (address[] memory) {\n        return _usableTokens.toArray();\n    }\n\n    /\n     * @notice Retrieves the topup handler for the given protocol\n     /\n    function getTopUpHandler(bytes32 protocol) external view override returns (address) {\n        return _getHandler(protocol, false);\n    }\n\n    /\n     * @notice Successfully tops up a position if it\'s conditions are met.\n     * @dev pool and vault funds are rebalanced after withdrawal for top up\n     * @param payer Account that pays for the top up.\n     * @param account Account owning the position for top up.\n     * @param beneficiary Address of the keeper\'s wallet for fee accrual.\n     * @param protocol Protocol of the top up position.\n     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas\n     * @return true if successful.\n     /\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol,\n        uint256 maxWeiForGas\n    ) public override returns (bool) {\n        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);\n\n        ExecuteLocalVars memory vars;\n\n        vars.initialGas = gasleft();\n\n        Record storage position = positions[payer][account][protocol];\n        require(position.threshold != 0, Error.NO_POSITION_EXISTS);\n        require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);\n        require(block.timestamp &gt; position.registeredAt, Error.CANNOT_EXECUTE_IN_SAME_BLOCK);\n\n        vars.topUpHandler = _getHandler(protocol, true);\n        vars.userFactor = ITopUpHandler(vars.topUpHandler).getUserFactor(account, position.extra);\n\n        // ensure that the position is actually below its set user factor threshold\n        require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);\n\n        IAddressProvider addressProvider = addressProvider;\n        IGasBank gasBank = addressProvider_.getGasBank();\n\n        // fail early if the user does not have enough funds in the gas bank\n        // to cover the cost of the transaction\n        vars.estimatedRequiredGas = getEstimatedGasUsage();\n        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;\n\n        // compute the gas price that the user will be paying\n        vars.userGasPrice = block.basefee + position.priorityFee;\n        if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;\n        if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;\n\n        // ensure the current position allows for the gas to be paid\n        require(\n            vars.estimatedRequiredWeiForGas &lt;=\n                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,\n            Error.ESTIMATED_GAS_TOO_HIGH\n        );\n\n        vars.gasBankBalance = gasBank.balanceOf(payer);\n        // ensure the user has enough funds in the gas bank to cover the gas\n        require(\n            vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,\n            Error.GAS_BANK_BALANCE_TOO_LOW\n        );\n\n        vars.totalTopUpAmount = position.totalTopUpAmount;\n        vars.actionFee = getActionFee();\n        // add top-up fees to top-up amount\n        vars.minActionAmountToTopUp = position.singleTopUpAmount;\n        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(\n            ScaledMath.ONE + vars.actionFee\n        );\n\n        // if the amount that we want to top-up (including fees) is higher than\n        // the available topup amount, we lower this down to what is left of the position\n        if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {\n            vars.actionAmountWithFees = vars.totalTopUpAmount;\n            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(\n                ScaledMath.ONE + vars.actionFee\n            );\n        }\n        ILiquidityPool pool = addressProvider_.getPoolForToken(position.depositToken);\n        vars.underlying = pool.getUnderlying();\n        vars.rate = pool.exchangeRate();\n\n        // compute the deposit tokens amount with and without fees\n        // we will need to unstake the amount with fees and to\n        // swap the amount without fees into action tokens\n        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);\n        if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {\n            vars.depositAmountWithFees = position.depositTokenBalance;\n            vars.minActionAmountToTopUp =\n                (vars.depositAmountWithFees * vars.rate) /\n                (ScaledMath.ONE + vars.actionFee);\n        }\n\n        // compute amount of LP tokens needed to pay for action\n        // rate is expressed in actionToken per depositToken\n        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);\n        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;\n\n        // will revert if vault does not exist\n        address vault = addressProvider_.getStakerVault(position.depositToken);\n\n        // unstake deposit tokens including fees\n        IStakerVault(vault).unstake(vars.depositAmountWithFees);\n        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);\n\n        // swap the amount without the fees\n        // as the fees are paid in deposit token, not in action token\n        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);\n\n        // compute how much of action token was actually redeemed and add fees to it\n        // this is to ensure that no funds get locked inside the contract\n        vars.totalActionTokenAmount =\n            vars.actionTokenAmount +\n            vars.depositTotalFeesAmount.scaledMul(vars.rate);\n\n        // at this point, we have exactly vars.actionTokenAmount\n        // (at least position.singleTopUpAmount) of action token\n        // and exactly vars.depositTotalFeesAmount deposit tokens in the contract\n        // solhint-disable-next-line avoid-low-level-calls\n        uint256 value_;\n        if (position.actionToken == address(0)) {\n            value_ = vars.actionTokenAmount;\n        } else {\n            approve(position.actionToken, vars.topUpHandler);\n        }\n        vars.topupResult = ITopUpHandler(vars.topUpHandler).topUp{value: value}(\n            account,\n            position.actionToken,\n            vars.actionTokenAmount,\n            position.extra\n        );\n\n        require(vars.topupResult, Error.TOP_UP_FAILED);\n\n        // totalTopUpAmount is updated to reflect the new "balance" of the position\n        if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {\n            position.totalTopUpAmount -= vars.totalActionTokenAmount.toUint128();\n        } else {\n            position.totalTopUpAmount = 0;\n        }\n\n        position.depositTokenBalance -= vars.depositAmountWithFees.toUint128();\n\n        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;\n        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);\n        if (vars.removePosition) {\n            if (position.depositTokenBalance &gt; 0) {\n                // transfer any unused locked tokens to the payer\n                IStakerVault(vault).transfer(payer, position.depositTokenBalance);\n                IStakerVault(vault).decreaseActionLockedBalance(\n                    payer,\n                    position.depositTokenBalance\n                );\n            }\n            _removePosition(payer, account, protocol);\n        }\n\n        emit TopUp(\n            account,\n            protocol,\n            payer,\n            position.depositToken,\n            vars.depositAmountWithFees,\n            position.actionToken,\n            vars.actionTokenAmount\n        );\n\n        // compute gas used and reimburse the keeper by using the\n        // funds of payer in the gas bank\n        // TODO: add constant gas consumed for transfer and tx prologue\n        vars.gasConsumed = vars.initialGas - gasleft();\n\n        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;\n        if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {\n            vars.reimbursedWeiForGas = vars.gasBankBalance;\n        }\n\n        // ensure that the keeper is not overpaying\n        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;\n        require(\n            vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,\n            Error.GAS_TOO_HIGH\n        );\n        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);\n        if (vars.removePosition) {\n            gasBank.withdrawUnused(payer);\n        }\n\n        return true;\n    }\n\n    /\n     * @notice Prepare new top up handler fee update.\n     * @dev Setting the address to 0 means that the protocol will no longer be supported.\n     * @param protocol Protocol for which a new handler should be prepared.\n     * @param newHandler Address of new handler.\n     * @return true if success.\n     */\n    function prepareTopUpHandler(bytes32 protocol, address newHandler)\n        public\n        override\n        onlyGovernance\n        returns (bool)\n    {\n        return _prepare(_getProtocolKey(protocol), newHandler);\n    }\n\n    /\n     * @notice Check if action can be executed.\n     * @param protocol for which to get the health factor\n     * @param account for which to get the health factor\n     * @param extra data to be used by the topup handler\n     * @return healthFactor of the position\n     /\n    function getHealthFactor(\n        bytes32 protocol,\n        bytes32 account,\n        bytes calldata extra\n    ) public view override returns (uint256 healthFactor) {\n        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));\n        return topUpHandler.getUserFactor(account, extra);\n    }\n\n    function getHandler(bytes32 protocol) public view override returns (address) {\n        return _getHandler(protocol, false);\n    }\n\n    /\n     * @notice returns the current estimated gas usage\n     /\n    function getEstimatedGasUsage() public view override returns (uint256) {\n        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];\n    }\n\n    /\n     * @notice Returns the current action fee\n     */\n    function getActionFee() public view override returns (uint256) {\n        return currentUInts256[_ACTION_FEE_KEY];\n    }\n\n    /\n     * @notice Returns the current fee handler\n     /\n    function getFeeHandler() public view override returns (address) {\n        return currentAddresses[_FEE_HANDLER_KEY];\n    }\n\n    /\n     * @notice Get the record for a position.\n     * @param payer Registered payer of the position.\n     * @param account Address holding the position.\n     * @param protocol Protocol where the position is held.\n     /\n    function getPosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) public view override returns (Record memory) {\n        return _positions[payer][account][protocol];\n    }\n\n    /\n     * @notice Check whether a token is usable as a deposit token.\n     * @param token Address of token to check.\n     * @return True if token is usable as a deposit token for this action.\n     */\n    function isUsable(address token) public view override returns (bool) {\n        return _usableTokens.contains(token);\n    }\n\n    function _updateTopUpHandler(\n        bytes32 protocol,\n        address oldHandler,\n        address newHandler\n    ) internal {\n        if (newHandler == address(0)) {\n            _supportedProtocols.remove(protocol);\n        } else if (oldHandler == address(0)) {\n            _supportedProtocols.add(protocol);\n        }\n    }\n\n    /\n     * @dev Pays fees to the feeHandler\n     * @param payer The account who\'s position the fees are charged on\n     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)\n     * @param feeAmount The amount in tokens to pay as fees\n     * @param depositToken The LpToken used to pay the fees\n     /\n    function _payFees(\n        address payer,\n        address beneficiary,\n        uint256 feeAmount,\n        address depositToken\n    ) internal {\n        address feeHandler = getFeeHandler();\n        IERC20(depositToken).safeApprove(feeHandler, feeAmount);\n        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);\n    }\n\n    /\n     * @dev "Locks" an amount of tokens on behalf of the TopUpAction\n     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.\n     * @param payer Owner of the funds to be locked\n     * @param token Token to lock\n     * @param lockAmount Minimum amount of token to lock\n     * @param depositAmount Amount of token that was deposited.\n     *                      If this is 0 then the staker vault allowance should be used.\n     *                      If this is greater than requiredAmount more tokens will be locked.\n     /\n    function _lockFunds(\n        address payer,\n        address token,\n        uint256 lockAmount,\n        uint256 depositAmount\n    ) internal {\n        address stakerVaultAddress = addressProvider.getStakerVault(token);\n        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);\n    }\n\n    function _removePosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) internal {\n        delete _positions[payer][account][protocol];\n        _removeUserPosition(payer, account, protocol);\n        if (_userPositions[payer].length == 0) {\n            _usersWithPositions.remove(payer);\n        }\n        emit Deregister(payer, account, protocol);\n    }\n\n    function _removeUserPosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) internal {\n        RecordMeta[] storage positionsMeta = _userPositions[payer];\n        uint256 length = positionsMeta.length;\n        for (uint256 i; i &lt; length; i = i.uncheckedInc()) {\n            RecordMeta storage positionMeta = positionsMeta[i];\n            if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {\n                positionsMeta[i] = positionsMeta[length - 1];\n                positionsMeta.pop();\n                return;\n            }\n        }\n    }\n\n    /\n     * @dev Approves infinite spending for the given spender.\n     * @param token The token to approve for.\n     * @param spender The spender to approve.\n     */\n    function _approve(address token, address spender) internal {\n        if (IERC20(token).allowance(address(this), spender) &gt; 0) return;\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n\n    /\n     * @dev Computes and returns the amount of LP tokens of type token that will be received in exchange for an amount of the actionToken.\n     */\n    function _calcExchangeAmount(\n        address token,\n        address actionToken,\n        uint256 amount\n    ) internal view returns (uint256) {\n        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);\n    }\n\n    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {\n        address handler = currentAddresses[_getProtocolKey(protocol)];\n        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);\n        return handler;\n    }\n\n    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);\n        return pool.getUnderlying() == toToken;\n    }\n\n    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));\n    }\n}\n'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 12:29:54 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.10; import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol"; import "@openzeppelin/contracts/utils/math/SafeCast.sol"; import "../../../interfaces/IGasBank.sol"; import "../../../interfaces/pool/ILiquidityPool.sol"; import "../../../interfaces/IController.sol"; import "../../../interfaces/IStakerVault.sol"; import "../../../interfaces/actions/topup/ITopUpHandler.sol"; import "../../../interfaces/actions/topup/ITopUpAction.sol"; import "../../../interfaces/actions/IActionFeeHandler.sol"; import "../../../libraries/AddressProviderHelpers.sol"; import "../../../libraries/Errors.sol"; import "../../../libraries/ScaledMath.sol"; import "../../../libraries/EnumerableExtensions.sol"; import "../../../libraries/UncheckedMath.sol"; import "../../access/Authorization.sol"; import "../../utils/Preparable.sol"; /*  * @notice The logic here should really be part of the top-up action  * but is split in a library to circumvent the byte-code size limit  / library TopUpActionLibrary {     using SafeERC20 for IERC20;     using ScaledMath for uint256;     using AddressProviderHelpers for IAddressProvider; /**  * @dev "Locks" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param stakerVaultAddress The address of the staker vault  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function lockFunds(     address stakerVaultAddress,     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) external {     IStakerVault stakerVault = IStakerVault(stakerVaultAddress);      // stake deposit amount     if (depositAmount &gt; 0) {         depositAmount = depositAmount &gt; lockAmount ? lockAmount : depositAmount;         IERC20(token).safeTransferFrom(payer, address(this), depositAmount);         _approve(token, stakerVaultAddress);         stakerVault.stake(depositAmount);         stakerVault.increaseActionLockedBalance(payer, depositAmount);         lockAmount -= depositAmount;     }      // use stake vault allowance if available and required     if (lockAmount &gt; 0) {         uint256 balance = stakerVault.balanceOf(payer);         uint256 allowance = stakerVault.allowance(payer, address(this));         uint256 availableFunds = balance &lt; allowance ? balance : allowance;         if (availableFunds &gt;= lockAmount) {             stakerVault.transferFrom(payer, address(this), lockAmount);             stakerVault.increaseActionLockedBalance(payer, lockAmount);             lockAmount = 0;         }     }      require(lockAmount == 0, Error.INSUFFICIENT_UPDATE_BALANCE); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function calcExchangeAmount(     IAddressProvider addressProvider,     address token,     address actionToken,     uint256 amount ) external view returns (uint256) {     ILiquidityPool pool = addressProvider.getPoolForToken(token);     uint256 rate = pool.exchangeRate();     address underlying = pool.getUnderlying();     require(underlying == actionToken, Error.TOKEN_NOT_USABLE);     return amount.scaledDivRoundUp(rate); }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) private {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  } contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {     using ScaledMath for uint256;     using UncheckedMath for uint256;     using ScaledMath for uint128;     using SafeERC20 for IERC20;     using EnumerableSet for EnumerableSet.AddressSet;     using EnumerableSet for EnumerableSet.Bytes32Set;     using EnumerableExtensions for EnumerableSet.AddressSet;     using AddressProviderHelpers for IAddressProvider;     using SafeCast for uint256; /**  * @dev Temporary struct to hold local variables in execute  * and avoid the stack being "too deep"  */ struct ExecuteLocalVars {     uint256 minActionAmountToTopUp;     uint256 actionTokenAmount;     uint256 depositTotalFeesAmount;     uint256 actionAmountWithFees;     uint256 userFactor;     uint256 rate;     uint256 depositAmountWithFees;     uint256 depositAmountWithoutFees;     uint256 actionFee;     uint256 totalActionTokenAmount;     uint128 totalTopUpAmount;     bool topupResult;     uint256 gasBankBalance;     uint256 initialGas;     uint256 gasConsumed;     uint256 userGasPrice;     uint256 estimatedRequiredGas;     uint256 estimatedRequiredWeiForGas;     uint256 requiredWeiForGas;     uint256 reimbursedWeiForGas;     address underlying;     bool removePosition;     address topUpHandler; }  EnumerableSet.AddressSet private _usableTokens;  uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 550_000;  bytes32 internal constant _ACTION_FEE_KEY = "ActionFee"; bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler"; bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler"; bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";  uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;  IController public immutable controller; IAddressProvider public immutable addressProvider;  EnumerableSet.Bytes32Set internal _supportedProtocols;  /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record) mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;  mapping(address =&gt; RecordMeta[]) internal _userPositions;  EnumerableSet.AddressSet internal _usersWithPositions;  constructor(IController _controller)     Authorization(_controller.addressProvider().getRoleManager()) {     controller = _controller;     addressProvider = controller.addressProvider();     _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE); }  receive() external payable {     // solhint-disable-previous-line no-empty-blocks }  function initialize(     address feeHandler,     bytes32[] calldata protocols,     address[] calldata handlers ) external initializer onlyGovernance {     require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);     _setConfig(_FEE_HANDLER_KEY, feeHandler);     for (uint256 i; i &lt; protocols.length; i = i.uncheckedInc()) {         bytes32 protocolKey = _getProtocolKey(protocols[i]);         _setConfig(protocolKey, handlers[i]);         _updateTopUpHandler(protocols[i], address(0), handlers[i]);     } }  /**  * @notice Register a top up action.  * @dev The `depositAmount`, once converted to units of `actionToken`, must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).  * @param account Account to be topped up (first 20 bytes will typically be the address).  * @param protocol Protocol which holds position to be topped up.  * @param depositAmount Amount of `depositToken` that will be locked.  * @param record containing the data for the position to register  */ function register(     bytes32 account,     bytes32 protocol,     uint128 depositAmount,     Record memory record ) external payable override returns (bool) {     require(record.maxFee != 0, Error.INVALID_MAX_FEE);     require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);     require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);     require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);     require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);     require(         _positions[msg.sender][account][protocol].threshold == 0,         Error.POSITION_ALREADY_EXISTS     );     require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);     require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);      uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *         record.maxFee *         getEstimatedGasUsage();      require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);      uint256 totalLockAmount = _calcExchangeAmount(         record.depositToken,         record.actionToken,         record.totalTopUpAmount     );     _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);      addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);      record.registeredAt = uint64(block.timestamp);     record.depositTokenBalance = totalLockAmount.toUint128();     _positions[msg.sender][account][protocol] = record;     _userPositions[msg.sender].push(RecordMeta(account, protocol));     _usersWithPositions.add(msg.sender);      emit Register(         account,         protocol,         record.threshold,         msg.sender,         record.depositToken,         totalLockAmount,         record.actionToken,         record.singleTopUpAmount,         record.totalTopUpAmount,         record.maxFee,         record.extra     );     return true; }  /**  * @notice See overloaded version of `execute` for more details.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol ) external override returns (bool) {     return execute(payer, account, beneficiary, protocol, 0); }  /**  * @notice Delete a position to back on the given protocol for `account`.  * @param account Account holding the position.  * @param protocol Protocol the position is held on.  * @param unstake If the tokens should be unstaked from vault.  * @return `true` if successful.  */ function resetPosition(     bytes32 account,     bytes32 protocol,     bool unstake ) external override returns (bool) {     address payer = msg.sender;     Record memory position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);      IAddressProvider addressProvider_ = addressProvider;     address vault = addressProvider_.getStakerVault(position.depositToken); // will revert if vault does not exist     IStakerVault staker = IStakerVault(vault);     staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);     if (unstake) {         staker.unstake(position.depositTokenBalance);         IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);     } else {         staker.transfer(payer, position.depositTokenBalance);     }      _removePosition(payer, account, protocol);     addressProvider_.getGasBank().withdrawUnused(payer);     return true; }  /**  * @notice Execute top up handler update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @param protocol Protocol for which a new handler should be executed.  * @return Address of new handler.  */ function executeTopUpHandler(bytes32 protocol) external override returns (address) {     address oldHandler = _getHandler(protocol, false);     address newHandler = _executeAddress(_getProtocolKey(protocol));      _updateTopUpHandler(protocol, oldHandler, newHandler);     return newHandler; }  /**  * @notice Reset new top up handler deadline for a protocol.  * @param protocol Protocol for which top up handler deadline should be reset.  * @return `true` if successful.  */ function resetTopUpHandler(bytes32 protocol) external override onlyGovernance returns (bool) {     return _resetAddressConfig(_getProtocolKey(protocol)); }  /**  * @notice Prepare action fee update.  * @param newActionFee New fee to set.  * @return `true` if success.  */ function prepareActionFee(uint256 newActionFee)     external     override     onlyGovernance     returns (bool) {     require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);     return _prepare(_ACTION_FEE_KEY, newActionFee); }  /**  * @notice Execute action fee update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeActionFee() external override returns (uint256) {     return _executeUInt256(_ACTION_FEE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetActionFee() external override onlyGovernance returns (bool) {     return _resetUInt256Config(_ACTION_FEE_KEY); }  /** Set fee handler */ /**  * @notice Prepare update of fee handler.  * @param handler New fee handler.  * @return `true` if success.  */ function prepareFeeHandler(address handler) external override onlyGovernance returns (bool) {     return _prepare(_FEE_HANDLER_KEY, handler); }  /**  * @notice Execute update of fee handler (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeFeeHandler() external override returns (address) {     return _executeAddress(_FEE_HANDLER_KEY); }  /**  * @notice Reset the handler deadline.  * @return `true` if success.  */ function resetFeeHandler() external override onlyGovernance returns (bool) {     return _resetAddressConfig(_FEE_HANDLER_KEY); }  /**  * @notice Prepare update of estimated gas usage.  * @param gasUsage New estimated gas usage.  * @return `true` if success.  */ function prepareEstimatedGasUsage(uint256 gasUsage)     external     override     onlyGovernance     returns (bool) {     return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage); }  /**  * @notice Execute update of gas usage (with time delay enforced).  * @return `true` if successful.  */ function executeEstimatedGasUsage() external override returns (uint256) {     return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Reset the gas usage deadline.  * @return `true` if success.  */ function resetGasUsage() external override onlyGovernance returns (bool) {     return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Add a new deposit token that is supported by the action.  * @dev There is a separate check for whether the usable token (i.e. deposit token)  *      is swappable for some action token.  * @param token Address of deposit token that can be used by the action.  */ function addUsableToken(address token) external override onlyGovernance returns (bool) {     return _usableTokens.add(token); }  /**  * @notice Computes the total amount of ETH (as wei) required to pay for all  * the top-ups assuming the maximum gas price and the current estimated gas  * usage of a top-up  */ function getEthRequiredForGas(address payer) external view override returns (uint256) {     uint256 totalEthRequired;     RecordMeta[] memory userRecordsMeta = _userPositions[payer];     uint256 gasUsagePerCall = getEstimatedGasUsage();     uint256 length = userRecordsMeta.length;     for (uint256 i; i &lt; length; i = i.uncheckedInc()) {         RecordMeta memory meta = userRecordsMeta[i];         Record memory record = _positions[payer][meta.account][meta.protocol];         uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);         totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;     }     return totalEthRequired; }  /**  * @notice Returns a list of positions for the given payer  */ function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {     return _userPositions[payer]; }  /**  * @notice Get a list supported protocols.  * @return List of supported protocols.  */ function getSupportedProtocols() external view override returns (bytes32[] memory) {     uint256 length = _supportedProtocols.length();     bytes32[] memory protocols = new bytes32[](length);     for (uint256 i; i &lt; length; i = i.uncheckedInc()) {         protocols[i] = _supportedProtocols.at(i);     }     return protocols; }  /*  * @notice Gets a list of users that have an active position.  * @dev Uses cursor pagination.  * @param cursor The cursor for pagination (should start at 0 for first call).  * @param howMany Maximum number of users to return in this pagination request.  * @return users List of users that have an active position.  * @return nextCursor The cursor to use for the next pagination request.  */ function usersWithPositions(uint256 cursor, uint256 howMany)     external     view     override     returns (address[] memory users, uint256 nextCursor) {     uint256 length = _usersWithPositions.length();     if (cursor &gt;= length) return (new address[](0), 0);     if (howMany &gt;= length - cursor) {         howMany = length - cursor;     }      address[] memory usersWithPositions_ = new address[](howMany);     for (uint256 i; i &lt; howMany; i = i.uncheckedInc()) {         usersWithPositions_[i] = _usersWithPositions.at(i + cursor);     }      return (usersWithPositions_, cursor + howMany); }  /**  * @notice Get a list of all tokens usable for this action.  * @dev This refers to all tokens that can be used as deposit tokens.  * @return Array of addresses of usable tokens.  */ function getUsableTokens() external view override returns (address[] memory) {     return _usableTokens.toArray(); }  /**  * @notice Retrieves the topup handler for the given `protocol`  */ function getTopUpHandler(bytes32 protocol) external view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice Successfully tops up a position if it's conditions are met.  * @dev pool and vault funds are rebalanced after withdrawal for top up  * @param payer Account that pays for the top up.  * @param account Account owning the position for top up.  * @param beneficiary Address of the keeper's wallet for fee accrual.  * @param protocol Protocol of the top up position.  * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas  * @return `true` if successful.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol,     uint256 maxWeiForGas ) public override returns (bool) {     require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);      ExecuteLocalVars memory vars;      vars.initialGas = gasleft();      Record storage position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);     require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);     require(block.timestamp &gt; position.registeredAt, Error.CANNOT_EXECUTE_IN_SAME_BLOCK);      vars.topUpHandler = _getHandler(protocol, true);     vars.userFactor = ITopUpHandler(vars.topUpHandler).getUserFactor(account, position.extra);      // ensure that the position is actually below its set user factor threshold     require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);      IAddressProvider addressProvider_ = addressProvider;     IGasBank gasBank = addressProvider_.getGasBank();      // fail early if the user does not have enough funds in the gas bank     // to cover the cost of the transaction     vars.estimatedRequiredGas = getEstimatedGasUsage();     vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;      // compute the gas price that the user will be paying     vars.userGasPrice = block.basefee + position.priorityFee;     if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;     if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;      // ensure the current position allows for the gas to be paid     require(         vars.estimatedRequiredWeiForGas &lt;=             vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,         Error.ESTIMATED_GAS_TOO_HIGH     );      vars.gasBankBalance = gasBank.balanceOf(payer);     // ensure the user has enough funds in the gas bank to cover the gas     require(         vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,         Error.GAS_BANK_BALANCE_TOO_LOW     );      vars.totalTopUpAmount = position.totalTopUpAmount;     vars.actionFee = getActionFee();     // add top-up fees to top-up amount     vars.minActionAmountToTopUp = position.singleTopUpAmount;     vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(         ScaledMath.ONE + vars.actionFee     );      // if the amount that we want to top-up (including fees) is higher than     // the available topup amount, we lower this down to what is left of the position     if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {         vars.actionAmountWithFees = vars.totalTopUpAmount;         vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(             ScaledMath.ONE + vars.actionFee         );     }     ILiquidityPool pool = addressProvider_.getPoolForToken(position.depositToken);     vars.underlying = pool.getUnderlying();     vars.rate = pool.exchangeRate();      // compute the deposit tokens amount with and without fees     // we will need to unstake the amount with fees and to     // swap the amount without fees into action tokens     vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);     if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {         vars.depositAmountWithFees = position.depositTokenBalance;         vars.minActionAmountToTopUp =             (vars.depositAmountWithFees * vars.rate) /             (ScaledMath.ONE + vars.actionFee);     }      // compute amount of LP tokens needed to pay for action     // rate is expressed in actionToken per depositToken     vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);     vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;      // will revert if vault does not exist     address vault = addressProvider_.getStakerVault(position.depositToken);      // unstake deposit tokens including fees     IStakerVault(vault).unstake(vars.depositAmountWithFees);     IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);      // swap the amount without the fees     // as the fees are paid in deposit token, not in action token     vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);      // compute how much of action token was actually redeemed and add fees to it     // this is to ensure that no funds get locked inside the contract     vars.totalActionTokenAmount =         vars.actionTokenAmount +         vars.depositTotalFeesAmount.scaledMul(vars.rate);      // at this point, we have exactly `vars.actionTokenAmount`     // (at least `position.singleTopUpAmount`) of action token     // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract     // solhint-disable-next-line avoid-low-level-calls     uint256 value_;     if (position.actionToken == address(0)) {         value_ = vars.actionTokenAmount;     } else {         _approve(position.actionToken, vars.topUpHandler);     }     vars.topupResult = ITopUpHandler(vars.topUpHandler).topUp{value: value_}(         account,         position.actionToken,         vars.actionTokenAmount,         position.extra     );      require(vars.topupResult, Error.TOP_UP_FAILED);      // totalTopUpAmount is updated to reflect the new "balance" of the position     if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {         position.totalTopUpAmount -= vars.totalActionTokenAmount.toUint128();     } else {         position.totalTopUpAmount = 0;     }      position.depositTokenBalance -= vars.depositAmountWithFees.toUint128();      vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;     _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);     if (vars.removePosition) {         if (position.depositTokenBalance &gt; 0) {             // transfer any unused locked tokens to the payer             IStakerVault(vault).transfer(payer, position.depositTokenBalance);             IStakerVault(vault).decreaseActionLockedBalance(                 payer,                 position.depositTokenBalance             );         }         _removePosition(payer, account, protocol);     }      emit TopUp(         account,         protocol,         payer,         position.depositToken,         vars.depositAmountWithFees,         position.actionToken,         vars.actionTokenAmount     );      // compute gas used and reimburse the keeper by using the     // funds of payer in the gas bank     // TODO: add constant gas consumed for transfer and tx prologue     vars.gasConsumed = vars.initialGas - gasleft();      vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;     if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {         vars.reimbursedWeiForGas = vars.gasBankBalance;     }      // ensure that the keeper is not overpaying     vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;     require(         vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,         Error.GAS_TOO_HIGH     );     gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);     if (vars.removePosition) {         gasBank.withdrawUnused(payer);     }      return true; }  /**  * @notice Prepare new top up handler fee update.  * @dev Setting the address to 0 means that the protocol will no longer be supported.  * @param protocol Protocol for which a new handler should be prepared.  * @param newHandler Address of new handler.  * @return `true` if success.  */ function prepareTopUpHandler(bytes32 protocol, address newHandler)     public     override     onlyGovernance     returns (bool) {     return _prepare(_getProtocolKey(protocol), newHandler); }  /**  * @notice Check if action can be executed.  * @param protocol for which to get the health factor  * @param account for which to get the health factor  * @param extra data to be used by the topup handler  * @return healthFactor of the position  */ function getHealthFactor(     bytes32 protocol,     bytes32 account,     bytes calldata extra ) public view override returns (uint256 healthFactor) {     ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));     return topUpHandler.getUserFactor(account, extra); }  function getHandler(bytes32 protocol) public view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice returns the current estimated gas usage  */ function getEstimatedGasUsage() public view override returns (uint256) {     return currentUInts256[_ESTIMATED_GAS_USAGE_KEY]; }  /**  * @notice Returns the current action fee  */ function getActionFee() public view override returns (uint256) {     return currentUInts256[_ACTION_FEE_KEY]; }  /**  * @notice Returns the current fee handler  */ function getFeeHandler() public view override returns (address) {     return currentAddresses[_FEE_HANDLER_KEY]; }  /**  * @notice Get the record for a position.  * @param payer Registered payer of the position.  * @param account Address holding the position.  * @param protocol Protocol where the position is held.  */ function getPosition(     address payer,     bytes32 account,     bytes32 protocol ) public view override returns (Record memory) {     return _positions[payer][account][protocol]; }  /**  * @notice Check whether a token is usable as a deposit token.  * @param token Address of token to check.  * @return True if token is usable as a deposit token for this action.  */ function isUsable(address token) public view override returns (bool) {     return _usableTokens.contains(token); }  function _updateTopUpHandler(     bytes32 protocol,     address oldHandler,     address newHandler ) internal {     if (newHandler == address(0)) {         _supportedProtocols.remove(protocol);     } else if (oldHandler == address(0)) {         _supportedProtocols.add(protocol);     } }  /**  * @dev Pays fees to the feeHandler  * @param payer The account who's position the fees are charged on  * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)  * @param feeAmount The amount in tokens to pay as fees  * @param depositToken The LpToken used to pay the fees  */ function _payFees(     address payer,     address beneficiary,     uint256 feeAmount,     address depositToken ) internal {     address feeHandler = getFeeHandler();     IERC20(depositToken).safeApprove(feeHandler, feeAmount);     IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken); }  /**  * @dev "Locks" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function _lockFunds(     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) internal {     address stakerVaultAddress = addressProvider.getStakerVault(token);     TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount); }  function _removePosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     delete _positions[payer][account][protocol];     _removeUserPosition(payer, account, protocol);     if (_userPositions[payer].length == 0) {         _usersWithPositions.remove(payer);     }     emit Deregister(payer, account, protocol); }  function _removeUserPosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     RecordMeta[] storage positionsMeta = _userPositions[payer];     uint256 length = positionsMeta.length;     for (uint256 i; i &lt; length; i = i.uncheckedInc()) {         RecordMeta storage positionMeta = positionsMeta[i];         if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {             positionsMeta[i] = positionsMeta[length - 1];             positionsMeta.pop();             return;         }     } }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) internal {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the `actionToken`.  */ function _calcExchangeAmount(     address token,     address actionToken,     uint256 amount ) internal view returns (uint256) {     return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount); }  function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {     address handler = currentAddresses[_getProtocolKey(protocol)];     require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);     return handler; }  function _isSwappable(address depositToken, address toToken) internal view returns (bool) {     ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);     return pool.getUnderlying() == toToken; }  function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {     return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol)); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 12:29:54 INFO] Chief Executive Officer: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.10;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";
import "@openzeppelin/contracts/utils/math/SafeCast.sol";

import "../../../interfaces/IGasBank.sol";
import "../../../interfaces/pool/ILiquidityPool.sol";
import "../../../interfaces/IController.sol";
import "../../../interfaces/IStakerVault.sol";
import "../../../interfaces/actions/topup/ITopUpHandler.sol";
import "../../../interfaces/actions/topup/ITopUpAction.sol";
import "../../../interfaces/actions/IActionFeeHandler.sol";

import "../../../libraries/AddressProviderHelpers.sol";
import "../../../libraries/Errors.sol";
import "../../../libraries/ScaledMath.sol";
import "../../../libraries/EnumerableExtensions.sol";
import "../../../libraries/UncheckedMath.sol";

import "../../access/Authorization.sol";
import "../../utils/Preparable.sol";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param stakerVaultAddress The address of the staker vault
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > lockAmount ? lockAmount : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            _approve(token, stakerVaultAddress);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            lockAmount -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (lockAmount > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= lockAmount) {
                stakerVault.transferFrom(payer, address(this), lockAmount);
                stakerVault.increaseActionLockedBalance(payer, lockAmount);
                lockAmount = 0;
            }
        }

        require(lockAmount == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        require(underlying == actionToken, Error.TOKEN_NOT_USABLE);
        return amount.scaledDivRoundUp(rate);
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) private {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using UncheckedMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;
    using SafeCast for uint256;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being "too deep"
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
        address topUpHandler;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 550_000;

    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";
    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        for (uint256 i; i < protocols.length; i = i.uncheckedInc()) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount`, once converted to units of `actionToken`, must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param protocol Protocol which holds position to be topped up.
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable override returns (bool) {
        require(record.maxFee != 0, Error.INVALID_MAX_FEE);
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.registeredAt = uint64(block.timestamp);
        record.depositTokenBalance = totalLockAmount.toUint128();
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        IAddressProvider addressProvider_ = addressProvider;
        address vault = addressProvider_.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider_.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external override onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee)
        external
        override
        onlyGovernance
        returns (bool)
    {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external override onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external override onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external override onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage)
        external
        override
        onlyGovernance
        returns (bool)
    {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external override returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external override onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i; i < howMany; i = i.uncheckedInc()) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);
        require(block.timestamp > position.registeredAt, Error.CANNOT_EXECUTE_IN_SAME_BLOCK);

        vars.topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(vars.topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IAddressProvider addressProvider_ = addressProvider;
        IGasBank gasBank = addressProvider_.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider_.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider_.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        uint256 value_;
        if (position.actionToken == address(0)) {
            value_ = vars.actionTokenAmount;
        } else {
            _approve(position.actionToken, vars.topUpHandler);
        }
        vars.topupResult = ITopUpHandler(vars.topUpHandler).topUp{value: value_}(
            account,
            position.actionToken,
            vars.actionTokenAmount,
            position.extra
        );

        require(vars.topupResult, Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new "balance" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= vars.totalActionTokenAmount.toUint128();
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= vars.depositAmountWithFees.toUint128();

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the address to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        override
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes calldata extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view override returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the `actionToken`.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        return pool.getUnderlying() == toToken;
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
.]

We excel in generating innovative approaches and enhancements for Solidity smart contract code.

Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.10;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";
import "@openzeppelin/contracts/utils/math/SafeCast.sol";

import "../../../interfaces/IGasBank.sol";
import "../../../interfaces/pool/ILiquidityPool.sol";
import "../../../interfaces/IController.sol";
import "../../../interfaces/IStakerVault.sol";
import "../../../interfaces/actions/topup/ITopUpHandler.sol";
import "../../../interfaces/actions/topup/ITopUpAction.sol";
import "../../../interfaces/actions/IActionFeeHandler.sol";

import "../../../libraries/AddressProviderHelpers.sol";
import "../../../libraries/Errors.sol";
import "../../../libraries/ScaledMath.sol";
import "../../../libraries/EnumerableExtensions.sol";
import "../../../libraries/UncheckedMath.sol";

import "../../access/Authorization.sol";
import "../../utils/Preparable.sol";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param stakerVaultAddress The address of the staker vault
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > lockAmount ? lockAmount : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            _approve(token, stakerVaultAddress);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            lockAmount -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (lockAmount > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= lockAmount) {
                stakerVault.transferFrom(payer, address(this), lockAmount);
                stakerVault.increaseActionLockedBalance(payer, lockAmount);
                lockAmount = 0;
            }
        }

        require(lockAmount == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        require(underlying == actionToken, Error.TOKEN_NOT_USABLE);
        return amount.scaledDivRoundUp(rate);
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) private {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using UncheckedMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;
    using SafeCast for uint256;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being "too deep"
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
        address topUpHandler;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 550_000;

    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";
    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        for (uint256 i; i < protocols.length; i = i.uncheckedInc()) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount`, once converted to units of `actionToken`, must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param protocol Protocol which holds position to be topped up.
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable override returns (bool) {
        require(record.maxFee != 0, Error.INVALID_MAX_FEE);
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.registeredAt = uint64(block.timestamp);
        record.depositTokenBalance = totalLockAmount.toUint128();
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        IAddressProvider addressProvider_ = addressProvider;
        address vault = addressProvider_.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider_.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external override onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee)
        external
        override
        onlyGovernance
        returns (bool)
    {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external override onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external override onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external override onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage)
        external
        override
        onlyGovernance
        returns (bool)
    {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external override returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external override onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i; i < howMany; i = i.uncheckedInc()) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);
        require(block.timestamp > position.registeredAt, Error.CANNOT_EXECUTE_IN_SAME_BLOCK);

        vars.topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(vars.topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IAddressProvider addressProvider_ = addressProvider;
        IGasBank gasBank = addressProvider_.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider_.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider_.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        uint256 value_;
        if (position.actionToken == address(0)) {
            value_ = vars.actionTokenAmount;
        } else {
            _approve(position.actionToken, vars.topUpHandler);
        }
        vars.topupResult = ITopUpHandler(vars.topUpHandler).topUp{value: value_}(
            account,
            position.actionToken,
            vars.actionTokenAmount,
            position.extra
        );

        require(vars.topupResult, Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new "balance" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= vars.totalActionTokenAmount.toUint128();
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= vars.depositAmountWithFees.toUint128();

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the address to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        override
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes calldata extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view override returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the `actionToken`.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        return pool.getUnderlying() == toToken;
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
".

As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.

Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

[2024-01-09 12:30:03 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 12:30:03 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 15312
completion_tokens: 438
total_tokens: 15750
cost: $-1.000000


[2024-01-09 12:30:03 INFO] Security Analyst: **Security Analyst<->Chief Executive Officer on : ContractAnalysis, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.10;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";
import "@openzeppelin/contracts/utils/math/SafeCast.sol";

import "../../../interfaces/IGasBank.sol";
import "../../../interfaces/pool/ILiquidityPool.sol";
import "../../../interfaces/IController.sol";
import "../../../interfaces/IStakerVault.sol";
import "../../../interfaces/actions/topup/ITopUpHandler.sol";
import "../../../interfaces/actions/topup/ITopUpAction.sol";
import "../../../interfaces/actions/IActionFeeHandler.sol";

import "../../../libraries/AddressProviderHelpers.sol";
import "../../../libraries/Errors.sol";
import "../../../libraries/ScaledMath.sol";
import "../../../libraries/EnumerableExtensions.sol";
import "../../../libraries/UncheckedMath.sol";

import "../../access/Authorization.sol";
import "../../utils/Preparable.sol";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param stakerVaultAddress The address of the staker vault
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > lockAmount ? lockAmount : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            _approve(token, stakerVaultAddress);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            lockAmount -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (lockAmount > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= lockAmount) {
                stakerVault.transferFrom(payer, address(this), lockAmount);
                stakerVault.increaseActionLockedBalance(payer, lockAmount);
                lockAmount = 0;
            }
        }

        require(lockAmount == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        require(underlying == actionToken, Error.TOKEN_NOT_USABLE);
        return amount.scaledDivRoundUp(rate);
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) private {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using UncheckedMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;
    using SafeCast for uint256;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being "too deep"
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
        address topUpHandler;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 550_000;

    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";
    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        for (uint256 i; i < protocols.length; i = i.uncheckedInc()) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount`, once converted to units of `actionToken`, must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param protocol Protocol which holds position to be topped up.
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable override returns (bool) {
        require(record.maxFee != 0, Error.INVALID_MAX_FEE);
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.registeredAt = uint64(block.timestamp);
        record.depositTokenBalance = totalLockAmount.toUint128();
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        IAddressProvider addressProvider_ = addressProvider;
        address vault = addressProvider_.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider_.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external override onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee)
        external
        override
        onlyGovernance
        returns (bool)
    {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external override onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external override onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external override onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage)
        external
        override
        onlyGovernance
        returns (bool)
    {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external override returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external override onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i; i < howMany; i = i.uncheckedInc()) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);
        require(block.timestamp > position.registeredAt, Error.CANNOT_EXECUTE_IN_SAME_BLOCK);

        vars.topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(vars.topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IAddressProvider addressProvider_ = addressProvider;
        IGasBank gasBank = addressProvider_.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider_.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider_.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        uint256 value_;
        if (position.actionToken == address(0)) {
            value_ = vars.actionTokenAmount;
        } else {
            _approve(position.actionToken, vars.topUpHandler);
        }
        vars.topupResult = ITopUpHandler(vars.topUpHandler).topUp{value: value_}(
            account,
            position.actionToken,
            vars.actionTokenAmount,
            position.extra
        );

        require(vars.topupResult, Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new "balance" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= vars.totalActionTokenAmount.toUint128();
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= vars.depositAmountWithFees.toUint128();

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the address to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        override
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes calldata extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view override returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the `actionToken`.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        return pool.getUnderlying() == toToken;
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
.]

Let's analyze the provided Solidity contract code and identify potential improvements or enhancements.

1. **Gas Optimization**: The contract has several places where gas consumption could be reduced. For example, in the `execute` function, the calculation of `vars.estimatedRequiredWeiForGas` and `vars.userGasPrice` could be optimized to avoid redundant calculations. We could also consider caching frequently accessed values to minimize storage reads.

2. **Error Handling**: The contract uses require statements for error handling, which is good, but we could enhance the error messages to provide more context. This would help in debugging and understanding the failure points better.

3. **Reentrancy Guard**: Although the contract uses SafeERC20 for token transfers, we should consider implementing a reentrancy guard on critical functions like `execute` and `register`. This would prevent potential reentrancy attacks, especially since the contract interacts with external contracts.

4. **Event Emission**: The contract emits events for significant actions, but we could enhance this by adding more events for actions like `resetPosition` and `prepareTopUpHandler`. This would improve transparency and allow for better tracking of contract interactions.

5. **Access Control**: The contract uses a governance mechanism for certain functions. We could consider implementing a multi-signature wallet for critical functions to enhance security and ensure that no single entity has control over significant actions.

6. **Upgradeability**: Since the contract uses OpenZeppelin's Initializable, we should ensure that all upgradeable patterns are followed correctly. It might be beneficial to include a function to pause the contract in emergencies, which can be controlled by governance.

7. **Testing and Auditing**: While this is more of a process improvement, ensuring that the contract undergoes thorough testing, including unit tests and integration tests, is crucial. Additionally, a third-party audit would provide an extra layer of security assurance.

8. **Documentation**: Improving inline documentation and comments throughout the code would help future developers understand the logic and purpose of various functions and variables.

Which of these suggestions resonates most with you, or do you have any other specific areas you would like to focus on?

[2024-01-09 12:30:03 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.10; import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol"; import "@openzeppelin/contracts/utils/math/SafeCast.sol"; import "../../../interfaces/IGasBank.sol"; import "../../../interfaces/pool/ILiquidityPool.sol"; import "../../../interfaces/IController.sol"; import "../../../interfaces/IStakerVault.sol"; import "../../../interfaces/actions/topup/ITopUpHandler.sol"; import "../../../interfaces/actions/topup/ITopUpAction.sol"; import "../../../interfaces/actions/IActionFeeHandler.sol"; import "../../../libraries/AddressProviderHelpers.sol"; import "../../../libraries/Errors.sol"; import "../../../libraries/ScaledMath.sol"; import "../../../libraries/EnumerableExtensions.sol"; import "../../../libraries/UncheckedMath.sol"; import "../../access/Authorization.sol"; import "../../utils/Preparable.sol"; /*  * @notice The logic here should really be part of the top-up action  * but is split in a library to circumvent the byte-code size limit  / library TopUpActionLibrary {     using SafeERC20 for IERC20;     using ScaledMath for uint256;     using AddressProviderHelpers for IAddressProvider; /**  * @dev "Locks" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param stakerVaultAddress The address of the staker vault  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function lockFunds(     address stakerVaultAddress,     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) external {     IStakerVault stakerVault = IStakerVault(stakerVaultAddress);      // stake deposit amount     if (depositAmount &gt; 0) {         depositAmount = depositAmount &gt; lockAmount ? lockAmount : depositAmount;         IERC20(token).safeTransferFrom(payer, address(this), depositAmount);         _approve(token, stakerVaultAddress);         stakerVault.stake(depositAmount);         stakerVault.increaseActionLockedBalance(payer, depositAmount);         lockAmount -= depositAmount;     }      // use stake vault allowance if available and required     if (lockAmount &gt; 0) {         uint256 balance = stakerVault.balanceOf(payer);         uint256 allowance = stakerVault.allowance(payer, address(this));         uint256 availableFunds = balance &lt; allowance ? balance : allowance;         if (availableFunds &gt;= lockAmount) {             stakerVault.transferFrom(payer, address(this), lockAmount);             stakerVault.increaseActionLockedBalance(payer, lockAmount);             lockAmount = 0;         }     }      require(lockAmount == 0, Error.INSUFFICIENT_UPDATE_BALANCE); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function calcExchangeAmount(     IAddressProvider addressProvider,     address token,     address actionToken,     uint256 amount ) external view returns (uint256) {     ILiquidityPool pool = addressProvider.getPoolForToken(token);     uint256 rate = pool.exchangeRate();     address underlying = pool.getUnderlying();     require(underlying == actionToken, Error.TOKEN_NOT_USABLE);     return amount.scaledDivRoundUp(rate); }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) private {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  } contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {     using ScaledMath for uint256;     using UncheckedMath for uint256;     using ScaledMath for uint128;     using SafeERC20 for IERC20;     using EnumerableSet for EnumerableSet.AddressSet;     using EnumerableSet for EnumerableSet.Bytes32Set;     using EnumerableExtensions for EnumerableSet.AddressSet;     using AddressProviderHelpers for IAddressProvider;     using SafeCast for uint256; /**  * @dev Temporary struct to hold local variables in execute  * and avoid the stack being "too deep"  */ struct ExecuteLocalVars {     uint256 minActionAmountToTopUp;     uint256 actionTokenAmount;     uint256 depositTotalFeesAmount;     uint256 actionAmountWithFees;     uint256 userFactor;     uint256 rate;     uint256 depositAmountWithFees;     uint256 depositAmountWithoutFees;     uint256 actionFee;     uint256 totalActionTokenAmount;     uint128 totalTopUpAmount;     bool topupResult;     uint256 gasBankBalance;     uint256 initialGas;     uint256 gasConsumed;     uint256 userGasPrice;     uint256 estimatedRequiredGas;     uint256 estimatedRequiredWeiForGas;     uint256 requiredWeiForGas;     uint256 reimbursedWeiForGas;     address underlying;     bool removePosition;     address topUpHandler; }  EnumerableSet.AddressSet private _usableTokens;  uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 550_000;  bytes32 internal constant _ACTION_FEE_KEY = "ActionFee"; bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler"; bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler"; bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";  uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;  IController public immutable controller; IAddressProvider public immutable addressProvider;  EnumerableSet.Bytes32Set internal _supportedProtocols;  /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record) mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;  mapping(address =&gt; RecordMeta[]) internal _userPositions;  EnumerableSet.AddressSet internal _usersWithPositions;  constructor(IController _controller)     Authorization(_controller.addressProvider().getRoleManager()) {     controller = _controller;     addressProvider = controller.addressProvider();     _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE); }  receive() external payable {     // solhint-disable-previous-line no-empty-blocks }  function initialize(     address feeHandler,     bytes32[] calldata protocols,     address[] calldata handlers ) external initializer onlyGovernance {     require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);     _setConfig(_FEE_HANDLER_KEY, feeHandler);     for (uint256 i; i &lt; protocols.length; i = i.uncheckedInc()) {         bytes32 protocolKey = _getProtocolKey(protocols[i]);         _setConfig(protocolKey, handlers[i]);         _updateTopUpHandler(protocols[i], address(0), handlers[i]);     } }  /**  * @notice Register a top up action.  * @dev The `depositAmount`, once converted to units of `actionToken`, must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).  * @param account Account to be topped up (first 20 bytes will typically be the address).  * @param protocol Protocol which holds position to be topped up.  * @param depositAmount Amount of `depositToken` that will be locked.  * @param record containing the data for the position to register  */ function register(     bytes32 account,     bytes32 protocol,     uint128 depositAmount,     Record memory record ) external payable override returns (bool) {     require(record.maxFee != 0, Error.INVALID_MAX_FEE);     require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);     require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);     require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);     require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);     require(         _positions[msg.sender][account][protocol].threshold == 0,         Error.POSITION_ALREADY_EXISTS     );     require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);     require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);      uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *         record.maxFee *         getEstimatedGasUsage();      require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);      uint256 totalLockAmount = _calcExchangeAmount(         record.depositToken,         record.actionToken,         record.totalTopUpAmount     );     _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);      addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);      record.registeredAt = uint64(block.timestamp);     record.depositTokenBalance = totalLockAmount.toUint128();     _positions[msg.sender][account][protocol] = record;     _userPositions[msg.sender].push(RecordMeta(account, protocol));     _usersWithPositions.add(msg.sender);      emit Register(         account,         protocol,         record.threshold,         msg.sender,         record.depositToken,         totalLockAmount,         record.actionToken,         record.singleTopUpAmount,         record.totalTopUpAmount,         record.maxFee,         record.extra     );     return true; }  /**  * @notice See overloaded version of `execute` for more details.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol ) external override returns (bool) {     return execute(payer, account, beneficiary, protocol, 0); }  /**  * @notice Delete a position to back on the given protocol for `account`.  * @param account Account holding the position.  * @param protocol Protocol the position is held on.  * @param unstake If the tokens should be unstaked from vault.  * @return `true` if successful.  */ function resetPosition(     bytes32 account,     bytes32 protocol,     bool unstake ) external override returns (bool) {     address payer = msg.sender;     Record memory position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);      IAddressProvider addressProvider_ = addressProvider;     address vault = addressProvider_.getStakerVault(position.depositToken); // will revert if vault does not exist     IStakerVault staker = IStakerVault(vault);     staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);     if (unstake) {         staker.unstake(position.depositTokenBalance);         IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);     } else {         staker.transfer(payer, position.depositTokenBalance);     }      _removePosition(payer, account, protocol);     addressProvider_.getGasBank().withdrawUnused(payer);     return true; }  /**  * @notice Execute top up handler update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @param protocol Protocol for which a new handler should be executed.  * @return Address of new handler.  */ function executeTopUpHandler(bytes32 protocol) external override returns (address) {     address oldHandler = _getHandler(protocol, false);     address newHandler = _executeAddress(_getProtocolKey(protocol));      _updateTopUpHandler(protocol, oldHandler, newHandler);     return newHandler; }  /**  * @notice Reset new top up handler deadline for a protocol.  * @param protocol Protocol for which top up handler deadline should be reset.  * @return `true` if successful.  */ function resetTopUpHandler(bytes32 protocol) external override onlyGovernance returns (bool) {     return _resetAddressConfig(_getProtocolKey(protocol)); }  /**  * @notice Prepare action fee update.  * @param newActionFee New fee to set.  * @return `true` if success.  */ function prepareActionFee(uint256 newActionFee)     external     override     onlyGovernance     returns (bool) {     require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);     return _prepare(_ACTION_FEE_KEY, newActionFee); }  /**  * @notice Execute action fee update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeActionFee() external override returns (uint256) {     return _executeUInt256(_ACTION_FEE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetActionFee() external override onlyGovernance returns (bool) {     return _resetUInt256Config(_ACTION_FEE_KEY); }  /** Set fee handler */ /**  * @notice Prepare update of fee handler.  * @param handler New fee handler.  * @return `true` if success.  */ function prepareFeeHandler(address handler) external override onlyGovernance returns (bool) {     return _prepare(_FEE_HANDLER_KEY, handler); }  /**  * @notice Execute update of fee handler (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeFeeHandler() external override returns (address) {     return _executeAddress(_FEE_HANDLER_KEY); }  /**  * @notice Reset the handler deadline.  * @return `true` if success.  */ function resetFeeHandler() external override onlyGovernance returns (bool) {     return _resetAddressConfig(_FEE_HANDLER_KEY); }  /**  * @notice Prepare update of estimated gas usage.  * @param gasUsage New estimated gas usage.  * @return `true` if success.  */ function prepareEstimatedGasUsage(uint256 gasUsage)     external     override     onlyGovernance     returns (bool) {     return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage); }  /**  * @notice Execute update of gas usage (with time delay enforced).  * @return `true` if successful.  */ function executeEstimatedGasUsage() external override returns (uint256) {     return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Reset the gas usage deadline.  * @return `true` if success.  */ function resetGasUsage() external override onlyGovernance returns (bool) {     return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Add a new deposit token that is supported by the action.  * @dev There is a separate check for whether the usable token (i.e. deposit token)  *      is swappable for some action token.  * @param token Address of deposit token that can be used by the action.  */ function addUsableToken(address token) external override onlyGovernance returns (bool) {     return _usableTokens.add(token); }  /**  * @notice Computes the total amount of ETH (as wei) required to pay for all  * the top-ups assuming the maximum gas price and the current estimated gas  * usage of a top-up  */ function getEthRequiredForGas(address payer) external view override returns (uint256) {     uint256 totalEthRequired;     RecordMeta[] memory userRecordsMeta = _userPositions[payer];     uint256 gasUsagePerCall = getEstimatedGasUsage();     uint256 length = userRecordsMeta.length;     for (uint256 i; i &lt; length; i = i.uncheckedInc()) {         RecordMeta memory meta = userRecordsMeta[i];         Record memory record = _positions[payer][meta.account][meta.protocol];         uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);         totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;     }     return totalEthRequired; }  /**  * @notice Returns a list of positions for the given payer  */ function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {     return _userPositions[payer]; }  /**  * @notice Get a list supported protocols.  * @return List of supported protocols.  */ function getSupportedProtocols() external view override returns (bytes32[] memory) {     uint256 length = _supportedProtocols.length();     bytes32[] memory protocols = new bytes32[](length);     for (uint256 i; i &lt; length; i = i.uncheckedInc()) {         protocols[i] = _supportedProtocols.at(i);     }     return protocols; }  /*  * @notice Gets a list of users that have an active position.  * @dev Uses cursor pagination.  * @param cursor The cursor for pagination (should start at 0 for first call).  * @param howMany Maximum number of users to return in this pagination request.  * @return users List of users that have an active position.  * @return nextCursor The cursor to use for the next pagination request.  */ function usersWithPositions(uint256 cursor, uint256 howMany)     external     view     override     returns (address[] memory users, uint256 nextCursor) {     uint256 length = _usersWithPositions.length();     if (cursor &gt;= length) return (new address[](0), 0);     if (howMany &gt;= length - cursor) {         howMany = length - cursor;     }      address[] memory usersWithPositions_ = new address[](howMany);     for (uint256 i; i &lt; howMany; i = i.uncheckedInc()) {         usersWithPositions_[i] = _usersWithPositions.at(i + cursor);     }      return (usersWithPositions_, cursor + howMany); }  /**  * @notice Get a list of all tokens usable for this action.  * @dev This refers to all tokens that can be used as deposit tokens.  * @return Array of addresses of usable tokens.  */ function getUsableTokens() external view override returns (address[] memory) {     return _usableTokens.toArray(); }  /**  * @notice Retrieves the topup handler for the given `protocol`  */ function getTopUpHandler(bytes32 protocol) external view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice Successfully tops up a position if it's conditions are met.  * @dev pool and vault funds are rebalanced after withdrawal for top up  * @param payer Account that pays for the top up.  * @param account Account owning the position for top up.  * @param beneficiary Address of the keeper's wallet for fee accrual.  * @param protocol Protocol of the top up position.  * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas  * @return `true` if successful.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol,     uint256 maxWeiForGas ) public override returns (bool) {     require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);      ExecuteLocalVars memory vars;      vars.initialGas = gasleft();      Record storage position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);     require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);     require(block.timestamp &gt; position.registeredAt, Error.CANNOT_EXECUTE_IN_SAME_BLOCK);      vars.topUpHandler = _getHandler(protocol, true);     vars.userFactor = ITopUpHandler(vars.topUpHandler).getUserFactor(account, position.extra);      // ensure that the position is actually below its set user factor threshold     require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);      IAddressProvider addressProvider_ = addressProvider;     IGasBank gasBank = addressProvider_.getGasBank();      // fail early if the user does not have enough funds in the gas bank     // to cover the cost of the transaction     vars.estimatedRequiredGas = getEstimatedGasUsage();     vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;      // compute the gas price that the user will be paying     vars.userGasPrice = block.basefee + position.priorityFee;     if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;     if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;      // ensure the current position allows for the gas to be paid     require(         vars.estimatedRequiredWeiForGas &lt;=             vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,         Error.ESTIMATED_GAS_TOO_HIGH     );      vars.gasBankBalance = gasBank.balanceOf(payer);     // ensure the user has enough funds in the gas bank to cover the gas     require(         vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,         Error.GAS_BANK_BALANCE_TOO_LOW     );      vars.totalTopUpAmount = position.totalTopUpAmount;     vars.actionFee = getActionFee();     // add top-up fees to top-up amount     vars.minActionAmountToTopUp = position.singleTopUpAmount;     vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(         ScaledMath.ONE + vars.actionFee     );      // if the amount that we want to top-up (including fees) is higher than     // the available topup amount, we lower this down to what is left of the position     if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {         vars.actionAmountWithFees = vars.totalTopUpAmount;         vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(             ScaledMath.ONE + vars.actionFee         );     }     ILiquidityPool pool = addressProvider_.getPoolForToken(position.depositToken);     vars.underlying = pool.getUnderlying();     vars.rate = pool.exchangeRate();      // compute the deposit tokens amount with and without fees     // we will need to unstake the amount with fees and to     // swap the amount without fees into action tokens     vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);     if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {         vars.depositAmountWithFees = position.depositTokenBalance;         vars.minActionAmountToTopUp =             (vars.depositAmountWithFees * vars.rate) /             (ScaledMath.ONE + vars.actionFee);     }      // compute amount of LP tokens needed to pay for action     // rate is expressed in actionToken per depositToken     vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);     vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;      // will revert if vault does not exist     address vault = addressProvider_.getStakerVault(position.depositToken);      // unstake deposit tokens including fees     IStakerVault(vault).unstake(vars.depositAmountWithFees);     IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);      // swap the amount without the fees     // as the fees are paid in deposit token, not in action token     vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);      // compute how much of action token was actually redeemed and add fees to it     // this is to ensure that no funds get locked inside the contract     vars.totalActionTokenAmount =         vars.actionTokenAmount +         vars.depositTotalFeesAmount.scaledMul(vars.rate);      // at this point, we have exactly `vars.actionTokenAmount`     // (at least `position.singleTopUpAmount`) of action token     // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract     // solhint-disable-next-line avoid-low-level-calls     uint256 value_;     if (position.actionToken == address(0)) {         value_ = vars.actionTokenAmount;     } else {         _approve(position.actionToken, vars.topUpHandler);     }     vars.topupResult = ITopUpHandler(vars.topUpHandler).topUp{value: value_}(         account,         position.actionToken,         vars.actionTokenAmount,         position.extra     );      require(vars.topupResult, Error.TOP_UP_FAILED);      // totalTopUpAmount is updated to reflect the new "balance" of the position     if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {         position.totalTopUpAmount -= vars.totalActionTokenAmount.toUint128();     } else {         position.totalTopUpAmount = 0;     }      position.depositTokenBalance -= vars.depositAmountWithFees.toUint128();      vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;     _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);     if (vars.removePosition) {         if (position.depositTokenBalance &gt; 0) {             // transfer any unused locked tokens to the payer             IStakerVault(vault).transfer(payer, position.depositTokenBalance);             IStakerVault(vault).decreaseActionLockedBalance(                 payer,                 position.depositTokenBalance             );         }         _removePosition(payer, account, protocol);     }      emit TopUp(         account,         protocol,         payer,         position.depositToken,         vars.depositAmountWithFees,         position.actionToken,         vars.actionTokenAmount     );      // compute gas used and reimburse the keeper by using the     // funds of payer in the gas bank     // TODO: add constant gas consumed for transfer and tx prologue     vars.gasConsumed = vars.initialGas - gasleft();      vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;     if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {         vars.reimbursedWeiForGas = vars.gasBankBalance;     }      // ensure that the keeper is not overpaying     vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;     require(         vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,         Error.GAS_TOO_HIGH     );     gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);     if (vars.removePosition) {         gasBank.withdrawUnused(payer);     }      return true; }  /**  * @notice Prepare new top up handler fee update.  * @dev Setting the address to 0 means that the protocol will no longer be supported.  * @param protocol Protocol for which a new handler should be prepared.  * @param newHandler Address of new handler.  * @return `true` if success.  */ function prepareTopUpHandler(bytes32 protocol, address newHandler)     public     override     onlyGovernance     returns (bool) {     return _prepare(_getProtocolKey(protocol), newHandler); }  /**  * @notice Check if action can be executed.  * @param protocol for which to get the health factor  * @param account for which to get the health factor  * @param extra data to be used by the topup handler  * @return healthFactor of the position  */ function getHealthFactor(     bytes32 protocol,     bytes32 account,     bytes calldata extra ) public view override returns (uint256 healthFactor) {     ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));     return topUpHandler.getUserFactor(account, extra); }  function getHandler(bytes32 protocol) public view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice returns the current estimated gas usage  */ function getEstimatedGasUsage() public view override returns (uint256) {     return currentUInts256[_ESTIMATED_GAS_USAGE_KEY]; }  /**  * @notice Returns the current action fee  */ function getActionFee() public view override returns (uint256) {     return currentUInts256[_ACTION_FEE_KEY]; }  /**  * @notice Returns the current fee handler  */ function getFeeHandler() public view override returns (address) {     return currentAddresses[_FEE_HANDLER_KEY]; }  /**  * @notice Get the record for a position.  * @param payer Registered payer of the position.  * @param account Address holding the position.  * @param protocol Protocol where the position is held.  */ function getPosition(     address payer,     bytes32 account,     bytes32 protocol ) public view override returns (Record memory) {     return _positions[payer][account][protocol]; }  /**  * @notice Check whether a token is usable as a deposit token.  * @param token Address of token to check.  * @return True if token is usable as a deposit token for this action.  */ function isUsable(address token) public view override returns (bool) {     return _usableTokens.contains(token); }  function _updateTopUpHandler(     bytes32 protocol,     address oldHandler,     address newHandler ) internal {     if (newHandler == address(0)) {         _supportedProtocols.remove(protocol);     } else if (oldHandler == address(0)) {         _supportedProtocols.add(protocol);     } }  /**  * @dev Pays fees to the feeHandler  * @param payer The account who's position the fees are charged on  * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)  * @param feeAmount The amount in tokens to pay as fees  * @param depositToken The LpToken used to pay the fees  */ function _payFees(     address payer,     address beneficiary,     uint256 feeAmount,     address depositToken ) internal {     address feeHandler = getFeeHandler();     IERC20(depositToken).safeApprove(feeHandler, feeAmount);     IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken); }  /**  * @dev "Locks" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function _lockFunds(     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) internal {     address stakerVaultAddress = addressProvider.getStakerVault(token);     TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount); }  function _removePosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     delete _positions[payer][account][protocol];     _removeUserPosition(payer, account, protocol);     if (_userPositions[payer].length == 0) {         _usersWithPositions.remove(payer);     }     emit Deregister(payer, account, protocol); }  function _removeUserPosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     RecordMeta[] storage positionsMeta = _userPositions[payer];     uint256 length = positionsMeta.length;     for (uint256 i; i &lt; length; i = i.uncheckedInc()) {         RecordMeta storage positionMeta = positionsMeta[i];         if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {             positionsMeta[i] = positionsMeta[length - 1];             positionsMeta.pop();             return;         }     } }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) internal {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the `actionToken`.  */ function _calcExchangeAmount(     address token,     address actionToken,     uint256 amount ) internal view returns (uint256) {     return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount); }  function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {     address handler = currentAddresses[_getProtocolKey(protocol)];     require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);     return handler; }  function _isSwappable(address depositToken, address toToken) internal view returns (bool) {     ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);     return pool.getUnderlying() == toToken; }  function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {     return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol)); }  } |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **phase_prompt** | Here is a conversation between two roles: {conversations} {question} |
| **phase_name** | Reflection |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **placeholders** | {'conversations': 'Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.\nYou are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.\nYou can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites\nHere is a new customer\'s task: // SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\nimport "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";\nimport "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\nimport "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";\nimport "@openzeppelin/contracts/utils/math/SafeCast.sol";\nimport "../../../interfaces/IGasBank.sol";\nimport "../../../interfaces/pool/ILiquidityPool.sol";\nimport "../../../interfaces/IController.sol";\nimport "../../../interfaces/IStakerVault.sol";\nimport "../../../interfaces/actions/topup/ITopUpHandler.sol";\nimport "../../../interfaces/actions/topup/ITopUpAction.sol";\nimport "../../../interfaces/actions/IActionFeeHandler.sol";\nimport "../../../libraries/AddressProviderHelpers.sol";\nimport "../../../libraries/Errors.sol";\nimport "../../../libraries/ScaledMath.sol";\nimport "../../../libraries/EnumerableExtensions.sol";\nimport "../../../libraries/UncheckedMath.sol";\nimport "../../access/Authorization.sol";\nimport "../../utils/Preparable.sol";\n/\n * @notice The logic here should really be part of the top-up action\n * but is split in a library to circumvent the byte-code size limit\n */\nlibrary TopUpActionLibrary {\n    using SafeERC20 for IERC20;\n    using ScaledMath for uint256;\n    using AddressProviderHelpers for IAddressProvider;\n    /\n     * @dev "Locks" an amount of tokens on behalf of the TopUpAction\n     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.\n     * @param stakerVaultAddress The address of the staker vault\n     * @param payer Owner of the funds to be locked\n     * @param token Token to lock\n     * @param lockAmount Minimum amount of token to lock\n     * @param depositAmount Amount of token that was deposited.\n     *                      If this is 0 then the staker vault allowance should be used.\n     *                      If this is greater than requiredAmount more tokens will be locked.\n     /\n    function lockFunds(\n        address stakerVaultAddress,\n        address payer,\n        address token,\n        uint256 lockAmount,\n        uint256 depositAmount\n    ) external {\n        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);\n        // stake deposit amount\n        if (depositAmount &gt; 0) {\n            depositAmount = depositAmount &gt; lockAmount ? lockAmount : depositAmount;\n            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);\n            _approve(token, stakerVaultAddress);\n            stakerVault.stake(depositAmount);\n            stakerVault.increaseActionLockedBalance(payer, depositAmount);\n            lockAmount -= depositAmount;\n        }\n        // use stake vault allowance if available and required\n        if (lockAmount &gt; 0) {\n            uint256 balance = stakerVault.balanceOf(payer);\n            uint256 allowance = stakerVault.allowance(payer, address(this));\n            uint256 availableFunds = balance &lt; allowance ? balance : allowance;\n            if (availableFunds &gt;= lockAmount) {\n                stakerVault.transferFrom(payer, address(this), lockAmount);\n                stakerVault.increaseActionLockedBalance(payer, lockAmount);\n                lockAmount = 0;\n            }\n        }\n        require(lockAmount == 0, Error.INSUFFICIENT_UPDATE_BALANCE);\n    }\n    /\n     * @dev Computes and returns the amount of LP tokens of type token that will be received in exchange for an amount of the underlying.\n     /\n    function calcExchangeAmount(\n        IAddressProvider addressProvider,\n        address token,\n        address actionToken,\n        uint256 amount\n    ) external view returns (uint256) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(token);\n        uint256 rate = pool.exchangeRate();\n        address underlying = pool.getUnderlying();\n        require(underlying == actionToken, Error.TOKEN_NOT_USABLE);\n        return amount.scaledDivRoundUp(rate);\n    }\n    /\n     * @dev Approves infinite spending for the given spender.\n     * @param token The token to approve for.\n     * @param spender The spender to approve.\n     */\n    function _approve(address token, address spender) private {\n        if (IERC20(token).allowance(address(this), spender) &gt; 0) return;\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n}\ncontract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {\n    using ScaledMath for uint256;\n    using UncheckedMath for uint256;\n    using ScaledMath for uint128;\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using EnumerableExtensions for EnumerableSet.AddressSet;\n    using AddressProviderHelpers for IAddressProvider;\n    using SafeCast for uint256;\n    /\n     * @dev Temporary struct to hold local variables in execute\n     * and avoid the stack being "too deep"\n     /\n    struct ExecuteLocalVars {\n        uint256 minActionAmountToTopUp;\n        uint256 actionTokenAmount;\n        uint256 depositTotalFeesAmount;\n        uint256 actionAmountWithFees;\n        uint256 userFactor;\n        uint256 rate;\n        uint256 depositAmountWithFees;\n        uint256 depositAmountWithoutFees;\n        uint256 actionFee;\n        uint256 totalActionTokenAmount;\n        uint128 totalTopUpAmount;\n        bool topupResult;\n        uint256 gasBankBalance;\n        uint256 initialGas;\n        uint256 gasConsumed;\n        uint256 userGasPrice;\n        uint256 estimatedRequiredGas;\n        uint256 estimatedRequiredWeiForGas;\n        uint256 requiredWeiForGas;\n        uint256 reimbursedWeiForGas;\n        address underlying;\n        bool removePosition;\n        address topUpHandler;\n    }\n    EnumerableSet.AddressSet private _usableTokens;\n    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 550_000;\n    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";\n    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";\n    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";\n    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";\n    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;\n    IController public immutable controller;\n    IAddressProvider public immutable addressProvider;\n    EnumerableSet.Bytes32Set internal _supportedProtocols;\n    /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record)\n    mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;\n    mapping(address =&gt; RecordMeta[]) internal _userPositions;\n    EnumerableSet.AddressSet internal _usersWithPositions;\n    constructor(IController _controller)\n        Authorization(_controller.addressProvider().getRoleManager())\n    {\n        controller = _controller;\n        addressProvider = controller.addressProvider();\n        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);\n    }\n    receive() external payable {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n    function initialize(\n        address feeHandler,\n        bytes32[] calldata protocols,\n        address[] calldata handlers\n    ) external initializer onlyGovernance {\n        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);\n        _setConfig(_FEE_HANDLER_KEY, feeHandler);\n        for (uint256 i; i &lt; protocols.length; i = i.uncheckedInc()) {\n            bytes32 protocolKey = _getProtocolKey(protocols[i]);\n            _setConfig(protocolKey, handlers[i]);\n            _updateTopUpHandler(protocols[i], address(0), handlers[i]);\n        }\n    }\n    /\n     * @notice Register a top up action.\n     * @dev The depositAmount, once converted to units of actionToken, must be greater or equal to the totalTopUpAmount (which is denominated in actionToken).\n     * @param account Account to be topped up (first 20 bytes will typically be the address).\n     * @param protocol Protocol which holds position to be topped up.\n     * @param depositAmount Amount of depositToken that will be locked.\n     * @param record containing the data for the position to register\n     /\n    function register(\n        bytes32 account,\n        bytes32 protocol,\n        uint128 depositAmount,\n        Record memory record\n    ) external payable override returns (bool) {\n        require(record.maxFee != 0, Error.INVALID_MAX_FEE);\n        require(supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);\n        require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);\n        require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);\n        require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);\n        require(\n            _positions[msg.sender][account][protocol].threshold == 0,\n            Error.POSITION_ALREADY_EXISTS\n        );\n        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);\n        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);\n        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) \n            record.maxFee \n            getEstimatedGasUsage();\n        require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);\n        uint256 totalLockAmount = _calcExchangeAmount(\n            record.depositToken,\n            record.actionToken,\n            record.totalTopUpAmount\n        );\n        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);\n        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);\n        record.registeredAt = uint64(block.timestamp);\n        record.depositTokenBalance = totalLockAmount.toUint128();\n        _positions[msg.sender][account][protocol] = record;\n        _userPositions[msg.sender].push(RecordMeta(account, protocol));\n        _usersWithPositions.add(msg.sender);\n        emit Register(\n            account,\n            protocol,\n            record.threshold,\n            msg.sender,\n            record.depositToken,\n            totalLockAmount,\n            record.actionToken,\n            record.singleTopUpAmount,\n            record.totalTopUpAmount,\n            record.maxFee,\n            record.extra\n        );\n        return true;\n    }\n    /\n     * @notice See overloaded version of execute for more details.\n     */\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol\n    ) external override returns (bool) {\n        return execute(payer, account, beneficiary, protocol, 0);\n    }\n    /\n     * @notice Delete a position to back on the given protocol for account.\n     * @param account Account holding the position.\n     * @param protocol Protocol the position is held on.\n     * @param unstake If the tokens should be unstaked from vault.\n     * @return true if successful.\n     /\n    function resetPosition(\n        bytes32 account,\n        bytes32 protocol,\n        bool unstake\n    ) external override returns (bool) {\n        address payer = msg.sender;\n        Record memory position = positions[payer][account][protocol];\n        require(position.threshold != 0, Error.NO_POSITION_EXISTS);\n        IAddressProvider addressProvider = addressProvider;\n        address vault = addressProvider_.getStakerVault(position.depositToken); // will revert if vault does not exist\n        IStakerVault staker = IStakerVault(vault);\n        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);\n        if (unstake) {\n            staker.unstake(position.depositTokenBalance);\n            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);\n        } else {\n            staker.transfer(payer, position.depositTokenBalance);\n        }\n        removePosition(payer, account, protocol);\n        addressProvider.getGasBank().withdrawUnused(payer);\n        return true;\n    }\n    /\n     * @notice Execute top up handler update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @param protocol Protocol for which a new handler should be executed.\n     * @return Address of new handler.\n     /\n    function executeTopUpHandler(bytes32 protocol) external override returns (address) {\n        address oldHandler = _getHandler(protocol, false);\n        address newHandler = _executeAddress(_getProtocolKey(protocol));\n        _updateTopUpHandler(protocol, oldHandler, newHandler);\n        return newHandler;\n    }\n    /\n     * @notice Reset new top up handler deadline for a protocol.\n     * @param protocol Protocol for which top up handler deadline should be reset.\n     * @return true if successful.\n     */\n    function resetTopUpHandler(bytes32 protocol) external override onlyGovernance returns (bool) {\n        return _resetAddressConfig(_getProtocolKey(protocol));\n    }\n    /\n     * @notice Prepare action fee update.\n     * @param newActionFee New fee to set.\n     * @return true if success.\n     /\n    function prepareActionFee(uint256 newActionFee)\n        external\n        override\n        onlyGovernance\n        returns (bool)\n    {\n        require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);\n        return _prepare(_ACTION_FEE_KEY, newActionFee);\n    }\n    /\n     * @notice Execute action fee update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return true if successful.\n     /\n    function executeActionFee() external override returns (uint256) {\n        return _executeUInt256(_ACTION_FEE_KEY);\n    }\n    /\n     * @notice Reset action fee deadline.\n     * @return true if successful.\n     */\n    function resetActionFee() external override onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ACTION_FEE_KEY);\n    }\n    / Set fee handler /\n    /\n     * @notice Prepare update of fee handler.\n     * @param handler New fee handler.\n     * @return true if success.\n     /\n    function prepareFeeHandler(address handler) external override onlyGovernance returns (bool) {\n        return _prepare(_FEE_HANDLER_KEY, handler);\n    }\n    /\n     * @notice Execute update of fee handler (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return true if successful.\n     */\n    function executeFeeHandler() external override returns (address) {\n        return _executeAddress(_FEE_HANDLER_KEY);\n    }\n    /\n     * @notice Reset the handler deadline.\n     * @return true if success.\n     /\n    function resetFeeHandler() external override onlyGovernance returns (bool) {\n        return _resetAddressConfig(_FEE_HANDLER_KEY);\n    }\n    /\n     * @notice Prepare update of estimated gas usage.\n     * @param gasUsage New estimated gas usage.\n     * @return true if success.\n     /\n    function prepareEstimatedGasUsage(uint256 gasUsage)\n        external\n        override\n        onlyGovernance\n        returns (bool)\n    {\n        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);\n    }\n    /\n     * @notice Execute update of gas usage (with time delay enforced).\n     * @return true if successful.\n     */\n    function executeEstimatedGasUsage() external override returns (uint256) {\n        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);\n    }\n    /\n     * @notice Reset the gas usage deadline.\n     * @return true if success.\n     /\n    function resetGasUsage() external override onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);\n    }\n    /\n     * @notice Add a new deposit token that is supported by the action.\n     * @dev There is a separate check for whether the usable token (i.e. deposit token)\n     *      is swappable for some action token.\n     * @param token Address of deposit token that can be used by the action.\n     /\n    function addUsableToken(address token) external override onlyGovernance returns (bool) {\n        return _usableTokens.add(token);\n    }\n    /\n     * @notice Computes the total amount of ETH (as wei) required to pay for all\n     * the top-ups assuming the maximum gas price and the current estimated gas\n     * usage of a top-up\n     */\n    function getEthRequiredForGas(address payer) external view override returns (uint256) {\n        uint256 totalEthRequired;\n        RecordMeta[] memory userRecordsMeta = _userPositions[payer];\n        uint256 gasUsagePerCall = getEstimatedGasUsage();\n        uint256 length = userRecordsMeta.length;\n        for (uint256 i; i &lt; length; i = i.uncheckedInc()) {\n            RecordMeta memory meta = userRecordsMeta[i];\n            Record memory record = _positions[payer][meta.account][meta.protocol];\n            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);\n            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;\n        }\n        return totalEthRequired;\n    }\n    /\n     * @notice Returns a list of positions for the given payer\n     /\n    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {\n        return _userPositions[payer];\n    }\n    /\n     * @notice Get a list supported protocols.\n     * @return List of supported protocols.\n     /\n    function getSupportedProtocols() external view override returns (bytes32[] memory) {\n        uint256 length = _supportedProtocols.length();\n        bytes32[] memory protocols = new bytes32;\n        for (uint256 i; i &lt; length; i = i.uncheckedInc()) {\n            protocols[i] = _supportedProtocols.at(i);\n        }\n        return protocols;\n    }\n    /\n     * @notice Gets a list of users that have an active position.\n     * @dev Uses cursor pagination.\n     * @param cursor The cursor for pagination (should start at 0 for first call).\n     * @param howMany Maximum number of users to return in this pagination request.\n     * @return users List of users that have an active position.\n     * @return nextCursor The cursor to use for the next pagination request.\n     /\n    function usersWithPositions(uint256 cursor, uint256 howMany)\n        external\n        view\n        override\n        returns (address[] memory users, uint256 nextCursor)\n    {\n        uint256 length = _usersWithPositions.length();\n        if (cursor &gt;= length) return (new address, 0);\n        if (howMany &gt;= length - cursor) {\n            howMany = length - cursor;\n        }\n        address[] memory usersWithPositions = new address;\n        for (uint256 i; i &lt; howMany; i = i.uncheckedInc()) {\n            usersWithPositions_[i] = usersWithPositions.at(i + cursor);\n        }\n        return (usersWithPositions, cursor + howMany);\n    }\n    /\n     * @notice Get a list of all tokens usable for this action.\n     * @dev This refers to all tokens that can be used as deposit tokens.\n     * @return Array of addresses of usable tokens.\n     */\n    function getUsableTokens() external view override returns (address[] memory) {\n        return _usableTokens.toArray();\n    }\n    /\n     * @notice Retrieves the topup handler for the given protocol\n     /\n    function getTopUpHandler(bytes32 protocol) external view override returns (address) {\n        return _getHandler(protocol, false);\n    }\n    /\n     * @notice Successfully tops up a position if it\'s conditions are met.\n     * @dev pool and vault funds are rebalanced after withdrawal for top up\n     * @param payer Account that pays for the top up.\n     * @param account Account owning the position for top up.\n     * @param beneficiary Address of the keeper\'s wallet for fee accrual.\n     * @param protocol Protocol of the top up position.\n     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas\n     * @return true if successful.\n     /\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol,\n        uint256 maxWeiForGas\n    ) public override returns (bool) {\n        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);\n        ExecuteLocalVars memory vars;\n        vars.initialGas = gasleft();\n        Record storage position = positions[payer][account][protocol];\n        require(position.threshold != 0, Error.NO_POSITION_EXISTS);\n        require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);\n        require(block.timestamp &gt; position.registeredAt, Error.CANNOT_EXECUTE_IN_SAME_BLOCK);\n        vars.topUpHandler = _getHandler(protocol, true);\n        vars.userFactor = ITopUpHandler(vars.topUpHandler).getUserFactor(account, position.extra);\n        // ensure that the position is actually below its set user factor threshold\n        require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);\n        IAddressProvider addressProvider = addressProvider;\n        IGasBank gasBank = addressProvider_.getGasBank();\n        // fail early if the user does not have enough funds in the gas bank\n        // to cover the cost of the transaction\n        vars.estimatedRequiredGas = getEstimatedGasUsage();\n        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;\n        // compute the gas price that the user will be paying\n        vars.userGasPrice = block.basefee + position.priorityFee;\n        if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;\n        if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;\n        // ensure the current position allows for the gas to be paid\n        require(\n            vars.estimatedRequiredWeiForGas &lt;=\n                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,\n            Error.ESTIMATED_GAS_TOO_HIGH\n        );\n        vars.gasBankBalance = gasBank.balanceOf(payer);\n        // ensure the user has enough funds in the gas bank to cover the gas\n        require(\n            vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,\n            Error.GAS_BANK_BALANCE_TOO_LOW\n        );\n        vars.totalTopUpAmount = position.totalTopUpAmount;\n        vars.actionFee = getActionFee();\n        // add top-up fees to top-up amount\n        vars.minActionAmountToTopUp = position.singleTopUpAmount;\n        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(\n            ScaledMath.ONE + vars.actionFee\n        );\n        // if the amount that we want to top-up (including fees) is higher than\n        // the available topup amount, we lower this down to what is left of the position\n        if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {\n            vars.actionAmountWithFees = vars.totalTopUpAmount;\n            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(\n                ScaledMath.ONE + vars.actionFee\n            );\n        }\n        ILiquidityPool pool = addressProvider_.getPoolForToken(position.depositToken);\n        vars.underlying = pool.getUnderlying();\n        vars.rate = pool.exchangeRate();\n        // compute the deposit tokens amount with and without fees\n        // we will need to unstake the amount with fees and to\n        // swap the amount without fees into action tokens\n        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);\n        if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {\n            vars.depositAmountWithFees = position.depositTokenBalance;\n            vars.minActionAmountToTopUp =\n                (vars.depositAmountWithFees * vars.rate) /\n                (ScaledMath.ONE + vars.actionFee);\n        }\n        // compute amount of LP tokens needed to pay for action\n        // rate is expressed in actionToken per depositToken\n        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);\n        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;\n        // will revert if vault does not exist\n        address vault = addressProvider_.getStakerVault(position.depositToken);\n        // unstake deposit tokens including fees\n        IStakerVault(vault).unstake(vars.depositAmountWithFees);\n        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);\n        // swap the amount without the fees\n        // as the fees are paid in deposit token, not in action token\n        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);\n        // compute how much of action token was actually redeemed and add fees to it\n        // this is to ensure that no funds get locked inside the contract\n        vars.totalActionTokenAmount =\n            vars.actionTokenAmount +\n            vars.depositTotalFeesAmount.scaledMul(vars.rate);\n        // at this point, we have exactly vars.actionTokenAmount\n        // (at least position.singleTopUpAmount) of action token\n        // and exactly vars.depositTotalFeesAmount deposit tokens in the contract\n        // solhint-disable-next-line avoid-low-level-calls\n        uint256 value_;\n        if (position.actionToken == address(0)) {\n            value_ = vars.actionTokenAmount;\n        } else {\n            approve(position.actionToken, vars.topUpHandler);\n        }\n        vars.topupResult = ITopUpHandler(vars.topUpHandler).topUp{value: value}(\n            account,\n            position.actionToken,\n            vars.actionTokenAmount,\n            position.extra\n        );\n        require(vars.topupResult, Error.TOP_UP_FAILED);\n        // totalTopUpAmount is updated to reflect the new "balance" of the position\n        if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {\n            position.totalTopUpAmount -= vars.totalActionTokenAmount.toUint128();\n        } else {\n            position.totalTopUpAmount = 0;\n        }\n        position.depositTokenBalance -= vars.depositAmountWithFees.toUint128();\n        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;\n        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);\n        if (vars.removePosition) {\n            if (position.depositTokenBalance &gt; 0) {\n                // transfer any unused locked tokens to the payer\n                IStakerVault(vault).transfer(payer, position.depositTokenBalance);\n                IStakerVault(vault).decreaseActionLockedBalance(\n                    payer,\n                    position.depositTokenBalance\n                );\n            }\n            _removePosition(payer, account, protocol);\n        }\n        emit TopUp(\n            account,\n            protocol,\n            payer,\n            position.depositToken,\n            vars.depositAmountWithFees,\n            position.actionToken,\n            vars.actionTokenAmount\n        );\n        // compute gas used and reimburse the keeper by using the\n        // funds of payer in the gas bank\n        // TODO: add constant gas consumed for transfer and tx prologue\n        vars.gasConsumed = vars.initialGas - gasleft();\n        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;\n        if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {\n            vars.reimbursedWeiForGas = vars.gasBankBalance;\n        }\n        // ensure that the keeper is not overpaying\n        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;\n        require(\n            vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,\n            Error.GAS_TOO_HIGH\n        );\n        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);\n        if (vars.removePosition) {\n            gasBank.withdrawUnused(payer);\n        }\n        return true;\n    }\n    /\n     * @notice Prepare new top up handler fee update.\n     * @dev Setting the address to 0 means that the protocol will no longer be supported.\n     * @param protocol Protocol for which a new handler should be prepared.\n     * @param newHandler Address of new handler.\n     * @return true if success.\n     */\n    function prepareTopUpHandler(bytes32 protocol, address newHandler)\n        public\n        override\n        onlyGovernance\n        returns (bool)\n    {\n        return _prepare(_getProtocolKey(protocol), newHandler);\n    }\n    /\n     * @notice Check if action can be executed.\n     * @param protocol for which to get the health factor\n     * @param account for which to get the health factor\n     * @param extra data to be used by the topup handler\n     * @return healthFactor of the position\n     /\n    function getHealthFactor(\n        bytes32 protocol,\n        bytes32 account,\n        bytes calldata extra\n    ) public view override returns (uint256 healthFactor) {\n        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));\n        return topUpHandler.getUserFactor(account, extra);\n    }\n    function getHandler(bytes32 protocol) public view override returns (address) {\n        return _getHandler(protocol, false);\n    }\n    /\n     * @notice returns the current estimated gas usage\n     /\n    function getEstimatedGasUsage() public view override returns (uint256) {\n        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];\n    }\n    /\n     * @notice Returns the current action fee\n     */\n    function getActionFee() public view override returns (uint256) {\n        return currentUInts256[_ACTION_FEE_KEY];\n    }\n    /\n     * @notice Returns the current fee handler\n     /\n    function getFeeHandler() public view override returns (address) {\n        return currentAddresses[_FEE_HANDLER_KEY];\n    }\n    /\n     * @notice Get the record for a position.\n     * @param payer Registered payer of the position.\n     * @param account Address holding the position.\n     * @param protocol Protocol where the position is held.\n     /\n    function getPosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) public view override returns (Record memory) {\n        return _positions[payer][account][protocol];\n    }\n    /\n     * @notice Check whether a token is usable as a deposit token.\n     * @param token Address of token to check.\n     * @return True if token is usable as a deposit token for this action.\n     */\n    function isUsable(address token) public view override returns (bool) {\n        return _usableTokens.contains(token);\n    }\n    function _updateTopUpHandler(\n        bytes32 protocol,\n        address oldHandler,\n        address newHandler\n    ) internal {\n        if (newHandler == address(0)) {\n            _supportedProtocols.remove(protocol);\n        } else if (oldHandler == address(0)) {\n            _supportedProtocols.add(protocol);\n        }\n    }\n    /\n     * @dev Pays fees to the feeHandler\n     * @param payer The account who\'s position the fees are charged on\n     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)\n     * @param feeAmount The amount in tokens to pay as fees\n     * @param depositToken The LpToken used to pay the fees\n     /\n    function _payFees(\n        address payer,\n        address beneficiary,\n        uint256 feeAmount,\n        address depositToken\n    ) internal {\n        address feeHandler = getFeeHandler();\n        IERC20(depositToken).safeApprove(feeHandler, feeAmount);\n        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);\n    }\n    /\n     * @dev "Locks" an amount of tokens on behalf of the TopUpAction\n     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.\n     * @param payer Owner of the funds to be locked\n     * @param token Token to lock\n     * @param lockAmount Minimum amount of token to lock\n     * @param depositAmount Amount of token that was deposited.\n     *                      If this is 0 then the staker vault allowance should be used.\n     *                      If this is greater than requiredAmount more tokens will be locked.\n     /\n    function _lockFunds(\n        address payer,\n        address token,\n        uint256 lockAmount,\n        uint256 depositAmount\n    ) internal {\n        address stakerVaultAddress = addressProvider.getStakerVault(token);\n        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);\n    }\n    function _removePosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) internal {\n        delete _positions[payer][account][protocol];\n        _removeUserPosition(payer, account, protocol);\n        if (_userPositions[payer].length == 0) {\n            _usersWithPositions.remove(payer);\n        }\n        emit Deregister(payer, account, protocol);\n    }\n    function _removeUserPosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) internal {\n        RecordMeta[] storage positionsMeta = _userPositions[payer];\n        uint256 length = positionsMeta.length;\n        for (uint256 i; i &lt; length; i = i.uncheckedInc()) {\n            RecordMeta storage positionMeta = positionsMeta[i];\n            if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {\n                positionsMeta[i] = positionsMeta[length - 1];\n                positionsMeta.pop();\n                return;\n            }\n        }\n    }\n    /\n     * @dev Approves infinite spending for the given spender.\n     * @param token The token to approve for.\n     * @param spender The spender to approve.\n     */\n    function _approve(address token, address spender) internal {\n        if (IERC20(token).allowance(address(this), spender) &gt; 0) return;\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n    /\n     * @dev Computes and returns the amount of LP tokens of type token that will be received in exchange for an amount of the actionToken.\n     /\n    function _calcExchangeAmount(\n        address token,\n        address actionToken,\n        uint256 amount\n    ) internal view returns (uint256) {\n        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);\n    }\n    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {\n        address handler = currentAddresses[_getProtocolKey(protocol)];\n        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);\n        return handler;\n    }\n    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);\n        return pool.getUnderlying() == toToken;\n    }\n    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));\n    }\n}\n.\n\nChief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.\nHere\'s a Solidity contract provided by the user: "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\nimport "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";\nimport "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\nimport "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";\nimport "@openzeppelin/contracts/utils/math/SafeCast.sol";\nimport "../../../interfaces/IGasBank.sol";\nimport "../../../interfaces/pool/ILiquidityPool.sol";\nimport "../../../interfaces/IController.sol";\nimport "../../../interfaces/IStakerVault.sol";\nimport "../../../interfaces/actions/topup/ITopUpHandler.sol";\nimport "../../../interfaces/actions/topup/ITopUpAction.sol";\nimport "../../../interfaces/actions/IActionFeeHandler.sol";\nimport "../../../libraries/AddressProviderHelpers.sol";\nimport "../../../libraries/Errors.sol";\nimport "../../../libraries/ScaledMath.sol";\nimport "../../../libraries/EnumerableExtensions.sol";\nimport "../../../libraries/UncheckedMath.sol";\nimport "../../access/Authorization.sol";\nimport "../../utils/Preparable.sol";\n/\n * @notice The logic here should really be part of the top-up action\n * but is split in a library to circumvent the byte-code size limit\n /\nlibrary TopUpActionLibrary {\n    using SafeERC20 for IERC20;\n    using ScaledMath for uint256;\n    using AddressProviderHelpers for IAddressProvider;\n    /\n     * @dev "Locks" an amount of tokens on behalf of the TopUpAction\n     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.\n     * @param stakerVaultAddress The address of the staker vault\n     * @param payer Owner of the funds to be locked\n     * @param token Token to lock\n     * @param lockAmount Minimum amount of token to lock\n     * @param depositAmount Amount of token that was deposited.\n     *                      If this is 0 then the staker vault allowance should be used.\n     *                      If this is greater than requiredAmount more tokens will be locked.\n     */\n    function lockFunds(\n        address stakerVaultAddress,\n        address payer,\n        address token,\n        uint256 lockAmount,\n        uint256 depositAmount\n    ) external {\n        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);\n        // stake deposit amount\n        if (depositAmount &gt; 0) {\n            depositAmount = depositAmount &gt; lockAmount ? lockAmount : depositAmount;\n            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);\n            _approve(token, stakerVaultAddress);\n            stakerVault.stake(depositAmount);\n            stakerVault.increaseActionLockedBalance(payer, depositAmount);\n            lockAmount -= depositAmount;\n        }\n        // use stake vault allowance if available and required\n        if (lockAmount &gt; 0) {\n            uint256 balance = stakerVault.balanceOf(payer);\n            uint256 allowance = stakerVault.allowance(payer, address(this));\n            uint256 availableFunds = balance &lt; allowance ? balance : allowance;\n            if (availableFunds &gt;= lockAmount) {\n                stakerVault.transferFrom(payer, address(this), lockAmount);\n                stakerVault.increaseActionLockedBalance(payer, lockAmount);\n                lockAmount = 0;\n            }\n        }\n        require(lockAmount == 0, Error.INSUFFICIENT_UPDATE_BALANCE);\n    }\n    /\n     * @dev Computes and returns the amount of LP tokens of type token that will be received in exchange for an amount of the underlying.\n     /\n    function calcExchangeAmount(\n        IAddressProvider addressProvider,\n        address token,\n        address actionToken,\n        uint256 amount\n    ) external view returns (uint256) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(token);\n        uint256 rate = pool.exchangeRate();\n        address underlying = pool.getUnderlying();\n        require(underlying == actionToken, Error.TOKEN_NOT_USABLE);\n        return amount.scaledDivRoundUp(rate);\n    }\n    /\n     * @dev Approves infinite spending for the given spender.\n     * @param token The token to approve for.\n     * @param spender The spender to approve.\n     /\n    function _approve(address token, address spender) private {\n        if (IERC20(token).allowance(address(this), spender) &gt; 0) return;\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n}\ncontract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {\n    using ScaledMath for uint256;\n    using UncheckedMath for uint256;\n    using ScaledMath for uint128;\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using EnumerableExtensions for EnumerableSet.AddressSet;\n    using AddressProviderHelpers for IAddressProvider;\n    using SafeCast for uint256;\n    /\n     * @dev Temporary struct to hold local variables in execute\n     * and avoid the stack being "too deep"\n     */\n    struct ExecuteLocalVars {\n        uint256 minActionAmountToTopUp;\n        uint256 actionTokenAmount;\n        uint256 depositTotalFeesAmount;\n        uint256 actionAmountWithFees;\n        uint256 userFactor;\n        uint256 rate;\n        uint256 depositAmountWithFees;\n        uint256 depositAmountWithoutFees;\n        uint256 actionFee;\n        uint256 totalActionTokenAmount;\n        uint128 totalTopUpAmount;\n        bool topupResult;\n        uint256 gasBankBalance;\n        uint256 initialGas;\n        uint256 gasConsumed;\n        uint256 userGasPrice;\n        uint256 estimatedRequiredGas;\n        uint256 estimatedRequiredWeiForGas;\n        uint256 requiredWeiForGas;\n        uint256 reimbursedWeiForGas;\n        address underlying;\n        bool removePosition;\n        address topUpHandler;\n    }\n    EnumerableSet.AddressSet private _usableTokens;\n    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 550_000;\n    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";\n    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";\n    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";\n    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";\n    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;\n    IController public immutable controller;\n    IAddressProvider public immutable addressProvider;\n    EnumerableSet.Bytes32Set internal _supportedProtocols;\n    /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record)\n    mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;\n    mapping(address =&gt; RecordMeta[]) internal _userPositions;\n    EnumerableSet.AddressSet internal _usersWithPositions;\n    constructor(IController _controller)\n        Authorization(_controller.addressProvider().getRoleManager())\n    {\n        controller = _controller;\n        addressProvider = controller.addressProvider();\n        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);\n    }\n    receive() external payable {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n    function initialize(\n        address feeHandler,\n        bytes32[] calldata protocols,\n        address[] calldata handlers\n    ) external initializer onlyGovernance {\n        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);\n        _setConfig(_FEE_HANDLER_KEY, feeHandler);\n        for (uint256 i; i &lt; protocols.length; i = i.uncheckedInc()) {\n            bytes32 protocolKey = _getProtocolKey(protocols[i]);\n            _setConfig(protocolKey, handlers[i]);\n            _updateTopUpHandler(protocols[i], address(0), handlers[i]);\n        }\n    }\n    /\n     * @notice Register a top up action.\n     * @dev The depositAmount, once converted to units of actionToken, must be greater or equal to the totalTopUpAmount (which is denominated in actionToken).\n     * @param account Account to be topped up (first 20 bytes will typically be the address).\n     * @param protocol Protocol which holds position to be topped up.\n     * @param depositAmount Amount of depositToken that will be locked.\n     * @param record containing the data for the position to register\n     /\n    function register(\n        bytes32 account,\n        bytes32 protocol,\n        uint128 depositAmount,\n        Record memory record\n    ) external payable override returns (bool) {\n        require(record.maxFee != 0, Error.INVALID_MAX_FEE);\n        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);\n        require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);\n        require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);\n        require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);\n        require(\n            _positions[msg.sender][account][protocol].threshold == 0,\n            Error.POSITION_ALREADY_EXISTS\n        );\n        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);\n        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);\n        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) \n            record.maxFee \n            getEstimatedGasUsage();\n        require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);\n        uint256 totalLockAmount = _calcExchangeAmount(\n            record.depositToken,\n            record.actionToken,\n            record.totalTopUpAmount\n        );\n        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);\n        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);\n        record.registeredAt = uint64(block.timestamp);\n        record.depositTokenBalance = totalLockAmount.toUint128();\n        _positions[msg.sender][account][protocol] = record;\n        _userPositions[msg.sender].push(RecordMeta(account, protocol));\n        _usersWithPositions.add(msg.sender);\n        emit Register(\n            account,\n            protocol,\n            record.threshold,\n            msg.sender,\n            record.depositToken,\n            totalLockAmount,\n            record.actionToken,\n            record.singleTopUpAmount,\n            record.totalTopUpAmount,\n            record.maxFee,\n            record.extra\n        );\n        return true;\n    }\n    /\n     * @notice See overloaded version of execute for more details.\n     /\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol\n    ) external override returns (bool) {\n        return execute(payer, account, beneficiary, protocol, 0);\n    }\n    /\n     * @notice Delete a position to back on the given protocol for account.\n     * @param account Account holding the position.\n     * @param protocol Protocol the position is held on.\n     * @param unstake If the tokens should be unstaked from vault.\n     * @return true if successful.\n     */\n    function resetPosition(\n        bytes32 account,\n        bytes32 protocol,\n        bool unstake\n    ) external override returns (bool) {\n        address payer = msg.sender;\n        Record memory position = positions[payer][account][protocol];\n        require(position.threshold != 0, Error.NO_POSITION_EXISTS);\n        IAddressProvider addressProvider = addressProvider;\n        address vault = addressProvider_.getStakerVault(position.depositToken); // will revert if vault does not exist\n        IStakerVault staker = IStakerVault(vault);\n        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);\n        if (unstake) {\n            staker.unstake(position.depositTokenBalance);\n            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);\n        } else {\n            staker.transfer(payer, position.depositTokenBalance);\n        }\n        removePosition(payer, account, protocol);\n        addressProvider.getGasBank().withdrawUnused(payer);\n        return true;\n    }\n    /\n     * @notice Execute top up handler update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @param protocol Protocol for which a new handler should be executed.\n     * @return Address of new handler.\n     /\n    function executeTopUpHandler(bytes32 protocol) external override returns (address) {\n        address oldHandler = _getHandler(protocol, false);\n        address newHandler = _executeAddress(_getProtocolKey(protocol));\n        _updateTopUpHandler(protocol, oldHandler, newHandler);\n        return newHandler;\n    }\n    /\n     * @notice Reset new top up handler deadline for a protocol.\n     * @param protocol Protocol for which top up handler deadline should be reset.\n     * @return true if successful.\n     /\n    function resetTopUpHandler(bytes32 protocol) external override onlyGovernance returns (bool) {\n        return _resetAddressConfig(_getProtocolKey(protocol));\n    }\n    /\n     * @notice Prepare action fee update.\n     * @param newActionFee New fee to set.\n     * @return true if success.\n     */\n    function prepareActionFee(uint256 newActionFee)\n        external\n        override\n        onlyGovernance\n        returns (bool)\n    {\n        require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);\n        return _prepare(_ACTION_FEE_KEY, newActionFee);\n    }\n    /\n     * @notice Execute action fee update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return true if successful.\n     /\n    function executeActionFee() external override returns (uint256) {\n        return _executeUInt256(_ACTION_FEE_KEY);\n    }\n    /\n     * @notice Reset action fee deadline.\n     * @return true if successful.\n     /\n    function resetActionFee() external override onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ACTION_FEE_KEY);\n    }\n    / Set fee handler */\n    /\n     * @notice Prepare update of fee handler.\n     * @param handler New fee handler.\n     * @return true if success.\n     /\n    function prepareFeeHandler(address handler) external override onlyGovernance returns (bool) {\n        return _prepare(_FEE_HANDLER_KEY, handler);\n    }\n    /\n     * @notice Execute update of fee handler (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return true if successful.\n     /\n    function executeFeeHandler() external override returns (address) {\n        return _executeAddress(_FEE_HANDLER_KEY);\n    }\n    /\n     * @notice Reset the handler deadline.\n     * @return true if success.\n     */\n    function resetFeeHandler() external override onlyGovernance returns (bool) {\n        return _resetAddressConfig(_FEE_HANDLER_KEY);\n    }\n    /\n     * @notice Prepare update of estimated gas usage.\n     * @param gasUsage New estimated gas usage.\n     * @return true if success.\n     /\n    function prepareEstimatedGasUsage(uint256 gasUsage)\n        external\n        override\n        onlyGovernance\n        returns (bool)\n    {\n        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);\n    }\n    /\n     * @notice Execute update of gas usage (with time delay enforced).\n     * @return true if successful.\n     /\n    function executeEstimatedGasUsage() external override returns (uint256) {\n        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);\n    }\n    /\n     * @notice Reset the gas usage deadline.\n     * @return true if success.\n     */\n    function resetGasUsage() external override onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);\n    }\n    /\n     * @notice Add a new deposit token that is supported by the action.\n     * @dev There is a separate check for whether the usable token (i.e. deposit token)\n     *      is swappable for some action token.\n     * @param token Address of deposit token that can be used by the action.\n     /\n    function addUsableToken(address token) external override onlyGovernance returns (bool) {\n        return _usableTokens.add(token);\n    }\n    /\n     * @notice Computes the total amount of ETH (as wei) required to pay for all\n     * the top-ups assuming the maximum gas price and the current estimated gas\n     * usage of a top-up\n     /\n    function getEthRequiredForGas(address payer) external view override returns (uint256) {\n        uint256 totalEthRequired;\n        RecordMeta[] memory userRecordsMeta = _userPositions[payer];\n        uint256 gasUsagePerCall = getEstimatedGasUsage();\n        uint256 length = userRecordsMeta.length;\n        for (uint256 i; i &lt; length; i = i.uncheckedInc()) {\n            RecordMeta memory meta = userRecordsMeta[i];\n            Record memory record = _positions[payer][meta.account][meta.protocol];\n            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);\n            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;\n        }\n        return totalEthRequired;\n    }\n    /\n     * @notice Returns a list of positions for the given payer\n     */\n    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {\n        return _userPositions[payer];\n    }\n    /\n     * @notice Get a list supported protocols.\n     * @return List of supported protocols.\n     /\n    function getSupportedProtocols() external view override returns (bytes32[] memory) {\n        uint256 length = _supportedProtocols.length();\n        bytes32[] memory protocols = new bytes32;\n        for (uint256 i; i &lt; length; i = i.uncheckedInc()) {\n            protocols[i] = _supportedProtocols.at(i);\n        }\n        return protocols;\n    }\n    /\n     * @notice Gets a list of users that have an active position.\n     * @dev Uses cursor pagination.\n     * @param cursor The cursor for pagination (should start at 0 for first call).\n     * @param howMany Maximum number of users to return in this pagination request.\n     * @return users List of users that have an active position.\n     * @return nextCursor The cursor to use for the next pagination request.\n     /\n    function usersWithPositions(uint256 cursor, uint256 howMany)\n        external\n        view\n        override\n        returns (address[] memory users, uint256 nextCursor)\n    {\n        uint256 length = usersWithPositions.length();\n        if (cursor &gt;= length) return (new address, 0);\n        if (howMany &gt;= length - cursor) {\n            howMany = length - cursor;\n        }\n        address[] memory usersWithPositions = new address;\n        for (uint256 i; i &lt; howMany; i = i.uncheckedInc()) {\n            usersWithPositions_[i] = usersWithPositions.at(i + cursor);\n        }\n        return (usersWithPositions, cursor + howMany);\n    }\n    /\n     * @notice Get a list of all tokens usable for this action.\n     * @dev This refers to all tokens that can be used as deposit tokens.\n     * @return Array of addresses of usable tokens.\n     /\n    function getUsableTokens() external view override returns (address[] memory) {\n        return _usableTokens.toArray();\n    }\n    /\n     * @notice Retrieves the topup handler for the given protocol\n     */\n    function getTopUpHandler(bytes32 protocol) external view override returns (address) {\n        return _getHandler(protocol, false);\n    }\n    /\n     * @notice Successfully tops up a position if it\'s conditions are met.\n     * @dev pool and vault funds are rebalanced after withdrawal for top up\n     * @param payer Account that pays for the top up.\n     * @param account Account owning the position for top up.\n     * @param beneficiary Address of the keeper\'s wallet for fee accrual.\n     * @param protocol Protocol of the top up position.\n     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas\n     * @return true if successful.\n     /\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol,\n        uint256 maxWeiForGas\n    ) public override returns (bool) {\n        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);\n        ExecuteLocalVars memory vars;\n        vars.initialGas = gasleft();\n        Record storage position = positions[payer][account][protocol];\n        require(position.threshold != 0, Error.NO_POSITION_EXISTS);\n        require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);\n        require(block.timestamp &gt; position.registeredAt, Error.CANNOT_EXECUTE_IN_SAME_BLOCK);\n        vars.topUpHandler = _getHandler(protocol, true);\n        vars.userFactor = ITopUpHandler(vars.topUpHandler).getUserFactor(account, position.extra);\n        // ensure that the position is actually below its set user factor threshold\n        require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);\n        IAddressProvider addressProvider = addressProvider;\n        IGasBank gasBank = addressProvider_.getGasBank();\n        // fail early if the user does not have enough funds in the gas bank\n        // to cover the cost of the transaction\n        vars.estimatedRequiredGas = getEstimatedGasUsage();\n        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;\n        // compute the gas price that the user will be paying\n        vars.userGasPrice = block.basefee + position.priorityFee;\n        if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;\n        if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;\n        // ensure the current position allows for the gas to be paid\n        require(\n            vars.estimatedRequiredWeiForGas &lt;=\n                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,\n            Error.ESTIMATED_GAS_TOO_HIGH\n        );\n        vars.gasBankBalance = gasBank.balanceOf(payer);\n        // ensure the user has enough funds in the gas bank to cover the gas\n        require(\n            vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,\n            Error.GAS_BANK_BALANCE_TOO_LOW\n        );\n        vars.totalTopUpAmount = position.totalTopUpAmount;\n        vars.actionFee = getActionFee();\n        // add top-up fees to top-up amount\n        vars.minActionAmountToTopUp = position.singleTopUpAmount;\n        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(\n            ScaledMath.ONE + vars.actionFee\n        );\n        // if the amount that we want to top-up (including fees) is higher than\n        // the available topup amount, we lower this down to what is left of the position\n        if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {\n            vars.actionAmountWithFees = vars.totalTopUpAmount;\n            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(\n                ScaledMath.ONE + vars.actionFee\n            );\n        }\n        ILiquidityPool pool = addressProvider_.getPoolForToken(position.depositToken);\n        vars.underlying = pool.getUnderlying();\n        vars.rate = pool.exchangeRate();\n        // compute the deposit tokens amount with and without fees\n        // we will need to unstake the amount with fees and to\n        // swap the amount without fees into action tokens\n        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);\n        if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {\n            vars.depositAmountWithFees = position.depositTokenBalance;\n            vars.minActionAmountToTopUp =\n                (vars.depositAmountWithFees * vars.rate) /\n                (ScaledMath.ONE + vars.actionFee);\n        }\n        // compute amount of LP tokens needed to pay for action\n        // rate is expressed in actionToken per depositToken\n        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);\n        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;\n        // will revert if vault does not exist\n        address vault = addressProvider_.getStakerVault(position.depositToken);\n        // unstake deposit tokens including fees\n        IStakerVault(vault).unstake(vars.depositAmountWithFees);\n        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);\n        // swap the amount without the fees\n        // as the fees are paid in deposit token, not in action token\n        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);\n        // compute how much of action token was actually redeemed and add fees to it\n        // this is to ensure that no funds get locked inside the contract\n        vars.totalActionTokenAmount =\n            vars.actionTokenAmount +\n            vars.depositTotalFeesAmount.scaledMul(vars.rate);\n        // at this point, we have exactly vars.actionTokenAmount\n        // (at least position.singleTopUpAmount) of action token\n        // and exactly vars.depositTotalFeesAmount deposit tokens in the contract\n        // solhint-disable-next-line avoid-low-level-calls\n        uint256 value_;\n        if (position.actionToken == address(0)) {\n            value_ = vars.actionTokenAmount;\n        } else {\n            approve(position.actionToken, vars.topUpHandler);\n        }\n        vars.topupResult = ITopUpHandler(vars.topUpHandler).topUp{value: value}(\n            account,\n            position.actionToken,\n            vars.actionTokenAmount,\n            position.extra\n        );\n        require(vars.topupResult, Error.TOP_UP_FAILED);\n        // totalTopUpAmount is updated to reflect the new "balance" of the position\n        if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {\n            position.totalTopUpAmount -= vars.totalActionTokenAmount.toUint128();\n        } else {\n            position.totalTopUpAmount = 0;\n        }\n        position.depositTokenBalance -= vars.depositAmountWithFees.toUint128();\n        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;\n        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);\n        if (vars.removePosition) {\n            if (position.depositTokenBalance &gt; 0) {\n                // transfer any unused locked tokens to the payer\n                IStakerVault(vault).transfer(payer, position.depositTokenBalance);\n                IStakerVault(vault).decreaseActionLockedBalance(\n                    payer,\n                    position.depositTokenBalance\n                );\n            }\n            _removePosition(payer, account, protocol);\n        }\n        emit TopUp(\n            account,\n            protocol,\n            payer,\n            position.depositToken,\n            vars.depositAmountWithFees,\n            position.actionToken,\n            vars.actionTokenAmount\n        );\n        // compute gas used and reimburse the keeper by using the\n        // funds of payer in the gas bank\n        // TODO: add constant gas consumed for transfer and tx prologue\n        vars.gasConsumed = vars.initialGas - gasleft();\n        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;\n        if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {\n            vars.reimbursedWeiForGas = vars.gasBankBalance;\n        }\n        // ensure that the keeper is not overpaying\n        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;\n        require(\n            vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,\n            Error.GAS_TOO_HIGH\n        );\n        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);\n        if (vars.removePosition) {\n            gasBank.withdrawUnused(payer);\n        }\n        return true;\n    }\n    /\n     * @notice Prepare new top up handler fee update.\n     * @dev Setting the address to 0 means that the protocol will no longer be supported.\n     * @param protocol Protocol for which a new handler should be prepared.\n     * @param newHandler Address of new handler.\n     * @return true if success.\n     /\n    function prepareTopUpHandler(bytes32 protocol, address newHandler)\n        public\n        override\n        onlyGovernance\n        returns (bool)\n    {\n        return _prepare(_getProtocolKey(protocol), newHandler);\n    }\n    /\n     * @notice Check if action can be executed.\n     * @param protocol for which to get the health factor\n     * @param account for which to get the health factor\n     * @param extra data to be used by the topup handler\n     * @return healthFactor of the position\n     */\n    function getHealthFactor(\n        bytes32 protocol,\n        bytes32 account,\n        bytes calldata extra\n    ) public view override returns (uint256 healthFactor) {\n        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));\n        return topUpHandler.getUserFactor(account, extra);\n    }\n    function getHandler(bytes32 protocol) public view override returns (address) {\n        return _getHandler(protocol, false);\n    }\n    /\n     * @notice returns the current estimated gas usage\n     /\n    function getEstimatedGasUsage() public view override returns (uint256) {\n        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];\n    }\n    /\n     * @notice Returns the current action fee\n     /\n    function getActionFee() public view override returns (uint256) {\n        return currentUInts256[_ACTION_FEE_KEY];\n    }\n    /\n     * @notice Returns the current fee handler\n     */\n    function getFeeHandler() public view override returns (address) {\n        return currentAddresses[_FEE_HANDLER_KEY];\n    }\n    /\n     * @notice Get the record for a position.\n     * @param payer Registered payer of the position.\n     * @param account Address holding the position.\n     * @param protocol Protocol where the position is held.\n     /\n    function getPosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) public view override returns (Record memory) {\n        return _positions[payer][account][protocol];\n    }\n    /\n     * @notice Check whether a token is usable as a deposit token.\n     * @param token Address of token to check.\n     * @return True if token is usable as a deposit token for this action.\n     /\n    function isUsable(address token) public view override returns (bool) {\n        return _usableTokens.contains(token);\n    }\n    function _updateTopUpHandler(\n        bytes32 protocol,\n        address oldHandler,\n        address newHandler\n    ) internal {\n        if (newHandler == address(0)) {\n            _supportedProtocols.remove(protocol);\n        } else if (oldHandler == address(0)) {\n            _supportedProtocols.add(protocol);\n        }\n    }\n    /\n     * @dev Pays fees to the feeHandler\n     * @param payer The account who\'s position the fees are charged on\n     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)\n     * @param feeAmount The amount in tokens to pay as fees\n     * @param depositToken The LpToken used to pay the fees\n     */\n    function _payFees(\n        address payer,\n        address beneficiary,\n        uint256 feeAmount,\n        address depositToken\n    ) internal {\n        address feeHandler = getFeeHandler();\n        IERC20(depositToken).safeApprove(feeHandler, feeAmount);\n        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);\n    }\n    /\n     * @dev "Locks" an amount of tokens on behalf of the TopUpAction\n     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.\n     * @param payer Owner of the funds to be locked\n     * @param token Token to lock\n     * @param lockAmount Minimum amount of token to lock\n     * @param depositAmount Amount of token that was deposited.\n     *                      If this is 0 then the staker vault allowance should be used.\n     *                      If this is greater than requiredAmount more tokens will be locked.\n     /\n    function _lockFunds(\n        address payer,\n        address token,\n        uint256 lockAmount,\n        uint256 depositAmount\n    ) internal {\n        address stakerVaultAddress = addressProvider.getStakerVault(token);\n        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);\n    }\n    function _removePosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) internal {\n        delete _positions[payer][account][protocol];\n        _removeUserPosition(payer, account, protocol);\n        if (_userPositions[payer].length == 0) {\n            _usersWithPositions.remove(payer);\n        }\n        emit Deregister(payer, account, protocol);\n    }\n    function _removeUserPosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) internal {\n        RecordMeta[] storage positionsMeta = _userPositions[payer];\n        uint256 length = positionsMeta.length;\n        for (uint256 i; i &lt; length; i = i.uncheckedInc()) {\n            RecordMeta storage positionMeta = positionsMeta[i];\n            if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {\n                positionsMeta[i] = positionsMeta[length - 1];\n                positionsMeta.pop();\n                return;\n            }\n        }\n    }\n    /\n     * @dev Approves infinite spending for the given spender.\n     * @param token The token to approve for.\n     * @param spender The spender to approve.\n     /\n    function _approve(address token, address spender) internal {\n        if (IERC20(token).allowance(address(this), spender) &gt; 0) return;\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n    /\n     * @dev Computes and returns the amount of LP tokens of type token that will be received in exchange for an amount of the actionToken.\n     */\n    function _calcExchangeAmount(\n        address token,\n        address actionToken,\n        uint256 amount\n    ) internal view returns (uint256) {\n        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);\n    }\n    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {\n        address handler = currentAddresses[_getProtocolKey(protocol)];\n        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);\n        return handler;\n    }\n    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);\n        return pool.getUnderlying() == toToken;\n    }\n    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));\n    }\n}\n".\nAs the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.\nNote that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we\'ve collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions".\n\nSecurity Analyst: Let\'s analyze the provided Solidity contract code and identify potential improvements or enhancements.\n1. Gas Optimization: The contract has several places where gas consumption could be reduced. For example, in the execute function, the calculation of vars.estimatedRequiredWeiForGas and vars.userGasPrice could be optimized to avoid redundant calculations. We could also consider caching frequently accessed values to minimize storage reads.\n2. Error Handling: The contract uses require statements for error handling, which is good, but we could enhance the error messages to provide more context. This would help in debugging and understanding the failure points better.\n3. Reentrancy Guard: Although the contract uses SafeERC20 for token transfers, we should consider implementing a reentrancy guard on critical functions like execute and register. This would prevent potential reentrancy attacks, especially since the contract interacts with external contracts.\n4. Event Emission: The contract emits events for significant actions, but we could enhance this by adding more events for actions like resetPosition and prepareTopUpHandler. This would improve transparency and allow for better tracking of contract interactions.\n5. Access Control: The contract uses a governance mechanism for certain functions. We could consider implementing a multi-signature wallet for critical functions to enhance security and ensure that no single entity has control over significant actions.\n6. Upgradeability: Since the contract uses OpenZeppelin\'s Initializable, we should ensure that all upgradeable patterns are followed correctly. It might be beneficial to include a function to pause the contract in emergencies, which can be controlled by governance.\n7. Testing and Auditing: While this is more of a process improvement, ensuring that the contract undergoes thorough testing, including unit tests and integration tests, is crucial. Additionally, a third-party audit would provide an extra layer of security assurance.\n8. Documentation**: Improving inline documentation and comments throughout the code would help future developers understand the logic and purpose of various functions and variables.\nWhich of these suggestions resonates most with you, or do you have any other specific areas you would like to focus on?', 'question': 'Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" '} |
| **need_reflect** | False |
| **memory** | No existed memory |
| **chat_turn_limit** | 1 |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 12:30:03 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.10; import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol"; import "@openzeppelin/contracts/utils/math/SafeCast.sol"; import "../../../interfaces/IGasBank.sol"; import "../../../interfaces/pool/ILiquidityPool.sol"; import "../../../interfaces/IController.sol"; import "../../../interfaces/IStakerVault.sol"; import "../../../interfaces/actions/topup/ITopUpHandler.sol"; import "../../../interfaces/actions/topup/ITopUpAction.sol"; import "../../../interfaces/actions/IActionFeeHandler.sol"; import "../../../libraries/AddressProviderHelpers.sol"; import "../../../libraries/Errors.sol"; import "../../../libraries/ScaledMath.sol"; import "../../../libraries/EnumerableExtensions.sol"; import "../../../libraries/UncheckedMath.sol"; import "../../access/Authorization.sol"; import "../../utils/Preparable.sol"; /*  * @notice The logic here should really be part of the top-up action  * but is split in a library to circumvent the byte-code size limit  / library TopUpActionLibrary {     using SafeERC20 for IERC20;     using ScaledMath for uint256;     using AddressProviderHelpers for IAddressProvider; /**  * @dev "Locks" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param stakerVaultAddress The address of the staker vault  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function lockFunds(     address stakerVaultAddress,     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) external {     IStakerVault stakerVault = IStakerVault(stakerVaultAddress);      // stake deposit amount     if (depositAmount &gt; 0) {         depositAmount = depositAmount &gt; lockAmount ? lockAmount : depositAmount;         IERC20(token).safeTransferFrom(payer, address(this), depositAmount);         _approve(token, stakerVaultAddress);         stakerVault.stake(depositAmount);         stakerVault.increaseActionLockedBalance(payer, depositAmount);         lockAmount -= depositAmount;     }      // use stake vault allowance if available and required     if (lockAmount &gt; 0) {         uint256 balance = stakerVault.balanceOf(payer);         uint256 allowance = stakerVault.allowance(payer, address(this));         uint256 availableFunds = balance &lt; allowance ? balance : allowance;         if (availableFunds &gt;= lockAmount) {             stakerVault.transferFrom(payer, address(this), lockAmount);             stakerVault.increaseActionLockedBalance(payer, lockAmount);             lockAmount = 0;         }     }      require(lockAmount == 0, Error.INSUFFICIENT_UPDATE_BALANCE); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function calcExchangeAmount(     IAddressProvider addressProvider,     address token,     address actionToken,     uint256 amount ) external view returns (uint256) {     ILiquidityPool pool = addressProvider.getPoolForToken(token);     uint256 rate = pool.exchangeRate();     address underlying = pool.getUnderlying();     require(underlying == actionToken, Error.TOKEN_NOT_USABLE);     return amount.scaledDivRoundUp(rate); }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) private {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  } contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {     using ScaledMath for uint256;     using UncheckedMath for uint256;     using ScaledMath for uint128;     using SafeERC20 for IERC20;     using EnumerableSet for EnumerableSet.AddressSet;     using EnumerableSet for EnumerableSet.Bytes32Set;     using EnumerableExtensions for EnumerableSet.AddressSet;     using AddressProviderHelpers for IAddressProvider;     using SafeCast for uint256; /**  * @dev Temporary struct to hold local variables in execute  * and avoid the stack being "too deep"  */ struct ExecuteLocalVars {     uint256 minActionAmountToTopUp;     uint256 actionTokenAmount;     uint256 depositTotalFeesAmount;     uint256 actionAmountWithFees;     uint256 userFactor;     uint256 rate;     uint256 depositAmountWithFees;     uint256 depositAmountWithoutFees;     uint256 actionFee;     uint256 totalActionTokenAmount;     uint128 totalTopUpAmount;     bool topupResult;     uint256 gasBankBalance;     uint256 initialGas;     uint256 gasConsumed;     uint256 userGasPrice;     uint256 estimatedRequiredGas;     uint256 estimatedRequiredWeiForGas;     uint256 requiredWeiForGas;     uint256 reimbursedWeiForGas;     address underlying;     bool removePosition;     address topUpHandler; }  EnumerableSet.AddressSet private _usableTokens;  uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 550_000;  bytes32 internal constant _ACTION_FEE_KEY = "ActionFee"; bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler"; bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler"; bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";  uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;  IController public immutable controller; IAddressProvider public immutable addressProvider;  EnumerableSet.Bytes32Set internal _supportedProtocols;  /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record) mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;  mapping(address =&gt; RecordMeta[]) internal _userPositions;  EnumerableSet.AddressSet internal _usersWithPositions;  constructor(IController _controller)     Authorization(_controller.addressProvider().getRoleManager()) {     controller = _controller;     addressProvider = controller.addressProvider();     _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE); }  receive() external payable {     // solhint-disable-previous-line no-empty-blocks }  function initialize(     address feeHandler,     bytes32[] calldata protocols,     address[] calldata handlers ) external initializer onlyGovernance {     require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);     _setConfig(_FEE_HANDLER_KEY, feeHandler);     for (uint256 i; i &lt; protocols.length; i = i.uncheckedInc()) {         bytes32 protocolKey = _getProtocolKey(protocols[i]);         _setConfig(protocolKey, handlers[i]);         _updateTopUpHandler(protocols[i], address(0), handlers[i]);     } }  /**  * @notice Register a top up action.  * @dev The `depositAmount`, once converted to units of `actionToken`, must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).  * @param account Account to be topped up (first 20 bytes will typically be the address).  * @param protocol Protocol which holds position to be topped up.  * @param depositAmount Amount of `depositToken` that will be locked.  * @param record containing the data for the position to register  */ function register(     bytes32 account,     bytes32 protocol,     uint128 depositAmount,     Record memory record ) external payable override returns (bool) {     require(record.maxFee != 0, Error.INVALID_MAX_FEE);     require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);     require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);     require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);     require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);     require(         _positions[msg.sender][account][protocol].threshold == 0,         Error.POSITION_ALREADY_EXISTS     );     require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);     require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);      uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *         record.maxFee *         getEstimatedGasUsage();      require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);      uint256 totalLockAmount = _calcExchangeAmount(         record.depositToken,         record.actionToken,         record.totalTopUpAmount     );     _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);      addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);      record.registeredAt = uint64(block.timestamp);     record.depositTokenBalance = totalLockAmount.toUint128();     _positions[msg.sender][account][protocol] = record;     _userPositions[msg.sender].push(RecordMeta(account, protocol));     _usersWithPositions.add(msg.sender);      emit Register(         account,         protocol,         record.threshold,         msg.sender,         record.depositToken,         totalLockAmount,         record.actionToken,         record.singleTopUpAmount,         record.totalTopUpAmount,         record.maxFee,         record.extra     );     return true; }  /**  * @notice See overloaded version of `execute` for more details.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol ) external override returns (bool) {     return execute(payer, account, beneficiary, protocol, 0); }  /**  * @notice Delete a position to back on the given protocol for `account`.  * @param account Account holding the position.  * @param protocol Protocol the position is held on.  * @param unstake If the tokens should be unstaked from vault.  * @return `true` if successful.  */ function resetPosition(     bytes32 account,     bytes32 protocol,     bool unstake ) external override returns (bool) {     address payer = msg.sender;     Record memory position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);      IAddressProvider addressProvider_ = addressProvider;     address vault = addressProvider_.getStakerVault(position.depositToken); // will revert if vault does not exist     IStakerVault staker = IStakerVault(vault);     staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);     if (unstake) {         staker.unstake(position.depositTokenBalance);         IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);     } else {         staker.transfer(payer, position.depositTokenBalance);     }      _removePosition(payer, account, protocol);     addressProvider_.getGasBank().withdrawUnused(payer);     return true; }  /**  * @notice Execute top up handler update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @param protocol Protocol for which a new handler should be executed.  * @return Address of new handler.  */ function executeTopUpHandler(bytes32 protocol) external override returns (address) {     address oldHandler = _getHandler(protocol, false);     address newHandler = _executeAddress(_getProtocolKey(protocol));      _updateTopUpHandler(protocol, oldHandler, newHandler);     return newHandler; }  /**  * @notice Reset new top up handler deadline for a protocol.  * @param protocol Protocol for which top up handler deadline should be reset.  * @return `true` if successful.  */ function resetTopUpHandler(bytes32 protocol) external override onlyGovernance returns (bool) {     return _resetAddressConfig(_getProtocolKey(protocol)); }  /**  * @notice Prepare action fee update.  * @param newActionFee New fee to set.  * @return `true` if success.  */ function prepareActionFee(uint256 newActionFee)     external     override     onlyGovernance     returns (bool) {     require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);     return _prepare(_ACTION_FEE_KEY, newActionFee); }  /**  * @notice Execute action fee update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeActionFee() external override returns (uint256) {     return _executeUInt256(_ACTION_FEE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetActionFee() external override onlyGovernance returns (bool) {     return _resetUInt256Config(_ACTION_FEE_KEY); }  /** Set fee handler */ /**  * @notice Prepare update of fee handler.  * @param handler New fee handler.  * @return `true` if success.  */ function prepareFeeHandler(address handler) external override onlyGovernance returns (bool) {     return _prepare(_FEE_HANDLER_KEY, handler); }  /**  * @notice Execute update of fee handler (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeFeeHandler() external override returns (address) {     return _executeAddress(_FEE_HANDLER_KEY); }  /**  * @notice Reset the handler deadline.  * @return `true` if success.  */ function resetFeeHandler() external override onlyGovernance returns (bool) {     return _resetAddressConfig(_FEE_HANDLER_KEY); }  /**  * @notice Prepare update of estimated gas usage.  * @param gasUsage New estimated gas usage.  * @return `true` if success.  */ function prepareEstimatedGasUsage(uint256 gasUsage)     external     override     onlyGovernance     returns (bool) {     return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage); }  /**  * @notice Execute update of gas usage (with time delay enforced).  * @return `true` if successful.  */ function executeEstimatedGasUsage() external override returns (uint256) {     return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Reset the gas usage deadline.  * @return `true` if success.  */ function resetGasUsage() external override onlyGovernance returns (bool) {     return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Add a new deposit token that is supported by the action.  * @dev There is a separate check for whether the usable token (i.e. deposit token)  *      is swappable for some action token.  * @param token Address of deposit token that can be used by the action.  */ function addUsableToken(address token) external override onlyGovernance returns (bool) {     return _usableTokens.add(token); }  /**  * @notice Computes the total amount of ETH (as wei) required to pay for all  * the top-ups assuming the maximum gas price and the current estimated gas  * usage of a top-up  */ function getEthRequiredForGas(address payer) external view override returns (uint256) {     uint256 totalEthRequired;     RecordMeta[] memory userRecordsMeta = _userPositions[payer];     uint256 gasUsagePerCall = getEstimatedGasUsage();     uint256 length = userRecordsMeta.length;     for (uint256 i; i &lt; length; i = i.uncheckedInc()) {         RecordMeta memory meta = userRecordsMeta[i];         Record memory record = _positions[payer][meta.account][meta.protocol];         uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);         totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;     }     return totalEthRequired; }  /**  * @notice Returns a list of positions for the given payer  */ function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {     return _userPositions[payer]; }  /**  * @notice Get a list supported protocols.  * @return List of supported protocols.  */ function getSupportedProtocols() external view override returns (bytes32[] memory) {     uint256 length = _supportedProtocols.length();     bytes32[] memory protocols = new bytes32[](length);     for (uint256 i; i &lt; length; i = i.uncheckedInc()) {         protocols[i] = _supportedProtocols.at(i);     }     return protocols; }  /*  * @notice Gets a list of users that have an active position.  * @dev Uses cursor pagination.  * @param cursor The cursor for pagination (should start at 0 for first call).  * @param howMany Maximum number of users to return in this pagination request.  * @return users List of users that have an active position.  * @return nextCursor The cursor to use for the next pagination request.  */ function usersWithPositions(uint256 cursor, uint256 howMany)     external     view     override     returns (address[] memory users, uint256 nextCursor) {     uint256 length = _usersWithPositions.length();     if (cursor &gt;= length) return (new address[](0), 0);     if (howMany &gt;= length - cursor) {         howMany = length - cursor;     }      address[] memory usersWithPositions_ = new address[](howMany);     for (uint256 i; i &lt; howMany; i = i.uncheckedInc()) {         usersWithPositions_[i] = _usersWithPositions.at(i + cursor);     }      return (usersWithPositions_, cursor + howMany); }  /**  * @notice Get a list of all tokens usable for this action.  * @dev This refers to all tokens that can be used as deposit tokens.  * @return Array of addresses of usable tokens.  */ function getUsableTokens() external view override returns (address[] memory) {     return _usableTokens.toArray(); }  /**  * @notice Retrieves the topup handler for the given `protocol`  */ function getTopUpHandler(bytes32 protocol) external view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice Successfully tops up a position if it's conditions are met.  * @dev pool and vault funds are rebalanced after withdrawal for top up  * @param payer Account that pays for the top up.  * @param account Account owning the position for top up.  * @param beneficiary Address of the keeper's wallet for fee accrual.  * @param protocol Protocol of the top up position.  * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas  * @return `true` if successful.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol,     uint256 maxWeiForGas ) public override returns (bool) {     require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);      ExecuteLocalVars memory vars;      vars.initialGas = gasleft();      Record storage position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);     require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);     require(block.timestamp &gt; position.registeredAt, Error.CANNOT_EXECUTE_IN_SAME_BLOCK);      vars.topUpHandler = _getHandler(protocol, true);     vars.userFactor = ITopUpHandler(vars.topUpHandler).getUserFactor(account, position.extra);      // ensure that the position is actually below its set user factor threshold     require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);      IAddressProvider addressProvider_ = addressProvider;     IGasBank gasBank = addressProvider_.getGasBank();      // fail early if the user does not have enough funds in the gas bank     // to cover the cost of the transaction     vars.estimatedRequiredGas = getEstimatedGasUsage();     vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;      // compute the gas price that the user will be paying     vars.userGasPrice = block.basefee + position.priorityFee;     if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;     if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;      // ensure the current position allows for the gas to be paid     require(         vars.estimatedRequiredWeiForGas &lt;=             vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,         Error.ESTIMATED_GAS_TOO_HIGH     );      vars.gasBankBalance = gasBank.balanceOf(payer);     // ensure the user has enough funds in the gas bank to cover the gas     require(         vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,         Error.GAS_BANK_BALANCE_TOO_LOW     );      vars.totalTopUpAmount = position.totalTopUpAmount;     vars.actionFee = getActionFee();     // add top-up fees to top-up amount     vars.minActionAmountToTopUp = position.singleTopUpAmount;     vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(         ScaledMath.ONE + vars.actionFee     );      // if the amount that we want to top-up (including fees) is higher than     // the available topup amount, we lower this down to what is left of the position     if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {         vars.actionAmountWithFees = vars.totalTopUpAmount;         vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(             ScaledMath.ONE + vars.actionFee         );     }     ILiquidityPool pool = addressProvider_.getPoolForToken(position.depositToken);     vars.underlying = pool.getUnderlying();     vars.rate = pool.exchangeRate();      // compute the deposit tokens amount with and without fees     // we will need to unstake the amount with fees and to     // swap the amount without fees into action tokens     vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);     if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {         vars.depositAmountWithFees = position.depositTokenBalance;         vars.minActionAmountToTopUp =             (vars.depositAmountWithFees * vars.rate) /             (ScaledMath.ONE + vars.actionFee);     }      // compute amount of LP tokens needed to pay for action     // rate is expressed in actionToken per depositToken     vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);     vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;      // will revert if vault does not exist     address vault = addressProvider_.getStakerVault(position.depositToken);      // unstake deposit tokens including fees     IStakerVault(vault).unstake(vars.depositAmountWithFees);     IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);      // swap the amount without the fees     // as the fees are paid in deposit token, not in action token     vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);      // compute how much of action token was actually redeemed and add fees to it     // this is to ensure that no funds get locked inside the contract     vars.totalActionTokenAmount =         vars.actionTokenAmount +         vars.depositTotalFeesAmount.scaledMul(vars.rate);      // at this point, we have exactly `vars.actionTokenAmount`     // (at least `position.singleTopUpAmount`) of action token     // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract     // solhint-disable-next-line avoid-low-level-calls     uint256 value_;     if (position.actionToken == address(0)) {         value_ = vars.actionTokenAmount;     } else {         _approve(position.actionToken, vars.topUpHandler);     }     vars.topupResult = ITopUpHandler(vars.topUpHandler).topUp{value: value_}(         account,         position.actionToken,         vars.actionTokenAmount,         position.extra     );      require(vars.topupResult, Error.TOP_UP_FAILED);      // totalTopUpAmount is updated to reflect the new "balance" of the position     if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {         position.totalTopUpAmount -= vars.totalActionTokenAmount.toUint128();     } else {         position.totalTopUpAmount = 0;     }      position.depositTokenBalance -= vars.depositAmountWithFees.toUint128();      vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;     _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);     if (vars.removePosition) {         if (position.depositTokenBalance &gt; 0) {             // transfer any unused locked tokens to the payer             IStakerVault(vault).transfer(payer, position.depositTokenBalance);             IStakerVault(vault).decreaseActionLockedBalance(                 payer,                 position.depositTokenBalance             );         }         _removePosition(payer, account, protocol);     }      emit TopUp(         account,         protocol,         payer,         position.depositToken,         vars.depositAmountWithFees,         position.actionToken,         vars.actionTokenAmount     );      // compute gas used and reimburse the keeper by using the     // funds of payer in the gas bank     // TODO: add constant gas consumed for transfer and tx prologue     vars.gasConsumed = vars.initialGas - gasleft();      vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;     if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {         vars.reimbursedWeiForGas = vars.gasBankBalance;     }      // ensure that the keeper is not overpaying     vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;     require(         vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,         Error.GAS_TOO_HIGH     );     gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);     if (vars.removePosition) {         gasBank.withdrawUnused(payer);     }      return true; }  /**  * @notice Prepare new top up handler fee update.  * @dev Setting the address to 0 means that the protocol will no longer be supported.  * @param protocol Protocol for which a new handler should be prepared.  * @param newHandler Address of new handler.  * @return `true` if success.  */ function prepareTopUpHandler(bytes32 protocol, address newHandler)     public     override     onlyGovernance     returns (bool) {     return _prepare(_getProtocolKey(protocol), newHandler); }  /**  * @notice Check if action can be executed.  * @param protocol for which to get the health factor  * @param account for which to get the health factor  * @param extra data to be used by the topup handler  * @return healthFactor of the position  */ function getHealthFactor(     bytes32 protocol,     bytes32 account,     bytes calldata extra ) public view override returns (uint256 healthFactor) {     ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));     return topUpHandler.getUserFactor(account, extra); }  function getHandler(bytes32 protocol) public view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice returns the current estimated gas usage  */ function getEstimatedGasUsage() public view override returns (uint256) {     return currentUInts256[_ESTIMATED_GAS_USAGE_KEY]; }  /**  * @notice Returns the current action fee  */ function getActionFee() public view override returns (uint256) {     return currentUInts256[_ACTION_FEE_KEY]; }  /**  * @notice Returns the current fee handler  */ function getFeeHandler() public view override returns (address) {     return currentAddresses[_FEE_HANDLER_KEY]; }  /**  * @notice Get the record for a position.  * @param payer Registered payer of the position.  * @param account Address holding the position.  * @param protocol Protocol where the position is held.  */ function getPosition(     address payer,     bytes32 account,     bytes32 protocol ) public view override returns (Record memory) {     return _positions[payer][account][protocol]; }  /**  * @notice Check whether a token is usable as a deposit token.  * @param token Address of token to check.  * @return True if token is usable as a deposit token for this action.  */ function isUsable(address token) public view override returns (bool) {     return _usableTokens.contains(token); }  function _updateTopUpHandler(     bytes32 protocol,     address oldHandler,     address newHandler ) internal {     if (newHandler == address(0)) {         _supportedProtocols.remove(protocol);     } else if (oldHandler == address(0)) {         _supportedProtocols.add(protocol);     } }  /**  * @dev Pays fees to the feeHandler  * @param payer The account who's position the fees are charged on  * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)  * @param feeAmount The amount in tokens to pay as fees  * @param depositToken The LpToken used to pay the fees  */ function _payFees(     address payer,     address beneficiary,     uint256 feeAmount,     address depositToken ) internal {     address feeHandler = getFeeHandler();     IERC20(depositToken).safeApprove(feeHandler, feeAmount);     IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken); }  /**  * @dev "Locks" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function _lockFunds(     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) internal {     address stakerVaultAddress = addressProvider.getStakerVault(token);     TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount); }  function _removePosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     delete _positions[payer][account][protocol];     _removeUserPosition(payer, account, protocol);     if (_userPositions[payer].length == 0) {         _usersWithPositions.remove(payer);     }     emit Deregister(payer, account, protocol); }  function _removeUserPosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     RecordMeta[] storage positionsMeta = _userPositions[payer];     uint256 length = positionsMeta.length;     for (uint256 i; i &lt; length; i = i.uncheckedInc()) {         RecordMeta storage positionMeta = positionsMeta[i];         if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {             positionsMeta[i] = positionsMeta[length - 1];             positionsMeta.pop();             return;         }     } }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) internal {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the `actionToken`.  */ function _calcExchangeAmount(     address token,     address actionToken,     uint256 amount ) internal view returns (uint256) {     return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount); }  function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {     address handler = currentAddresses[_getProtocolKey(protocol)];     require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);     return handler; }  function _isSwappable(address depositToken, address toToken) internal view returns (bool) {     ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);     return pool.getUnderlying() == toToken; }  function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {     return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol)); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 12:30:03 INFO] Counselor: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.10;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";
import "@openzeppelin/contracts/utils/math/SafeCast.sol";

import "../../../interfaces/IGasBank.sol";
import "../../../interfaces/pool/ILiquidityPool.sol";
import "../../../interfaces/IController.sol";
import "../../../interfaces/IStakerVault.sol";
import "../../../interfaces/actions/topup/ITopUpHandler.sol";
import "../../../interfaces/actions/topup/ITopUpAction.sol";
import "../../../interfaces/actions/IActionFeeHandler.sol";

import "../../../libraries/AddressProviderHelpers.sol";
import "../../../libraries/Errors.sol";
import "../../../libraries/ScaledMath.sol";
import "../../../libraries/EnumerableExtensions.sol";
import "../../../libraries/UncheckedMath.sol";

import "../../access/Authorization.sol";
import "../../utils/Preparable.sol";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param stakerVaultAddress The address of the staker vault
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > lockAmount ? lockAmount : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            _approve(token, stakerVaultAddress);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            lockAmount -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (lockAmount > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= lockAmount) {
                stakerVault.transferFrom(payer, address(this), lockAmount);
                stakerVault.increaseActionLockedBalance(payer, lockAmount);
                lockAmount = 0;
            }
        }

        require(lockAmount == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        require(underlying == actionToken, Error.TOKEN_NOT_USABLE);
        return amount.scaledDivRoundUp(rate);
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) private {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using UncheckedMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;
    using SafeCast for uint256;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being "too deep"
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
        address topUpHandler;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 550_000;

    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";
    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        for (uint256 i; i < protocols.length; i = i.uncheckedInc()) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount`, once converted to units of `actionToken`, must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param protocol Protocol which holds position to be topped up.
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable override returns (bool) {
        require(record.maxFee != 0, Error.INVALID_MAX_FEE);
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.registeredAt = uint64(block.timestamp);
        record.depositTokenBalance = totalLockAmount.toUint128();
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        IAddressProvider addressProvider_ = addressProvider;
        address vault = addressProvider_.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider_.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external override onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee)
        external
        override
        onlyGovernance
        returns (bool)
    {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external override onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external override onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external override onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage)
        external
        override
        onlyGovernance
        returns (bool)
    {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external override returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external override onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i; i < howMany; i = i.uncheckedInc()) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);
        require(block.timestamp > position.registeredAt, Error.CANNOT_EXECUTE_IN_SAME_BLOCK);

        vars.topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(vars.topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IAddressProvider addressProvider_ = addressProvider;
        IGasBank gasBank = addressProvider_.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider_.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider_.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        uint256 value_;
        if (position.actionToken == address(0)) {
            value_ = vars.actionTokenAmount;
        } else {
            _approve(position.actionToken, vars.topUpHandler);
        }
        vars.topupResult = ITopUpHandler(vars.topUpHandler).topUp{value: value_}(
            account,
            position.actionToken,
            vars.actionTokenAmount,
            position.extra
        );

        require(vars.topupResult, Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new "balance" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= vars.totalActionTokenAmount.toUint128();
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= vars.depositAmountWithFees.toUint128();

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the address to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        override
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes calldata extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view override returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the `actionToken`.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        return pool.getUnderlying() == toToken;
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
.]

Here is a conversation between two roles: Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.10;
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";
import "@openzeppelin/contracts/utils/math/SafeCast.sol";
import "../../../interfaces/IGasBank.sol";
import "../../../interfaces/pool/ILiquidityPool.sol";
import "../../../interfaces/IController.sol";
import "../../../interfaces/IStakerVault.sol";
import "../../../interfaces/actions/topup/ITopUpHandler.sol";
import "../../../interfaces/actions/topup/ITopUpAction.sol";
import "../../../interfaces/actions/IActionFeeHandler.sol";
import "../../../libraries/AddressProviderHelpers.sol";
import "../../../libraries/Errors.sol";
import "../../../libraries/ScaledMath.sol";
import "../../../libraries/EnumerableExtensions.sol";
import "../../../libraries/UncheckedMath.sol";
import "../../access/Authorization.sol";
import "../../utils/Preparable.sol";
/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;
    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param stakerVaultAddress The address of the staker vault
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);
        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > lockAmount ? lockAmount : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            _approve(token, stakerVaultAddress);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            lockAmount -= depositAmount;
        }
        // use stake vault allowance if available and required
        if (lockAmount > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= lockAmount) {
                stakerVault.transferFrom(payer, address(this), lockAmount);
                stakerVault.increaseActionLockedBalance(payer, lockAmount);
                lockAmount = 0;
            }
        }
        require(lockAmount == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }
    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        require(underlying == actionToken, Error.TOKEN_NOT_USABLE);
        return amount.scaledDivRoundUp(rate);
    }
    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) private {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }
}
contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using UncheckedMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;
    using SafeCast for uint256;
    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being "too deep"
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
        address topUpHandler;
    }
    EnumerableSet.AddressSet private _usableTokens;
    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 550_000;
    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";
    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";
    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;
    IController public immutable controller;
    IAddressProvider public immutable addressProvider;
    EnumerableSet.Bytes32Set internal _supportedProtocols;
    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;
    mapping(address => RecordMeta[]) internal _userPositions;
    EnumerableSet.AddressSet internal _usersWithPositions;
    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }
    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }
    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        for (uint256 i; i < protocols.length; i = i.uncheckedInc()) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }
    /**
     * @notice Register a top up action.
     * @dev The `depositAmount`, once converted to units of `actionToken`, must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param protocol Protocol which holds position to be topped up.
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable override returns (bool) {
        require(record.maxFee != 0, Error.INVALID_MAX_FEE);
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);
        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();
        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);
        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);
        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);
        record.registeredAt = uint64(block.timestamp);
        record.depositTokenBalance = totalLockAmount.toUint128();
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);
        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }
    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }
    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        IAddressProvider addressProvider_ = addressProvider;
        address vault = addressProvider_.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }
        _removePosition(payer, account, protocol);
        addressProvider_.getGasBank().withdrawUnused(payer);
        return true;
    }
    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));
        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }
    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external override onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }
    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee)
        external
        override
        onlyGovernance
        returns (bool)
    {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }
    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }
    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external override onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }
    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external override onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }
    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }
    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external override onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }
    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage)
        external
        override
        onlyGovernance
        returns (bool)
    {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }
    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external override returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }
    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external override onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }
    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }
    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }
    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }
    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }
    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }
        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i; i < howMany; i = i.uncheckedInc()) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }
        return (usersWithPositions_, cursor + howMany);
    }
    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }
    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view override returns (address) {
        return _getHandler(protocol, false);
    }
    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);
        ExecuteLocalVars memory vars;
        vars.initialGas = gasleft();
        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);
        require(block.timestamp > position.registeredAt, Error.CANNOT_EXECUTE_IN_SAME_BLOCK);
        vars.topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(vars.topUpHandler).getUserFactor(account, position.extra);
        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);
        IAddressProvider addressProvider_ = addressProvider;
        IGasBank gasBank = addressProvider_.getGasBank();
        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;
        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;
        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );
        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );
        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );
        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider_.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();
        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }
        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;
        // will revert if vault does not exist
        address vault = addressProvider_.getStakerVault(position.depositToken);
        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);
        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);
        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);
        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        uint256 value_;
        if (position.actionToken == address(0)) {
            value_ = vars.actionTokenAmount;
        } else {
            _approve(position.actionToken, vars.topUpHandler);
        }
        vars.topupResult = ITopUpHandler(vars.topUpHandler).topUp{value: value_}(
            account,
            position.actionToken,
            vars.actionTokenAmount,
            position.extra
        );
        require(vars.topupResult, Error.TOP_UP_FAILED);
        // totalTopUpAmount is updated to reflect the new "balance" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= vars.totalActionTokenAmount.toUint128();
        } else {
            position.totalTopUpAmount = 0;
        }
        position.depositTokenBalance -= vars.depositAmountWithFees.toUint128();
        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }
        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );
        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();
        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }
        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }
        return true;
    }
    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the address to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        override
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }
    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes calldata extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }
    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }
    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view override returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }
    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }
    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }
    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }
    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }
    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }
    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }
    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }
    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }
    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }
    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }
    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the `actionToken`.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }
    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }
    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        return pool.getUnderlying() == toToken;
    }
    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
.

Chief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.
Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.10;
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";
import "@openzeppelin/contracts/utils/math/SafeCast.sol";
import "../../../interfaces/IGasBank.sol";
import "../../../interfaces/pool/ILiquidityPool.sol";
import "../../../interfaces/IController.sol";
import "../../../interfaces/IStakerVault.sol";
import "../../../interfaces/actions/topup/ITopUpHandler.sol";
import "../../../interfaces/actions/topup/ITopUpAction.sol";
import "../../../interfaces/actions/IActionFeeHandler.sol";
import "../../../libraries/AddressProviderHelpers.sol";
import "../../../libraries/Errors.sol";
import "../../../libraries/ScaledMath.sol";
import "../../../libraries/EnumerableExtensions.sol";
import "../../../libraries/UncheckedMath.sol";
import "../../access/Authorization.sol";
import "../../utils/Preparable.sol";
/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;
    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param stakerVaultAddress The address of the staker vault
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);
        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > lockAmount ? lockAmount : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            _approve(token, stakerVaultAddress);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            lockAmount -= depositAmount;
        }
        // use stake vault allowance if available and required
        if (lockAmount > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= lockAmount) {
                stakerVault.transferFrom(payer, address(this), lockAmount);
                stakerVault.increaseActionLockedBalance(payer, lockAmount);
                lockAmount = 0;
            }
        }
        require(lockAmount == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }
    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        require(underlying == actionToken, Error.TOKEN_NOT_USABLE);
        return amount.scaledDivRoundUp(rate);
    }
    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) private {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }
}
contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using UncheckedMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;
    using SafeCast for uint256;
    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being "too deep"
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
        address topUpHandler;
    }
    EnumerableSet.AddressSet private _usableTokens;
    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 550_000;
    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";
    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";
    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;
    IController public immutable controller;
    IAddressProvider public immutable addressProvider;
    EnumerableSet.Bytes32Set internal _supportedProtocols;
    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;
    mapping(address => RecordMeta[]) internal _userPositions;
    EnumerableSet.AddressSet internal _usersWithPositions;
    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }
    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }
    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        for (uint256 i; i < protocols.length; i = i.uncheckedInc()) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }
    /**
     * @notice Register a top up action.
     * @dev The `depositAmount`, once converted to units of `actionToken`, must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param protocol Protocol which holds position to be topped up.
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable override returns (bool) {
        require(record.maxFee != 0, Error.INVALID_MAX_FEE);
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);
        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();
        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);
        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);
        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);
        record.registeredAt = uint64(block.timestamp);
        record.depositTokenBalance = totalLockAmount.toUint128();
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);
        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }
    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }
    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        IAddressProvider addressProvider_ = addressProvider;
        address vault = addressProvider_.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }
        _removePosition(payer, account, protocol);
        addressProvider_.getGasBank().withdrawUnused(payer);
        return true;
    }
    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));
        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }
    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external override onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }
    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee)
        external
        override
        onlyGovernance
        returns (bool)
    {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }
    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }
    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external override onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }
    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external override onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }
    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }
    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external override onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }
    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage)
        external
        override
        onlyGovernance
        returns (bool)
    {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }
    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external override returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }
    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external override onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }
    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }
    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }
    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }
    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }
    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }
        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i; i < howMany; i = i.uncheckedInc()) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }
        return (usersWithPositions_, cursor + howMany);
    }
    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }
    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view override returns (address) {
        return _getHandler(protocol, false);
    }
    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);
        ExecuteLocalVars memory vars;
        vars.initialGas = gasleft();
        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);
        require(block.timestamp > position.registeredAt, Error.CANNOT_EXECUTE_IN_SAME_BLOCK);
        vars.topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(vars.topUpHandler).getUserFactor(account, position.extra);
        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);
        IAddressProvider addressProvider_ = addressProvider;
        IGasBank gasBank = addressProvider_.getGasBank();
        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;
        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;
        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );
        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );
        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );
        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider_.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();
        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }
        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;
        // will revert if vault does not exist
        address vault = addressProvider_.getStakerVault(position.depositToken);
        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);
        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);
        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);
        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        uint256 value_;
        if (position.actionToken == address(0)) {
            value_ = vars.actionTokenAmount;
        } else {
            _approve(position.actionToken, vars.topUpHandler);
        }
        vars.topupResult = ITopUpHandler(vars.topUpHandler).topUp{value: value_}(
            account,
            position.actionToken,
            vars.actionTokenAmount,
            position.extra
        );
        require(vars.topupResult, Error.TOP_UP_FAILED);
        // totalTopUpAmount is updated to reflect the new "balance" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= vars.totalActionTokenAmount.toUint128();
        } else {
            position.totalTopUpAmount = 0;
        }
        position.depositTokenBalance -= vars.depositAmountWithFees.toUint128();
        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }
        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );
        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();
        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }
        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }
        return true;
    }
    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the address to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        override
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }
    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes calldata extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }
    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }
    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view override returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }
    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }
    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }
    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }
    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }
    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }
    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }
    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }
    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }
    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }
    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }
    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the `actionToken`.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }
    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }
    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        return pool.getUnderlying() == toToken;
    }
    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
".
As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.
Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

Security Analyst: Let's analyze the provided Solidity contract code and identify potential improvements or enhancements.
1. **Gas Optimization**: The contract has several places where gas consumption could be reduced. For example, in the `execute` function, the calculation of `vars.estimatedRequiredWeiForGas` and `vars.userGasPrice` could be optimized to avoid redundant calculations. We could also consider caching frequently accessed values to minimize storage reads.
2. **Error Handling**: The contract uses require statements for error handling, which is good, but we could enhance the error messages to provide more context. This would help in debugging and understanding the failure points better.
3. **Reentrancy Guard**: Although the contract uses SafeERC20 for token transfers, we should consider implementing a reentrancy guard on critical functions like `execute` and `register`. This would prevent potential reentrancy attacks, especially since the contract interacts with external contracts.
4. **Event Emission**: The contract emits events for significant actions, but we could enhance this by adding more events for actions like `resetPosition` and `prepareTopUpHandler`. This would improve transparency and allow for better tracking of contract interactions.
5. **Access Control**: The contract uses a governance mechanism for certain functions. We could consider implementing a multi-signature wallet for critical functions to enhance security and ensure that no single entity has control over significant actions.
6. **Upgradeability**: Since the contract uses OpenZeppelin's Initializable, we should ensure that all upgradeable patterns are followed correctly. It might be beneficial to include a function to pause the contract in emergencies, which can be controlled by governance.
7. **Testing and Auditing**: While this is more of a process improvement, ensuring that the contract undergoes thorough testing, including unit tests and integration tests, is crucial. Additionally, a third-party audit would provide an extra layer of security assurance.
8. **Documentation**: Improving inline documentation and comments throughout the code would help future developers understand the logic and purpose of various functions and variables.
Which of these suggestions resonates most with you, or do you have any other specific areas you would like to focus on? Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" 

[2024-01-09 12:30:07 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 12:30:07 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 23460
completion_tokens: 1
total_tokens: 23461
cost: $-1.000000


[2024-01-09 12:30:07 INFO] Chief Executive Officer: **Chief Executive Officer<->Counselor on : Reflection, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your main responsibilities include asking what user and customer think and provide your valuable suggestions. 
Here is a new customer's task: // SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.10;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";
import "@openzeppelin/contracts/utils/math/SafeCast.sol";

import "../../../interfaces/IGasBank.sol";
import "../../../interfaces/pool/ILiquidityPool.sol";
import "../../../interfaces/IController.sol";
import "../../../interfaces/IStakerVault.sol";
import "../../../interfaces/actions/topup/ITopUpHandler.sol";
import "../../../interfaces/actions/topup/ITopUpAction.sol";
import "../../../interfaces/actions/IActionFeeHandler.sol";

import "../../../libraries/AddressProviderHelpers.sol";
import "../../../libraries/Errors.sol";
import "../../../libraries/ScaledMath.sol";
import "../../../libraries/EnumerableExtensions.sol";
import "../../../libraries/UncheckedMath.sol";

import "../../access/Authorization.sol";
import "../../utils/Preparable.sol";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param stakerVaultAddress The address of the staker vault
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > lockAmount ? lockAmount : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            _approve(token, stakerVaultAddress);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            lockAmount -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (lockAmount > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= lockAmount) {
                stakerVault.transferFrom(payer, address(this), lockAmount);
                stakerVault.increaseActionLockedBalance(payer, lockAmount);
                lockAmount = 0;
            }
        }

        require(lockAmount == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        require(underlying == actionToken, Error.TOKEN_NOT_USABLE);
        return amount.scaledDivRoundUp(rate);
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) private {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using UncheckedMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;
    using SafeCast for uint256;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being "too deep"
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
        address topUpHandler;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 550_000;

    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";
    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        for (uint256 i; i < protocols.length; i = i.uncheckedInc()) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount`, once converted to units of `actionToken`, must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param protocol Protocol which holds position to be topped up.
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable override returns (bool) {
        require(record.maxFee != 0, Error.INVALID_MAX_FEE);
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.registeredAt = uint64(block.timestamp);
        record.depositTokenBalance = totalLockAmount.toUint128();
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        IAddressProvider addressProvider_ = addressProvider;
        address vault = addressProvider_.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider_.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external override onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee)
        external
        override
        onlyGovernance
        returns (bool)
    {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external override onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external override onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external override onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage)
        external
        override
        onlyGovernance
        returns (bool)
    {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external override returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external override onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i; i < howMany; i = i.uncheckedInc()) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);
        require(block.timestamp > position.registeredAt, Error.CANNOT_EXECUTE_IN_SAME_BLOCK);

        vars.topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(vars.topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IAddressProvider addressProvider_ = addressProvider;
        IGasBank gasBank = addressProvider_.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider_.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider_.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        uint256 value_;
        if (position.actionToken == address(0)) {
            value_ = vars.actionTokenAmount;
        } else {
            _approve(position.actionToken, vars.topUpHandler);
        }
        vars.topupResult = ITopUpHandler(vars.topUpHandler).topUp{value: value_}(
            account,
            position.actionToken,
            vars.actionTokenAmount,
            position.extra
        );

        require(vars.topupResult, Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new "balance" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= vars.totalActionTokenAmount.toUint128();
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= vars.depositAmountWithFees.toUint128();

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the address to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        override
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes calldata extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view override returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the `actionToken`.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        return pool.getUnderlying() == toToken;
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
.]

1

[2024-01-09 12:30:07 INFO] **[Seminar Conclusion]**:

 1

[2024-01-09 12:30:07 INFO] **[Seminar Conclusion]**:

 <INFO> 1

[2024-01-09 12:30:07 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 1

[2024-01-09 12:30:07 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.10; import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol"; import "@openzeppelin/contracts/utils/math/SafeCast.sol"; import "../../../interfaces/IGasBank.sol"; import "../../../interfaces/pool/ILiquidityPool.sol"; import "../../../interfaces/IController.sol"; import "../../../interfaces/IStakerVault.sol"; import "../../../interfaces/actions/topup/ITopUpHandler.sol"; import "../../../interfaces/actions/topup/ITopUpAction.sol"; import "../../../interfaces/actions/IActionFeeHandler.sol"; import "../../../libraries/AddressProviderHelpers.sol"; import "../../../libraries/Errors.sol"; import "../../../libraries/ScaledMath.sol"; import "../../../libraries/EnumerableExtensions.sol"; import "../../../libraries/UncheckedMath.sol"; import "../../access/Authorization.sol"; import "../../utils/Preparable.sol"; /*  * @notice The logic here should really be part of the top-up action  * but is split in a library to circumvent the byte-code size limit  / library TopUpActionLibrary {     using SafeERC20 for IERC20;     using ScaledMath for uint256;     using AddressProviderHelpers for IAddressProvider; /**  * @dev "Locks" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param stakerVaultAddress The address of the staker vault  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function lockFunds(     address stakerVaultAddress,     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) external {     IStakerVault stakerVault = IStakerVault(stakerVaultAddress);      // stake deposit amount     if (depositAmount &gt; 0) {         depositAmount = depositAmount &gt; lockAmount ? lockAmount : depositAmount;         IERC20(token).safeTransferFrom(payer, address(this), depositAmount);         _approve(token, stakerVaultAddress);         stakerVault.stake(depositAmount);         stakerVault.increaseActionLockedBalance(payer, depositAmount);         lockAmount -= depositAmount;     }      // use stake vault allowance if available and required     if (lockAmount &gt; 0) {         uint256 balance = stakerVault.balanceOf(payer);         uint256 allowance = stakerVault.allowance(payer, address(this));         uint256 availableFunds = balance &lt; allowance ? balance : allowance;         if (availableFunds &gt;= lockAmount) {             stakerVault.transferFrom(payer, address(this), lockAmount);             stakerVault.increaseActionLockedBalance(payer, lockAmount);             lockAmount = 0;         }     }      require(lockAmount == 0, Error.INSUFFICIENT_UPDATE_BALANCE); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function calcExchangeAmount(     IAddressProvider addressProvider,     address token,     address actionToken,     uint256 amount ) external view returns (uint256) {     ILiquidityPool pool = addressProvider.getPoolForToken(token);     uint256 rate = pool.exchangeRate();     address underlying = pool.getUnderlying();     require(underlying == actionToken, Error.TOKEN_NOT_USABLE);     return amount.scaledDivRoundUp(rate); }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) private {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  } contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {     using ScaledMath for uint256;     using UncheckedMath for uint256;     using ScaledMath for uint128;     using SafeERC20 for IERC20;     using EnumerableSet for EnumerableSet.AddressSet;     using EnumerableSet for EnumerableSet.Bytes32Set;     using EnumerableExtensions for EnumerableSet.AddressSet;     using AddressProviderHelpers for IAddressProvider;     using SafeCast for uint256; /**  * @dev Temporary struct to hold local variables in execute  * and avoid the stack being "too deep"  */ struct ExecuteLocalVars {     uint256 minActionAmountToTopUp;     uint256 actionTokenAmount;     uint256 depositTotalFeesAmount;     uint256 actionAmountWithFees;     uint256 userFactor;     uint256 rate;     uint256 depositAmountWithFees;     uint256 depositAmountWithoutFees;     uint256 actionFee;     uint256 totalActionTokenAmount;     uint128 totalTopUpAmount;     bool topupResult;     uint256 gasBankBalance;     uint256 initialGas;     uint256 gasConsumed;     uint256 userGasPrice;     uint256 estimatedRequiredGas;     uint256 estimatedRequiredWeiForGas;     uint256 requiredWeiForGas;     uint256 reimbursedWeiForGas;     address underlying;     bool removePosition;     address topUpHandler; }  EnumerableSet.AddressSet private _usableTokens;  uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 550_000;  bytes32 internal constant _ACTION_FEE_KEY = "ActionFee"; bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler"; bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler"; bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";  uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;  IController public immutable controller; IAddressProvider public immutable addressProvider;  EnumerableSet.Bytes32Set internal _supportedProtocols;  /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record) mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;  mapping(address =&gt; RecordMeta[]) internal _userPositions;  EnumerableSet.AddressSet internal _usersWithPositions;  constructor(IController _controller)     Authorization(_controller.addressProvider().getRoleManager()) {     controller = _controller;     addressProvider = controller.addressProvider();     _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE); }  receive() external payable {     // solhint-disable-previous-line no-empty-blocks }  function initialize(     address feeHandler,     bytes32[] calldata protocols,     address[] calldata handlers ) external initializer onlyGovernance {     require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);     _setConfig(_FEE_HANDLER_KEY, feeHandler);     for (uint256 i; i &lt; protocols.length; i = i.uncheckedInc()) {         bytes32 protocolKey = _getProtocolKey(protocols[i]);         _setConfig(protocolKey, handlers[i]);         _updateTopUpHandler(protocols[i], address(0), handlers[i]);     } }  /**  * @notice Register a top up action.  * @dev The `depositAmount`, once converted to units of `actionToken`, must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).  * @param account Account to be topped up (first 20 bytes will typically be the address).  * @param protocol Protocol which holds position to be topped up.  * @param depositAmount Amount of `depositToken` that will be locked.  * @param record containing the data for the position to register  */ function register(     bytes32 account,     bytes32 protocol,     uint128 depositAmount,     Record memory record ) external payable override returns (bool) {     require(record.maxFee != 0, Error.INVALID_MAX_FEE);     require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);     require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);     require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);     require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);     require(         _positions[msg.sender][account][protocol].threshold == 0,         Error.POSITION_ALREADY_EXISTS     );     require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);     require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);      uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *         record.maxFee *         getEstimatedGasUsage();      require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);      uint256 totalLockAmount = _calcExchangeAmount(         record.depositToken,         record.actionToken,         record.totalTopUpAmount     );     _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);      addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);      record.registeredAt = uint64(block.timestamp);     record.depositTokenBalance = totalLockAmount.toUint128();     _positions[msg.sender][account][protocol] = record;     _userPositions[msg.sender].push(RecordMeta(account, protocol));     _usersWithPositions.add(msg.sender);      emit Register(         account,         protocol,         record.threshold,         msg.sender,         record.depositToken,         totalLockAmount,         record.actionToken,         record.singleTopUpAmount,         record.totalTopUpAmount,         record.maxFee,         record.extra     );     return true; }  /**  * @notice See overloaded version of `execute` for more details.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol ) external override returns (bool) {     return execute(payer, account, beneficiary, protocol, 0); }  /**  * @notice Delete a position to back on the given protocol for `account`.  * @param account Account holding the position.  * @param protocol Protocol the position is held on.  * @param unstake If the tokens should be unstaked from vault.  * @return `true` if successful.  */ function resetPosition(     bytes32 account,     bytes32 protocol,     bool unstake ) external override returns (bool) {     address payer = msg.sender;     Record memory position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);      IAddressProvider addressProvider_ = addressProvider;     address vault = addressProvider_.getStakerVault(position.depositToken); // will revert if vault does not exist     IStakerVault staker = IStakerVault(vault);     staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);     if (unstake) {         staker.unstake(position.depositTokenBalance);         IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);     } else {         staker.transfer(payer, position.depositTokenBalance);     }      _removePosition(payer, account, protocol);     addressProvider_.getGasBank().withdrawUnused(payer);     return true; }  /**  * @notice Execute top up handler update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @param protocol Protocol for which a new handler should be executed.  * @return Address of new handler.  */ function executeTopUpHandler(bytes32 protocol) external override returns (address) {     address oldHandler = _getHandler(protocol, false);     address newHandler = _executeAddress(_getProtocolKey(protocol));      _updateTopUpHandler(protocol, oldHandler, newHandler);     return newHandler; }  /**  * @notice Reset new top up handler deadline for a protocol.  * @param protocol Protocol for which top up handler deadline should be reset.  * @return `true` if successful.  */ function resetTopUpHandler(bytes32 protocol) external override onlyGovernance returns (bool) {     return _resetAddressConfig(_getProtocolKey(protocol)); }  /**  * @notice Prepare action fee update.  * @param newActionFee New fee to set.  * @return `true` if success.  */ function prepareActionFee(uint256 newActionFee)     external     override     onlyGovernance     returns (bool) {     require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);     return _prepare(_ACTION_FEE_KEY, newActionFee); }  /**  * @notice Execute action fee update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeActionFee() external override returns (uint256) {     return _executeUInt256(_ACTION_FEE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetActionFee() external override onlyGovernance returns (bool) {     return _resetUInt256Config(_ACTION_FEE_KEY); }  /** Set fee handler */ /**  * @notice Prepare update of fee handler.  * @param handler New fee handler.  * @return `true` if success.  */ function prepareFeeHandler(address handler) external override onlyGovernance returns (bool) {     return _prepare(_FEE_HANDLER_KEY, handler); }  /**  * @notice Execute update of fee handler (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeFeeHandler() external override returns (address) {     return _executeAddress(_FEE_HANDLER_KEY); }  /**  * @notice Reset the handler deadline.  * @return `true` if success.  */ function resetFeeHandler() external override onlyGovernance returns (bool) {     return _resetAddressConfig(_FEE_HANDLER_KEY); }  /**  * @notice Prepare update of estimated gas usage.  * @param gasUsage New estimated gas usage.  * @return `true` if success.  */ function prepareEstimatedGasUsage(uint256 gasUsage)     external     override     onlyGovernance     returns (bool) {     return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage); }  /**  * @notice Execute update of gas usage (with time delay enforced).  * @return `true` if successful.  */ function executeEstimatedGasUsage() external override returns (uint256) {     return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Reset the gas usage deadline.  * @return `true` if success.  */ function resetGasUsage() external override onlyGovernance returns (bool) {     return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Add a new deposit token that is supported by the action.  * @dev There is a separate check for whether the usable token (i.e. deposit token)  *      is swappable for some action token.  * @param token Address of deposit token that can be used by the action.  */ function addUsableToken(address token) external override onlyGovernance returns (bool) {     return _usableTokens.add(token); }  /**  * @notice Computes the total amount of ETH (as wei) required to pay for all  * the top-ups assuming the maximum gas price and the current estimated gas  * usage of a top-up  */ function getEthRequiredForGas(address payer) external view override returns (uint256) {     uint256 totalEthRequired;     RecordMeta[] memory userRecordsMeta = _userPositions[payer];     uint256 gasUsagePerCall = getEstimatedGasUsage();     uint256 length = userRecordsMeta.length;     for (uint256 i; i &lt; length; i = i.uncheckedInc()) {         RecordMeta memory meta = userRecordsMeta[i];         Record memory record = _positions[payer][meta.account][meta.protocol];         uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);         totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;     }     return totalEthRequired; }  /**  * @notice Returns a list of positions for the given payer  */ function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {     return _userPositions[payer]; }  /**  * @notice Get a list supported protocols.  * @return List of supported protocols.  */ function getSupportedProtocols() external view override returns (bytes32[] memory) {     uint256 length = _supportedProtocols.length();     bytes32[] memory protocols = new bytes32[](length);     for (uint256 i; i &lt; length; i = i.uncheckedInc()) {         protocols[i] = _supportedProtocols.at(i);     }     return protocols; }  /*  * @notice Gets a list of users that have an active position.  * @dev Uses cursor pagination.  * @param cursor The cursor for pagination (should start at 0 for first call).  * @param howMany Maximum number of users to return in this pagination request.  * @return users List of users that have an active position.  * @return nextCursor The cursor to use for the next pagination request.  */ function usersWithPositions(uint256 cursor, uint256 howMany)     external     view     override     returns (address[] memory users, uint256 nextCursor) {     uint256 length = _usersWithPositions.length();     if (cursor &gt;= length) return (new address[](0), 0);     if (howMany &gt;= length - cursor) {         howMany = length - cursor;     }      address[] memory usersWithPositions_ = new address[](howMany);     for (uint256 i; i &lt; howMany; i = i.uncheckedInc()) {         usersWithPositions_[i] = _usersWithPositions.at(i + cursor);     }      return (usersWithPositions_, cursor + howMany); }  /**  * @notice Get a list of all tokens usable for this action.  * @dev This refers to all tokens that can be used as deposit tokens.  * @return Array of addresses of usable tokens.  */ function getUsableTokens() external view override returns (address[] memory) {     return _usableTokens.toArray(); }  /**  * @notice Retrieves the topup handler for the given `protocol`  */ function getTopUpHandler(bytes32 protocol) external view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice Successfully tops up a position if it's conditions are met.  * @dev pool and vault funds are rebalanced after withdrawal for top up  * @param payer Account that pays for the top up.  * @param account Account owning the position for top up.  * @param beneficiary Address of the keeper's wallet for fee accrual.  * @param protocol Protocol of the top up position.  * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas  * @return `true` if successful.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol,     uint256 maxWeiForGas ) public override returns (bool) {     require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);      ExecuteLocalVars memory vars;      vars.initialGas = gasleft();      Record storage position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);     require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);     require(block.timestamp &gt; position.registeredAt, Error.CANNOT_EXECUTE_IN_SAME_BLOCK);      vars.topUpHandler = _getHandler(protocol, true);     vars.userFactor = ITopUpHandler(vars.topUpHandler).getUserFactor(account, position.extra);      // ensure that the position is actually below its set user factor threshold     require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);      IAddressProvider addressProvider_ = addressProvider;     IGasBank gasBank = addressProvider_.getGasBank();      // fail early if the user does not have enough funds in the gas bank     // to cover the cost of the transaction     vars.estimatedRequiredGas = getEstimatedGasUsage();     vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;      // compute the gas price that the user will be paying     vars.userGasPrice = block.basefee + position.priorityFee;     if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;     if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;      // ensure the current position allows for the gas to be paid     require(         vars.estimatedRequiredWeiForGas &lt;=             vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,         Error.ESTIMATED_GAS_TOO_HIGH     );      vars.gasBankBalance = gasBank.balanceOf(payer);     // ensure the user has enough funds in the gas bank to cover the gas     require(         vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,         Error.GAS_BANK_BALANCE_TOO_LOW     );      vars.totalTopUpAmount = position.totalTopUpAmount;     vars.actionFee = getActionFee();     // add top-up fees to top-up amount     vars.minActionAmountToTopUp = position.singleTopUpAmount;     vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(         ScaledMath.ONE + vars.actionFee     );      // if the amount that we want to top-up (including fees) is higher than     // the available topup amount, we lower this down to what is left of the position     if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {         vars.actionAmountWithFees = vars.totalTopUpAmount;         vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(             ScaledMath.ONE + vars.actionFee         );     }     ILiquidityPool pool = addressProvider_.getPoolForToken(position.depositToken);     vars.underlying = pool.getUnderlying();     vars.rate = pool.exchangeRate();      // compute the deposit tokens amount with and without fees     // we will need to unstake the amount with fees and to     // swap the amount without fees into action tokens     vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);     if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {         vars.depositAmountWithFees = position.depositTokenBalance;         vars.minActionAmountToTopUp =             (vars.depositAmountWithFees * vars.rate) /             (ScaledMath.ONE + vars.actionFee);     }      // compute amount of LP tokens needed to pay for action     // rate is expressed in actionToken per depositToken     vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);     vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;      // will revert if vault does not exist     address vault = addressProvider_.getStakerVault(position.depositToken);      // unstake deposit tokens including fees     IStakerVault(vault).unstake(vars.depositAmountWithFees);     IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);      // swap the amount without the fees     // as the fees are paid in deposit token, not in action token     vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);      // compute how much of action token was actually redeemed and add fees to it     // this is to ensure that no funds get locked inside the contract     vars.totalActionTokenAmount =         vars.actionTokenAmount +         vars.depositTotalFeesAmount.scaledMul(vars.rate);      // at this point, we have exactly `vars.actionTokenAmount`     // (at least `position.singleTopUpAmount`) of action token     // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract     // solhint-disable-next-line avoid-low-level-calls     uint256 value_;     if (position.actionToken == address(0)) {         value_ = vars.actionTokenAmount;     } else {         _approve(position.actionToken, vars.topUpHandler);     }     vars.topupResult = ITopUpHandler(vars.topUpHandler).topUp{value: value_}(         account,         position.actionToken,         vars.actionTokenAmount,         position.extra     );      require(vars.topupResult, Error.TOP_UP_FAILED);      // totalTopUpAmount is updated to reflect the new "balance" of the position     if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {         position.totalTopUpAmount -= vars.totalActionTokenAmount.toUint128();     } else {         position.totalTopUpAmount = 0;     }      position.depositTokenBalance -= vars.depositAmountWithFees.toUint128();      vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;     _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);     if (vars.removePosition) {         if (position.depositTokenBalance &gt; 0) {             // transfer any unused locked tokens to the payer             IStakerVault(vault).transfer(payer, position.depositTokenBalance);             IStakerVault(vault).decreaseActionLockedBalance(                 payer,                 position.depositTokenBalance             );         }         _removePosition(payer, account, protocol);     }      emit TopUp(         account,         protocol,         payer,         position.depositToken,         vars.depositAmountWithFees,         position.actionToken,         vars.actionTokenAmount     );      // compute gas used and reimburse the keeper by using the     // funds of payer in the gas bank     // TODO: add constant gas consumed for transfer and tx prologue     vars.gasConsumed = vars.initialGas - gasleft();      vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;     if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {         vars.reimbursedWeiForGas = vars.gasBankBalance;     }      // ensure that the keeper is not overpaying     vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;     require(         vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,         Error.GAS_TOO_HIGH     );     gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);     if (vars.removePosition) {         gasBank.withdrawUnused(payer);     }      return true; }  /**  * @notice Prepare new top up handler fee update.  * @dev Setting the address to 0 means that the protocol will no longer be supported.  * @param protocol Protocol for which a new handler should be prepared.  * @param newHandler Address of new handler.  * @return `true` if success.  */ function prepareTopUpHandler(bytes32 protocol, address newHandler)     public     override     onlyGovernance     returns (bool) {     return _prepare(_getProtocolKey(protocol), newHandler); }  /**  * @notice Check if action can be executed.  * @param protocol for which to get the health factor  * @param account for which to get the health factor  * @param extra data to be used by the topup handler  * @return healthFactor of the position  */ function getHealthFactor(     bytes32 protocol,     bytes32 account,     bytes calldata extra ) public view override returns (uint256 healthFactor) {     ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));     return topUpHandler.getUserFactor(account, extra); }  function getHandler(bytes32 protocol) public view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice returns the current estimated gas usage  */ function getEstimatedGasUsage() public view override returns (uint256) {     return currentUInts256[_ESTIMATED_GAS_USAGE_KEY]; }  /**  * @notice Returns the current action fee  */ function getActionFee() public view override returns (uint256) {     return currentUInts256[_ACTION_FEE_KEY]; }  /**  * @notice Returns the current fee handler  */ function getFeeHandler() public view override returns (address) {     return currentAddresses[_FEE_HANDLER_KEY]; }  /**  * @notice Get the record for a position.  * @param payer Registered payer of the position.  * @param account Address holding the position.  * @param protocol Protocol where the position is held.  */ function getPosition(     address payer,     bytes32 account,     bytes32 protocol ) public view override returns (Record memory) {     return _positions[payer][account][protocol]; }  /**  * @notice Check whether a token is usable as a deposit token.  * @param token Address of token to check.  * @return True if token is usable as a deposit token for this action.  */ function isUsable(address token) public view override returns (bool) {     return _usableTokens.contains(token); }  function _updateTopUpHandler(     bytes32 protocol,     address oldHandler,     address newHandler ) internal {     if (newHandler == address(0)) {         _supportedProtocols.remove(protocol);     } else if (oldHandler == address(0)) {         _supportedProtocols.add(protocol);     } }  /**  * @dev Pays fees to the feeHandler  * @param payer The account who's position the fees are charged on  * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)  * @param feeAmount The amount in tokens to pay as fees  * @param depositToken The LpToken used to pay the fees  */ function _payFees(     address payer,     address beneficiary,     uint256 feeAmount,     address depositToken ) internal {     address feeHandler = getFeeHandler();     IERC20(depositToken).safeApprove(feeHandler, feeAmount);     IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken); }  /**  * @dev "Locks" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function _lockFunds(     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) internal {     address stakerVaultAddress = addressProvider.getStakerVault(token);     TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount); }  function _removePosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     delete _positions[payer][account][protocol];     _removeUserPosition(payer, account, protocol);     if (_userPositions[payer].length == 0) {         _usersWithPositions.remove(payer);     }     emit Deregister(payer, account, protocol); }  function _removeUserPosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     RecordMeta[] storage positionsMeta = _userPositions[payer];     uint256 length = positionsMeta.length;     for (uint256 i; i &lt; length; i = i.uncheckedInc()) {         RecordMeta storage positionMeta = positionsMeta[i];         if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {             positionsMeta[i] = positionsMeta[length - 1];             positionsMeta.pop();             return;         }     } }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) internal {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the `actionToken`.  */ function _calcExchangeAmount(     address token,     address actionToken,     uint256 amount ) internal view returns (uint256) {     return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount); }  function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {     address handler = currentAddresses[_getProtocolKey(protocol)];     require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);     return handler; }  function _isSwappable(address depositToken, address toToken) internal view returns (bool) {     ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);     return pool.getUnderlying() == toToken; }  function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {     return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol)); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";\nimport "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\nimport "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";\nimport "@openzeppelin/contracts/utils/math/SafeCast.sol";\n\nimport "../../../interfaces/IGasBank.sol";\nimport "../../../interfaces/pool/ILiquidityPool.sol";\nimport "../../../interfaces/IController.sol";\nimport "../../../interfaces/IStakerVault.sol";\nimport "../../../interfaces/actions/topup/ITopUpHandler.sol";\nimport "../../../interfaces/actions/topup/ITopUpAction.sol";\nimport "../../../interfaces/actions/IActionFeeHandler.sol";\n\nimport "../../../libraries/AddressProviderHelpers.sol";\nimport "../../../libraries/Errors.sol";\nimport "../../../libraries/ScaledMath.sol";\nimport "../../../libraries/EnumerableExtensions.sol";\nimport "../../../libraries/UncheckedMath.sol";\n\nimport "../../access/Authorization.sol";\nimport "../../utils/Preparable.sol";\n\n/\n * @notice The logic here should really be part of the top-up action\n * but is split in a library to circumvent the byte-code size limit\n */\nlibrary TopUpActionLibrary {\n    using SafeERC20 for IERC20;\n    using ScaledMath for uint256;\n    using AddressProviderHelpers for IAddressProvider;\n\n    /\n     * @dev "Locks" an amount of tokens on behalf of the TopUpAction\n     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.\n     * @param stakerVaultAddress The address of the staker vault\n     * @param payer Owner of the funds to be locked\n     * @param token Token to lock\n     * @param lockAmount Minimum amount of token to lock\n     * @param depositAmount Amount of token that was deposited.\n     *                      If this is 0 then the staker vault allowance should be used.\n     *                      If this is greater than requiredAmount more tokens will be locked.\n     /\n    function lockFunds(\n        address stakerVaultAddress,\n        address payer,\n        address token,\n        uint256 lockAmount,\n        uint256 depositAmount\n    ) external {\n        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);\n\n        // stake deposit amount\n        if (depositAmount &gt; 0) {\n            depositAmount = depositAmount &gt; lockAmount ? lockAmount : depositAmount;\n            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);\n            _approve(token, stakerVaultAddress);\n            stakerVault.stake(depositAmount);\n            stakerVault.increaseActionLockedBalance(payer, depositAmount);\n            lockAmount -= depositAmount;\n        }\n\n        // use stake vault allowance if available and required\n        if (lockAmount &gt; 0) {\n            uint256 balance = stakerVault.balanceOf(payer);\n            uint256 allowance = stakerVault.allowance(payer, address(this));\n            uint256 availableFunds = balance &lt; allowance ? balance : allowance;\n            if (availableFunds &gt;= lockAmount) {\n                stakerVault.transferFrom(payer, address(this), lockAmount);\n                stakerVault.increaseActionLockedBalance(payer, lockAmount);\n                lockAmount = 0;\n            }\n        }\n\n        require(lockAmount == 0, Error.INSUFFICIENT_UPDATE_BALANCE);\n    }\n\n    /\n     * @dev Computes and returns the amount of LP tokens of type token that will be received in exchange for an amount of the underlying.\n     /\n    function calcExchangeAmount(\n        IAddressProvider addressProvider,\n        address token,\n        address actionToken,\n        uint256 amount\n    ) external view returns (uint256) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(token);\n        uint256 rate = pool.exchangeRate();\n        address underlying = pool.getUnderlying();\n        require(underlying == actionToken, Error.TOKEN_NOT_USABLE);\n        return amount.scaledDivRoundUp(rate);\n    }\n\n    /\n     * @dev Approves infinite spending for the given spender.\n     * @param token The token to approve for.\n     * @param spender The spender to approve.\n     */\n    function _approve(address token, address spender) private {\n        if (IERC20(token).allowance(address(this), spender) &gt; 0) return;\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n}\n\ncontract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {\n    using ScaledMath for uint256;\n    using UncheckedMath for uint256;\n    using ScaledMath for uint128;\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using EnumerableExtensions for EnumerableSet.AddressSet;\n    using AddressProviderHelpers for IAddressProvider;\n    using SafeCast for uint256;\n\n    /\n     * @dev Temporary struct to hold local variables in execute\n     * and avoid the stack being "too deep"\n     /\n    struct ExecuteLocalVars {\n        uint256 minActionAmountToTopUp;\n        uint256 actionTokenAmount;\n        uint256 depositTotalFeesAmount;\n        uint256 actionAmountWithFees;\n        uint256 userFactor;\n        uint256 rate;\n        uint256 depositAmountWithFees;\n        uint256 depositAmountWithoutFees;\n        uint256 actionFee;\n        uint256 totalActionTokenAmount;\n        uint128 totalTopUpAmount;\n        bool topupResult;\n        uint256 gasBankBalance;\n        uint256 initialGas;\n        uint256 gasConsumed;\n        uint256 userGasPrice;\n        uint256 estimatedRequiredGas;\n        uint256 estimatedRequiredWeiForGas;\n        uint256 requiredWeiForGas;\n        uint256 reimbursedWeiForGas;\n        address underlying;\n        bool removePosition;\n        address topUpHandler;\n    }\n\n    EnumerableSet.AddressSet private _usableTokens;\n\n    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 550_000;\n\n    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";\n    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";\n    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";\n    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";\n\n    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;\n\n    IController public immutable controller;\n    IAddressProvider public immutable addressProvider;\n\n    EnumerableSet.Bytes32Set internal _supportedProtocols;\n\n    /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record)\n    mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;\n\n    mapping(address =&gt; RecordMeta[]) internal _userPositions;\n\n    EnumerableSet.AddressSet internal _usersWithPositions;\n\n    constructor(IController _controller)\n        Authorization(_controller.addressProvider().getRoleManager())\n    {\n        controller = _controller;\n        addressProvider = controller.addressProvider();\n        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);\n    }\n\n    receive() external payable {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    function initialize(\n        address feeHandler,\n        bytes32[] calldata protocols,\n        address[] calldata handlers\n    ) external initializer onlyGovernance {\n        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);\n        _setConfig(_FEE_HANDLER_KEY, feeHandler);\n        for (uint256 i; i &lt; protocols.length; i = i.uncheckedInc()) {\n            bytes32 protocolKey = _getProtocolKey(protocols[i]);\n            _setConfig(protocolKey, handlers[i]);\n            _updateTopUpHandler(protocols[i], address(0), handlers[i]);\n        }\n    }\n\n    /\n     * @notice Register a top up action.\n     * @dev The depositAmount, once converted to units of actionToken, must be greater or equal to the totalTopUpAmount (which is denominated in actionToken).\n     * @param account Account to be topped up (first 20 bytes will typically be the address).\n     * @param protocol Protocol which holds position to be topped up.\n     * @param depositAmount Amount of depositToken that will be locked.\n     * @param record containing the data for the position to register\n     /\n    function register(\n        bytes32 account,\n        bytes32 protocol,\n        uint128 depositAmount,\n        Record memory record\n    ) external payable override returns (bool) {\n        require(record.maxFee != 0, Error.INVALID_MAX_FEE);\n        require(supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);\n        require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);\n        require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);\n        require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);\n        require(\n            _positions[msg.sender][account][protocol].threshold == 0,\n            Error.POSITION_ALREADY_EXISTS\n        );\n        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);\n        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);\n\n        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) \n            record.maxFee \n            getEstimatedGasUsage();\n\n        require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);\n\n        uint256 totalLockAmount = _calcExchangeAmount(\n            record.depositToken,\n            record.actionToken,\n            record.totalTopUpAmount\n        );\n        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);\n\n        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);\n\n        record.registeredAt = uint64(block.timestamp);\n        record.depositTokenBalance = totalLockAmount.toUint128();\n        _positions[msg.sender][account][protocol] = record;\n        _userPositions[msg.sender].push(RecordMeta(account, protocol));\n        _usersWithPositions.add(msg.sender);\n\n        emit Register(\n            account,\n            protocol,\n            record.threshold,\n            msg.sender,\n            record.depositToken,\n            totalLockAmount,\n            record.actionToken,\n            record.singleTopUpAmount,\n            record.totalTopUpAmount,\n            record.maxFee,\n            record.extra\n        );\n        return true;\n    }\n\n    /\n     * @notice See overloaded version of execute for more details.\n     */\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol\n    ) external override returns (bool) {\n        return execute(payer, account, beneficiary, protocol, 0);\n    }\n\n    /\n     * @notice Delete a position to back on the given protocol for account.\n     * @param account Account holding the position.\n     * @param protocol Protocol the position is held on.\n     * @param unstake If the tokens should be unstaked from vault.\n     * @return true if successful.\n     /\n    function resetPosition(\n        bytes32 account,\n        bytes32 protocol,\n        bool unstake\n    ) external override returns (bool) {\n        address payer = msg.sender;\n        Record memory position = positions[payer][account][protocol];\n        require(position.threshold != 0, Error.NO_POSITION_EXISTS);\n\n        IAddressProvider addressProvider = addressProvider;\n        address vault = addressProvider_.getStakerVault(position.depositToken); // will revert if vault does not exist\n        IStakerVault staker = IStakerVault(vault);\n        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);\n        if (unstake) {\n            staker.unstake(position.depositTokenBalance);\n            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);\n        } else {\n            staker.transfer(payer, position.depositTokenBalance);\n        }\n\n        removePosition(payer, account, protocol);\n        addressProvider.getGasBank().withdrawUnused(payer);\n        return true;\n    }\n\n    /\n     * @notice Execute top up handler update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @param protocol Protocol for which a new handler should be executed.\n     * @return Address of new handler.\n     /\n    function executeTopUpHandler(bytes32 protocol) external override returns (address) {\n        address oldHandler = _getHandler(protocol, false);\n        address newHandler = _executeAddress(_getProtocolKey(protocol));\n\n        _updateTopUpHandler(protocol, oldHandler, newHandler);\n        return newHandler;\n    }\n\n    /\n     * @notice Reset new top up handler deadline for a protocol.\n     * @param protocol Protocol for which top up handler deadline should be reset.\n     * @return true if successful.\n     */\n    function resetTopUpHandler(bytes32 protocol) external override onlyGovernance returns (bool) {\n        return _resetAddressConfig(_getProtocolKey(protocol));\n    }\n\n    /\n     * @notice Prepare action fee update.\n     * @param newActionFee New fee to set.\n     * @return true if success.\n     /\n    function prepareActionFee(uint256 newActionFee)\n        external\n        override\n        onlyGovernance\n        returns (bool)\n    {\n        require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);\n        return _prepare(_ACTION_FEE_KEY, newActionFee);\n    }\n\n    /\n     * @notice Execute action fee update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return true if successful.\n     /\n    function executeActionFee() external override returns (uint256) {\n        return _executeUInt256(_ACTION_FEE_KEY);\n    }\n\n    /\n     * @notice Reset action fee deadline.\n     * @return true if successful.\n     */\n    function resetActionFee() external override onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ACTION_FEE_KEY);\n    }\n\n    / Set fee handler /\n    /\n     * @notice Prepare update of fee handler.\n     * @param handler New fee handler.\n     * @return true if success.\n     /\n    function prepareFeeHandler(address handler) external override onlyGovernance returns (bool) {\n        return _prepare(_FEE_HANDLER_KEY, handler);\n    }\n\n    /\n     * @notice Execute update of fee handler (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return true if successful.\n     */\n    function executeFeeHandler() external override returns (address) {\n        return _executeAddress(_FEE_HANDLER_KEY);\n    }\n\n    /\n     * @notice Reset the handler deadline.\n     * @return true if success.\n     /\n    function resetFeeHandler() external override onlyGovernance returns (bool) {\n        return _resetAddressConfig(_FEE_HANDLER_KEY);\n    }\n\n    /\n     * @notice Prepare update of estimated gas usage.\n     * @param gasUsage New estimated gas usage.\n     * @return true if success.\n     /\n    function prepareEstimatedGasUsage(uint256 gasUsage)\n        external\n        override\n        onlyGovernance\n        returns (bool)\n    {\n        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);\n    }\n\n    /\n     * @notice Execute update of gas usage (with time delay enforced).\n     * @return true if successful.\n     */\n    function executeEstimatedGasUsage() external override returns (uint256) {\n        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);\n    }\n\n    /\n     * @notice Reset the gas usage deadline.\n     * @return true if success.\n     /\n    function resetGasUsage() external override onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);\n    }\n\n    /\n     * @notice Add a new deposit token that is supported by the action.\n     * @dev There is a separate check for whether the usable token (i.e. deposit token)\n     *      is swappable for some action token.\n     * @param token Address of deposit token that can be used by the action.\n     /\n    function addUsableToken(address token) external override onlyGovernance returns (bool) {\n        return _usableTokens.add(token);\n    }\n\n    /\n     * @notice Computes the total amount of ETH (as wei) required to pay for all\n     * the top-ups assuming the maximum gas price and the current estimated gas\n     * usage of a top-up\n     */\n    function getEthRequiredForGas(address payer) external view override returns (uint256) {\n        uint256 totalEthRequired;\n        RecordMeta[] memory userRecordsMeta = _userPositions[payer];\n        uint256 gasUsagePerCall = getEstimatedGasUsage();\n        uint256 length = userRecordsMeta.length;\n        for (uint256 i; i &lt; length; i = i.uncheckedInc()) {\n            RecordMeta memory meta = userRecordsMeta[i];\n            Record memory record = _positions[payer][meta.account][meta.protocol];\n            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);\n            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;\n        }\n        return totalEthRequired;\n    }\n\n    /\n     * @notice Returns a list of positions for the given payer\n     /\n    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {\n        return _userPositions[payer];\n    }\n\n    /\n     * @notice Get a list supported protocols.\n     * @return List of supported protocols.\n     /\n    function getSupportedProtocols() external view override returns (bytes32[] memory) {\n        uint256 length = _supportedProtocols.length();\n        bytes32[] memory protocols = new bytes32;\n        for (uint256 i; i &lt; length; i = i.uncheckedInc()) {\n            protocols[i] = _supportedProtocols.at(i);\n        }\n        return protocols;\n    }\n\n    /\n     * @notice Gets a list of users that have an active position.\n     * @dev Uses cursor pagination.\n     * @param cursor The cursor for pagination (should start at 0 for first call).\n     * @param howMany Maximum number of users to return in this pagination request.\n     * @return users List of users that have an active position.\n     * @return nextCursor The cursor to use for the next pagination request.\n     /\n    function usersWithPositions(uint256 cursor, uint256 howMany)\n        external\n        view\n        override\n        returns (address[] memory users, uint256 nextCursor)\n    {\n        uint256 length = _usersWithPositions.length();\n        if (cursor &gt;= length) return (new address, 0);\n        if (howMany &gt;= length - cursor) {\n            howMany = length - cursor;\n        }\n\n        address[] memory usersWithPositions = new address;\n        for (uint256 i; i &lt; howMany; i = i.uncheckedInc()) {\n            usersWithPositions_[i] = usersWithPositions.at(i + cursor);\n        }\n\n        return (usersWithPositions, cursor + howMany);\n    }\n\n    /\n     * @notice Get a list of all tokens usable for this action.\n     * @dev This refers to all tokens that can be used as deposit tokens.\n     * @return Array of addresses of usable tokens.\n     */\n    function getUsableTokens() external view override returns (address[] memory) {\n        return _usableTokens.toArray();\n    }\n\n    /\n     * @notice Retrieves the topup handler for the given protocol\n     /\n    function getTopUpHandler(bytes32 protocol) external view override returns (address) {\n        return _getHandler(protocol, false);\n    }\n\n    /\n     * @notice Successfully tops up a position if it\'s conditions are met.\n     * @dev pool and vault funds are rebalanced after withdrawal for top up\n     * @param payer Account that pays for the top up.\n     * @param account Account owning the position for top up.\n     * @param beneficiary Address of the keeper\'s wallet for fee accrual.\n     * @param protocol Protocol of the top up position.\n     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas\n     * @return true if successful.\n     /\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol,\n        uint256 maxWeiForGas\n    ) public override returns (bool) {\n        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);\n\n        ExecuteLocalVars memory vars;\n\n        vars.initialGas = gasleft();\n\n        Record storage position = positions[payer][account][protocol];\n        require(position.threshold != 0, Error.NO_POSITION_EXISTS);\n        require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);\n        require(block.timestamp &gt; position.registeredAt, Error.CANNOT_EXECUTE_IN_SAME_BLOCK);\n\n        vars.topUpHandler = _getHandler(protocol, true);\n        vars.userFactor = ITopUpHandler(vars.topUpHandler).getUserFactor(account, position.extra);\n\n        // ensure that the position is actually below its set user factor threshold\n        require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);\n\n        IAddressProvider addressProvider = addressProvider;\n        IGasBank gasBank = addressProvider_.getGasBank();\n\n        // fail early if the user does not have enough funds in the gas bank\n        // to cover the cost of the transaction\n        vars.estimatedRequiredGas = getEstimatedGasUsage();\n        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;\n\n        // compute the gas price that the user will be paying\n        vars.userGasPrice = block.basefee + position.priorityFee;\n        if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;\n        if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;\n\n        // ensure the current position allows for the gas to be paid\n        require(\n            vars.estimatedRequiredWeiForGas &lt;=\n                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,\n            Error.ESTIMATED_GAS_TOO_HIGH\n        );\n\n        vars.gasBankBalance = gasBank.balanceOf(payer);\n        // ensure the user has enough funds in the gas bank to cover the gas\n        require(\n            vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,\n            Error.GAS_BANK_BALANCE_TOO_LOW\n        );\n\n        vars.totalTopUpAmount = position.totalTopUpAmount;\n        vars.actionFee = getActionFee();\n        // add top-up fees to top-up amount\n        vars.minActionAmountToTopUp = position.singleTopUpAmount;\n        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(\n            ScaledMath.ONE + vars.actionFee\n        );\n\n        // if the amount that we want to top-up (including fees) is higher than\n        // the available topup amount, we lower this down to what is left of the position\n        if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {\n            vars.actionAmountWithFees = vars.totalTopUpAmount;\n            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(\n                ScaledMath.ONE + vars.actionFee\n            );\n        }\n        ILiquidityPool pool = addressProvider_.getPoolForToken(position.depositToken);\n        vars.underlying = pool.getUnderlying();\n        vars.rate = pool.exchangeRate();\n\n        // compute the deposit tokens amount with and without fees\n        // we will need to unstake the amount with fees and to\n        // swap the amount without fees into action tokens\n        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);\n        if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {\n            vars.depositAmountWithFees = position.depositTokenBalance;\n            vars.minActionAmountToTopUp =\n                (vars.depositAmountWithFees * vars.rate) /\n                (ScaledMath.ONE + vars.actionFee);\n        }\n\n        // compute amount of LP tokens needed to pay for action\n        // rate is expressed in actionToken per depositToken\n        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);\n        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;\n\n        // will revert if vault does not exist\n        address vault = addressProvider_.getStakerVault(position.depositToken);\n\n        // unstake deposit tokens including fees\n        IStakerVault(vault).unstake(vars.depositAmountWithFees);\n        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);\n\n        // swap the amount without the fees\n        // as the fees are paid in deposit token, not in action token\n        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);\n\n        // compute how much of action token was actually redeemed and add fees to it\n        // this is to ensure that no funds get locked inside the contract\n        vars.totalActionTokenAmount =\n            vars.actionTokenAmount +\n            vars.depositTotalFeesAmount.scaledMul(vars.rate);\n\n        // at this point, we have exactly vars.actionTokenAmount\n        // (at least position.singleTopUpAmount) of action token\n        // and exactly vars.depositTotalFeesAmount deposit tokens in the contract\n        // solhint-disable-next-line avoid-low-level-calls\n        uint256 value_;\n        if (position.actionToken == address(0)) {\n            value_ = vars.actionTokenAmount;\n        } else {\n            approve(position.actionToken, vars.topUpHandler);\n        }\n        vars.topupResult = ITopUpHandler(vars.topUpHandler).topUp{value: value}(\n            account,\n            position.actionToken,\n            vars.actionTokenAmount,\n            position.extra\n        );\n\n        require(vars.topupResult, Error.TOP_UP_FAILED);\n\n        // totalTopUpAmount is updated to reflect the new "balance" of the position\n        if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {\n            position.totalTopUpAmount -= vars.totalActionTokenAmount.toUint128();\n        } else {\n            position.totalTopUpAmount = 0;\n        }\n\n        position.depositTokenBalance -= vars.depositAmountWithFees.toUint128();\n\n        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;\n        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);\n        if (vars.removePosition) {\n            if (position.depositTokenBalance &gt; 0) {\n                // transfer any unused locked tokens to the payer\n                IStakerVault(vault).transfer(payer, position.depositTokenBalance);\n                IStakerVault(vault).decreaseActionLockedBalance(\n                    payer,\n                    position.depositTokenBalance\n                );\n            }\n            _removePosition(payer, account, protocol);\n        }\n\n        emit TopUp(\n            account,\n            protocol,\n            payer,\n            position.depositToken,\n            vars.depositAmountWithFees,\n            position.actionToken,\n            vars.actionTokenAmount\n        );\n\n        // compute gas used and reimburse the keeper by using the\n        // funds of payer in the gas bank\n        // TODO: add constant gas consumed for transfer and tx prologue\n        vars.gasConsumed = vars.initialGas - gasleft();\n\n        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;\n        if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {\n            vars.reimbursedWeiForGas = vars.gasBankBalance;\n        }\n\n        // ensure that the keeper is not overpaying\n        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;\n        require(\n            vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,\n            Error.GAS_TOO_HIGH\n        );\n        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);\n        if (vars.removePosition) {\n            gasBank.withdrawUnused(payer);\n        }\n\n        return true;\n    }\n\n    /\n     * @notice Prepare new top up handler fee update.\n     * @dev Setting the address to 0 means that the protocol will no longer be supported.\n     * @param protocol Protocol for which a new handler should be prepared.\n     * @param newHandler Address of new handler.\n     * @return true if success.\n     */\n    function prepareTopUpHandler(bytes32 protocol, address newHandler)\n        public\n        override\n        onlyGovernance\n        returns (bool)\n    {\n        return _prepare(_getProtocolKey(protocol), newHandler);\n    }\n\n    /\n     * @notice Check if action can be executed.\n     * @param protocol for which to get the health factor\n     * @param account for which to get the health factor\n     * @param extra data to be used by the topup handler\n     * @return healthFactor of the position\n     /\n    function getHealthFactor(\n        bytes32 protocol,\n        bytes32 account,\n        bytes calldata extra\n    ) public view override returns (uint256 healthFactor) {\n        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));\n        return topUpHandler.getUserFactor(account, extra);\n    }\n\n    function getHandler(bytes32 protocol) public view override returns (address) {\n        return _getHandler(protocol, false);\n    }\n\n    /\n     * @notice returns the current estimated gas usage\n     /\n    function getEstimatedGasUsage() public view override returns (uint256) {\n        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];\n    }\n\n    /\n     * @notice Returns the current action fee\n     */\n    function getActionFee() public view override returns (uint256) {\n        return currentUInts256[_ACTION_FEE_KEY];\n    }\n\n    /\n     * @notice Returns the current fee handler\n     /\n    function getFeeHandler() public view override returns (address) {\n        return currentAddresses[_FEE_HANDLER_KEY];\n    }\n\n    /\n     * @notice Get the record for a position.\n     * @param payer Registered payer of the position.\n     * @param account Address holding the position.\n     * @param protocol Protocol where the position is held.\n     /\n    function getPosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) public view override returns (Record memory) {\n        return _positions[payer][account][protocol];\n    }\n\n    /\n     * @notice Check whether a token is usable as a deposit token.\n     * @param token Address of token to check.\n     * @return True if token is usable as a deposit token for this action.\n     */\n    function isUsable(address token) public view override returns (bool) {\n        return _usableTokens.contains(token);\n    }\n\n    function _updateTopUpHandler(\n        bytes32 protocol,\n        address oldHandler,\n        address newHandler\n    ) internal {\n        if (newHandler == address(0)) {\n            _supportedProtocols.remove(protocol);\n        } else if (oldHandler == address(0)) {\n            _supportedProtocols.add(protocol);\n        }\n    }\n\n    /\n     * @dev Pays fees to the feeHandler\n     * @param payer The account who\'s position the fees are charged on\n     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)\n     * @param feeAmount The amount in tokens to pay as fees\n     * @param depositToken The LpToken used to pay the fees\n     /\n    function _payFees(\n        address payer,\n        address beneficiary,\n        uint256 feeAmount,\n        address depositToken\n    ) internal {\n        address feeHandler = getFeeHandler();\n        IERC20(depositToken).safeApprove(feeHandler, feeAmount);\n        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);\n    }\n\n    /\n     * @dev "Locks" an amount of tokens on behalf of the TopUpAction\n     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.\n     * @param payer Owner of the funds to be locked\n     * @param token Token to lock\n     * @param lockAmount Minimum amount of token to lock\n     * @param depositAmount Amount of token that was deposited.\n     *                      If this is 0 then the staker vault allowance should be used.\n     *                      If this is greater than requiredAmount more tokens will be locked.\n     /\n    function _lockFunds(\n        address payer,\n        address token,\n        uint256 lockAmount,\n        uint256 depositAmount\n    ) internal {\n        address stakerVaultAddress = addressProvider.getStakerVault(token);\n        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);\n    }\n\n    function _removePosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) internal {\n        delete _positions[payer][account][protocol];\n        _removeUserPosition(payer, account, protocol);\n        if (_userPositions[payer].length == 0) {\n            _usersWithPositions.remove(payer);\n        }\n        emit Deregister(payer, account, protocol);\n    }\n\n    function _removeUserPosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) internal {\n        RecordMeta[] storage positionsMeta = _userPositions[payer];\n        uint256 length = positionsMeta.length;\n        for (uint256 i; i &lt; length; i = i.uncheckedInc()) {\n            RecordMeta storage positionMeta = positionsMeta[i];\n            if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {\n                positionsMeta[i] = positionsMeta[length - 1];\n                positionsMeta.pop();\n                return;\n            }\n        }\n    }\n\n    /\n     * @dev Approves infinite spending for the given spender.\n     * @param token The token to approve for.\n     * @param spender The spender to approve.\n     */\n    function _approve(address token, address spender) internal {\n        if (IERC20(token).allowance(address(this), spender) &gt; 0) return;\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n\n    /\n     * @dev Computes and returns the amount of LP tokens of type token that will be received in exchange for an amount of the actionToken.\n     */\n    function _calcExchangeAmount(\n        address token,\n        address actionToken,\n        uint256 amount\n    ) internal view returns (uint256) {\n        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);\n    }\n\n    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {\n        address handler = currentAddresses[_getProtocolKey(protocol)];\n        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);\n        return handler;\n    }\n\n    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);\n        return pool.getUnderlying() == toToken;\n    }\n\n    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));\n    }\n}\n', 'ideas': ' 1'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 12:30:07 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.10; import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol"; import "@openzeppelin/contracts/utils/math/SafeCast.sol"; import "../../../interfaces/IGasBank.sol"; import "../../../interfaces/pool/ILiquidityPool.sol"; import "../../../interfaces/IController.sol"; import "../../../interfaces/IStakerVault.sol"; import "../../../interfaces/actions/topup/ITopUpHandler.sol"; import "../../../interfaces/actions/topup/ITopUpAction.sol"; import "../../../interfaces/actions/IActionFeeHandler.sol"; import "../../../libraries/AddressProviderHelpers.sol"; import "../../../libraries/Errors.sol"; import "../../../libraries/ScaledMath.sol"; import "../../../libraries/EnumerableExtensions.sol"; import "../../../libraries/UncheckedMath.sol"; import "../../access/Authorization.sol"; import "../../utils/Preparable.sol"; /*  * @notice The logic here should really be part of the top-up action  * but is split in a library to circumvent the byte-code size limit  / library TopUpActionLibrary {     using SafeERC20 for IERC20;     using ScaledMath for uint256;     using AddressProviderHelpers for IAddressProvider; /**  * @dev "Locks" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param stakerVaultAddress The address of the staker vault  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function lockFunds(     address stakerVaultAddress,     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) external {     IStakerVault stakerVault = IStakerVault(stakerVaultAddress);      // stake deposit amount     if (depositAmount &gt; 0) {         depositAmount = depositAmount &gt; lockAmount ? lockAmount : depositAmount;         IERC20(token).safeTransferFrom(payer, address(this), depositAmount);         _approve(token, stakerVaultAddress);         stakerVault.stake(depositAmount);         stakerVault.increaseActionLockedBalance(payer, depositAmount);         lockAmount -= depositAmount;     }      // use stake vault allowance if available and required     if (lockAmount &gt; 0) {         uint256 balance = stakerVault.balanceOf(payer);         uint256 allowance = stakerVault.allowance(payer, address(this));         uint256 availableFunds = balance &lt; allowance ? balance : allowance;         if (availableFunds &gt;= lockAmount) {             stakerVault.transferFrom(payer, address(this), lockAmount);             stakerVault.increaseActionLockedBalance(payer, lockAmount);             lockAmount = 0;         }     }      require(lockAmount == 0, Error.INSUFFICIENT_UPDATE_BALANCE); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function calcExchangeAmount(     IAddressProvider addressProvider,     address token,     address actionToken,     uint256 amount ) external view returns (uint256) {     ILiquidityPool pool = addressProvider.getPoolForToken(token);     uint256 rate = pool.exchangeRate();     address underlying = pool.getUnderlying();     require(underlying == actionToken, Error.TOKEN_NOT_USABLE);     return amount.scaledDivRoundUp(rate); }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) private {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  } contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {     using ScaledMath for uint256;     using UncheckedMath for uint256;     using ScaledMath for uint128;     using SafeERC20 for IERC20;     using EnumerableSet for EnumerableSet.AddressSet;     using EnumerableSet for EnumerableSet.Bytes32Set;     using EnumerableExtensions for EnumerableSet.AddressSet;     using AddressProviderHelpers for IAddressProvider;     using SafeCast for uint256; /**  * @dev Temporary struct to hold local variables in execute  * and avoid the stack being "too deep"  */ struct ExecuteLocalVars {     uint256 minActionAmountToTopUp;     uint256 actionTokenAmount;     uint256 depositTotalFeesAmount;     uint256 actionAmountWithFees;     uint256 userFactor;     uint256 rate;     uint256 depositAmountWithFees;     uint256 depositAmountWithoutFees;     uint256 actionFee;     uint256 totalActionTokenAmount;     uint128 totalTopUpAmount;     bool topupResult;     uint256 gasBankBalance;     uint256 initialGas;     uint256 gasConsumed;     uint256 userGasPrice;     uint256 estimatedRequiredGas;     uint256 estimatedRequiredWeiForGas;     uint256 requiredWeiForGas;     uint256 reimbursedWeiForGas;     address underlying;     bool removePosition;     address topUpHandler; }  EnumerableSet.AddressSet private _usableTokens;  uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 550_000;  bytes32 internal constant _ACTION_FEE_KEY = "ActionFee"; bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler"; bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler"; bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";  uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;  IController public immutable controller; IAddressProvider public immutable addressProvider;  EnumerableSet.Bytes32Set internal _supportedProtocols;  /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record) mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;  mapping(address =&gt; RecordMeta[]) internal _userPositions;  EnumerableSet.AddressSet internal _usersWithPositions;  constructor(IController _controller)     Authorization(_controller.addressProvider().getRoleManager()) {     controller = _controller;     addressProvider = controller.addressProvider();     _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE); }  receive() external payable {     // solhint-disable-previous-line no-empty-blocks }  function initialize(     address feeHandler,     bytes32[] calldata protocols,     address[] calldata handlers ) external initializer onlyGovernance {     require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);     _setConfig(_FEE_HANDLER_KEY, feeHandler);     for (uint256 i; i &lt; protocols.length; i = i.uncheckedInc()) {         bytes32 protocolKey = _getProtocolKey(protocols[i]);         _setConfig(protocolKey, handlers[i]);         _updateTopUpHandler(protocols[i], address(0), handlers[i]);     } }  /**  * @notice Register a top up action.  * @dev The `depositAmount`, once converted to units of `actionToken`, must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).  * @param account Account to be topped up (first 20 bytes will typically be the address).  * @param protocol Protocol which holds position to be topped up.  * @param depositAmount Amount of `depositToken` that will be locked.  * @param record containing the data for the position to register  */ function register(     bytes32 account,     bytes32 protocol,     uint128 depositAmount,     Record memory record ) external payable override returns (bool) {     require(record.maxFee != 0, Error.INVALID_MAX_FEE);     require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);     require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);     require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);     require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);     require(         _positions[msg.sender][account][protocol].threshold == 0,         Error.POSITION_ALREADY_EXISTS     );     require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);     require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);      uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *         record.maxFee *         getEstimatedGasUsage();      require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);      uint256 totalLockAmount = _calcExchangeAmount(         record.depositToken,         record.actionToken,         record.totalTopUpAmount     );     _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);      addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);      record.registeredAt = uint64(block.timestamp);     record.depositTokenBalance = totalLockAmount.toUint128();     _positions[msg.sender][account][protocol] = record;     _userPositions[msg.sender].push(RecordMeta(account, protocol));     _usersWithPositions.add(msg.sender);      emit Register(         account,         protocol,         record.threshold,         msg.sender,         record.depositToken,         totalLockAmount,         record.actionToken,         record.singleTopUpAmount,         record.totalTopUpAmount,         record.maxFee,         record.extra     );     return true; }  /**  * @notice See overloaded version of `execute` for more details.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol ) external override returns (bool) {     return execute(payer, account, beneficiary, protocol, 0); }  /**  * @notice Delete a position to back on the given protocol for `account`.  * @param account Account holding the position.  * @param protocol Protocol the position is held on.  * @param unstake If the tokens should be unstaked from vault.  * @return `true` if successful.  */ function resetPosition(     bytes32 account,     bytes32 protocol,     bool unstake ) external override returns (bool) {     address payer = msg.sender;     Record memory position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);      IAddressProvider addressProvider_ = addressProvider;     address vault = addressProvider_.getStakerVault(position.depositToken); // will revert if vault does not exist     IStakerVault staker = IStakerVault(vault);     staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);     if (unstake) {         staker.unstake(position.depositTokenBalance);         IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);     } else {         staker.transfer(payer, position.depositTokenBalance);     }      _removePosition(payer, account, protocol);     addressProvider_.getGasBank().withdrawUnused(payer);     return true; }  /**  * @notice Execute top up handler update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @param protocol Protocol for which a new handler should be executed.  * @return Address of new handler.  */ function executeTopUpHandler(bytes32 protocol) external override returns (address) {     address oldHandler = _getHandler(protocol, false);     address newHandler = _executeAddress(_getProtocolKey(protocol));      _updateTopUpHandler(protocol, oldHandler, newHandler);     return newHandler; }  /**  * @notice Reset new top up handler deadline for a protocol.  * @param protocol Protocol for which top up handler deadline should be reset.  * @return `true` if successful.  */ function resetTopUpHandler(bytes32 protocol) external override onlyGovernance returns (bool) {     return _resetAddressConfig(_getProtocolKey(protocol)); }  /**  * @notice Prepare action fee update.  * @param newActionFee New fee to set.  * @return `true` if success.  */ function prepareActionFee(uint256 newActionFee)     external     override     onlyGovernance     returns (bool) {     require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);     return _prepare(_ACTION_FEE_KEY, newActionFee); }  /**  * @notice Execute action fee update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeActionFee() external override returns (uint256) {     return _executeUInt256(_ACTION_FEE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetActionFee() external override onlyGovernance returns (bool) {     return _resetUInt256Config(_ACTION_FEE_KEY); }  /** Set fee handler */ /**  * @notice Prepare update of fee handler.  * @param handler New fee handler.  * @return `true` if success.  */ function prepareFeeHandler(address handler) external override onlyGovernance returns (bool) {     return _prepare(_FEE_HANDLER_KEY, handler); }  /**  * @notice Execute update of fee handler (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeFeeHandler() external override returns (address) {     return _executeAddress(_FEE_HANDLER_KEY); }  /**  * @notice Reset the handler deadline.  * @return `true` if success.  */ function resetFeeHandler() external override onlyGovernance returns (bool) {     return _resetAddressConfig(_FEE_HANDLER_KEY); }  /**  * @notice Prepare update of estimated gas usage.  * @param gasUsage New estimated gas usage.  * @return `true` if success.  */ function prepareEstimatedGasUsage(uint256 gasUsage)     external     override     onlyGovernance     returns (bool) {     return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage); }  /**  * @notice Execute update of gas usage (with time delay enforced).  * @return `true` if successful.  */ function executeEstimatedGasUsage() external override returns (uint256) {     return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Reset the gas usage deadline.  * @return `true` if success.  */ function resetGasUsage() external override onlyGovernance returns (bool) {     return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Add a new deposit token that is supported by the action.  * @dev There is a separate check for whether the usable token (i.e. deposit token)  *      is swappable for some action token.  * @param token Address of deposit token that can be used by the action.  */ function addUsableToken(address token) external override onlyGovernance returns (bool) {     return _usableTokens.add(token); }  /**  * @notice Computes the total amount of ETH (as wei) required to pay for all  * the top-ups assuming the maximum gas price and the current estimated gas  * usage of a top-up  */ function getEthRequiredForGas(address payer) external view override returns (uint256) {     uint256 totalEthRequired;     RecordMeta[] memory userRecordsMeta = _userPositions[payer];     uint256 gasUsagePerCall = getEstimatedGasUsage();     uint256 length = userRecordsMeta.length;     for (uint256 i; i &lt; length; i = i.uncheckedInc()) {         RecordMeta memory meta = userRecordsMeta[i];         Record memory record = _positions[payer][meta.account][meta.protocol];         uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);         totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;     }     return totalEthRequired; }  /**  * @notice Returns a list of positions for the given payer  */ function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {     return _userPositions[payer]; }  /**  * @notice Get a list supported protocols.  * @return List of supported protocols.  */ function getSupportedProtocols() external view override returns (bytes32[] memory) {     uint256 length = _supportedProtocols.length();     bytes32[] memory protocols = new bytes32[](length);     for (uint256 i; i &lt; length; i = i.uncheckedInc()) {         protocols[i] = _supportedProtocols.at(i);     }     return protocols; }  /*  * @notice Gets a list of users that have an active position.  * @dev Uses cursor pagination.  * @param cursor The cursor for pagination (should start at 0 for first call).  * @param howMany Maximum number of users to return in this pagination request.  * @return users List of users that have an active position.  * @return nextCursor The cursor to use for the next pagination request.  */ function usersWithPositions(uint256 cursor, uint256 howMany)     external     view     override     returns (address[] memory users, uint256 nextCursor) {     uint256 length = _usersWithPositions.length();     if (cursor &gt;= length) return (new address[](0), 0);     if (howMany &gt;= length - cursor) {         howMany = length - cursor;     }      address[] memory usersWithPositions_ = new address[](howMany);     for (uint256 i; i &lt; howMany; i = i.uncheckedInc()) {         usersWithPositions_[i] = _usersWithPositions.at(i + cursor);     }      return (usersWithPositions_, cursor + howMany); }  /**  * @notice Get a list of all tokens usable for this action.  * @dev This refers to all tokens that can be used as deposit tokens.  * @return Array of addresses of usable tokens.  */ function getUsableTokens() external view override returns (address[] memory) {     return _usableTokens.toArray(); }  /**  * @notice Retrieves the topup handler for the given `protocol`  */ function getTopUpHandler(bytes32 protocol) external view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice Successfully tops up a position if it's conditions are met.  * @dev pool and vault funds are rebalanced after withdrawal for top up  * @param payer Account that pays for the top up.  * @param account Account owning the position for top up.  * @param beneficiary Address of the keeper's wallet for fee accrual.  * @param protocol Protocol of the top up position.  * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas  * @return `true` if successful.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol,     uint256 maxWeiForGas ) public override returns (bool) {     require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);      ExecuteLocalVars memory vars;      vars.initialGas = gasleft();      Record storage position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);     require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);     require(block.timestamp &gt; position.registeredAt, Error.CANNOT_EXECUTE_IN_SAME_BLOCK);      vars.topUpHandler = _getHandler(protocol, true);     vars.userFactor = ITopUpHandler(vars.topUpHandler).getUserFactor(account, position.extra);      // ensure that the position is actually below its set user factor threshold     require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);      IAddressProvider addressProvider_ = addressProvider;     IGasBank gasBank = addressProvider_.getGasBank();      // fail early if the user does not have enough funds in the gas bank     // to cover the cost of the transaction     vars.estimatedRequiredGas = getEstimatedGasUsage();     vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;      // compute the gas price that the user will be paying     vars.userGasPrice = block.basefee + position.priorityFee;     if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;     if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;      // ensure the current position allows for the gas to be paid     require(         vars.estimatedRequiredWeiForGas &lt;=             vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,         Error.ESTIMATED_GAS_TOO_HIGH     );      vars.gasBankBalance = gasBank.balanceOf(payer);     // ensure the user has enough funds in the gas bank to cover the gas     require(         vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,         Error.GAS_BANK_BALANCE_TOO_LOW     );      vars.totalTopUpAmount = position.totalTopUpAmount;     vars.actionFee = getActionFee();     // add top-up fees to top-up amount     vars.minActionAmountToTopUp = position.singleTopUpAmount;     vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(         ScaledMath.ONE + vars.actionFee     );      // if the amount that we want to top-up (including fees) is higher than     // the available topup amount, we lower this down to what is left of the position     if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {         vars.actionAmountWithFees = vars.totalTopUpAmount;         vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(             ScaledMath.ONE + vars.actionFee         );     }     ILiquidityPool pool = addressProvider_.getPoolForToken(position.depositToken);     vars.underlying = pool.getUnderlying();     vars.rate = pool.exchangeRate();      // compute the deposit tokens amount with and without fees     // we will need to unstake the amount with fees and to     // swap the amount without fees into action tokens     vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);     if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {         vars.depositAmountWithFees = position.depositTokenBalance;         vars.minActionAmountToTopUp =             (vars.depositAmountWithFees * vars.rate) /             (ScaledMath.ONE + vars.actionFee);     }      // compute amount of LP tokens needed to pay for action     // rate is expressed in actionToken per depositToken     vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);     vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;      // will revert if vault does not exist     address vault = addressProvider_.getStakerVault(position.depositToken);      // unstake deposit tokens including fees     IStakerVault(vault).unstake(vars.depositAmountWithFees);     IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);      // swap the amount without the fees     // as the fees are paid in deposit token, not in action token     vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);      // compute how much of action token was actually redeemed and add fees to it     // this is to ensure that no funds get locked inside the contract     vars.totalActionTokenAmount =         vars.actionTokenAmount +         vars.depositTotalFeesAmount.scaledMul(vars.rate);      // at this point, we have exactly `vars.actionTokenAmount`     // (at least `position.singleTopUpAmount`) of action token     // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract     // solhint-disable-next-line avoid-low-level-calls     uint256 value_;     if (position.actionToken == address(0)) {         value_ = vars.actionTokenAmount;     } else {         _approve(position.actionToken, vars.topUpHandler);     }     vars.topupResult = ITopUpHandler(vars.topUpHandler).topUp{value: value_}(         account,         position.actionToken,         vars.actionTokenAmount,         position.extra     );      require(vars.topupResult, Error.TOP_UP_FAILED);      // totalTopUpAmount is updated to reflect the new "balance" of the position     if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {         position.totalTopUpAmount -= vars.totalActionTokenAmount.toUint128();     } else {         position.totalTopUpAmount = 0;     }      position.depositTokenBalance -= vars.depositAmountWithFees.toUint128();      vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;     _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);     if (vars.removePosition) {         if (position.depositTokenBalance &gt; 0) {             // transfer any unused locked tokens to the payer             IStakerVault(vault).transfer(payer, position.depositTokenBalance);             IStakerVault(vault).decreaseActionLockedBalance(                 payer,                 position.depositTokenBalance             );         }         _removePosition(payer, account, protocol);     }      emit TopUp(         account,         protocol,         payer,         position.depositToken,         vars.depositAmountWithFees,         position.actionToken,         vars.actionTokenAmount     );      // compute gas used and reimburse the keeper by using the     // funds of payer in the gas bank     // TODO: add constant gas consumed for transfer and tx prologue     vars.gasConsumed = vars.initialGas - gasleft();      vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;     if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {         vars.reimbursedWeiForGas = vars.gasBankBalance;     }      // ensure that the keeper is not overpaying     vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;     require(         vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,         Error.GAS_TOO_HIGH     );     gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);     if (vars.removePosition) {         gasBank.withdrawUnused(payer);     }      return true; }  /**  * @notice Prepare new top up handler fee update.  * @dev Setting the address to 0 means that the protocol will no longer be supported.  * @param protocol Protocol for which a new handler should be prepared.  * @param newHandler Address of new handler.  * @return `true` if success.  */ function prepareTopUpHandler(bytes32 protocol, address newHandler)     public     override     onlyGovernance     returns (bool) {     return _prepare(_getProtocolKey(protocol), newHandler); }  /**  * @notice Check if action can be executed.  * @param protocol for which to get the health factor  * @param account for which to get the health factor  * @param extra data to be used by the topup handler  * @return healthFactor of the position  */ function getHealthFactor(     bytes32 protocol,     bytes32 account,     bytes calldata extra ) public view override returns (uint256 healthFactor) {     ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));     return topUpHandler.getUserFactor(account, extra); }  function getHandler(bytes32 protocol) public view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice returns the current estimated gas usage  */ function getEstimatedGasUsage() public view override returns (uint256) {     return currentUInts256[_ESTIMATED_GAS_USAGE_KEY]; }  /**  * @notice Returns the current action fee  */ function getActionFee() public view override returns (uint256) {     return currentUInts256[_ACTION_FEE_KEY]; }  /**  * @notice Returns the current fee handler  */ function getFeeHandler() public view override returns (address) {     return currentAddresses[_FEE_HANDLER_KEY]; }  /**  * @notice Get the record for a position.  * @param payer Registered payer of the position.  * @param account Address holding the position.  * @param protocol Protocol where the position is held.  */ function getPosition(     address payer,     bytes32 account,     bytes32 protocol ) public view override returns (Record memory) {     return _positions[payer][account][protocol]; }  /**  * @notice Check whether a token is usable as a deposit token.  * @param token Address of token to check.  * @return True if token is usable as a deposit token for this action.  */ function isUsable(address token) public view override returns (bool) {     return _usableTokens.contains(token); }  function _updateTopUpHandler(     bytes32 protocol,     address oldHandler,     address newHandler ) internal {     if (newHandler == address(0)) {         _supportedProtocols.remove(protocol);     } else if (oldHandler == address(0)) {         _supportedProtocols.add(protocol);     } }  /**  * @dev Pays fees to the feeHandler  * @param payer The account who's position the fees are charged on  * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)  * @param feeAmount The amount in tokens to pay as fees  * @param depositToken The LpToken used to pay the fees  */ function _payFees(     address payer,     address beneficiary,     uint256 feeAmount,     address depositToken ) internal {     address feeHandler = getFeeHandler();     IERC20(depositToken).safeApprove(feeHandler, feeAmount);     IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken); }  /**  * @dev "Locks" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function _lockFunds(     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) internal {     address stakerVaultAddress = addressProvider.getStakerVault(token);     TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount); }  function _removePosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     delete _positions[payer][account][protocol];     _removeUserPosition(payer, account, protocol);     if (_userPositions[payer].length == 0) {         _usersWithPositions.remove(payer);     }     emit Deregister(payer, account, protocol); }  function _removeUserPosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     RecordMeta[] storage positionsMeta = _userPositions[payer];     uint256 length = positionsMeta.length;     for (uint256 i; i &lt; length; i = i.uncheckedInc()) {         RecordMeta storage positionMeta = positionsMeta[i];         if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {             positionsMeta[i] = positionsMeta[length - 1];             positionsMeta.pop();             return;         }     } }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) internal {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the `actionToken`.  */ function _calcExchangeAmount(     address token,     address actionToken,     uint256 amount ) internal view returns (uint256) {     return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount); }  function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {     address handler = currentAddresses[_getProtocolKey(protocol)];     require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);     return handler; }  function _isSwappable(address depositToken, address toToken) internal view returns (bool) {     ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);     return pool.getUnderlying() == toToken; }  function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {     return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol)); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 12:30:07 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.10;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";
import "@openzeppelin/contracts/utils/math/SafeCast.sol";

import "../../../interfaces/IGasBank.sol";
import "../../../interfaces/pool/ILiquidityPool.sol";
import "../../../interfaces/IController.sol";
import "../../../interfaces/IStakerVault.sol";
import "../../../interfaces/actions/topup/ITopUpHandler.sol";
import "../../../interfaces/actions/topup/ITopUpAction.sol";
import "../../../interfaces/actions/IActionFeeHandler.sol";

import "../../../libraries/AddressProviderHelpers.sol";
import "../../../libraries/Errors.sol";
import "../../../libraries/ScaledMath.sol";
import "../../../libraries/EnumerableExtensions.sol";
import "../../../libraries/UncheckedMath.sol";

import "../../access/Authorization.sol";
import "../../utils/Preparable.sol";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param stakerVaultAddress The address of the staker vault
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > lockAmount ? lockAmount : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            _approve(token, stakerVaultAddress);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            lockAmount -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (lockAmount > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= lockAmount) {
                stakerVault.transferFrom(payer, address(this), lockAmount);
                stakerVault.increaseActionLockedBalance(payer, lockAmount);
                lockAmount = 0;
            }
        }

        require(lockAmount == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        require(underlying == actionToken, Error.TOKEN_NOT_USABLE);
        return amount.scaledDivRoundUp(rate);
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) private {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using UncheckedMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;
    using SafeCast for uint256;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being "too deep"
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
        address topUpHandler;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 550_000;

    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";
    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        for (uint256 i; i < protocols.length; i = i.uncheckedInc()) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount`, once converted to units of `actionToken`, must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param protocol Protocol which holds position to be topped up.
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable override returns (bool) {
        require(record.maxFee != 0, Error.INVALID_MAX_FEE);
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.registeredAt = uint64(block.timestamp);
        record.depositTokenBalance = totalLockAmount.toUint128();
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        IAddressProvider addressProvider_ = addressProvider;
        address vault = addressProvider_.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider_.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external override onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee)
        external
        override
        onlyGovernance
        returns (bool)
    {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external override onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external override onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external override onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage)
        external
        override
        onlyGovernance
        returns (bool)
    {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external override returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external override onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i; i < howMany; i = i.uncheckedInc()) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);
        require(block.timestamp > position.registeredAt, Error.CANNOT_EXECUTE_IN_SAME_BLOCK);

        vars.topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(vars.topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IAddressProvider addressProvider_ = addressProvider;
        IGasBank gasBank = addressProvider_.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider_.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider_.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        uint256 value_;
        if (position.actionToken == address(0)) {
            value_ = vars.actionTokenAmount;
        } else {
            _approve(position.actionToken, vars.topUpHandler);
        }
        vars.topupResult = ITopUpHandler(vars.topUpHandler).topUp{value: value_}(
            account,
            position.actionToken,
            vars.actionTokenAmount,
            position.extra
        );

        require(vars.topupResult, Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new "balance" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= vars.totalActionTokenAmount.toUint128();
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= vars.depositAmountWithFees.toUint128();

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the address to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        override
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes calldata extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view override returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the `actionToken`.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        return pool.getUnderlying() == toToken;
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.10;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";
import "@openzeppelin/contracts/utils/math/SafeCast.sol";

import "../../../interfaces/IGasBank.sol";
import "../../../interfaces/pool/ILiquidityPool.sol";
import "../../../interfaces/IController.sol";
import "../../../interfaces/IStakerVault.sol";
import "../../../interfaces/actions/topup/ITopUpHandler.sol";
import "../../../interfaces/actions/topup/ITopUpAction.sol";
import "../../../interfaces/actions/IActionFeeHandler.sol";

import "../../../libraries/AddressProviderHelpers.sol";
import "../../../libraries/Errors.sol";
import "../../../libraries/ScaledMath.sol";
import "../../../libraries/EnumerableExtensions.sol";
import "../../../libraries/UncheckedMath.sol";

import "../../access/Authorization.sol";
import "../../utils/Preparable.sol";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param stakerVaultAddress The address of the staker vault
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > lockAmount ? lockAmount : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            _approve(token, stakerVaultAddress);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            lockAmount -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (lockAmount > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= lockAmount) {
                stakerVault.transferFrom(payer, address(this), lockAmount);
                stakerVault.increaseActionLockedBalance(payer, lockAmount);
                lockAmount = 0;
            }
        }

        require(lockAmount == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        require(underlying == actionToken, Error.TOKEN_NOT_USABLE);
        return amount.scaledDivRoundUp(rate);
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) private {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using UncheckedMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;
    using SafeCast for uint256;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being "too deep"
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
        address topUpHandler;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 550_000;

    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";
    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        for (uint256 i; i < protocols.length; i = i.uncheckedInc()) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount`, once converted to units of `actionToken`, must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param protocol Protocol which holds position to be topped up.
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable override returns (bool) {
        require(record.maxFee != 0, Error.INVALID_MAX_FEE);
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.registeredAt = uint64(block.timestamp);
        record.depositTokenBalance = totalLockAmount.toUint128();
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        IAddressProvider addressProvider_ = addressProvider;
        address vault = addressProvider_.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider_.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external override onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee)
        external
        override
        onlyGovernance
        returns (bool)
    {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external override onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external override onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external override onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage)
        external
        override
        onlyGovernance
        returns (bool)
    {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external override returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external override onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i; i < howMany; i = i.uncheckedInc()) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);
        require(block.timestamp > position.registeredAt, Error.CANNOT_EXECUTE_IN_SAME_BLOCK);

        vars.topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(vars.topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IAddressProvider addressProvider_ = addressProvider;
        IGasBank gasBank = addressProvider_.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider_.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider_.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        uint256 value_;
        if (position.actionToken == address(0)) {
            value_ = vars.actionTokenAmount;
        } else {
            _approve(position.actionToken, vars.topUpHandler);
        }
        vars.topupResult = ITopUpHandler(vars.topUpHandler).topUp{value: value_}(
            account,
            position.actionToken,
            vars.actionTokenAmount,
            position.extra
        );

        require(vars.topupResult, Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new "balance" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= vars.totalActionTokenAmount.toUint128();
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= vars.depositAmountWithFees.toUint128();

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the address to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        override
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes calldata extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view override returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the `actionToken`.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        return pool.getUnderlying() == toToken;
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
".
Ideas: " 1".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-01-09 12:30:12 INFO] Retrying request to /chat/completions in 0.941583 seconds
[2024-01-09 12:30:27 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 12:30:27 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 15304
completion_tokens: 900
total_tokens: 16204
cost: $-1.000000


[2024-01-09 12:30:27 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.10;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";
import "@openzeppelin/contracts/utils/math/SafeCast.sol";

import "../../../interfaces/IGasBank.sol";
import "../../../interfaces/pool/ILiquidityPool.sol";
import "../../../interfaces/IController.sol";
import "../../../interfaces/IStakerVault.sol";
import "../../../interfaces/actions/topup/ITopUpHandler.sol";
import "../../../interfaces/actions/topup/ITopUpAction.sol";
import "../../../interfaces/actions/IActionFeeHandler.sol";

import "../../../libraries/AddressProviderHelpers.sol";
import "../../../libraries/Errors.sol";
import "../../../libraries/ScaledMath.sol";
import "../../../libraries/EnumerableExtensions.sol";
import "../../../libraries/UncheckedMath.sol";

import "../../access/Authorization.sol";
import "../../utils/Preparable.sol";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param stakerVaultAddress The address of the staker vault
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > lockAmount ? lockAmount : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            _approve(token, stakerVaultAddress);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            lockAmount -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (lockAmount > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= lockAmount) {
                stakerVault.transferFrom(payer, address(this), lockAmount);
                stakerVault.increaseActionLockedBalance(payer, lockAmount);
                lockAmount = 0;
            }
        }

        require(lockAmount == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        require(underlying == actionToken, Error.TOKEN_NOT_USABLE);
        return amount.scaledDivRoundUp(rate);
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) private {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using UncheckedMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;
    using SafeCast for uint256;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being "too deep"
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
        address topUpHandler;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 550_000;

    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";
    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        for (uint256 i; i < protocols.length; i = i.uncheckedInc()) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount`, once converted to units of `actionToken`, must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param protocol Protocol which holds position to be topped up.
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable override returns (bool) {
        require(record.maxFee != 0, Error.INVALID_MAX_FEE);
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.registeredAt = uint64(block.timestamp);
        record.depositTokenBalance = totalLockAmount.toUint128();
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        IAddressProvider addressProvider_ = addressProvider;
        address vault = addressProvider_.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider_.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external override onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee)
        external
        override
        onlyGovernance
        returns (bool)
    {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external override onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external override onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external override onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage)
        external
        override
        onlyGovernance
        returns (bool)
    {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external override returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external override onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i; i < howMany; i = i.uncheckedInc()) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);
        require(block.timestamp > position.registeredAt, Error.CANNOT_EXECUTE_IN_SAME_BLOCK);

        vars.topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(vars.topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IAddressProvider addressProvider_ = addressProvider;
        IGasBank gasBank = addressProvider_.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider_.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider_.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        uint256 value_;
        if (position.actionToken == address(0)) {
            value_ = vars.actionTokenAmount;
        } else {
            _approve(position.actionToken, vars.topUpHandler);
        }
        vars.topupResult = ITopUpHandler(vars.topUpHandler).topUp{value: value_}(
            account,
            position.actionToken,
            vars.actionTokenAmount,
            position.extra
        );

        require(vars.topupResult, Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new "balance" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= vars.totalActionTokenAmount.toUint128();
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= vars.depositAmountWithFees.toUint128();

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the address to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        override
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes calldata extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view override returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the `actionToken`.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        return pool.getUnderlying() == toToken;
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
.]

### VULNERABILITY 1: Reentrancy Attack
```
DETAILED DESCRIPTION: The contract does not implement any reentrancy guards in functions that involve external calls, such as `execute`, `resetPosition`, and `_payFees`. This could allow a malicious contract to call back into the vulnerable function before the original execution is complete, potentially leading to unexpected behavior or loss of funds.

RECOMMENDED MITIGATION: Implement the Checks-Effects-Interactions pattern. Use a reentrancy guard modifier (e.g., `nonReentrant`) to prevent reentrant calls. Ensure that state changes are made before calling external contracts.
```

### VULNERABILITY 2: Gas Limit and Loops
```
DETAILED DESCRIPTION: The `usersWithPositions` function uses a loop to return a list of users with active positions. If the number of users is large, this could exceed the gas limit, causing the transaction to fail. Additionally, the `getEthRequiredForGas` function also contains a loop that could lead to similar issues.

RECOMMENDED MITIGATION: Implement pagination for the `usersWithPositions` function to limit the number of users returned in a single call. Consider using events to log user positions instead of returning them directly in a potentially gas-heavy operation.
```

### VULNERABILITY 3: Insufficient Input Validation
```
DETAILED DESCRIPTION: In the `register` function, there are several require statements that check for valid input, but they do not cover all edge cases. For example, `record.maxFee` should be checked to ensure it is within a reasonable range to prevent excessive fees from being set.

RECOMMENDED MITIGATION: Add additional validation checks for all input parameters to ensure they fall within expected ranges. For example, check that `record.maxFee` is not only non-zero but also does not exceed a certain threshold.
```

### VULNERABILITY 4: Improper Handling of Allowances
```
DETAILED DESCRIPTION: The `_approve` function sets an infinite allowance for the spender. This could lead to issues if the spender is compromised, as it allows unlimited spending of the token.

RECOMMENDED MITIGATION: Instead of setting an infinite allowance, consider setting a specific allowance and requiring the spender to request an increase when needed. This limits the potential damage in case of a compromise.
```

### VULNERABILITY 5: Lack of Event Emission for Critical State Changes
```
DETAILED DESCRIPTION: The contract performs several critical state changes (e.g., in `resetPosition`, `_removePosition`, and `execute`), but not all of them emit events. This can make it difficult to track changes and diagnose issues.

RECOMMENDED MITIGATION: Ensure that all critical state changes emit appropriate events. This will improve transparency and allow for better tracking of contract activity.
```

### VULNERABILITY 6: Potential Integer Underflow/Overflow
```
DETAILED DESCRIPTION: Although Solidity 0.8.0 and later versions have built-in overflow and underflow protection, the use of unchecked arithmetic in some parts of the code (e.g., `uncheckedInc()`) could still lead to unexpected behavior if not handled carefully.

RECOMMENDED MITIGATION: Review all arithmetic operations to ensure they are safe and consider using SafeMath functions explicitly when necessary, even in Solidity 0.8.0 and later.
```

### VULNERABILITY 7: Improper Access Control
```
DETAILED DESCRIPTION: The contract relies on the `onlyGovernance` modifier for several functions, but there is no clear definition of what constitutes governance. If the governance mechanism is compromised, it could lead to unauthorized access to sensitive functions.

RECOMMENDED MITIGATION: Clearly define the governance mechanism and ensure that it is secure. Consider implementing a multi-signature wallet or a DAO-like structure for governance to reduce the risk of a single point of failure.
```

### VULNERABILITY 8: Lack of Fallback Function Security
```
DETAILED DESCRIPTION: The fallback function is empty, which means it can accept Ether without any checks. This could lead to unexpected behavior if Ether is sent to the contract unintentionally.

RECOMMENDED MITIGATION: Implement a fallback function that either reverts or logs an event when Ether is sent to the contract. This will help prevent unintended Ether transfers.
```

<INFO> Analysis Complete.

[2024-01-09 12:30:27 INFO] **[Seminar Conclusion]**:

 ### VULNERABILITY 1: Reentrancy Attack
```
DETAILED DESCRIPTION: The contract does not implement any reentrancy guards in functions that involve external calls, such as `execute`, `resetPosition`, and `_payFees`. This could allow a malicious contract to call back into the vulnerable function before the original execution is complete, potentially leading to unexpected behavior or loss of funds.

RECOMMENDED MITIGATION: Implement the Checks-Effects-Interactions pattern. Use a reentrancy guard modifier (e.g., `nonReentrant`) to prevent reentrant calls. Ensure that state changes are made before calling external contracts.
```

### VULNERABILITY 2: Gas Limit and Loops
```
DETAILED DESCRIPTION: The `usersWithPositions` function uses a loop to return a list of users with active positions. If the number of users is large, this could exceed the gas limit, causing the transaction to fail. Additionally, the `getEthRequiredForGas` function also contains a loop that could lead to similar issues.

RECOMMENDED MITIGATION: Implement pagination for the `usersWithPositions` function to limit the number of users returned in a single call. Consider using events to log user positions instead of returning them directly in a potentially gas-heavy operation.
```

### VULNERABILITY 3: Insufficient Input Validation
```
DETAILED DESCRIPTION: In the `register` function, there are several require statements that check for valid input, but they do not cover all edge cases. For example, `record.maxFee` should be checked to ensure it is within a reasonable range to prevent excessive fees from being set.

RECOMMENDED MITIGATION: Add additional validation checks for all input parameters to ensure they fall within expected ranges. For example, check that `record.maxFee` is not only non-zero but also does not exceed a certain threshold.
```

### VULNERABILITY 4: Improper Handling of Allowances
```
DETAILED DESCRIPTION: The `_approve` function sets an infinite allowance for the spender. This could lead to issues if the spender is compromised, as it allows unlimited spending of the token.

RECOMMENDED MITIGATION: Instead of setting an infinite allowance, consider setting a specific allowance and requiring the spender to request an increase when needed. This limits the potential damage in case of a compromise.
```

### VULNERABILITY 5: Lack of Event Emission for Critical State Changes
```
DETAILED DESCRIPTION: The contract performs several critical state changes (e.g., in `resetPosition`, `_removePosition`, and `execute`), but not all of them emit events. This can make it difficult to track changes and diagnose issues.

RECOMMENDED MITIGATION: Ensure that all critical state changes emit appropriate events. This will improve transparency and allow for better tracking of contract activity.
```

### VULNERABILITY 6: Potential Integer Underflow/Overflow
```
DETAILED DESCRIPTION: Although Solidity 0.8.0 and later versions have built-in overflow and underflow protection, the use of unchecked arithmetic in some parts of the code (e.g., `uncheckedInc()`) could still lead to unexpected behavior if not handled carefully.

RECOMMENDED MITIGATION: Review all arithmetic operations to ensure they are safe and consider using SafeMath functions explicitly when necessary, even in Solidity 0.8.0 and later.
```

### VULNERABILITY 7: Improper Access Control
```
DETAILED DESCRIPTION: The contract relies on the `onlyGovernance` modifier for several functions, but there is no clear definition of what constitutes governance. If the governance mechanism is compromised, it could lead to unauthorized access to sensitive functions.

RECOMMENDED MITIGATION: Clearly define the governance mechanism and ensure that it is secure. Consider implementing a multi-signature wallet or a DAO-like structure for governance to reduce the risk of a single point of failure.
```

### VULNERABILITY 8: Lack of Fallback Function Security
```
DETAILED DESCRIPTION: The fallback function is empty, which means it can accept Ether without any checks. This could lead to unexpected behavior if Ether is sent to the contract unintentionally.

RECOMMENDED MITIGATION: Implement a fallback function that either reverts or logs an event when Ether is sent to the contract. This will help prevent unintended Ether transfers.
```

<INFO> Analysis Complete.

[2024-01-09 12:30:27 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 1

[2024-01-09 12:30:27 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.10; import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol"; import "@openzeppelin/contracts/utils/math/SafeCast.sol"; import "../../../interfaces/IGasBank.sol"; import "../../../interfaces/pool/ILiquidityPool.sol"; import "../../../interfaces/IController.sol"; import "../../../interfaces/IStakerVault.sol"; import "../../../interfaces/actions/topup/ITopUpHandler.sol"; import "../../../interfaces/actions/topup/ITopUpAction.sol"; import "../../../interfaces/actions/IActionFeeHandler.sol"; import "../../../libraries/AddressProviderHelpers.sol"; import "../../../libraries/Errors.sol"; import "../../../libraries/ScaledMath.sol"; import "../../../libraries/EnumerableExtensions.sol"; import "../../../libraries/UncheckedMath.sol"; import "../../access/Authorization.sol"; import "../../utils/Preparable.sol"; /*  * @notice The logic here should really be part of the top-up action  * but is split in a library to circumvent the byte-code size limit  / library TopUpActionLibrary {     using SafeERC20 for IERC20;     using ScaledMath for uint256;     using AddressProviderHelpers for IAddressProvider; /**  * @dev "Locks" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param stakerVaultAddress The address of the staker vault  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function lockFunds(     address stakerVaultAddress,     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) external {     IStakerVault stakerVault = IStakerVault(stakerVaultAddress);      // stake deposit amount     if (depositAmount &gt; 0) {         depositAmount = depositAmount &gt; lockAmount ? lockAmount : depositAmount;         IERC20(token).safeTransferFrom(payer, address(this), depositAmount);         _approve(token, stakerVaultAddress);         stakerVault.stake(depositAmount);         stakerVault.increaseActionLockedBalance(payer, depositAmount);         lockAmount -= depositAmount;     }      // use stake vault allowance if available and required     if (lockAmount &gt; 0) {         uint256 balance = stakerVault.balanceOf(payer);         uint256 allowance = stakerVault.allowance(payer, address(this));         uint256 availableFunds = balance &lt; allowance ? balance : allowance;         if (availableFunds &gt;= lockAmount) {             stakerVault.transferFrom(payer, address(this), lockAmount);             stakerVault.increaseActionLockedBalance(payer, lockAmount);             lockAmount = 0;         }     }      require(lockAmount == 0, Error.INSUFFICIENT_UPDATE_BALANCE); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function calcExchangeAmount(     IAddressProvider addressProvider,     address token,     address actionToken,     uint256 amount ) external view returns (uint256) {     ILiquidityPool pool = addressProvider.getPoolForToken(token);     uint256 rate = pool.exchangeRate();     address underlying = pool.getUnderlying();     require(underlying == actionToken, Error.TOKEN_NOT_USABLE);     return amount.scaledDivRoundUp(rate); }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) private {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  } contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {     using ScaledMath for uint256;     using UncheckedMath for uint256;     using ScaledMath for uint128;     using SafeERC20 for IERC20;     using EnumerableSet for EnumerableSet.AddressSet;     using EnumerableSet for EnumerableSet.Bytes32Set;     using EnumerableExtensions for EnumerableSet.AddressSet;     using AddressProviderHelpers for IAddressProvider;     using SafeCast for uint256; /**  * @dev Temporary struct to hold local variables in execute  * and avoid the stack being "too deep"  */ struct ExecuteLocalVars {     uint256 minActionAmountToTopUp;     uint256 actionTokenAmount;     uint256 depositTotalFeesAmount;     uint256 actionAmountWithFees;     uint256 userFactor;     uint256 rate;     uint256 depositAmountWithFees;     uint256 depositAmountWithoutFees;     uint256 actionFee;     uint256 totalActionTokenAmount;     uint128 totalTopUpAmount;     bool topupResult;     uint256 gasBankBalance;     uint256 initialGas;     uint256 gasConsumed;     uint256 userGasPrice;     uint256 estimatedRequiredGas;     uint256 estimatedRequiredWeiForGas;     uint256 requiredWeiForGas;     uint256 reimbursedWeiForGas;     address underlying;     bool removePosition;     address topUpHandler; }  EnumerableSet.AddressSet private _usableTokens;  uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 550_000;  bytes32 internal constant _ACTION_FEE_KEY = "ActionFee"; bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler"; bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler"; bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";  uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;  IController public immutable controller; IAddressProvider public immutable addressProvider;  EnumerableSet.Bytes32Set internal _supportedProtocols;  /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record) mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;  mapping(address =&gt; RecordMeta[]) internal _userPositions;  EnumerableSet.AddressSet internal _usersWithPositions;  constructor(IController _controller)     Authorization(_controller.addressProvider().getRoleManager()) {     controller = _controller;     addressProvider = controller.addressProvider();     _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE); }  receive() external payable {     // solhint-disable-previous-line no-empty-blocks }  function initialize(     address feeHandler,     bytes32[] calldata protocols,     address[] calldata handlers ) external initializer onlyGovernance {     require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);     _setConfig(_FEE_HANDLER_KEY, feeHandler);     for (uint256 i; i &lt; protocols.length; i = i.uncheckedInc()) {         bytes32 protocolKey = _getProtocolKey(protocols[i]);         _setConfig(protocolKey, handlers[i]);         _updateTopUpHandler(protocols[i], address(0), handlers[i]);     } }  /**  * @notice Register a top up action.  * @dev The `depositAmount`, once converted to units of `actionToken`, must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).  * @param account Account to be topped up (first 20 bytes will typically be the address).  * @param protocol Protocol which holds position to be topped up.  * @param depositAmount Amount of `depositToken` that will be locked.  * @param record containing the data for the position to register  */ function register(     bytes32 account,     bytes32 protocol,     uint128 depositAmount,     Record memory record ) external payable override returns (bool) {     require(record.maxFee != 0, Error.INVALID_MAX_FEE);     require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);     require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);     require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);     require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);     require(         _positions[msg.sender][account][protocol].threshold == 0,         Error.POSITION_ALREADY_EXISTS     );     require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);     require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);      uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *         record.maxFee *         getEstimatedGasUsage();      require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);      uint256 totalLockAmount = _calcExchangeAmount(         record.depositToken,         record.actionToken,         record.totalTopUpAmount     );     _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);      addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);      record.registeredAt = uint64(block.timestamp);     record.depositTokenBalance = totalLockAmount.toUint128();     _positions[msg.sender][account][protocol] = record;     _userPositions[msg.sender].push(RecordMeta(account, protocol));     _usersWithPositions.add(msg.sender);      emit Register(         account,         protocol,         record.threshold,         msg.sender,         record.depositToken,         totalLockAmount,         record.actionToken,         record.singleTopUpAmount,         record.totalTopUpAmount,         record.maxFee,         record.extra     );     return true; }  /**  * @notice See overloaded version of `execute` for more details.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol ) external override returns (bool) {     return execute(payer, account, beneficiary, protocol, 0); }  /**  * @notice Delete a position to back on the given protocol for `account`.  * @param account Account holding the position.  * @param protocol Protocol the position is held on.  * @param unstake If the tokens should be unstaked from vault.  * @return `true` if successful.  */ function resetPosition(     bytes32 account,     bytes32 protocol,     bool unstake ) external override returns (bool) {     address payer = msg.sender;     Record memory position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);      IAddressProvider addressProvider_ = addressProvider;     address vault = addressProvider_.getStakerVault(position.depositToken); // will revert if vault does not exist     IStakerVault staker = IStakerVault(vault);     staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);     if (unstake) {         staker.unstake(position.depositTokenBalance);         IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);     } else {         staker.transfer(payer, position.depositTokenBalance);     }      _removePosition(payer, account, protocol);     addressProvider_.getGasBank().withdrawUnused(payer);     return true; }  /**  * @notice Execute top up handler update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @param protocol Protocol for which a new handler should be executed.  * @return Address of new handler.  */ function executeTopUpHandler(bytes32 protocol) external override returns (address) {     address oldHandler = _getHandler(protocol, false);     address newHandler = _executeAddress(_getProtocolKey(protocol));      _updateTopUpHandler(protocol, oldHandler, newHandler);     return newHandler; }  /**  * @notice Reset new top up handler deadline for a protocol.  * @param protocol Protocol for which top up handler deadline should be reset.  * @return `true` if successful.  */ function resetTopUpHandler(bytes32 protocol) external override onlyGovernance returns (bool) {     return _resetAddressConfig(_getProtocolKey(protocol)); }  /**  * @notice Prepare action fee update.  * @param newActionFee New fee to set.  * @return `true` if success.  */ function prepareActionFee(uint256 newActionFee)     external     override     onlyGovernance     returns (bool) {     require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);     return _prepare(_ACTION_FEE_KEY, newActionFee); }  /**  * @notice Execute action fee update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeActionFee() external override returns (uint256) {     return _executeUInt256(_ACTION_FEE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetActionFee() external override onlyGovernance returns (bool) {     return _resetUInt256Config(_ACTION_FEE_KEY); }  /** Set fee handler */ /**  * @notice Prepare update of fee handler.  * @param handler New fee handler.  * @return `true` if success.  */ function prepareFeeHandler(address handler) external override onlyGovernance returns (bool) {     return _prepare(_FEE_HANDLER_KEY, handler); }  /**  * @notice Execute update of fee handler (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeFeeHandler() external override returns (address) {     return _executeAddress(_FEE_HANDLER_KEY); }  /**  * @notice Reset the handler deadline.  * @return `true` if success.  */ function resetFeeHandler() external override onlyGovernance returns (bool) {     return _resetAddressConfig(_FEE_HANDLER_KEY); }  /**  * @notice Prepare update of estimated gas usage.  * @param gasUsage New estimated gas usage.  * @return `true` if success.  */ function prepareEstimatedGasUsage(uint256 gasUsage)     external     override     onlyGovernance     returns (bool) {     return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage); }  /**  * @notice Execute update of gas usage (with time delay enforced).  * @return `true` if successful.  */ function executeEstimatedGasUsage() external override returns (uint256) {     return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Reset the gas usage deadline.  * @return `true` if success.  */ function resetGasUsage() external override onlyGovernance returns (bool) {     return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Add a new deposit token that is supported by the action.  * @dev There is a separate check for whether the usable token (i.e. deposit token)  *      is swappable for some action token.  * @param token Address of deposit token that can be used by the action.  */ function addUsableToken(address token) external override onlyGovernance returns (bool) {     return _usableTokens.add(token); }  /**  * @notice Computes the total amount of ETH (as wei) required to pay for all  * the top-ups assuming the maximum gas price and the current estimated gas  * usage of a top-up  */ function getEthRequiredForGas(address payer) external view override returns (uint256) {     uint256 totalEthRequired;     RecordMeta[] memory userRecordsMeta = _userPositions[payer];     uint256 gasUsagePerCall = getEstimatedGasUsage();     uint256 length = userRecordsMeta.length;     for (uint256 i; i &lt; length; i = i.uncheckedInc()) {         RecordMeta memory meta = userRecordsMeta[i];         Record memory record = _positions[payer][meta.account][meta.protocol];         uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);         totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;     }     return totalEthRequired; }  /**  * @notice Returns a list of positions for the given payer  */ function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {     return _userPositions[payer]; }  /**  * @notice Get a list supported protocols.  * @return List of supported protocols.  */ function getSupportedProtocols() external view override returns (bytes32[] memory) {     uint256 length = _supportedProtocols.length();     bytes32[] memory protocols = new bytes32[](length);     for (uint256 i; i &lt; length; i = i.uncheckedInc()) {         protocols[i] = _supportedProtocols.at(i);     }     return protocols; }  /*  * @notice Gets a list of users that have an active position.  * @dev Uses cursor pagination.  * @param cursor The cursor for pagination (should start at 0 for first call).  * @param howMany Maximum number of users to return in this pagination request.  * @return users List of users that have an active position.  * @return nextCursor The cursor to use for the next pagination request.  */ function usersWithPositions(uint256 cursor, uint256 howMany)     external     view     override     returns (address[] memory users, uint256 nextCursor) {     uint256 length = _usersWithPositions.length();     if (cursor &gt;= length) return (new address[](0), 0);     if (howMany &gt;= length - cursor) {         howMany = length - cursor;     }      address[] memory usersWithPositions_ = new address[](howMany);     for (uint256 i; i &lt; howMany; i = i.uncheckedInc()) {         usersWithPositions_[i] = _usersWithPositions.at(i + cursor);     }      return (usersWithPositions_, cursor + howMany); }  /**  * @notice Get a list of all tokens usable for this action.  * @dev This refers to all tokens that can be used as deposit tokens.  * @return Array of addresses of usable tokens.  */ function getUsableTokens() external view override returns (address[] memory) {     return _usableTokens.toArray(); }  /**  * @notice Retrieves the topup handler for the given `protocol`  */ function getTopUpHandler(bytes32 protocol) external view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice Successfully tops up a position if it's conditions are met.  * @dev pool and vault funds are rebalanced after withdrawal for top up  * @param payer Account that pays for the top up.  * @param account Account owning the position for top up.  * @param beneficiary Address of the keeper's wallet for fee accrual.  * @param protocol Protocol of the top up position.  * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas  * @return `true` if successful.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol,     uint256 maxWeiForGas ) public override returns (bool) {     require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);      ExecuteLocalVars memory vars;      vars.initialGas = gasleft();      Record storage position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);     require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);     require(block.timestamp &gt; position.registeredAt, Error.CANNOT_EXECUTE_IN_SAME_BLOCK);      vars.topUpHandler = _getHandler(protocol, true);     vars.userFactor = ITopUpHandler(vars.topUpHandler).getUserFactor(account, position.extra);      // ensure that the position is actually below its set user factor threshold     require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);      IAddressProvider addressProvider_ = addressProvider;     IGasBank gasBank = addressProvider_.getGasBank();      // fail early if the user does not have enough funds in the gas bank     // to cover the cost of the transaction     vars.estimatedRequiredGas = getEstimatedGasUsage();     vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;      // compute the gas price that the user will be paying     vars.userGasPrice = block.basefee + position.priorityFee;     if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;     if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;      // ensure the current position allows for the gas to be paid     require(         vars.estimatedRequiredWeiForGas &lt;=             vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,         Error.ESTIMATED_GAS_TOO_HIGH     );      vars.gasBankBalance = gasBank.balanceOf(payer);     // ensure the user has enough funds in the gas bank to cover the gas     require(         vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,         Error.GAS_BANK_BALANCE_TOO_LOW     );      vars.totalTopUpAmount = position.totalTopUpAmount;     vars.actionFee = getActionFee();     // add top-up fees to top-up amount     vars.minActionAmountToTopUp = position.singleTopUpAmount;     vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(         ScaledMath.ONE + vars.actionFee     );      // if the amount that we want to top-up (including fees) is higher than     // the available topup amount, we lower this down to what is left of the position     if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {         vars.actionAmountWithFees = vars.totalTopUpAmount;         vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(             ScaledMath.ONE + vars.actionFee         );     }     ILiquidityPool pool = addressProvider_.getPoolForToken(position.depositToken);     vars.underlying = pool.getUnderlying();     vars.rate = pool.exchangeRate();      // compute the deposit tokens amount with and without fees     // we will need to unstake the amount with fees and to     // swap the amount without fees into action tokens     vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);     if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {         vars.depositAmountWithFees = position.depositTokenBalance;         vars.minActionAmountToTopUp =             (vars.depositAmountWithFees * vars.rate) /             (ScaledMath.ONE + vars.actionFee);     }      // compute amount of LP tokens needed to pay for action     // rate is expressed in actionToken per depositToken     vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);     vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;      // will revert if vault does not exist     address vault = addressProvider_.getStakerVault(position.depositToken);      // unstake deposit tokens including fees     IStakerVault(vault).unstake(vars.depositAmountWithFees);     IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);      // swap the amount without the fees     // as the fees are paid in deposit token, not in action token     vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);      // compute how much of action token was actually redeemed and add fees to it     // this is to ensure that no funds get locked inside the contract     vars.totalActionTokenAmount =         vars.actionTokenAmount +         vars.depositTotalFeesAmount.scaledMul(vars.rate);      // at this point, we have exactly `vars.actionTokenAmount`     // (at least `position.singleTopUpAmount`) of action token     // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract     // solhint-disable-next-line avoid-low-level-calls     uint256 value_;     if (position.actionToken == address(0)) {         value_ = vars.actionTokenAmount;     } else {         _approve(position.actionToken, vars.topUpHandler);     }     vars.topupResult = ITopUpHandler(vars.topUpHandler).topUp{value: value_}(         account,         position.actionToken,         vars.actionTokenAmount,         position.extra     );      require(vars.topupResult, Error.TOP_UP_FAILED);      // totalTopUpAmount is updated to reflect the new "balance" of the position     if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {         position.totalTopUpAmount -= vars.totalActionTokenAmount.toUint128();     } else {         position.totalTopUpAmount = 0;     }      position.depositTokenBalance -= vars.depositAmountWithFees.toUint128();      vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;     _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);     if (vars.removePosition) {         if (position.depositTokenBalance &gt; 0) {             // transfer any unused locked tokens to the payer             IStakerVault(vault).transfer(payer, position.depositTokenBalance);             IStakerVault(vault).decreaseActionLockedBalance(                 payer,                 position.depositTokenBalance             );         }         _removePosition(payer, account, protocol);     }      emit TopUp(         account,         protocol,         payer,         position.depositToken,         vars.depositAmountWithFees,         position.actionToken,         vars.actionTokenAmount     );      // compute gas used and reimburse the keeper by using the     // funds of payer in the gas bank     // TODO: add constant gas consumed for transfer and tx prologue     vars.gasConsumed = vars.initialGas - gasleft();      vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;     if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {         vars.reimbursedWeiForGas = vars.gasBankBalance;     }      // ensure that the keeper is not overpaying     vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;     require(         vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,         Error.GAS_TOO_HIGH     );     gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);     if (vars.removePosition) {         gasBank.withdrawUnused(payer);     }      return true; }  /**  * @notice Prepare new top up handler fee update.  * @dev Setting the address to 0 means that the protocol will no longer be supported.  * @param protocol Protocol for which a new handler should be prepared.  * @param newHandler Address of new handler.  * @return `true` if success.  */ function prepareTopUpHandler(bytes32 protocol, address newHandler)     public     override     onlyGovernance     returns (bool) {     return _prepare(_getProtocolKey(protocol), newHandler); }  /**  * @notice Check if action can be executed.  * @param protocol for which to get the health factor  * @param account for which to get the health factor  * @param extra data to be used by the topup handler  * @return healthFactor of the position  */ function getHealthFactor(     bytes32 protocol,     bytes32 account,     bytes calldata extra ) public view override returns (uint256 healthFactor) {     ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));     return topUpHandler.getUserFactor(account, extra); }  function getHandler(bytes32 protocol) public view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice returns the current estimated gas usage  */ function getEstimatedGasUsage() public view override returns (uint256) {     return currentUInts256[_ESTIMATED_GAS_USAGE_KEY]; }  /**  * @notice Returns the current action fee  */ function getActionFee() public view override returns (uint256) {     return currentUInts256[_ACTION_FEE_KEY]; }  /**  * @notice Returns the current fee handler  */ function getFeeHandler() public view override returns (address) {     return currentAddresses[_FEE_HANDLER_KEY]; }  /**  * @notice Get the record for a position.  * @param payer Registered payer of the position.  * @param account Address holding the position.  * @param protocol Protocol where the position is held.  */ function getPosition(     address payer,     bytes32 account,     bytes32 protocol ) public view override returns (Record memory) {     return _positions[payer][account][protocol]; }  /**  * @notice Check whether a token is usable as a deposit token.  * @param token Address of token to check.  * @return True if token is usable as a deposit token for this action.  */ function isUsable(address token) public view override returns (bool) {     return _usableTokens.contains(token); }  function _updateTopUpHandler(     bytes32 protocol,     address oldHandler,     address newHandler ) internal {     if (newHandler == address(0)) {         _supportedProtocols.remove(protocol);     } else if (oldHandler == address(0)) {         _supportedProtocols.add(protocol);     } }  /**  * @dev Pays fees to the feeHandler  * @param payer The account who's position the fees are charged on  * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)  * @param feeAmount The amount in tokens to pay as fees  * @param depositToken The LpToken used to pay the fees  */ function _payFees(     address payer,     address beneficiary,     uint256 feeAmount,     address depositToken ) internal {     address feeHandler = getFeeHandler();     IERC20(depositToken).safeApprove(feeHandler, feeAmount);     IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken); }  /**  * @dev "Locks" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function _lockFunds(     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) internal {     address stakerVaultAddress = addressProvider.getStakerVault(token);     TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount); }  function _removePosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     delete _positions[payer][account][protocol];     _removeUserPosition(payer, account, protocol);     if (_userPositions[payer].length == 0) {         _usersWithPositions.remove(payer);     }     emit Deregister(payer, account, protocol); }  function _removeUserPosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     RecordMeta[] storage positionsMeta = _userPositions[payer];     uint256 length = positionsMeta.length;     for (uint256 i; i &lt; length; i = i.uncheckedInc()) {         RecordMeta storage positionMeta = positionsMeta[i];         if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {             positionsMeta[i] = positionsMeta[length - 1];             positionsMeta.pop();             return;         }     } }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) internal {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the `actionToken`.  */ function _calcExchangeAmount(     address token,     address actionToken,     uint256 amount ) internal view returns (uint256) {     return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount); }  function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {     address handler = currentAddresses[_getProtocolKey(protocol)];     require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);     return handler; }  function _isSwappable(address depositToken, address toToken) internal view returns (bool) {     ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);     return pool.getUnderlying() == toToken; }  function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {     return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol)); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '', 'ideas': ' 1'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 12:30:27 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.10; import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol"; import "@openzeppelin/contracts/utils/math/SafeCast.sol"; import "../../../interfaces/IGasBank.sol"; import "../../../interfaces/pool/ILiquidityPool.sol"; import "../../../interfaces/IController.sol"; import "../../../interfaces/IStakerVault.sol"; import "../../../interfaces/actions/topup/ITopUpHandler.sol"; import "../../../interfaces/actions/topup/ITopUpAction.sol"; import "../../../interfaces/actions/IActionFeeHandler.sol"; import "../../../libraries/AddressProviderHelpers.sol"; import "../../../libraries/Errors.sol"; import "../../../libraries/ScaledMath.sol"; import "../../../libraries/EnumerableExtensions.sol"; import "../../../libraries/UncheckedMath.sol"; import "../../access/Authorization.sol"; import "../../utils/Preparable.sol"; /*  * @notice The logic here should really be part of the top-up action  * but is split in a library to circumvent the byte-code size limit  / library TopUpActionLibrary {     using SafeERC20 for IERC20;     using ScaledMath for uint256;     using AddressProviderHelpers for IAddressProvider; /**  * @dev "Locks" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param stakerVaultAddress The address of the staker vault  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function lockFunds(     address stakerVaultAddress,     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) external {     IStakerVault stakerVault = IStakerVault(stakerVaultAddress);      // stake deposit amount     if (depositAmount &gt; 0) {         depositAmount = depositAmount &gt; lockAmount ? lockAmount : depositAmount;         IERC20(token).safeTransferFrom(payer, address(this), depositAmount);         _approve(token, stakerVaultAddress);         stakerVault.stake(depositAmount);         stakerVault.increaseActionLockedBalance(payer, depositAmount);         lockAmount -= depositAmount;     }      // use stake vault allowance if available and required     if (lockAmount &gt; 0) {         uint256 balance = stakerVault.balanceOf(payer);         uint256 allowance = stakerVault.allowance(payer, address(this));         uint256 availableFunds = balance &lt; allowance ? balance : allowance;         if (availableFunds &gt;= lockAmount) {             stakerVault.transferFrom(payer, address(this), lockAmount);             stakerVault.increaseActionLockedBalance(payer, lockAmount);             lockAmount = 0;         }     }      require(lockAmount == 0, Error.INSUFFICIENT_UPDATE_BALANCE); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function calcExchangeAmount(     IAddressProvider addressProvider,     address token,     address actionToken,     uint256 amount ) external view returns (uint256) {     ILiquidityPool pool = addressProvider.getPoolForToken(token);     uint256 rate = pool.exchangeRate();     address underlying = pool.getUnderlying();     require(underlying == actionToken, Error.TOKEN_NOT_USABLE);     return amount.scaledDivRoundUp(rate); }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) private {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  } contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {     using ScaledMath for uint256;     using UncheckedMath for uint256;     using ScaledMath for uint128;     using SafeERC20 for IERC20;     using EnumerableSet for EnumerableSet.AddressSet;     using EnumerableSet for EnumerableSet.Bytes32Set;     using EnumerableExtensions for EnumerableSet.AddressSet;     using AddressProviderHelpers for IAddressProvider;     using SafeCast for uint256; /**  * @dev Temporary struct to hold local variables in execute  * and avoid the stack being "too deep"  */ struct ExecuteLocalVars {     uint256 minActionAmountToTopUp;     uint256 actionTokenAmount;     uint256 depositTotalFeesAmount;     uint256 actionAmountWithFees;     uint256 userFactor;     uint256 rate;     uint256 depositAmountWithFees;     uint256 depositAmountWithoutFees;     uint256 actionFee;     uint256 totalActionTokenAmount;     uint128 totalTopUpAmount;     bool topupResult;     uint256 gasBankBalance;     uint256 initialGas;     uint256 gasConsumed;     uint256 userGasPrice;     uint256 estimatedRequiredGas;     uint256 estimatedRequiredWeiForGas;     uint256 requiredWeiForGas;     uint256 reimbursedWeiForGas;     address underlying;     bool removePosition;     address topUpHandler; }  EnumerableSet.AddressSet private _usableTokens;  uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 550_000;  bytes32 internal constant _ACTION_FEE_KEY = "ActionFee"; bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler"; bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler"; bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";  uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;  IController public immutable controller; IAddressProvider public immutable addressProvider;  EnumerableSet.Bytes32Set internal _supportedProtocols;  /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record) mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;  mapping(address =&gt; RecordMeta[]) internal _userPositions;  EnumerableSet.AddressSet internal _usersWithPositions;  constructor(IController _controller)     Authorization(_controller.addressProvider().getRoleManager()) {     controller = _controller;     addressProvider = controller.addressProvider();     _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE); }  receive() external payable {     // solhint-disable-previous-line no-empty-blocks }  function initialize(     address feeHandler,     bytes32[] calldata protocols,     address[] calldata handlers ) external initializer onlyGovernance {     require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);     _setConfig(_FEE_HANDLER_KEY, feeHandler);     for (uint256 i; i &lt; protocols.length; i = i.uncheckedInc()) {         bytes32 protocolKey = _getProtocolKey(protocols[i]);         _setConfig(protocolKey, handlers[i]);         _updateTopUpHandler(protocols[i], address(0), handlers[i]);     } }  /**  * @notice Register a top up action.  * @dev The `depositAmount`, once converted to units of `actionToken`, must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).  * @param account Account to be topped up (first 20 bytes will typically be the address).  * @param protocol Protocol which holds position to be topped up.  * @param depositAmount Amount of `depositToken` that will be locked.  * @param record containing the data for the position to register  */ function register(     bytes32 account,     bytes32 protocol,     uint128 depositAmount,     Record memory record ) external payable override returns (bool) {     require(record.maxFee != 0, Error.INVALID_MAX_FEE);     require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);     require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);     require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);     require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);     require(         _positions[msg.sender][account][protocol].threshold == 0,         Error.POSITION_ALREADY_EXISTS     );     require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);     require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);      uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *         record.maxFee *         getEstimatedGasUsage();      require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);      uint256 totalLockAmount = _calcExchangeAmount(         record.depositToken,         record.actionToken,         record.totalTopUpAmount     );     _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);      addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);      record.registeredAt = uint64(block.timestamp);     record.depositTokenBalance = totalLockAmount.toUint128();     _positions[msg.sender][account][protocol] = record;     _userPositions[msg.sender].push(RecordMeta(account, protocol));     _usersWithPositions.add(msg.sender);      emit Register(         account,         protocol,         record.threshold,         msg.sender,         record.depositToken,         totalLockAmount,         record.actionToken,         record.singleTopUpAmount,         record.totalTopUpAmount,         record.maxFee,         record.extra     );     return true; }  /**  * @notice See overloaded version of `execute` for more details.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol ) external override returns (bool) {     return execute(payer, account, beneficiary, protocol, 0); }  /**  * @notice Delete a position to back on the given protocol for `account`.  * @param account Account holding the position.  * @param protocol Protocol the position is held on.  * @param unstake If the tokens should be unstaked from vault.  * @return `true` if successful.  */ function resetPosition(     bytes32 account,     bytes32 protocol,     bool unstake ) external override returns (bool) {     address payer = msg.sender;     Record memory position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);      IAddressProvider addressProvider_ = addressProvider;     address vault = addressProvider_.getStakerVault(position.depositToken); // will revert if vault does not exist     IStakerVault staker = IStakerVault(vault);     staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);     if (unstake) {         staker.unstake(position.depositTokenBalance);         IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);     } else {         staker.transfer(payer, position.depositTokenBalance);     }      _removePosition(payer, account, protocol);     addressProvider_.getGasBank().withdrawUnused(payer);     return true; }  /**  * @notice Execute top up handler update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @param protocol Protocol for which a new handler should be executed.  * @return Address of new handler.  */ function executeTopUpHandler(bytes32 protocol) external override returns (address) {     address oldHandler = _getHandler(protocol, false);     address newHandler = _executeAddress(_getProtocolKey(protocol));      _updateTopUpHandler(protocol, oldHandler, newHandler);     return newHandler; }  /**  * @notice Reset new top up handler deadline for a protocol.  * @param protocol Protocol for which top up handler deadline should be reset.  * @return `true` if successful.  */ function resetTopUpHandler(bytes32 protocol) external override onlyGovernance returns (bool) {     return _resetAddressConfig(_getProtocolKey(protocol)); }  /**  * @notice Prepare action fee update.  * @param newActionFee New fee to set.  * @return `true` if success.  */ function prepareActionFee(uint256 newActionFee)     external     override     onlyGovernance     returns (bool) {     require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);     return _prepare(_ACTION_FEE_KEY, newActionFee); }  /**  * @notice Execute action fee update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeActionFee() external override returns (uint256) {     return _executeUInt256(_ACTION_FEE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetActionFee() external override onlyGovernance returns (bool) {     return _resetUInt256Config(_ACTION_FEE_KEY); }  /** Set fee handler */ /**  * @notice Prepare update of fee handler.  * @param handler New fee handler.  * @return `true` if success.  */ function prepareFeeHandler(address handler) external override onlyGovernance returns (bool) {     return _prepare(_FEE_HANDLER_KEY, handler); }  /**  * @notice Execute update of fee handler (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeFeeHandler() external override returns (address) {     return _executeAddress(_FEE_HANDLER_KEY); }  /**  * @notice Reset the handler deadline.  * @return `true` if success.  */ function resetFeeHandler() external override onlyGovernance returns (bool) {     return _resetAddressConfig(_FEE_HANDLER_KEY); }  /**  * @notice Prepare update of estimated gas usage.  * @param gasUsage New estimated gas usage.  * @return `true` if success.  */ function prepareEstimatedGasUsage(uint256 gasUsage)     external     override     onlyGovernance     returns (bool) {     return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage); }  /**  * @notice Execute update of gas usage (with time delay enforced).  * @return `true` if successful.  */ function executeEstimatedGasUsage() external override returns (uint256) {     return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Reset the gas usage deadline.  * @return `true` if success.  */ function resetGasUsage() external override onlyGovernance returns (bool) {     return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Add a new deposit token that is supported by the action.  * @dev There is a separate check for whether the usable token (i.e. deposit token)  *      is swappable for some action token.  * @param token Address of deposit token that can be used by the action.  */ function addUsableToken(address token) external override onlyGovernance returns (bool) {     return _usableTokens.add(token); }  /**  * @notice Computes the total amount of ETH (as wei) required to pay for all  * the top-ups assuming the maximum gas price and the current estimated gas  * usage of a top-up  */ function getEthRequiredForGas(address payer) external view override returns (uint256) {     uint256 totalEthRequired;     RecordMeta[] memory userRecordsMeta = _userPositions[payer];     uint256 gasUsagePerCall = getEstimatedGasUsage();     uint256 length = userRecordsMeta.length;     for (uint256 i; i &lt; length; i = i.uncheckedInc()) {         RecordMeta memory meta = userRecordsMeta[i];         Record memory record = _positions[payer][meta.account][meta.protocol];         uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);         totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;     }     return totalEthRequired; }  /**  * @notice Returns a list of positions for the given payer  */ function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {     return _userPositions[payer]; }  /**  * @notice Get a list supported protocols.  * @return List of supported protocols.  */ function getSupportedProtocols() external view override returns (bytes32[] memory) {     uint256 length = _supportedProtocols.length();     bytes32[] memory protocols = new bytes32[](length);     for (uint256 i; i &lt; length; i = i.uncheckedInc()) {         protocols[i] = _supportedProtocols.at(i);     }     return protocols; }  /*  * @notice Gets a list of users that have an active position.  * @dev Uses cursor pagination.  * @param cursor The cursor for pagination (should start at 0 for first call).  * @param howMany Maximum number of users to return in this pagination request.  * @return users List of users that have an active position.  * @return nextCursor The cursor to use for the next pagination request.  */ function usersWithPositions(uint256 cursor, uint256 howMany)     external     view     override     returns (address[] memory users, uint256 nextCursor) {     uint256 length = _usersWithPositions.length();     if (cursor &gt;= length) return (new address[](0), 0);     if (howMany &gt;= length - cursor) {         howMany = length - cursor;     }      address[] memory usersWithPositions_ = new address[](howMany);     for (uint256 i; i &lt; howMany; i = i.uncheckedInc()) {         usersWithPositions_[i] = _usersWithPositions.at(i + cursor);     }      return (usersWithPositions_, cursor + howMany); }  /**  * @notice Get a list of all tokens usable for this action.  * @dev This refers to all tokens that can be used as deposit tokens.  * @return Array of addresses of usable tokens.  */ function getUsableTokens() external view override returns (address[] memory) {     return _usableTokens.toArray(); }  /**  * @notice Retrieves the topup handler for the given `protocol`  */ function getTopUpHandler(bytes32 protocol) external view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice Successfully tops up a position if it's conditions are met.  * @dev pool and vault funds are rebalanced after withdrawal for top up  * @param payer Account that pays for the top up.  * @param account Account owning the position for top up.  * @param beneficiary Address of the keeper's wallet for fee accrual.  * @param protocol Protocol of the top up position.  * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas  * @return `true` if successful.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol,     uint256 maxWeiForGas ) public override returns (bool) {     require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);      ExecuteLocalVars memory vars;      vars.initialGas = gasleft();      Record storage position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);     require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);     require(block.timestamp &gt; position.registeredAt, Error.CANNOT_EXECUTE_IN_SAME_BLOCK);      vars.topUpHandler = _getHandler(protocol, true);     vars.userFactor = ITopUpHandler(vars.topUpHandler).getUserFactor(account, position.extra);      // ensure that the position is actually below its set user factor threshold     require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);      IAddressProvider addressProvider_ = addressProvider;     IGasBank gasBank = addressProvider_.getGasBank();      // fail early if the user does not have enough funds in the gas bank     // to cover the cost of the transaction     vars.estimatedRequiredGas = getEstimatedGasUsage();     vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;      // compute the gas price that the user will be paying     vars.userGasPrice = block.basefee + position.priorityFee;     if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;     if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;      // ensure the current position allows for the gas to be paid     require(         vars.estimatedRequiredWeiForGas &lt;=             vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,         Error.ESTIMATED_GAS_TOO_HIGH     );      vars.gasBankBalance = gasBank.balanceOf(payer);     // ensure the user has enough funds in the gas bank to cover the gas     require(         vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,         Error.GAS_BANK_BALANCE_TOO_LOW     );      vars.totalTopUpAmount = position.totalTopUpAmount;     vars.actionFee = getActionFee();     // add top-up fees to top-up amount     vars.minActionAmountToTopUp = position.singleTopUpAmount;     vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(         ScaledMath.ONE + vars.actionFee     );      // if the amount that we want to top-up (including fees) is higher than     // the available topup amount, we lower this down to what is left of the position     if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {         vars.actionAmountWithFees = vars.totalTopUpAmount;         vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(             ScaledMath.ONE + vars.actionFee         );     }     ILiquidityPool pool = addressProvider_.getPoolForToken(position.depositToken);     vars.underlying = pool.getUnderlying();     vars.rate = pool.exchangeRate();      // compute the deposit tokens amount with and without fees     // we will need to unstake the amount with fees and to     // swap the amount without fees into action tokens     vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);     if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {         vars.depositAmountWithFees = position.depositTokenBalance;         vars.minActionAmountToTopUp =             (vars.depositAmountWithFees * vars.rate) /             (ScaledMath.ONE + vars.actionFee);     }      // compute amount of LP tokens needed to pay for action     // rate is expressed in actionToken per depositToken     vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);     vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;      // will revert if vault does not exist     address vault = addressProvider_.getStakerVault(position.depositToken);      // unstake deposit tokens including fees     IStakerVault(vault).unstake(vars.depositAmountWithFees);     IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);      // swap the amount without the fees     // as the fees are paid in deposit token, not in action token     vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);      // compute how much of action token was actually redeemed and add fees to it     // this is to ensure that no funds get locked inside the contract     vars.totalActionTokenAmount =         vars.actionTokenAmount +         vars.depositTotalFeesAmount.scaledMul(vars.rate);      // at this point, we have exactly `vars.actionTokenAmount`     // (at least `position.singleTopUpAmount`) of action token     // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract     // solhint-disable-next-line avoid-low-level-calls     uint256 value_;     if (position.actionToken == address(0)) {         value_ = vars.actionTokenAmount;     } else {         _approve(position.actionToken, vars.topUpHandler);     }     vars.topupResult = ITopUpHandler(vars.topUpHandler).topUp{value: value_}(         account,         position.actionToken,         vars.actionTokenAmount,         position.extra     );      require(vars.topupResult, Error.TOP_UP_FAILED);      // totalTopUpAmount is updated to reflect the new "balance" of the position     if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {         position.totalTopUpAmount -= vars.totalActionTokenAmount.toUint128();     } else {         position.totalTopUpAmount = 0;     }      position.depositTokenBalance -= vars.depositAmountWithFees.toUint128();      vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;     _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);     if (vars.removePosition) {         if (position.depositTokenBalance &gt; 0) {             // transfer any unused locked tokens to the payer             IStakerVault(vault).transfer(payer, position.depositTokenBalance);             IStakerVault(vault).decreaseActionLockedBalance(                 payer,                 position.depositTokenBalance             );         }         _removePosition(payer, account, protocol);     }      emit TopUp(         account,         protocol,         payer,         position.depositToken,         vars.depositAmountWithFees,         position.actionToken,         vars.actionTokenAmount     );      // compute gas used and reimburse the keeper by using the     // funds of payer in the gas bank     // TODO: add constant gas consumed for transfer and tx prologue     vars.gasConsumed = vars.initialGas - gasleft();      vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;     if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {         vars.reimbursedWeiForGas = vars.gasBankBalance;     }      // ensure that the keeper is not overpaying     vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;     require(         vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,         Error.GAS_TOO_HIGH     );     gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);     if (vars.removePosition) {         gasBank.withdrawUnused(payer);     }      return true; }  /**  * @notice Prepare new top up handler fee update.  * @dev Setting the address to 0 means that the protocol will no longer be supported.  * @param protocol Protocol for which a new handler should be prepared.  * @param newHandler Address of new handler.  * @return `true` if success.  */ function prepareTopUpHandler(bytes32 protocol, address newHandler)     public     override     onlyGovernance     returns (bool) {     return _prepare(_getProtocolKey(protocol), newHandler); }  /**  * @notice Check if action can be executed.  * @param protocol for which to get the health factor  * @param account for which to get the health factor  * @param extra data to be used by the topup handler  * @return healthFactor of the position  */ function getHealthFactor(     bytes32 protocol,     bytes32 account,     bytes calldata extra ) public view override returns (uint256 healthFactor) {     ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));     return topUpHandler.getUserFactor(account, extra); }  function getHandler(bytes32 protocol) public view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice returns the current estimated gas usage  */ function getEstimatedGasUsage() public view override returns (uint256) {     return currentUInts256[_ESTIMATED_GAS_USAGE_KEY]; }  /**  * @notice Returns the current action fee  */ function getActionFee() public view override returns (uint256) {     return currentUInts256[_ACTION_FEE_KEY]; }  /**  * @notice Returns the current fee handler  */ function getFeeHandler() public view override returns (address) {     return currentAddresses[_FEE_HANDLER_KEY]; }  /**  * @notice Get the record for a position.  * @param payer Registered payer of the position.  * @param account Address holding the position.  * @param protocol Protocol where the position is held.  */ function getPosition(     address payer,     bytes32 account,     bytes32 protocol ) public view override returns (Record memory) {     return _positions[payer][account][protocol]; }  /**  * @notice Check whether a token is usable as a deposit token.  * @param token Address of token to check.  * @return True if token is usable as a deposit token for this action.  */ function isUsable(address token) public view override returns (bool) {     return _usableTokens.contains(token); }  function _updateTopUpHandler(     bytes32 protocol,     address oldHandler,     address newHandler ) internal {     if (newHandler == address(0)) {         _supportedProtocols.remove(protocol);     } else if (oldHandler == address(0)) {         _supportedProtocols.add(protocol);     } }  /**  * @dev Pays fees to the feeHandler  * @param payer The account who's position the fees are charged on  * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)  * @param feeAmount The amount in tokens to pay as fees  * @param depositToken The LpToken used to pay the fees  */ function _payFees(     address payer,     address beneficiary,     uint256 feeAmount,     address depositToken ) internal {     address feeHandler = getFeeHandler();     IERC20(depositToken).safeApprove(feeHandler, feeAmount);     IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken); }  /**  * @dev "Locks" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function _lockFunds(     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) internal {     address stakerVaultAddress = addressProvider.getStakerVault(token);     TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount); }  function _removePosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     delete _positions[payer][account][protocol];     _removeUserPosition(payer, account, protocol);     if (_userPositions[payer].length == 0) {         _usersWithPositions.remove(payer);     }     emit Deregister(payer, account, protocol); }  function _removeUserPosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     RecordMeta[] storage positionsMeta = _userPositions[payer];     uint256 length = positionsMeta.length;     for (uint256 i; i &lt; length; i = i.uncheckedInc()) {         RecordMeta storage positionMeta = positionsMeta[i];         if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {             positionsMeta[i] = positionsMeta[length - 1];             positionsMeta.pop();             return;         }     } }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) internal {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the `actionToken`.  */ function _calcExchangeAmount(     address token,     address actionToken,     uint256 amount ) internal view returns (uint256) {     return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount); }  function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {     address handler = currentAddresses[_getProtocolKey(protocol)];     require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);     return handler; }  function _isSwappable(address depositToken, address toToken) internal view returns (bool) {     ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);     return pool.getUnderlying() == toToken; }  function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {     return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol)); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 12:30:27 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.10;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";
import "@openzeppelin/contracts/utils/math/SafeCast.sol";

import "../../../interfaces/IGasBank.sol";
import "../../../interfaces/pool/ILiquidityPool.sol";
import "../../../interfaces/IController.sol";
import "../../../interfaces/IStakerVault.sol";
import "../../../interfaces/actions/topup/ITopUpHandler.sol";
import "../../../interfaces/actions/topup/ITopUpAction.sol";
import "../../../interfaces/actions/IActionFeeHandler.sol";

import "../../../libraries/AddressProviderHelpers.sol";
import "../../../libraries/Errors.sol";
import "../../../libraries/ScaledMath.sol";
import "../../../libraries/EnumerableExtensions.sol";
import "../../../libraries/UncheckedMath.sol";

import "../../access/Authorization.sol";
import "../../utils/Preparable.sol";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param stakerVaultAddress The address of the staker vault
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > lockAmount ? lockAmount : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            _approve(token, stakerVaultAddress);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            lockAmount -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (lockAmount > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= lockAmount) {
                stakerVault.transferFrom(payer, address(this), lockAmount);
                stakerVault.increaseActionLockedBalance(payer, lockAmount);
                lockAmount = 0;
            }
        }

        require(lockAmount == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        require(underlying == actionToken, Error.TOKEN_NOT_USABLE);
        return amount.scaledDivRoundUp(rate);
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) private {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using UncheckedMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;
    using SafeCast for uint256;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being "too deep"
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
        address topUpHandler;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 550_000;

    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";
    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        for (uint256 i; i < protocols.length; i = i.uncheckedInc()) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount`, once converted to units of `actionToken`, must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param protocol Protocol which holds position to be topped up.
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable override returns (bool) {
        require(record.maxFee != 0, Error.INVALID_MAX_FEE);
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.registeredAt = uint64(block.timestamp);
        record.depositTokenBalance = totalLockAmount.toUint128();
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        IAddressProvider addressProvider_ = addressProvider;
        address vault = addressProvider_.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider_.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external override onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee)
        external
        override
        onlyGovernance
        returns (bool)
    {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external override onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external override onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external override onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage)
        external
        override
        onlyGovernance
        returns (bool)
    {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external override returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external override onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i; i < howMany; i = i.uncheckedInc()) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);
        require(block.timestamp > position.registeredAt, Error.CANNOT_EXECUTE_IN_SAME_BLOCK);

        vars.topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(vars.topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IAddressProvider addressProvider_ = addressProvider;
        IGasBank gasBank = addressProvider_.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider_.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider_.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        uint256 value_;
        if (position.actionToken == address(0)) {
            value_ = vars.actionTokenAmount;
        } else {
            _approve(position.actionToken, vars.topUpHandler);
        }
        vars.topupResult = ITopUpHandler(vars.topUpHandler).topUp{value: value_}(
            account,
            position.actionToken,
            vars.actionTokenAmount,
            position.extra
        );

        require(vars.topupResult, Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new "balance" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= vars.totalActionTokenAmount.toUint128();
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= vars.depositAmountWithFees.toUint128();

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the address to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        override
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes calldata extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view override returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the `actionToken`.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        return pool.getUnderlying() == toToken;
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-01-09 12:30:36 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 12:30:36 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 7711
completion_tokens: 792
total_tokens: 8503
cost: $-1.000000


[2024-01-09 12:30:36 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.10;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";
import "@openzeppelin/contracts/utils/math/SafeCast.sol";

import "../../../interfaces/IGasBank.sol";
import "../../../interfaces/pool/ILiquidityPool.sol";
import "../../../interfaces/IController.sol";
import "../../../interfaces/IStakerVault.sol";
import "../../../interfaces/actions/topup/ITopUpHandler.sol";
import "../../../interfaces/actions/topup/ITopUpAction.sol";
import "../../../interfaces/actions/IActionFeeHandler.sol";

import "../../../libraries/AddressProviderHelpers.sol";
import "../../../libraries/Errors.sol";
import "../../../libraries/ScaledMath.sol";
import "../../../libraries/EnumerableExtensions.sol";
import "../../../libraries/UncheckedMath.sol";

import "../../access/Authorization.sol";
import "../../utils/Preparable.sol";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param stakerVaultAddress The address of the staker vault
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > lockAmount ? lockAmount : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            _approve(token, stakerVaultAddress);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            lockAmount -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (lockAmount > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= lockAmount) {
                stakerVault.transferFrom(payer, address(this), lockAmount);
                stakerVault.increaseActionLockedBalance(payer, lockAmount);
                lockAmount = 0;
            }
        }

        require(lockAmount == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        require(underlying == actionToken, Error.TOKEN_NOT_USABLE);
        return amount.scaledDivRoundUp(rate);
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) private {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using UncheckedMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;
    using SafeCast for uint256;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being "too deep"
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
        address topUpHandler;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 550_000;

    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";
    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        for (uint256 i; i < protocols.length; i = i.uncheckedInc()) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount`, once converted to units of `actionToken`, must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param protocol Protocol which holds position to be topped up.
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable override returns (bool) {
        require(record.maxFee != 0, Error.INVALID_MAX_FEE);
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.registeredAt = uint64(block.timestamp);
        record.depositTokenBalance = totalLockAmount.toUint128();
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        IAddressProvider addressProvider_ = addressProvider;
        address vault = addressProvider_.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider_.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external override onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee)
        external
        override
        onlyGovernance
        returns (bool)
    {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external override onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external override onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external override onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage)
        external
        override
        onlyGovernance
        returns (bool)
    {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external override returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external override onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i; i < howMany; i = i.uncheckedInc()) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);
        require(block.timestamp > position.registeredAt, Error.CANNOT_EXECUTE_IN_SAME_BLOCK);

        vars.topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(vars.topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IAddressProvider addressProvider_ = addressProvider;
        IGasBank gasBank = addressProvider_.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider_.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider_.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        uint256 value_;
        if (position.actionToken == address(0)) {
            value_ = vars.actionTokenAmount;
        } else {
            _approve(position.actionToken, vars.topUpHandler);
        }
        vars.topupResult = ITopUpHandler(vars.topUpHandler).topUp{value: value_}(
            account,
            position.actionToken,
            vars.actionTokenAmount,
            position.extra
        );

        require(vars.topupResult, Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new "balance" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= vars.totalActionTokenAmount.toUint128();
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= vars.depositAmountWithFees.toUint128();

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the address to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        override
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes calldata extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view override returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the `actionToken`.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        return pool.getUnderlying() == toToken;
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
.]

Based on the provided smart contract code and the typical vulnerabilities that can arise in Solidity contracts, here is a summary of potential security vulnerabilities identified within the contract:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - The contract allows external calls (e.g., to `ITopUpHandler`) before updating the state variables. This could lead to reentrancy attacks where an attacker could exploit the contract's state before it is updated.

2. **Gas Limit and Loops**:
   - The contract contains loops that could potentially run out of gas if the number of users or positions grows significantly. This could lead to denial of service (DoS) attacks.

3. **Integer Overflow/Underflow**:
   - Although Solidity 0.8.x has built-in overflow/underflow protection, any arithmetic operations that are not carefully handled could still lead to unexpected behavior if the logic is flawed.

4. **Insufficient Input Validation**:
   - The contract relies on several require statements to validate inputs, but there may be cases where additional checks are necessary to ensure that the values are within expected ranges or formats.

5. **Access Control Issues**:
   - The contract uses the `onlyGovernance` modifier for critical functions, but if the governance mechanism is compromised, it could lead to unauthorized access and manipulation of sensitive functions.

6. **Token Approval Issues**:
   - The `_approve` function does not check for the current allowance before setting it to `type(uint256).max`. This could lead to potential issues if the spender is not trusted, as it allows unlimited spending.

7. **Fallback Function Risks**:
   - The fallback function is empty, which could lead to unexpected behavior if Ether is sent to the contract. It is generally advisable to handle incoming Ether appropriately.

8. **Lack of Event Emission**:
   - Certain state-changing functions do not emit events, which can hinder tracking and debugging of contract interactions.

9. **Potential for Front-Running**:
   - The contract does not implement any mechanisms to prevent front-running, which could allow malicious actors to exploit the timing of transactions for profit.

### Comprehensive Analysis Report:

The `TopUpAction` contract demonstrates a complex interaction with various external contracts and libraries, which increases its attack surface. While it employs several best practices, such as using OpenZeppelin's SafeERC20 and EnumerableSet, there are notable vulnerabilities that need to be addressed to enhance security.

1. **Reentrancy Protection**: Implement checks-effects-interactions pattern to prevent reentrancy attacks. Consider using a reentrancy guard modifier.

2. **Gas Optimization**: Review loops and consider implementing pagination or limits on the number of iterations to avoid potential gas limit issues.

3. **Input Validation**: Strengthen input validation to ensure that all parameters passed to functions are within acceptable limits and formats.

4. **Access Control**: Ensure that the governance mechanism is robust and consider implementing multi-signature wallets or time-locks for critical functions.

5. **Token Management**: Reassess the token approval mechanism to ensure that it does not expose the contract to risks associated with unlimited allowances.

6. **Fallback Function**: Implement a fallback function that appropriately handles incoming Ether and provides a mechanism for users to interact with the contract safely.

7. **Event Emission**: Ensure that all state-changing functions emit relevant events to facilitate tracking and debugging.

8. **Front-Running Mitigation**: Consider implementing measures to mitigate front-running risks, such as commit-reveal schemes or transaction ordering mechanisms.

In conclusion, while the `TopUpAction` contract has been designed with several security features, it is essential to address the identified vulnerabilities to safeguard against potential attacks and ensure the integrity of the contract's operations. Regular audits and updates, along with a thorough testing strategy, will be crucial in maintaining the security posture of the contract.

[2024-01-09 12:30:36 INFO] **[Seminar Conclusion]**:

 Based on the provided smart contract code and the typical vulnerabilities that can arise in Solidity contracts, here is a summary of potential security vulnerabilities identified within the contract:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - The contract allows external calls (e.g., to `ITopUpHandler`) before updating the state variables. This could lead to reentrancy attacks where an attacker could exploit the contract's state before it is updated.

2. **Gas Limit and Loops**:
   - The contract contains loops that could potentially run out of gas if the number of users or positions grows significantly. This could lead to denial of service (DoS) attacks.

3. **Integer Overflow/Underflow**:
   - Although Solidity 0.8.x has built-in overflow/underflow protection, any arithmetic operations that are not carefully handled could still lead to unexpected behavior if the logic is flawed.

4. **Insufficient Input Validation**:
   - The contract relies on several require statements to validate inputs, but there may be cases where additional checks are necessary to ensure that the values are within expected ranges or formats.

5. **Access Control Issues**:
   - The contract uses the `onlyGovernance` modifier for critical functions, but if the governance mechanism is compromised, it could lead to unauthorized access and manipulation of sensitive functions.

6. **Token Approval Issues**:
   - The `_approve` function does not check for the current allowance before setting it to `type(uint256).max`. This could lead to potential issues if the spender is not trusted, as it allows unlimited spending.

7. **Fallback Function Risks**:
   - The fallback function is empty, which could lead to unexpected behavior if Ether is sent to the contract. It is generally advisable to handle incoming Ether appropriately.

8. **Lack of Event Emission**:
   - Certain state-changing functions do not emit events, which can hinder tracking and debugging of contract interactions.

9. **Potential for Front-Running**:
   - The contract does not implement any mechanisms to prevent front-running, which could allow malicious actors to exploit the timing of transactions for profit.

### Comprehensive Analysis Report:

The `TopUpAction` contract demonstrates a complex interaction with various external contracts and libraries, which increases its attack surface. While it employs several best practices, such as using OpenZeppelin's SafeERC20 and EnumerableSet, there are notable vulnerabilities that need to be addressed to enhance security.

1. **Reentrancy Protection**: Implement checks-effects-interactions pattern to prevent reentrancy attacks. Consider using a reentrancy guard modifier.

2. **Gas Optimization**: Review loops and consider implementing pagination or limits on the number of iterations to avoid potential gas limit issues.

3. **Input Validation**: Strengthen input validation to ensure that all parameters passed to functions are within acceptable limits and formats.

4. **Access Control**: Ensure that the governance mechanism is robust and consider implementing multi-signature wallets or time-locks for critical functions.

5. **Token Management**: Reassess the token approval mechanism to ensure that it does not expose the contract to risks associated with unlimited allowances.

6. **Fallback Function**: Implement a fallback function that appropriately handles incoming Ether and provides a mechanism for users to interact with the contract safely.

7. **Event Emission**: Ensure that all state-changing functions emit relevant events to facilitate tracking and debugging.

8. **Front-Running Mitigation**: Consider implementing measures to mitigate front-running risks, such as commit-reveal schemes or transaction ordering mechanisms.

In conclusion, while the `TopUpAction` contract has been designed with several security features, it is essential to address the identified vulnerabilities to safeguard against potential attacks and ensure the integrity of the contract's operations. Regular audits and updates, along with a thorough testing strategy, will be crucial in maintaining the security posture of the contract.

[2024-01-09 12:30:36 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 2

[2024-01-09 12:30:36 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.10; import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol"; import "@openzeppelin/contracts/utils/math/SafeCast.sol"; import "../../../interfaces/IGasBank.sol"; import "../../../interfaces/pool/ILiquidityPool.sol"; import "../../../interfaces/IController.sol"; import "../../../interfaces/IStakerVault.sol"; import "../../../interfaces/actions/topup/ITopUpHandler.sol"; import "../../../interfaces/actions/topup/ITopUpAction.sol"; import "../../../interfaces/actions/IActionFeeHandler.sol"; import "../../../libraries/AddressProviderHelpers.sol"; import "../../../libraries/Errors.sol"; import "../../../libraries/ScaledMath.sol"; import "../../../libraries/EnumerableExtensions.sol"; import "../../../libraries/UncheckedMath.sol"; import "../../access/Authorization.sol"; import "../../utils/Preparable.sol"; /*  * @notice The logic here should really be part of the top-up action  * but is split in a library to circumvent the byte-code size limit  / library TopUpActionLibrary {     using SafeERC20 for IERC20;     using ScaledMath for uint256;     using AddressProviderHelpers for IAddressProvider; /**  * @dev "Locks" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param stakerVaultAddress The address of the staker vault  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function lockFunds(     address stakerVaultAddress,     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) external {     IStakerVault stakerVault = IStakerVault(stakerVaultAddress);      // stake deposit amount     if (depositAmount &gt; 0) {         depositAmount = depositAmount &gt; lockAmount ? lockAmount : depositAmount;         IERC20(token).safeTransferFrom(payer, address(this), depositAmount);         _approve(token, stakerVaultAddress);         stakerVault.stake(depositAmount);         stakerVault.increaseActionLockedBalance(payer, depositAmount);         lockAmount -= depositAmount;     }      // use stake vault allowance if available and required     if (lockAmount &gt; 0) {         uint256 balance = stakerVault.balanceOf(payer);         uint256 allowance = stakerVault.allowance(payer, address(this));         uint256 availableFunds = balance &lt; allowance ? balance : allowance;         if (availableFunds &gt;= lockAmount) {             stakerVault.transferFrom(payer, address(this), lockAmount);             stakerVault.increaseActionLockedBalance(payer, lockAmount);             lockAmount = 0;         }     }      require(lockAmount == 0, Error.INSUFFICIENT_UPDATE_BALANCE); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function calcExchangeAmount(     IAddressProvider addressProvider,     address token,     address actionToken,     uint256 amount ) external view returns (uint256) {     ILiquidityPool pool = addressProvider.getPoolForToken(token);     uint256 rate = pool.exchangeRate();     address underlying = pool.getUnderlying();     require(underlying == actionToken, Error.TOKEN_NOT_USABLE);     return amount.scaledDivRoundUp(rate); }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) private {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  } contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {     using ScaledMath for uint256;     using UncheckedMath for uint256;     using ScaledMath for uint128;     using SafeERC20 for IERC20;     using EnumerableSet for EnumerableSet.AddressSet;     using EnumerableSet for EnumerableSet.Bytes32Set;     using EnumerableExtensions for EnumerableSet.AddressSet;     using AddressProviderHelpers for IAddressProvider;     using SafeCast for uint256; /**  * @dev Temporary struct to hold local variables in execute  * and avoid the stack being "too deep"  */ struct ExecuteLocalVars {     uint256 minActionAmountToTopUp;     uint256 actionTokenAmount;     uint256 depositTotalFeesAmount;     uint256 actionAmountWithFees;     uint256 userFactor;     uint256 rate;     uint256 depositAmountWithFees;     uint256 depositAmountWithoutFees;     uint256 actionFee;     uint256 totalActionTokenAmount;     uint128 totalTopUpAmount;     bool topupResult;     uint256 gasBankBalance;     uint256 initialGas;     uint256 gasConsumed;     uint256 userGasPrice;     uint256 estimatedRequiredGas;     uint256 estimatedRequiredWeiForGas;     uint256 requiredWeiForGas;     uint256 reimbursedWeiForGas;     address underlying;     bool removePosition;     address topUpHandler; }  EnumerableSet.AddressSet private _usableTokens;  uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 550_000;  bytes32 internal constant _ACTION_FEE_KEY = "ActionFee"; bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler"; bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler"; bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";  uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;  IController public immutable controller; IAddressProvider public immutable addressProvider;  EnumerableSet.Bytes32Set internal _supportedProtocols;  /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record) mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;  mapping(address =&gt; RecordMeta[]) internal _userPositions;  EnumerableSet.AddressSet internal _usersWithPositions;  constructor(IController _controller)     Authorization(_controller.addressProvider().getRoleManager()) {     controller = _controller;     addressProvider = controller.addressProvider();     _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE); }  receive() external payable {     // solhint-disable-previous-line no-empty-blocks }  function initialize(     address feeHandler,     bytes32[] calldata protocols,     address[] calldata handlers ) external initializer onlyGovernance {     require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);     _setConfig(_FEE_HANDLER_KEY, feeHandler);     for (uint256 i; i &lt; protocols.length; i = i.uncheckedInc()) {         bytes32 protocolKey = _getProtocolKey(protocols[i]);         _setConfig(protocolKey, handlers[i]);         _updateTopUpHandler(protocols[i], address(0), handlers[i]);     } }  /**  * @notice Register a top up action.  * @dev The `depositAmount`, once converted to units of `actionToken`, must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).  * @param account Account to be topped up (first 20 bytes will typically be the address).  * @param protocol Protocol which holds position to be topped up.  * @param depositAmount Amount of `depositToken` that will be locked.  * @param record containing the data for the position to register  */ function register(     bytes32 account,     bytes32 protocol,     uint128 depositAmount,     Record memory record ) external payable override returns (bool) {     require(record.maxFee != 0, Error.INVALID_MAX_FEE);     require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);     require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);     require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);     require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);     require(         _positions[msg.sender][account][protocol].threshold == 0,         Error.POSITION_ALREADY_EXISTS     );     require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);     require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);      uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *         record.maxFee *         getEstimatedGasUsage();      require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);      uint256 totalLockAmount = _calcExchangeAmount(         record.depositToken,         record.actionToken,         record.totalTopUpAmount     );     _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);      addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);      record.registeredAt = uint64(block.timestamp);     record.depositTokenBalance = totalLockAmount.toUint128();     _positions[msg.sender][account][protocol] = record;     _userPositions[msg.sender].push(RecordMeta(account, protocol));     _usersWithPositions.add(msg.sender);      emit Register(         account,         protocol,         record.threshold,         msg.sender,         record.depositToken,         totalLockAmount,         record.actionToken,         record.singleTopUpAmount,         record.totalTopUpAmount,         record.maxFee,         record.extra     );     return true; }  /**  * @notice See overloaded version of `execute` for more details.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol ) external override returns (bool) {     return execute(payer, account, beneficiary, protocol, 0); }  /**  * @notice Delete a position to back on the given protocol for `account`.  * @param account Account holding the position.  * @param protocol Protocol the position is held on.  * @param unstake If the tokens should be unstaked from vault.  * @return `true` if successful.  */ function resetPosition(     bytes32 account,     bytes32 protocol,     bool unstake ) external override returns (bool) {     address payer = msg.sender;     Record memory position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);      IAddressProvider addressProvider_ = addressProvider;     address vault = addressProvider_.getStakerVault(position.depositToken); // will revert if vault does not exist     IStakerVault staker = IStakerVault(vault);     staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);     if (unstake) {         staker.unstake(position.depositTokenBalance);         IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);     } else {         staker.transfer(payer, position.depositTokenBalance);     }      _removePosition(payer, account, protocol);     addressProvider_.getGasBank().withdrawUnused(payer);     return true; }  /**  * @notice Execute top up handler update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @param protocol Protocol for which a new handler should be executed.  * @return Address of new handler.  */ function executeTopUpHandler(bytes32 protocol) external override returns (address) {     address oldHandler = _getHandler(protocol, false);     address newHandler = _executeAddress(_getProtocolKey(protocol));      _updateTopUpHandler(protocol, oldHandler, newHandler);     return newHandler; }  /**  * @notice Reset new top up handler deadline for a protocol.  * @param protocol Protocol for which top up handler deadline should be reset.  * @return `true` if successful.  */ function resetTopUpHandler(bytes32 protocol) external override onlyGovernance returns (bool) {     return _resetAddressConfig(_getProtocolKey(protocol)); }  /**  * @notice Prepare action fee update.  * @param newActionFee New fee to set.  * @return `true` if success.  */ function prepareActionFee(uint256 newActionFee)     external     override     onlyGovernance     returns (bool) {     require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);     return _prepare(_ACTION_FEE_KEY, newActionFee); }  /**  * @notice Execute action fee update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeActionFee() external override returns (uint256) {     return _executeUInt256(_ACTION_FEE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetActionFee() external override onlyGovernance returns (bool) {     return _resetUInt256Config(_ACTION_FEE_KEY); }  /** Set fee handler */ /**  * @notice Prepare update of fee handler.  * @param handler New fee handler.  * @return `true` if success.  */ function prepareFeeHandler(address handler) external override onlyGovernance returns (bool) {     return _prepare(_FEE_HANDLER_KEY, handler); }  /**  * @notice Execute update of fee handler (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeFeeHandler() external override returns (address) {     return _executeAddress(_FEE_HANDLER_KEY); }  /**  * @notice Reset the handler deadline.  * @return `true` if success.  */ function resetFeeHandler() external override onlyGovernance returns (bool) {     return _resetAddressConfig(_FEE_HANDLER_KEY); }  /**  * @notice Prepare update of estimated gas usage.  * @param gasUsage New estimated gas usage.  * @return `true` if success.  */ function prepareEstimatedGasUsage(uint256 gasUsage)     external     override     onlyGovernance     returns (bool) {     return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage); }  /**  * @notice Execute update of gas usage (with time delay enforced).  * @return `true` if successful.  */ function executeEstimatedGasUsage() external override returns (uint256) {     return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Reset the gas usage deadline.  * @return `true` if success.  */ function resetGasUsage() external override onlyGovernance returns (bool) {     return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Add a new deposit token that is supported by the action.  * @dev There is a separate check for whether the usable token (i.e. deposit token)  *      is swappable for some action token.  * @param token Address of deposit token that can be used by the action.  */ function addUsableToken(address token) external override onlyGovernance returns (bool) {     return _usableTokens.add(token); }  /**  * @notice Computes the total amount of ETH (as wei) required to pay for all  * the top-ups assuming the maximum gas price and the current estimated gas  * usage of a top-up  */ function getEthRequiredForGas(address payer) external view override returns (uint256) {     uint256 totalEthRequired;     RecordMeta[] memory userRecordsMeta = _userPositions[payer];     uint256 gasUsagePerCall = getEstimatedGasUsage();     uint256 length = userRecordsMeta.length;     for (uint256 i; i &lt; length; i = i.uncheckedInc()) {         RecordMeta memory meta = userRecordsMeta[i];         Record memory record = _positions[payer][meta.account][meta.protocol];         uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);         totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;     }     return totalEthRequired; }  /**  * @notice Returns a list of positions for the given payer  */ function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {     return _userPositions[payer]; }  /**  * @notice Get a list supported protocols.  * @return List of supported protocols.  */ function getSupportedProtocols() external view override returns (bytes32[] memory) {     uint256 length = _supportedProtocols.length();     bytes32[] memory protocols = new bytes32[](length);     for (uint256 i; i &lt; length; i = i.uncheckedInc()) {         protocols[i] = _supportedProtocols.at(i);     }     return protocols; }  /*  * @notice Gets a list of users that have an active position.  * @dev Uses cursor pagination.  * @param cursor The cursor for pagination (should start at 0 for first call).  * @param howMany Maximum number of users to return in this pagination request.  * @return users List of users that have an active position.  * @return nextCursor The cursor to use for the next pagination request.  */ function usersWithPositions(uint256 cursor, uint256 howMany)     external     view     override     returns (address[] memory users, uint256 nextCursor) {     uint256 length = _usersWithPositions.length();     if (cursor &gt;= length) return (new address[](0), 0);     if (howMany &gt;= length - cursor) {         howMany = length - cursor;     }      address[] memory usersWithPositions_ = new address[](howMany);     for (uint256 i; i &lt; howMany; i = i.uncheckedInc()) {         usersWithPositions_[i] = _usersWithPositions.at(i + cursor);     }      return (usersWithPositions_, cursor + howMany); }  /**  * @notice Get a list of all tokens usable for this action.  * @dev This refers to all tokens that can be used as deposit tokens.  * @return Array of addresses of usable tokens.  */ function getUsableTokens() external view override returns (address[] memory) {     return _usableTokens.toArray(); }  /**  * @notice Retrieves the topup handler for the given `protocol`  */ function getTopUpHandler(bytes32 protocol) external view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice Successfully tops up a position if it's conditions are met.  * @dev pool and vault funds are rebalanced after withdrawal for top up  * @param payer Account that pays for the top up.  * @param account Account owning the position for top up.  * @param beneficiary Address of the keeper's wallet for fee accrual.  * @param protocol Protocol of the top up position.  * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas  * @return `true` if successful.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol,     uint256 maxWeiForGas ) public override returns (bool) {     require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);      ExecuteLocalVars memory vars;      vars.initialGas = gasleft();      Record storage position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);     require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);     require(block.timestamp &gt; position.registeredAt, Error.CANNOT_EXECUTE_IN_SAME_BLOCK);      vars.topUpHandler = _getHandler(protocol, true);     vars.userFactor = ITopUpHandler(vars.topUpHandler).getUserFactor(account, position.extra);      // ensure that the position is actually below its set user factor threshold     require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);      IAddressProvider addressProvider_ = addressProvider;     IGasBank gasBank = addressProvider_.getGasBank();      // fail early if the user does not have enough funds in the gas bank     // to cover the cost of the transaction     vars.estimatedRequiredGas = getEstimatedGasUsage();     vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;      // compute the gas price that the user will be paying     vars.userGasPrice = block.basefee + position.priorityFee;     if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;     if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;      // ensure the current position allows for the gas to be paid     require(         vars.estimatedRequiredWeiForGas &lt;=             vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,         Error.ESTIMATED_GAS_TOO_HIGH     );      vars.gasBankBalance = gasBank.balanceOf(payer);     // ensure the user has enough funds in the gas bank to cover the gas     require(         vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,         Error.GAS_BANK_BALANCE_TOO_LOW     );      vars.totalTopUpAmount = position.totalTopUpAmount;     vars.actionFee = getActionFee();     // add top-up fees to top-up amount     vars.minActionAmountToTopUp = position.singleTopUpAmount;     vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(         ScaledMath.ONE + vars.actionFee     );      // if the amount that we want to top-up (including fees) is higher than     // the available topup amount, we lower this down to what is left of the position     if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {         vars.actionAmountWithFees = vars.totalTopUpAmount;         vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(             ScaledMath.ONE + vars.actionFee         );     }     ILiquidityPool pool = addressProvider_.getPoolForToken(position.depositToken);     vars.underlying = pool.getUnderlying();     vars.rate = pool.exchangeRate();      // compute the deposit tokens amount with and without fees     // we will need to unstake the amount with fees and to     // swap the amount without fees into action tokens     vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);     if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {         vars.depositAmountWithFees = position.depositTokenBalance;         vars.minActionAmountToTopUp =             (vars.depositAmountWithFees * vars.rate) /             (ScaledMath.ONE + vars.actionFee);     }      // compute amount of LP tokens needed to pay for action     // rate is expressed in actionToken per depositToken     vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);     vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;      // will revert if vault does not exist     address vault = addressProvider_.getStakerVault(position.depositToken);      // unstake deposit tokens including fees     IStakerVault(vault).unstake(vars.depositAmountWithFees);     IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);      // swap the amount without the fees     // as the fees are paid in deposit token, not in action token     vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);      // compute how much of action token was actually redeemed and add fees to it     // this is to ensure that no funds get locked inside the contract     vars.totalActionTokenAmount =         vars.actionTokenAmount +         vars.depositTotalFeesAmount.scaledMul(vars.rate);      // at this point, we have exactly `vars.actionTokenAmount`     // (at least `position.singleTopUpAmount`) of action token     // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract     // solhint-disable-next-line avoid-low-level-calls     uint256 value_;     if (position.actionToken == address(0)) {         value_ = vars.actionTokenAmount;     } else {         _approve(position.actionToken, vars.topUpHandler);     }     vars.topupResult = ITopUpHandler(vars.topUpHandler).topUp{value: value_}(         account,         position.actionToken,         vars.actionTokenAmount,         position.extra     );      require(vars.topupResult, Error.TOP_UP_FAILED);      // totalTopUpAmount is updated to reflect the new "balance" of the position     if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {         position.totalTopUpAmount -= vars.totalActionTokenAmount.toUint128();     } else {         position.totalTopUpAmount = 0;     }      position.depositTokenBalance -= vars.depositAmountWithFees.toUint128();      vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;     _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);     if (vars.removePosition) {         if (position.depositTokenBalance &gt; 0) {             // transfer any unused locked tokens to the payer             IStakerVault(vault).transfer(payer, position.depositTokenBalance);             IStakerVault(vault).decreaseActionLockedBalance(                 payer,                 position.depositTokenBalance             );         }         _removePosition(payer, account, protocol);     }      emit TopUp(         account,         protocol,         payer,         position.depositToken,         vars.depositAmountWithFees,         position.actionToken,         vars.actionTokenAmount     );      // compute gas used and reimburse the keeper by using the     // funds of payer in the gas bank     // TODO: add constant gas consumed for transfer and tx prologue     vars.gasConsumed = vars.initialGas - gasleft();      vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;     if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {         vars.reimbursedWeiForGas = vars.gasBankBalance;     }      // ensure that the keeper is not overpaying     vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;     require(         vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,         Error.GAS_TOO_HIGH     );     gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);     if (vars.removePosition) {         gasBank.withdrawUnused(payer);     }      return true; }  /**  * @notice Prepare new top up handler fee update.  * @dev Setting the address to 0 means that the protocol will no longer be supported.  * @param protocol Protocol for which a new handler should be prepared.  * @param newHandler Address of new handler.  * @return `true` if success.  */ function prepareTopUpHandler(bytes32 protocol, address newHandler)     public     override     onlyGovernance     returns (bool) {     return _prepare(_getProtocolKey(protocol), newHandler); }  /**  * @notice Check if action can be executed.  * @param protocol for which to get the health factor  * @param account for which to get the health factor  * @param extra data to be used by the topup handler  * @return healthFactor of the position  */ function getHealthFactor(     bytes32 protocol,     bytes32 account,     bytes calldata extra ) public view override returns (uint256 healthFactor) {     ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));     return topUpHandler.getUserFactor(account, extra); }  function getHandler(bytes32 protocol) public view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice returns the current estimated gas usage  */ function getEstimatedGasUsage() public view override returns (uint256) {     return currentUInts256[_ESTIMATED_GAS_USAGE_KEY]; }  /**  * @notice Returns the current action fee  */ function getActionFee() public view override returns (uint256) {     return currentUInts256[_ACTION_FEE_KEY]; }  /**  * @notice Returns the current fee handler  */ function getFeeHandler() public view override returns (address) {     return currentAddresses[_FEE_HANDLER_KEY]; }  /**  * @notice Get the record for a position.  * @param payer Registered payer of the position.  * @param account Address holding the position.  * @param protocol Protocol where the position is held.  */ function getPosition(     address payer,     bytes32 account,     bytes32 protocol ) public view override returns (Record memory) {     return _positions[payer][account][protocol]; }  /**  * @notice Check whether a token is usable as a deposit token.  * @param token Address of token to check.  * @return True if token is usable as a deposit token for this action.  */ function isUsable(address token) public view override returns (bool) {     return _usableTokens.contains(token); }  function _updateTopUpHandler(     bytes32 protocol,     address oldHandler,     address newHandler ) internal {     if (newHandler == address(0)) {         _supportedProtocols.remove(protocol);     } else if (oldHandler == address(0)) {         _supportedProtocols.add(protocol);     } }  /**  * @dev Pays fees to the feeHandler  * @param payer The account who's position the fees are charged on  * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)  * @param feeAmount The amount in tokens to pay as fees  * @param depositToken The LpToken used to pay the fees  */ function _payFees(     address payer,     address beneficiary,     uint256 feeAmount,     address depositToken ) internal {     address feeHandler = getFeeHandler();     IERC20(depositToken).safeApprove(feeHandler, feeAmount);     IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken); }  /**  * @dev "Locks" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function _lockFunds(     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) internal {     address stakerVaultAddress = addressProvider.getStakerVault(token);     TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount); }  function _removePosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     delete _positions[payer][account][protocol];     _removeUserPosition(payer, account, protocol);     if (_userPositions[payer].length == 0) {         _usersWithPositions.remove(payer);     }     emit Deregister(payer, account, protocol); }  function _removeUserPosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     RecordMeta[] storage positionsMeta = _userPositions[payer];     uint256 length = positionsMeta.length;     for (uint256 i; i &lt; length; i = i.uncheckedInc()) {         RecordMeta storage positionMeta = positionsMeta[i];         if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {             positionsMeta[i] = positionsMeta[length - 1];             positionsMeta.pop();             return;         }     } }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) internal {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the `actionToken`.  */ function _calcExchangeAmount(     address token,     address actionToken,     uint256 amount ) internal view returns (uint256) {     return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount); }  function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {     address handler = currentAddresses[_getProtocolKey(protocol)];     require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);     return handler; }  function _isSwappable(address depositToken, address toToken) internal view returns (bool) {     ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);     return pool.getUnderlying() == toToken; }  function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {     return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol)); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";\nimport "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\nimport "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";\nimport "@openzeppelin/contracts/utils/math/SafeCast.sol";\n\nimport "../../../interfaces/IGasBank.sol";\nimport "../../../interfaces/pool/ILiquidityPool.sol";\nimport "../../../interfaces/IController.sol";\nimport "../../../interfaces/IStakerVault.sol";\nimport "../../../interfaces/actions/topup/ITopUpHandler.sol";\nimport "../../../interfaces/actions/topup/ITopUpAction.sol";\nimport "../../../interfaces/actions/IActionFeeHandler.sol";\n\nimport "../../../libraries/AddressProviderHelpers.sol";\nimport "../../../libraries/Errors.sol";\nimport "../../../libraries/ScaledMath.sol";\nimport "../../../libraries/EnumerableExtensions.sol";\nimport "../../../libraries/UncheckedMath.sol";\n\nimport "../../access/Authorization.sol";\nimport "../../utils/Preparable.sol";\n\n/\n * @notice The logic here should really be part of the top-up action\n * but is split in a library to circumvent the byte-code size limit\n */\nlibrary TopUpActionLibrary {\n    using SafeERC20 for IERC20;\n    using ScaledMath for uint256;\n    using AddressProviderHelpers for IAddressProvider;\n\n    /\n     * @dev "Locks" an amount of tokens on behalf of the TopUpAction\n     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.\n     * @param stakerVaultAddress The address of the staker vault\n     * @param payer Owner of the funds to be locked\n     * @param token Token to lock\n     * @param lockAmount Minimum amount of token to lock\n     * @param depositAmount Amount of token that was deposited.\n     *                      If this is 0 then the staker vault allowance should be used.\n     *                      If this is greater than requiredAmount more tokens will be locked.\n     /\n    function lockFunds(\n        address stakerVaultAddress,\n        address payer,\n        address token,\n        uint256 lockAmount,\n        uint256 depositAmount\n    ) external {\n        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);\n\n        // stake deposit amount\n        if (depositAmount &gt; 0) {\n            depositAmount = depositAmount &gt; lockAmount ? lockAmount : depositAmount;\n            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);\n            _approve(token, stakerVaultAddress);\n            stakerVault.stake(depositAmount);\n            stakerVault.increaseActionLockedBalance(payer, depositAmount);\n            lockAmount -= depositAmount;\n        }\n\n        // use stake vault allowance if available and required\n        if (lockAmount &gt; 0) {\n            uint256 balance = stakerVault.balanceOf(payer);\n            uint256 allowance = stakerVault.allowance(payer, address(this));\n            uint256 availableFunds = balance &lt; allowance ? balance : allowance;\n            if (availableFunds &gt;= lockAmount) {\n                stakerVault.transferFrom(payer, address(this), lockAmount);\n                stakerVault.increaseActionLockedBalance(payer, lockAmount);\n                lockAmount = 0;\n            }\n        }\n\n        require(lockAmount == 0, Error.INSUFFICIENT_UPDATE_BALANCE);\n    }\n\n    /\n     * @dev Computes and returns the amount of LP tokens of type token that will be received in exchange for an amount of the underlying.\n     /\n    function calcExchangeAmount(\n        IAddressProvider addressProvider,\n        address token,\n        address actionToken,\n        uint256 amount\n    ) external view returns (uint256) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(token);\n        uint256 rate = pool.exchangeRate();\n        address underlying = pool.getUnderlying();\n        require(underlying == actionToken, Error.TOKEN_NOT_USABLE);\n        return amount.scaledDivRoundUp(rate);\n    }\n\n    /\n     * @dev Approves infinite spending for the given spender.\n     * @param token The token to approve for.\n     * @param spender The spender to approve.\n     */\n    function _approve(address token, address spender) private {\n        if (IERC20(token).allowance(address(this), spender) &gt; 0) return;\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n}\n\ncontract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {\n    using ScaledMath for uint256;\n    using UncheckedMath for uint256;\n    using ScaledMath for uint128;\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using EnumerableExtensions for EnumerableSet.AddressSet;\n    using AddressProviderHelpers for IAddressProvider;\n    using SafeCast for uint256;\n\n    /\n     * @dev Temporary struct to hold local variables in execute\n     * and avoid the stack being "too deep"\n     /\n    struct ExecuteLocalVars {\n        uint256 minActionAmountToTopUp;\n        uint256 actionTokenAmount;\n        uint256 depositTotalFeesAmount;\n        uint256 actionAmountWithFees;\n        uint256 userFactor;\n        uint256 rate;\n        uint256 depositAmountWithFees;\n        uint256 depositAmountWithoutFees;\n        uint256 actionFee;\n        uint256 totalActionTokenAmount;\n        uint128 totalTopUpAmount;\n        bool topupResult;\n        uint256 gasBankBalance;\n        uint256 initialGas;\n        uint256 gasConsumed;\n        uint256 userGasPrice;\n        uint256 estimatedRequiredGas;\n        uint256 estimatedRequiredWeiForGas;\n        uint256 requiredWeiForGas;\n        uint256 reimbursedWeiForGas;\n        address underlying;\n        bool removePosition;\n        address topUpHandler;\n    }\n\n    EnumerableSet.AddressSet private _usableTokens;\n\n    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 550_000;\n\n    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";\n    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";\n    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";\n    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";\n\n    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;\n\n    IController public immutable controller;\n    IAddressProvider public immutable addressProvider;\n\n    EnumerableSet.Bytes32Set internal _supportedProtocols;\n\n    /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record)\n    mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;\n\n    mapping(address =&gt; RecordMeta[]) internal _userPositions;\n\n    EnumerableSet.AddressSet internal _usersWithPositions;\n\n    constructor(IController _controller)\n        Authorization(_controller.addressProvider().getRoleManager())\n    {\n        controller = _controller;\n        addressProvider = controller.addressProvider();\n        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);\n    }\n\n    receive() external payable {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    function initialize(\n        address feeHandler,\n        bytes32[] calldata protocols,\n        address[] calldata handlers\n    ) external initializer onlyGovernance {\n        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);\n        _setConfig(_FEE_HANDLER_KEY, feeHandler);\n        for (uint256 i; i &lt; protocols.length; i = i.uncheckedInc()) {\n            bytes32 protocolKey = _getProtocolKey(protocols[i]);\n            _setConfig(protocolKey, handlers[i]);\n            _updateTopUpHandler(protocols[i], address(0), handlers[i]);\n        }\n    }\n\n    /\n     * @notice Register a top up action.\n     * @dev The depositAmount, once converted to units of actionToken, must be greater or equal to the totalTopUpAmount (which is denominated in actionToken).\n     * @param account Account to be topped up (first 20 bytes will typically be the address).\n     * @param protocol Protocol which holds position to be topped up.\n     * @param depositAmount Amount of depositToken that will be locked.\n     * @param record containing the data for the position to register\n     /\n    function register(\n        bytes32 account,\n        bytes32 protocol,\n        uint128 depositAmount,\n        Record memory record\n    ) external payable override returns (bool) {\n        require(record.maxFee != 0, Error.INVALID_MAX_FEE);\n        require(supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);\n        require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);\n        require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);\n        require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);\n        require(\n            _positions[msg.sender][account][protocol].threshold == 0,\n            Error.POSITION_ALREADY_EXISTS\n        );\n        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);\n        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);\n\n        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) \n            record.maxFee \n            getEstimatedGasUsage();\n\n        require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);\n\n        uint256 totalLockAmount = _calcExchangeAmount(\n            record.depositToken,\n            record.actionToken,\n            record.totalTopUpAmount\n        );\n        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);\n\n        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);\n\n        record.registeredAt = uint64(block.timestamp);\n        record.depositTokenBalance = totalLockAmount.toUint128();\n        _positions[msg.sender][account][protocol] = record;\n        _userPositions[msg.sender].push(RecordMeta(account, protocol));\n        _usersWithPositions.add(msg.sender);\n\n        emit Register(\n            account,\n            protocol,\n            record.threshold,\n            msg.sender,\n            record.depositToken,\n            totalLockAmount,\n            record.actionToken,\n            record.singleTopUpAmount,\n            record.totalTopUpAmount,\n            record.maxFee,\n            record.extra\n        );\n        return true;\n    }\n\n    /\n     * @notice See overloaded version of execute for more details.\n     */\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol\n    ) external override returns (bool) {\n        return execute(payer, account, beneficiary, protocol, 0);\n    }\n\n    /\n     * @notice Delete a position to back on the given protocol for account.\n     * @param account Account holding the position.\n     * @param protocol Protocol the position is held on.\n     * @param unstake If the tokens should be unstaked from vault.\n     * @return true if successful.\n     /\n    function resetPosition(\n        bytes32 account,\n        bytes32 protocol,\n        bool unstake\n    ) external override returns (bool) {\n        address payer = msg.sender;\n        Record memory position = positions[payer][account][protocol];\n        require(position.threshold != 0, Error.NO_POSITION_EXISTS);\n\n        IAddressProvider addressProvider = addressProvider;\n        address vault = addressProvider_.getStakerVault(position.depositToken); // will revert if vault does not exist\n        IStakerVault staker = IStakerVault(vault);\n        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);\n        if (unstake) {\n            staker.unstake(position.depositTokenBalance);\n            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);\n        } else {\n            staker.transfer(payer, position.depositTokenBalance);\n        }\n\n        removePosition(payer, account, protocol);\n        addressProvider.getGasBank().withdrawUnused(payer);\n        return true;\n    }\n\n    /\n     * @notice Execute top up handler update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @param protocol Protocol for which a new handler should be executed.\n     * @return Address of new handler.\n     /\n    function executeTopUpHandler(bytes32 protocol) external override returns (address) {\n        address oldHandler = _getHandler(protocol, false);\n        address newHandler = _executeAddress(_getProtocolKey(protocol));\n\n        _updateTopUpHandler(protocol, oldHandler, newHandler);\n        return newHandler;\n    }\n\n    /\n     * @notice Reset new top up handler deadline for a protocol.\n     * @param protocol Protocol for which top up handler deadline should be reset.\n     * @return true if successful.\n     */\n    function resetTopUpHandler(bytes32 protocol) external override onlyGovernance returns (bool) {\n        return _resetAddressConfig(_getProtocolKey(protocol));\n    }\n\n    /\n     * @notice Prepare action fee update.\n     * @param newActionFee New fee to set.\n     * @return true if success.\n     /\n    function prepareActionFee(uint256 newActionFee)\n        external\n        override\n        onlyGovernance\n        returns (bool)\n    {\n        require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);\n        return _prepare(_ACTION_FEE_KEY, newActionFee);\n    }\n\n    /\n     * @notice Execute action fee update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return true if successful.\n     /\n    function executeActionFee() external override returns (uint256) {\n        return _executeUInt256(_ACTION_FEE_KEY);\n    }\n\n    /\n     * @notice Reset action fee deadline.\n     * @return true if successful.\n     */\n    function resetActionFee() external override onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ACTION_FEE_KEY);\n    }\n\n    / Set fee handler /\n    /\n     * @notice Prepare update of fee handler.\n     * @param handler New fee handler.\n     * @return true if success.\n     /\n    function prepareFeeHandler(address handler) external override onlyGovernance returns (bool) {\n        return _prepare(_FEE_HANDLER_KEY, handler);\n    }\n\n    /\n     * @notice Execute update of fee handler (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return true if successful.\n     */\n    function executeFeeHandler() external override returns (address) {\n        return _executeAddress(_FEE_HANDLER_KEY);\n    }\n\n    /\n     * @notice Reset the handler deadline.\n     * @return true if success.\n     /\n    function resetFeeHandler() external override onlyGovernance returns (bool) {\n        return _resetAddressConfig(_FEE_HANDLER_KEY);\n    }\n\n    /\n     * @notice Prepare update of estimated gas usage.\n     * @param gasUsage New estimated gas usage.\n     * @return true if success.\n     /\n    function prepareEstimatedGasUsage(uint256 gasUsage)\n        external\n        override\n        onlyGovernance\n        returns (bool)\n    {\n        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);\n    }\n\n    /\n     * @notice Execute update of gas usage (with time delay enforced).\n     * @return true if successful.\n     */\n    function executeEstimatedGasUsage() external override returns (uint256) {\n        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);\n    }\n\n    /\n     * @notice Reset the gas usage deadline.\n     * @return true if success.\n     /\n    function resetGasUsage() external override onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);\n    }\n\n    /\n     * @notice Add a new deposit token that is supported by the action.\n     * @dev There is a separate check for whether the usable token (i.e. deposit token)\n     *      is swappable for some action token.\n     * @param token Address of deposit token that can be used by the action.\n     /\n    function addUsableToken(address token) external override onlyGovernance returns (bool) {\n        return _usableTokens.add(token);\n    }\n\n    /\n     * @notice Computes the total amount of ETH (as wei) required to pay for all\n     * the top-ups assuming the maximum gas price and the current estimated gas\n     * usage of a top-up\n     */\n    function getEthRequiredForGas(address payer) external view override returns (uint256) {\n        uint256 totalEthRequired;\n        RecordMeta[] memory userRecordsMeta = _userPositions[payer];\n        uint256 gasUsagePerCall = getEstimatedGasUsage();\n        uint256 length = userRecordsMeta.length;\n        for (uint256 i; i &lt; length; i = i.uncheckedInc()) {\n            RecordMeta memory meta = userRecordsMeta[i];\n            Record memory record = _positions[payer][meta.account][meta.protocol];\n            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);\n            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;\n        }\n        return totalEthRequired;\n    }\n\n    /\n     * @notice Returns a list of positions for the given payer\n     /\n    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {\n        return _userPositions[payer];\n    }\n\n    /\n     * @notice Get a list supported protocols.\n     * @return List of supported protocols.\n     /\n    function getSupportedProtocols() external view override returns (bytes32[] memory) {\n        uint256 length = _supportedProtocols.length();\n        bytes32[] memory protocols = new bytes32;\n        for (uint256 i; i &lt; length; i = i.uncheckedInc()) {\n            protocols[i] = _supportedProtocols.at(i);\n        }\n        return protocols;\n    }\n\n    /\n     * @notice Gets a list of users that have an active position.\n     * @dev Uses cursor pagination.\n     * @param cursor The cursor for pagination (should start at 0 for first call).\n     * @param howMany Maximum number of users to return in this pagination request.\n     * @return users List of users that have an active position.\n     * @return nextCursor The cursor to use for the next pagination request.\n     /\n    function usersWithPositions(uint256 cursor, uint256 howMany)\n        external\n        view\n        override\n        returns (address[] memory users, uint256 nextCursor)\n    {\n        uint256 length = _usersWithPositions.length();\n        if (cursor &gt;= length) return (new address, 0);\n        if (howMany &gt;= length - cursor) {\n            howMany = length - cursor;\n        }\n\n        address[] memory usersWithPositions = new address;\n        for (uint256 i; i &lt; howMany; i = i.uncheckedInc()) {\n            usersWithPositions_[i] = usersWithPositions.at(i + cursor);\n        }\n\n        return (usersWithPositions, cursor + howMany);\n    }\n\n    /\n     * @notice Get a list of all tokens usable for this action.\n     * @dev This refers to all tokens that can be used as deposit tokens.\n     * @return Array of addresses of usable tokens.\n     */\n    function getUsableTokens() external view override returns (address[] memory) {\n        return _usableTokens.toArray();\n    }\n\n    /\n     * @notice Retrieves the topup handler for the given protocol\n     /\n    function getTopUpHandler(bytes32 protocol) external view override returns (address) {\n        return _getHandler(protocol, false);\n    }\n\n    /\n     * @notice Successfully tops up a position if it\'s conditions are met.\n     * @dev pool and vault funds are rebalanced after withdrawal for top up\n     * @param payer Account that pays for the top up.\n     * @param account Account owning the position for top up.\n     * @param beneficiary Address of the keeper\'s wallet for fee accrual.\n     * @param protocol Protocol of the top up position.\n     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas\n     * @return true if successful.\n     /\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol,\n        uint256 maxWeiForGas\n    ) public override returns (bool) {\n        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);\n\n        ExecuteLocalVars memory vars;\n\n        vars.initialGas = gasleft();\n\n        Record storage position = positions[payer][account][protocol];\n        require(position.threshold != 0, Error.NO_POSITION_EXISTS);\n        require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);\n        require(block.timestamp &gt; position.registeredAt, Error.CANNOT_EXECUTE_IN_SAME_BLOCK);\n\n        vars.topUpHandler = _getHandler(protocol, true);\n        vars.userFactor = ITopUpHandler(vars.topUpHandler).getUserFactor(account, position.extra);\n\n        // ensure that the position is actually below its set user factor threshold\n        require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);\n\n        IAddressProvider addressProvider = addressProvider;\n        IGasBank gasBank = addressProvider_.getGasBank();\n\n        // fail early if the user does not have enough funds in the gas bank\n        // to cover the cost of the transaction\n        vars.estimatedRequiredGas = getEstimatedGasUsage();\n        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;\n\n        // compute the gas price that the user will be paying\n        vars.userGasPrice = block.basefee + position.priorityFee;\n        if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;\n        if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;\n\n        // ensure the current position allows for the gas to be paid\n        require(\n            vars.estimatedRequiredWeiForGas &lt;=\n                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,\n            Error.ESTIMATED_GAS_TOO_HIGH\n        );\n\n        vars.gasBankBalance = gasBank.balanceOf(payer);\n        // ensure the user has enough funds in the gas bank to cover the gas\n        require(\n            vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,\n            Error.GAS_BANK_BALANCE_TOO_LOW\n        );\n\n        vars.totalTopUpAmount = position.totalTopUpAmount;\n        vars.actionFee = getActionFee();\n        // add top-up fees to top-up amount\n        vars.minActionAmountToTopUp = position.singleTopUpAmount;\n        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(\n            ScaledMath.ONE + vars.actionFee\n        );\n\n        // if the amount that we want to top-up (including fees) is higher than\n        // the available topup amount, we lower this down to what is left of the position\n        if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {\n            vars.actionAmountWithFees = vars.totalTopUpAmount;\n            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(\n                ScaledMath.ONE + vars.actionFee\n            );\n        }\n        ILiquidityPool pool = addressProvider_.getPoolForToken(position.depositToken);\n        vars.underlying = pool.getUnderlying();\n        vars.rate = pool.exchangeRate();\n\n        // compute the deposit tokens amount with and without fees\n        // we will need to unstake the amount with fees and to\n        // swap the amount without fees into action tokens\n        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);\n        if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {\n            vars.depositAmountWithFees = position.depositTokenBalance;\n            vars.minActionAmountToTopUp =\n                (vars.depositAmountWithFees * vars.rate) /\n                (ScaledMath.ONE + vars.actionFee);\n        }\n\n        // compute amount of LP tokens needed to pay for action\n        // rate is expressed in actionToken per depositToken\n        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);\n        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;\n\n        // will revert if vault does not exist\n        address vault = addressProvider_.getStakerVault(position.depositToken);\n\n        // unstake deposit tokens including fees\n        IStakerVault(vault).unstake(vars.depositAmountWithFees);\n        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);\n\n        // swap the amount without the fees\n        // as the fees are paid in deposit token, not in action token\n        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);\n\n        // compute how much of action token was actually redeemed and add fees to it\n        // this is to ensure that no funds get locked inside the contract\n        vars.totalActionTokenAmount =\n            vars.actionTokenAmount +\n            vars.depositTotalFeesAmount.scaledMul(vars.rate);\n\n        // at this point, we have exactly vars.actionTokenAmount\n        // (at least position.singleTopUpAmount) of action token\n        // and exactly vars.depositTotalFeesAmount deposit tokens in the contract\n        // solhint-disable-next-line avoid-low-level-calls\n        uint256 value_;\n        if (position.actionToken == address(0)) {\n            value_ = vars.actionTokenAmount;\n        } else {\n            approve(position.actionToken, vars.topUpHandler);\n        }\n        vars.topupResult = ITopUpHandler(vars.topUpHandler).topUp{value: value}(\n            account,\n            position.actionToken,\n            vars.actionTokenAmount,\n            position.extra\n        );\n\n        require(vars.topupResult, Error.TOP_UP_FAILED);\n\n        // totalTopUpAmount is updated to reflect the new "balance" of the position\n        if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {\n            position.totalTopUpAmount -= vars.totalActionTokenAmount.toUint128();\n        } else {\n            position.totalTopUpAmount = 0;\n        }\n\n        position.depositTokenBalance -= vars.depositAmountWithFees.toUint128();\n\n        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;\n        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);\n        if (vars.removePosition) {\n            if (position.depositTokenBalance &gt; 0) {\n                // transfer any unused locked tokens to the payer\n                IStakerVault(vault).transfer(payer, position.depositTokenBalance);\n                IStakerVault(vault).decreaseActionLockedBalance(\n                    payer,\n                    position.depositTokenBalance\n                );\n            }\n            _removePosition(payer, account, protocol);\n        }\n\n        emit TopUp(\n            account,\n            protocol,\n            payer,\n            position.depositToken,\n            vars.depositAmountWithFees,\n            position.actionToken,\n            vars.actionTokenAmount\n        );\n\n        // compute gas used and reimburse the keeper by using the\n        // funds of payer in the gas bank\n        // TODO: add constant gas consumed for transfer and tx prologue\n        vars.gasConsumed = vars.initialGas - gasleft();\n\n        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;\n        if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {\n            vars.reimbursedWeiForGas = vars.gasBankBalance;\n        }\n\n        // ensure that the keeper is not overpaying\n        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;\n        require(\n            vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,\n            Error.GAS_TOO_HIGH\n        );\n        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);\n        if (vars.removePosition) {\n            gasBank.withdrawUnused(payer);\n        }\n\n        return true;\n    }\n\n    /\n     * @notice Prepare new top up handler fee update.\n     * @dev Setting the address to 0 means that the protocol will no longer be supported.\n     * @param protocol Protocol for which a new handler should be prepared.\n     * @param newHandler Address of new handler.\n     * @return true if success.\n     */\n    function prepareTopUpHandler(bytes32 protocol, address newHandler)\n        public\n        override\n        onlyGovernance\n        returns (bool)\n    {\n        return _prepare(_getProtocolKey(protocol), newHandler);\n    }\n\n    /\n     * @notice Check if action can be executed.\n     * @param protocol for which to get the health factor\n     * @param account for which to get the health factor\n     * @param extra data to be used by the topup handler\n     * @return healthFactor of the position\n     /\n    function getHealthFactor(\n        bytes32 protocol,\n        bytes32 account,\n        bytes calldata extra\n    ) public view override returns (uint256 healthFactor) {\n        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));\n        return topUpHandler.getUserFactor(account, extra);\n    }\n\n    function getHandler(bytes32 protocol) public view override returns (address) {\n        return _getHandler(protocol, false);\n    }\n\n    /\n     * @notice returns the current estimated gas usage\n     /\n    function getEstimatedGasUsage() public view override returns (uint256) {\n        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];\n    }\n\n    /\n     * @notice Returns the current action fee\n     */\n    function getActionFee() public view override returns (uint256) {\n        return currentUInts256[_ACTION_FEE_KEY];\n    }\n\n    /\n     * @notice Returns the current fee handler\n     /\n    function getFeeHandler() public view override returns (address) {\n        return currentAddresses[_FEE_HANDLER_KEY];\n    }\n\n    /\n     * @notice Get the record for a position.\n     * @param payer Registered payer of the position.\n     * @param account Address holding the position.\n     * @param protocol Protocol where the position is held.\n     /\n    function getPosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) public view override returns (Record memory) {\n        return _positions[payer][account][protocol];\n    }\n\n    /\n     * @notice Check whether a token is usable as a deposit token.\n     * @param token Address of token to check.\n     * @return True if token is usable as a deposit token for this action.\n     */\n    function isUsable(address token) public view override returns (bool) {\n        return _usableTokens.contains(token);\n    }\n\n    function _updateTopUpHandler(\n        bytes32 protocol,\n        address oldHandler,\n        address newHandler\n    ) internal {\n        if (newHandler == address(0)) {\n            _supportedProtocols.remove(protocol);\n        } else if (oldHandler == address(0)) {\n            _supportedProtocols.add(protocol);\n        }\n    }\n\n    /\n     * @dev Pays fees to the feeHandler\n     * @param payer The account who\'s position the fees are charged on\n     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)\n     * @param feeAmount The amount in tokens to pay as fees\n     * @param depositToken The LpToken used to pay the fees\n     /\n    function _payFees(\n        address payer,\n        address beneficiary,\n        uint256 feeAmount,\n        address depositToken\n    ) internal {\n        address feeHandler = getFeeHandler();\n        IERC20(depositToken).safeApprove(feeHandler, feeAmount);\n        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);\n    }\n\n    /\n     * @dev "Locks" an amount of tokens on behalf of the TopUpAction\n     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.\n     * @param payer Owner of the funds to be locked\n     * @param token Token to lock\n     * @param lockAmount Minimum amount of token to lock\n     * @param depositAmount Amount of token that was deposited.\n     *                      If this is 0 then the staker vault allowance should be used.\n     *                      If this is greater than requiredAmount more tokens will be locked.\n     /\n    function _lockFunds(\n        address payer,\n        address token,\n        uint256 lockAmount,\n        uint256 depositAmount\n    ) internal {\n        address stakerVaultAddress = addressProvider.getStakerVault(token);\n        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);\n    }\n\n    function _removePosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) internal {\n        delete _positions[payer][account][protocol];\n        _removeUserPosition(payer, account, protocol);\n        if (_userPositions[payer].length == 0) {\n            _usersWithPositions.remove(payer);\n        }\n        emit Deregister(payer, account, protocol);\n    }\n\n    function _removeUserPosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) internal {\n        RecordMeta[] storage positionsMeta = _userPositions[payer];\n        uint256 length = positionsMeta.length;\n        for (uint256 i; i &lt; length; i = i.uncheckedInc()) {\n            RecordMeta storage positionMeta = positionsMeta[i];\n            if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {\n                positionsMeta[i] = positionsMeta[length - 1];\n                positionsMeta.pop();\n                return;\n            }\n        }\n    }\n\n    /\n     * @dev Approves infinite spending for the given spender.\n     * @param token The token to approve for.\n     * @param spender The spender to approve.\n     */\n    function _approve(address token, address spender) internal {\n        if (IERC20(token).allowance(address(this), spender) &gt; 0) return;\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n\n    /\n     * @dev Computes and returns the amount of LP tokens of type token that will be received in exchange for an amount of the actionToken.\n     */\n    function _calcExchangeAmount(\n        address token,\n        address actionToken,\n        uint256 amount\n    ) internal view returns (uint256) {\n        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);\n    }\n\n    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {\n        address handler = currentAddresses[_getProtocolKey(protocol)];\n        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);\n        return handler;\n    }\n\n    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);\n        return pool.getUnderlying() == toToken;\n    }\n\n    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));\n    }\n}\n', 'ideas': ' 1'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 12:30:36 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.10; import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol"; import "@openzeppelin/contracts/utils/math/SafeCast.sol"; import "../../../interfaces/IGasBank.sol"; import "../../../interfaces/pool/ILiquidityPool.sol"; import "../../../interfaces/IController.sol"; import "../../../interfaces/IStakerVault.sol"; import "../../../interfaces/actions/topup/ITopUpHandler.sol"; import "../../../interfaces/actions/topup/ITopUpAction.sol"; import "../../../interfaces/actions/IActionFeeHandler.sol"; import "../../../libraries/AddressProviderHelpers.sol"; import "../../../libraries/Errors.sol"; import "../../../libraries/ScaledMath.sol"; import "../../../libraries/EnumerableExtensions.sol"; import "../../../libraries/UncheckedMath.sol"; import "../../access/Authorization.sol"; import "../../utils/Preparable.sol"; /*  * @notice The logic here should really be part of the top-up action  * but is split in a library to circumvent the byte-code size limit  / library TopUpActionLibrary {     using SafeERC20 for IERC20;     using ScaledMath for uint256;     using AddressProviderHelpers for IAddressProvider; /**  * @dev "Locks" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param stakerVaultAddress The address of the staker vault  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function lockFunds(     address stakerVaultAddress,     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) external {     IStakerVault stakerVault = IStakerVault(stakerVaultAddress);      // stake deposit amount     if (depositAmount &gt; 0) {         depositAmount = depositAmount &gt; lockAmount ? lockAmount : depositAmount;         IERC20(token).safeTransferFrom(payer, address(this), depositAmount);         _approve(token, stakerVaultAddress);         stakerVault.stake(depositAmount);         stakerVault.increaseActionLockedBalance(payer, depositAmount);         lockAmount -= depositAmount;     }      // use stake vault allowance if available and required     if (lockAmount &gt; 0) {         uint256 balance = stakerVault.balanceOf(payer);         uint256 allowance = stakerVault.allowance(payer, address(this));         uint256 availableFunds = balance &lt; allowance ? balance : allowance;         if (availableFunds &gt;= lockAmount) {             stakerVault.transferFrom(payer, address(this), lockAmount);             stakerVault.increaseActionLockedBalance(payer, lockAmount);             lockAmount = 0;         }     }      require(lockAmount == 0, Error.INSUFFICIENT_UPDATE_BALANCE); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function calcExchangeAmount(     IAddressProvider addressProvider,     address token,     address actionToken,     uint256 amount ) external view returns (uint256) {     ILiquidityPool pool = addressProvider.getPoolForToken(token);     uint256 rate = pool.exchangeRate();     address underlying = pool.getUnderlying();     require(underlying == actionToken, Error.TOKEN_NOT_USABLE);     return amount.scaledDivRoundUp(rate); }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) private {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  } contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {     using ScaledMath for uint256;     using UncheckedMath for uint256;     using ScaledMath for uint128;     using SafeERC20 for IERC20;     using EnumerableSet for EnumerableSet.AddressSet;     using EnumerableSet for EnumerableSet.Bytes32Set;     using EnumerableExtensions for EnumerableSet.AddressSet;     using AddressProviderHelpers for IAddressProvider;     using SafeCast for uint256; /**  * @dev Temporary struct to hold local variables in execute  * and avoid the stack being "too deep"  */ struct ExecuteLocalVars {     uint256 minActionAmountToTopUp;     uint256 actionTokenAmount;     uint256 depositTotalFeesAmount;     uint256 actionAmountWithFees;     uint256 userFactor;     uint256 rate;     uint256 depositAmountWithFees;     uint256 depositAmountWithoutFees;     uint256 actionFee;     uint256 totalActionTokenAmount;     uint128 totalTopUpAmount;     bool topupResult;     uint256 gasBankBalance;     uint256 initialGas;     uint256 gasConsumed;     uint256 userGasPrice;     uint256 estimatedRequiredGas;     uint256 estimatedRequiredWeiForGas;     uint256 requiredWeiForGas;     uint256 reimbursedWeiForGas;     address underlying;     bool removePosition;     address topUpHandler; }  EnumerableSet.AddressSet private _usableTokens;  uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 550_000;  bytes32 internal constant _ACTION_FEE_KEY = "ActionFee"; bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler"; bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler"; bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";  uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;  IController public immutable controller; IAddressProvider public immutable addressProvider;  EnumerableSet.Bytes32Set internal _supportedProtocols;  /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record) mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;  mapping(address =&gt; RecordMeta[]) internal _userPositions;  EnumerableSet.AddressSet internal _usersWithPositions;  constructor(IController _controller)     Authorization(_controller.addressProvider().getRoleManager()) {     controller = _controller;     addressProvider = controller.addressProvider();     _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE); }  receive() external payable {     // solhint-disable-previous-line no-empty-blocks }  function initialize(     address feeHandler,     bytes32[] calldata protocols,     address[] calldata handlers ) external initializer onlyGovernance {     require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);     _setConfig(_FEE_HANDLER_KEY, feeHandler);     for (uint256 i; i &lt; protocols.length; i = i.uncheckedInc()) {         bytes32 protocolKey = _getProtocolKey(protocols[i]);         _setConfig(protocolKey, handlers[i]);         _updateTopUpHandler(protocols[i], address(0), handlers[i]);     } }  /**  * @notice Register a top up action.  * @dev The `depositAmount`, once converted to units of `actionToken`, must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).  * @param account Account to be topped up (first 20 bytes will typically be the address).  * @param protocol Protocol which holds position to be topped up.  * @param depositAmount Amount of `depositToken` that will be locked.  * @param record containing the data for the position to register  */ function register(     bytes32 account,     bytes32 protocol,     uint128 depositAmount,     Record memory record ) external payable override returns (bool) {     require(record.maxFee != 0, Error.INVALID_MAX_FEE);     require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);     require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);     require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);     require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);     require(         _positions[msg.sender][account][protocol].threshold == 0,         Error.POSITION_ALREADY_EXISTS     );     require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);     require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);      uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *         record.maxFee *         getEstimatedGasUsage();      require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);      uint256 totalLockAmount = _calcExchangeAmount(         record.depositToken,         record.actionToken,         record.totalTopUpAmount     );     _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);      addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);      record.registeredAt = uint64(block.timestamp);     record.depositTokenBalance = totalLockAmount.toUint128();     _positions[msg.sender][account][protocol] = record;     _userPositions[msg.sender].push(RecordMeta(account, protocol));     _usersWithPositions.add(msg.sender);      emit Register(         account,         protocol,         record.threshold,         msg.sender,         record.depositToken,         totalLockAmount,         record.actionToken,         record.singleTopUpAmount,         record.totalTopUpAmount,         record.maxFee,         record.extra     );     return true; }  /**  * @notice See overloaded version of `execute` for more details.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol ) external override returns (bool) {     return execute(payer, account, beneficiary, protocol, 0); }  /**  * @notice Delete a position to back on the given protocol for `account`.  * @param account Account holding the position.  * @param protocol Protocol the position is held on.  * @param unstake If the tokens should be unstaked from vault.  * @return `true` if successful.  */ function resetPosition(     bytes32 account,     bytes32 protocol,     bool unstake ) external override returns (bool) {     address payer = msg.sender;     Record memory position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);      IAddressProvider addressProvider_ = addressProvider;     address vault = addressProvider_.getStakerVault(position.depositToken); // will revert if vault does not exist     IStakerVault staker = IStakerVault(vault);     staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);     if (unstake) {         staker.unstake(position.depositTokenBalance);         IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);     } else {         staker.transfer(payer, position.depositTokenBalance);     }      _removePosition(payer, account, protocol);     addressProvider_.getGasBank().withdrawUnused(payer);     return true; }  /**  * @notice Execute top up handler update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @param protocol Protocol for which a new handler should be executed.  * @return Address of new handler.  */ function executeTopUpHandler(bytes32 protocol) external override returns (address) {     address oldHandler = _getHandler(protocol, false);     address newHandler = _executeAddress(_getProtocolKey(protocol));      _updateTopUpHandler(protocol, oldHandler, newHandler);     return newHandler; }  /**  * @notice Reset new top up handler deadline for a protocol.  * @param protocol Protocol for which top up handler deadline should be reset.  * @return `true` if successful.  */ function resetTopUpHandler(bytes32 protocol) external override onlyGovernance returns (bool) {     return _resetAddressConfig(_getProtocolKey(protocol)); }  /**  * @notice Prepare action fee update.  * @param newActionFee New fee to set.  * @return `true` if success.  */ function prepareActionFee(uint256 newActionFee)     external     override     onlyGovernance     returns (bool) {     require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);     return _prepare(_ACTION_FEE_KEY, newActionFee); }  /**  * @notice Execute action fee update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeActionFee() external override returns (uint256) {     return _executeUInt256(_ACTION_FEE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetActionFee() external override onlyGovernance returns (bool) {     return _resetUInt256Config(_ACTION_FEE_KEY); }  /** Set fee handler */ /**  * @notice Prepare update of fee handler.  * @param handler New fee handler.  * @return `true` if success.  */ function prepareFeeHandler(address handler) external override onlyGovernance returns (bool) {     return _prepare(_FEE_HANDLER_KEY, handler); }  /**  * @notice Execute update of fee handler (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeFeeHandler() external override returns (address) {     return _executeAddress(_FEE_HANDLER_KEY); }  /**  * @notice Reset the handler deadline.  * @return `true` if success.  */ function resetFeeHandler() external override onlyGovernance returns (bool) {     return _resetAddressConfig(_FEE_HANDLER_KEY); }  /**  * @notice Prepare update of estimated gas usage.  * @param gasUsage New estimated gas usage.  * @return `true` if success.  */ function prepareEstimatedGasUsage(uint256 gasUsage)     external     override     onlyGovernance     returns (bool) {     return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage); }  /**  * @notice Execute update of gas usage (with time delay enforced).  * @return `true` if successful.  */ function executeEstimatedGasUsage() external override returns (uint256) {     return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Reset the gas usage deadline.  * @return `true` if success.  */ function resetGasUsage() external override onlyGovernance returns (bool) {     return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Add a new deposit token that is supported by the action.  * @dev There is a separate check for whether the usable token (i.e. deposit token)  *      is swappable for some action token.  * @param token Address of deposit token that can be used by the action.  */ function addUsableToken(address token) external override onlyGovernance returns (bool) {     return _usableTokens.add(token); }  /**  * @notice Computes the total amount of ETH (as wei) required to pay for all  * the top-ups assuming the maximum gas price and the current estimated gas  * usage of a top-up  */ function getEthRequiredForGas(address payer) external view override returns (uint256) {     uint256 totalEthRequired;     RecordMeta[] memory userRecordsMeta = _userPositions[payer];     uint256 gasUsagePerCall = getEstimatedGasUsage();     uint256 length = userRecordsMeta.length;     for (uint256 i; i &lt; length; i = i.uncheckedInc()) {         RecordMeta memory meta = userRecordsMeta[i];         Record memory record = _positions[payer][meta.account][meta.protocol];         uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);         totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;     }     return totalEthRequired; }  /**  * @notice Returns a list of positions for the given payer  */ function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {     return _userPositions[payer]; }  /**  * @notice Get a list supported protocols.  * @return List of supported protocols.  */ function getSupportedProtocols() external view override returns (bytes32[] memory) {     uint256 length = _supportedProtocols.length();     bytes32[] memory protocols = new bytes32[](length);     for (uint256 i; i &lt; length; i = i.uncheckedInc()) {         protocols[i] = _supportedProtocols.at(i);     }     return protocols; }  /*  * @notice Gets a list of users that have an active position.  * @dev Uses cursor pagination.  * @param cursor The cursor for pagination (should start at 0 for first call).  * @param howMany Maximum number of users to return in this pagination request.  * @return users List of users that have an active position.  * @return nextCursor The cursor to use for the next pagination request.  */ function usersWithPositions(uint256 cursor, uint256 howMany)     external     view     override     returns (address[] memory users, uint256 nextCursor) {     uint256 length = _usersWithPositions.length();     if (cursor &gt;= length) return (new address[](0), 0);     if (howMany &gt;= length - cursor) {         howMany = length - cursor;     }      address[] memory usersWithPositions_ = new address[](howMany);     for (uint256 i; i &lt; howMany; i = i.uncheckedInc()) {         usersWithPositions_[i] = _usersWithPositions.at(i + cursor);     }      return (usersWithPositions_, cursor + howMany); }  /**  * @notice Get a list of all tokens usable for this action.  * @dev This refers to all tokens that can be used as deposit tokens.  * @return Array of addresses of usable tokens.  */ function getUsableTokens() external view override returns (address[] memory) {     return _usableTokens.toArray(); }  /**  * @notice Retrieves the topup handler for the given `protocol`  */ function getTopUpHandler(bytes32 protocol) external view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice Successfully tops up a position if it's conditions are met.  * @dev pool and vault funds are rebalanced after withdrawal for top up  * @param payer Account that pays for the top up.  * @param account Account owning the position for top up.  * @param beneficiary Address of the keeper's wallet for fee accrual.  * @param protocol Protocol of the top up position.  * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas  * @return `true` if successful.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol,     uint256 maxWeiForGas ) public override returns (bool) {     require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);      ExecuteLocalVars memory vars;      vars.initialGas = gasleft();      Record storage position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);     require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);     require(block.timestamp &gt; position.registeredAt, Error.CANNOT_EXECUTE_IN_SAME_BLOCK);      vars.topUpHandler = _getHandler(protocol, true);     vars.userFactor = ITopUpHandler(vars.topUpHandler).getUserFactor(account, position.extra);      // ensure that the position is actually below its set user factor threshold     require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);      IAddressProvider addressProvider_ = addressProvider;     IGasBank gasBank = addressProvider_.getGasBank();      // fail early if the user does not have enough funds in the gas bank     // to cover the cost of the transaction     vars.estimatedRequiredGas = getEstimatedGasUsage();     vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;      // compute the gas price that the user will be paying     vars.userGasPrice = block.basefee + position.priorityFee;     if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;     if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;      // ensure the current position allows for the gas to be paid     require(         vars.estimatedRequiredWeiForGas &lt;=             vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,         Error.ESTIMATED_GAS_TOO_HIGH     );      vars.gasBankBalance = gasBank.balanceOf(payer);     // ensure the user has enough funds in the gas bank to cover the gas     require(         vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,         Error.GAS_BANK_BALANCE_TOO_LOW     );      vars.totalTopUpAmount = position.totalTopUpAmount;     vars.actionFee = getActionFee();     // add top-up fees to top-up amount     vars.minActionAmountToTopUp = position.singleTopUpAmount;     vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(         ScaledMath.ONE + vars.actionFee     );      // if the amount that we want to top-up (including fees) is higher than     // the available topup amount, we lower this down to what is left of the position     if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {         vars.actionAmountWithFees = vars.totalTopUpAmount;         vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(             ScaledMath.ONE + vars.actionFee         );     }     ILiquidityPool pool = addressProvider_.getPoolForToken(position.depositToken);     vars.underlying = pool.getUnderlying();     vars.rate = pool.exchangeRate();      // compute the deposit tokens amount with and without fees     // we will need to unstake the amount with fees and to     // swap the amount without fees into action tokens     vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);     if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {         vars.depositAmountWithFees = position.depositTokenBalance;         vars.minActionAmountToTopUp =             (vars.depositAmountWithFees * vars.rate) /             (ScaledMath.ONE + vars.actionFee);     }      // compute amount of LP tokens needed to pay for action     // rate is expressed in actionToken per depositToken     vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);     vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;      // will revert if vault does not exist     address vault = addressProvider_.getStakerVault(position.depositToken);      // unstake deposit tokens including fees     IStakerVault(vault).unstake(vars.depositAmountWithFees);     IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);      // swap the amount without the fees     // as the fees are paid in deposit token, not in action token     vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);      // compute how much of action token was actually redeemed and add fees to it     // this is to ensure that no funds get locked inside the contract     vars.totalActionTokenAmount =         vars.actionTokenAmount +         vars.depositTotalFeesAmount.scaledMul(vars.rate);      // at this point, we have exactly `vars.actionTokenAmount`     // (at least `position.singleTopUpAmount`) of action token     // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract     // solhint-disable-next-line avoid-low-level-calls     uint256 value_;     if (position.actionToken == address(0)) {         value_ = vars.actionTokenAmount;     } else {         _approve(position.actionToken, vars.topUpHandler);     }     vars.topupResult = ITopUpHandler(vars.topUpHandler).topUp{value: value_}(         account,         position.actionToken,         vars.actionTokenAmount,         position.extra     );      require(vars.topupResult, Error.TOP_UP_FAILED);      // totalTopUpAmount is updated to reflect the new "balance" of the position     if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {         position.totalTopUpAmount -= vars.totalActionTokenAmount.toUint128();     } else {         position.totalTopUpAmount = 0;     }      position.depositTokenBalance -= vars.depositAmountWithFees.toUint128();      vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;     _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);     if (vars.removePosition) {         if (position.depositTokenBalance &gt; 0) {             // transfer any unused locked tokens to the payer             IStakerVault(vault).transfer(payer, position.depositTokenBalance);             IStakerVault(vault).decreaseActionLockedBalance(                 payer,                 position.depositTokenBalance             );         }         _removePosition(payer, account, protocol);     }      emit TopUp(         account,         protocol,         payer,         position.depositToken,         vars.depositAmountWithFees,         position.actionToken,         vars.actionTokenAmount     );      // compute gas used and reimburse the keeper by using the     // funds of payer in the gas bank     // TODO: add constant gas consumed for transfer and tx prologue     vars.gasConsumed = vars.initialGas - gasleft();      vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;     if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {         vars.reimbursedWeiForGas = vars.gasBankBalance;     }      // ensure that the keeper is not overpaying     vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;     require(         vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,         Error.GAS_TOO_HIGH     );     gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);     if (vars.removePosition) {         gasBank.withdrawUnused(payer);     }      return true; }  /**  * @notice Prepare new top up handler fee update.  * @dev Setting the address to 0 means that the protocol will no longer be supported.  * @param protocol Protocol for which a new handler should be prepared.  * @param newHandler Address of new handler.  * @return `true` if success.  */ function prepareTopUpHandler(bytes32 protocol, address newHandler)     public     override     onlyGovernance     returns (bool) {     return _prepare(_getProtocolKey(protocol), newHandler); }  /**  * @notice Check if action can be executed.  * @param protocol for which to get the health factor  * @param account for which to get the health factor  * @param extra data to be used by the topup handler  * @return healthFactor of the position  */ function getHealthFactor(     bytes32 protocol,     bytes32 account,     bytes calldata extra ) public view override returns (uint256 healthFactor) {     ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));     return topUpHandler.getUserFactor(account, extra); }  function getHandler(bytes32 protocol) public view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice returns the current estimated gas usage  */ function getEstimatedGasUsage() public view override returns (uint256) {     return currentUInts256[_ESTIMATED_GAS_USAGE_KEY]; }  /**  * @notice Returns the current action fee  */ function getActionFee() public view override returns (uint256) {     return currentUInts256[_ACTION_FEE_KEY]; }  /**  * @notice Returns the current fee handler  */ function getFeeHandler() public view override returns (address) {     return currentAddresses[_FEE_HANDLER_KEY]; }  /**  * @notice Get the record for a position.  * @param payer Registered payer of the position.  * @param account Address holding the position.  * @param protocol Protocol where the position is held.  */ function getPosition(     address payer,     bytes32 account,     bytes32 protocol ) public view override returns (Record memory) {     return _positions[payer][account][protocol]; }  /**  * @notice Check whether a token is usable as a deposit token.  * @param token Address of token to check.  * @return True if token is usable as a deposit token for this action.  */ function isUsable(address token) public view override returns (bool) {     return _usableTokens.contains(token); }  function _updateTopUpHandler(     bytes32 protocol,     address oldHandler,     address newHandler ) internal {     if (newHandler == address(0)) {         _supportedProtocols.remove(protocol);     } else if (oldHandler == address(0)) {         _supportedProtocols.add(protocol);     } }  /**  * @dev Pays fees to the feeHandler  * @param payer The account who's position the fees are charged on  * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)  * @param feeAmount The amount in tokens to pay as fees  * @param depositToken The LpToken used to pay the fees  */ function _payFees(     address payer,     address beneficiary,     uint256 feeAmount,     address depositToken ) internal {     address feeHandler = getFeeHandler();     IERC20(depositToken).safeApprove(feeHandler, feeAmount);     IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken); }  /**  * @dev "Locks" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function _lockFunds(     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) internal {     address stakerVaultAddress = addressProvider.getStakerVault(token);     TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount); }  function _removePosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     delete _positions[payer][account][protocol];     _removeUserPosition(payer, account, protocol);     if (_userPositions[payer].length == 0) {         _usersWithPositions.remove(payer);     }     emit Deregister(payer, account, protocol); }  function _removeUserPosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     RecordMeta[] storage positionsMeta = _userPositions[payer];     uint256 length = positionsMeta.length;     for (uint256 i; i &lt; length; i = i.uncheckedInc()) {         RecordMeta storage positionMeta = positionsMeta[i];         if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {             positionsMeta[i] = positionsMeta[length - 1];             positionsMeta.pop();             return;         }     } }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) internal {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the `actionToken`.  */ function _calcExchangeAmount(     address token,     address actionToken,     uint256 amount ) internal view returns (uint256) {     return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount); }  function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {     address handler = currentAddresses[_getProtocolKey(protocol)];     require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);     return handler; }  function _isSwappable(address depositToken, address toToken) internal view returns (bool) {     ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);     return pool.getUnderlying() == toToken; }  function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {     return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol)); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 12:30:36 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.10;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";
import "@openzeppelin/contracts/utils/math/SafeCast.sol";

import "../../../interfaces/IGasBank.sol";
import "../../../interfaces/pool/ILiquidityPool.sol";
import "../../../interfaces/IController.sol";
import "../../../interfaces/IStakerVault.sol";
import "../../../interfaces/actions/topup/ITopUpHandler.sol";
import "../../../interfaces/actions/topup/ITopUpAction.sol";
import "../../../interfaces/actions/IActionFeeHandler.sol";

import "../../../libraries/AddressProviderHelpers.sol";
import "../../../libraries/Errors.sol";
import "../../../libraries/ScaledMath.sol";
import "../../../libraries/EnumerableExtensions.sol";
import "../../../libraries/UncheckedMath.sol";

import "../../access/Authorization.sol";
import "../../utils/Preparable.sol";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param stakerVaultAddress The address of the staker vault
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > lockAmount ? lockAmount : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            _approve(token, stakerVaultAddress);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            lockAmount -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (lockAmount > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= lockAmount) {
                stakerVault.transferFrom(payer, address(this), lockAmount);
                stakerVault.increaseActionLockedBalance(payer, lockAmount);
                lockAmount = 0;
            }
        }

        require(lockAmount == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        require(underlying == actionToken, Error.TOKEN_NOT_USABLE);
        return amount.scaledDivRoundUp(rate);
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) private {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using UncheckedMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;
    using SafeCast for uint256;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being "too deep"
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
        address topUpHandler;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 550_000;

    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";
    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        for (uint256 i; i < protocols.length; i = i.uncheckedInc()) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount`, once converted to units of `actionToken`, must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param protocol Protocol which holds position to be topped up.
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable override returns (bool) {
        require(record.maxFee != 0, Error.INVALID_MAX_FEE);
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.registeredAt = uint64(block.timestamp);
        record.depositTokenBalance = totalLockAmount.toUint128();
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        IAddressProvider addressProvider_ = addressProvider;
        address vault = addressProvider_.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider_.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external override onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee)
        external
        override
        onlyGovernance
        returns (bool)
    {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external override onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external override onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external override onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage)
        external
        override
        onlyGovernance
        returns (bool)
    {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external override returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external override onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i; i < howMany; i = i.uncheckedInc()) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);
        require(block.timestamp > position.registeredAt, Error.CANNOT_EXECUTE_IN_SAME_BLOCK);

        vars.topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(vars.topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IAddressProvider addressProvider_ = addressProvider;
        IGasBank gasBank = addressProvider_.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider_.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider_.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        uint256 value_;
        if (position.actionToken == address(0)) {
            value_ = vars.actionTokenAmount;
        } else {
            _approve(position.actionToken, vars.topUpHandler);
        }
        vars.topupResult = ITopUpHandler(vars.topUpHandler).topUp{value: value_}(
            account,
            position.actionToken,
            vars.actionTokenAmount,
            position.extra
        );

        require(vars.topupResult, Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new "balance" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= vars.totalActionTokenAmount.toUint128();
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= vars.depositAmountWithFees.toUint128();

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the address to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        override
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes calldata extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view override returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the `actionToken`.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        return pool.getUnderlying() == toToken;
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.10;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";
import "@openzeppelin/contracts/utils/math/SafeCast.sol";

import "../../../interfaces/IGasBank.sol";
import "../../../interfaces/pool/ILiquidityPool.sol";
import "../../../interfaces/IController.sol";
import "../../../interfaces/IStakerVault.sol";
import "../../../interfaces/actions/topup/ITopUpHandler.sol";
import "../../../interfaces/actions/topup/ITopUpAction.sol";
import "../../../interfaces/actions/IActionFeeHandler.sol";

import "../../../libraries/AddressProviderHelpers.sol";
import "../../../libraries/Errors.sol";
import "../../../libraries/ScaledMath.sol";
import "../../../libraries/EnumerableExtensions.sol";
import "../../../libraries/UncheckedMath.sol";

import "../../access/Authorization.sol";
import "../../utils/Preparable.sol";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param stakerVaultAddress The address of the staker vault
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > lockAmount ? lockAmount : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            _approve(token, stakerVaultAddress);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            lockAmount -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (lockAmount > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= lockAmount) {
                stakerVault.transferFrom(payer, address(this), lockAmount);
                stakerVault.increaseActionLockedBalance(payer, lockAmount);
                lockAmount = 0;
            }
        }

        require(lockAmount == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        require(underlying == actionToken, Error.TOKEN_NOT_USABLE);
        return amount.scaledDivRoundUp(rate);
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) private {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using UncheckedMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;
    using SafeCast for uint256;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being "too deep"
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
        address topUpHandler;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 550_000;

    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";
    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        for (uint256 i; i < protocols.length; i = i.uncheckedInc()) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount`, once converted to units of `actionToken`, must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param protocol Protocol which holds position to be topped up.
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable override returns (bool) {
        require(record.maxFee != 0, Error.INVALID_MAX_FEE);
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.registeredAt = uint64(block.timestamp);
        record.depositTokenBalance = totalLockAmount.toUint128();
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        IAddressProvider addressProvider_ = addressProvider;
        address vault = addressProvider_.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider_.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external override onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee)
        external
        override
        onlyGovernance
        returns (bool)
    {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external override onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external override onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external override onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage)
        external
        override
        onlyGovernance
        returns (bool)
    {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external override returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external override onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i; i < howMany; i = i.uncheckedInc()) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);
        require(block.timestamp > position.registeredAt, Error.CANNOT_EXECUTE_IN_SAME_BLOCK);

        vars.topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(vars.topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IAddressProvider addressProvider_ = addressProvider;
        IGasBank gasBank = addressProvider_.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider_.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider_.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        uint256 value_;
        if (position.actionToken == address(0)) {
            value_ = vars.actionTokenAmount;
        } else {
            _approve(position.actionToken, vars.topUpHandler);
        }
        vars.topupResult = ITopUpHandler(vars.topUpHandler).topUp{value: value_}(
            account,
            position.actionToken,
            vars.actionTokenAmount,
            position.extra
        );

        require(vars.topupResult, Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new "balance" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= vars.totalActionTokenAmount.toUint128();
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= vars.depositAmountWithFees.toUint128();

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the address to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        override
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes calldata extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view override returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the `actionToken`.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        return pool.getUnderlying() == toToken;
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
".
Ideas: " 1".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-01-09 12:30:51 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 12:30:51 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 15304
completion_tokens: 1061
total_tokens: 16365
cost: $-1.000000


[2024-01-09 12:30:51 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.10;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";
import "@openzeppelin/contracts/utils/math/SafeCast.sol";

import "../../../interfaces/IGasBank.sol";
import "../../../interfaces/pool/ILiquidityPool.sol";
import "../../../interfaces/IController.sol";
import "../../../interfaces/IStakerVault.sol";
import "../../../interfaces/actions/topup/ITopUpHandler.sol";
import "../../../interfaces/actions/topup/ITopUpAction.sol";
import "../../../interfaces/actions/IActionFeeHandler.sol";

import "../../../libraries/AddressProviderHelpers.sol";
import "../../../libraries/Errors.sol";
import "../../../libraries/ScaledMath.sol";
import "../../../libraries/EnumerableExtensions.sol";
import "../../../libraries/UncheckedMath.sol";

import "../../access/Authorization.sol";
import "../../utils/Preparable.sol";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param stakerVaultAddress The address of the staker vault
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > lockAmount ? lockAmount : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            _approve(token, stakerVaultAddress);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            lockAmount -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (lockAmount > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= lockAmount) {
                stakerVault.transferFrom(payer, address(this), lockAmount);
                stakerVault.increaseActionLockedBalance(payer, lockAmount);
                lockAmount = 0;
            }
        }

        require(lockAmount == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        require(underlying == actionToken, Error.TOKEN_NOT_USABLE);
        return amount.scaledDivRoundUp(rate);
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) private {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using UncheckedMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;
    using SafeCast for uint256;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being "too deep"
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
        address topUpHandler;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 550_000;

    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";
    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        for (uint256 i; i < protocols.length; i = i.uncheckedInc()) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount`, once converted to units of `actionToken`, must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param protocol Protocol which holds position to be topped up.
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable override returns (bool) {
        require(record.maxFee != 0, Error.INVALID_MAX_FEE);
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.registeredAt = uint64(block.timestamp);
        record.depositTokenBalance = totalLockAmount.toUint128();
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        IAddressProvider addressProvider_ = addressProvider;
        address vault = addressProvider_.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider_.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external override onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee)
        external
        override
        onlyGovernance
        returns (bool)
    {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external override onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external override onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external override onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage)
        external
        override
        onlyGovernance
        returns (bool)
    {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external override returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external override onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i; i < howMany; i = i.uncheckedInc()) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);
        require(block.timestamp > position.registeredAt, Error.CANNOT_EXECUTE_IN_SAME_BLOCK);

        vars.topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(vars.topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IAddressProvider addressProvider_ = addressProvider;
        IGasBank gasBank = addressProvider_.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider_.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider_.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        uint256 value_;
        if (position.actionToken == address(0)) {
            value_ = vars.actionTokenAmount;
        } else {
            _approve(position.actionToken, vars.topUpHandler);
        }
        vars.topupResult = ITopUpHandler(vars.topUpHandler).topUp{value: value_}(
            account,
            position.actionToken,
            vars.actionTokenAmount,
            position.extra
        );

        require(vars.topupResult, Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new "balance" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= vars.totalActionTokenAmount.toUint128();
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= vars.depositAmountWithFees.toUint128();

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the address to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        override
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes calldata extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view override returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the `actionToken`.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        return pool.getUnderlying() == toToken;
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
.]

### VULNERABILITY 1: Reentrancy Attack
```
DETAILED DESCRIPTION: The contract does not implement any reentrancy guards, particularly in the `execute` function where external calls are made to the `topUpHandler`. If the `topUpHandler` is a malicious contract, it could call back into the `TopUpAction` contract before the state changes are completed, leading to potential reentrancy attacks.

POTENTIAL IMPACT: An attacker could exploit this vulnerability to drain funds from the contract or manipulate the state in unintended ways, leading to loss of funds or incorrect contract behavior.

RECOMMENDED MITIGATION: Implement a reentrancy guard using the `nonReentrant` modifier from OpenZeppelin's ReentrancyGuard contract. This should be applied to functions that make external calls, particularly the `execute` function.
```

### VULNERABILITY 2: Gas Limit and Loops
```
DETAILED DESCRIPTION: The `usersWithPositions` function uses a loop to return users with active positions. If the number of users is large, this could lead to exceeding the block gas limit, causing the transaction to fail.

POTENTIAL IMPACT: Users may be unable to retrieve their positions if the number of users exceeds the gas limit, leading to a denial of service.

RECOMMENDED MITIGATION: Implement pagination or a limit on the number of users returned in a single call. This will ensure that the function can always execute within the gas limits.
```

### VULNERABILITY 3: Improper Input Validation
```
DETAILED DESCRIPTION: In the `register` function, there are several require statements that check for valid input. However, there are no checks to ensure that the `depositAmount` and `record` parameters are valid before proceeding with the locking of funds.

POTENTIAL IMPACT: If invalid or malicious data is passed, it could lead to unexpected behavior or state corruption.

RECOMMENDED MITIGATION: Add additional checks to validate the `depositAmount` and ensure that the `record` structure contains valid data before proceeding with the logic.
```

### VULNERABILITY 4: Lack of Access Control
```
DETAILED DESCRIPTION: The `resetPosition` function allows any user to reset a position for any account. This could lead to unauthorized users manipulating positions that do not belong to them.

POTENTIAL IMPACT: An attacker could reset positions of other users, leading to loss of funds or manipulation of the contract state.

RECOMMENDED MITIGATION: Implement proper access control to ensure that only the owner of the position can reset it. This can be done by checking that `msg.sender` is the same as the `payer` associated with the position.
```

### VULNERABILITY 5: Insufficient Handling of Ether Transfers
```
DETAILED DESCRIPTION: The contract uses `transfer` for Ether transfers in the `execute` function. If the receiving contract does not implement the `receive` function or if it consumes too much gas, the transfer will fail.

POTENTIAL IMPACT: This could lead to failed transactions and loss of funds if not handled properly.

RECOMMENDED MITIGATION: Use `call` instead of `transfer` for Ether transfers, as it forwards all available gas and allows for better error handling. Always check the return value of the call to ensure that the transfer was successful.
```

### VULNERABILITY 6: Integer Overflow/Underflow
```
DETAILED DESCRIPTION: Although Solidity 0.8.0 and above has built-in overflow and underflow checks, there are still areas in the code where arithmetic operations could lead to unexpected behavior if not handled properly, especially when manipulating balances and amounts.

POTENTIAL IMPACT: If an overflow or underflow occurs, it could lead to incorrect balances, allowing users to withdraw more than they should or causing the contract to behave unexpectedly.

RECOMMENDED MITIGATION: Ensure that all arithmetic operations are checked and handled properly, especially in critical functions like `execute` and `register`. Consider using SafeMath for clarity, even though it's not strictly necessary in Solidity 0.8.0 and above.
```

### VULNERABILITY 7: Unchecked External Calls
```
DETAILED DESCRIPTION: The contract makes external calls to other contracts (e.g., `topUpHandler`, `gasBank`, etc.) without checking the return values. If these calls fail, the contract may enter an inconsistent state.

POTENTIAL IMPACT: Failure to check return values can lead to loss of funds or incorrect state, as the contract may proceed with operations that depend on the success of these calls.

RECOMMENDED MITIGATION: Always check the return values of external calls and handle failures gracefully. This can include reverting the transaction or implementing fallback mechanisms.
```

### VULNERABILITY 8: Lack of Event Emission for Critical State Changes
```
DETAILED DESCRIPTION: The contract does not emit events for certain critical state changes, such as when positions are reset or when fees are paid.

POTENTIAL IMPACT: This lack of transparency can make it difficult for users to track changes and for external systems to monitor the contract

[2024-01-09 12:30:51 INFO] **[Seminar Conclusion]**:

 ### VULNERABILITY 1: Reentrancy Attack
```
DETAILED DESCRIPTION: The contract does not implement any reentrancy guards, particularly in the `execute` function where external calls are made to the `topUpHandler`. If the `topUpHandler` is a malicious contract, it could call back into the `TopUpAction` contract before the state changes are completed, leading to potential reentrancy attacks.

POTENTIAL IMPACT: An attacker could exploit this vulnerability to drain funds from the contract or manipulate the state in unintended ways, leading to loss of funds or incorrect contract behavior.

RECOMMENDED MITIGATION: Implement a reentrancy guard using the `nonReentrant` modifier from OpenZeppelin's ReentrancyGuard contract. This should be applied to functions that make external calls, particularly the `execute` function.
```

### VULNERABILITY 2: Gas Limit and Loops
```
DETAILED DESCRIPTION: The `usersWithPositions` function uses a loop to return users with active positions. If the number of users is large, this could lead to exceeding the block gas limit, causing the transaction to fail.

POTENTIAL IMPACT: Users may be unable to retrieve their positions if the number of users exceeds the gas limit, leading to a denial of service.

RECOMMENDED MITIGATION: Implement pagination or a limit on the number of users returned in a single call. This will ensure that the function can always execute within the gas limits.
```

### VULNERABILITY 3: Improper Input Validation
```
DETAILED DESCRIPTION: In the `register` function, there are several require statements that check for valid input. However, there are no checks to ensure that the `depositAmount` and `record` parameters are valid before proceeding with the locking of funds.

POTENTIAL IMPACT: If invalid or malicious data is passed, it could lead to unexpected behavior or state corruption.

RECOMMENDED MITIGATION: Add additional checks to validate the `depositAmount` and ensure that the `record` structure contains valid data before proceeding with the logic.
```

### VULNERABILITY 4: Lack of Access Control
```
DETAILED DESCRIPTION: The `resetPosition` function allows any user to reset a position for any account. This could lead to unauthorized users manipulating positions that do not belong to them.

POTENTIAL IMPACT: An attacker could reset positions of other users, leading to loss of funds or manipulation of the contract state.

RECOMMENDED MITIGATION: Implement proper access control to ensure that only the owner of the position can reset it. This can be done by checking that `msg.sender` is the same as the `payer` associated with the position.
```

### VULNERABILITY 5: Insufficient Handling of Ether Transfers
```
DETAILED DESCRIPTION: The contract uses `transfer` for Ether transfers in the `execute` function. If the receiving contract does not implement the `receive` function or if it consumes too much gas, the transfer will fail.

POTENTIAL IMPACT: This could lead to failed transactions and loss of funds if not handled properly.

RECOMMENDED MITIGATION: Use `call` instead of `transfer` for Ether transfers, as it forwards all available gas and allows for better error handling. Always check the return value of the call to ensure that the transfer was successful.
```

### VULNERABILITY 6: Integer Overflow/Underflow
```
DETAILED DESCRIPTION: Although Solidity 0.8.0 and above has built-in overflow and underflow checks, there are still areas in the code where arithmetic operations could lead to unexpected behavior if not handled properly, especially when manipulating balances and amounts.

POTENTIAL IMPACT: If an overflow or underflow occurs, it could lead to incorrect balances, allowing users to withdraw more than they should or causing the contract to behave unexpectedly.

RECOMMENDED MITIGATION: Ensure that all arithmetic operations are checked and handled properly, especially in critical functions like `execute` and `register`. Consider using SafeMath for clarity, even though it's not strictly necessary in Solidity 0.8.0 and above.
```

### VULNERABILITY 7: Unchecked External Calls
```
DETAILED DESCRIPTION: The contract makes external calls to other contracts (e.g., `topUpHandler`, `gasBank`, etc.) without checking the return values. If these calls fail, the contract may enter an inconsistent state.

POTENTIAL IMPACT: Failure to check return values can lead to loss of funds or incorrect state, as the contract may proceed with operations that depend on the success of these calls.

RECOMMENDED MITIGATION: Always check the return values of external calls and handle failures gracefully. This can include reverting the transaction or implementing fallback mechanisms.
```

### VULNERABILITY 8: Lack of Event Emission for Critical State Changes
```
DETAILED DESCRIPTION: The contract does not emit events for certain critical state changes, such as when positions are reset or when fees are paid.

POTENTIAL IMPACT: This lack of transparency can make it difficult for users to track changes and for external systems to monitor the contract

[2024-01-09 12:30:51 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 2

[2024-01-09 12:30:51 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.10; import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol"; import "@openzeppelin/contracts/utils/math/SafeCast.sol"; import "../../../interfaces/IGasBank.sol"; import "../../../interfaces/pool/ILiquidityPool.sol"; import "../../../interfaces/IController.sol"; import "../../../interfaces/IStakerVault.sol"; import "../../../interfaces/actions/topup/ITopUpHandler.sol"; import "../../../interfaces/actions/topup/ITopUpAction.sol"; import "../../../interfaces/actions/IActionFeeHandler.sol"; import "../../../libraries/AddressProviderHelpers.sol"; import "../../../libraries/Errors.sol"; import "../../../libraries/ScaledMath.sol"; import "../../../libraries/EnumerableExtensions.sol"; import "../../../libraries/UncheckedMath.sol"; import "../../access/Authorization.sol"; import "../../utils/Preparable.sol"; /*  * @notice The logic here should really be part of the top-up action  * but is split in a library to circumvent the byte-code size limit  / library TopUpActionLibrary {     using SafeERC20 for IERC20;     using ScaledMath for uint256;     using AddressProviderHelpers for IAddressProvider; /**  * @dev "Locks" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param stakerVaultAddress The address of the staker vault  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function lockFunds(     address stakerVaultAddress,     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) external {     IStakerVault stakerVault = IStakerVault(stakerVaultAddress);      // stake deposit amount     if (depositAmount &gt; 0) {         depositAmount = depositAmount &gt; lockAmount ? lockAmount : depositAmount;         IERC20(token).safeTransferFrom(payer, address(this), depositAmount);         _approve(token, stakerVaultAddress);         stakerVault.stake(depositAmount);         stakerVault.increaseActionLockedBalance(payer, depositAmount);         lockAmount -= depositAmount;     }      // use stake vault allowance if available and required     if (lockAmount &gt; 0) {         uint256 balance = stakerVault.balanceOf(payer);         uint256 allowance = stakerVault.allowance(payer, address(this));         uint256 availableFunds = balance &lt; allowance ? balance : allowance;         if (availableFunds &gt;= lockAmount) {             stakerVault.transferFrom(payer, address(this), lockAmount);             stakerVault.increaseActionLockedBalance(payer, lockAmount);             lockAmount = 0;         }     }      require(lockAmount == 0, Error.INSUFFICIENT_UPDATE_BALANCE); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function calcExchangeAmount(     IAddressProvider addressProvider,     address token,     address actionToken,     uint256 amount ) external view returns (uint256) {     ILiquidityPool pool = addressProvider.getPoolForToken(token);     uint256 rate = pool.exchangeRate();     address underlying = pool.getUnderlying();     require(underlying == actionToken, Error.TOKEN_NOT_USABLE);     return amount.scaledDivRoundUp(rate); }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) private {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  } contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {     using ScaledMath for uint256;     using UncheckedMath for uint256;     using ScaledMath for uint128;     using SafeERC20 for IERC20;     using EnumerableSet for EnumerableSet.AddressSet;     using EnumerableSet for EnumerableSet.Bytes32Set;     using EnumerableExtensions for EnumerableSet.AddressSet;     using AddressProviderHelpers for IAddressProvider;     using SafeCast for uint256; /**  * @dev Temporary struct to hold local variables in execute  * and avoid the stack being "too deep"  */ struct ExecuteLocalVars {     uint256 minActionAmountToTopUp;     uint256 actionTokenAmount;     uint256 depositTotalFeesAmount;     uint256 actionAmountWithFees;     uint256 userFactor;     uint256 rate;     uint256 depositAmountWithFees;     uint256 depositAmountWithoutFees;     uint256 actionFee;     uint256 totalActionTokenAmount;     uint128 totalTopUpAmount;     bool topupResult;     uint256 gasBankBalance;     uint256 initialGas;     uint256 gasConsumed;     uint256 userGasPrice;     uint256 estimatedRequiredGas;     uint256 estimatedRequiredWeiForGas;     uint256 requiredWeiForGas;     uint256 reimbursedWeiForGas;     address underlying;     bool removePosition;     address topUpHandler; }  EnumerableSet.AddressSet private _usableTokens;  uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 550_000;  bytes32 internal constant _ACTION_FEE_KEY = "ActionFee"; bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler"; bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler"; bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";  uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;  IController public immutable controller; IAddressProvider public immutable addressProvider;  EnumerableSet.Bytes32Set internal _supportedProtocols;  /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record) mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;  mapping(address =&gt; RecordMeta[]) internal _userPositions;  EnumerableSet.AddressSet internal _usersWithPositions;  constructor(IController _controller)     Authorization(_controller.addressProvider().getRoleManager()) {     controller = _controller;     addressProvider = controller.addressProvider();     _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE); }  receive() external payable {     // solhint-disable-previous-line no-empty-blocks }  function initialize(     address feeHandler,     bytes32[] calldata protocols,     address[] calldata handlers ) external initializer onlyGovernance {     require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);     _setConfig(_FEE_HANDLER_KEY, feeHandler);     for (uint256 i; i &lt; protocols.length; i = i.uncheckedInc()) {         bytes32 protocolKey = _getProtocolKey(protocols[i]);         _setConfig(protocolKey, handlers[i]);         _updateTopUpHandler(protocols[i], address(0), handlers[i]);     } }  /**  * @notice Register a top up action.  * @dev The `depositAmount`, once converted to units of `actionToken`, must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).  * @param account Account to be topped up (first 20 bytes will typically be the address).  * @param protocol Protocol which holds position to be topped up.  * @param depositAmount Amount of `depositToken` that will be locked.  * @param record containing the data for the position to register  */ function register(     bytes32 account,     bytes32 protocol,     uint128 depositAmount,     Record memory record ) external payable override returns (bool) {     require(record.maxFee != 0, Error.INVALID_MAX_FEE);     require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);     require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);     require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);     require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);     require(         _positions[msg.sender][account][protocol].threshold == 0,         Error.POSITION_ALREADY_EXISTS     );     require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);     require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);      uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *         record.maxFee *         getEstimatedGasUsage();      require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);      uint256 totalLockAmount = _calcExchangeAmount(         record.depositToken,         record.actionToken,         record.totalTopUpAmount     );     _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);      addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);      record.registeredAt = uint64(block.timestamp);     record.depositTokenBalance = totalLockAmount.toUint128();     _positions[msg.sender][account][protocol] = record;     _userPositions[msg.sender].push(RecordMeta(account, protocol));     _usersWithPositions.add(msg.sender);      emit Register(         account,         protocol,         record.threshold,         msg.sender,         record.depositToken,         totalLockAmount,         record.actionToken,         record.singleTopUpAmount,         record.totalTopUpAmount,         record.maxFee,         record.extra     );     return true; }  /**  * @notice See overloaded version of `execute` for more details.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol ) external override returns (bool) {     return execute(payer, account, beneficiary, protocol, 0); }  /**  * @notice Delete a position to back on the given protocol for `account`.  * @param account Account holding the position.  * @param protocol Protocol the position is held on.  * @param unstake If the tokens should be unstaked from vault.  * @return `true` if successful.  */ function resetPosition(     bytes32 account,     bytes32 protocol,     bool unstake ) external override returns (bool) {     address payer = msg.sender;     Record memory position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);      IAddressProvider addressProvider_ = addressProvider;     address vault = addressProvider_.getStakerVault(position.depositToken); // will revert if vault does not exist     IStakerVault staker = IStakerVault(vault);     staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);     if (unstake) {         staker.unstake(position.depositTokenBalance);         IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);     } else {         staker.transfer(payer, position.depositTokenBalance);     }      _removePosition(payer, account, protocol);     addressProvider_.getGasBank().withdrawUnused(payer);     return true; }  /**  * @notice Execute top up handler update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @param protocol Protocol for which a new handler should be executed.  * @return Address of new handler.  */ function executeTopUpHandler(bytes32 protocol) external override returns (address) {     address oldHandler = _getHandler(protocol, false);     address newHandler = _executeAddress(_getProtocolKey(protocol));      _updateTopUpHandler(protocol, oldHandler, newHandler);     return newHandler; }  /**  * @notice Reset new top up handler deadline for a protocol.  * @param protocol Protocol for which top up handler deadline should be reset.  * @return `true` if successful.  */ function resetTopUpHandler(bytes32 protocol) external override onlyGovernance returns (bool) {     return _resetAddressConfig(_getProtocolKey(protocol)); }  /**  * @notice Prepare action fee update.  * @param newActionFee New fee to set.  * @return `true` if success.  */ function prepareActionFee(uint256 newActionFee)     external     override     onlyGovernance     returns (bool) {     require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);     return _prepare(_ACTION_FEE_KEY, newActionFee); }  /**  * @notice Execute action fee update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeActionFee() external override returns (uint256) {     return _executeUInt256(_ACTION_FEE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetActionFee() external override onlyGovernance returns (bool) {     return _resetUInt256Config(_ACTION_FEE_KEY); }  /** Set fee handler */ /**  * @notice Prepare update of fee handler.  * @param handler New fee handler.  * @return `true` if success.  */ function prepareFeeHandler(address handler) external override onlyGovernance returns (bool) {     return _prepare(_FEE_HANDLER_KEY, handler); }  /**  * @notice Execute update of fee handler (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeFeeHandler() external override returns (address) {     return _executeAddress(_FEE_HANDLER_KEY); }  /**  * @notice Reset the handler deadline.  * @return `true` if success.  */ function resetFeeHandler() external override onlyGovernance returns (bool) {     return _resetAddressConfig(_FEE_HANDLER_KEY); }  /**  * @notice Prepare update of estimated gas usage.  * @param gasUsage New estimated gas usage.  * @return `true` if success.  */ function prepareEstimatedGasUsage(uint256 gasUsage)     external     override     onlyGovernance     returns (bool) {     return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage); }  /**  * @notice Execute update of gas usage (with time delay enforced).  * @return `true` if successful.  */ function executeEstimatedGasUsage() external override returns (uint256) {     return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Reset the gas usage deadline.  * @return `true` if success.  */ function resetGasUsage() external override onlyGovernance returns (bool) {     return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Add a new deposit token that is supported by the action.  * @dev There is a separate check for whether the usable token (i.e. deposit token)  *      is swappable for some action token.  * @param token Address of deposit token that can be used by the action.  */ function addUsableToken(address token) external override onlyGovernance returns (bool) {     return _usableTokens.add(token); }  /**  * @notice Computes the total amount of ETH (as wei) required to pay for all  * the top-ups assuming the maximum gas price and the current estimated gas  * usage of a top-up  */ function getEthRequiredForGas(address payer) external view override returns (uint256) {     uint256 totalEthRequired;     RecordMeta[] memory userRecordsMeta = _userPositions[payer];     uint256 gasUsagePerCall = getEstimatedGasUsage();     uint256 length = userRecordsMeta.length;     for (uint256 i; i &lt; length; i = i.uncheckedInc()) {         RecordMeta memory meta = userRecordsMeta[i];         Record memory record = _positions[payer][meta.account][meta.protocol];         uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);         totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;     }     return totalEthRequired; }  /**  * @notice Returns a list of positions for the given payer  */ function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {     return _userPositions[payer]; }  /**  * @notice Get a list supported protocols.  * @return List of supported protocols.  */ function getSupportedProtocols() external view override returns (bytes32[] memory) {     uint256 length = _supportedProtocols.length();     bytes32[] memory protocols = new bytes32[](length);     for (uint256 i; i &lt; length; i = i.uncheckedInc()) {         protocols[i] = _supportedProtocols.at(i);     }     return protocols; }  /*  * @notice Gets a list of users that have an active position.  * @dev Uses cursor pagination.  * @param cursor The cursor for pagination (should start at 0 for first call).  * @param howMany Maximum number of users to return in this pagination request.  * @return users List of users that have an active position.  * @return nextCursor The cursor to use for the next pagination request.  */ function usersWithPositions(uint256 cursor, uint256 howMany)     external     view     override     returns (address[] memory users, uint256 nextCursor) {     uint256 length = _usersWithPositions.length();     if (cursor &gt;= length) return (new address[](0), 0);     if (howMany &gt;= length - cursor) {         howMany = length - cursor;     }      address[] memory usersWithPositions_ = new address[](howMany);     for (uint256 i; i &lt; howMany; i = i.uncheckedInc()) {         usersWithPositions_[i] = _usersWithPositions.at(i + cursor);     }      return (usersWithPositions_, cursor + howMany); }  /**  * @notice Get a list of all tokens usable for this action.  * @dev This refers to all tokens that can be used as deposit tokens.  * @return Array of addresses of usable tokens.  */ function getUsableTokens() external view override returns (address[] memory) {     return _usableTokens.toArray(); }  /**  * @notice Retrieves the topup handler for the given `protocol`  */ function getTopUpHandler(bytes32 protocol) external view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice Successfully tops up a position if it's conditions are met.  * @dev pool and vault funds are rebalanced after withdrawal for top up  * @param payer Account that pays for the top up.  * @param account Account owning the position for top up.  * @param beneficiary Address of the keeper's wallet for fee accrual.  * @param protocol Protocol of the top up position.  * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas  * @return `true` if successful.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol,     uint256 maxWeiForGas ) public override returns (bool) {     require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);      ExecuteLocalVars memory vars;      vars.initialGas = gasleft();      Record storage position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);     require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);     require(block.timestamp &gt; position.registeredAt, Error.CANNOT_EXECUTE_IN_SAME_BLOCK);      vars.topUpHandler = _getHandler(protocol, true);     vars.userFactor = ITopUpHandler(vars.topUpHandler).getUserFactor(account, position.extra);      // ensure that the position is actually below its set user factor threshold     require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);      IAddressProvider addressProvider_ = addressProvider;     IGasBank gasBank = addressProvider_.getGasBank();      // fail early if the user does not have enough funds in the gas bank     // to cover the cost of the transaction     vars.estimatedRequiredGas = getEstimatedGasUsage();     vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;      // compute the gas price that the user will be paying     vars.userGasPrice = block.basefee + position.priorityFee;     if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;     if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;      // ensure the current position allows for the gas to be paid     require(         vars.estimatedRequiredWeiForGas &lt;=             vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,         Error.ESTIMATED_GAS_TOO_HIGH     );      vars.gasBankBalance = gasBank.balanceOf(payer);     // ensure the user has enough funds in the gas bank to cover the gas     require(         vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,         Error.GAS_BANK_BALANCE_TOO_LOW     );      vars.totalTopUpAmount = position.totalTopUpAmount;     vars.actionFee = getActionFee();     // add top-up fees to top-up amount     vars.minActionAmountToTopUp = position.singleTopUpAmount;     vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(         ScaledMath.ONE + vars.actionFee     );      // if the amount that we want to top-up (including fees) is higher than     // the available topup amount, we lower this down to what is left of the position     if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {         vars.actionAmountWithFees = vars.totalTopUpAmount;         vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(             ScaledMath.ONE + vars.actionFee         );     }     ILiquidityPool pool = addressProvider_.getPoolForToken(position.depositToken);     vars.underlying = pool.getUnderlying();     vars.rate = pool.exchangeRate();      // compute the deposit tokens amount with and without fees     // we will need to unstake the amount with fees and to     // swap the amount without fees into action tokens     vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);     if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {         vars.depositAmountWithFees = position.depositTokenBalance;         vars.minActionAmountToTopUp =             (vars.depositAmountWithFees * vars.rate) /             (ScaledMath.ONE + vars.actionFee);     }      // compute amount of LP tokens needed to pay for action     // rate is expressed in actionToken per depositToken     vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);     vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;      // will revert if vault does not exist     address vault = addressProvider_.getStakerVault(position.depositToken);      // unstake deposit tokens including fees     IStakerVault(vault).unstake(vars.depositAmountWithFees);     IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);      // swap the amount without the fees     // as the fees are paid in deposit token, not in action token     vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);      // compute how much of action token was actually redeemed and add fees to it     // this is to ensure that no funds get locked inside the contract     vars.totalActionTokenAmount =         vars.actionTokenAmount +         vars.depositTotalFeesAmount.scaledMul(vars.rate);      // at this point, we have exactly `vars.actionTokenAmount`     // (at least `position.singleTopUpAmount`) of action token     // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract     // solhint-disable-next-line avoid-low-level-calls     uint256 value_;     if (position.actionToken == address(0)) {         value_ = vars.actionTokenAmount;     } else {         _approve(position.actionToken, vars.topUpHandler);     }     vars.topupResult = ITopUpHandler(vars.topUpHandler).topUp{value: value_}(         account,         position.actionToken,         vars.actionTokenAmount,         position.extra     );      require(vars.topupResult, Error.TOP_UP_FAILED);      // totalTopUpAmount is updated to reflect the new "balance" of the position     if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {         position.totalTopUpAmount -= vars.totalActionTokenAmount.toUint128();     } else {         position.totalTopUpAmount = 0;     }      position.depositTokenBalance -= vars.depositAmountWithFees.toUint128();      vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;     _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);     if (vars.removePosition) {         if (position.depositTokenBalance &gt; 0) {             // transfer any unused locked tokens to the payer             IStakerVault(vault).transfer(payer, position.depositTokenBalance);             IStakerVault(vault).decreaseActionLockedBalance(                 payer,                 position.depositTokenBalance             );         }         _removePosition(payer, account, protocol);     }      emit TopUp(         account,         protocol,         payer,         position.depositToken,         vars.depositAmountWithFees,         position.actionToken,         vars.actionTokenAmount     );      // compute gas used and reimburse the keeper by using the     // funds of payer in the gas bank     // TODO: add constant gas consumed for transfer and tx prologue     vars.gasConsumed = vars.initialGas - gasleft();      vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;     if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {         vars.reimbursedWeiForGas = vars.gasBankBalance;     }      // ensure that the keeper is not overpaying     vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;     require(         vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,         Error.GAS_TOO_HIGH     );     gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);     if (vars.removePosition) {         gasBank.withdrawUnused(payer);     }      return true; }  /**  * @notice Prepare new top up handler fee update.  * @dev Setting the address to 0 means that the protocol will no longer be supported.  * @param protocol Protocol for which a new handler should be prepared.  * @param newHandler Address of new handler.  * @return `true` if success.  */ function prepareTopUpHandler(bytes32 protocol, address newHandler)     public     override     onlyGovernance     returns (bool) {     return _prepare(_getProtocolKey(protocol), newHandler); }  /**  * @notice Check if action can be executed.  * @param protocol for which to get the health factor  * @param account for which to get the health factor  * @param extra data to be used by the topup handler  * @return healthFactor of the position  */ function getHealthFactor(     bytes32 protocol,     bytes32 account,     bytes calldata extra ) public view override returns (uint256 healthFactor) {     ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));     return topUpHandler.getUserFactor(account, extra); }  function getHandler(bytes32 protocol) public view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice returns the current estimated gas usage  */ function getEstimatedGasUsage() public view override returns (uint256) {     return currentUInts256[_ESTIMATED_GAS_USAGE_KEY]; }  /**  * @notice Returns the current action fee  */ function getActionFee() public view override returns (uint256) {     return currentUInts256[_ACTION_FEE_KEY]; }  /**  * @notice Returns the current fee handler  */ function getFeeHandler() public view override returns (address) {     return currentAddresses[_FEE_HANDLER_KEY]; }  /**  * @notice Get the record for a position.  * @param payer Registered payer of the position.  * @param account Address holding the position.  * @param protocol Protocol where the position is held.  */ function getPosition(     address payer,     bytes32 account,     bytes32 protocol ) public view override returns (Record memory) {     return _positions[payer][account][protocol]; }  /**  * @notice Check whether a token is usable as a deposit token.  * @param token Address of token to check.  * @return True if token is usable as a deposit token for this action.  */ function isUsable(address token) public view override returns (bool) {     return _usableTokens.contains(token); }  function _updateTopUpHandler(     bytes32 protocol,     address oldHandler,     address newHandler ) internal {     if (newHandler == address(0)) {         _supportedProtocols.remove(protocol);     } else if (oldHandler == address(0)) {         _supportedProtocols.add(protocol);     } }  /**  * @dev Pays fees to the feeHandler  * @param payer The account who's position the fees are charged on  * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)  * @param feeAmount The amount in tokens to pay as fees  * @param depositToken The LpToken used to pay the fees  */ function _payFees(     address payer,     address beneficiary,     uint256 feeAmount,     address depositToken ) internal {     address feeHandler = getFeeHandler();     IERC20(depositToken).safeApprove(feeHandler, feeAmount);     IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken); }  /**  * @dev "Locks" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function _lockFunds(     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) internal {     address stakerVaultAddress = addressProvider.getStakerVault(token);     TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount); }  function _removePosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     delete _positions[payer][account][protocol];     _removeUserPosition(payer, account, protocol);     if (_userPositions[payer].length == 0) {         _usersWithPositions.remove(payer);     }     emit Deregister(payer, account, protocol); }  function _removeUserPosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     RecordMeta[] storage positionsMeta = _userPositions[payer];     uint256 length = positionsMeta.length;     for (uint256 i; i &lt; length; i = i.uncheckedInc()) {         RecordMeta storage positionMeta = positionsMeta[i];         if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {             positionsMeta[i] = positionsMeta[length - 1];             positionsMeta.pop();             return;         }     } }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) internal {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the `actionToken`.  */ function _calcExchangeAmount(     address token,     address actionToken,     uint256 amount ) internal view returns (uint256) {     return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount); }  function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {     address handler = currentAddresses[_getProtocolKey(protocol)];     require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);     return handler; }  function _isSwappable(address depositToken, address toToken) internal view returns (bool) {     ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);     return pool.getUnderlying() == toToken; }  function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {     return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol)); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '', 'ideas': ' 1'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 12:30:51 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.10; import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol"; import "@openzeppelin/contracts/utils/math/SafeCast.sol"; import "../../../interfaces/IGasBank.sol"; import "../../../interfaces/pool/ILiquidityPool.sol"; import "../../../interfaces/IController.sol"; import "../../../interfaces/IStakerVault.sol"; import "../../../interfaces/actions/topup/ITopUpHandler.sol"; import "../../../interfaces/actions/topup/ITopUpAction.sol"; import "../../../interfaces/actions/IActionFeeHandler.sol"; import "../../../libraries/AddressProviderHelpers.sol"; import "../../../libraries/Errors.sol"; import "../../../libraries/ScaledMath.sol"; import "../../../libraries/EnumerableExtensions.sol"; import "../../../libraries/UncheckedMath.sol"; import "../../access/Authorization.sol"; import "../../utils/Preparable.sol"; /*  * @notice The logic here should really be part of the top-up action  * but is split in a library to circumvent the byte-code size limit  / library TopUpActionLibrary {     using SafeERC20 for IERC20;     using ScaledMath for uint256;     using AddressProviderHelpers for IAddressProvider; /**  * @dev "Locks" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param stakerVaultAddress The address of the staker vault  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function lockFunds(     address stakerVaultAddress,     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) external {     IStakerVault stakerVault = IStakerVault(stakerVaultAddress);      // stake deposit amount     if (depositAmount &gt; 0) {         depositAmount = depositAmount &gt; lockAmount ? lockAmount : depositAmount;         IERC20(token).safeTransferFrom(payer, address(this), depositAmount);         _approve(token, stakerVaultAddress);         stakerVault.stake(depositAmount);         stakerVault.increaseActionLockedBalance(payer, depositAmount);         lockAmount -= depositAmount;     }      // use stake vault allowance if available and required     if (lockAmount &gt; 0) {         uint256 balance = stakerVault.balanceOf(payer);         uint256 allowance = stakerVault.allowance(payer, address(this));         uint256 availableFunds = balance &lt; allowance ? balance : allowance;         if (availableFunds &gt;= lockAmount) {             stakerVault.transferFrom(payer, address(this), lockAmount);             stakerVault.increaseActionLockedBalance(payer, lockAmount);             lockAmount = 0;         }     }      require(lockAmount == 0, Error.INSUFFICIENT_UPDATE_BALANCE); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function calcExchangeAmount(     IAddressProvider addressProvider,     address token,     address actionToken,     uint256 amount ) external view returns (uint256) {     ILiquidityPool pool = addressProvider.getPoolForToken(token);     uint256 rate = pool.exchangeRate();     address underlying = pool.getUnderlying();     require(underlying == actionToken, Error.TOKEN_NOT_USABLE);     return amount.scaledDivRoundUp(rate); }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) private {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  } contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {     using ScaledMath for uint256;     using UncheckedMath for uint256;     using ScaledMath for uint128;     using SafeERC20 for IERC20;     using EnumerableSet for EnumerableSet.AddressSet;     using EnumerableSet for EnumerableSet.Bytes32Set;     using EnumerableExtensions for EnumerableSet.AddressSet;     using AddressProviderHelpers for IAddressProvider;     using SafeCast for uint256; /**  * @dev Temporary struct to hold local variables in execute  * and avoid the stack being "too deep"  */ struct ExecuteLocalVars {     uint256 minActionAmountToTopUp;     uint256 actionTokenAmount;     uint256 depositTotalFeesAmount;     uint256 actionAmountWithFees;     uint256 userFactor;     uint256 rate;     uint256 depositAmountWithFees;     uint256 depositAmountWithoutFees;     uint256 actionFee;     uint256 totalActionTokenAmount;     uint128 totalTopUpAmount;     bool topupResult;     uint256 gasBankBalance;     uint256 initialGas;     uint256 gasConsumed;     uint256 userGasPrice;     uint256 estimatedRequiredGas;     uint256 estimatedRequiredWeiForGas;     uint256 requiredWeiForGas;     uint256 reimbursedWeiForGas;     address underlying;     bool removePosition;     address topUpHandler; }  EnumerableSet.AddressSet private _usableTokens;  uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 550_000;  bytes32 internal constant _ACTION_FEE_KEY = "ActionFee"; bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler"; bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler"; bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";  uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;  IController public immutable controller; IAddressProvider public immutable addressProvider;  EnumerableSet.Bytes32Set internal _supportedProtocols;  /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record) mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;  mapping(address =&gt; RecordMeta[]) internal _userPositions;  EnumerableSet.AddressSet internal _usersWithPositions;  constructor(IController _controller)     Authorization(_controller.addressProvider().getRoleManager()) {     controller = _controller;     addressProvider = controller.addressProvider();     _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE); }  receive() external payable {     // solhint-disable-previous-line no-empty-blocks }  function initialize(     address feeHandler,     bytes32[] calldata protocols,     address[] calldata handlers ) external initializer onlyGovernance {     require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);     _setConfig(_FEE_HANDLER_KEY, feeHandler);     for (uint256 i; i &lt; protocols.length; i = i.uncheckedInc()) {         bytes32 protocolKey = _getProtocolKey(protocols[i]);         _setConfig(protocolKey, handlers[i]);         _updateTopUpHandler(protocols[i], address(0), handlers[i]);     } }  /**  * @notice Register a top up action.  * @dev The `depositAmount`, once converted to units of `actionToken`, must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).  * @param account Account to be topped up (first 20 bytes will typically be the address).  * @param protocol Protocol which holds position to be topped up.  * @param depositAmount Amount of `depositToken` that will be locked.  * @param record containing the data for the position to register  */ function register(     bytes32 account,     bytes32 protocol,     uint128 depositAmount,     Record memory record ) external payable override returns (bool) {     require(record.maxFee != 0, Error.INVALID_MAX_FEE);     require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);     require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);     require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);     require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);     require(         _positions[msg.sender][account][protocol].threshold == 0,         Error.POSITION_ALREADY_EXISTS     );     require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);     require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);      uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *         record.maxFee *         getEstimatedGasUsage();      require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);      uint256 totalLockAmount = _calcExchangeAmount(         record.depositToken,         record.actionToken,         record.totalTopUpAmount     );     _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);      addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);      record.registeredAt = uint64(block.timestamp);     record.depositTokenBalance = totalLockAmount.toUint128();     _positions[msg.sender][account][protocol] = record;     _userPositions[msg.sender].push(RecordMeta(account, protocol));     _usersWithPositions.add(msg.sender);      emit Register(         account,         protocol,         record.threshold,         msg.sender,         record.depositToken,         totalLockAmount,         record.actionToken,         record.singleTopUpAmount,         record.totalTopUpAmount,         record.maxFee,         record.extra     );     return true; }  /**  * @notice See overloaded version of `execute` for more details.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol ) external override returns (bool) {     return execute(payer, account, beneficiary, protocol, 0); }  /**  * @notice Delete a position to back on the given protocol for `account`.  * @param account Account holding the position.  * @param protocol Protocol the position is held on.  * @param unstake If the tokens should be unstaked from vault.  * @return `true` if successful.  */ function resetPosition(     bytes32 account,     bytes32 protocol,     bool unstake ) external override returns (bool) {     address payer = msg.sender;     Record memory position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);      IAddressProvider addressProvider_ = addressProvider;     address vault = addressProvider_.getStakerVault(position.depositToken); // will revert if vault does not exist     IStakerVault staker = IStakerVault(vault);     staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);     if (unstake) {         staker.unstake(position.depositTokenBalance);         IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);     } else {         staker.transfer(payer, position.depositTokenBalance);     }      _removePosition(payer, account, protocol);     addressProvider_.getGasBank().withdrawUnused(payer);     return true; }  /**  * @notice Execute top up handler update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @param protocol Protocol for which a new handler should be executed.  * @return Address of new handler.  */ function executeTopUpHandler(bytes32 protocol) external override returns (address) {     address oldHandler = _getHandler(protocol, false);     address newHandler = _executeAddress(_getProtocolKey(protocol));      _updateTopUpHandler(protocol, oldHandler, newHandler);     return newHandler; }  /**  * @notice Reset new top up handler deadline for a protocol.  * @param protocol Protocol for which top up handler deadline should be reset.  * @return `true` if successful.  */ function resetTopUpHandler(bytes32 protocol) external override onlyGovernance returns (bool) {     return _resetAddressConfig(_getProtocolKey(protocol)); }  /**  * @notice Prepare action fee update.  * @param newActionFee New fee to set.  * @return `true` if success.  */ function prepareActionFee(uint256 newActionFee)     external     override     onlyGovernance     returns (bool) {     require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);     return _prepare(_ACTION_FEE_KEY, newActionFee); }  /**  * @notice Execute action fee update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeActionFee() external override returns (uint256) {     return _executeUInt256(_ACTION_FEE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetActionFee() external override onlyGovernance returns (bool) {     return _resetUInt256Config(_ACTION_FEE_KEY); }  /** Set fee handler */ /**  * @notice Prepare update of fee handler.  * @param handler New fee handler.  * @return `true` if success.  */ function prepareFeeHandler(address handler) external override onlyGovernance returns (bool) {     return _prepare(_FEE_HANDLER_KEY, handler); }  /**  * @notice Execute update of fee handler (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeFeeHandler() external override returns (address) {     return _executeAddress(_FEE_HANDLER_KEY); }  /**  * @notice Reset the handler deadline.  * @return `true` if success.  */ function resetFeeHandler() external override onlyGovernance returns (bool) {     return _resetAddressConfig(_FEE_HANDLER_KEY); }  /**  * @notice Prepare update of estimated gas usage.  * @param gasUsage New estimated gas usage.  * @return `true` if success.  */ function prepareEstimatedGasUsage(uint256 gasUsage)     external     override     onlyGovernance     returns (bool) {     return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage); }  /**  * @notice Execute update of gas usage (with time delay enforced).  * @return `true` if successful.  */ function executeEstimatedGasUsage() external override returns (uint256) {     return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Reset the gas usage deadline.  * @return `true` if success.  */ function resetGasUsage() external override onlyGovernance returns (bool) {     return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Add a new deposit token that is supported by the action.  * @dev There is a separate check for whether the usable token (i.e. deposit token)  *      is swappable for some action token.  * @param token Address of deposit token that can be used by the action.  */ function addUsableToken(address token) external override onlyGovernance returns (bool) {     return _usableTokens.add(token); }  /**  * @notice Computes the total amount of ETH (as wei) required to pay for all  * the top-ups assuming the maximum gas price and the current estimated gas  * usage of a top-up  */ function getEthRequiredForGas(address payer) external view override returns (uint256) {     uint256 totalEthRequired;     RecordMeta[] memory userRecordsMeta = _userPositions[payer];     uint256 gasUsagePerCall = getEstimatedGasUsage();     uint256 length = userRecordsMeta.length;     for (uint256 i; i &lt; length; i = i.uncheckedInc()) {         RecordMeta memory meta = userRecordsMeta[i];         Record memory record = _positions[payer][meta.account][meta.protocol];         uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);         totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;     }     return totalEthRequired; }  /**  * @notice Returns a list of positions for the given payer  */ function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {     return _userPositions[payer]; }  /**  * @notice Get a list supported protocols.  * @return List of supported protocols.  */ function getSupportedProtocols() external view override returns (bytes32[] memory) {     uint256 length = _supportedProtocols.length();     bytes32[] memory protocols = new bytes32[](length);     for (uint256 i; i &lt; length; i = i.uncheckedInc()) {         protocols[i] = _supportedProtocols.at(i);     }     return protocols; }  /*  * @notice Gets a list of users that have an active position.  * @dev Uses cursor pagination.  * @param cursor The cursor for pagination (should start at 0 for first call).  * @param howMany Maximum number of users to return in this pagination request.  * @return users List of users that have an active position.  * @return nextCursor The cursor to use for the next pagination request.  */ function usersWithPositions(uint256 cursor, uint256 howMany)     external     view     override     returns (address[] memory users, uint256 nextCursor) {     uint256 length = _usersWithPositions.length();     if (cursor &gt;= length) return (new address[](0), 0);     if (howMany &gt;= length - cursor) {         howMany = length - cursor;     }      address[] memory usersWithPositions_ = new address[](howMany);     for (uint256 i; i &lt; howMany; i = i.uncheckedInc()) {         usersWithPositions_[i] = _usersWithPositions.at(i + cursor);     }      return (usersWithPositions_, cursor + howMany); }  /**  * @notice Get a list of all tokens usable for this action.  * @dev This refers to all tokens that can be used as deposit tokens.  * @return Array of addresses of usable tokens.  */ function getUsableTokens() external view override returns (address[] memory) {     return _usableTokens.toArray(); }  /**  * @notice Retrieves the topup handler for the given `protocol`  */ function getTopUpHandler(bytes32 protocol) external view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice Successfully tops up a position if it's conditions are met.  * @dev pool and vault funds are rebalanced after withdrawal for top up  * @param payer Account that pays for the top up.  * @param account Account owning the position for top up.  * @param beneficiary Address of the keeper's wallet for fee accrual.  * @param protocol Protocol of the top up position.  * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas  * @return `true` if successful.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol,     uint256 maxWeiForGas ) public override returns (bool) {     require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);      ExecuteLocalVars memory vars;      vars.initialGas = gasleft();      Record storage position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);     require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);     require(block.timestamp &gt; position.registeredAt, Error.CANNOT_EXECUTE_IN_SAME_BLOCK);      vars.topUpHandler = _getHandler(protocol, true);     vars.userFactor = ITopUpHandler(vars.topUpHandler).getUserFactor(account, position.extra);      // ensure that the position is actually below its set user factor threshold     require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);      IAddressProvider addressProvider_ = addressProvider;     IGasBank gasBank = addressProvider_.getGasBank();      // fail early if the user does not have enough funds in the gas bank     // to cover the cost of the transaction     vars.estimatedRequiredGas = getEstimatedGasUsage();     vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;      // compute the gas price that the user will be paying     vars.userGasPrice = block.basefee + position.priorityFee;     if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;     if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;      // ensure the current position allows for the gas to be paid     require(         vars.estimatedRequiredWeiForGas &lt;=             vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,         Error.ESTIMATED_GAS_TOO_HIGH     );      vars.gasBankBalance = gasBank.balanceOf(payer);     // ensure the user has enough funds in the gas bank to cover the gas     require(         vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,         Error.GAS_BANK_BALANCE_TOO_LOW     );      vars.totalTopUpAmount = position.totalTopUpAmount;     vars.actionFee = getActionFee();     // add top-up fees to top-up amount     vars.minActionAmountToTopUp = position.singleTopUpAmount;     vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(         ScaledMath.ONE + vars.actionFee     );      // if the amount that we want to top-up (including fees) is higher than     // the available topup amount, we lower this down to what is left of the position     if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {         vars.actionAmountWithFees = vars.totalTopUpAmount;         vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(             ScaledMath.ONE + vars.actionFee         );     }     ILiquidityPool pool = addressProvider_.getPoolForToken(position.depositToken);     vars.underlying = pool.getUnderlying();     vars.rate = pool.exchangeRate();      // compute the deposit tokens amount with and without fees     // we will need to unstake the amount with fees and to     // swap the amount without fees into action tokens     vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);     if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {         vars.depositAmountWithFees = position.depositTokenBalance;         vars.minActionAmountToTopUp =             (vars.depositAmountWithFees * vars.rate) /             (ScaledMath.ONE + vars.actionFee);     }      // compute amount of LP tokens needed to pay for action     // rate is expressed in actionToken per depositToken     vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);     vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;      // will revert if vault does not exist     address vault = addressProvider_.getStakerVault(position.depositToken);      // unstake deposit tokens including fees     IStakerVault(vault).unstake(vars.depositAmountWithFees);     IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);      // swap the amount without the fees     // as the fees are paid in deposit token, not in action token     vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);      // compute how much of action token was actually redeemed and add fees to it     // this is to ensure that no funds get locked inside the contract     vars.totalActionTokenAmount =         vars.actionTokenAmount +         vars.depositTotalFeesAmount.scaledMul(vars.rate);      // at this point, we have exactly `vars.actionTokenAmount`     // (at least `position.singleTopUpAmount`) of action token     // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract     // solhint-disable-next-line avoid-low-level-calls     uint256 value_;     if (position.actionToken == address(0)) {         value_ = vars.actionTokenAmount;     } else {         _approve(position.actionToken, vars.topUpHandler);     }     vars.topupResult = ITopUpHandler(vars.topUpHandler).topUp{value: value_}(         account,         position.actionToken,         vars.actionTokenAmount,         position.extra     );      require(vars.topupResult, Error.TOP_UP_FAILED);      // totalTopUpAmount is updated to reflect the new "balance" of the position     if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {         position.totalTopUpAmount -= vars.totalActionTokenAmount.toUint128();     } else {         position.totalTopUpAmount = 0;     }      position.depositTokenBalance -= vars.depositAmountWithFees.toUint128();      vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;     _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);     if (vars.removePosition) {         if (position.depositTokenBalance &gt; 0) {             // transfer any unused locked tokens to the payer             IStakerVault(vault).transfer(payer, position.depositTokenBalance);             IStakerVault(vault).decreaseActionLockedBalance(                 payer,                 position.depositTokenBalance             );         }         _removePosition(payer, account, protocol);     }      emit TopUp(         account,         protocol,         payer,         position.depositToken,         vars.depositAmountWithFees,         position.actionToken,         vars.actionTokenAmount     );      // compute gas used and reimburse the keeper by using the     // funds of payer in the gas bank     // TODO: add constant gas consumed for transfer and tx prologue     vars.gasConsumed = vars.initialGas - gasleft();      vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;     if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {         vars.reimbursedWeiForGas = vars.gasBankBalance;     }      // ensure that the keeper is not overpaying     vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;     require(         vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,         Error.GAS_TOO_HIGH     );     gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);     if (vars.removePosition) {         gasBank.withdrawUnused(payer);     }      return true; }  /**  * @notice Prepare new top up handler fee update.  * @dev Setting the address to 0 means that the protocol will no longer be supported.  * @param protocol Protocol for which a new handler should be prepared.  * @param newHandler Address of new handler.  * @return `true` if success.  */ function prepareTopUpHandler(bytes32 protocol, address newHandler)     public     override     onlyGovernance     returns (bool) {     return _prepare(_getProtocolKey(protocol), newHandler); }  /**  * @notice Check if action can be executed.  * @param protocol for which to get the health factor  * @param account for which to get the health factor  * @param extra data to be used by the topup handler  * @return healthFactor of the position  */ function getHealthFactor(     bytes32 protocol,     bytes32 account,     bytes calldata extra ) public view override returns (uint256 healthFactor) {     ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));     return topUpHandler.getUserFactor(account, extra); }  function getHandler(bytes32 protocol) public view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice returns the current estimated gas usage  */ function getEstimatedGasUsage() public view override returns (uint256) {     return currentUInts256[_ESTIMATED_GAS_USAGE_KEY]; }  /**  * @notice Returns the current action fee  */ function getActionFee() public view override returns (uint256) {     return currentUInts256[_ACTION_FEE_KEY]; }  /**  * @notice Returns the current fee handler  */ function getFeeHandler() public view override returns (address) {     return currentAddresses[_FEE_HANDLER_KEY]; }  /**  * @notice Get the record for a position.  * @param payer Registered payer of the position.  * @param account Address holding the position.  * @param protocol Protocol where the position is held.  */ function getPosition(     address payer,     bytes32 account,     bytes32 protocol ) public view override returns (Record memory) {     return _positions[payer][account][protocol]; }  /**  * @notice Check whether a token is usable as a deposit token.  * @param token Address of token to check.  * @return True if token is usable as a deposit token for this action.  */ function isUsable(address token) public view override returns (bool) {     return _usableTokens.contains(token); }  function _updateTopUpHandler(     bytes32 protocol,     address oldHandler,     address newHandler ) internal {     if (newHandler == address(0)) {         _supportedProtocols.remove(protocol);     } else if (oldHandler == address(0)) {         _supportedProtocols.add(protocol);     } }  /**  * @dev Pays fees to the feeHandler  * @param payer The account who's position the fees are charged on  * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)  * @param feeAmount The amount in tokens to pay as fees  * @param depositToken The LpToken used to pay the fees  */ function _payFees(     address payer,     address beneficiary,     uint256 feeAmount,     address depositToken ) internal {     address feeHandler = getFeeHandler();     IERC20(depositToken).safeApprove(feeHandler, feeAmount);     IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken); }  /**  * @dev "Locks" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function _lockFunds(     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) internal {     address stakerVaultAddress = addressProvider.getStakerVault(token);     TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount); }  function _removePosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     delete _positions[payer][account][protocol];     _removeUserPosition(payer, account, protocol);     if (_userPositions[payer].length == 0) {         _usersWithPositions.remove(payer);     }     emit Deregister(payer, account, protocol); }  function _removeUserPosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     RecordMeta[] storage positionsMeta = _userPositions[payer];     uint256 length = positionsMeta.length;     for (uint256 i; i &lt; length; i = i.uncheckedInc()) {         RecordMeta storage positionMeta = positionsMeta[i];         if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {             positionsMeta[i] = positionsMeta[length - 1];             positionsMeta.pop();             return;         }     } }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) internal {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the `actionToken`.  */ function _calcExchangeAmount(     address token,     address actionToken,     uint256 amount ) internal view returns (uint256) {     return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount); }  function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {     address handler = currentAddresses[_getProtocolKey(protocol)];     require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);     return handler; }  function _isSwappable(address depositToken, address toToken) internal view returns (bool) {     ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);     return pool.getUnderlying() == toToken; }  function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {     return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol)); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 12:30:51 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.10;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";
import "@openzeppelin/contracts/utils/math/SafeCast.sol";

import "../../../interfaces/IGasBank.sol";
import "../../../interfaces/pool/ILiquidityPool.sol";
import "../../../interfaces/IController.sol";
import "../../../interfaces/IStakerVault.sol";
import "../../../interfaces/actions/topup/ITopUpHandler.sol";
import "../../../interfaces/actions/topup/ITopUpAction.sol";
import "../../../interfaces/actions/IActionFeeHandler.sol";

import "../../../libraries/AddressProviderHelpers.sol";
import "../../../libraries/Errors.sol";
import "../../../libraries/ScaledMath.sol";
import "../../../libraries/EnumerableExtensions.sol";
import "../../../libraries/UncheckedMath.sol";

import "../../access/Authorization.sol";
import "../../utils/Preparable.sol";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param stakerVaultAddress The address of the staker vault
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > lockAmount ? lockAmount : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            _approve(token, stakerVaultAddress);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            lockAmount -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (lockAmount > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= lockAmount) {
                stakerVault.transferFrom(payer, address(this), lockAmount);
                stakerVault.increaseActionLockedBalance(payer, lockAmount);
                lockAmount = 0;
            }
        }

        require(lockAmount == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        require(underlying == actionToken, Error.TOKEN_NOT_USABLE);
        return amount.scaledDivRoundUp(rate);
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) private {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using UncheckedMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;
    using SafeCast for uint256;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being "too deep"
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
        address topUpHandler;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 550_000;

    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";
    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        for (uint256 i; i < protocols.length; i = i.uncheckedInc()) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount`, once converted to units of `actionToken`, must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param protocol Protocol which holds position to be topped up.
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable override returns (bool) {
        require(record.maxFee != 0, Error.INVALID_MAX_FEE);
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.registeredAt = uint64(block.timestamp);
        record.depositTokenBalance = totalLockAmount.toUint128();
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        IAddressProvider addressProvider_ = addressProvider;
        address vault = addressProvider_.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider_.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external override onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee)
        external
        override
        onlyGovernance
        returns (bool)
    {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external override onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external override onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external override onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage)
        external
        override
        onlyGovernance
        returns (bool)
    {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external override returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external override onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i; i < howMany; i = i.uncheckedInc()) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);
        require(block.timestamp > position.registeredAt, Error.CANNOT_EXECUTE_IN_SAME_BLOCK);

        vars.topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(vars.topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IAddressProvider addressProvider_ = addressProvider;
        IGasBank gasBank = addressProvider_.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider_.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider_.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        uint256 value_;
        if (position.actionToken == address(0)) {
            value_ = vars.actionTokenAmount;
        } else {
            _approve(position.actionToken, vars.topUpHandler);
        }
        vars.topupResult = ITopUpHandler(vars.topUpHandler).topUp{value: value_}(
            account,
            position.actionToken,
            vars.actionTokenAmount,
            position.extra
        );

        require(vars.topupResult, Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new "balance" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= vars.totalActionTokenAmount.toUint128();
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= vars.depositAmountWithFees.toUint128();

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the address to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        override
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes calldata extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view override returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the `actionToken`.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        return pool.getUnderlying() == toToken;
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-01-09 12:30:57 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 12:30:57 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 7711
completion_tokens: 701
total_tokens: 8412
cost: $-1.000000


[2024-01-09 12:30:57 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.10;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";
import "@openzeppelin/contracts/utils/math/SafeCast.sol";

import "../../../interfaces/IGasBank.sol";
import "../../../interfaces/pool/ILiquidityPool.sol";
import "../../../interfaces/IController.sol";
import "../../../interfaces/IStakerVault.sol";
import "../../../interfaces/actions/topup/ITopUpHandler.sol";
import "../../../interfaces/actions/topup/ITopUpAction.sol";
import "../../../interfaces/actions/IActionFeeHandler.sol";

import "../../../libraries/AddressProviderHelpers.sol";
import "../../../libraries/Errors.sol";
import "../../../libraries/ScaledMath.sol";
import "../../../libraries/EnumerableExtensions.sol";
import "../../../libraries/UncheckedMath.sol";

import "../../access/Authorization.sol";
import "../../utils/Preparable.sol";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param stakerVaultAddress The address of the staker vault
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > lockAmount ? lockAmount : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            _approve(token, stakerVaultAddress);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            lockAmount -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (lockAmount > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= lockAmount) {
                stakerVault.transferFrom(payer, address(this), lockAmount);
                stakerVault.increaseActionLockedBalance(payer, lockAmount);
                lockAmount = 0;
            }
        }

        require(lockAmount == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        require(underlying == actionToken, Error.TOKEN_NOT_USABLE);
        return amount.scaledDivRoundUp(rate);
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) private {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using UncheckedMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;
    using SafeCast for uint256;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being "too deep"
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
        address topUpHandler;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 550_000;

    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";
    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        for (uint256 i; i < protocols.length; i = i.uncheckedInc()) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount`, once converted to units of `actionToken`, must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param protocol Protocol which holds position to be topped up.
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable override returns (bool) {
        require(record.maxFee != 0, Error.INVALID_MAX_FEE);
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.registeredAt = uint64(block.timestamp);
        record.depositTokenBalance = totalLockAmount.toUint128();
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        IAddressProvider addressProvider_ = addressProvider;
        address vault = addressProvider_.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider_.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external override onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee)
        external
        override
        onlyGovernance
        returns (bool)
    {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external override onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external override onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external override onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage)
        external
        override
        onlyGovernance
        returns (bool)
    {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external override returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external override onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i; i < howMany; i = i.uncheckedInc()) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);
        require(block.timestamp > position.registeredAt, Error.CANNOT_EXECUTE_IN_SAME_BLOCK);

        vars.topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(vars.topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IAddressProvider addressProvider_ = addressProvider;
        IGasBank gasBank = addressProvider_.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider_.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider_.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        uint256 value_;
        if (position.actionToken == address(0)) {
            value_ = vars.actionTokenAmount;
        } else {
            _approve(position.actionToken, vars.topUpHandler);
        }
        vars.topupResult = ITopUpHandler(vars.topUpHandler).topUp{value: value_}(
            account,
            position.actionToken,
            vars.actionTokenAmount,
            position.extra
        );

        require(vars.topupResult, Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new "balance" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= vars.totalActionTokenAmount.toUint128();
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= vars.depositAmountWithFees.toUint128();

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the address to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        override
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes calldata extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view override returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the `actionToken`.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        return pool.getUnderlying() == toToken;
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
.]

### Summary of Security Vulnerabilities in the Smart Contract

1. **Reentrancy Vulnerability**: 
   - The contract does not implement a reentrancy guard, which could allow an attacker to exploit functions that transfer funds, such as `execute`, leading to potential fund theft.

2. **Insufficient Input Validation**:
   - The contract relies on external calls (e.g., to the `TopUpHandler`) without adequate checks on the return values. If these calls fail, the contract may enter an inconsistent state.

3. **Gas Limit and Loops**:
   - The `execute` function contains loops that could lead to excessive gas consumption. If the number of user positions grows large, it may exceed the block gas limit, causing transactions to fail.

4. **Arithmetic Issues**:
   - While the contract uses SafeMath and similar libraries, there are still areas where arithmetic operations could lead to underflows or overflows if not properly handled, especially in calculations involving user balances and fees.

5. **Access Control Issues**:
   - The contract uses the `onlyGovernance` modifier for critical functions, but there may be scenarios where governance can be compromised, allowing unauthorized access to sensitive functions.

6. **Token Approval Issues**:
   - The `_approve` function does not handle the case where the allowance is already set to the maximum value. This could lead to potential issues if the token contract has a non-standard implementation.

7. **Lack of Event Emission**:
   - Certain state-changing functions do not emit events, which could hinder tracking and auditing of contract activity.

8. **Potential for Denial of Service (DoS)**:
   - The contract could be vulnerable to DoS attacks if an external contract (like a fee handler) fails or behaves unexpectedly, preventing legitimate operations from completing.

9. **Fallback Function**:
   - The fallback function is empty, which could lead to unexpected behavior if Ether is sent to the contract without a specific function call.

### Comprehensive Analysis Report

The provided smart contract exhibits several security vulnerabilities that could potentially be exploited by malicious actors. The absence of a reentrancy guard is particularly concerning, as it opens the door for reentrancy attacks during fund transfers. Additionally, insufficient input validation and reliance on external calls without proper checks can lead to inconsistent states and unexpected behavior.

The contract's design also raises concerns regarding gas consumption, especially in functions that involve loops, which could lead to transaction failures if the gas limit is exceeded. While the use of SafeMath mitigates some arithmetic risks, there are still areas where underflows or overflows could occur.

Access control mechanisms, while present, may not be robust enough to prevent unauthorized access, particularly if governance is compromised. Furthermore, the `_approve` function's handling of token allowances could lead to issues with non-standard token contracts.

The lack of event emissions for certain state changes complicates tracking and auditing, making it difficult to monitor contract activity effectively. Additionally, the potential for DoS attacks due to reliance on external contracts poses a significant risk to the contract's operability.

In conclusion, it is imperative to address these vulnerabilities through rigorous testing, code reviews, and the implementation of best practices in smart contract development. This includes adding reentrancy guards, improving input validation, ensuring proper event emissions, and enhancing access control measures to safeguard against unauthorized actions. Regular audits and updates to the contract will also be essential in maintaining its security and integrity over time.

[2024-01-09 12:30:57 INFO] **[Seminar Conclusion]**:

 ### Summary of Security Vulnerabilities in the Smart Contract

1. **Reentrancy Vulnerability**: 
   - The contract does not implement a reentrancy guard, which could allow an attacker to exploit functions that transfer funds, such as `execute`, leading to potential fund theft.

2. **Insufficient Input Validation**:
   - The contract relies on external calls (e.g., to the `TopUpHandler`) without adequate checks on the return values. If these calls fail, the contract may enter an inconsistent state.

3. **Gas Limit and Loops**:
   - The `execute` function contains loops that could lead to excessive gas consumption. If the number of user positions grows large, it may exceed the block gas limit, causing transactions to fail.

4. **Arithmetic Issues**:
   - While the contract uses SafeMath and similar libraries, there are still areas where arithmetic operations could lead to underflows or overflows if not properly handled, especially in calculations involving user balances and fees.

5. **Access Control Issues**:
   - The contract uses the `onlyGovernance` modifier for critical functions, but there may be scenarios where governance can be compromised, allowing unauthorized access to sensitive functions.

6. **Token Approval Issues**:
   - The `_approve` function does not handle the case where the allowance is already set to the maximum value. This could lead to potential issues if the token contract has a non-standard implementation.

7. **Lack of Event Emission**:
   - Certain state-changing functions do not emit events, which could hinder tracking and auditing of contract activity.

8. **Potential for Denial of Service (DoS)**:
   - The contract could be vulnerable to DoS attacks if an external contract (like a fee handler) fails or behaves unexpectedly, preventing legitimate operations from completing.

9. **Fallback Function**:
   - The fallback function is empty, which could lead to unexpected behavior if Ether is sent to the contract without a specific function call.

### Comprehensive Analysis Report

The provided smart contract exhibits several security vulnerabilities that could potentially be exploited by malicious actors. The absence of a reentrancy guard is particularly concerning, as it opens the door for reentrancy attacks during fund transfers. Additionally, insufficient input validation and reliance on external calls without proper checks can lead to inconsistent states and unexpected behavior.

The contract's design also raises concerns regarding gas consumption, especially in functions that involve loops, which could lead to transaction failures if the gas limit is exceeded. While the use of SafeMath mitigates some arithmetic risks, there are still areas where underflows or overflows could occur.

Access control mechanisms, while present, may not be robust enough to prevent unauthorized access, particularly if governance is compromised. Furthermore, the `_approve` function's handling of token allowances could lead to issues with non-standard token contracts.

The lack of event emissions for certain state changes complicates tracking and auditing, making it difficult to monitor contract activity effectively. Additionally, the potential for DoS attacks due to reliance on external contracts poses a significant risk to the contract's operability.

In conclusion, it is imperative to address these vulnerabilities through rigorous testing, code reviews, and the implementation of best practices in smart contract development. This includes adding reentrancy guards, improving input validation, ensuring proper event emissions, and enhancing access control measures to safeguard against unauthorized actions. Regular audits and updates to the contract will also be essential in maintaining its security and integrity over time.

[2024-01-09 12:30:57 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 3

[2024-01-09 12:30:57 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.10; import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol"; import "@openzeppelin/contracts/utils/math/SafeCast.sol"; import "../../../interfaces/IGasBank.sol"; import "../../../interfaces/pool/ILiquidityPool.sol"; import "../../../interfaces/IController.sol"; import "../../../interfaces/IStakerVault.sol"; import "../../../interfaces/actions/topup/ITopUpHandler.sol"; import "../../../interfaces/actions/topup/ITopUpAction.sol"; import "../../../interfaces/actions/IActionFeeHandler.sol"; import "../../../libraries/AddressProviderHelpers.sol"; import "../../../libraries/Errors.sol"; import "../../../libraries/ScaledMath.sol"; import "../../../libraries/EnumerableExtensions.sol"; import "../../../libraries/UncheckedMath.sol"; import "../../access/Authorization.sol"; import "../../utils/Preparable.sol"; /*  * @notice The logic here should really be part of the top-up action  * but is split in a library to circumvent the byte-code size limit  / library TopUpActionLibrary {     using SafeERC20 for IERC20;     using ScaledMath for uint256;     using AddressProviderHelpers for IAddressProvider; /**  * @dev "Locks" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param stakerVaultAddress The address of the staker vault  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function lockFunds(     address stakerVaultAddress,     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) external {     IStakerVault stakerVault = IStakerVault(stakerVaultAddress);      // stake deposit amount     if (depositAmount &gt; 0) {         depositAmount = depositAmount &gt; lockAmount ? lockAmount : depositAmount;         IERC20(token).safeTransferFrom(payer, address(this), depositAmount);         _approve(token, stakerVaultAddress);         stakerVault.stake(depositAmount);         stakerVault.increaseActionLockedBalance(payer, depositAmount);         lockAmount -= depositAmount;     }      // use stake vault allowance if available and required     if (lockAmount &gt; 0) {         uint256 balance = stakerVault.balanceOf(payer);         uint256 allowance = stakerVault.allowance(payer, address(this));         uint256 availableFunds = balance &lt; allowance ? balance : allowance;         if (availableFunds &gt;= lockAmount) {             stakerVault.transferFrom(payer, address(this), lockAmount);             stakerVault.increaseActionLockedBalance(payer, lockAmount);             lockAmount = 0;         }     }      require(lockAmount == 0, Error.INSUFFICIENT_UPDATE_BALANCE); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function calcExchangeAmount(     IAddressProvider addressProvider,     address token,     address actionToken,     uint256 amount ) external view returns (uint256) {     ILiquidityPool pool = addressProvider.getPoolForToken(token);     uint256 rate = pool.exchangeRate();     address underlying = pool.getUnderlying();     require(underlying == actionToken, Error.TOKEN_NOT_USABLE);     return amount.scaledDivRoundUp(rate); }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) private {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  } contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {     using ScaledMath for uint256;     using UncheckedMath for uint256;     using ScaledMath for uint128;     using SafeERC20 for IERC20;     using EnumerableSet for EnumerableSet.AddressSet;     using EnumerableSet for EnumerableSet.Bytes32Set;     using EnumerableExtensions for EnumerableSet.AddressSet;     using AddressProviderHelpers for IAddressProvider;     using SafeCast for uint256; /**  * @dev Temporary struct to hold local variables in execute  * and avoid the stack being "too deep"  */ struct ExecuteLocalVars {     uint256 minActionAmountToTopUp;     uint256 actionTokenAmount;     uint256 depositTotalFeesAmount;     uint256 actionAmountWithFees;     uint256 userFactor;     uint256 rate;     uint256 depositAmountWithFees;     uint256 depositAmountWithoutFees;     uint256 actionFee;     uint256 totalActionTokenAmount;     uint128 totalTopUpAmount;     bool topupResult;     uint256 gasBankBalance;     uint256 initialGas;     uint256 gasConsumed;     uint256 userGasPrice;     uint256 estimatedRequiredGas;     uint256 estimatedRequiredWeiForGas;     uint256 requiredWeiForGas;     uint256 reimbursedWeiForGas;     address underlying;     bool removePosition;     address topUpHandler; }  EnumerableSet.AddressSet private _usableTokens;  uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 550_000;  bytes32 internal constant _ACTION_FEE_KEY = "ActionFee"; bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler"; bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler"; bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";  uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;  IController public immutable controller; IAddressProvider public immutable addressProvider;  EnumerableSet.Bytes32Set internal _supportedProtocols;  /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record) mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;  mapping(address =&gt; RecordMeta[]) internal _userPositions;  EnumerableSet.AddressSet internal _usersWithPositions;  constructor(IController _controller)     Authorization(_controller.addressProvider().getRoleManager()) {     controller = _controller;     addressProvider = controller.addressProvider();     _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE); }  receive() external payable {     // solhint-disable-previous-line no-empty-blocks }  function initialize(     address feeHandler,     bytes32[] calldata protocols,     address[] calldata handlers ) external initializer onlyGovernance {     require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);     _setConfig(_FEE_HANDLER_KEY, feeHandler);     for (uint256 i; i &lt; protocols.length; i = i.uncheckedInc()) {         bytes32 protocolKey = _getProtocolKey(protocols[i]);         _setConfig(protocolKey, handlers[i]);         _updateTopUpHandler(protocols[i], address(0), handlers[i]);     } }  /**  * @notice Register a top up action.  * @dev The `depositAmount`, once converted to units of `actionToken`, must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).  * @param account Account to be topped up (first 20 bytes will typically be the address).  * @param protocol Protocol which holds position to be topped up.  * @param depositAmount Amount of `depositToken` that will be locked.  * @param record containing the data for the position to register  */ function register(     bytes32 account,     bytes32 protocol,     uint128 depositAmount,     Record memory record ) external payable override returns (bool) {     require(record.maxFee != 0, Error.INVALID_MAX_FEE);     require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);     require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);     require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);     require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);     require(         _positions[msg.sender][account][protocol].threshold == 0,         Error.POSITION_ALREADY_EXISTS     );     require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);     require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);      uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *         record.maxFee *         getEstimatedGasUsage();      require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);      uint256 totalLockAmount = _calcExchangeAmount(         record.depositToken,         record.actionToken,         record.totalTopUpAmount     );     _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);      addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);      record.registeredAt = uint64(block.timestamp);     record.depositTokenBalance = totalLockAmount.toUint128();     _positions[msg.sender][account][protocol] = record;     _userPositions[msg.sender].push(RecordMeta(account, protocol));     _usersWithPositions.add(msg.sender);      emit Register(         account,         protocol,         record.threshold,         msg.sender,         record.depositToken,         totalLockAmount,         record.actionToken,         record.singleTopUpAmount,         record.totalTopUpAmount,         record.maxFee,         record.extra     );     return true; }  /**  * @notice See overloaded version of `execute` for more details.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol ) external override returns (bool) {     return execute(payer, account, beneficiary, protocol, 0); }  /**  * @notice Delete a position to back on the given protocol for `account`.  * @param account Account holding the position.  * @param protocol Protocol the position is held on.  * @param unstake If the tokens should be unstaked from vault.  * @return `true` if successful.  */ function resetPosition(     bytes32 account,     bytes32 protocol,     bool unstake ) external override returns (bool) {     address payer = msg.sender;     Record memory position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);      IAddressProvider addressProvider_ = addressProvider;     address vault = addressProvider_.getStakerVault(position.depositToken); // will revert if vault does not exist     IStakerVault staker = IStakerVault(vault);     staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);     if (unstake) {         staker.unstake(position.depositTokenBalance);         IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);     } else {         staker.transfer(payer, position.depositTokenBalance);     }      _removePosition(payer, account, protocol);     addressProvider_.getGasBank().withdrawUnused(payer);     return true; }  /**  * @notice Execute top up handler update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @param protocol Protocol for which a new handler should be executed.  * @return Address of new handler.  */ function executeTopUpHandler(bytes32 protocol) external override returns (address) {     address oldHandler = _getHandler(protocol, false);     address newHandler = _executeAddress(_getProtocolKey(protocol));      _updateTopUpHandler(protocol, oldHandler, newHandler);     return newHandler; }  /**  * @notice Reset new top up handler deadline for a protocol.  * @param protocol Protocol for which top up handler deadline should be reset.  * @return `true` if successful.  */ function resetTopUpHandler(bytes32 protocol) external override onlyGovernance returns (bool) {     return _resetAddressConfig(_getProtocolKey(protocol)); }  /**  * @notice Prepare action fee update.  * @param newActionFee New fee to set.  * @return `true` if success.  */ function prepareActionFee(uint256 newActionFee)     external     override     onlyGovernance     returns (bool) {     require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);     return _prepare(_ACTION_FEE_KEY, newActionFee); }  /**  * @notice Execute action fee update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeActionFee() external override returns (uint256) {     return _executeUInt256(_ACTION_FEE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetActionFee() external override onlyGovernance returns (bool) {     return _resetUInt256Config(_ACTION_FEE_KEY); }  /** Set fee handler */ /**  * @notice Prepare update of fee handler.  * @param handler New fee handler.  * @return `true` if success.  */ function prepareFeeHandler(address handler) external override onlyGovernance returns (bool) {     return _prepare(_FEE_HANDLER_KEY, handler); }  /**  * @notice Execute update of fee handler (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeFeeHandler() external override returns (address) {     return _executeAddress(_FEE_HANDLER_KEY); }  /**  * @notice Reset the handler deadline.  * @return `true` if success.  */ function resetFeeHandler() external override onlyGovernance returns (bool) {     return _resetAddressConfig(_FEE_HANDLER_KEY); }  /**  * @notice Prepare update of estimated gas usage.  * @param gasUsage New estimated gas usage.  * @return `true` if success.  */ function prepareEstimatedGasUsage(uint256 gasUsage)     external     override     onlyGovernance     returns (bool) {     return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage); }  /**  * @notice Execute update of gas usage (with time delay enforced).  * @return `true` if successful.  */ function executeEstimatedGasUsage() external override returns (uint256) {     return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Reset the gas usage deadline.  * @return `true` if success.  */ function resetGasUsage() external override onlyGovernance returns (bool) {     return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Add a new deposit token that is supported by the action.  * @dev There is a separate check for whether the usable token (i.e. deposit token)  *      is swappable for some action token.  * @param token Address of deposit token that can be used by the action.  */ function addUsableToken(address token) external override onlyGovernance returns (bool) {     return _usableTokens.add(token); }  /**  * @notice Computes the total amount of ETH (as wei) required to pay for all  * the top-ups assuming the maximum gas price and the current estimated gas  * usage of a top-up  */ function getEthRequiredForGas(address payer) external view override returns (uint256) {     uint256 totalEthRequired;     RecordMeta[] memory userRecordsMeta = _userPositions[payer];     uint256 gasUsagePerCall = getEstimatedGasUsage();     uint256 length = userRecordsMeta.length;     for (uint256 i; i &lt; length; i = i.uncheckedInc()) {         RecordMeta memory meta = userRecordsMeta[i];         Record memory record = _positions[payer][meta.account][meta.protocol];         uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);         totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;     }     return totalEthRequired; }  /**  * @notice Returns a list of positions for the given payer  */ function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {     return _userPositions[payer]; }  /**  * @notice Get a list supported protocols.  * @return List of supported protocols.  */ function getSupportedProtocols() external view override returns (bytes32[] memory) {     uint256 length = _supportedProtocols.length();     bytes32[] memory protocols = new bytes32[](length);     for (uint256 i; i &lt; length; i = i.uncheckedInc()) {         protocols[i] = _supportedProtocols.at(i);     }     return protocols; }  /*  * @notice Gets a list of users that have an active position.  * @dev Uses cursor pagination.  * @param cursor The cursor for pagination (should start at 0 for first call).  * @param howMany Maximum number of users to return in this pagination request.  * @return users List of users that have an active position.  * @return nextCursor The cursor to use for the next pagination request.  */ function usersWithPositions(uint256 cursor, uint256 howMany)     external     view     override     returns (address[] memory users, uint256 nextCursor) {     uint256 length = _usersWithPositions.length();     if (cursor &gt;= length) return (new address[](0), 0);     if (howMany &gt;= length - cursor) {         howMany = length - cursor;     }      address[] memory usersWithPositions_ = new address[](howMany);     for (uint256 i; i &lt; howMany; i = i.uncheckedInc()) {         usersWithPositions_[i] = _usersWithPositions.at(i + cursor);     }      return (usersWithPositions_, cursor + howMany); }  /**  * @notice Get a list of all tokens usable for this action.  * @dev This refers to all tokens that can be used as deposit tokens.  * @return Array of addresses of usable tokens.  */ function getUsableTokens() external view override returns (address[] memory) {     return _usableTokens.toArray(); }  /**  * @notice Retrieves the topup handler for the given `protocol`  */ function getTopUpHandler(bytes32 protocol) external view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice Successfully tops up a position if it's conditions are met.  * @dev pool and vault funds are rebalanced after withdrawal for top up  * @param payer Account that pays for the top up.  * @param account Account owning the position for top up.  * @param beneficiary Address of the keeper's wallet for fee accrual.  * @param protocol Protocol of the top up position.  * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas  * @return `true` if successful.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol,     uint256 maxWeiForGas ) public override returns (bool) {     require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);      ExecuteLocalVars memory vars;      vars.initialGas = gasleft();      Record storage position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);     require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);     require(block.timestamp &gt; position.registeredAt, Error.CANNOT_EXECUTE_IN_SAME_BLOCK);      vars.topUpHandler = _getHandler(protocol, true);     vars.userFactor = ITopUpHandler(vars.topUpHandler).getUserFactor(account, position.extra);      // ensure that the position is actually below its set user factor threshold     require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);      IAddressProvider addressProvider_ = addressProvider;     IGasBank gasBank = addressProvider_.getGasBank();      // fail early if the user does not have enough funds in the gas bank     // to cover the cost of the transaction     vars.estimatedRequiredGas = getEstimatedGasUsage();     vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;      // compute the gas price that the user will be paying     vars.userGasPrice = block.basefee + position.priorityFee;     if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;     if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;      // ensure the current position allows for the gas to be paid     require(         vars.estimatedRequiredWeiForGas &lt;=             vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,         Error.ESTIMATED_GAS_TOO_HIGH     );      vars.gasBankBalance = gasBank.balanceOf(payer);     // ensure the user has enough funds in the gas bank to cover the gas     require(         vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,         Error.GAS_BANK_BALANCE_TOO_LOW     );      vars.totalTopUpAmount = position.totalTopUpAmount;     vars.actionFee = getActionFee();     // add top-up fees to top-up amount     vars.minActionAmountToTopUp = position.singleTopUpAmount;     vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(         ScaledMath.ONE + vars.actionFee     );      // if the amount that we want to top-up (including fees) is higher than     // the available topup amount, we lower this down to what is left of the position     if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {         vars.actionAmountWithFees = vars.totalTopUpAmount;         vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(             ScaledMath.ONE + vars.actionFee         );     }     ILiquidityPool pool = addressProvider_.getPoolForToken(position.depositToken);     vars.underlying = pool.getUnderlying();     vars.rate = pool.exchangeRate();      // compute the deposit tokens amount with and without fees     // we will need to unstake the amount with fees and to     // swap the amount without fees into action tokens     vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);     if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {         vars.depositAmountWithFees = position.depositTokenBalance;         vars.minActionAmountToTopUp =             (vars.depositAmountWithFees * vars.rate) /             (ScaledMath.ONE + vars.actionFee);     }      // compute amount of LP tokens needed to pay for action     // rate is expressed in actionToken per depositToken     vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);     vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;      // will revert if vault does not exist     address vault = addressProvider_.getStakerVault(position.depositToken);      // unstake deposit tokens including fees     IStakerVault(vault).unstake(vars.depositAmountWithFees);     IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);      // swap the amount without the fees     // as the fees are paid in deposit token, not in action token     vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);      // compute how much of action token was actually redeemed and add fees to it     // this is to ensure that no funds get locked inside the contract     vars.totalActionTokenAmount =         vars.actionTokenAmount +         vars.depositTotalFeesAmount.scaledMul(vars.rate);      // at this point, we have exactly `vars.actionTokenAmount`     // (at least `position.singleTopUpAmount`) of action token     // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract     // solhint-disable-next-line avoid-low-level-calls     uint256 value_;     if (position.actionToken == address(0)) {         value_ = vars.actionTokenAmount;     } else {         _approve(position.actionToken, vars.topUpHandler);     }     vars.topupResult = ITopUpHandler(vars.topUpHandler).topUp{value: value_}(         account,         position.actionToken,         vars.actionTokenAmount,         position.extra     );      require(vars.topupResult, Error.TOP_UP_FAILED);      // totalTopUpAmount is updated to reflect the new "balance" of the position     if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {         position.totalTopUpAmount -= vars.totalActionTokenAmount.toUint128();     } else {         position.totalTopUpAmount = 0;     }      position.depositTokenBalance -= vars.depositAmountWithFees.toUint128();      vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;     _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);     if (vars.removePosition) {         if (position.depositTokenBalance &gt; 0) {             // transfer any unused locked tokens to the payer             IStakerVault(vault).transfer(payer, position.depositTokenBalance);             IStakerVault(vault).decreaseActionLockedBalance(                 payer,                 position.depositTokenBalance             );         }         _removePosition(payer, account, protocol);     }      emit TopUp(         account,         protocol,         payer,         position.depositToken,         vars.depositAmountWithFees,         position.actionToken,         vars.actionTokenAmount     );      // compute gas used and reimburse the keeper by using the     // funds of payer in the gas bank     // TODO: add constant gas consumed for transfer and tx prologue     vars.gasConsumed = vars.initialGas - gasleft();      vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;     if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {         vars.reimbursedWeiForGas = vars.gasBankBalance;     }      // ensure that the keeper is not overpaying     vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;     require(         vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,         Error.GAS_TOO_HIGH     );     gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);     if (vars.removePosition) {         gasBank.withdrawUnused(payer);     }      return true; }  /**  * @notice Prepare new top up handler fee update.  * @dev Setting the address to 0 means that the protocol will no longer be supported.  * @param protocol Protocol for which a new handler should be prepared.  * @param newHandler Address of new handler.  * @return `true` if success.  */ function prepareTopUpHandler(bytes32 protocol, address newHandler)     public     override     onlyGovernance     returns (bool) {     return _prepare(_getProtocolKey(protocol), newHandler); }  /**  * @notice Check if action can be executed.  * @param protocol for which to get the health factor  * @param account for which to get the health factor  * @param extra data to be used by the topup handler  * @return healthFactor of the position  */ function getHealthFactor(     bytes32 protocol,     bytes32 account,     bytes calldata extra ) public view override returns (uint256 healthFactor) {     ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));     return topUpHandler.getUserFactor(account, extra); }  function getHandler(bytes32 protocol) public view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice returns the current estimated gas usage  */ function getEstimatedGasUsage() public view override returns (uint256) {     return currentUInts256[_ESTIMATED_GAS_USAGE_KEY]; }  /**  * @notice Returns the current action fee  */ function getActionFee() public view override returns (uint256) {     return currentUInts256[_ACTION_FEE_KEY]; }  /**  * @notice Returns the current fee handler  */ function getFeeHandler() public view override returns (address) {     return currentAddresses[_FEE_HANDLER_KEY]; }  /**  * @notice Get the record for a position.  * @param payer Registered payer of the position.  * @param account Address holding the position.  * @param protocol Protocol where the position is held.  */ function getPosition(     address payer,     bytes32 account,     bytes32 protocol ) public view override returns (Record memory) {     return _positions[payer][account][protocol]; }  /**  * @notice Check whether a token is usable as a deposit token.  * @param token Address of token to check.  * @return True if token is usable as a deposit token for this action.  */ function isUsable(address token) public view override returns (bool) {     return _usableTokens.contains(token); }  function _updateTopUpHandler(     bytes32 protocol,     address oldHandler,     address newHandler ) internal {     if (newHandler == address(0)) {         _supportedProtocols.remove(protocol);     } else if (oldHandler == address(0)) {         _supportedProtocols.add(protocol);     } }  /**  * @dev Pays fees to the feeHandler  * @param payer The account who's position the fees are charged on  * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)  * @param feeAmount The amount in tokens to pay as fees  * @param depositToken The LpToken used to pay the fees  */ function _payFees(     address payer,     address beneficiary,     uint256 feeAmount,     address depositToken ) internal {     address feeHandler = getFeeHandler();     IERC20(depositToken).safeApprove(feeHandler, feeAmount);     IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken); }  /**  * @dev "Locks" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function _lockFunds(     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) internal {     address stakerVaultAddress = addressProvider.getStakerVault(token);     TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount); }  function _removePosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     delete _positions[payer][account][protocol];     _removeUserPosition(payer, account, protocol);     if (_userPositions[payer].length == 0) {         _usersWithPositions.remove(payer);     }     emit Deregister(payer, account, protocol); }  function _removeUserPosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     RecordMeta[] storage positionsMeta = _userPositions[payer];     uint256 length = positionsMeta.length;     for (uint256 i; i &lt; length; i = i.uncheckedInc()) {         RecordMeta storage positionMeta = positionsMeta[i];         if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {             positionsMeta[i] = positionsMeta[length - 1];             positionsMeta.pop();             return;         }     } }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) internal {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the `actionToken`.  */ function _calcExchangeAmount(     address token,     address actionToken,     uint256 amount ) internal view returns (uint256) {     return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount); }  function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {     address handler = currentAddresses[_getProtocolKey(protocol)];     require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);     return handler; }  function _isSwappable(address depositToken, address toToken) internal view returns (bool) {     ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);     return pool.getUnderlying() == toToken; }  function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {     return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol)); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";\nimport "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\nimport "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";\nimport "@openzeppelin/contracts/utils/math/SafeCast.sol";\n\nimport "../../../interfaces/IGasBank.sol";\nimport "../../../interfaces/pool/ILiquidityPool.sol";\nimport "../../../interfaces/IController.sol";\nimport "../../../interfaces/IStakerVault.sol";\nimport "../../../interfaces/actions/topup/ITopUpHandler.sol";\nimport "../../../interfaces/actions/topup/ITopUpAction.sol";\nimport "../../../interfaces/actions/IActionFeeHandler.sol";\n\nimport "../../../libraries/AddressProviderHelpers.sol";\nimport "../../../libraries/Errors.sol";\nimport "../../../libraries/ScaledMath.sol";\nimport "../../../libraries/EnumerableExtensions.sol";\nimport "../../../libraries/UncheckedMath.sol";\n\nimport "../../access/Authorization.sol";\nimport "../../utils/Preparable.sol";\n\n/\n * @notice The logic here should really be part of the top-up action\n * but is split in a library to circumvent the byte-code size limit\n */\nlibrary TopUpActionLibrary {\n    using SafeERC20 for IERC20;\n    using ScaledMath for uint256;\n    using AddressProviderHelpers for IAddressProvider;\n\n    /\n     * @dev "Locks" an amount of tokens on behalf of the TopUpAction\n     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.\n     * @param stakerVaultAddress The address of the staker vault\n     * @param payer Owner of the funds to be locked\n     * @param token Token to lock\n     * @param lockAmount Minimum amount of token to lock\n     * @param depositAmount Amount of token that was deposited.\n     *                      If this is 0 then the staker vault allowance should be used.\n     *                      If this is greater than requiredAmount more tokens will be locked.\n     /\n    function lockFunds(\n        address stakerVaultAddress,\n        address payer,\n        address token,\n        uint256 lockAmount,\n        uint256 depositAmount\n    ) external {\n        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);\n\n        // stake deposit amount\n        if (depositAmount &gt; 0) {\n            depositAmount = depositAmount &gt; lockAmount ? lockAmount : depositAmount;\n            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);\n            _approve(token, stakerVaultAddress);\n            stakerVault.stake(depositAmount);\n            stakerVault.increaseActionLockedBalance(payer, depositAmount);\n            lockAmount -= depositAmount;\n        }\n\n        // use stake vault allowance if available and required\n        if (lockAmount &gt; 0) {\n            uint256 balance = stakerVault.balanceOf(payer);\n            uint256 allowance = stakerVault.allowance(payer, address(this));\n            uint256 availableFunds = balance &lt; allowance ? balance : allowance;\n            if (availableFunds &gt;= lockAmount) {\n                stakerVault.transferFrom(payer, address(this), lockAmount);\n                stakerVault.increaseActionLockedBalance(payer, lockAmount);\n                lockAmount = 0;\n            }\n        }\n\n        require(lockAmount == 0, Error.INSUFFICIENT_UPDATE_BALANCE);\n    }\n\n    /\n     * @dev Computes and returns the amount of LP tokens of type token that will be received in exchange for an amount of the underlying.\n     /\n    function calcExchangeAmount(\n        IAddressProvider addressProvider,\n        address token,\n        address actionToken,\n        uint256 amount\n    ) external view returns (uint256) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(token);\n        uint256 rate = pool.exchangeRate();\n        address underlying = pool.getUnderlying();\n        require(underlying == actionToken, Error.TOKEN_NOT_USABLE);\n        return amount.scaledDivRoundUp(rate);\n    }\n\n    /\n     * @dev Approves infinite spending for the given spender.\n     * @param token The token to approve for.\n     * @param spender The spender to approve.\n     */\n    function _approve(address token, address spender) private {\n        if (IERC20(token).allowance(address(this), spender) &gt; 0) return;\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n}\n\ncontract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {\n    using ScaledMath for uint256;\n    using UncheckedMath for uint256;\n    using ScaledMath for uint128;\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using EnumerableExtensions for EnumerableSet.AddressSet;\n    using AddressProviderHelpers for IAddressProvider;\n    using SafeCast for uint256;\n\n    /\n     * @dev Temporary struct to hold local variables in execute\n     * and avoid the stack being "too deep"\n     /\n    struct ExecuteLocalVars {\n        uint256 minActionAmountToTopUp;\n        uint256 actionTokenAmount;\n        uint256 depositTotalFeesAmount;\n        uint256 actionAmountWithFees;\n        uint256 userFactor;\n        uint256 rate;\n        uint256 depositAmountWithFees;\n        uint256 depositAmountWithoutFees;\n        uint256 actionFee;\n        uint256 totalActionTokenAmount;\n        uint128 totalTopUpAmount;\n        bool topupResult;\n        uint256 gasBankBalance;\n        uint256 initialGas;\n        uint256 gasConsumed;\n        uint256 userGasPrice;\n        uint256 estimatedRequiredGas;\n        uint256 estimatedRequiredWeiForGas;\n        uint256 requiredWeiForGas;\n        uint256 reimbursedWeiForGas;\n        address underlying;\n        bool removePosition;\n        address topUpHandler;\n    }\n\n    EnumerableSet.AddressSet private _usableTokens;\n\n    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 550_000;\n\n    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";\n    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";\n    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";\n    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";\n\n    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;\n\n    IController public immutable controller;\n    IAddressProvider public immutable addressProvider;\n\n    EnumerableSet.Bytes32Set internal _supportedProtocols;\n\n    /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record)\n    mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;\n\n    mapping(address =&gt; RecordMeta[]) internal _userPositions;\n\n    EnumerableSet.AddressSet internal _usersWithPositions;\n\n    constructor(IController _controller)\n        Authorization(_controller.addressProvider().getRoleManager())\n    {\n        controller = _controller;\n        addressProvider = controller.addressProvider();\n        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);\n    }\n\n    receive() external payable {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    function initialize(\n        address feeHandler,\n        bytes32[] calldata protocols,\n        address[] calldata handlers\n    ) external initializer onlyGovernance {\n        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);\n        _setConfig(_FEE_HANDLER_KEY, feeHandler);\n        for (uint256 i; i &lt; protocols.length; i = i.uncheckedInc()) {\n            bytes32 protocolKey = _getProtocolKey(protocols[i]);\n            _setConfig(protocolKey, handlers[i]);\n            _updateTopUpHandler(protocols[i], address(0), handlers[i]);\n        }\n    }\n\n    /\n     * @notice Register a top up action.\n     * @dev The depositAmount, once converted to units of actionToken, must be greater or equal to the totalTopUpAmount (which is denominated in actionToken).\n     * @param account Account to be topped up (first 20 bytes will typically be the address).\n     * @param protocol Protocol which holds position to be topped up.\n     * @param depositAmount Amount of depositToken that will be locked.\n     * @param record containing the data for the position to register\n     /\n    function register(\n        bytes32 account,\n        bytes32 protocol,\n        uint128 depositAmount,\n        Record memory record\n    ) external payable override returns (bool) {\n        require(record.maxFee != 0, Error.INVALID_MAX_FEE);\n        require(supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);\n        require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);\n        require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);\n        require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);\n        require(\n            _positions[msg.sender][account][protocol].threshold == 0,\n            Error.POSITION_ALREADY_EXISTS\n        );\n        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);\n        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);\n\n        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) \n            record.maxFee \n            getEstimatedGasUsage();\n\n        require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);\n\n        uint256 totalLockAmount = _calcExchangeAmount(\n            record.depositToken,\n            record.actionToken,\n            record.totalTopUpAmount\n        );\n        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);\n\n        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);\n\n        record.registeredAt = uint64(block.timestamp);\n        record.depositTokenBalance = totalLockAmount.toUint128();\n        _positions[msg.sender][account][protocol] = record;\n        _userPositions[msg.sender].push(RecordMeta(account, protocol));\n        _usersWithPositions.add(msg.sender);\n\n        emit Register(\n            account,\n            protocol,\n            record.threshold,\n            msg.sender,\n            record.depositToken,\n            totalLockAmount,\n            record.actionToken,\n            record.singleTopUpAmount,\n            record.totalTopUpAmount,\n            record.maxFee,\n            record.extra\n        );\n        return true;\n    }\n\n    /\n     * @notice See overloaded version of execute for more details.\n     */\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol\n    ) external override returns (bool) {\n        return execute(payer, account, beneficiary, protocol, 0);\n    }\n\n    /\n     * @notice Delete a position to back on the given protocol for account.\n     * @param account Account holding the position.\n     * @param protocol Protocol the position is held on.\n     * @param unstake If the tokens should be unstaked from vault.\n     * @return true if successful.\n     /\n    function resetPosition(\n        bytes32 account,\n        bytes32 protocol,\n        bool unstake\n    ) external override returns (bool) {\n        address payer = msg.sender;\n        Record memory position = positions[payer][account][protocol];\n        require(position.threshold != 0, Error.NO_POSITION_EXISTS);\n\n        IAddressProvider addressProvider = addressProvider;\n        address vault = addressProvider_.getStakerVault(position.depositToken); // will revert if vault does not exist\n        IStakerVault staker = IStakerVault(vault);\n        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);\n        if (unstake) {\n            staker.unstake(position.depositTokenBalance);\n            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);\n        } else {\n            staker.transfer(payer, position.depositTokenBalance);\n        }\n\n        removePosition(payer, account, protocol);\n        addressProvider.getGasBank().withdrawUnused(payer);\n        return true;\n    }\n\n    /\n     * @notice Execute top up handler update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @param protocol Protocol for which a new handler should be executed.\n     * @return Address of new handler.\n     /\n    function executeTopUpHandler(bytes32 protocol) external override returns (address) {\n        address oldHandler = _getHandler(protocol, false);\n        address newHandler = _executeAddress(_getProtocolKey(protocol));\n\n        _updateTopUpHandler(protocol, oldHandler, newHandler);\n        return newHandler;\n    }\n\n    /\n     * @notice Reset new top up handler deadline for a protocol.\n     * @param protocol Protocol for which top up handler deadline should be reset.\n     * @return true if successful.\n     */\n    function resetTopUpHandler(bytes32 protocol) external override onlyGovernance returns (bool) {\n        return _resetAddressConfig(_getProtocolKey(protocol));\n    }\n\n    /\n     * @notice Prepare action fee update.\n     * @param newActionFee New fee to set.\n     * @return true if success.\n     /\n    function prepareActionFee(uint256 newActionFee)\n        external\n        override\n        onlyGovernance\n        returns (bool)\n    {\n        require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);\n        return _prepare(_ACTION_FEE_KEY, newActionFee);\n    }\n\n    /\n     * @notice Execute action fee update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return true if successful.\n     /\n    function executeActionFee() external override returns (uint256) {\n        return _executeUInt256(_ACTION_FEE_KEY);\n    }\n\n    /\n     * @notice Reset action fee deadline.\n     * @return true if successful.\n     */\n    function resetActionFee() external override onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ACTION_FEE_KEY);\n    }\n\n    / Set fee handler /\n    /\n     * @notice Prepare update of fee handler.\n     * @param handler New fee handler.\n     * @return true if success.\n     /\n    function prepareFeeHandler(address handler) external override onlyGovernance returns (bool) {\n        return _prepare(_FEE_HANDLER_KEY, handler);\n    }\n\n    /\n     * @notice Execute update of fee handler (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return true if successful.\n     */\n    function executeFeeHandler() external override returns (address) {\n        return _executeAddress(_FEE_HANDLER_KEY);\n    }\n\n    /\n     * @notice Reset the handler deadline.\n     * @return true if success.\n     /\n    function resetFeeHandler() external override onlyGovernance returns (bool) {\n        return _resetAddressConfig(_FEE_HANDLER_KEY);\n    }\n\n    /\n     * @notice Prepare update of estimated gas usage.\n     * @param gasUsage New estimated gas usage.\n     * @return true if success.\n     /\n    function prepareEstimatedGasUsage(uint256 gasUsage)\n        external\n        override\n        onlyGovernance\n        returns (bool)\n    {\n        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);\n    }\n\n    /\n     * @notice Execute update of gas usage (with time delay enforced).\n     * @return true if successful.\n     */\n    function executeEstimatedGasUsage() external override returns (uint256) {\n        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);\n    }\n\n    /\n     * @notice Reset the gas usage deadline.\n     * @return true if success.\n     /\n    function resetGasUsage() external override onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);\n    }\n\n    /\n     * @notice Add a new deposit token that is supported by the action.\n     * @dev There is a separate check for whether the usable token (i.e. deposit token)\n     *      is swappable for some action token.\n     * @param token Address of deposit token that can be used by the action.\n     /\n    function addUsableToken(address token) external override onlyGovernance returns (bool) {\n        return _usableTokens.add(token);\n    }\n\n    /\n     * @notice Computes the total amount of ETH (as wei) required to pay for all\n     * the top-ups assuming the maximum gas price and the current estimated gas\n     * usage of a top-up\n     */\n    function getEthRequiredForGas(address payer) external view override returns (uint256) {\n        uint256 totalEthRequired;\n        RecordMeta[] memory userRecordsMeta = _userPositions[payer];\n        uint256 gasUsagePerCall = getEstimatedGasUsage();\n        uint256 length = userRecordsMeta.length;\n        for (uint256 i; i &lt; length; i = i.uncheckedInc()) {\n            RecordMeta memory meta = userRecordsMeta[i];\n            Record memory record = _positions[payer][meta.account][meta.protocol];\n            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);\n            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;\n        }\n        return totalEthRequired;\n    }\n\n    /\n     * @notice Returns a list of positions for the given payer\n     /\n    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {\n        return _userPositions[payer];\n    }\n\n    /\n     * @notice Get a list supported protocols.\n     * @return List of supported protocols.\n     /\n    function getSupportedProtocols() external view override returns (bytes32[] memory) {\n        uint256 length = _supportedProtocols.length();\n        bytes32[] memory protocols = new bytes32;\n        for (uint256 i; i &lt; length; i = i.uncheckedInc()) {\n            protocols[i] = _supportedProtocols.at(i);\n        }\n        return protocols;\n    }\n\n    /\n     * @notice Gets a list of users that have an active position.\n     * @dev Uses cursor pagination.\n     * @param cursor The cursor for pagination (should start at 0 for first call).\n     * @param howMany Maximum number of users to return in this pagination request.\n     * @return users List of users that have an active position.\n     * @return nextCursor The cursor to use for the next pagination request.\n     /\n    function usersWithPositions(uint256 cursor, uint256 howMany)\n        external\n        view\n        override\n        returns (address[] memory users, uint256 nextCursor)\n    {\n        uint256 length = _usersWithPositions.length();\n        if (cursor &gt;= length) return (new address, 0);\n        if (howMany &gt;= length - cursor) {\n            howMany = length - cursor;\n        }\n\n        address[] memory usersWithPositions = new address;\n        for (uint256 i; i &lt; howMany; i = i.uncheckedInc()) {\n            usersWithPositions_[i] = usersWithPositions.at(i + cursor);\n        }\n\n        return (usersWithPositions, cursor + howMany);\n    }\n\n    /\n     * @notice Get a list of all tokens usable for this action.\n     * @dev This refers to all tokens that can be used as deposit tokens.\n     * @return Array of addresses of usable tokens.\n     */\n    function getUsableTokens() external view override returns (address[] memory) {\n        return _usableTokens.toArray();\n    }\n\n    /\n     * @notice Retrieves the topup handler for the given protocol\n     /\n    function getTopUpHandler(bytes32 protocol) external view override returns (address) {\n        return _getHandler(protocol, false);\n    }\n\n    /\n     * @notice Successfully tops up a position if it\'s conditions are met.\n     * @dev pool and vault funds are rebalanced after withdrawal for top up\n     * @param payer Account that pays for the top up.\n     * @param account Account owning the position for top up.\n     * @param beneficiary Address of the keeper\'s wallet for fee accrual.\n     * @param protocol Protocol of the top up position.\n     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas\n     * @return true if successful.\n     /\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol,\n        uint256 maxWeiForGas\n    ) public override returns (bool) {\n        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);\n\n        ExecuteLocalVars memory vars;\n\n        vars.initialGas = gasleft();\n\n        Record storage position = positions[payer][account][protocol];\n        require(position.threshold != 0, Error.NO_POSITION_EXISTS);\n        require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);\n        require(block.timestamp &gt; position.registeredAt, Error.CANNOT_EXECUTE_IN_SAME_BLOCK);\n\n        vars.topUpHandler = _getHandler(protocol, true);\n        vars.userFactor = ITopUpHandler(vars.topUpHandler).getUserFactor(account, position.extra);\n\n        // ensure that the position is actually below its set user factor threshold\n        require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);\n\n        IAddressProvider addressProvider = addressProvider;\n        IGasBank gasBank = addressProvider_.getGasBank();\n\n        // fail early if the user does not have enough funds in the gas bank\n        // to cover the cost of the transaction\n        vars.estimatedRequiredGas = getEstimatedGasUsage();\n        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;\n\n        // compute the gas price that the user will be paying\n        vars.userGasPrice = block.basefee + position.priorityFee;\n        if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;\n        if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;\n\n        // ensure the current position allows for the gas to be paid\n        require(\n            vars.estimatedRequiredWeiForGas &lt;=\n                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,\n            Error.ESTIMATED_GAS_TOO_HIGH\n        );\n\n        vars.gasBankBalance = gasBank.balanceOf(payer);\n        // ensure the user has enough funds in the gas bank to cover the gas\n        require(\n            vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,\n            Error.GAS_BANK_BALANCE_TOO_LOW\n        );\n\n        vars.totalTopUpAmount = position.totalTopUpAmount;\n        vars.actionFee = getActionFee();\n        // add top-up fees to top-up amount\n        vars.minActionAmountToTopUp = position.singleTopUpAmount;\n        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(\n            ScaledMath.ONE + vars.actionFee\n        );\n\n        // if the amount that we want to top-up (including fees) is higher than\n        // the available topup amount, we lower this down to what is left of the position\n        if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {\n            vars.actionAmountWithFees = vars.totalTopUpAmount;\n            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(\n                ScaledMath.ONE + vars.actionFee\n            );\n        }\n        ILiquidityPool pool = addressProvider_.getPoolForToken(position.depositToken);\n        vars.underlying = pool.getUnderlying();\n        vars.rate = pool.exchangeRate();\n\n        // compute the deposit tokens amount with and without fees\n        // we will need to unstake the amount with fees and to\n        // swap the amount without fees into action tokens\n        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);\n        if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {\n            vars.depositAmountWithFees = position.depositTokenBalance;\n            vars.minActionAmountToTopUp =\n                (vars.depositAmountWithFees * vars.rate) /\n                (ScaledMath.ONE + vars.actionFee);\n        }\n\n        // compute amount of LP tokens needed to pay for action\n        // rate is expressed in actionToken per depositToken\n        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);\n        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;\n\n        // will revert if vault does not exist\n        address vault = addressProvider_.getStakerVault(position.depositToken);\n\n        // unstake deposit tokens including fees\n        IStakerVault(vault).unstake(vars.depositAmountWithFees);\n        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);\n\n        // swap the amount without the fees\n        // as the fees are paid in deposit token, not in action token\n        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);\n\n        // compute how much of action token was actually redeemed and add fees to it\n        // this is to ensure that no funds get locked inside the contract\n        vars.totalActionTokenAmount =\n            vars.actionTokenAmount +\n            vars.depositTotalFeesAmount.scaledMul(vars.rate);\n\n        // at this point, we have exactly vars.actionTokenAmount\n        // (at least position.singleTopUpAmount) of action token\n        // and exactly vars.depositTotalFeesAmount deposit tokens in the contract\n        // solhint-disable-next-line avoid-low-level-calls\n        uint256 value_;\n        if (position.actionToken == address(0)) {\n            value_ = vars.actionTokenAmount;\n        } else {\n            approve(position.actionToken, vars.topUpHandler);\n        }\n        vars.topupResult = ITopUpHandler(vars.topUpHandler).topUp{value: value}(\n            account,\n            position.actionToken,\n            vars.actionTokenAmount,\n            position.extra\n        );\n\n        require(vars.topupResult, Error.TOP_UP_FAILED);\n\n        // totalTopUpAmount is updated to reflect the new "balance" of the position\n        if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {\n            position.totalTopUpAmount -= vars.totalActionTokenAmount.toUint128();\n        } else {\n            position.totalTopUpAmount = 0;\n        }\n\n        position.depositTokenBalance -= vars.depositAmountWithFees.toUint128();\n\n        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;\n        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);\n        if (vars.removePosition) {\n            if (position.depositTokenBalance &gt; 0) {\n                // transfer any unused locked tokens to the payer\n                IStakerVault(vault).transfer(payer, position.depositTokenBalance);\n                IStakerVault(vault).decreaseActionLockedBalance(\n                    payer,\n                    position.depositTokenBalance\n                );\n            }\n            _removePosition(payer, account, protocol);\n        }\n\n        emit TopUp(\n            account,\n            protocol,\n            payer,\n            position.depositToken,\n            vars.depositAmountWithFees,\n            position.actionToken,\n            vars.actionTokenAmount\n        );\n\n        // compute gas used and reimburse the keeper by using the\n        // funds of payer in the gas bank\n        // TODO: add constant gas consumed for transfer and tx prologue\n        vars.gasConsumed = vars.initialGas - gasleft();\n\n        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;\n        if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {\n            vars.reimbursedWeiForGas = vars.gasBankBalance;\n        }\n\n        // ensure that the keeper is not overpaying\n        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;\n        require(\n            vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,\n            Error.GAS_TOO_HIGH\n        );\n        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);\n        if (vars.removePosition) {\n            gasBank.withdrawUnused(payer);\n        }\n\n        return true;\n    }\n\n    /\n     * @notice Prepare new top up handler fee update.\n     * @dev Setting the address to 0 means that the protocol will no longer be supported.\n     * @param protocol Protocol for which a new handler should be prepared.\n     * @param newHandler Address of new handler.\n     * @return true if success.\n     */\n    function prepareTopUpHandler(bytes32 protocol, address newHandler)\n        public\n        override\n        onlyGovernance\n        returns (bool)\n    {\n        return _prepare(_getProtocolKey(protocol), newHandler);\n    }\n\n    /\n     * @notice Check if action can be executed.\n     * @param protocol for which to get the health factor\n     * @param account for which to get the health factor\n     * @param extra data to be used by the topup handler\n     * @return healthFactor of the position\n     /\n    function getHealthFactor(\n        bytes32 protocol,\n        bytes32 account,\n        bytes calldata extra\n    ) public view override returns (uint256 healthFactor) {\n        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));\n        return topUpHandler.getUserFactor(account, extra);\n    }\n\n    function getHandler(bytes32 protocol) public view override returns (address) {\n        return _getHandler(protocol, false);\n    }\n\n    /\n     * @notice returns the current estimated gas usage\n     /\n    function getEstimatedGasUsage() public view override returns (uint256) {\n        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];\n    }\n\n    /\n     * @notice Returns the current action fee\n     */\n    function getActionFee() public view override returns (uint256) {\n        return currentUInts256[_ACTION_FEE_KEY];\n    }\n\n    /\n     * @notice Returns the current fee handler\n     /\n    function getFeeHandler() public view override returns (address) {\n        return currentAddresses[_FEE_HANDLER_KEY];\n    }\n\n    /\n     * @notice Get the record for a position.\n     * @param payer Registered payer of the position.\n     * @param account Address holding the position.\n     * @param protocol Protocol where the position is held.\n     /\n    function getPosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) public view override returns (Record memory) {\n        return _positions[payer][account][protocol];\n    }\n\n    /\n     * @notice Check whether a token is usable as a deposit token.\n     * @param token Address of token to check.\n     * @return True if token is usable as a deposit token for this action.\n     */\n    function isUsable(address token) public view override returns (bool) {\n        return _usableTokens.contains(token);\n    }\n\n    function _updateTopUpHandler(\n        bytes32 protocol,\n        address oldHandler,\n        address newHandler\n    ) internal {\n        if (newHandler == address(0)) {\n            _supportedProtocols.remove(protocol);\n        } else if (oldHandler == address(0)) {\n            _supportedProtocols.add(protocol);\n        }\n    }\n\n    /\n     * @dev Pays fees to the feeHandler\n     * @param payer The account who\'s position the fees are charged on\n     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)\n     * @param feeAmount The amount in tokens to pay as fees\n     * @param depositToken The LpToken used to pay the fees\n     /\n    function _payFees(\n        address payer,\n        address beneficiary,\n        uint256 feeAmount,\n        address depositToken\n    ) internal {\n        address feeHandler = getFeeHandler();\n        IERC20(depositToken).safeApprove(feeHandler, feeAmount);\n        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);\n    }\n\n    /\n     * @dev "Locks" an amount of tokens on behalf of the TopUpAction\n     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.\n     * @param payer Owner of the funds to be locked\n     * @param token Token to lock\n     * @param lockAmount Minimum amount of token to lock\n     * @param depositAmount Amount of token that was deposited.\n     *                      If this is 0 then the staker vault allowance should be used.\n     *                      If this is greater than requiredAmount more tokens will be locked.\n     /\n    function _lockFunds(\n        address payer,\n        address token,\n        uint256 lockAmount,\n        uint256 depositAmount\n    ) internal {\n        address stakerVaultAddress = addressProvider.getStakerVault(token);\n        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);\n    }\n\n    function _removePosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) internal {\n        delete _positions[payer][account][protocol];\n        _removeUserPosition(payer, account, protocol);\n        if (_userPositions[payer].length == 0) {\n            _usersWithPositions.remove(payer);\n        }\n        emit Deregister(payer, account, protocol);\n    }\n\n    function _removeUserPosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) internal {\n        RecordMeta[] storage positionsMeta = _userPositions[payer];\n        uint256 length = positionsMeta.length;\n        for (uint256 i; i &lt; length; i = i.uncheckedInc()) {\n            RecordMeta storage positionMeta = positionsMeta[i];\n            if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {\n                positionsMeta[i] = positionsMeta[length - 1];\n                positionsMeta.pop();\n                return;\n            }\n        }\n    }\n\n    /\n     * @dev Approves infinite spending for the given spender.\n     * @param token The token to approve for.\n     * @param spender The spender to approve.\n     */\n    function _approve(address token, address spender) internal {\n        if (IERC20(token).allowance(address(this), spender) &gt; 0) return;\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n\n    /\n     * @dev Computes and returns the amount of LP tokens of type token that will be received in exchange for an amount of the actionToken.\n     */\n    function _calcExchangeAmount(\n        address token,\n        address actionToken,\n        uint256 amount\n    ) internal view returns (uint256) {\n        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);\n    }\n\n    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {\n        address handler = currentAddresses[_getProtocolKey(protocol)];\n        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);\n        return handler;\n    }\n\n    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);\n        return pool.getUnderlying() == toToken;\n    }\n\n    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));\n    }\n}\n', 'ideas': ' 1'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 12:30:57 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.10; import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol"; import "@openzeppelin/contracts/utils/math/SafeCast.sol"; import "../../../interfaces/IGasBank.sol"; import "../../../interfaces/pool/ILiquidityPool.sol"; import "../../../interfaces/IController.sol"; import "../../../interfaces/IStakerVault.sol"; import "../../../interfaces/actions/topup/ITopUpHandler.sol"; import "../../../interfaces/actions/topup/ITopUpAction.sol"; import "../../../interfaces/actions/IActionFeeHandler.sol"; import "../../../libraries/AddressProviderHelpers.sol"; import "../../../libraries/Errors.sol"; import "../../../libraries/ScaledMath.sol"; import "../../../libraries/EnumerableExtensions.sol"; import "../../../libraries/UncheckedMath.sol"; import "../../access/Authorization.sol"; import "../../utils/Preparable.sol"; /*  * @notice The logic here should really be part of the top-up action  * but is split in a library to circumvent the byte-code size limit  / library TopUpActionLibrary {     using SafeERC20 for IERC20;     using ScaledMath for uint256;     using AddressProviderHelpers for IAddressProvider; /**  * @dev "Locks" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param stakerVaultAddress The address of the staker vault  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function lockFunds(     address stakerVaultAddress,     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) external {     IStakerVault stakerVault = IStakerVault(stakerVaultAddress);      // stake deposit amount     if (depositAmount &gt; 0) {         depositAmount = depositAmount &gt; lockAmount ? lockAmount : depositAmount;         IERC20(token).safeTransferFrom(payer, address(this), depositAmount);         _approve(token, stakerVaultAddress);         stakerVault.stake(depositAmount);         stakerVault.increaseActionLockedBalance(payer, depositAmount);         lockAmount -= depositAmount;     }      // use stake vault allowance if available and required     if (lockAmount &gt; 0) {         uint256 balance = stakerVault.balanceOf(payer);         uint256 allowance = stakerVault.allowance(payer, address(this));         uint256 availableFunds = balance &lt; allowance ? balance : allowance;         if (availableFunds &gt;= lockAmount) {             stakerVault.transferFrom(payer, address(this), lockAmount);             stakerVault.increaseActionLockedBalance(payer, lockAmount);             lockAmount = 0;         }     }      require(lockAmount == 0, Error.INSUFFICIENT_UPDATE_BALANCE); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function calcExchangeAmount(     IAddressProvider addressProvider,     address token,     address actionToken,     uint256 amount ) external view returns (uint256) {     ILiquidityPool pool = addressProvider.getPoolForToken(token);     uint256 rate = pool.exchangeRate();     address underlying = pool.getUnderlying();     require(underlying == actionToken, Error.TOKEN_NOT_USABLE);     return amount.scaledDivRoundUp(rate); }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) private {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  } contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {     using ScaledMath for uint256;     using UncheckedMath for uint256;     using ScaledMath for uint128;     using SafeERC20 for IERC20;     using EnumerableSet for EnumerableSet.AddressSet;     using EnumerableSet for EnumerableSet.Bytes32Set;     using EnumerableExtensions for EnumerableSet.AddressSet;     using AddressProviderHelpers for IAddressProvider;     using SafeCast for uint256; /**  * @dev Temporary struct to hold local variables in execute  * and avoid the stack being "too deep"  */ struct ExecuteLocalVars {     uint256 minActionAmountToTopUp;     uint256 actionTokenAmount;     uint256 depositTotalFeesAmount;     uint256 actionAmountWithFees;     uint256 userFactor;     uint256 rate;     uint256 depositAmountWithFees;     uint256 depositAmountWithoutFees;     uint256 actionFee;     uint256 totalActionTokenAmount;     uint128 totalTopUpAmount;     bool topupResult;     uint256 gasBankBalance;     uint256 initialGas;     uint256 gasConsumed;     uint256 userGasPrice;     uint256 estimatedRequiredGas;     uint256 estimatedRequiredWeiForGas;     uint256 requiredWeiForGas;     uint256 reimbursedWeiForGas;     address underlying;     bool removePosition;     address topUpHandler; }  EnumerableSet.AddressSet private _usableTokens;  uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 550_000;  bytes32 internal constant _ACTION_FEE_KEY = "ActionFee"; bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler"; bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler"; bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";  uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;  IController public immutable controller; IAddressProvider public immutable addressProvider;  EnumerableSet.Bytes32Set internal _supportedProtocols;  /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record) mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;  mapping(address =&gt; RecordMeta[]) internal _userPositions;  EnumerableSet.AddressSet internal _usersWithPositions;  constructor(IController _controller)     Authorization(_controller.addressProvider().getRoleManager()) {     controller = _controller;     addressProvider = controller.addressProvider();     _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE); }  receive() external payable {     // solhint-disable-previous-line no-empty-blocks }  function initialize(     address feeHandler,     bytes32[] calldata protocols,     address[] calldata handlers ) external initializer onlyGovernance {     require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);     _setConfig(_FEE_HANDLER_KEY, feeHandler);     for (uint256 i; i &lt; protocols.length; i = i.uncheckedInc()) {         bytes32 protocolKey = _getProtocolKey(protocols[i]);         _setConfig(protocolKey, handlers[i]);         _updateTopUpHandler(protocols[i], address(0), handlers[i]);     } }  /**  * @notice Register a top up action.  * @dev The `depositAmount`, once converted to units of `actionToken`, must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).  * @param account Account to be topped up (first 20 bytes will typically be the address).  * @param protocol Protocol which holds position to be topped up.  * @param depositAmount Amount of `depositToken` that will be locked.  * @param record containing the data for the position to register  */ function register(     bytes32 account,     bytes32 protocol,     uint128 depositAmount,     Record memory record ) external payable override returns (bool) {     require(record.maxFee != 0, Error.INVALID_MAX_FEE);     require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);     require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);     require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);     require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);     require(         _positions[msg.sender][account][protocol].threshold == 0,         Error.POSITION_ALREADY_EXISTS     );     require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);     require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);      uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *         record.maxFee *         getEstimatedGasUsage();      require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);      uint256 totalLockAmount = _calcExchangeAmount(         record.depositToken,         record.actionToken,         record.totalTopUpAmount     );     _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);      addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);      record.registeredAt = uint64(block.timestamp);     record.depositTokenBalance = totalLockAmount.toUint128();     _positions[msg.sender][account][protocol] = record;     _userPositions[msg.sender].push(RecordMeta(account, protocol));     _usersWithPositions.add(msg.sender);      emit Register(         account,         protocol,         record.threshold,         msg.sender,         record.depositToken,         totalLockAmount,         record.actionToken,         record.singleTopUpAmount,         record.totalTopUpAmount,         record.maxFee,         record.extra     );     return true; }  /**  * @notice See overloaded version of `execute` for more details.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol ) external override returns (bool) {     return execute(payer, account, beneficiary, protocol, 0); }  /**  * @notice Delete a position to back on the given protocol for `account`.  * @param account Account holding the position.  * @param protocol Protocol the position is held on.  * @param unstake If the tokens should be unstaked from vault.  * @return `true` if successful.  */ function resetPosition(     bytes32 account,     bytes32 protocol,     bool unstake ) external override returns (bool) {     address payer = msg.sender;     Record memory position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);      IAddressProvider addressProvider_ = addressProvider;     address vault = addressProvider_.getStakerVault(position.depositToken); // will revert if vault does not exist     IStakerVault staker = IStakerVault(vault);     staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);     if (unstake) {         staker.unstake(position.depositTokenBalance);         IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);     } else {         staker.transfer(payer, position.depositTokenBalance);     }      _removePosition(payer, account, protocol);     addressProvider_.getGasBank().withdrawUnused(payer);     return true; }  /**  * @notice Execute top up handler update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @param protocol Protocol for which a new handler should be executed.  * @return Address of new handler.  */ function executeTopUpHandler(bytes32 protocol) external override returns (address) {     address oldHandler = _getHandler(protocol, false);     address newHandler = _executeAddress(_getProtocolKey(protocol));      _updateTopUpHandler(protocol, oldHandler, newHandler);     return newHandler; }  /**  * @notice Reset new top up handler deadline for a protocol.  * @param protocol Protocol for which top up handler deadline should be reset.  * @return `true` if successful.  */ function resetTopUpHandler(bytes32 protocol) external override onlyGovernance returns (bool) {     return _resetAddressConfig(_getProtocolKey(protocol)); }  /**  * @notice Prepare action fee update.  * @param newActionFee New fee to set.  * @return `true` if success.  */ function prepareActionFee(uint256 newActionFee)     external     override     onlyGovernance     returns (bool) {     require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);     return _prepare(_ACTION_FEE_KEY, newActionFee); }  /**  * @notice Execute action fee update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeActionFee() external override returns (uint256) {     return _executeUInt256(_ACTION_FEE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetActionFee() external override onlyGovernance returns (bool) {     return _resetUInt256Config(_ACTION_FEE_KEY); }  /** Set fee handler */ /**  * @notice Prepare update of fee handler.  * @param handler New fee handler.  * @return `true` if success.  */ function prepareFeeHandler(address handler) external override onlyGovernance returns (bool) {     return _prepare(_FEE_HANDLER_KEY, handler); }  /**  * @notice Execute update of fee handler (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeFeeHandler() external override returns (address) {     return _executeAddress(_FEE_HANDLER_KEY); }  /**  * @notice Reset the handler deadline.  * @return `true` if success.  */ function resetFeeHandler() external override onlyGovernance returns (bool) {     return _resetAddressConfig(_FEE_HANDLER_KEY); }  /**  * @notice Prepare update of estimated gas usage.  * @param gasUsage New estimated gas usage.  * @return `true` if success.  */ function prepareEstimatedGasUsage(uint256 gasUsage)     external     override     onlyGovernance     returns (bool) {     return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage); }  /**  * @notice Execute update of gas usage (with time delay enforced).  * @return `true` if successful.  */ function executeEstimatedGasUsage() external override returns (uint256) {     return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Reset the gas usage deadline.  * @return `true` if success.  */ function resetGasUsage() external override onlyGovernance returns (bool) {     return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Add a new deposit token that is supported by the action.  * @dev There is a separate check for whether the usable token (i.e. deposit token)  *      is swappable for some action token.  * @param token Address of deposit token that can be used by the action.  */ function addUsableToken(address token) external override onlyGovernance returns (bool) {     return _usableTokens.add(token); }  /**  * @notice Computes the total amount of ETH (as wei) required to pay for all  * the top-ups assuming the maximum gas price and the current estimated gas  * usage of a top-up  */ function getEthRequiredForGas(address payer) external view override returns (uint256) {     uint256 totalEthRequired;     RecordMeta[] memory userRecordsMeta = _userPositions[payer];     uint256 gasUsagePerCall = getEstimatedGasUsage();     uint256 length = userRecordsMeta.length;     for (uint256 i; i &lt; length; i = i.uncheckedInc()) {         RecordMeta memory meta = userRecordsMeta[i];         Record memory record = _positions[payer][meta.account][meta.protocol];         uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);         totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;     }     return totalEthRequired; }  /**  * @notice Returns a list of positions for the given payer  */ function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {     return _userPositions[payer]; }  /**  * @notice Get a list supported protocols.  * @return List of supported protocols.  */ function getSupportedProtocols() external view override returns (bytes32[] memory) {     uint256 length = _supportedProtocols.length();     bytes32[] memory protocols = new bytes32[](length);     for (uint256 i; i &lt; length; i = i.uncheckedInc()) {         protocols[i] = _supportedProtocols.at(i);     }     return protocols; }  /*  * @notice Gets a list of users that have an active position.  * @dev Uses cursor pagination.  * @param cursor The cursor for pagination (should start at 0 for first call).  * @param howMany Maximum number of users to return in this pagination request.  * @return users List of users that have an active position.  * @return nextCursor The cursor to use for the next pagination request.  */ function usersWithPositions(uint256 cursor, uint256 howMany)     external     view     override     returns (address[] memory users, uint256 nextCursor) {     uint256 length = _usersWithPositions.length();     if (cursor &gt;= length) return (new address[](0), 0);     if (howMany &gt;= length - cursor) {         howMany = length - cursor;     }      address[] memory usersWithPositions_ = new address[](howMany);     for (uint256 i; i &lt; howMany; i = i.uncheckedInc()) {         usersWithPositions_[i] = _usersWithPositions.at(i + cursor);     }      return (usersWithPositions_, cursor + howMany); }  /**  * @notice Get a list of all tokens usable for this action.  * @dev This refers to all tokens that can be used as deposit tokens.  * @return Array of addresses of usable tokens.  */ function getUsableTokens() external view override returns (address[] memory) {     return _usableTokens.toArray(); }  /**  * @notice Retrieves the topup handler for the given `protocol`  */ function getTopUpHandler(bytes32 protocol) external view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice Successfully tops up a position if it's conditions are met.  * @dev pool and vault funds are rebalanced after withdrawal for top up  * @param payer Account that pays for the top up.  * @param account Account owning the position for top up.  * @param beneficiary Address of the keeper's wallet for fee accrual.  * @param protocol Protocol of the top up position.  * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas  * @return `true` if successful.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol,     uint256 maxWeiForGas ) public override returns (bool) {     require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);      ExecuteLocalVars memory vars;      vars.initialGas = gasleft();      Record storage position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);     require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);     require(block.timestamp &gt; position.registeredAt, Error.CANNOT_EXECUTE_IN_SAME_BLOCK);      vars.topUpHandler = _getHandler(protocol, true);     vars.userFactor = ITopUpHandler(vars.topUpHandler).getUserFactor(account, position.extra);      // ensure that the position is actually below its set user factor threshold     require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);      IAddressProvider addressProvider_ = addressProvider;     IGasBank gasBank = addressProvider_.getGasBank();      // fail early if the user does not have enough funds in the gas bank     // to cover the cost of the transaction     vars.estimatedRequiredGas = getEstimatedGasUsage();     vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;      // compute the gas price that the user will be paying     vars.userGasPrice = block.basefee + position.priorityFee;     if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;     if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;      // ensure the current position allows for the gas to be paid     require(         vars.estimatedRequiredWeiForGas &lt;=             vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,         Error.ESTIMATED_GAS_TOO_HIGH     );      vars.gasBankBalance = gasBank.balanceOf(payer);     // ensure the user has enough funds in the gas bank to cover the gas     require(         vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,         Error.GAS_BANK_BALANCE_TOO_LOW     );      vars.totalTopUpAmount = position.totalTopUpAmount;     vars.actionFee = getActionFee();     // add top-up fees to top-up amount     vars.minActionAmountToTopUp = position.singleTopUpAmount;     vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(         ScaledMath.ONE + vars.actionFee     );      // if the amount that we want to top-up (including fees) is higher than     // the available topup amount, we lower this down to what is left of the position     if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {         vars.actionAmountWithFees = vars.totalTopUpAmount;         vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(             ScaledMath.ONE + vars.actionFee         );     }     ILiquidityPool pool = addressProvider_.getPoolForToken(position.depositToken);     vars.underlying = pool.getUnderlying();     vars.rate = pool.exchangeRate();      // compute the deposit tokens amount with and without fees     // we will need to unstake the amount with fees and to     // swap the amount without fees into action tokens     vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);     if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {         vars.depositAmountWithFees = position.depositTokenBalance;         vars.minActionAmountToTopUp =             (vars.depositAmountWithFees * vars.rate) /             (ScaledMath.ONE + vars.actionFee);     }      // compute amount of LP tokens needed to pay for action     // rate is expressed in actionToken per depositToken     vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);     vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;      // will revert if vault does not exist     address vault = addressProvider_.getStakerVault(position.depositToken);      // unstake deposit tokens including fees     IStakerVault(vault).unstake(vars.depositAmountWithFees);     IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);      // swap the amount without the fees     // as the fees are paid in deposit token, not in action token     vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);      // compute how much of action token was actually redeemed and add fees to it     // this is to ensure that no funds get locked inside the contract     vars.totalActionTokenAmount =         vars.actionTokenAmount +         vars.depositTotalFeesAmount.scaledMul(vars.rate);      // at this point, we have exactly `vars.actionTokenAmount`     // (at least `position.singleTopUpAmount`) of action token     // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract     // solhint-disable-next-line avoid-low-level-calls     uint256 value_;     if (position.actionToken == address(0)) {         value_ = vars.actionTokenAmount;     } else {         _approve(position.actionToken, vars.topUpHandler);     }     vars.topupResult = ITopUpHandler(vars.topUpHandler).topUp{value: value_}(         account,         position.actionToken,         vars.actionTokenAmount,         position.extra     );      require(vars.topupResult, Error.TOP_UP_FAILED);      // totalTopUpAmount is updated to reflect the new "balance" of the position     if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {         position.totalTopUpAmount -= vars.totalActionTokenAmount.toUint128();     } else {         position.totalTopUpAmount = 0;     }      position.depositTokenBalance -= vars.depositAmountWithFees.toUint128();      vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;     _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);     if (vars.removePosition) {         if (position.depositTokenBalance &gt; 0) {             // transfer any unused locked tokens to the payer             IStakerVault(vault).transfer(payer, position.depositTokenBalance);             IStakerVault(vault).decreaseActionLockedBalance(                 payer,                 position.depositTokenBalance             );         }         _removePosition(payer, account, protocol);     }      emit TopUp(         account,         protocol,         payer,         position.depositToken,         vars.depositAmountWithFees,         position.actionToken,         vars.actionTokenAmount     );      // compute gas used and reimburse the keeper by using the     // funds of payer in the gas bank     // TODO: add constant gas consumed for transfer and tx prologue     vars.gasConsumed = vars.initialGas - gasleft();      vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;     if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {         vars.reimbursedWeiForGas = vars.gasBankBalance;     }      // ensure that the keeper is not overpaying     vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;     require(         vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,         Error.GAS_TOO_HIGH     );     gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);     if (vars.removePosition) {         gasBank.withdrawUnused(payer);     }      return true; }  /**  * @notice Prepare new top up handler fee update.  * @dev Setting the address to 0 means that the protocol will no longer be supported.  * @param protocol Protocol for which a new handler should be prepared.  * @param newHandler Address of new handler.  * @return `true` if success.  */ function prepareTopUpHandler(bytes32 protocol, address newHandler)     public     override     onlyGovernance     returns (bool) {     return _prepare(_getProtocolKey(protocol), newHandler); }  /**  * @notice Check if action can be executed.  * @param protocol for which to get the health factor  * @param account for which to get the health factor  * @param extra data to be used by the topup handler  * @return healthFactor of the position  */ function getHealthFactor(     bytes32 protocol,     bytes32 account,     bytes calldata extra ) public view override returns (uint256 healthFactor) {     ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));     return topUpHandler.getUserFactor(account, extra); }  function getHandler(bytes32 protocol) public view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice returns the current estimated gas usage  */ function getEstimatedGasUsage() public view override returns (uint256) {     return currentUInts256[_ESTIMATED_GAS_USAGE_KEY]; }  /**  * @notice Returns the current action fee  */ function getActionFee() public view override returns (uint256) {     return currentUInts256[_ACTION_FEE_KEY]; }  /**  * @notice Returns the current fee handler  */ function getFeeHandler() public view override returns (address) {     return currentAddresses[_FEE_HANDLER_KEY]; }  /**  * @notice Get the record for a position.  * @param payer Registered payer of the position.  * @param account Address holding the position.  * @param protocol Protocol where the position is held.  */ function getPosition(     address payer,     bytes32 account,     bytes32 protocol ) public view override returns (Record memory) {     return _positions[payer][account][protocol]; }  /**  * @notice Check whether a token is usable as a deposit token.  * @param token Address of token to check.  * @return True if token is usable as a deposit token for this action.  */ function isUsable(address token) public view override returns (bool) {     return _usableTokens.contains(token); }  function _updateTopUpHandler(     bytes32 protocol,     address oldHandler,     address newHandler ) internal {     if (newHandler == address(0)) {         _supportedProtocols.remove(protocol);     } else if (oldHandler == address(0)) {         _supportedProtocols.add(protocol);     } }  /**  * @dev Pays fees to the feeHandler  * @param payer The account who's position the fees are charged on  * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)  * @param feeAmount The amount in tokens to pay as fees  * @param depositToken The LpToken used to pay the fees  */ function _payFees(     address payer,     address beneficiary,     uint256 feeAmount,     address depositToken ) internal {     address feeHandler = getFeeHandler();     IERC20(depositToken).safeApprove(feeHandler, feeAmount);     IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken); }  /**  * @dev "Locks" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function _lockFunds(     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) internal {     address stakerVaultAddress = addressProvider.getStakerVault(token);     TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount); }  function _removePosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     delete _positions[payer][account][protocol];     _removeUserPosition(payer, account, protocol);     if (_userPositions[payer].length == 0) {         _usersWithPositions.remove(payer);     }     emit Deregister(payer, account, protocol); }  function _removeUserPosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     RecordMeta[] storage positionsMeta = _userPositions[payer];     uint256 length = positionsMeta.length;     for (uint256 i; i &lt; length; i = i.uncheckedInc()) {         RecordMeta storage positionMeta = positionsMeta[i];         if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {             positionsMeta[i] = positionsMeta[length - 1];             positionsMeta.pop();             return;         }     } }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) internal {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the `actionToken`.  */ function _calcExchangeAmount(     address token,     address actionToken,     uint256 amount ) internal view returns (uint256) {     return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount); }  function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {     address handler = currentAddresses[_getProtocolKey(protocol)];     require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);     return handler; }  function _isSwappable(address depositToken, address toToken) internal view returns (bool) {     ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);     return pool.getUnderlying() == toToken; }  function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {     return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol)); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 12:30:57 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.10;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";
import "@openzeppelin/contracts/utils/math/SafeCast.sol";

import "../../../interfaces/IGasBank.sol";
import "../../../interfaces/pool/ILiquidityPool.sol";
import "../../../interfaces/IController.sol";
import "../../../interfaces/IStakerVault.sol";
import "../../../interfaces/actions/topup/ITopUpHandler.sol";
import "../../../interfaces/actions/topup/ITopUpAction.sol";
import "../../../interfaces/actions/IActionFeeHandler.sol";

import "../../../libraries/AddressProviderHelpers.sol";
import "../../../libraries/Errors.sol";
import "../../../libraries/ScaledMath.sol";
import "../../../libraries/EnumerableExtensions.sol";
import "../../../libraries/UncheckedMath.sol";

import "../../access/Authorization.sol";
import "../../utils/Preparable.sol";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param stakerVaultAddress The address of the staker vault
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > lockAmount ? lockAmount : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            _approve(token, stakerVaultAddress);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            lockAmount -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (lockAmount > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= lockAmount) {
                stakerVault.transferFrom(payer, address(this), lockAmount);
                stakerVault.increaseActionLockedBalance(payer, lockAmount);
                lockAmount = 0;
            }
        }

        require(lockAmount == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        require(underlying == actionToken, Error.TOKEN_NOT_USABLE);
        return amount.scaledDivRoundUp(rate);
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) private {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using UncheckedMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;
    using SafeCast for uint256;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being "too deep"
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
        address topUpHandler;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 550_000;

    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";
    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        for (uint256 i; i < protocols.length; i = i.uncheckedInc()) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount`, once converted to units of `actionToken`, must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param protocol Protocol which holds position to be topped up.
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable override returns (bool) {
        require(record.maxFee != 0, Error.INVALID_MAX_FEE);
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.registeredAt = uint64(block.timestamp);
        record.depositTokenBalance = totalLockAmount.toUint128();
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        IAddressProvider addressProvider_ = addressProvider;
        address vault = addressProvider_.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider_.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external override onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee)
        external
        override
        onlyGovernance
        returns (bool)
    {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external override onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external override onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external override onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage)
        external
        override
        onlyGovernance
        returns (bool)
    {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external override returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external override onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i; i < howMany; i = i.uncheckedInc()) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);
        require(block.timestamp > position.registeredAt, Error.CANNOT_EXECUTE_IN_SAME_BLOCK);

        vars.topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(vars.topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IAddressProvider addressProvider_ = addressProvider;
        IGasBank gasBank = addressProvider_.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider_.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider_.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        uint256 value_;
        if (position.actionToken == address(0)) {
            value_ = vars.actionTokenAmount;
        } else {
            _approve(position.actionToken, vars.topUpHandler);
        }
        vars.topupResult = ITopUpHandler(vars.topUpHandler).topUp{value: value_}(
            account,
            position.actionToken,
            vars.actionTokenAmount,
            position.extra
        );

        require(vars.topupResult, Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new "balance" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= vars.totalActionTokenAmount.toUint128();
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= vars.depositAmountWithFees.toUint128();

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the address to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        override
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes calldata extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view override returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the `actionToken`.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        return pool.getUnderlying() == toToken;
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.10;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";
import "@openzeppelin/contracts/utils/math/SafeCast.sol";

import "../../../interfaces/IGasBank.sol";
import "../../../interfaces/pool/ILiquidityPool.sol";
import "../../../interfaces/IController.sol";
import "../../../interfaces/IStakerVault.sol";
import "../../../interfaces/actions/topup/ITopUpHandler.sol";
import "../../../interfaces/actions/topup/ITopUpAction.sol";
import "../../../interfaces/actions/IActionFeeHandler.sol";

import "../../../libraries/AddressProviderHelpers.sol";
import "../../../libraries/Errors.sol";
import "../../../libraries/ScaledMath.sol";
import "../../../libraries/EnumerableExtensions.sol";
import "../../../libraries/UncheckedMath.sol";

import "../../access/Authorization.sol";
import "../../utils/Preparable.sol";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param stakerVaultAddress The address of the staker vault
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > lockAmount ? lockAmount : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            _approve(token, stakerVaultAddress);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            lockAmount -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (lockAmount > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= lockAmount) {
                stakerVault.transferFrom(payer, address(this), lockAmount);
                stakerVault.increaseActionLockedBalance(payer, lockAmount);
                lockAmount = 0;
            }
        }

        require(lockAmount == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        require(underlying == actionToken, Error.TOKEN_NOT_USABLE);
        return amount.scaledDivRoundUp(rate);
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) private {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using UncheckedMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;
    using SafeCast for uint256;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being "too deep"
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
        address topUpHandler;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 550_000;

    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";
    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        for (uint256 i; i < protocols.length; i = i.uncheckedInc()) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount`, once converted to units of `actionToken`, must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param protocol Protocol which holds position to be topped up.
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable override returns (bool) {
        require(record.maxFee != 0, Error.INVALID_MAX_FEE);
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.registeredAt = uint64(block.timestamp);
        record.depositTokenBalance = totalLockAmount.toUint128();
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        IAddressProvider addressProvider_ = addressProvider;
        address vault = addressProvider_.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider_.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external override onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee)
        external
        override
        onlyGovernance
        returns (bool)
    {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external override onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external override onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external override onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage)
        external
        override
        onlyGovernance
        returns (bool)
    {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external override returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external override onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i; i < howMany; i = i.uncheckedInc()) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);
        require(block.timestamp > position.registeredAt, Error.CANNOT_EXECUTE_IN_SAME_BLOCK);

        vars.topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(vars.topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IAddressProvider addressProvider_ = addressProvider;
        IGasBank gasBank = addressProvider_.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider_.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider_.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        uint256 value_;
        if (position.actionToken == address(0)) {
            value_ = vars.actionTokenAmount;
        } else {
            _approve(position.actionToken, vars.topUpHandler);
        }
        vars.topupResult = ITopUpHandler(vars.topUpHandler).topUp{value: value_}(
            account,
            position.actionToken,
            vars.actionTokenAmount,
            position.extra
        );

        require(vars.topupResult, Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new "balance" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= vars.totalActionTokenAmount.toUint128();
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= vars.depositAmountWithFees.toUint128();

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the address to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        override
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes calldata extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view override returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the `actionToken`.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        return pool.getUnderlying() == toToken;
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
".
Ideas: " 1".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-01-09 12:31:12 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 12:31:12 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 15304
completion_tokens: 1061
total_tokens: 16365
cost: $-1.000000


[2024-01-09 12:31:12 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.10;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";
import "@openzeppelin/contracts/utils/math/SafeCast.sol";

import "../../../interfaces/IGasBank.sol";
import "../../../interfaces/pool/ILiquidityPool.sol";
import "../../../interfaces/IController.sol";
import "../../../interfaces/IStakerVault.sol";
import "../../../interfaces/actions/topup/ITopUpHandler.sol";
import "../../../interfaces/actions/topup/ITopUpAction.sol";
import "../../../interfaces/actions/IActionFeeHandler.sol";

import "../../../libraries/AddressProviderHelpers.sol";
import "../../../libraries/Errors.sol";
import "../../../libraries/ScaledMath.sol";
import "../../../libraries/EnumerableExtensions.sol";
import "../../../libraries/UncheckedMath.sol";

import "../../access/Authorization.sol";
import "../../utils/Preparable.sol";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param stakerVaultAddress The address of the staker vault
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > lockAmount ? lockAmount : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            _approve(token, stakerVaultAddress);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            lockAmount -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (lockAmount > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= lockAmount) {
                stakerVault.transferFrom(payer, address(this), lockAmount);
                stakerVault.increaseActionLockedBalance(payer, lockAmount);
                lockAmount = 0;
            }
        }

        require(lockAmount == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        require(underlying == actionToken, Error.TOKEN_NOT_USABLE);
        return amount.scaledDivRoundUp(rate);
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) private {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using UncheckedMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;
    using SafeCast for uint256;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being "too deep"
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
        address topUpHandler;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 550_000;

    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";
    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        for (uint256 i; i < protocols.length; i = i.uncheckedInc()) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount`, once converted to units of `actionToken`, must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param protocol Protocol which holds position to be topped up.
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable override returns (bool) {
        require(record.maxFee != 0, Error.INVALID_MAX_FEE);
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.registeredAt = uint64(block.timestamp);
        record.depositTokenBalance = totalLockAmount.toUint128();
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        IAddressProvider addressProvider_ = addressProvider;
        address vault = addressProvider_.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider_.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external override onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee)
        external
        override
        onlyGovernance
        returns (bool)
    {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external override onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external override onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external override onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage)
        external
        override
        onlyGovernance
        returns (bool)
    {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external override returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external override onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i; i < howMany; i = i.uncheckedInc()) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);
        require(block.timestamp > position.registeredAt, Error.CANNOT_EXECUTE_IN_SAME_BLOCK);

        vars.topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(vars.topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IAddressProvider addressProvider_ = addressProvider;
        IGasBank gasBank = addressProvider_.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider_.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider_.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        uint256 value_;
        if (position.actionToken == address(0)) {
            value_ = vars.actionTokenAmount;
        } else {
            _approve(position.actionToken, vars.topUpHandler);
        }
        vars.topupResult = ITopUpHandler(vars.topUpHandler).topUp{value: value_}(
            account,
            position.actionToken,
            vars.actionTokenAmount,
            position.extra
        );

        require(vars.topupResult, Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new "balance" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= vars.totalActionTokenAmount.toUint128();
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= vars.depositAmountWithFees.toUint128();

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the address to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        override
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes calldata extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view override returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the `actionToken`.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        return pool.getUnderlying() == toToken;
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
.]

### VULNERABILITY 1: Reentrancy Attack
```
DETAILED DESCRIPTION:
The contract does not implement any reentrancy guards, particularly in the `execute` function where external calls are made to the `topUpHandler`. If the `topUpHandler` is a malicious contract, it could call back into the `TopUpAction` contract during the execution of the `topUp` function, potentially allowing it to manipulate the state or drain funds.

POTENTIAL IMPACT:
An attacker could exploit this vulnerability to perform unauthorized actions, such as draining funds from the contract or manipulating user positions.

RECOMMENDED MITIGATION:
Implement a reentrancy guard using the `nonReentrant` modifier from OpenZeppelin's `ReentrancyGuard` contract. This should be applied to functions that make external calls, particularly the `execute` function.
```

### VULNERABILITY 2: Gas Limit and Block Gas Limit Issues
```
DETAILED DESCRIPTION:
The contract relies on gas estimates for executing transactions, particularly in the `execute` function. If the gas limit is exceeded, the transaction will fail, but this could lead to denial of service for users who cannot execute their actions due to high gas consumption.

POTENTIAL IMPACT:
Users may be unable to execute their top-up actions if the gas required exceeds the block gas limit, leading to potential loss of funds or inability to interact with the contract.

RECOMMENDED MITIGATION:
Implement a fallback mechanism to handle cases where the gas limit is exceeded. This could involve allowing users to specify a maximum gas price they are willing to pay or providing a way to adjust the gas estimation dynamically based on current network conditions.
```

### VULNERABILITY 3: Insufficient Input Validation
```
DETAILED DESCRIPTION:
The contract has several places where input parameters are not sufficiently validated. For example, in the `register` function, while there are checks for `maxFee`, `singleTopUpAmount`, and `threshold`, there is no check to ensure that the `depositAmount` is greater than zero.

POTENTIAL IMPACT:
If invalid parameters are passed, it could lead to unexpected behavior or state corruption within the contract, potentially allowing for exploitation.

RECOMMENDED MITIGATION:
Add additional checks to validate all input parameters in functions like `register`, `execute`, and others to ensure they meet expected conditions (e.g., non-zero values, valid addresses).
```

### VULNERABILITY 4: Lack of Access Control on Critical Functions
```
DETAILED DESCRIPTION:
While there are some access control mechanisms in place (e.g., `onlyGovernance`), there are critical functions such as `execute` and `register` that could potentially be called by unauthorized users if the governance mechanism is compromised.

POTENTIAL IMPACT:
An attacker could exploit this lack of access control to manipulate user positions, execute unauthorized top-ups, or drain funds from the contract.

RECOMMENDED MITIGATION:
Implement stricter access control mechanisms for critical functions. Consider using role-based access control (RBAC) to ensure that only authorized users can call sensitive functions.
```

### VULNERABILITY 5: Token Approval Race Condition
```
DETAILED DESCRIPTION:
The contract uses the `safeApprove` method to approve tokens for spending. However, there is a known issue with token approvals where if a user first sets an approval to a non-zero value and then immediately sets it to a new value, it could lead to a race condition where an attacker could exploit this to spend more tokens than intended.

POTENTIAL IMPACT:
An attacker could exploit this race condition to drain tokens from the user's account.

RECOMMENDED MITIGATION:
Use the `safeIncreaseAllowance` and `safeDecreaseAllowance` methods from OpenZeppelin to adjust allowances instead of setting them directly. This prevents the race condition by ensuring that the allowance is adjusted safely.
```

### VULNERABILITY 6: Lack of Event Emission for Critical State Changes
```
DETAILED DESCRIPTION:
The contract does not emit events for all critical state changes, particularly in functions like `resetPosition` and `register`. Events are crucial for tracking state changes and debugging.

POTENTIAL IMPACT:
Without proper event logging, it becomes difficult to track actions taken on the contract, making it harder to audit and debug issues.

RECOMMENDED MITIGATION:
Ensure that all critical state changes emit appropriate events. For example, emit an event when a position is reset or registered to provide transparency and traceability.
```

### VULNERABILITY 7: Insufficient Handling of Ether Transfers
```
DETAILED DESCRIPTION:
The contract accepts Ether in the `register` function but does not have a clear mechanism for handling it properly. If the contract fails after receiving Ether, the funds may be locked or lost.

POTENTIAL IMPACT:
Users may lose Ether if the transaction fails after sending it, leading to a poor user experience and potential financial loss.

RECOMMENDED MITIGATION:
Implement a mechanism to ensure that Ether sent to the contract is handled properly, such as using `call` for transferring Ether and ensuring that the contract can revert transactions safely.
```

### VULNER

[2024-01-09 12:31:12 INFO] **[Seminar Conclusion]**:

 ### VULNERABILITY 1: Reentrancy Attack
```
DETAILED DESCRIPTION:
The contract does not implement any reentrancy guards, particularly in the `execute` function where external calls are made to the `topUpHandler`. If the `topUpHandler` is a malicious contract, it could call back into the `TopUpAction` contract during the execution of the `topUp` function, potentially allowing it to manipulate the state or drain funds.

POTENTIAL IMPACT:
An attacker could exploit this vulnerability to perform unauthorized actions, such as draining funds from the contract or manipulating user positions.

RECOMMENDED MITIGATION:
Implement a reentrancy guard using the `nonReentrant` modifier from OpenZeppelin's `ReentrancyGuard` contract. This should be applied to functions that make external calls, particularly the `execute` function.
```

### VULNERABILITY 2: Gas Limit and Block Gas Limit Issues
```
DETAILED DESCRIPTION:
The contract relies on gas estimates for executing transactions, particularly in the `execute` function. If the gas limit is exceeded, the transaction will fail, but this could lead to denial of service for users who cannot execute their actions due to high gas consumption.

POTENTIAL IMPACT:
Users may be unable to execute their top-up actions if the gas required exceeds the block gas limit, leading to potential loss of funds or inability to interact with the contract.

RECOMMENDED MITIGATION:
Implement a fallback mechanism to handle cases where the gas limit is exceeded. This could involve allowing users to specify a maximum gas price they are willing to pay or providing a way to adjust the gas estimation dynamically based on current network conditions.
```

### VULNERABILITY 3: Insufficient Input Validation
```
DETAILED DESCRIPTION:
The contract has several places where input parameters are not sufficiently validated. For example, in the `register` function, while there are checks for `maxFee`, `singleTopUpAmount`, and `threshold`, there is no check to ensure that the `depositAmount` is greater than zero.

POTENTIAL IMPACT:
If invalid parameters are passed, it could lead to unexpected behavior or state corruption within the contract, potentially allowing for exploitation.

RECOMMENDED MITIGATION:
Add additional checks to validate all input parameters in functions like `register`, `execute`, and others to ensure they meet expected conditions (e.g., non-zero values, valid addresses).
```

### VULNERABILITY 4: Lack of Access Control on Critical Functions
```
DETAILED DESCRIPTION:
While there are some access control mechanisms in place (e.g., `onlyGovernance`), there are critical functions such as `execute` and `register` that could potentially be called by unauthorized users if the governance mechanism is compromised.

POTENTIAL IMPACT:
An attacker could exploit this lack of access control to manipulate user positions, execute unauthorized top-ups, or drain funds from the contract.

RECOMMENDED MITIGATION:
Implement stricter access control mechanisms for critical functions. Consider using role-based access control (RBAC) to ensure that only authorized users can call sensitive functions.
```

### VULNERABILITY 5: Token Approval Race Condition
```
DETAILED DESCRIPTION:
The contract uses the `safeApprove` method to approve tokens for spending. However, there is a known issue with token approvals where if a user first sets an approval to a non-zero value and then immediately sets it to a new value, it could lead to a race condition where an attacker could exploit this to spend more tokens than intended.

POTENTIAL IMPACT:
An attacker could exploit this race condition to drain tokens from the user's account.

RECOMMENDED MITIGATION:
Use the `safeIncreaseAllowance` and `safeDecreaseAllowance` methods from OpenZeppelin to adjust allowances instead of setting them directly. This prevents the race condition by ensuring that the allowance is adjusted safely.
```

### VULNERABILITY 6: Lack of Event Emission for Critical State Changes
```
DETAILED DESCRIPTION:
The contract does not emit events for all critical state changes, particularly in functions like `resetPosition` and `register`. Events are crucial for tracking state changes and debugging.

POTENTIAL IMPACT:
Without proper event logging, it becomes difficult to track actions taken on the contract, making it harder to audit and debug issues.

RECOMMENDED MITIGATION:
Ensure that all critical state changes emit appropriate events. For example, emit an event when a position is reset or registered to provide transparency and traceability.
```

### VULNERABILITY 7: Insufficient Handling of Ether Transfers
```
DETAILED DESCRIPTION:
The contract accepts Ether in the `register` function but does not have a clear mechanism for handling it properly. If the contract fails after receiving Ether, the funds may be locked or lost.

POTENTIAL IMPACT:
Users may lose Ether if the transaction fails after sending it, leading to a poor user experience and potential financial loss.

RECOMMENDED MITIGATION:
Implement a mechanism to ensure that Ether sent to the contract is handled properly, such as using `call` for transferring Ether and ensuring that the contract can revert transactions safely.
```

### VULNER

[2024-01-09 12:31:12 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 3

[2024-01-09 12:31:12 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.10; import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol"; import "@openzeppelin/contracts/utils/math/SafeCast.sol"; import "../../../interfaces/IGasBank.sol"; import "../../../interfaces/pool/ILiquidityPool.sol"; import "../../../interfaces/IController.sol"; import "../../../interfaces/IStakerVault.sol"; import "../../../interfaces/actions/topup/ITopUpHandler.sol"; import "../../../interfaces/actions/topup/ITopUpAction.sol"; import "../../../interfaces/actions/IActionFeeHandler.sol"; import "../../../libraries/AddressProviderHelpers.sol"; import "../../../libraries/Errors.sol"; import "../../../libraries/ScaledMath.sol"; import "../../../libraries/EnumerableExtensions.sol"; import "../../../libraries/UncheckedMath.sol"; import "../../access/Authorization.sol"; import "../../utils/Preparable.sol"; /*  * @notice The logic here should really be part of the top-up action  * but is split in a library to circumvent the byte-code size limit  / library TopUpActionLibrary {     using SafeERC20 for IERC20;     using ScaledMath for uint256;     using AddressProviderHelpers for IAddressProvider; /**  * @dev "Locks" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param stakerVaultAddress The address of the staker vault  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function lockFunds(     address stakerVaultAddress,     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) external {     IStakerVault stakerVault = IStakerVault(stakerVaultAddress);      // stake deposit amount     if (depositAmount &gt; 0) {         depositAmount = depositAmount &gt; lockAmount ? lockAmount : depositAmount;         IERC20(token).safeTransferFrom(payer, address(this), depositAmount);         _approve(token, stakerVaultAddress);         stakerVault.stake(depositAmount);         stakerVault.increaseActionLockedBalance(payer, depositAmount);         lockAmount -= depositAmount;     }      // use stake vault allowance if available and required     if (lockAmount &gt; 0) {         uint256 balance = stakerVault.balanceOf(payer);         uint256 allowance = stakerVault.allowance(payer, address(this));         uint256 availableFunds = balance &lt; allowance ? balance : allowance;         if (availableFunds &gt;= lockAmount) {             stakerVault.transferFrom(payer, address(this), lockAmount);             stakerVault.increaseActionLockedBalance(payer, lockAmount);             lockAmount = 0;         }     }      require(lockAmount == 0, Error.INSUFFICIENT_UPDATE_BALANCE); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function calcExchangeAmount(     IAddressProvider addressProvider,     address token,     address actionToken,     uint256 amount ) external view returns (uint256) {     ILiquidityPool pool = addressProvider.getPoolForToken(token);     uint256 rate = pool.exchangeRate();     address underlying = pool.getUnderlying();     require(underlying == actionToken, Error.TOKEN_NOT_USABLE);     return amount.scaledDivRoundUp(rate); }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) private {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  } contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {     using ScaledMath for uint256;     using UncheckedMath for uint256;     using ScaledMath for uint128;     using SafeERC20 for IERC20;     using EnumerableSet for EnumerableSet.AddressSet;     using EnumerableSet for EnumerableSet.Bytes32Set;     using EnumerableExtensions for EnumerableSet.AddressSet;     using AddressProviderHelpers for IAddressProvider;     using SafeCast for uint256; /**  * @dev Temporary struct to hold local variables in execute  * and avoid the stack being "too deep"  */ struct ExecuteLocalVars {     uint256 minActionAmountToTopUp;     uint256 actionTokenAmount;     uint256 depositTotalFeesAmount;     uint256 actionAmountWithFees;     uint256 userFactor;     uint256 rate;     uint256 depositAmountWithFees;     uint256 depositAmountWithoutFees;     uint256 actionFee;     uint256 totalActionTokenAmount;     uint128 totalTopUpAmount;     bool topupResult;     uint256 gasBankBalance;     uint256 initialGas;     uint256 gasConsumed;     uint256 userGasPrice;     uint256 estimatedRequiredGas;     uint256 estimatedRequiredWeiForGas;     uint256 requiredWeiForGas;     uint256 reimbursedWeiForGas;     address underlying;     bool removePosition;     address topUpHandler; }  EnumerableSet.AddressSet private _usableTokens;  uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 550_000;  bytes32 internal constant _ACTION_FEE_KEY = "ActionFee"; bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler"; bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler"; bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";  uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;  IController public immutable controller; IAddressProvider public immutable addressProvider;  EnumerableSet.Bytes32Set internal _supportedProtocols;  /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record) mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;  mapping(address =&gt; RecordMeta[]) internal _userPositions;  EnumerableSet.AddressSet internal _usersWithPositions;  constructor(IController _controller)     Authorization(_controller.addressProvider().getRoleManager()) {     controller = _controller;     addressProvider = controller.addressProvider();     _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE); }  receive() external payable {     // solhint-disable-previous-line no-empty-blocks }  function initialize(     address feeHandler,     bytes32[] calldata protocols,     address[] calldata handlers ) external initializer onlyGovernance {     require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);     _setConfig(_FEE_HANDLER_KEY, feeHandler);     for (uint256 i; i &lt; protocols.length; i = i.uncheckedInc()) {         bytes32 protocolKey = _getProtocolKey(protocols[i]);         _setConfig(protocolKey, handlers[i]);         _updateTopUpHandler(protocols[i], address(0), handlers[i]);     } }  /**  * @notice Register a top up action.  * @dev The `depositAmount`, once converted to units of `actionToken`, must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).  * @param account Account to be topped up (first 20 bytes will typically be the address).  * @param protocol Protocol which holds position to be topped up.  * @param depositAmount Amount of `depositToken` that will be locked.  * @param record containing the data for the position to register  */ function register(     bytes32 account,     bytes32 protocol,     uint128 depositAmount,     Record memory record ) external payable override returns (bool) {     require(record.maxFee != 0, Error.INVALID_MAX_FEE);     require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);     require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);     require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);     require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);     require(         _positions[msg.sender][account][protocol].threshold == 0,         Error.POSITION_ALREADY_EXISTS     );     require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);     require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);      uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *         record.maxFee *         getEstimatedGasUsage();      require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);      uint256 totalLockAmount = _calcExchangeAmount(         record.depositToken,         record.actionToken,         record.totalTopUpAmount     );     _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);      addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);      record.registeredAt = uint64(block.timestamp);     record.depositTokenBalance = totalLockAmount.toUint128();     _positions[msg.sender][account][protocol] = record;     _userPositions[msg.sender].push(RecordMeta(account, protocol));     _usersWithPositions.add(msg.sender);      emit Register(         account,         protocol,         record.threshold,         msg.sender,         record.depositToken,         totalLockAmount,         record.actionToken,         record.singleTopUpAmount,         record.totalTopUpAmount,         record.maxFee,         record.extra     );     return true; }  /**  * @notice See overloaded version of `execute` for more details.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol ) external override returns (bool) {     return execute(payer, account, beneficiary, protocol, 0); }  /**  * @notice Delete a position to back on the given protocol for `account`.  * @param account Account holding the position.  * @param protocol Protocol the position is held on.  * @param unstake If the tokens should be unstaked from vault.  * @return `true` if successful.  */ function resetPosition(     bytes32 account,     bytes32 protocol,     bool unstake ) external override returns (bool) {     address payer = msg.sender;     Record memory position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);      IAddressProvider addressProvider_ = addressProvider;     address vault = addressProvider_.getStakerVault(position.depositToken); // will revert if vault does not exist     IStakerVault staker = IStakerVault(vault);     staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);     if (unstake) {         staker.unstake(position.depositTokenBalance);         IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);     } else {         staker.transfer(payer, position.depositTokenBalance);     }      _removePosition(payer, account, protocol);     addressProvider_.getGasBank().withdrawUnused(payer);     return true; }  /**  * @notice Execute top up handler update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @param protocol Protocol for which a new handler should be executed.  * @return Address of new handler.  */ function executeTopUpHandler(bytes32 protocol) external override returns (address) {     address oldHandler = _getHandler(protocol, false);     address newHandler = _executeAddress(_getProtocolKey(protocol));      _updateTopUpHandler(protocol, oldHandler, newHandler);     return newHandler; }  /**  * @notice Reset new top up handler deadline for a protocol.  * @param protocol Protocol for which top up handler deadline should be reset.  * @return `true` if successful.  */ function resetTopUpHandler(bytes32 protocol) external override onlyGovernance returns (bool) {     return _resetAddressConfig(_getProtocolKey(protocol)); }  /**  * @notice Prepare action fee update.  * @param newActionFee New fee to set.  * @return `true` if success.  */ function prepareActionFee(uint256 newActionFee)     external     override     onlyGovernance     returns (bool) {     require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);     return _prepare(_ACTION_FEE_KEY, newActionFee); }  /**  * @notice Execute action fee update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeActionFee() external override returns (uint256) {     return _executeUInt256(_ACTION_FEE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetActionFee() external override onlyGovernance returns (bool) {     return _resetUInt256Config(_ACTION_FEE_KEY); }  /** Set fee handler */ /**  * @notice Prepare update of fee handler.  * @param handler New fee handler.  * @return `true` if success.  */ function prepareFeeHandler(address handler) external override onlyGovernance returns (bool) {     return _prepare(_FEE_HANDLER_KEY, handler); }  /**  * @notice Execute update of fee handler (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeFeeHandler() external override returns (address) {     return _executeAddress(_FEE_HANDLER_KEY); }  /**  * @notice Reset the handler deadline.  * @return `true` if success.  */ function resetFeeHandler() external override onlyGovernance returns (bool) {     return _resetAddressConfig(_FEE_HANDLER_KEY); }  /**  * @notice Prepare update of estimated gas usage.  * @param gasUsage New estimated gas usage.  * @return `true` if success.  */ function prepareEstimatedGasUsage(uint256 gasUsage)     external     override     onlyGovernance     returns (bool) {     return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage); }  /**  * @notice Execute update of gas usage (with time delay enforced).  * @return `true` if successful.  */ function executeEstimatedGasUsage() external override returns (uint256) {     return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Reset the gas usage deadline.  * @return `true` if success.  */ function resetGasUsage() external override onlyGovernance returns (bool) {     return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Add a new deposit token that is supported by the action.  * @dev There is a separate check for whether the usable token (i.e. deposit token)  *      is swappable for some action token.  * @param token Address of deposit token that can be used by the action.  */ function addUsableToken(address token) external override onlyGovernance returns (bool) {     return _usableTokens.add(token); }  /**  * @notice Computes the total amount of ETH (as wei) required to pay for all  * the top-ups assuming the maximum gas price and the current estimated gas  * usage of a top-up  */ function getEthRequiredForGas(address payer) external view override returns (uint256) {     uint256 totalEthRequired;     RecordMeta[] memory userRecordsMeta = _userPositions[payer];     uint256 gasUsagePerCall = getEstimatedGasUsage();     uint256 length = userRecordsMeta.length;     for (uint256 i; i &lt; length; i = i.uncheckedInc()) {         RecordMeta memory meta = userRecordsMeta[i];         Record memory record = _positions[payer][meta.account][meta.protocol];         uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);         totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;     }     return totalEthRequired; }  /**  * @notice Returns a list of positions for the given payer  */ function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {     return _userPositions[payer]; }  /**  * @notice Get a list supported protocols.  * @return List of supported protocols.  */ function getSupportedProtocols() external view override returns (bytes32[] memory) {     uint256 length = _supportedProtocols.length();     bytes32[] memory protocols = new bytes32[](length);     for (uint256 i; i &lt; length; i = i.uncheckedInc()) {         protocols[i] = _supportedProtocols.at(i);     }     return protocols; }  /*  * @notice Gets a list of users that have an active position.  * @dev Uses cursor pagination.  * @param cursor The cursor for pagination (should start at 0 for first call).  * @param howMany Maximum number of users to return in this pagination request.  * @return users List of users that have an active position.  * @return nextCursor The cursor to use for the next pagination request.  */ function usersWithPositions(uint256 cursor, uint256 howMany)     external     view     override     returns (address[] memory users, uint256 nextCursor) {     uint256 length = _usersWithPositions.length();     if (cursor &gt;= length) return (new address[](0), 0);     if (howMany &gt;= length - cursor) {         howMany = length - cursor;     }      address[] memory usersWithPositions_ = new address[](howMany);     for (uint256 i; i &lt; howMany; i = i.uncheckedInc()) {         usersWithPositions_[i] = _usersWithPositions.at(i + cursor);     }      return (usersWithPositions_, cursor + howMany); }  /**  * @notice Get a list of all tokens usable for this action.  * @dev This refers to all tokens that can be used as deposit tokens.  * @return Array of addresses of usable tokens.  */ function getUsableTokens() external view override returns (address[] memory) {     return _usableTokens.toArray(); }  /**  * @notice Retrieves the topup handler for the given `protocol`  */ function getTopUpHandler(bytes32 protocol) external view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice Successfully tops up a position if it's conditions are met.  * @dev pool and vault funds are rebalanced after withdrawal for top up  * @param payer Account that pays for the top up.  * @param account Account owning the position for top up.  * @param beneficiary Address of the keeper's wallet for fee accrual.  * @param protocol Protocol of the top up position.  * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas  * @return `true` if successful.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol,     uint256 maxWeiForGas ) public override returns (bool) {     require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);      ExecuteLocalVars memory vars;      vars.initialGas = gasleft();      Record storage position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);     require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);     require(block.timestamp &gt; position.registeredAt, Error.CANNOT_EXECUTE_IN_SAME_BLOCK);      vars.topUpHandler = _getHandler(protocol, true);     vars.userFactor = ITopUpHandler(vars.topUpHandler).getUserFactor(account, position.extra);      // ensure that the position is actually below its set user factor threshold     require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);      IAddressProvider addressProvider_ = addressProvider;     IGasBank gasBank = addressProvider_.getGasBank();      // fail early if the user does not have enough funds in the gas bank     // to cover the cost of the transaction     vars.estimatedRequiredGas = getEstimatedGasUsage();     vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;      // compute the gas price that the user will be paying     vars.userGasPrice = block.basefee + position.priorityFee;     if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;     if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;      // ensure the current position allows for the gas to be paid     require(         vars.estimatedRequiredWeiForGas &lt;=             vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,         Error.ESTIMATED_GAS_TOO_HIGH     );      vars.gasBankBalance = gasBank.balanceOf(payer);     // ensure the user has enough funds in the gas bank to cover the gas     require(         vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,         Error.GAS_BANK_BALANCE_TOO_LOW     );      vars.totalTopUpAmount = position.totalTopUpAmount;     vars.actionFee = getActionFee();     // add top-up fees to top-up amount     vars.minActionAmountToTopUp = position.singleTopUpAmount;     vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(         ScaledMath.ONE + vars.actionFee     );      // if the amount that we want to top-up (including fees) is higher than     // the available topup amount, we lower this down to what is left of the position     if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {         vars.actionAmountWithFees = vars.totalTopUpAmount;         vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(             ScaledMath.ONE + vars.actionFee         );     }     ILiquidityPool pool = addressProvider_.getPoolForToken(position.depositToken);     vars.underlying = pool.getUnderlying();     vars.rate = pool.exchangeRate();      // compute the deposit tokens amount with and without fees     // we will need to unstake the amount with fees and to     // swap the amount without fees into action tokens     vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);     if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {         vars.depositAmountWithFees = position.depositTokenBalance;         vars.minActionAmountToTopUp =             (vars.depositAmountWithFees * vars.rate) /             (ScaledMath.ONE + vars.actionFee);     }      // compute amount of LP tokens needed to pay for action     // rate is expressed in actionToken per depositToken     vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);     vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;      // will revert if vault does not exist     address vault = addressProvider_.getStakerVault(position.depositToken);      // unstake deposit tokens including fees     IStakerVault(vault).unstake(vars.depositAmountWithFees);     IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);      // swap the amount without the fees     // as the fees are paid in deposit token, not in action token     vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);      // compute how much of action token was actually redeemed and add fees to it     // this is to ensure that no funds get locked inside the contract     vars.totalActionTokenAmount =         vars.actionTokenAmount +         vars.depositTotalFeesAmount.scaledMul(vars.rate);      // at this point, we have exactly `vars.actionTokenAmount`     // (at least `position.singleTopUpAmount`) of action token     // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract     // solhint-disable-next-line avoid-low-level-calls     uint256 value_;     if (position.actionToken == address(0)) {         value_ = vars.actionTokenAmount;     } else {         _approve(position.actionToken, vars.topUpHandler);     }     vars.topupResult = ITopUpHandler(vars.topUpHandler).topUp{value: value_}(         account,         position.actionToken,         vars.actionTokenAmount,         position.extra     );      require(vars.topupResult, Error.TOP_UP_FAILED);      // totalTopUpAmount is updated to reflect the new "balance" of the position     if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {         position.totalTopUpAmount -= vars.totalActionTokenAmount.toUint128();     } else {         position.totalTopUpAmount = 0;     }      position.depositTokenBalance -= vars.depositAmountWithFees.toUint128();      vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;     _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);     if (vars.removePosition) {         if (position.depositTokenBalance &gt; 0) {             // transfer any unused locked tokens to the payer             IStakerVault(vault).transfer(payer, position.depositTokenBalance);             IStakerVault(vault).decreaseActionLockedBalance(                 payer,                 position.depositTokenBalance             );         }         _removePosition(payer, account, protocol);     }      emit TopUp(         account,         protocol,         payer,         position.depositToken,         vars.depositAmountWithFees,         position.actionToken,         vars.actionTokenAmount     );      // compute gas used and reimburse the keeper by using the     // funds of payer in the gas bank     // TODO: add constant gas consumed for transfer and tx prologue     vars.gasConsumed = vars.initialGas - gasleft();      vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;     if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {         vars.reimbursedWeiForGas = vars.gasBankBalance;     }      // ensure that the keeper is not overpaying     vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;     require(         vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,         Error.GAS_TOO_HIGH     );     gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);     if (vars.removePosition) {         gasBank.withdrawUnused(payer);     }      return true; }  /**  * @notice Prepare new top up handler fee update.  * @dev Setting the address to 0 means that the protocol will no longer be supported.  * @param protocol Protocol for which a new handler should be prepared.  * @param newHandler Address of new handler.  * @return `true` if success.  */ function prepareTopUpHandler(bytes32 protocol, address newHandler)     public     override     onlyGovernance     returns (bool) {     return _prepare(_getProtocolKey(protocol), newHandler); }  /**  * @notice Check if action can be executed.  * @param protocol for which to get the health factor  * @param account for which to get the health factor  * @param extra data to be used by the topup handler  * @return healthFactor of the position  */ function getHealthFactor(     bytes32 protocol,     bytes32 account,     bytes calldata extra ) public view override returns (uint256 healthFactor) {     ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));     return topUpHandler.getUserFactor(account, extra); }  function getHandler(bytes32 protocol) public view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice returns the current estimated gas usage  */ function getEstimatedGasUsage() public view override returns (uint256) {     return currentUInts256[_ESTIMATED_GAS_USAGE_KEY]; }  /**  * @notice Returns the current action fee  */ function getActionFee() public view override returns (uint256) {     return currentUInts256[_ACTION_FEE_KEY]; }  /**  * @notice Returns the current fee handler  */ function getFeeHandler() public view override returns (address) {     return currentAddresses[_FEE_HANDLER_KEY]; }  /**  * @notice Get the record for a position.  * @param payer Registered payer of the position.  * @param account Address holding the position.  * @param protocol Protocol where the position is held.  */ function getPosition(     address payer,     bytes32 account,     bytes32 protocol ) public view override returns (Record memory) {     return _positions[payer][account][protocol]; }  /**  * @notice Check whether a token is usable as a deposit token.  * @param token Address of token to check.  * @return True if token is usable as a deposit token for this action.  */ function isUsable(address token) public view override returns (bool) {     return _usableTokens.contains(token); }  function _updateTopUpHandler(     bytes32 protocol,     address oldHandler,     address newHandler ) internal {     if (newHandler == address(0)) {         _supportedProtocols.remove(protocol);     } else if (oldHandler == address(0)) {         _supportedProtocols.add(protocol);     } }  /**  * @dev Pays fees to the feeHandler  * @param payer The account who's position the fees are charged on  * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)  * @param feeAmount The amount in tokens to pay as fees  * @param depositToken The LpToken used to pay the fees  */ function _payFees(     address payer,     address beneficiary,     uint256 feeAmount,     address depositToken ) internal {     address feeHandler = getFeeHandler();     IERC20(depositToken).safeApprove(feeHandler, feeAmount);     IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken); }  /**  * @dev "Locks" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function _lockFunds(     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) internal {     address stakerVaultAddress = addressProvider.getStakerVault(token);     TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount); }  function _removePosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     delete _positions[payer][account][protocol];     _removeUserPosition(payer, account, protocol);     if (_userPositions[payer].length == 0) {         _usersWithPositions.remove(payer);     }     emit Deregister(payer, account, protocol); }  function _removeUserPosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     RecordMeta[] storage positionsMeta = _userPositions[payer];     uint256 length = positionsMeta.length;     for (uint256 i; i &lt; length; i = i.uncheckedInc()) {         RecordMeta storage positionMeta = positionsMeta[i];         if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {             positionsMeta[i] = positionsMeta[length - 1];             positionsMeta.pop();             return;         }     } }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) internal {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the `actionToken`.  */ function _calcExchangeAmount(     address token,     address actionToken,     uint256 amount ) internal view returns (uint256) {     return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount); }  function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {     address handler = currentAddresses[_getProtocolKey(protocol)];     require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);     return handler; }  function _isSwappable(address depositToken, address toToken) internal view returns (bool) {     ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);     return pool.getUnderlying() == toToken; }  function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {     return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol)); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '', 'ideas': ' 1'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 12:31:12 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.10; import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol"; import "@openzeppelin/contracts/utils/math/SafeCast.sol"; import "../../../interfaces/IGasBank.sol"; import "../../../interfaces/pool/ILiquidityPool.sol"; import "../../../interfaces/IController.sol"; import "../../../interfaces/IStakerVault.sol"; import "../../../interfaces/actions/topup/ITopUpHandler.sol"; import "../../../interfaces/actions/topup/ITopUpAction.sol"; import "../../../interfaces/actions/IActionFeeHandler.sol"; import "../../../libraries/AddressProviderHelpers.sol"; import "../../../libraries/Errors.sol"; import "../../../libraries/ScaledMath.sol"; import "../../../libraries/EnumerableExtensions.sol"; import "../../../libraries/UncheckedMath.sol"; import "../../access/Authorization.sol"; import "../../utils/Preparable.sol"; /*  * @notice The logic here should really be part of the top-up action  * but is split in a library to circumvent the byte-code size limit  / library TopUpActionLibrary {     using SafeERC20 for IERC20;     using ScaledMath for uint256;     using AddressProviderHelpers for IAddressProvider; /**  * @dev "Locks" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param stakerVaultAddress The address of the staker vault  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function lockFunds(     address stakerVaultAddress,     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) external {     IStakerVault stakerVault = IStakerVault(stakerVaultAddress);      // stake deposit amount     if (depositAmount &gt; 0) {         depositAmount = depositAmount &gt; lockAmount ? lockAmount : depositAmount;         IERC20(token).safeTransferFrom(payer, address(this), depositAmount);         _approve(token, stakerVaultAddress);         stakerVault.stake(depositAmount);         stakerVault.increaseActionLockedBalance(payer, depositAmount);         lockAmount -= depositAmount;     }      // use stake vault allowance if available and required     if (lockAmount &gt; 0) {         uint256 balance = stakerVault.balanceOf(payer);         uint256 allowance = stakerVault.allowance(payer, address(this));         uint256 availableFunds = balance &lt; allowance ? balance : allowance;         if (availableFunds &gt;= lockAmount) {             stakerVault.transferFrom(payer, address(this), lockAmount);             stakerVault.increaseActionLockedBalance(payer, lockAmount);             lockAmount = 0;         }     }      require(lockAmount == 0, Error.INSUFFICIENT_UPDATE_BALANCE); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function calcExchangeAmount(     IAddressProvider addressProvider,     address token,     address actionToken,     uint256 amount ) external view returns (uint256) {     ILiquidityPool pool = addressProvider.getPoolForToken(token);     uint256 rate = pool.exchangeRate();     address underlying = pool.getUnderlying();     require(underlying == actionToken, Error.TOKEN_NOT_USABLE);     return amount.scaledDivRoundUp(rate); }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) private {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  } contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {     using ScaledMath for uint256;     using UncheckedMath for uint256;     using ScaledMath for uint128;     using SafeERC20 for IERC20;     using EnumerableSet for EnumerableSet.AddressSet;     using EnumerableSet for EnumerableSet.Bytes32Set;     using EnumerableExtensions for EnumerableSet.AddressSet;     using AddressProviderHelpers for IAddressProvider;     using SafeCast for uint256; /**  * @dev Temporary struct to hold local variables in execute  * and avoid the stack being "too deep"  */ struct ExecuteLocalVars {     uint256 minActionAmountToTopUp;     uint256 actionTokenAmount;     uint256 depositTotalFeesAmount;     uint256 actionAmountWithFees;     uint256 userFactor;     uint256 rate;     uint256 depositAmountWithFees;     uint256 depositAmountWithoutFees;     uint256 actionFee;     uint256 totalActionTokenAmount;     uint128 totalTopUpAmount;     bool topupResult;     uint256 gasBankBalance;     uint256 initialGas;     uint256 gasConsumed;     uint256 userGasPrice;     uint256 estimatedRequiredGas;     uint256 estimatedRequiredWeiForGas;     uint256 requiredWeiForGas;     uint256 reimbursedWeiForGas;     address underlying;     bool removePosition;     address topUpHandler; }  EnumerableSet.AddressSet private _usableTokens;  uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 550_000;  bytes32 internal constant _ACTION_FEE_KEY = "ActionFee"; bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler"; bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler"; bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";  uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;  IController public immutable controller; IAddressProvider public immutable addressProvider;  EnumerableSet.Bytes32Set internal _supportedProtocols;  /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record) mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;  mapping(address =&gt; RecordMeta[]) internal _userPositions;  EnumerableSet.AddressSet internal _usersWithPositions;  constructor(IController _controller)     Authorization(_controller.addressProvider().getRoleManager()) {     controller = _controller;     addressProvider = controller.addressProvider();     _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE); }  receive() external payable {     // solhint-disable-previous-line no-empty-blocks }  function initialize(     address feeHandler,     bytes32[] calldata protocols,     address[] calldata handlers ) external initializer onlyGovernance {     require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);     _setConfig(_FEE_HANDLER_KEY, feeHandler);     for (uint256 i; i &lt; protocols.length; i = i.uncheckedInc()) {         bytes32 protocolKey = _getProtocolKey(protocols[i]);         _setConfig(protocolKey, handlers[i]);         _updateTopUpHandler(protocols[i], address(0), handlers[i]);     } }  /**  * @notice Register a top up action.  * @dev The `depositAmount`, once converted to units of `actionToken`, must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).  * @param account Account to be topped up (first 20 bytes will typically be the address).  * @param protocol Protocol which holds position to be topped up.  * @param depositAmount Amount of `depositToken` that will be locked.  * @param record containing the data for the position to register  */ function register(     bytes32 account,     bytes32 protocol,     uint128 depositAmount,     Record memory record ) external payable override returns (bool) {     require(record.maxFee != 0, Error.INVALID_MAX_FEE);     require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);     require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);     require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);     require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);     require(         _positions[msg.sender][account][protocol].threshold == 0,         Error.POSITION_ALREADY_EXISTS     );     require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);     require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);      uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *         record.maxFee *         getEstimatedGasUsage();      require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);      uint256 totalLockAmount = _calcExchangeAmount(         record.depositToken,         record.actionToken,         record.totalTopUpAmount     );     _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);      addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);      record.registeredAt = uint64(block.timestamp);     record.depositTokenBalance = totalLockAmount.toUint128();     _positions[msg.sender][account][protocol] = record;     _userPositions[msg.sender].push(RecordMeta(account, protocol));     _usersWithPositions.add(msg.sender);      emit Register(         account,         protocol,         record.threshold,         msg.sender,         record.depositToken,         totalLockAmount,         record.actionToken,         record.singleTopUpAmount,         record.totalTopUpAmount,         record.maxFee,         record.extra     );     return true; }  /**  * @notice See overloaded version of `execute` for more details.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol ) external override returns (bool) {     return execute(payer, account, beneficiary, protocol, 0); }  /**  * @notice Delete a position to back on the given protocol for `account`.  * @param account Account holding the position.  * @param protocol Protocol the position is held on.  * @param unstake If the tokens should be unstaked from vault.  * @return `true` if successful.  */ function resetPosition(     bytes32 account,     bytes32 protocol,     bool unstake ) external override returns (bool) {     address payer = msg.sender;     Record memory position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);      IAddressProvider addressProvider_ = addressProvider;     address vault = addressProvider_.getStakerVault(position.depositToken); // will revert if vault does not exist     IStakerVault staker = IStakerVault(vault);     staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);     if (unstake) {         staker.unstake(position.depositTokenBalance);         IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);     } else {         staker.transfer(payer, position.depositTokenBalance);     }      _removePosition(payer, account, protocol);     addressProvider_.getGasBank().withdrawUnused(payer);     return true; }  /**  * @notice Execute top up handler update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @param protocol Protocol for which a new handler should be executed.  * @return Address of new handler.  */ function executeTopUpHandler(bytes32 protocol) external override returns (address) {     address oldHandler = _getHandler(protocol, false);     address newHandler = _executeAddress(_getProtocolKey(protocol));      _updateTopUpHandler(protocol, oldHandler, newHandler);     return newHandler; }  /**  * @notice Reset new top up handler deadline for a protocol.  * @param protocol Protocol for which top up handler deadline should be reset.  * @return `true` if successful.  */ function resetTopUpHandler(bytes32 protocol) external override onlyGovernance returns (bool) {     return _resetAddressConfig(_getProtocolKey(protocol)); }  /**  * @notice Prepare action fee update.  * @param newActionFee New fee to set.  * @return `true` if success.  */ function prepareActionFee(uint256 newActionFee)     external     override     onlyGovernance     returns (bool) {     require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);     return _prepare(_ACTION_FEE_KEY, newActionFee); }  /**  * @notice Execute action fee update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeActionFee() external override returns (uint256) {     return _executeUInt256(_ACTION_FEE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetActionFee() external override onlyGovernance returns (bool) {     return _resetUInt256Config(_ACTION_FEE_KEY); }  /** Set fee handler */ /**  * @notice Prepare update of fee handler.  * @param handler New fee handler.  * @return `true` if success.  */ function prepareFeeHandler(address handler) external override onlyGovernance returns (bool) {     return _prepare(_FEE_HANDLER_KEY, handler); }  /**  * @notice Execute update of fee handler (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeFeeHandler() external override returns (address) {     return _executeAddress(_FEE_HANDLER_KEY); }  /**  * @notice Reset the handler deadline.  * @return `true` if success.  */ function resetFeeHandler() external override onlyGovernance returns (bool) {     return _resetAddressConfig(_FEE_HANDLER_KEY); }  /**  * @notice Prepare update of estimated gas usage.  * @param gasUsage New estimated gas usage.  * @return `true` if success.  */ function prepareEstimatedGasUsage(uint256 gasUsage)     external     override     onlyGovernance     returns (bool) {     return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage); }  /**  * @notice Execute update of gas usage (with time delay enforced).  * @return `true` if successful.  */ function executeEstimatedGasUsage() external override returns (uint256) {     return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Reset the gas usage deadline.  * @return `true` if success.  */ function resetGasUsage() external override onlyGovernance returns (bool) {     return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Add a new deposit token that is supported by the action.  * @dev There is a separate check for whether the usable token (i.e. deposit token)  *      is swappable for some action token.  * @param token Address of deposit token that can be used by the action.  */ function addUsableToken(address token) external override onlyGovernance returns (bool) {     return _usableTokens.add(token); }  /**  * @notice Computes the total amount of ETH (as wei) required to pay for all  * the top-ups assuming the maximum gas price and the current estimated gas  * usage of a top-up  */ function getEthRequiredForGas(address payer) external view override returns (uint256) {     uint256 totalEthRequired;     RecordMeta[] memory userRecordsMeta = _userPositions[payer];     uint256 gasUsagePerCall = getEstimatedGasUsage();     uint256 length = userRecordsMeta.length;     for (uint256 i; i &lt; length; i = i.uncheckedInc()) {         RecordMeta memory meta = userRecordsMeta[i];         Record memory record = _positions[payer][meta.account][meta.protocol];         uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);         totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;     }     return totalEthRequired; }  /**  * @notice Returns a list of positions for the given payer  */ function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {     return _userPositions[payer]; }  /**  * @notice Get a list supported protocols.  * @return List of supported protocols.  */ function getSupportedProtocols() external view override returns (bytes32[] memory) {     uint256 length = _supportedProtocols.length();     bytes32[] memory protocols = new bytes32[](length);     for (uint256 i; i &lt; length; i = i.uncheckedInc()) {         protocols[i] = _supportedProtocols.at(i);     }     return protocols; }  /*  * @notice Gets a list of users that have an active position.  * @dev Uses cursor pagination.  * @param cursor The cursor for pagination (should start at 0 for first call).  * @param howMany Maximum number of users to return in this pagination request.  * @return users List of users that have an active position.  * @return nextCursor The cursor to use for the next pagination request.  */ function usersWithPositions(uint256 cursor, uint256 howMany)     external     view     override     returns (address[] memory users, uint256 nextCursor) {     uint256 length = _usersWithPositions.length();     if (cursor &gt;= length) return (new address[](0), 0);     if (howMany &gt;= length - cursor) {         howMany = length - cursor;     }      address[] memory usersWithPositions_ = new address[](howMany);     for (uint256 i; i &lt; howMany; i = i.uncheckedInc()) {         usersWithPositions_[i] = _usersWithPositions.at(i + cursor);     }      return (usersWithPositions_, cursor + howMany); }  /**  * @notice Get a list of all tokens usable for this action.  * @dev This refers to all tokens that can be used as deposit tokens.  * @return Array of addresses of usable tokens.  */ function getUsableTokens() external view override returns (address[] memory) {     return _usableTokens.toArray(); }  /**  * @notice Retrieves the topup handler for the given `protocol`  */ function getTopUpHandler(bytes32 protocol) external view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice Successfully tops up a position if it's conditions are met.  * @dev pool and vault funds are rebalanced after withdrawal for top up  * @param payer Account that pays for the top up.  * @param account Account owning the position for top up.  * @param beneficiary Address of the keeper's wallet for fee accrual.  * @param protocol Protocol of the top up position.  * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas  * @return `true` if successful.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol,     uint256 maxWeiForGas ) public override returns (bool) {     require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);      ExecuteLocalVars memory vars;      vars.initialGas = gasleft();      Record storage position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);     require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);     require(block.timestamp &gt; position.registeredAt, Error.CANNOT_EXECUTE_IN_SAME_BLOCK);      vars.topUpHandler = _getHandler(protocol, true);     vars.userFactor = ITopUpHandler(vars.topUpHandler).getUserFactor(account, position.extra);      // ensure that the position is actually below its set user factor threshold     require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);      IAddressProvider addressProvider_ = addressProvider;     IGasBank gasBank = addressProvider_.getGasBank();      // fail early if the user does not have enough funds in the gas bank     // to cover the cost of the transaction     vars.estimatedRequiredGas = getEstimatedGasUsage();     vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;      // compute the gas price that the user will be paying     vars.userGasPrice = block.basefee + position.priorityFee;     if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;     if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;      // ensure the current position allows for the gas to be paid     require(         vars.estimatedRequiredWeiForGas &lt;=             vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,         Error.ESTIMATED_GAS_TOO_HIGH     );      vars.gasBankBalance = gasBank.balanceOf(payer);     // ensure the user has enough funds in the gas bank to cover the gas     require(         vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,         Error.GAS_BANK_BALANCE_TOO_LOW     );      vars.totalTopUpAmount = position.totalTopUpAmount;     vars.actionFee = getActionFee();     // add top-up fees to top-up amount     vars.minActionAmountToTopUp = position.singleTopUpAmount;     vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(         ScaledMath.ONE + vars.actionFee     );      // if the amount that we want to top-up (including fees) is higher than     // the available topup amount, we lower this down to what is left of the position     if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {         vars.actionAmountWithFees = vars.totalTopUpAmount;         vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(             ScaledMath.ONE + vars.actionFee         );     }     ILiquidityPool pool = addressProvider_.getPoolForToken(position.depositToken);     vars.underlying = pool.getUnderlying();     vars.rate = pool.exchangeRate();      // compute the deposit tokens amount with and without fees     // we will need to unstake the amount with fees and to     // swap the amount without fees into action tokens     vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);     if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {         vars.depositAmountWithFees = position.depositTokenBalance;         vars.minActionAmountToTopUp =             (vars.depositAmountWithFees * vars.rate) /             (ScaledMath.ONE + vars.actionFee);     }      // compute amount of LP tokens needed to pay for action     // rate is expressed in actionToken per depositToken     vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);     vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;      // will revert if vault does not exist     address vault = addressProvider_.getStakerVault(position.depositToken);      // unstake deposit tokens including fees     IStakerVault(vault).unstake(vars.depositAmountWithFees);     IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);      // swap the amount without the fees     // as the fees are paid in deposit token, not in action token     vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);      // compute how much of action token was actually redeemed and add fees to it     // this is to ensure that no funds get locked inside the contract     vars.totalActionTokenAmount =         vars.actionTokenAmount +         vars.depositTotalFeesAmount.scaledMul(vars.rate);      // at this point, we have exactly `vars.actionTokenAmount`     // (at least `position.singleTopUpAmount`) of action token     // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract     // solhint-disable-next-line avoid-low-level-calls     uint256 value_;     if (position.actionToken == address(0)) {         value_ = vars.actionTokenAmount;     } else {         _approve(position.actionToken, vars.topUpHandler);     }     vars.topupResult = ITopUpHandler(vars.topUpHandler).topUp{value: value_}(         account,         position.actionToken,         vars.actionTokenAmount,         position.extra     );      require(vars.topupResult, Error.TOP_UP_FAILED);      // totalTopUpAmount is updated to reflect the new "balance" of the position     if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {         position.totalTopUpAmount -= vars.totalActionTokenAmount.toUint128();     } else {         position.totalTopUpAmount = 0;     }      position.depositTokenBalance -= vars.depositAmountWithFees.toUint128();      vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;     _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);     if (vars.removePosition) {         if (position.depositTokenBalance &gt; 0) {             // transfer any unused locked tokens to the payer             IStakerVault(vault).transfer(payer, position.depositTokenBalance);             IStakerVault(vault).decreaseActionLockedBalance(                 payer,                 position.depositTokenBalance             );         }         _removePosition(payer, account, protocol);     }      emit TopUp(         account,         protocol,         payer,         position.depositToken,         vars.depositAmountWithFees,         position.actionToken,         vars.actionTokenAmount     );      // compute gas used and reimburse the keeper by using the     // funds of payer in the gas bank     // TODO: add constant gas consumed for transfer and tx prologue     vars.gasConsumed = vars.initialGas - gasleft();      vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;     if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {         vars.reimbursedWeiForGas = vars.gasBankBalance;     }      // ensure that the keeper is not overpaying     vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;     require(         vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,         Error.GAS_TOO_HIGH     );     gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);     if (vars.removePosition) {         gasBank.withdrawUnused(payer);     }      return true; }  /**  * @notice Prepare new top up handler fee update.  * @dev Setting the address to 0 means that the protocol will no longer be supported.  * @param protocol Protocol for which a new handler should be prepared.  * @param newHandler Address of new handler.  * @return `true` if success.  */ function prepareTopUpHandler(bytes32 protocol, address newHandler)     public     override     onlyGovernance     returns (bool) {     return _prepare(_getProtocolKey(protocol), newHandler); }  /**  * @notice Check if action can be executed.  * @param protocol for which to get the health factor  * @param account for which to get the health factor  * @param extra data to be used by the topup handler  * @return healthFactor of the position  */ function getHealthFactor(     bytes32 protocol,     bytes32 account,     bytes calldata extra ) public view override returns (uint256 healthFactor) {     ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));     return topUpHandler.getUserFactor(account, extra); }  function getHandler(bytes32 protocol) public view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice returns the current estimated gas usage  */ function getEstimatedGasUsage() public view override returns (uint256) {     return currentUInts256[_ESTIMATED_GAS_USAGE_KEY]; }  /**  * @notice Returns the current action fee  */ function getActionFee() public view override returns (uint256) {     return currentUInts256[_ACTION_FEE_KEY]; }  /**  * @notice Returns the current fee handler  */ function getFeeHandler() public view override returns (address) {     return currentAddresses[_FEE_HANDLER_KEY]; }  /**  * @notice Get the record for a position.  * @param payer Registered payer of the position.  * @param account Address holding the position.  * @param protocol Protocol where the position is held.  */ function getPosition(     address payer,     bytes32 account,     bytes32 protocol ) public view override returns (Record memory) {     return _positions[payer][account][protocol]; }  /**  * @notice Check whether a token is usable as a deposit token.  * @param token Address of token to check.  * @return True if token is usable as a deposit token for this action.  */ function isUsable(address token) public view override returns (bool) {     return _usableTokens.contains(token); }  function _updateTopUpHandler(     bytes32 protocol,     address oldHandler,     address newHandler ) internal {     if (newHandler == address(0)) {         _supportedProtocols.remove(protocol);     } else if (oldHandler == address(0)) {         _supportedProtocols.add(protocol);     } }  /**  * @dev Pays fees to the feeHandler  * @param payer The account who's position the fees are charged on  * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)  * @param feeAmount The amount in tokens to pay as fees  * @param depositToken The LpToken used to pay the fees  */ function _payFees(     address payer,     address beneficiary,     uint256 feeAmount,     address depositToken ) internal {     address feeHandler = getFeeHandler();     IERC20(depositToken).safeApprove(feeHandler, feeAmount);     IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken); }  /**  * @dev "Locks" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function _lockFunds(     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) internal {     address stakerVaultAddress = addressProvider.getStakerVault(token);     TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount); }  function _removePosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     delete _positions[payer][account][protocol];     _removeUserPosition(payer, account, protocol);     if (_userPositions[payer].length == 0) {         _usersWithPositions.remove(payer);     }     emit Deregister(payer, account, protocol); }  function _removeUserPosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     RecordMeta[] storage positionsMeta = _userPositions[payer];     uint256 length = positionsMeta.length;     for (uint256 i; i &lt; length; i = i.uncheckedInc()) {         RecordMeta storage positionMeta = positionsMeta[i];         if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {             positionsMeta[i] = positionsMeta[length - 1];             positionsMeta.pop();             return;         }     } }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) internal {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the `actionToken`.  */ function _calcExchangeAmount(     address token,     address actionToken,     uint256 amount ) internal view returns (uint256) {     return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount); }  function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {     address handler = currentAddresses[_getProtocolKey(protocol)];     require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);     return handler; }  function _isSwappable(address depositToken, address toToken) internal view returns (bool) {     ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);     return pool.getUnderlying() == toToken; }  function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {     return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol)); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 12:31:12 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.10;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";
import "@openzeppelin/contracts/utils/math/SafeCast.sol";

import "../../../interfaces/IGasBank.sol";
import "../../../interfaces/pool/ILiquidityPool.sol";
import "../../../interfaces/IController.sol";
import "../../../interfaces/IStakerVault.sol";
import "../../../interfaces/actions/topup/ITopUpHandler.sol";
import "../../../interfaces/actions/topup/ITopUpAction.sol";
import "../../../interfaces/actions/IActionFeeHandler.sol";

import "../../../libraries/AddressProviderHelpers.sol";
import "../../../libraries/Errors.sol";
import "../../../libraries/ScaledMath.sol";
import "../../../libraries/EnumerableExtensions.sol";
import "../../../libraries/UncheckedMath.sol";

import "../../access/Authorization.sol";
import "../../utils/Preparable.sol";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param stakerVaultAddress The address of the staker vault
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > lockAmount ? lockAmount : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            _approve(token, stakerVaultAddress);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            lockAmount -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (lockAmount > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= lockAmount) {
                stakerVault.transferFrom(payer, address(this), lockAmount);
                stakerVault.increaseActionLockedBalance(payer, lockAmount);
                lockAmount = 0;
            }
        }

        require(lockAmount == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        require(underlying == actionToken, Error.TOKEN_NOT_USABLE);
        return amount.scaledDivRoundUp(rate);
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) private {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using UncheckedMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;
    using SafeCast for uint256;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being "too deep"
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
        address topUpHandler;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 550_000;

    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";
    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        for (uint256 i; i < protocols.length; i = i.uncheckedInc()) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount`, once converted to units of `actionToken`, must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param protocol Protocol which holds position to be topped up.
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable override returns (bool) {
        require(record.maxFee != 0, Error.INVALID_MAX_FEE);
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.registeredAt = uint64(block.timestamp);
        record.depositTokenBalance = totalLockAmount.toUint128();
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        IAddressProvider addressProvider_ = addressProvider;
        address vault = addressProvider_.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider_.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external override onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee)
        external
        override
        onlyGovernance
        returns (bool)
    {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external override onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external override onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external override onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage)
        external
        override
        onlyGovernance
        returns (bool)
    {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external override returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external override onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i; i < howMany; i = i.uncheckedInc()) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);
        require(block.timestamp > position.registeredAt, Error.CANNOT_EXECUTE_IN_SAME_BLOCK);

        vars.topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(vars.topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IAddressProvider addressProvider_ = addressProvider;
        IGasBank gasBank = addressProvider_.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider_.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider_.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        uint256 value_;
        if (position.actionToken == address(0)) {
            value_ = vars.actionTokenAmount;
        } else {
            _approve(position.actionToken, vars.topUpHandler);
        }
        vars.topupResult = ITopUpHandler(vars.topUpHandler).topUp{value: value_}(
            account,
            position.actionToken,
            vars.actionTokenAmount,
            position.extra
        );

        require(vars.topupResult, Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new "balance" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= vars.totalActionTokenAmount.toUint128();
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= vars.depositAmountWithFees.toUint128();

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the address to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        override
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes calldata extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view override returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the `actionToken`.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        return pool.getUnderlying() == toToken;
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-01-09 12:31:18 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 12:31:18 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 7711
completion_tokens: 733
total_tokens: 8444
cost: $-1.000000


[2024-01-09 12:31:18 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.10;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";
import "@openzeppelin/contracts/utils/math/SafeCast.sol";

import "../../../interfaces/IGasBank.sol";
import "../../../interfaces/pool/ILiquidityPool.sol";
import "../../../interfaces/IController.sol";
import "../../../interfaces/IStakerVault.sol";
import "../../../interfaces/actions/topup/ITopUpHandler.sol";
import "../../../interfaces/actions/topup/ITopUpAction.sol";
import "../../../interfaces/actions/IActionFeeHandler.sol";

import "../../../libraries/AddressProviderHelpers.sol";
import "../../../libraries/Errors.sol";
import "../../../libraries/ScaledMath.sol";
import "../../../libraries/EnumerableExtensions.sol";
import "../../../libraries/UncheckedMath.sol";

import "../../access/Authorization.sol";
import "../../utils/Preparable.sol";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param stakerVaultAddress The address of the staker vault
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > lockAmount ? lockAmount : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            _approve(token, stakerVaultAddress);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            lockAmount -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (lockAmount > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= lockAmount) {
                stakerVault.transferFrom(payer, address(this), lockAmount);
                stakerVault.increaseActionLockedBalance(payer, lockAmount);
                lockAmount = 0;
            }
        }

        require(lockAmount == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        require(underlying == actionToken, Error.TOKEN_NOT_USABLE);
        return amount.scaledDivRoundUp(rate);
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) private {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using UncheckedMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;
    using SafeCast for uint256;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being "too deep"
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
        address topUpHandler;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 550_000;

    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";
    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        for (uint256 i; i < protocols.length; i = i.uncheckedInc()) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount`, once converted to units of `actionToken`, must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param protocol Protocol which holds position to be topped up.
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable override returns (bool) {
        require(record.maxFee != 0, Error.INVALID_MAX_FEE);
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.registeredAt = uint64(block.timestamp);
        record.depositTokenBalance = totalLockAmount.toUint128();
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        IAddressProvider addressProvider_ = addressProvider;
        address vault = addressProvider_.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider_.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external override onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee)
        external
        override
        onlyGovernance
        returns (bool)
    {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external override onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external override onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external override onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage)
        external
        override
        onlyGovernance
        returns (bool)
    {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external override returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external override onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i; i < howMany; i = i.uncheckedInc()) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);
        require(block.timestamp > position.registeredAt, Error.CANNOT_EXECUTE_IN_SAME_BLOCK);

        vars.topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(vars.topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IAddressProvider addressProvider_ = addressProvider;
        IGasBank gasBank = addressProvider_.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider_.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider_.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        uint256 value_;
        if (position.actionToken == address(0)) {
            value_ = vars.actionTokenAmount;
        } else {
            _approve(position.actionToken, vars.topUpHandler);
        }
        vars.topupResult = ITopUpHandler(vars.topUpHandler).topUp{value: value_}(
            account,
            position.actionToken,
            vars.actionTokenAmount,
            position.extra
        );

        require(vars.topupResult, Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new "balance" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= vars.totalActionTokenAmount.toUint128();
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= vars.depositAmountWithFees.toUint128();

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the address to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        override
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes calldata extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view override returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the `actionToken`.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        return pool.getUnderlying() == toToken;
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
.]

Based on the provided smart contract code, here is a summary of the potential security vulnerabilities identified:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - The contract allows external calls to other contracts (e.g., `ITopUpHandler`, `IStakerVault`, and `IGasBank`) which may lead to reentrancy attacks if not properly guarded. Functions that transfer tokens or Ether should be designed to prevent reentrancy.

2. **Gas Limit and Loops**:
   - The `execute` function contains loops that could potentially run out of gas if the number of user positions is large. This could lead to denial of service (DoS) if the gas limit is exceeded.

3. **Insufficient Input Validation**:
   - Some functions do not have adequate checks for input parameters. For example, in the `register` function, while there are checks for `record.maxFee`, `record.singleTopUpAmount`, and `record.threshold`, there could be additional checks to ensure that `record.depositToken` and `record.actionToken` are valid addresses.

4. **Lack of Access Control**:
   - Functions that modify critical state variables (like `initialize`, `prepareActionFee`, etc.) should have stricter access control to ensure that only authorized users (e.g., governance) can call them. While some functions have the `onlyGovernance` modifier, others do not.

5. **Potential for Integer Overflow/Underflow**:
   - Although Solidity 0.8.x has built-in overflow/underflow protection, any arithmetic operations that involve external inputs should still be carefully handled to avoid unexpected behavior.

6. **Improper Handling of Ether**:
   - The contract accepts Ether through the `receive()` function but does not have a mechanism to withdraw or manage the Ether effectively. This could lead to funds being locked in the contract.

7. **Token Approval Issues**:
   - The `_approve` function is called multiple times without checking if the approval was successful. This could lead to issues if the token contract does not behave as expected.

8. **Lack of Event Emission**:
   - Some state-changing functions do not emit events, which can make it difficult to track changes on-chain. For example, the `_removePosition` function should emit an event when a position is removed.

### Comprehensive Analysis Report:

The provided smart contract code exhibits several security vulnerabilities that could potentially be exploited by malicious actors. The most critical issues include the risk of reentrancy attacks, which could allow an attacker to manipulate the contract's state during external calls. Additionally, the presence of loops in functions like `execute` could lead to gas exhaustion, making the contract susceptible to denial of service attacks.

Input validation is another area of concern, as insufficient checks could allow invalid data to be processed, leading to unexpected behavior or state corruption. Furthermore, the lack of robust access control mechanisms could enable unauthorized users to modify critical parameters, undermining the integrity of the contract.

While the contract is built on Solidity 0.8.x, which provides built-in protections against integer overflow and underflow, careful handling of arithmetic operations involving external inputs is still necessary. The management of Ether within the contract also raises concerns, as there is no clear mechanism for withdrawal or utilization of funds, potentially leading to locked assets.

Overall, the contract requires a thorough review and remediation of the identified vulnerabilities to ensure its security and reliability. Implementing best practices such as reentrancy guards, comprehensive input validation, proper access controls, and event emissions will significantly enhance the contract's security posture.

[2024-01-09 12:31:18 INFO] **[Seminar Conclusion]**:

 Based on the provided smart contract code, here is a summary of the potential security vulnerabilities identified:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - The contract allows external calls to other contracts (e.g., `ITopUpHandler`, `IStakerVault`, and `IGasBank`) which may lead to reentrancy attacks if not properly guarded. Functions that transfer tokens or Ether should be designed to prevent reentrancy.

2. **Gas Limit and Loops**:
   - The `execute` function contains loops that could potentially run out of gas if the number of user positions is large. This could lead to denial of service (DoS) if the gas limit is exceeded.

3. **Insufficient Input Validation**:
   - Some functions do not have adequate checks for input parameters. For example, in the `register` function, while there are checks for `record.maxFee`, `record.singleTopUpAmount`, and `record.threshold`, there could be additional checks to ensure that `record.depositToken` and `record.actionToken` are valid addresses.

4. **Lack of Access Control**:
   - Functions that modify critical state variables (like `initialize`, `prepareActionFee`, etc.) should have stricter access control to ensure that only authorized users (e.g., governance) can call them. While some functions have the `onlyGovernance` modifier, others do not.

5. **Potential for Integer Overflow/Underflow**:
   - Although Solidity 0.8.x has built-in overflow/underflow protection, any arithmetic operations that involve external inputs should still be carefully handled to avoid unexpected behavior.

6. **Improper Handling of Ether**:
   - The contract accepts Ether through the `receive()` function but does not have a mechanism to withdraw or manage the Ether effectively. This could lead to funds being locked in the contract.

7. **Token Approval Issues**:
   - The `_approve` function is called multiple times without checking if the approval was successful. This could lead to issues if the token contract does not behave as expected.

8. **Lack of Event Emission**:
   - Some state-changing functions do not emit events, which can make it difficult to track changes on-chain. For example, the `_removePosition` function should emit an event when a position is removed.

### Comprehensive Analysis Report:

The provided smart contract code exhibits several security vulnerabilities that could potentially be exploited by malicious actors. The most critical issues include the risk of reentrancy attacks, which could allow an attacker to manipulate the contract's state during external calls. Additionally, the presence of loops in functions like `execute` could lead to gas exhaustion, making the contract susceptible to denial of service attacks.

Input validation is another area of concern, as insufficient checks could allow invalid data to be processed, leading to unexpected behavior or state corruption. Furthermore, the lack of robust access control mechanisms could enable unauthorized users to modify critical parameters, undermining the integrity of the contract.

While the contract is built on Solidity 0.8.x, which provides built-in protections against integer overflow and underflow, careful handling of arithmetic operations involving external inputs is still necessary. The management of Ether within the contract also raises concerns, as there is no clear mechanism for withdrawal or utilization of funds, potentially leading to locked assets.

Overall, the contract requires a thorough review and remediation of the identified vulnerabilities to ensure its security and reliability. Implementing best practices such as reentrancy guards, comprehensive input validation, proper access controls, and event emissions will significantly enhance the contract's security posture.

[2024-01-09 12:31:21 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.10; import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol"; import "@openzeppelin/contracts/utils/math/SafeCast.sol"; import "../../../interfaces/IGasBank.sol"; import "../../../interfaces/pool/ILiquidityPool.sol"; import "../../../interfaces/IController.sol"; import "../../../interfaces/IStakerVault.sol"; import "../../../interfaces/actions/topup/ITopUpHandler.sol"; import "../../../interfaces/actions/topup/ITopUpAction.sol"; import "../../../interfaces/actions/IActionFeeHandler.sol"; import "../../../libraries/AddressProviderHelpers.sol"; import "../../../libraries/Errors.sol"; import "../../../libraries/ScaledMath.sol"; import "../../../libraries/EnumerableExtensions.sol"; import "../../../libraries/UncheckedMath.sol"; import "../../access/Authorization.sol"; import "../../utils/Preparable.sol"; /*  * @notice The logic here should really be part of the top-up action  * but is split in a library to circumvent the byte-code size limit  / library TopUpActionLibrary {     using SafeERC20 for IERC20;     using ScaledMath for uint256;     using AddressProviderHelpers for IAddressProvider; /**  * @dev "Locks" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param stakerVaultAddress The address of the staker vault  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function lockFunds(     address stakerVaultAddress,     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) external {     IStakerVault stakerVault = IStakerVault(stakerVaultAddress);      // stake deposit amount     if (depositAmount &gt; 0) {         depositAmount = depositAmount &gt; lockAmount ? lockAmount : depositAmount;         IERC20(token).safeTransferFrom(payer, address(this), depositAmount);         _approve(token, stakerVaultAddress);         stakerVault.stake(depositAmount);         stakerVault.increaseActionLockedBalance(payer, depositAmount);         lockAmount -= depositAmount;     }      // use stake vault allowance if available and required     if (lockAmount &gt; 0) {         uint256 balance = stakerVault.balanceOf(payer);         uint256 allowance = stakerVault.allowance(payer, address(this));         uint256 availableFunds = balance &lt; allowance ? balance : allowance;         if (availableFunds &gt;= lockAmount) {             stakerVault.transferFrom(payer, address(this), lockAmount);             stakerVault.increaseActionLockedBalance(payer, lockAmount);             lockAmount = 0;         }     }      require(lockAmount == 0, Error.INSUFFICIENT_UPDATE_BALANCE); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function calcExchangeAmount(     IAddressProvider addressProvider,     address token,     address actionToken,     uint256 amount ) external view returns (uint256) {     ILiquidityPool pool = addressProvider.getPoolForToken(token);     uint256 rate = pool.exchangeRate();     address underlying = pool.getUnderlying();     require(underlying == actionToken, Error.TOKEN_NOT_USABLE);     return amount.scaledDivRoundUp(rate); }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) private {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  } contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {     using ScaledMath for uint256;     using UncheckedMath for uint256;     using ScaledMath for uint128;     using SafeERC20 for IERC20;     using EnumerableSet for EnumerableSet.AddressSet;     using EnumerableSet for EnumerableSet.Bytes32Set;     using EnumerableExtensions for EnumerableSet.AddressSet;     using AddressProviderHelpers for IAddressProvider;     using SafeCast for uint256; /**  * @dev Temporary struct to hold local variables in execute  * and avoid the stack being "too deep"  */ struct ExecuteLocalVars {     uint256 minActionAmountToTopUp;     uint256 actionTokenAmount;     uint256 depositTotalFeesAmount;     uint256 actionAmountWithFees;     uint256 userFactor;     uint256 rate;     uint256 depositAmountWithFees;     uint256 depositAmountWithoutFees;     uint256 actionFee;     uint256 totalActionTokenAmount;     uint128 totalTopUpAmount;     bool topupResult;     uint256 gasBankBalance;     uint256 initialGas;     uint256 gasConsumed;     uint256 userGasPrice;     uint256 estimatedRequiredGas;     uint256 estimatedRequiredWeiForGas;     uint256 requiredWeiForGas;     uint256 reimbursedWeiForGas;     address underlying;     bool removePosition;     address topUpHandler; }  EnumerableSet.AddressSet private _usableTokens;  uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 550_000;  bytes32 internal constant _ACTION_FEE_KEY = "ActionFee"; bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler"; bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler"; bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";  uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;  IController public immutable controller; IAddressProvider public immutable addressProvider;  EnumerableSet.Bytes32Set internal _supportedProtocols;  /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record) mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;  mapping(address =&gt; RecordMeta[]) internal _userPositions;  EnumerableSet.AddressSet internal _usersWithPositions;  constructor(IController _controller)     Authorization(_controller.addressProvider().getRoleManager()) {     controller = _controller;     addressProvider = controller.addressProvider();     _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE); }  receive() external payable {     // solhint-disable-previous-line no-empty-blocks }  function initialize(     address feeHandler,     bytes32[] calldata protocols,     address[] calldata handlers ) external initializer onlyGovernance {     require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);     _setConfig(_FEE_HANDLER_KEY, feeHandler);     for (uint256 i; i &lt; protocols.length; i = i.uncheckedInc()) {         bytes32 protocolKey = _getProtocolKey(protocols[i]);         _setConfig(protocolKey, handlers[i]);         _updateTopUpHandler(protocols[i], address(0), handlers[i]);     } }  /**  * @notice Register a top up action.  * @dev The `depositAmount`, once converted to units of `actionToken`, must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).  * @param account Account to be topped up (first 20 bytes will typically be the address).  * @param protocol Protocol which holds position to be topped up.  * @param depositAmount Amount of `depositToken` that will be locked.  * @param record containing the data for the position to register  */ function register(     bytes32 account,     bytes32 protocol,     uint128 depositAmount,     Record memory record ) external payable override returns (bool) {     require(record.maxFee != 0, Error.INVALID_MAX_FEE);     require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);     require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);     require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);     require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);     require(         _positions[msg.sender][account][protocol].threshold == 0,         Error.POSITION_ALREADY_EXISTS     );     require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);     require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);      uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *         record.maxFee *         getEstimatedGasUsage();      require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);      uint256 totalLockAmount = _calcExchangeAmount(         record.depositToken,         record.actionToken,         record.totalTopUpAmount     );     _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);      addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);      record.registeredAt = uint64(block.timestamp);     record.depositTokenBalance = totalLockAmount.toUint128();     _positions[msg.sender][account][protocol] = record;     _userPositions[msg.sender].push(RecordMeta(account, protocol));     _usersWithPositions.add(msg.sender);      emit Register(         account,         protocol,         record.threshold,         msg.sender,         record.depositToken,         totalLockAmount,         record.actionToken,         record.singleTopUpAmount,         record.totalTopUpAmount,         record.maxFee,         record.extra     );     return true; }  /**  * @notice See overloaded version of `execute` for more details.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol ) external override returns (bool) {     return execute(payer, account, beneficiary, protocol, 0); }  /**  * @notice Delete a position to back on the given protocol for `account`.  * @param account Account holding the position.  * @param protocol Protocol the position is held on.  * @param unstake If the tokens should be unstaked from vault.  * @return `true` if successful.  */ function resetPosition(     bytes32 account,     bytes32 protocol,     bool unstake ) external override returns (bool) {     address payer = msg.sender;     Record memory position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);      IAddressProvider addressProvider_ = addressProvider;     address vault = addressProvider_.getStakerVault(position.depositToken); // will revert if vault does not exist     IStakerVault staker = IStakerVault(vault);     staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);     if (unstake) {         staker.unstake(position.depositTokenBalance);         IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);     } else {         staker.transfer(payer, position.depositTokenBalance);     }      _removePosition(payer, account, protocol);     addressProvider_.getGasBank().withdrawUnused(payer);     return true; }  /**  * @notice Execute top up handler update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @param protocol Protocol for which a new handler should be executed.  * @return Address of new handler.  */ function executeTopUpHandler(bytes32 protocol) external override returns (address) {     address oldHandler = _getHandler(protocol, false);     address newHandler = _executeAddress(_getProtocolKey(protocol));      _updateTopUpHandler(protocol, oldHandler, newHandler);     return newHandler; }  /**  * @notice Reset new top up handler deadline for a protocol.  * @param protocol Protocol for which top up handler deadline should be reset.  * @return `true` if successful.  */ function resetTopUpHandler(bytes32 protocol) external override onlyGovernance returns (bool) {     return _resetAddressConfig(_getProtocolKey(protocol)); }  /**  * @notice Prepare action fee update.  * @param newActionFee New fee to set.  * @return `true` if success.  */ function prepareActionFee(uint256 newActionFee)     external     override     onlyGovernance     returns (bool) {     require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);     return _prepare(_ACTION_FEE_KEY, newActionFee); }  /**  * @notice Execute action fee update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeActionFee() external override returns (uint256) {     return _executeUInt256(_ACTION_FEE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetActionFee() external override onlyGovernance returns (bool) {     return _resetUInt256Config(_ACTION_FEE_KEY); }  /** Set fee handler */ /**  * @notice Prepare update of fee handler.  * @param handler New fee handler.  * @return `true` if success.  */ function prepareFeeHandler(address handler) external override onlyGovernance returns (bool) {     return _prepare(_FEE_HANDLER_KEY, handler); }  /**  * @notice Execute update of fee handler (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeFeeHandler() external override returns (address) {     return _executeAddress(_FEE_HANDLER_KEY); }  /**  * @notice Reset the handler deadline.  * @return `true` if success.  */ function resetFeeHandler() external override onlyGovernance returns (bool) {     return _resetAddressConfig(_FEE_HANDLER_KEY); }  /**  * @notice Prepare update of estimated gas usage.  * @param gasUsage New estimated gas usage.  * @return `true` if success.  */ function prepareEstimatedGasUsage(uint256 gasUsage)     external     override     onlyGovernance     returns (bool) {     return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage); }  /**  * @notice Execute update of gas usage (with time delay enforced).  * @return `true` if successful.  */ function executeEstimatedGasUsage() external override returns (uint256) {     return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Reset the gas usage deadline.  * @return `true` if success.  */ function resetGasUsage() external override onlyGovernance returns (bool) {     return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Add a new deposit token that is supported by the action.  * @dev There is a separate check for whether the usable token (i.e. deposit token)  *      is swappable for some action token.  * @param token Address of deposit token that can be used by the action.  */ function addUsableToken(address token) external override onlyGovernance returns (bool) {     return _usableTokens.add(token); }  /**  * @notice Computes the total amount of ETH (as wei) required to pay for all  * the top-ups assuming the maximum gas price and the current estimated gas  * usage of a top-up  */ function getEthRequiredForGas(address payer) external view override returns (uint256) {     uint256 totalEthRequired;     RecordMeta[] memory userRecordsMeta = _userPositions[payer];     uint256 gasUsagePerCall = getEstimatedGasUsage();     uint256 length = userRecordsMeta.length;     for (uint256 i; i &lt; length; i = i.uncheckedInc()) {         RecordMeta memory meta = userRecordsMeta[i];         Record memory record = _positions[payer][meta.account][meta.protocol];         uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);         totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;     }     return totalEthRequired; }  /**  * @notice Returns a list of positions for the given payer  */ function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {     return _userPositions[payer]; }  /**  * @notice Get a list supported protocols.  * @return List of supported protocols.  */ function getSupportedProtocols() external view override returns (bytes32[] memory) {     uint256 length = _supportedProtocols.length();     bytes32[] memory protocols = new bytes32[](length);     for (uint256 i; i &lt; length; i = i.uncheckedInc()) {         protocols[i] = _supportedProtocols.at(i);     }     return protocols; }  /*  * @notice Gets a list of users that have an active position.  * @dev Uses cursor pagination.  * @param cursor The cursor for pagination (should start at 0 for first call).  * @param howMany Maximum number of users to return in this pagination request.  * @return users List of users that have an active position.  * @return nextCursor The cursor to use for the next pagination request.  */ function usersWithPositions(uint256 cursor, uint256 howMany)     external     view     override     returns (address[] memory users, uint256 nextCursor) {     uint256 length = _usersWithPositions.length();     if (cursor &gt;= length) return (new address[](0), 0);     if (howMany &gt;= length - cursor) {         howMany = length - cursor;     }      address[] memory usersWithPositions_ = new address[](howMany);     for (uint256 i; i &lt; howMany; i = i.uncheckedInc()) {         usersWithPositions_[i] = _usersWithPositions.at(i + cursor);     }      return (usersWithPositions_, cursor + howMany); }  /**  * @notice Get a list of all tokens usable for this action.  * @dev This refers to all tokens that can be used as deposit tokens.  * @return Array of addresses of usable tokens.  */ function getUsableTokens() external view override returns (address[] memory) {     return _usableTokens.toArray(); }  /**  * @notice Retrieves the topup handler for the given `protocol`  */ function getTopUpHandler(bytes32 protocol) external view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice Successfully tops up a position if it's conditions are met.  * @dev pool and vault funds are rebalanced after withdrawal for top up  * @param payer Account that pays for the top up.  * @param account Account owning the position for top up.  * @param beneficiary Address of the keeper's wallet for fee accrual.  * @param protocol Protocol of the top up position.  * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas  * @return `true` if successful.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol,     uint256 maxWeiForGas ) public override returns (bool) {     require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);      ExecuteLocalVars memory vars;      vars.initialGas = gasleft();      Record storage position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);     require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);     require(block.timestamp &gt; position.registeredAt, Error.CANNOT_EXECUTE_IN_SAME_BLOCK);      vars.topUpHandler = _getHandler(protocol, true);     vars.userFactor = ITopUpHandler(vars.topUpHandler).getUserFactor(account, position.extra);      // ensure that the position is actually below its set user factor threshold     require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);      IAddressProvider addressProvider_ = addressProvider;     IGasBank gasBank = addressProvider_.getGasBank();      // fail early if the user does not have enough funds in the gas bank     // to cover the cost of the transaction     vars.estimatedRequiredGas = getEstimatedGasUsage();     vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;      // compute the gas price that the user will be paying     vars.userGasPrice = block.basefee + position.priorityFee;     if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;     if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;      // ensure the current position allows for the gas to be paid     require(         vars.estimatedRequiredWeiForGas &lt;=             vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,         Error.ESTIMATED_GAS_TOO_HIGH     );      vars.gasBankBalance = gasBank.balanceOf(payer);     // ensure the user has enough funds in the gas bank to cover the gas     require(         vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,         Error.GAS_BANK_BALANCE_TOO_LOW     );      vars.totalTopUpAmount = position.totalTopUpAmount;     vars.actionFee = getActionFee();     // add top-up fees to top-up amount     vars.minActionAmountToTopUp = position.singleTopUpAmount;     vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(         ScaledMath.ONE + vars.actionFee     );      // if the amount that we want to top-up (including fees) is higher than     // the available topup amount, we lower this down to what is left of the position     if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {         vars.actionAmountWithFees = vars.totalTopUpAmount;         vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(             ScaledMath.ONE + vars.actionFee         );     }     ILiquidityPool pool = addressProvider_.getPoolForToken(position.depositToken);     vars.underlying = pool.getUnderlying();     vars.rate = pool.exchangeRate();      // compute the deposit tokens amount with and without fees     // we will need to unstake the amount with fees and to     // swap the amount without fees into action tokens     vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);     if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {         vars.depositAmountWithFees = position.depositTokenBalance;         vars.minActionAmountToTopUp =             (vars.depositAmountWithFees * vars.rate) /             (ScaledMath.ONE + vars.actionFee);     }      // compute amount of LP tokens needed to pay for action     // rate is expressed in actionToken per depositToken     vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);     vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;      // will revert if vault does not exist     address vault = addressProvider_.getStakerVault(position.depositToken);      // unstake deposit tokens including fees     IStakerVault(vault).unstake(vars.depositAmountWithFees);     IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);      // swap the amount without the fees     // as the fees are paid in deposit token, not in action token     vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);      // compute how much of action token was actually redeemed and add fees to it     // this is to ensure that no funds get locked inside the contract     vars.totalActionTokenAmount =         vars.actionTokenAmount +         vars.depositTotalFeesAmount.scaledMul(vars.rate);      // at this point, we have exactly `vars.actionTokenAmount`     // (at least `position.singleTopUpAmount`) of action token     // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract     // solhint-disable-next-line avoid-low-level-calls     uint256 value_;     if (position.actionToken == address(0)) {         value_ = vars.actionTokenAmount;     } else {         _approve(position.actionToken, vars.topUpHandler);     }     vars.topupResult = ITopUpHandler(vars.topUpHandler).topUp{value: value_}(         account,         position.actionToken,         vars.actionTokenAmount,         position.extra     );      require(vars.topupResult, Error.TOP_UP_FAILED);      // totalTopUpAmount is updated to reflect the new "balance" of the position     if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {         position.totalTopUpAmount -= vars.totalActionTokenAmount.toUint128();     } else {         position.totalTopUpAmount = 0;     }      position.depositTokenBalance -= vars.depositAmountWithFees.toUint128();      vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;     _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);     if (vars.removePosition) {         if (position.depositTokenBalance &gt; 0) {             // transfer any unused locked tokens to the payer             IStakerVault(vault).transfer(payer, position.depositTokenBalance);             IStakerVault(vault).decreaseActionLockedBalance(                 payer,                 position.depositTokenBalance             );         }         _removePosition(payer, account, protocol);     }      emit TopUp(         account,         protocol,         payer,         position.depositToken,         vars.depositAmountWithFees,         position.actionToken,         vars.actionTokenAmount     );      // compute gas used and reimburse the keeper by using the     // funds of payer in the gas bank     // TODO: add constant gas consumed for transfer and tx prologue     vars.gasConsumed = vars.initialGas - gasleft();      vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;     if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {         vars.reimbursedWeiForGas = vars.gasBankBalance;     }      // ensure that the keeper is not overpaying     vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;     require(         vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,         Error.GAS_TOO_HIGH     );     gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);     if (vars.removePosition) {         gasBank.withdrawUnused(payer);     }      return true; }  /**  * @notice Prepare new top up handler fee update.  * @dev Setting the address to 0 means that the protocol will no longer be supported.  * @param protocol Protocol for which a new handler should be prepared.  * @param newHandler Address of new handler.  * @return `true` if success.  */ function prepareTopUpHandler(bytes32 protocol, address newHandler)     public     override     onlyGovernance     returns (bool) {     return _prepare(_getProtocolKey(protocol), newHandler); }  /**  * @notice Check if action can be executed.  * @param protocol for which to get the health factor  * @param account for which to get the health factor  * @param extra data to be used by the topup handler  * @return healthFactor of the position  */ function getHealthFactor(     bytes32 protocol,     bytes32 account,     bytes calldata extra ) public view override returns (uint256 healthFactor) {     ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));     return topUpHandler.getUserFactor(account, extra); }  function getHandler(bytes32 protocol) public view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice returns the current estimated gas usage  */ function getEstimatedGasUsage() public view override returns (uint256) {     return currentUInts256[_ESTIMATED_GAS_USAGE_KEY]; }  /**  * @notice Returns the current action fee  */ function getActionFee() public view override returns (uint256) {     return currentUInts256[_ACTION_FEE_KEY]; }  /**  * @notice Returns the current fee handler  */ function getFeeHandler() public view override returns (address) {     return currentAddresses[_FEE_HANDLER_KEY]; }  /**  * @notice Get the record for a position.  * @param payer Registered payer of the position.  * @param account Address holding the position.  * @param protocol Protocol where the position is held.  */ function getPosition(     address payer,     bytes32 account,     bytes32 protocol ) public view override returns (Record memory) {     return _positions[payer][account][protocol]; }  /**  * @notice Check whether a token is usable as a deposit token.  * @param token Address of token to check.  * @return True if token is usable as a deposit token for this action.  */ function isUsable(address token) public view override returns (bool) {     return _usableTokens.contains(token); }  function _updateTopUpHandler(     bytes32 protocol,     address oldHandler,     address newHandler ) internal {     if (newHandler == address(0)) {         _supportedProtocols.remove(protocol);     } else if (oldHandler == address(0)) {         _supportedProtocols.add(protocol);     } }  /**  * @dev Pays fees to the feeHandler  * @param payer The account who's position the fees are charged on  * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)  * @param feeAmount The amount in tokens to pay as fees  * @param depositToken The LpToken used to pay the fees  */ function _payFees(     address payer,     address beneficiary,     uint256 feeAmount,     address depositToken ) internal {     address feeHandler = getFeeHandler();     IERC20(depositToken).safeApprove(feeHandler, feeAmount);     IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken); }  /**  * @dev "Locks" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function _lockFunds(     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) internal {     address stakerVaultAddress = addressProvider.getStakerVault(token);     TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount); }  function _removePosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     delete _positions[payer][account][protocol];     _removeUserPosition(payer, account, protocol);     if (_userPositions[payer].length == 0) {         _usersWithPositions.remove(payer);     }     emit Deregister(payer, account, protocol); }  function _removeUserPosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     RecordMeta[] storage positionsMeta = _userPositions[payer];     uint256 length = positionsMeta.length;     for (uint256 i; i &lt; length; i = i.uncheckedInc()) {         RecordMeta storage positionMeta = positionsMeta[i];         if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {             positionsMeta[i] = positionsMeta[length - 1];             positionsMeta.pop();             return;         }     } }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) internal {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the `actionToken`.  */ function _calcExchangeAmount(     address token,     address actionToken,     uint256 amount ) internal view returns (uint256) {     return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount); }  function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {     address handler = currentAddresses[_getProtocolKey(protocol)];     require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);     return handler; }  function _isSwappable(address depositToken, address toToken) internal view returns (bool) {     ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);     return pool.getUnderlying() == toToken; }  function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {     return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol)); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Below are the details of our target smart contract codes and their associated test reports: Task: "{task}". Existing Test Reports: "{test_reports}" Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings. |
| **phase_name** | TestBugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': '// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";\nimport "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\nimport "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";\nimport "@openzeppelin/contracts/utils/math/SafeCast.sol";\n\nimport "../../../interfaces/IGasBank.sol";\nimport "../../../interfaces/pool/ILiquidityPool.sol";\nimport "../../../interfaces/IController.sol";\nimport "../../../interfaces/IStakerVault.sol";\nimport "../../../interfaces/actions/topup/ITopUpHandler.sol";\nimport "../../../interfaces/actions/topup/ITopUpAction.sol";\nimport "../../../interfaces/actions/IActionFeeHandler.sol";\n\nimport "../../../libraries/AddressProviderHelpers.sol";\nimport "../../../libraries/Errors.sol";\nimport "../../../libraries/ScaledMath.sol";\nimport "../../../libraries/EnumerableExtensions.sol";\nimport "../../../libraries/UncheckedMath.sol";\n\nimport "../../access/Authorization.sol";\nimport "../../utils/Preparable.sol";\n\n/\n * @notice The logic here should really be part of the top-up action\n * but is split in a library to circumvent the byte-code size limit\n */\nlibrary TopUpActionLibrary {\n    using SafeERC20 for IERC20;\n    using ScaledMath for uint256;\n    using AddressProviderHelpers for IAddressProvider;\n\n    /\n     * @dev "Locks" an amount of tokens on behalf of the TopUpAction\n     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.\n     * @param stakerVaultAddress The address of the staker vault\n     * @param payer Owner of the funds to be locked\n     * @param token Token to lock\n     * @param lockAmount Minimum amount of token to lock\n     * @param depositAmount Amount of token that was deposited.\n     *                      If this is 0 then the staker vault allowance should be used.\n     *                      If this is greater than requiredAmount more tokens will be locked.\n     /\n    function lockFunds(\n        address stakerVaultAddress,\n        address payer,\n        address token,\n        uint256 lockAmount,\n        uint256 depositAmount\n    ) external {\n        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);\n\n        // stake deposit amount\n        if (depositAmount &gt; 0) {\n            depositAmount = depositAmount &gt; lockAmount ? lockAmount : depositAmount;\n            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);\n            _approve(token, stakerVaultAddress);\n            stakerVault.stake(depositAmount);\n            stakerVault.increaseActionLockedBalance(payer, depositAmount);\n            lockAmount -= depositAmount;\n        }\n\n        // use stake vault allowance if available and required\n        if (lockAmount &gt; 0) {\n            uint256 balance = stakerVault.balanceOf(payer);\n            uint256 allowance = stakerVault.allowance(payer, address(this));\n            uint256 availableFunds = balance &lt; allowance ? balance : allowance;\n            if (availableFunds &gt;= lockAmount) {\n                stakerVault.transferFrom(payer, address(this), lockAmount);\n                stakerVault.increaseActionLockedBalance(payer, lockAmount);\n                lockAmount = 0;\n            }\n        }\n\n        require(lockAmount == 0, Error.INSUFFICIENT_UPDATE_BALANCE);\n    }\n\n    /\n     * @dev Computes and returns the amount of LP tokens of type token that will be received in exchange for an amount of the underlying.\n     /\n    function calcExchangeAmount(\n        IAddressProvider addressProvider,\n        address token,\n        address actionToken,\n        uint256 amount\n    ) external view returns (uint256) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(token);\n        uint256 rate = pool.exchangeRate();\n        address underlying = pool.getUnderlying();\n        require(underlying == actionToken, Error.TOKEN_NOT_USABLE);\n        return amount.scaledDivRoundUp(rate);\n    }\n\n    /\n     * @dev Approves infinite spending for the given spender.\n     * @param token The token to approve for.\n     * @param spender The spender to approve.\n     */\n    function _approve(address token, address spender) private {\n        if (IERC20(token).allowance(address(this), spender) &gt; 0) return;\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n}\n\ncontract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {\n    using ScaledMath for uint256;\n    using UncheckedMath for uint256;\n    using ScaledMath for uint128;\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using EnumerableExtensions for EnumerableSet.AddressSet;\n    using AddressProviderHelpers for IAddressProvider;\n    using SafeCast for uint256;\n\n    /\n     * @dev Temporary struct to hold local variables in execute\n     * and avoid the stack being "too deep"\n     /\n    struct ExecuteLocalVars {\n        uint256 minActionAmountToTopUp;\n        uint256 actionTokenAmount;\n        uint256 depositTotalFeesAmount;\n        uint256 actionAmountWithFees;\n        uint256 userFactor;\n        uint256 rate;\n        uint256 depositAmountWithFees;\n        uint256 depositAmountWithoutFees;\n        uint256 actionFee;\n        uint256 totalActionTokenAmount;\n        uint128 totalTopUpAmount;\n        bool topupResult;\n        uint256 gasBankBalance;\n        uint256 initialGas;\n        uint256 gasConsumed;\n        uint256 userGasPrice;\n        uint256 estimatedRequiredGas;\n        uint256 estimatedRequiredWeiForGas;\n        uint256 requiredWeiForGas;\n        uint256 reimbursedWeiForGas;\n        address underlying;\n        bool removePosition;\n        address topUpHandler;\n    }\n\n    EnumerableSet.AddressSet private _usableTokens;\n\n    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 550_000;\n\n    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";\n    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";\n    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";\n    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";\n\n    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;\n\n    IController public immutable controller;\n    IAddressProvider public immutable addressProvider;\n\n    EnumerableSet.Bytes32Set internal _supportedProtocols;\n\n    /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record)\n    mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;\n\n    mapping(address =&gt; RecordMeta[]) internal _userPositions;\n\n    EnumerableSet.AddressSet internal _usersWithPositions;\n\n    constructor(IController _controller)\n        Authorization(_controller.addressProvider().getRoleManager())\n    {\n        controller = _controller;\n        addressProvider = controller.addressProvider();\n        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);\n    }\n\n    receive() external payable {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    function initialize(\n        address feeHandler,\n        bytes32[] calldata protocols,\n        address[] calldata handlers\n    ) external initializer onlyGovernance {\n        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);\n        _setConfig(_FEE_HANDLER_KEY, feeHandler);\n        for (uint256 i; i &lt; protocols.length; i = i.uncheckedInc()) {\n            bytes32 protocolKey = _getProtocolKey(protocols[i]);\n            _setConfig(protocolKey, handlers[i]);\n            _updateTopUpHandler(protocols[i], address(0), handlers[i]);\n        }\n    }\n\n    /\n     * @notice Register a top up action.\n     * @dev The depositAmount, once converted to units of actionToken, must be greater or equal to the totalTopUpAmount (which is denominated in actionToken).\n     * @param account Account to be topped up (first 20 bytes will typically be the address).\n     * @param protocol Protocol which holds position to be topped up.\n     * @param depositAmount Amount of depositToken that will be locked.\n     * @param record containing the data for the position to register\n     /\n    function register(\n        bytes32 account,\n        bytes32 protocol,\n        uint128 depositAmount,\n        Record memory record\n    ) external payable override returns (bool) {\n        require(record.maxFee != 0, Error.INVALID_MAX_FEE);\n        require(supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);\n        require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);\n        require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);\n        require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);\n        require(\n            _positions[msg.sender][account][protocol].threshold == 0,\n            Error.POSITION_ALREADY_EXISTS\n        );\n        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);\n        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);\n\n        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) \n            record.maxFee \n            getEstimatedGasUsage();\n\n        require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);\n\n        uint256 totalLockAmount = _calcExchangeAmount(\n            record.depositToken,\n            record.actionToken,\n            record.totalTopUpAmount\n        );\n        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);\n\n        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);\n\n        record.registeredAt = uint64(block.timestamp);\n        record.depositTokenBalance = totalLockAmount.toUint128();\n        _positions[msg.sender][account][protocol] = record;\n        _userPositions[msg.sender].push(RecordMeta(account, protocol));\n        _usersWithPositions.add(msg.sender);\n\n        emit Register(\n            account,\n            protocol,\n            record.threshold,\n            msg.sender,\n            record.depositToken,\n            totalLockAmount,\n            record.actionToken,\n            record.singleTopUpAmount,\n            record.totalTopUpAmount,\n            record.maxFee,\n            record.extra\n        );\n        return true;\n    }\n\n    /\n     * @notice See overloaded version of execute for more details.\n     */\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol\n    ) external override returns (bool) {\n        return execute(payer, account, beneficiary, protocol, 0);\n    }\n\n    /\n     * @notice Delete a position to back on the given protocol for account.\n     * @param account Account holding the position.\n     * @param protocol Protocol the position is held on.\n     * @param unstake If the tokens should be unstaked from vault.\n     * @return true if successful.\n     /\n    function resetPosition(\n        bytes32 account,\n        bytes32 protocol,\n        bool unstake\n    ) external override returns (bool) {\n        address payer = msg.sender;\n        Record memory position = positions[payer][account][protocol];\n        require(position.threshold != 0, Error.NO_POSITION_EXISTS);\n\n        IAddressProvider addressProvider = addressProvider;\n        address vault = addressProvider_.getStakerVault(position.depositToken); // will revert if vault does not exist\n        IStakerVault staker = IStakerVault(vault);\n        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);\n        if (unstake) {\n            staker.unstake(position.depositTokenBalance);\n            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);\n        } else {\n            staker.transfer(payer, position.depositTokenBalance);\n        }\n\n        removePosition(payer, account, protocol);\n        addressProvider.getGasBank().withdrawUnused(payer);\n        return true;\n    }\n\n    /\n     * @notice Execute top up handler update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @param protocol Protocol for which a new handler should be executed.\n     * @return Address of new handler.\n     /\n    function executeTopUpHandler(bytes32 protocol) external override returns (address) {\n        address oldHandler = _getHandler(protocol, false);\n        address newHandler = _executeAddress(_getProtocolKey(protocol));\n\n        _updateTopUpHandler(protocol, oldHandler, newHandler);\n        return newHandler;\n    }\n\n    /\n     * @notice Reset new top up handler deadline for a protocol.\n     * @param protocol Protocol for which top up handler deadline should be reset.\n     * @return true if successful.\n     */\n    function resetTopUpHandler(bytes32 protocol) external override onlyGovernance returns (bool) {\n        return _resetAddressConfig(_getProtocolKey(protocol));\n    }\n\n    /\n     * @notice Prepare action fee update.\n     * @param newActionFee New fee to set.\n     * @return true if success.\n     /\n    function prepareActionFee(uint256 newActionFee)\n        external\n        override\n        onlyGovernance\n        returns (bool)\n    {\n        require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);\n        return _prepare(_ACTION_FEE_KEY, newActionFee);\n    }\n\n    /\n     * @notice Execute action fee update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return true if successful.\n     /\n    function executeActionFee() external override returns (uint256) {\n        return _executeUInt256(_ACTION_FEE_KEY);\n    }\n\n    /\n     * @notice Reset action fee deadline.\n     * @return true if successful.\n     */\n    function resetActionFee() external override onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ACTION_FEE_KEY);\n    }\n\n    / Set fee handler /\n    /\n     * @notice Prepare update of fee handler.\n     * @param handler New fee handler.\n     * @return true if success.\n     /\n    function prepareFeeHandler(address handler) external override onlyGovernance returns (bool) {\n        return _prepare(_FEE_HANDLER_KEY, handler);\n    }\n\n    /\n     * @notice Execute update of fee handler (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return true if successful.\n     */\n    function executeFeeHandler() external override returns (address) {\n        return _executeAddress(_FEE_HANDLER_KEY);\n    }\n\n    /\n     * @notice Reset the handler deadline.\n     * @return true if success.\n     /\n    function resetFeeHandler() external override onlyGovernance returns (bool) {\n        return _resetAddressConfig(_FEE_HANDLER_KEY);\n    }\n\n    /\n     * @notice Prepare update of estimated gas usage.\n     * @param gasUsage New estimated gas usage.\n     * @return true if success.\n     /\n    function prepareEstimatedGasUsage(uint256 gasUsage)\n        external\n        override\n        onlyGovernance\n        returns (bool)\n    {\n        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);\n    }\n\n    /\n     * @notice Execute update of gas usage (with time delay enforced).\n     * @return true if successful.\n     */\n    function executeEstimatedGasUsage() external override returns (uint256) {\n        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);\n    }\n\n    /\n     * @notice Reset the gas usage deadline.\n     * @return true if success.\n     /\n    function resetGasUsage() external override onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);\n    }\n\n    /\n     * @notice Add a new deposit token that is supported by the action.\n     * @dev There is a separate check for whether the usable token (i.e. deposit token)\n     *      is swappable for some action token.\n     * @param token Address of deposit token that can be used by the action.\n     /\n    function addUsableToken(address token) external override onlyGovernance returns (bool) {\n        return _usableTokens.add(token);\n    }\n\n    /\n     * @notice Computes the total amount of ETH (as wei) required to pay for all\n     * the top-ups assuming the maximum gas price and the current estimated gas\n     * usage of a top-up\n     */\n    function getEthRequiredForGas(address payer) external view override returns (uint256) {\n        uint256 totalEthRequired;\n        RecordMeta[] memory userRecordsMeta = _userPositions[payer];\n        uint256 gasUsagePerCall = getEstimatedGasUsage();\n        uint256 length = userRecordsMeta.length;\n        for (uint256 i; i &lt; length; i = i.uncheckedInc()) {\n            RecordMeta memory meta = userRecordsMeta[i];\n            Record memory record = _positions[payer][meta.account][meta.protocol];\n            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);\n            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;\n        }\n        return totalEthRequired;\n    }\n\n    /\n     * @notice Returns a list of positions for the given payer\n     /\n    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {\n        return _userPositions[payer];\n    }\n\n    /\n     * @notice Get a list supported protocols.\n     * @return List of supported protocols.\n     /\n    function getSupportedProtocols() external view override returns (bytes32[] memory) {\n        uint256 length = _supportedProtocols.length();\n        bytes32[] memory protocols = new bytes32;\n        for (uint256 i; i &lt; length; i = i.uncheckedInc()) {\n            protocols[i] = _supportedProtocols.at(i);\n        }\n        return protocols;\n    }\n\n    /\n     * @notice Gets a list of users that have an active position.\n     * @dev Uses cursor pagination.\n     * @param cursor The cursor for pagination (should start at 0 for first call).\n     * @param howMany Maximum number of users to return in this pagination request.\n     * @return users List of users that have an active position.\n     * @return nextCursor The cursor to use for the next pagination request.\n     /\n    function usersWithPositions(uint256 cursor, uint256 howMany)\n        external\n        view\n        override\n        returns (address[] memory users, uint256 nextCursor)\n    {\n        uint256 length = _usersWithPositions.length();\n        if (cursor &gt;= length) return (new address, 0);\n        if (howMany &gt;= length - cursor) {\n            howMany = length - cursor;\n        }\n\n        address[] memory usersWithPositions = new address;\n        for (uint256 i; i &lt; howMany; i = i.uncheckedInc()) {\n            usersWithPositions_[i] = usersWithPositions.at(i + cursor);\n        }\n\n        return (usersWithPositions, cursor + howMany);\n    }\n\n    /\n     * @notice Get a list of all tokens usable for this action.\n     * @dev This refers to all tokens that can be used as deposit tokens.\n     * @return Array of addresses of usable tokens.\n     */\n    function getUsableTokens() external view override returns (address[] memory) {\n        return _usableTokens.toArray();\n    }\n\n    /\n     * @notice Retrieves the topup handler for the given protocol\n     /\n    function getTopUpHandler(bytes32 protocol) external view override returns (address) {\n        return _getHandler(protocol, false);\n    }\n\n    /\n     * @notice Successfully tops up a position if it\'s conditions are met.\n     * @dev pool and vault funds are rebalanced after withdrawal for top up\n     * @param payer Account that pays for the top up.\n     * @param account Account owning the position for top up.\n     * @param beneficiary Address of the keeper\'s wallet for fee accrual.\n     * @param protocol Protocol of the top up position.\n     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas\n     * @return true if successful.\n     /\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol,\n        uint256 maxWeiForGas\n    ) public override returns (bool) {\n        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);\n\n        ExecuteLocalVars memory vars;\n\n        vars.initialGas = gasleft();\n\n        Record storage position = positions[payer][account][protocol];\n        require(position.threshold != 0, Error.NO_POSITION_EXISTS);\n        require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);\n        require(block.timestamp &gt; position.registeredAt, Error.CANNOT_EXECUTE_IN_SAME_BLOCK);\n\n        vars.topUpHandler = _getHandler(protocol, true);\n        vars.userFactor = ITopUpHandler(vars.topUpHandler).getUserFactor(account, position.extra);\n\n        // ensure that the position is actually below its set user factor threshold\n        require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);\n\n        IAddressProvider addressProvider = addressProvider;\n        IGasBank gasBank = addressProvider_.getGasBank();\n\n        // fail early if the user does not have enough funds in the gas bank\n        // to cover the cost of the transaction\n        vars.estimatedRequiredGas = getEstimatedGasUsage();\n        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;\n\n        // compute the gas price that the user will be paying\n        vars.userGasPrice = block.basefee + position.priorityFee;\n        if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;\n        if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;\n\n        // ensure the current position allows for the gas to be paid\n        require(\n            vars.estimatedRequiredWeiForGas &lt;=\n                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,\n            Error.ESTIMATED_GAS_TOO_HIGH\n        );\n\n        vars.gasBankBalance = gasBank.balanceOf(payer);\n        // ensure the user has enough funds in the gas bank to cover the gas\n        require(\n            vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,\n            Error.GAS_BANK_BALANCE_TOO_LOW\n        );\n\n        vars.totalTopUpAmount = position.totalTopUpAmount;\n        vars.actionFee = getActionFee();\n        // add top-up fees to top-up amount\n        vars.minActionAmountToTopUp = position.singleTopUpAmount;\n        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(\n            ScaledMath.ONE + vars.actionFee\n        );\n\n        // if the amount that we want to top-up (including fees) is higher than\n        // the available topup amount, we lower this down to what is left of the position\n        if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {\n            vars.actionAmountWithFees = vars.totalTopUpAmount;\n            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(\n                ScaledMath.ONE + vars.actionFee\n            );\n        }\n        ILiquidityPool pool = addressProvider_.getPoolForToken(position.depositToken);\n        vars.underlying = pool.getUnderlying();\n        vars.rate = pool.exchangeRate();\n\n        // compute the deposit tokens amount with and without fees\n        // we will need to unstake the amount with fees and to\n        // swap the amount without fees into action tokens\n        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);\n        if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {\n            vars.depositAmountWithFees = position.depositTokenBalance;\n            vars.minActionAmountToTopUp =\n                (vars.depositAmountWithFees * vars.rate) /\n                (ScaledMath.ONE + vars.actionFee);\n        }\n\n        // compute amount of LP tokens needed to pay for action\n        // rate is expressed in actionToken per depositToken\n        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);\n        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;\n\n        // will revert if vault does not exist\n        address vault = addressProvider_.getStakerVault(position.depositToken);\n\n        // unstake deposit tokens including fees\n        IStakerVault(vault).unstake(vars.depositAmountWithFees);\n        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);\n\n        // swap the amount without the fees\n        // as the fees are paid in deposit token, not in action token\n        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);\n\n        // compute how much of action token was actually redeemed and add fees to it\n        // this is to ensure that no funds get locked inside the contract\n        vars.totalActionTokenAmount =\n            vars.actionTokenAmount +\n            vars.depositTotalFeesAmount.scaledMul(vars.rate);\n\n        // at this point, we have exactly vars.actionTokenAmount\n        // (at least position.singleTopUpAmount) of action token\n        // and exactly vars.depositTotalFeesAmount deposit tokens in the contract\n        // solhint-disable-next-line avoid-low-level-calls\n        uint256 value_;\n        if (position.actionToken == address(0)) {\n            value_ = vars.actionTokenAmount;\n        } else {\n            approve(position.actionToken, vars.topUpHandler);\n        }\n        vars.topupResult = ITopUpHandler(vars.topUpHandler).topUp{value: value}(\n            account,\n            position.actionToken,\n            vars.actionTokenAmount,\n            position.extra\n        );\n\n        require(vars.topupResult, Error.TOP_UP_FAILED);\n\n        // totalTopUpAmount is updated to reflect the new "balance" of the position\n        if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {\n            position.totalTopUpAmount -= vars.totalActionTokenAmount.toUint128();\n        } else {\n            position.totalTopUpAmount = 0;\n        }\n\n        position.depositTokenBalance -= vars.depositAmountWithFees.toUint128();\n\n        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;\n        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);\n        if (vars.removePosition) {\n            if (position.depositTokenBalance &gt; 0) {\n                // transfer any unused locked tokens to the payer\n                IStakerVault(vault).transfer(payer, position.depositTokenBalance);\n                IStakerVault(vault).decreaseActionLockedBalance(\n                    payer,\n                    position.depositTokenBalance\n                );\n            }\n            _removePosition(payer, account, protocol);\n        }\n\n        emit TopUp(\n            account,\n            protocol,\n            payer,\n            position.depositToken,\n            vars.depositAmountWithFees,\n            position.actionToken,\n            vars.actionTokenAmount\n        );\n\n        // compute gas used and reimburse the keeper by using the\n        // funds of payer in the gas bank\n        // TODO: add constant gas consumed for transfer and tx prologue\n        vars.gasConsumed = vars.initialGas - gasleft();\n\n        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;\n        if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {\n            vars.reimbursedWeiForGas = vars.gasBankBalance;\n        }\n\n        // ensure that the keeper is not overpaying\n        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;\n        require(\n            vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,\n            Error.GAS_TOO_HIGH\n        );\n        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);\n        if (vars.removePosition) {\n            gasBank.withdrawUnused(payer);\n        }\n\n        return true;\n    }\n\n    /\n     * @notice Prepare new top up handler fee update.\n     * @dev Setting the address to 0 means that the protocol will no longer be supported.\n     * @param protocol Protocol for which a new handler should be prepared.\n     * @param newHandler Address of new handler.\n     * @return true if success.\n     */\n    function prepareTopUpHandler(bytes32 protocol, address newHandler)\n        public\n        override\n        onlyGovernance\n        returns (bool)\n    {\n        return _prepare(_getProtocolKey(protocol), newHandler);\n    }\n\n    /\n     * @notice Check if action can be executed.\n     * @param protocol for which to get the health factor\n     * @param account for which to get the health factor\n     * @param extra data to be used by the topup handler\n     * @return healthFactor of the position\n     /\n    function getHealthFactor(\n        bytes32 protocol,\n        bytes32 account,\n        bytes calldata extra\n    ) public view override returns (uint256 healthFactor) {\n        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));\n        return topUpHandler.getUserFactor(account, extra);\n    }\n\n    function getHandler(bytes32 protocol) public view override returns (address) {\n        return _getHandler(protocol, false);\n    }\n\n    /\n     * @notice returns the current estimated gas usage\n     /\n    function getEstimatedGasUsage() public view override returns (uint256) {\n        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];\n    }\n\n    /\n     * @notice Returns the current action fee\n     */\n    function getActionFee() public view override returns (uint256) {\n        return currentUInts256[_ACTION_FEE_KEY];\n    }\n\n    /\n     * @notice Returns the current fee handler\n     /\n    function getFeeHandler() public view override returns (address) {\n        return currentAddresses[_FEE_HANDLER_KEY];\n    }\n\n    /\n     * @notice Get the record for a position.\n     * @param payer Registered payer of the position.\n     * @param account Address holding the position.\n     * @param protocol Protocol where the position is held.\n     /\n    function getPosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) public view override returns (Record memory) {\n        return _positions[payer][account][protocol];\n    }\n\n    /\n     * @notice Check whether a token is usable as a deposit token.\n     * @param token Address of token to check.\n     * @return True if token is usable as a deposit token for this action.\n     */\n    function isUsable(address token) public view override returns (bool) {\n        return _usableTokens.contains(token);\n    }\n\n    function _updateTopUpHandler(\n        bytes32 protocol,\n        address oldHandler,\n        address newHandler\n    ) internal {\n        if (newHandler == address(0)) {\n            _supportedProtocols.remove(protocol);\n        } else if (oldHandler == address(0)) {\n            _supportedProtocols.add(protocol);\n        }\n    }\n\n    /\n     * @dev Pays fees to the feeHandler\n     * @param payer The account who\'s position the fees are charged on\n     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)\n     * @param feeAmount The amount in tokens to pay as fees\n     * @param depositToken The LpToken used to pay the fees\n     /\n    function _payFees(\n        address payer,\n        address beneficiary,\n        uint256 feeAmount,\n        address depositToken\n    ) internal {\n        address feeHandler = getFeeHandler();\n        IERC20(depositToken).safeApprove(feeHandler, feeAmount);\n        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);\n    }\n\n    /\n     * @dev "Locks" an amount of tokens on behalf of the TopUpAction\n     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.\n     * @param payer Owner of the funds to be locked\n     * @param token Token to lock\n     * @param lockAmount Minimum amount of token to lock\n     * @param depositAmount Amount of token that was deposited.\n     *                      If this is 0 then the staker vault allowance should be used.\n     *                      If this is greater than requiredAmount more tokens will be locked.\n     /\n    function _lockFunds(\n        address payer,\n        address token,\n        uint256 lockAmount,\n        uint256 depositAmount\n    ) internal {\n        address stakerVaultAddress = addressProvider.getStakerVault(token);\n        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);\n    }\n\n    function _removePosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) internal {\n        delete _positions[payer][account][protocol];\n        _removeUserPosition(payer, account, protocol);\n        if (_userPositions[payer].length == 0) {\n            _usersWithPositions.remove(payer);\n        }\n        emit Deregister(payer, account, protocol);\n    }\n\n    function _removeUserPosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) internal {\n        RecordMeta[] storage positionsMeta = _userPositions[payer];\n        uint256 length = positionsMeta.length;\n        for (uint256 i; i &lt; length; i = i.uncheckedInc()) {\n            RecordMeta storage positionMeta = positionsMeta[i];\n            if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {\n                positionsMeta[i] = positionsMeta[length - 1];\n                positionsMeta.pop();\n                return;\n            }\n        }\n    }\n\n    /\n     * @dev Approves infinite spending for the given spender.\n     * @param token The token to approve for.\n     * @param spender The spender to approve.\n     */\n    function _approve(address token, address spender) internal {\n        if (IERC20(token).allowance(address(this), spender) &gt; 0) return;\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n\n    /\n     * @dev Computes and returns the amount of LP tokens of type token that will be received in exchange for an amount of the actionToken.\n     */\n    function _calcExchangeAmount(\n        address token,\n        address actionToken,\n        uint256 amount\n    ) internal view returns (uint256) {\n        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);\n    }\n\n    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {\n        address handler = currentAddresses[_getProtocolKey(protocol)];\n        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);\n        return handler;\n    }\n\n    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);\n        return pool.getUnderlying() == toToken;\n    }\n\n    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));\n    }\n}\n', 'ideas': ' 1', 'test_reports': 'The software run successfully without errors.', 'exist_bugs_flag': False} |

[2024-01-09 12:31:21 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.10; import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol"; import "@openzeppelin/contracts/utils/math/SafeCast.sol"; import "../../../interfaces/IGasBank.sol"; import "../../../interfaces/pool/ILiquidityPool.sol"; import "../../../interfaces/IController.sol"; import "../../../interfaces/IStakerVault.sol"; import "../../../interfaces/actions/topup/ITopUpHandler.sol"; import "../../../interfaces/actions/topup/ITopUpAction.sol"; import "../../../interfaces/actions/IActionFeeHandler.sol"; import "../../../libraries/AddressProviderHelpers.sol"; import "../../../libraries/Errors.sol"; import "../../../libraries/ScaledMath.sol"; import "../../../libraries/EnumerableExtensions.sol"; import "../../../libraries/UncheckedMath.sol"; import "../../access/Authorization.sol"; import "../../utils/Preparable.sol"; /*  * @notice The logic here should really be part of the top-up action  * but is split in a library to circumvent the byte-code size limit  / library TopUpActionLibrary {     using SafeERC20 for IERC20;     using ScaledMath for uint256;     using AddressProviderHelpers for IAddressProvider; /**  * @dev "Locks" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param stakerVaultAddress The address of the staker vault  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function lockFunds(     address stakerVaultAddress,     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) external {     IStakerVault stakerVault = IStakerVault(stakerVaultAddress);      // stake deposit amount     if (depositAmount &gt; 0) {         depositAmount = depositAmount &gt; lockAmount ? lockAmount : depositAmount;         IERC20(token).safeTransferFrom(payer, address(this), depositAmount);         _approve(token, stakerVaultAddress);         stakerVault.stake(depositAmount);         stakerVault.increaseActionLockedBalance(payer, depositAmount);         lockAmount -= depositAmount;     }      // use stake vault allowance if available and required     if (lockAmount &gt; 0) {         uint256 balance = stakerVault.balanceOf(payer);         uint256 allowance = stakerVault.allowance(payer, address(this));         uint256 availableFunds = balance &lt; allowance ? balance : allowance;         if (availableFunds &gt;= lockAmount) {             stakerVault.transferFrom(payer, address(this), lockAmount);             stakerVault.increaseActionLockedBalance(payer, lockAmount);             lockAmount = 0;         }     }      require(lockAmount == 0, Error.INSUFFICIENT_UPDATE_BALANCE); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function calcExchangeAmount(     IAddressProvider addressProvider,     address token,     address actionToken,     uint256 amount ) external view returns (uint256) {     ILiquidityPool pool = addressProvider.getPoolForToken(token);     uint256 rate = pool.exchangeRate();     address underlying = pool.getUnderlying();     require(underlying == actionToken, Error.TOKEN_NOT_USABLE);     return amount.scaledDivRoundUp(rate); }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) private {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  } contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {     using ScaledMath for uint256;     using UncheckedMath for uint256;     using ScaledMath for uint128;     using SafeERC20 for IERC20;     using EnumerableSet for EnumerableSet.AddressSet;     using EnumerableSet for EnumerableSet.Bytes32Set;     using EnumerableExtensions for EnumerableSet.AddressSet;     using AddressProviderHelpers for IAddressProvider;     using SafeCast for uint256; /**  * @dev Temporary struct to hold local variables in execute  * and avoid the stack being "too deep"  */ struct ExecuteLocalVars {     uint256 minActionAmountToTopUp;     uint256 actionTokenAmount;     uint256 depositTotalFeesAmount;     uint256 actionAmountWithFees;     uint256 userFactor;     uint256 rate;     uint256 depositAmountWithFees;     uint256 depositAmountWithoutFees;     uint256 actionFee;     uint256 totalActionTokenAmount;     uint128 totalTopUpAmount;     bool topupResult;     uint256 gasBankBalance;     uint256 initialGas;     uint256 gasConsumed;     uint256 userGasPrice;     uint256 estimatedRequiredGas;     uint256 estimatedRequiredWeiForGas;     uint256 requiredWeiForGas;     uint256 reimbursedWeiForGas;     address underlying;     bool removePosition;     address topUpHandler; }  EnumerableSet.AddressSet private _usableTokens;  uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 550_000;  bytes32 internal constant _ACTION_FEE_KEY = "ActionFee"; bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler"; bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler"; bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";  uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;  IController public immutable controller; IAddressProvider public immutable addressProvider;  EnumerableSet.Bytes32Set internal _supportedProtocols;  /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record) mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;  mapping(address =&gt; RecordMeta[]) internal _userPositions;  EnumerableSet.AddressSet internal _usersWithPositions;  constructor(IController _controller)     Authorization(_controller.addressProvider().getRoleManager()) {     controller = _controller;     addressProvider = controller.addressProvider();     _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE); }  receive() external payable {     // solhint-disable-previous-line no-empty-blocks }  function initialize(     address feeHandler,     bytes32[] calldata protocols,     address[] calldata handlers ) external initializer onlyGovernance {     require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);     _setConfig(_FEE_HANDLER_KEY, feeHandler);     for (uint256 i; i &lt; protocols.length; i = i.uncheckedInc()) {         bytes32 protocolKey = _getProtocolKey(protocols[i]);         _setConfig(protocolKey, handlers[i]);         _updateTopUpHandler(protocols[i], address(0), handlers[i]);     } }  /**  * @notice Register a top up action.  * @dev The `depositAmount`, once converted to units of `actionToken`, must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).  * @param account Account to be topped up (first 20 bytes will typically be the address).  * @param protocol Protocol which holds position to be topped up.  * @param depositAmount Amount of `depositToken` that will be locked.  * @param record containing the data for the position to register  */ function register(     bytes32 account,     bytes32 protocol,     uint128 depositAmount,     Record memory record ) external payable override returns (bool) {     require(record.maxFee != 0, Error.INVALID_MAX_FEE);     require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);     require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);     require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);     require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);     require(         _positions[msg.sender][account][protocol].threshold == 0,         Error.POSITION_ALREADY_EXISTS     );     require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);     require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);      uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *         record.maxFee *         getEstimatedGasUsage();      require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);      uint256 totalLockAmount = _calcExchangeAmount(         record.depositToken,         record.actionToken,         record.totalTopUpAmount     );     _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);      addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);      record.registeredAt = uint64(block.timestamp);     record.depositTokenBalance = totalLockAmount.toUint128();     _positions[msg.sender][account][protocol] = record;     _userPositions[msg.sender].push(RecordMeta(account, protocol));     _usersWithPositions.add(msg.sender);      emit Register(         account,         protocol,         record.threshold,         msg.sender,         record.depositToken,         totalLockAmount,         record.actionToken,         record.singleTopUpAmount,         record.totalTopUpAmount,         record.maxFee,         record.extra     );     return true; }  /**  * @notice See overloaded version of `execute` for more details.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol ) external override returns (bool) {     return execute(payer, account, beneficiary, protocol, 0); }  /**  * @notice Delete a position to back on the given protocol for `account`.  * @param account Account holding the position.  * @param protocol Protocol the position is held on.  * @param unstake If the tokens should be unstaked from vault.  * @return `true` if successful.  */ function resetPosition(     bytes32 account,     bytes32 protocol,     bool unstake ) external override returns (bool) {     address payer = msg.sender;     Record memory position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);      IAddressProvider addressProvider_ = addressProvider;     address vault = addressProvider_.getStakerVault(position.depositToken); // will revert if vault does not exist     IStakerVault staker = IStakerVault(vault);     staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);     if (unstake) {         staker.unstake(position.depositTokenBalance);         IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);     } else {         staker.transfer(payer, position.depositTokenBalance);     }      _removePosition(payer, account, protocol);     addressProvider_.getGasBank().withdrawUnused(payer);     return true; }  /**  * @notice Execute top up handler update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @param protocol Protocol for which a new handler should be executed.  * @return Address of new handler.  */ function executeTopUpHandler(bytes32 protocol) external override returns (address) {     address oldHandler = _getHandler(protocol, false);     address newHandler = _executeAddress(_getProtocolKey(protocol));      _updateTopUpHandler(protocol, oldHandler, newHandler);     return newHandler; }  /**  * @notice Reset new top up handler deadline for a protocol.  * @param protocol Protocol for which top up handler deadline should be reset.  * @return `true` if successful.  */ function resetTopUpHandler(bytes32 protocol) external override onlyGovernance returns (bool) {     return _resetAddressConfig(_getProtocolKey(protocol)); }  /**  * @notice Prepare action fee update.  * @param newActionFee New fee to set.  * @return `true` if success.  */ function prepareActionFee(uint256 newActionFee)     external     override     onlyGovernance     returns (bool) {     require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);     return _prepare(_ACTION_FEE_KEY, newActionFee); }  /**  * @notice Execute action fee update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeActionFee() external override returns (uint256) {     return _executeUInt256(_ACTION_FEE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetActionFee() external override onlyGovernance returns (bool) {     return _resetUInt256Config(_ACTION_FEE_KEY); }  /** Set fee handler */ /**  * @notice Prepare update of fee handler.  * @param handler New fee handler.  * @return `true` if success.  */ function prepareFeeHandler(address handler) external override onlyGovernance returns (bool) {     return _prepare(_FEE_HANDLER_KEY, handler); }  /**  * @notice Execute update of fee handler (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeFeeHandler() external override returns (address) {     return _executeAddress(_FEE_HANDLER_KEY); }  /**  * @notice Reset the handler deadline.  * @return `true` if success.  */ function resetFeeHandler() external override onlyGovernance returns (bool) {     return _resetAddressConfig(_FEE_HANDLER_KEY); }  /**  * @notice Prepare update of estimated gas usage.  * @param gasUsage New estimated gas usage.  * @return `true` if success.  */ function prepareEstimatedGasUsage(uint256 gasUsage)     external     override     onlyGovernance     returns (bool) {     return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage); }  /**  * @notice Execute update of gas usage (with time delay enforced).  * @return `true` if successful.  */ function executeEstimatedGasUsage() external override returns (uint256) {     return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Reset the gas usage deadline.  * @return `true` if success.  */ function resetGasUsage() external override onlyGovernance returns (bool) {     return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Add a new deposit token that is supported by the action.  * @dev There is a separate check for whether the usable token (i.e. deposit token)  *      is swappable for some action token.  * @param token Address of deposit token that can be used by the action.  */ function addUsableToken(address token) external override onlyGovernance returns (bool) {     return _usableTokens.add(token); }  /**  * @notice Computes the total amount of ETH (as wei) required to pay for all  * the top-ups assuming the maximum gas price and the current estimated gas  * usage of a top-up  */ function getEthRequiredForGas(address payer) external view override returns (uint256) {     uint256 totalEthRequired;     RecordMeta[] memory userRecordsMeta = _userPositions[payer];     uint256 gasUsagePerCall = getEstimatedGasUsage();     uint256 length = userRecordsMeta.length;     for (uint256 i; i &lt; length; i = i.uncheckedInc()) {         RecordMeta memory meta = userRecordsMeta[i];         Record memory record = _positions[payer][meta.account][meta.protocol];         uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);         totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;     }     return totalEthRequired; }  /**  * @notice Returns a list of positions for the given payer  */ function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {     return _userPositions[payer]; }  /**  * @notice Get a list supported protocols.  * @return List of supported protocols.  */ function getSupportedProtocols() external view override returns (bytes32[] memory) {     uint256 length = _supportedProtocols.length();     bytes32[] memory protocols = new bytes32[](length);     for (uint256 i; i &lt; length; i = i.uncheckedInc()) {         protocols[i] = _supportedProtocols.at(i);     }     return protocols; }  /*  * @notice Gets a list of users that have an active position.  * @dev Uses cursor pagination.  * @param cursor The cursor for pagination (should start at 0 for first call).  * @param howMany Maximum number of users to return in this pagination request.  * @return users List of users that have an active position.  * @return nextCursor The cursor to use for the next pagination request.  */ function usersWithPositions(uint256 cursor, uint256 howMany)     external     view     override     returns (address[] memory users, uint256 nextCursor) {     uint256 length = _usersWithPositions.length();     if (cursor &gt;= length) return (new address[](0), 0);     if (howMany &gt;= length - cursor) {         howMany = length - cursor;     }      address[] memory usersWithPositions_ = new address[](howMany);     for (uint256 i; i &lt; howMany; i = i.uncheckedInc()) {         usersWithPositions_[i] = _usersWithPositions.at(i + cursor);     }      return (usersWithPositions_, cursor + howMany); }  /**  * @notice Get a list of all tokens usable for this action.  * @dev This refers to all tokens that can be used as deposit tokens.  * @return Array of addresses of usable tokens.  */ function getUsableTokens() external view override returns (address[] memory) {     return _usableTokens.toArray(); }  /**  * @notice Retrieves the topup handler for the given `protocol`  */ function getTopUpHandler(bytes32 protocol) external view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice Successfully tops up a position if it's conditions are met.  * @dev pool and vault funds are rebalanced after withdrawal for top up  * @param payer Account that pays for the top up.  * @param account Account owning the position for top up.  * @param beneficiary Address of the keeper's wallet for fee accrual.  * @param protocol Protocol of the top up position.  * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas  * @return `true` if successful.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol,     uint256 maxWeiForGas ) public override returns (bool) {     require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);      ExecuteLocalVars memory vars;      vars.initialGas = gasleft();      Record storage position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);     require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);     require(block.timestamp &gt; position.registeredAt, Error.CANNOT_EXECUTE_IN_SAME_BLOCK);      vars.topUpHandler = _getHandler(protocol, true);     vars.userFactor = ITopUpHandler(vars.topUpHandler).getUserFactor(account, position.extra);      // ensure that the position is actually below its set user factor threshold     require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);      IAddressProvider addressProvider_ = addressProvider;     IGasBank gasBank = addressProvider_.getGasBank();      // fail early if the user does not have enough funds in the gas bank     // to cover the cost of the transaction     vars.estimatedRequiredGas = getEstimatedGasUsage();     vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;      // compute the gas price that the user will be paying     vars.userGasPrice = block.basefee + position.priorityFee;     if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;     if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;      // ensure the current position allows for the gas to be paid     require(         vars.estimatedRequiredWeiForGas &lt;=             vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,         Error.ESTIMATED_GAS_TOO_HIGH     );      vars.gasBankBalance = gasBank.balanceOf(payer);     // ensure the user has enough funds in the gas bank to cover the gas     require(         vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,         Error.GAS_BANK_BALANCE_TOO_LOW     );      vars.totalTopUpAmount = position.totalTopUpAmount;     vars.actionFee = getActionFee();     // add top-up fees to top-up amount     vars.minActionAmountToTopUp = position.singleTopUpAmount;     vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(         ScaledMath.ONE + vars.actionFee     );      // if the amount that we want to top-up (including fees) is higher than     // the available topup amount, we lower this down to what is left of the position     if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {         vars.actionAmountWithFees = vars.totalTopUpAmount;         vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(             ScaledMath.ONE + vars.actionFee         );     }     ILiquidityPool pool = addressProvider_.getPoolForToken(position.depositToken);     vars.underlying = pool.getUnderlying();     vars.rate = pool.exchangeRate();      // compute the deposit tokens amount with and without fees     // we will need to unstake the amount with fees and to     // swap the amount without fees into action tokens     vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);     if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {         vars.depositAmountWithFees = position.depositTokenBalance;         vars.minActionAmountToTopUp =             (vars.depositAmountWithFees * vars.rate) /             (ScaledMath.ONE + vars.actionFee);     }      // compute amount of LP tokens needed to pay for action     // rate is expressed in actionToken per depositToken     vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);     vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;      // will revert if vault does not exist     address vault = addressProvider_.getStakerVault(position.depositToken);      // unstake deposit tokens including fees     IStakerVault(vault).unstake(vars.depositAmountWithFees);     IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);      // swap the amount without the fees     // as the fees are paid in deposit token, not in action token     vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);      // compute how much of action token was actually redeemed and add fees to it     // this is to ensure that no funds get locked inside the contract     vars.totalActionTokenAmount =         vars.actionTokenAmount +         vars.depositTotalFeesAmount.scaledMul(vars.rate);      // at this point, we have exactly `vars.actionTokenAmount`     // (at least `position.singleTopUpAmount`) of action token     // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract     // solhint-disable-next-line avoid-low-level-calls     uint256 value_;     if (position.actionToken == address(0)) {         value_ = vars.actionTokenAmount;     } else {         _approve(position.actionToken, vars.topUpHandler);     }     vars.topupResult = ITopUpHandler(vars.topUpHandler).topUp{value: value_}(         account,         position.actionToken,         vars.actionTokenAmount,         position.extra     );      require(vars.topupResult, Error.TOP_UP_FAILED);      // totalTopUpAmount is updated to reflect the new "balance" of the position     if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {         position.totalTopUpAmount -= vars.totalActionTokenAmount.toUint128();     } else {         position.totalTopUpAmount = 0;     }      position.depositTokenBalance -= vars.depositAmountWithFees.toUint128();      vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;     _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);     if (vars.removePosition) {         if (position.depositTokenBalance &gt; 0) {             // transfer any unused locked tokens to the payer             IStakerVault(vault).transfer(payer, position.depositTokenBalance);             IStakerVault(vault).decreaseActionLockedBalance(                 payer,                 position.depositTokenBalance             );         }         _removePosition(payer, account, protocol);     }      emit TopUp(         account,         protocol,         payer,         position.depositToken,         vars.depositAmountWithFees,         position.actionToken,         vars.actionTokenAmount     );      // compute gas used and reimburse the keeper by using the     // funds of payer in the gas bank     // TODO: add constant gas consumed for transfer and tx prologue     vars.gasConsumed = vars.initialGas - gasleft();      vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;     if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {         vars.reimbursedWeiForGas = vars.gasBankBalance;     }      // ensure that the keeper is not overpaying     vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;     require(         vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,         Error.GAS_TOO_HIGH     );     gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);     if (vars.removePosition) {         gasBank.withdrawUnused(payer);     }      return true; }  /**  * @notice Prepare new top up handler fee update.  * @dev Setting the address to 0 means that the protocol will no longer be supported.  * @param protocol Protocol for which a new handler should be prepared.  * @param newHandler Address of new handler.  * @return `true` if success.  */ function prepareTopUpHandler(bytes32 protocol, address newHandler)     public     override     onlyGovernance     returns (bool) {     return _prepare(_getProtocolKey(protocol), newHandler); }  /**  * @notice Check if action can be executed.  * @param protocol for which to get the health factor  * @param account for which to get the health factor  * @param extra data to be used by the topup handler  * @return healthFactor of the position  */ function getHealthFactor(     bytes32 protocol,     bytes32 account,     bytes calldata extra ) public view override returns (uint256 healthFactor) {     ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));     return topUpHandler.getUserFactor(account, extra); }  function getHandler(bytes32 protocol) public view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice returns the current estimated gas usage  */ function getEstimatedGasUsage() public view override returns (uint256) {     return currentUInts256[_ESTIMATED_GAS_USAGE_KEY]; }  /**  * @notice Returns the current action fee  */ function getActionFee() public view override returns (uint256) {     return currentUInts256[_ACTION_FEE_KEY]; }  /**  * @notice Returns the current fee handler  */ function getFeeHandler() public view override returns (address) {     return currentAddresses[_FEE_HANDLER_KEY]; }  /**  * @notice Get the record for a position.  * @param payer Registered payer of the position.  * @param account Address holding the position.  * @param protocol Protocol where the position is held.  */ function getPosition(     address payer,     bytes32 account,     bytes32 protocol ) public view override returns (Record memory) {     return _positions[payer][account][protocol]; }  /**  * @notice Check whether a token is usable as a deposit token.  * @param token Address of token to check.  * @return True if token is usable as a deposit token for this action.  */ function isUsable(address token) public view override returns (bool) {     return _usableTokens.contains(token); }  function _updateTopUpHandler(     bytes32 protocol,     address oldHandler,     address newHandler ) internal {     if (newHandler == address(0)) {         _supportedProtocols.remove(protocol);     } else if (oldHandler == address(0)) {         _supportedProtocols.add(protocol);     } }  /**  * @dev Pays fees to the feeHandler  * @param payer The account who's position the fees are charged on  * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)  * @param feeAmount The amount in tokens to pay as fees  * @param depositToken The LpToken used to pay the fees  */ function _payFees(     address payer,     address beneficiary,     uint256 feeAmount,     address depositToken ) internal {     address feeHandler = getFeeHandler();     IERC20(depositToken).safeApprove(feeHandler, feeAmount);     IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken); }  /**  * @dev "Locks" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function _lockFunds(     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) internal {     address stakerVaultAddress = addressProvider.getStakerVault(token);     TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount); }  function _removePosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     delete _positions[payer][account][protocol];     _removeUserPosition(payer, account, protocol);     if (_userPositions[payer].length == 0) {         _usersWithPositions.remove(payer);     }     emit Deregister(payer, account, protocol); }  function _removeUserPosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     RecordMeta[] storage positionsMeta = _userPositions[payer];     uint256 length = positionsMeta.length;     for (uint256 i; i &lt; length; i = i.uncheckedInc()) {         RecordMeta storage positionMeta = positionsMeta[i];         if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {             positionsMeta[i] = positionsMeta[length - 1];             positionsMeta.pop();             return;         }     } }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) internal {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the `actionToken`.  */ function _calcExchangeAmount(     address token,     address actionToken,     uint256 amount ) internal view returns (uint256) {     return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount); }  function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {     address handler = currentAddresses[_getProtocolKey(protocol)];     require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);     return handler; }  function _isSwappable(address depositToken, address toToken) internal view returns (bool) {     ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);     return pool.getUnderlying() == toToken; }  function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {     return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol)); }  } |
| **with_task_specify** | False |
| **memory** | None |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 12:31:21 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures
Here is a new customer's task: // SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.10;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";
import "@openzeppelin/contracts/utils/math/SafeCast.sol";

import "../../../interfaces/IGasBank.sol";
import "../../../interfaces/pool/ILiquidityPool.sol";
import "../../../interfaces/IController.sol";
import "../../../interfaces/IStakerVault.sol";
import "../../../interfaces/actions/topup/ITopUpHandler.sol";
import "../../../interfaces/actions/topup/ITopUpAction.sol";
import "../../../interfaces/actions/IActionFeeHandler.sol";

import "../../../libraries/AddressProviderHelpers.sol";
import "../../../libraries/Errors.sol";
import "../../../libraries/ScaledMath.sol";
import "../../../libraries/EnumerableExtensions.sol";
import "../../../libraries/UncheckedMath.sol";

import "../../access/Authorization.sol";
import "../../utils/Preparable.sol";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param stakerVaultAddress The address of the staker vault
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > lockAmount ? lockAmount : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            _approve(token, stakerVaultAddress);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            lockAmount -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (lockAmount > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= lockAmount) {
                stakerVault.transferFrom(payer, address(this), lockAmount);
                stakerVault.increaseActionLockedBalance(payer, lockAmount);
                lockAmount = 0;
            }
        }

        require(lockAmount == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        require(underlying == actionToken, Error.TOKEN_NOT_USABLE);
        return amount.scaledDivRoundUp(rate);
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) private {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using UncheckedMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;
    using SafeCast for uint256;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being "too deep"
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
        address topUpHandler;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 550_000;

    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";
    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        for (uint256 i; i < protocols.length; i = i.uncheckedInc()) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount`, once converted to units of `actionToken`, must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param protocol Protocol which holds position to be topped up.
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable override returns (bool) {
        require(record.maxFee != 0, Error.INVALID_MAX_FEE);
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.registeredAt = uint64(block.timestamp);
        record.depositTokenBalance = totalLockAmount.toUint128();
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        IAddressProvider addressProvider_ = addressProvider;
        address vault = addressProvider_.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider_.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external override onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee)
        external
        override
        onlyGovernance
        returns (bool)
    {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external override onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external override onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external override onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage)
        external
        override
        onlyGovernance
        returns (bool)
    {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external override returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external override onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i; i < howMany; i = i.uncheckedInc()) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);
        require(block.timestamp > position.registeredAt, Error.CANNOT_EXECUTE_IN_SAME_BLOCK);

        vars.topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(vars.topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IAddressProvider addressProvider_ = addressProvider;
        IGasBank gasBank = addressProvider_.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider_.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider_.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        uint256 value_;
        if (position.actionToken == address(0)) {
            value_ = vars.actionTokenAmount;
        } else {
            _approve(position.actionToken, vars.topUpHandler);
        }
        vars.topupResult = ITopUpHandler(vars.topUpHandler).topUp{value: value_}(
            account,
            position.actionToken,
            vars.actionTokenAmount,
            position.extra
        );

        require(vars.topupResult, Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new "balance" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= vars.totalActionTokenAmount.toUint128();
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= vars.depositAmountWithFees.toUint128();

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the address to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        override
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes calldata extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view override returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the `actionToken`.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        return pool.getUnderlying() == toToken;
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
.]

Below are the details of our target smart contract codes and their associated test reports:

Task: "// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.10;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";
import "@openzeppelin/contracts/utils/math/SafeCast.sol";

import "../../../interfaces/IGasBank.sol";
import "../../../interfaces/pool/ILiquidityPool.sol";
import "../../../interfaces/IController.sol";
import "../../../interfaces/IStakerVault.sol";
import "../../../interfaces/actions/topup/ITopUpHandler.sol";
import "../../../interfaces/actions/topup/ITopUpAction.sol";
import "../../../interfaces/actions/IActionFeeHandler.sol";

import "../../../libraries/AddressProviderHelpers.sol";
import "../../../libraries/Errors.sol";
import "../../../libraries/ScaledMath.sol";
import "../../../libraries/EnumerableExtensions.sol";
import "../../../libraries/UncheckedMath.sol";

import "../../access/Authorization.sol";
import "../../utils/Preparable.sol";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param stakerVaultAddress The address of the staker vault
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > lockAmount ? lockAmount : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            _approve(token, stakerVaultAddress);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            lockAmount -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (lockAmount > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= lockAmount) {
                stakerVault.transferFrom(payer, address(this), lockAmount);
                stakerVault.increaseActionLockedBalance(payer, lockAmount);
                lockAmount = 0;
            }
        }

        require(lockAmount == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        require(underlying == actionToken, Error.TOKEN_NOT_USABLE);
        return amount.scaledDivRoundUp(rate);
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) private {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using UncheckedMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;
    using SafeCast for uint256;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being "too deep"
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
        address topUpHandler;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 550_000;

    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";
    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        for (uint256 i; i < protocols.length; i = i.uncheckedInc()) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount`, once converted to units of `actionToken`, must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param protocol Protocol which holds position to be topped up.
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable override returns (bool) {
        require(record.maxFee != 0, Error.INVALID_MAX_FEE);
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.registeredAt = uint64(block.timestamp);
        record.depositTokenBalance = totalLockAmount.toUint128();
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        IAddressProvider addressProvider_ = addressProvider;
        address vault = addressProvider_.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider_.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external override onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee)
        external
        override
        onlyGovernance
        returns (bool)
    {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external override onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external override onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external override onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage)
        external
        override
        onlyGovernance
        returns (bool)
    {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external override returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external override onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i; i < howMany; i = i.uncheckedInc()) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);
        require(block.timestamp > position.registeredAt, Error.CANNOT_EXECUTE_IN_SAME_BLOCK);

        vars.topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(vars.topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IAddressProvider addressProvider_ = addressProvider;
        IGasBank gasBank = addressProvider_.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider_.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider_.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        uint256 value_;
        if (position.actionToken == address(0)) {
            value_ = vars.actionTokenAmount;
        } else {
            _approve(position.actionToken, vars.topUpHandler);
        }
        vars.topupResult = ITopUpHandler(vars.topUpHandler).topUp{value: value_}(
            account,
            position.actionToken,
            vars.actionTokenAmount,
            position.extra
        );

        require(vars.topupResult, Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new "balance" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= vars.totalActionTokenAmount.toUint128();
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= vars.depositAmountWithFees.toUint128();

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the address to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        override
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes calldata extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view override returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the `actionToken`.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        return pool.getUnderlying() == toToken;
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
".

Existing Test Reports:

"The software run successfully without errors."

Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings.

[2024-01-09 12:31:24 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 12:31:24 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 15521
completion_tokens: 1
total_tokens: 15522
cost: $0.046567


[2024-01-09 12:31:24 INFO] Security Testing Engineer: **Security Testing Engineer<->Solidity Programming Expert on : TestBugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.10;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";
import "@openzeppelin/contracts/utils/math/SafeCast.sol";

import "../../../interfaces/IGasBank.sol";
import "../../../interfaces/pool/ILiquidityPool.sol";
import "../../../interfaces/IController.sol";
import "../../../interfaces/IStakerVault.sol";
import "../../../interfaces/actions/topup/ITopUpHandler.sol";
import "../../../interfaces/actions/topup/ITopUpAction.sol";
import "../../../interfaces/actions/IActionFeeHandler.sol";

import "../../../libraries/AddressProviderHelpers.sol";
import "../../../libraries/Errors.sol";
import "../../../libraries/ScaledMath.sol";
import "../../../libraries/EnumerableExtensions.sol";
import "../../../libraries/UncheckedMath.sol";

import "../../access/Authorization.sol";
import "../../utils/Preparable.sol";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param stakerVaultAddress The address of the staker vault
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > lockAmount ? lockAmount : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            _approve(token, stakerVaultAddress);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            lockAmount -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (lockAmount > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= lockAmount) {
                stakerVault.transferFrom(payer, address(this), lockAmount);
                stakerVault.increaseActionLockedBalance(payer, lockAmount);
                lockAmount = 0;
            }
        }

        require(lockAmount == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        require(underlying == actionToken, Error.TOKEN_NOT_USABLE);
        return amount.scaledDivRoundUp(rate);
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) private {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using UncheckedMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;
    using SafeCast for uint256;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being "too deep"
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
        address topUpHandler;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 550_000;

    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";
    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        for (uint256 i; i < protocols.length; i = i.uncheckedInc()) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount`, once converted to units of `actionToken`, must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param protocol Protocol which holds position to be topped up.
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable override returns (bool) {
        require(record.maxFee != 0, Error.INVALID_MAX_FEE);
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.registeredAt = uint64(block.timestamp);
        record.depositTokenBalance = totalLockAmount.toUint128();
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        IAddressProvider addressProvider_ = addressProvider;
        address vault = addressProvider_.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider_.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external override onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee)
        external
        override
        onlyGovernance
        returns (bool)
    {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external override onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external override onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external override onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage)
        external
        override
        onlyGovernance
        returns (bool)
    {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external override returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external override onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i; i < howMany; i = i.uncheckedInc()) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);
        require(block.timestamp > position.registeredAt, Error.CANNOT_EXECUTE_IN_SAME_BLOCK);

        vars.topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(vars.topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IAddressProvider addressProvider_ = addressProvider;
        IGasBank gasBank = addressProvider_.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider_.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider_.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        uint256 value_;
        if (position.actionToken == address(0)) {
            value_ = vars.actionTokenAmount;
        } else {
            _approve(position.actionToken, vars.topUpHandler);
        }
        vars.topupResult = ITopUpHandler(vars.topUpHandler).topUp{value: value_}(
            account,
            position.actionToken,
            vars.actionTokenAmount,
            position.extra
        );

        require(vars.topupResult, Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new "balance" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= vars.totalActionTokenAmount.toUint128();
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= vars.depositAmountWithFees.toUint128();

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the address to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        override
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes calldata extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view override returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i; i < length; i = i.uncheckedInc()) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the `actionToken`.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        return pool.getUnderlying() == toToken;
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
.]

###

[2024-01-09 12:31:24 INFO] **[Seminar Conclusion]**:

 ###

[2024-01-09 12:31:24 INFO] **[Post Info]**

Software Info: 

💰**cost**=$0.000000

🔨**version_updates**=1.0

📃**num_code_files**=0

🏞**num_png_files**=0

📚**num_doc_files**=5

📃**code_lines**=0

📋**env_lines**=-1

📒**manual_lines**=-1

🗣**num_utterances**=18

🤔**num_self_reflections**=1

❓**num_prompt_tokens**=123338

❗**num_completion_tokens**=5688

🌟**num_total_tokens**=129026

🕑**duration**=90.00s

ChatDev Starts (20240901122954)

ChatDev Ends (20240901123124)



