[2024-01-09 04:31:11 INFO] **[Preprocessing]**

**ChatDev Starts** (20240901043111)

**Timestamp**: 20240901043111

**config_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/ChatChainConfig.json

**config_phase_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/PhaseConfig.json

**config_role_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/RoleConfig.json

**task_prompt**: pragma solidity ^0.5.0;

import "openzeppelin-solidity/contracts/math/SafeMath.sol";
import "openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol";
import "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol";
import "openzeppelin-solidity/contracts/utils/Address.sol";
import "../libraries/openzeppelin-upgradeability/VersionedInitializable.sol";

import "../libraries/CoreLibrary.sol";
import "../configuration/LendingPoolAddressesProvider.sol";
import "../interfaces/ILendingRateOracle.sol";
import "../interfaces/IReserveInterestRateStrategy.sol";
import "../libraries/WadRayMath.sol";
import "../tokenization/AToken.sol";
import "../libraries/EthAddressLib.sol";

/**
* @title LendingPoolCore contract
* @author Aave
* @notice Holds the state of the lending pool and all the funds deposited
* @dev NOTE: The core does not enforce security checks on the update of the state
* (eg, updateStateOnBorrow() does not enforce that borrowed is enabled on the reserve).
* The check that an action can be performed is a duty of the overlying LendingPool contract.
**/

contract LendingPoolCore is VersionedInitializable {
    using SafeMath for uint256;
    using WadRayMath for uint256;
    using CoreLibrary for CoreLibrary.ReserveData;
    using CoreLibrary for CoreLibrary.UserReserveData;
    using SafeERC20 for ERC20;
    using Address for address payable;

    /**
    * @dev Emitted when the state of a reserve is updated
    * @param reserve the address of the reserve
    * @param liquidityRate the new liquidity rate
    * @param stableBorrowRate the new stable borrow rate
    * @param variableBorrowRate the new variable borrow rate
    * @param liquidityIndex the new liquidity index
    * @param variableBorrowIndex the new variable borrow index
    **/
    event ReserveUpdated(
        address indexed reserve,
        uint256 liquidityRate,
        uint256 stableBorrowRate,
        uint256 variableBorrowRate,
        uint256 liquidityIndex,
        uint256 variableBorrowIndex
    );

    address public lendingPoolAddress;

    LendingPoolAddressesProvider public addressesProvider;

    /**
    * @dev only lending pools can use functions affected by this modifier
    **/
    modifier onlyLendingPool {
        require(lendingPoolAddress == msg.sender, "The caller must be a lending pool contract");
        _;
    }

    /**
    * @dev only lending pools configurator can use functions affected by this modifier
    **/
    modifier onlyLendingPoolConfigurator {
        require(
            addressesProvider.getLendingPoolConfigurator() == msg.sender,
            "The caller must be a lending pool configurator contract"
        );
        _;
    }

    mapping(address => CoreLibrary.ReserveData) internal reserves;
    mapping(address => mapping(address => CoreLibrary.UserReserveData)) internal usersReserveData;

    address[] public reservesList;

    uint256 public constant CORE_REVISION = 0x4;

    /**
    * @dev returns the revision number of the contract
    **/
    function getRevision() internal pure returns (uint256) {
        return CORE_REVISION;
    }

    /**
    * @dev initializes the Core contract, invoked upon registration on the AddressesProvider
    * @param _addressesProvider the addressesProvider contract
    **/

    function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {
        addressesProvider = _addressesProvider;
        refreshConfigInternal();
    }

    /**
    * @dev updates the state of the core as a result of a deposit action
    * @param _reserve the address of the reserve in which the deposit is happening
    * @param _user the address of the the user depositing
    * @param _amount the amount being deposited
    * @param _isFirstDeposit true if the user is depositing for the first time
    **/

    function updateStateOnDeposit(
        address _reserve,
        address _user,
        uint256 _amount,
        bool _isFirstDeposit
    ) external onlyLendingPool {
        reserves[_reserve].updateCumulativeIndexes();
        updateReserveInterestRatesAndTimestampInternal(_reserve, _amount, 0);

        if (_isFirstDeposit) {
            //if this is the first deposit of the user, we configure the deposit as enabled to be used as collateral
            setUserUseReserveAsCollateral(_reserve, _user, true);
        }
    }

    /**
    * @dev updates the state of the core as a result of a redeem action
    * @param _reserve the address of the reserve in which the redeem is happening
    * @param _user the address of the the user redeeming
    * @param _amountRedeemed the amount being redeemed
    * @param _userRedeemedEverything true if the user is redeeming everything
    **/
    function updateStateOnRedeem(
        address _reserve,
        address _user,
        uint256 _amountRedeemed,
        bool _userRedeemedEverything
    ) external onlyLendingPool {
        //compound liquidity and variable borrow interests
        reserves[_reserve].updateCumulativeIndexes();
        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountRedeemed);

        //if user redeemed everything the useReserveAsCollateral flag is reset
        if (_userRedeemedEverything) {
            setUserUseReserveAsCollateral(_reserve, _user, false);
        }
    }

    /**
    * @dev updates the state of the core as a result of a flashloan action
    * @param _reserve the address of the reserve in which the flashloan is happening
    * @param _income the income of the protocol as a result of the action
    **/
    function updateStateOnFlashLoan(
        address _reserve,
        uint256 _availableLiquidityBefore,
        uint256 _income,
        uint256 _protocolFee
    ) external onlyLendingPool {
        transferFlashLoanProtocolFeeInternal(_reserve, _protocolFee);

        //compounding the cumulated interest
        reserves[_reserve].updateCumulativeIndexes();

        uint256 totalLiquidityBefore = _availableLiquidityBefore.add(
            getReserveTotalBorrows(_reserve)
        );

        //compounding the received fee into the reserve
        reserves[_reserve].cumulateToLiquidityIndex(totalLiquidityBefore, _income);

        //refresh interest rates
        updateReserveInterestRatesAndTimestampInternal(_reserve, _income, 0);
    }

    /**
    * @dev updates the state of the core as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _amountBorrowed the new amount borrowed
    * @param _borrowFee the fee on the amount borrowed
    * @param _rateMode the borrow rate mode (stable, variable)
    * @return the new borrow rate for the user
    **/
    function updateStateOnBorrow(
        address _reserve,
        address _user,
        uint256 _amountBorrowed,
        uint256 _borrowFee,
        CoreLibrary.InterestRateMode _rateMode
    ) external onlyLendingPool returns (uint256, uint256) {
        // getting the previous borrow data of the user
        (uint256 principalBorrowBalance, , uint256 balanceIncrease) = getUserBorrowBalances(
            _reserve,
            _user
        );

        updateReserveStateOnBorrowInternal(
            _reserve,
            _user,
            principalBorrowBalance,
            balanceIncrease,
            _amountBorrowed,
            _rateMode
        );

        updateUserStateOnBorrowInternal(
            _reserve,
            _user,
            _amountBorrowed,
            balanceIncrease,
            _borrowFee,
            _rateMode
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountBorrowed);

        return (getUserCurrentBorrowRate(_reserve, _user), balanceIncrease);
    }

    /**
    * @dev updates the state of the core as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _originationFeeRepaid the fee on the amount that is being repaid
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _repaidWholeLoan true if the user is repaying the whole loan
    **/

    function updateStateOnRepay(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _originationFeeRepaid,
        uint256 _balanceIncrease,
        bool _repaidWholeLoan
    ) external onlyLendingPool {
        updateReserveStateOnRepayInternal(
            _reserve,
            _user,
            _paybackAmountMinusFees,
            _balanceIncrease
        );
        updateUserStateOnRepayInternal(
            _reserve,
            _user,
            _paybackAmountMinusFees,
            _originationFeeRepaid,
            _balanceIncrease,
            _repaidWholeLoan
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, _paybackAmountMinusFees, 0);
    }

    /**
    * @dev updates the state of the core as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the amount borrowed by the user
    * @param _compoundedBorrowBalance the amount borrowed plus accrued interest
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _currentRateMode the current interest rate mode for the user
    **/
    function updateStateOnSwapRate(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _compoundedBorrowBalance,
        uint256 _balanceIncrease,
        CoreLibrary.InterestRateMode _currentRateMode
    ) external onlyLendingPool returns (CoreLibrary.InterestRateMode, uint256) {
        updateReserveStateOnSwapRateInternal(
            _reserve,
            _user,
            _principalBorrowBalance,
            _compoundedBorrowBalance,
            _currentRateMode
        );

        CoreLibrary.InterestRateMode newRateMode = updateUserStateOnSwapRateInternal(
            _reserve,
            _user,
            _balanceIncrease,
            _currentRateMode
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);

        return (newRateMode, getUserCurrentBorrowRate(_reserve, _user));
    }

    /**
    * @dev updates the state of the core as a consequence of a liquidation action.
    * @param _principalReserve the address of the principal reserve that is being repaid
    * @param _collateralReserve the address of the collateral reserve that is being liquidated
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _collateralToLiquidate the amount of collateral being liquidated
    * @param _feeLiquidated the amount of origination fee being liquidated
    * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise
    **/
    function updateStateOnLiquidation(
        address _principalReserve,
        address _collateralReserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _collateralToLiquidate,
        uint256 _feeLiquidated,
        uint256 _liquidatedCollateralForFee,
        uint256 _balanceIncrease,
        bool _liquidatorReceivesAToken
    ) external onlyLendingPool {
        updatePrincipalReserveStateOnLiquidationInternal(
            _principalReserve,
            _user,
            _amountToLiquidate,
            _balanceIncrease
        );

        updateCollateralReserveStateOnLiquidationInternal(
            _collateralReserve
        );

        updateUserStateOnLiquidationInternal(
            _principalReserve,
            _user,
            _amountToLiquidate,
            _feeLiquidated,
            _balanceIncrease
        );

        updateReserveInterestRatesAndTimestampInternal(_principalReserve, _amountToLiquidate, 0);

        if (!_liquidatorReceivesAToken) {
            updateReserveInterestRatesAndTimestampInternal(
                _collateralReserve,
                0,
                _collateralToLiquidate.add(_liquidatedCollateralForFee)
            );
        }

    }

    /**
    * @dev updates the state of the core as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @return the new stable rate for the user
    **/
    function updateStateOnRebalance(address _reserve, address _user, uint256 _balanceIncrease)
    external
    onlyLendingPool
    returns (uint256)
    {
        updateReserveStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);

        //update user data and rebalance the rate
        updateUserStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);
        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);
        return usersReserveData[_user][_reserve].stableBorrowRate;
    }

    /**
    * @dev enables or disables a reserve as collateral
    * @param _reserve the address of the principal reserve where the user deposited
    * @param _user the address of the depositor
    * @param _useAsCollateral true if the depositor wants to use the reserve as collateral
    **/
    function setUserUseReserveAsCollateral(address _reserve, address _user, bool _useAsCollateral)
    public
    onlyLendingPool
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        user.useAsCollateral = _useAsCollateral;
    }

    /**
    * @notice ETH/token transfer functions
    **/

    /**
    * @dev fallback function enforces that the caller is a contract, to support flashloan transfers
    **/
    function() external payable {
        //only contracts can send ETH to the core
        require(msg.sender.isContract(), "Only contracts can send ether to the Lending pool core");

    }

    /**
    * @dev transfers to the user a specific amount from the reserve.
    * @param _reserve the address of the reserve where the transfer is happening
    * @param _user the address of the user receiving the transfer
    * @param _amount the amount being transferred
    **/
    function transferToUser(address _reserve, address payable _user, uint256 _amount)
    external
    onlyLendingPool
    {
        if (_reserve != EthAddressLib.ethAddress()) {
            ERC20(_reserve).safeTransfer(_user, _amount);
        } else {
            //solium-disable-next-line
            (bool result, ) = _user.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers the protocol fees to the fees collection address
    * @param _token the address of the token being transferred
    * @param _user the address of the user from where the transfer is happening
    * @param _amount the amount being transferred
    * @param _destination the fee receiver address
    **/

    function transferToFeeCollectionAddress(
        address _token,
        address _user,
        uint256 _amount,
        address _destination
    ) external payable onlyLendingPool {
        address payable feeAddress = address(uint160(_destination)); //cast the address to payable

        if (_token != EthAddressLib.ethAddress()) {
            require(
                msg.value == 0,
                "User is sending ETH along with the ERC20 transfer. Check the value attribute of the transaction"
            );
            ERC20(_token).safeTransferFrom(_user, feeAddress, _amount);
        } else {
            require(msg.value >= _amount, "The amount and the value sent to deposit do not match");
            //solium-disable-next-line
            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers the fees to the fees collection address in the case of liquidation
    * @param _token the address of the token being transferred
    * @param _amount the amount being transferred
    * @param _destination the fee receiver address
    **/
    function liquidateFee(
        address _token,
        uint256 _amount,
        address _destination
    ) external payable onlyLendingPool {
        address payable feeAddress = address(uint160(_destination)); //cast the address to payable
        require(
            msg.value == 0,
            "Fee liquidation does not require any transfer of value"
        );

        if (_token != EthAddressLib.ethAddress()) {
            ERC20(_token).safeTransfer(feeAddress, _amount);
        } else {
            //solium-disable-next-line
            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers an amount from a user to the destination reserve
    * @param _reserve the address of the reserve where the amount is being transferred
    * @param _user the address of the user from where the transfer is happening
    * @param _amount the amount being transferred
    **/
    function transferToReserve(address _reserve, address payable _user, uint256 _amount)
    external
    payable
    onlyLendingPool
    {
        if (_reserve != EthAddressLib.ethAddress()) {
            require(msg.value == 0, "User is sending ETH along with the ERC20 transfer.");
            ERC20(_reserve).safeTransferFrom(_user, address(this), _amount);

        } else {
            require(msg.value >= _amount, "The amount and the value sent to deposit do not match");

            if (msg.value > _amount) {
                //send back excess ETH
                uint256 excessAmount = msg.value.sub(_amount);
                //solium-disable-next-line
                (bool result, ) = _user.call.value(excessAmount).gas(50000)("");
                require(result, "Transfer of ETH failed");
            }
        }
    }

    /**
    * @notice data access functions
    **/

    /**
    * @dev returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral)
    * needed to calculate the global account data in the LendingPoolDataProvider
    * @param _reserve the address of the reserve
    * @param _user the address of the user
    * @return the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not
    **/
    function getUserBasicReserveData(address _reserve, address _user)
    external
    view
    returns (uint256, uint256, uint256, bool)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        uint256 underlyingBalance = getUserUnderlyingAssetBalance(_reserve, _user);

        if (user.principalBorrowBalance == 0) {
            return (underlyingBalance, 0, 0, user.useAsCollateral);
        }

        return (
        underlyingBalance,
        user.getCompoundedBorrowBalance(reserve),
        user.originationFee,
        user.useAsCollateral
        );
    }

    /**
    * @dev checks if a user is allowed to borrow at a stable rate
    * @param _reserve the reserve address
    * @param _user the user
    * @param _amount the amount the the user wants to borrow
    * @return true if the user is allowed to borrow at a stable rate, false otherwise
    **/

    function isUserAllowedToBorrowAtStable(address _reserve, address _user, uint256 _amount)
    external
    view
    returns (bool)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (!reserve.isStableBorrowRateEnabled) return false;

        return
        !user.useAsCollateral ||
        !reserve.usageAsCollateralEnabled ||
        _amount > getUserUnderlyingAssetBalance(_reserve, _user);
    }

    /**
    * @dev gets the underlying asset balance of a user based on the corresponding aToken balance.
    * @param _reserve the reserve address
    * @param _user the user address
    * @return the underlying deposit balance of the user
    **/

    function getUserUnderlyingAssetBalance(address _reserve, address _user)
    public
    view
    returns (uint256)
    {
        AToken aToken = AToken(reserves[_reserve].aTokenAddress);
        return aToken.balanceOf(_user);

    }

    /**
    * @dev gets the interest rate strategy contract address for the reserve
    * @param _reserve the reserve address
    * @return the address of the interest rate strategy contract
    **/
    function getReserveInterestRateStrategyAddress(address _reserve) public view returns (address) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.interestRateStrategyAddress;
    }

    /**
    * @dev gets the aToken contract address for the reserve
    * @param _reserve the reserve address
    * @return the address of the aToken contract
    **/

    function getReserveATokenAddress(address _reserve) public view returns (address) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.aTokenAddress;
    }

    /**
    * @dev gets the available liquidity in the reserve. The available liquidity is the balance of the core contract
    * @param _reserve the reserve address
    * @return the available liquidity
    **/
    function getReserveAvailableLiquidity(address _reserve) public view returns (uint256) {
        uint256 balance = 0;

        if (_reserve == EthAddressLib.ethAddress()) {
            balance = address(this).balance;
        } else {
            balance = IERC20(_reserve).balanceOf(address(this));
        }
        return balance;
    }

    /**
    * @dev gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows
    * @param _reserve the reserve address
    * @return the total liquidity
    **/
    function getReserveTotalLiquidity(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return getReserveAvailableLiquidity(_reserve).add(reserve.getTotalBorrows());
    }

    /**
    * @dev gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there
    * there has been 100% income.
    * @param _reserve the reserve address
    * @return the reserve normalized income
    **/
    function getReserveNormalizedIncome(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.getNormalizedIncome();
    }

    /**
    * @dev gets the reserve total borrows
    * @param _reserve the reserve address
    * @return the total borrows (stable + variable)
    **/
    function getReserveTotalBorrows(address _reserve) public view returns (uint256) {
        return reserves[_reserve].getTotalBorrows();
    }

    /**
    * @dev gets the reserve total borrows stable
    * @param _reserve the reserve address
    * @return the total borrows stable
    **/
    function getReserveTotalBorrowsStable(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.totalBorrowsStable;
    }

    /**
    * @dev gets the reserve total borrows variable
    * @param _reserve the reserve address
    * @return the total borrows variable
    **/

    function getReserveTotalBorrowsVariable(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.totalBorrowsVariable;
    }

    /**
    * @dev gets the reserve liquidation threshold
    * @param _reserve the reserve address
    * @return the reserve liquidation threshold
    **/

    function getReserveLiquidationThreshold(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.liquidationThreshold;
    }

    /**
    * @dev gets the reserve liquidation bonus
    * @param _reserve the reserve address
    * @return the reserve liquidation bonus
    **/

    function getReserveLiquidationBonus(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.liquidationBonus;
    }

    /**
    * @dev gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty
    * @param _reserve the reserve address
    * @return the reserve current variable borrow rate
    **/

    function getReserveCurrentVariableBorrowRate(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        if (reserve.currentVariableBorrowRate == 0) {
            return
            IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)
            .getBaseVariableBorrowRate();
        }
        return reserve.currentVariableBorrowRate;
    }

    /**
    * @dev gets the reserve current stable borrow rate. Is the market rate if the reserve is empty
    * @param _reserve the reserve address
    * @return the reserve current stable borrow rate
    **/

    function getReserveCurrentStableBorrowRate(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        ILendingRateOracle oracle = ILendingRateOracle(addressesProvider.getLendingRateOracle());

        if (reserve.currentStableBorrowRate == 0) {
            //no stable rate borrows yet
            return oracle.getMarketBorrowRate(_reserve);
        }

        return reserve.currentStableBorrowRate;
    }

    /**
    * @dev gets the reserve average stable borrow rate. The average stable rate is the weighted average
    * of all the loans taken at stable rate.
    * @param _reserve the reserve address
    * @return the reserve current average borrow rate
    **/
    function getReserveCurrentAverageStableBorrowRate(address _reserve)
    external
    view
    returns (uint256)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.currentAverageStableBorrowRate;
    }

    /**
    * @dev gets the reserve liquidity rate
    * @param _reserve the reserve address
    * @return the reserve liquidity rate
    **/
    function getReserveCurrentLiquidityRate(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.currentLiquidityRate;
    }

    /**
    * @dev gets the reserve liquidity cumulative index
    * @param _reserve the reserve address
    * @return the reserve liquidity cumulative index
    **/
    function getReserveLiquidityCumulativeIndex(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.lastLiquidityCumulativeIndex;
    }

    /**
    * @dev gets the reserve variable borrow index
    * @param _reserve the reserve address
    * @return the reserve variable borrow index
    **/
    function getReserveVariableBorrowsCumulativeIndex(address _reserve)
    external
    view
    returns (uint256)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.lastVariableBorrowCumulativeIndex;
    }

    /**
    * @dev this function aggregates the configuration parameters of the reserve.
    * It's used in the LendingPoolDataProvider specifically to save gas, and avoid
    * multiple external contract calls to fetch the same data.
    * @param _reserve the reserve address
    * @return the reserve decimals
    * @return the base ltv as collateral
    * @return the liquidation threshold
    * @return if the reserve is used as collateral or not
    **/
    function getReserveConfiguration(address _reserve)
    external
    view
    returns (uint256, uint256, uint256, bool)
    {
        uint256 decimals;
        uint256 baseLTVasCollateral;
        uint256 liquidationThreshold;
        bool usageAsCollateralEnabled;

        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        decimals = reserve.decimals;
        baseLTVasCollateral = reserve.baseLTVasCollateral;
        liquidationThreshold = reserve.liquidationThreshold;
        usageAsCollateralEnabled = reserve.usageAsCollateralEnabled;

        return (decimals, baseLTVasCollateral, liquidationThreshold, usageAsCollateralEnabled);
    }

    /**
    * @dev returns the decimals of the reserve
    * @param _reserve the reserve address
    * @return the reserve decimals
    **/
    function getReserveDecimals(address _reserve) external view returns (uint256) {
        return reserves[_reserve].decimals;
    }

    /**
    * @dev returns true if the reserve is enabled for borrowing
    * @param _reserve the reserve address
    * @return true if the reserve is enabled for borrowing, false otherwise
    **/

    function isReserveBorrowingEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.borrowingEnabled;
    }

    /**
    * @dev returns true if the reserve is enabled as collateral
    * @param _reserve the reserve address
    * @return true if the reserve is enabled as collateral, false otherwise
    **/

    function isReserveUsageAsCollateralEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.usageAsCollateralEnabled;
    }

    /**
    * @dev returns true if the stable rate is enabled on reserve
    * @param _reserve the reserve address
    * @return true if the stable rate is enabled on reserve, false otherwise
    **/
    function getReserveIsStableBorrowRateEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isStableBorrowRateEnabled;
    }

    /**
    * @dev returns true if the reserve is active
    * @param _reserve the reserve address
    * @return true if the reserve is active, false otherwise
    **/
    function getReserveIsActive(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isActive;
    }

    /**
    * @notice returns if a reserve is freezed
    * @param _reserve the reserve for which the information is needed
    * @return true if the reserve is freezed, false otherwise
    **/

    function getReserveIsFreezed(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isFreezed;
    }

    /**
    * @notice returns the timestamp of the last action on the reserve
    * @param _reserve the reserve for which the information is needed
    * @return the last updated timestamp of the reserve
    **/

    function getReserveLastUpdate(address _reserve) external view returns (uint40 timestamp) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        timestamp = reserve.lastUpdateTimestamp;
    }

    /**
    * @dev returns the utilization rate U of a specific reserve
    * @param _reserve the reserve for which the information is needed
    * @return the utilization rate in ray
    **/

    function getReserveUtilizationRate(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        uint256 totalBorrows = reserve.getTotalBorrows();

        if (totalBorrows == 0) {
            return 0;
        }

        uint256 availableLiquidity = getReserveAvailableLiquidity(_reserve);

        return totalBorrows.rayDiv(availableLiquidity.add(totalBorrows));
    }

    /**
    * @return the array of reserves configured on the core
    **/
    function getReserves() external view returns (address[] memory) {
        return reservesList;
    }

    /**
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return true if the user has chosen to use the reserve as collateral, false otherwise
    **/
    function isUserUseReserveAsCollateralEnabled(address _reserve, address _user)
    external
    view
    returns (bool)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.useAsCollateral;
    }

    /**
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the origination fee for the user
    **/
    function getUserOriginationFee(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.originationFee;
    }

    /**
    * @dev users with no loans in progress have NONE as borrow rate mode
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the borrow rate mode for the user,
    **/

    function getUserCurrentBorrowRateMode(address _reserve, address _user)
    public
    view
    returns (CoreLibrary.InterestRateMode)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (user.principalBorrowBalance == 0) {
            return CoreLibrary.InterestRateMode.NONE;
        }

        return
        user.stableBorrowRate > 0
        ? CoreLibrary.InterestRateMode.STABLE
        : CoreLibrary.InterestRateMode.VARIABLE;
    }

    /**
    * @dev gets the current borrow rate of the user
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the borrow rate for the user,
    **/
    function getUserCurrentBorrowRate(address _reserve, address _user)
    internal
    view
    returns (uint256)
    {
        CoreLibrary.InterestRateMode rateMode = getUserCurrentBorrowRateMode(_reserve, _user);

        if (rateMode == CoreLibrary.InterestRateMode.NONE) {
            return 0;
        }

        return
        rateMode == CoreLibrary.InterestRateMode.STABLE
        ? usersReserveData[_user][_reserve].stableBorrowRate
        : reserves[_reserve].currentVariableBorrowRate;
    }

    /**
    * @dev the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the user stable rate
    **/
    function getUserCurrentStableBorrowRate(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.stableBorrowRate;
    }

    /**
    * @dev calculates and returns the borrow balances of the user
    * @param _reserve the address of the reserve
    * @param _user the address of the user
    * @return the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance
    **/

    function getUserBorrowBalances(address _reserve, address _user)
    public
    view
    returns (uint256, uint256, uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        if (user.principalBorrowBalance == 0) {
            return (0, 0, 0);
        }

        uint256 principal = user.principalBorrowBalance;
        uint256 compoundedBalance = CoreLibrary.getCompoundedBorrowBalance(
            user,
            reserves[_reserve]
        );
        return (principal, compoundedBalance, compoundedBalance.sub(principal));
    }

    /**
    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the variable borrow index for the user
    **/

    function getUserVariableBorrowCumulativeIndex(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.lastVariableBorrowCumulativeIndex;
    }

    /**
    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the variable borrow index for the user
    **/

    function getUserLastUpdate(address _reserve, address _user)
    external
    view
    returns (uint256 timestamp)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        timestamp = user.lastUpdateTimestamp;
    }

    /**
    * @dev updates the lending pool core configuration
    **/
    function refreshConfiguration() external onlyLendingPoolConfigurator {
        refreshConfigInternal();
    }

    /**
    * @dev initializes a reserve
    * @param _reserve the address of the reserve
    * @param _aTokenAddress the address of the overlying aToken contract
    * @param _decimals the decimals of the reserve currency
    * @param _interestRateStrategyAddress the address of the interest rate strategy contract
    **/
    function initReserve(
        address _reserve,
        address _aTokenAddress,
        uint256 _decimals,
        address _interestRateStrategyAddress
    ) external onlyLendingPoolConfigurator {
        reserves[_reserve].init(_aTokenAddress, _decimals, _interestRateStrategyAddress);
        addReserveToListInternal(_reserve);

    }



    /**
    * @dev removes the last added reserve in the reservesList array
    * @param _reserveToRemove the address of the reserve
    **/
    function removeLastAddedReserve(address _reserveToRemove)
    external onlyLendingPoolConfigurator {

        address lastReserve = reservesList[reservesList.length-1];

        require(lastReserve == _reserveToRemove, "Reserve being removed is different than the reserve requested");

        //as we can't check if totalLiquidity is 0 (since the reserve added might not be an ERC20) we at least check that there is nothing borrowed
        require(getReserveTotalBorrows(lastReserve) == 0, "Cannot remove a reserve with liquidity deposited");

        reserves[lastReserve].isActive = false;
        reserves[lastReserve].aTokenAddress = address(0);
        reserves[lastReserve].decimals = 0;
        reserves[lastReserve].lastLiquidityCumulativeIndex = 0;
        reserves[lastReserve].lastVariableBorrowCumulativeIndex = 0;
        reserves[lastReserve].borrowingEnabled = false;
        reserves[lastReserve].usageAsCollateralEnabled = false;
        reserves[lastReserve].baseLTVasCollateral = 0;
        reserves[lastReserve].liquidationThreshold = 0;
        reserves[lastReserve].liquidationBonus = 0;
        reserves[lastReserve].interestRateStrategyAddress = address(0);

        reservesList.pop();
    }

    /**
    * @dev updates the address of the interest rate strategy contract
    * @param _reserve the address of the reserve
    * @param _rateStrategyAddress the address of the interest rate strategy contract
    **/

    function setReserveInterestRateStrategyAddress(address _reserve, address _rateStrategyAddress)
    external
    onlyLendingPoolConfigurator
    {
        reserves[_reserve].interestRateStrategyAddress = _rateStrategyAddress;
    }

    /**
    * @dev enables borrowing on a reserve. Also sets the stable rate borrowing
    * @param _reserve the address of the reserve
    * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise
    **/

    function enableBorrowingOnReserve(address _reserve, bool _stableBorrowRateEnabled)
    external
    onlyLendingPoolConfigurator
    {
        reserves[_reserve].enableBorrowing(_stableBorrowRateEnabled);
    }

    /**
    * @dev disables borrowing on a reserve
    * @param _reserve the address of the reserve
    **/

    function disableBorrowingOnReserve(address _reserve) external onlyLendingPoolConfigurator {
        reserves[_reserve].disableBorrowing();
    }

    /**
    * @dev enables a reserve to be used as collateral
    * @param _reserve the address of the reserve
    **/
    function enableReserveAsCollateral(
        address _reserve,
        uint256 _baseLTVasCollateral,
        uint256 _liquidationThreshold,
        uint256 _liquidationBonus
    ) external onlyLendingPoolConfigurator {
        reserves[_reserve].enableAsCollateral(
            _baseLTVasCollateral,
            _liquidationThreshold,
            _liquidationBonus
        );
    }

    /**
    * @dev disables a reserve to be used as collateral
    * @param _reserve the address of the reserve
    **/
    function disableReserveAsCollateral(address _reserve) external onlyLendingPoolConfigurator {
        reserves[_reserve].disableAsCollateral();
    }

    /**
    * @dev enable the stable borrow rate mode on a reserve
    * @param _reserve the address of the reserve
    **/
    function enableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isStableBorrowRateEnabled = true;
    }

    /**
    * @dev disable the stable borrow rate mode on a reserve
    * @param _reserve the address of the reserve
    **/
    function disableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isStableBorrowRateEnabled = false;
    }

    /**
    * @dev activates a reserve
    * @param _reserve the address of the reserve
    **/
    function activateReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        require(
            reserve.lastLiquidityCumulativeIndex > 0 &&
            reserve.lastVariableBorrowCumulativeIndex > 0,
            "Reserve has not been initialized yet"
        );
        reserve.isActive = true;
    }

    /**
    * @dev deactivates a reserve
    * @param _reserve the address of the reserve
    **/
    function deactivateReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isActive = false;
    }

    /**
    * @notice allows the configurator to freeze the reserve.
    * A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance.
    * @param _reserve the address of the reserve
    **/
    function freezeReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isFreezed = true;
    }

    /**
    * @notice allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed.
    * @param _reserve the address of the reserve
    **/
    function unfreezeReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isFreezed = false;
    }

    /**
    * @notice allows the configurator to update the loan to value of a reserve
    * @param _reserve the address of the reserve
    * @param _ltv the new loan to value
    **/
    function setReserveBaseLTVasCollateral(address _reserve, uint256 _ltv)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.baseLTVasCollateral = _ltv;
    }

    /**
    * @notice allows the configurator to update the liquidation threshold of a reserve
    * @param _reserve the address of the reserve
    * @param _threshold the new liquidation threshold
    **/
    function setReserveLiquidationThreshold(address _reserve, uint256 _threshold)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.liquidationThreshold = _threshold;
    }

    /**
    * @notice allows the configurator to update the liquidation bonus of a reserve
    * @param _reserve the address of the reserve
    * @param _bonus the new liquidation bonus
    **/
    function setReserveLiquidationBonus(address _reserve, uint256 _bonus)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.liquidationBonus = _bonus;
    }

    /**
    * @notice allows the configurator to update the reserve decimals
    * @param _reserve the address of the reserve
    * @param _decimals the decimals of the reserve
    **/
    function setReserveDecimals(address _reserve, uint256 _decimals)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.decimals = _decimals;
    }

    /**
    * @notice internal functions
    **/

    /**
    * @dev updates the state of a reserve as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the previous borrow balance of the borrower before the action
    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount
    * @param _amountBorrowed the new amount borrowed
    * @param _rateMode the borrow rate mode (stable, variable)
    **/

    function updateReserveStateOnBorrowInternal(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _balanceIncrease,
        uint256 _amountBorrowed,
        CoreLibrary.InterestRateMode _rateMode
    ) internal {
        reserves[_reserve].updateCumulativeIndexes();

        //increasing reserve total borrows to account for the new borrow balance of the user
        //NOTE: Depending on the previous borrow mode, the borrows might need to be switched from variable to stable or vice versa

        updateReserveTotalBorrowsByRateModeInternal(
            _reserve,
            _user,
            _principalBorrowBalance,
            _balanceIncrease,
            _amountBorrowed,
            _rateMode
        );
    }

    /**
    * @dev updates the state of a user as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _amountBorrowed the amount borrowed
    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount
    * @param _rateMode the borrow rate mode (stable, variable)
    * @return the final borrow rate for the user. Emitted by the borrow() event
    **/

    function updateUserStateOnBorrowInternal(
        address _reserve,
        address _user,
        uint256 _amountBorrowed,
        uint256 _balanceIncrease,
        uint256 _fee,
        CoreLibrary.InterestRateMode _rateMode
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (_rateMode == CoreLibrary.InterestRateMode.STABLE) {
            //stable
            //reset the user variable index, and update the stable rate
            user.stableBorrowRate = reserve.currentStableBorrowRate;
            user.lastVariableBorrowCumulativeIndex = 0;
        } else if (_rateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //variable
            //reset the user stable rate, and store the new borrow index
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        } else {
            revert("Invalid borrow rate mode");
        }
        //increase the principal borrows and the origination fee
        user.principalBorrowBalance = user.principalBorrowBalance.add(_amountBorrowed).add(
            _balanceIncrease
        );
        user.originationFee = user.originationFee.add(_fee);

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

    }

    /**
    * @dev updates the state of the reserve as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateReserveStateOnRepayInternal(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_reserve][_user];

        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(_reserve, _user);

        //update the indexes
        reserves[_reserve].updateCumulativeIndexes();

        //compound the cumulated interest to the borrow balance and then subtracting the payback amount
        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _balanceIncrease,
                user.stableBorrowRate
            );
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _paybackAmountMinusFees,
                user.stableBorrowRate
            );
        } else {
            reserve.increaseTotalBorrowsVariable(_balanceIncrease);
            reserve.decreaseTotalBorrowsVariable(_paybackAmountMinusFees);
        }
    }

    /**
    * @dev updates the state of the user as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _originationFeeRepaid the fee on the amount that is being repaid
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _repaidWholeLoan true if the user is repaying the whole loan
    **/
    function updateUserStateOnRepayInternal(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _originationFeeRepaid,
        uint256 _balanceIncrease,
        bool _repaidWholeLoan
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        //update the user principal borrow balance, adding the cumulated interest and then subtracting the payback amount
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(
            _paybackAmountMinusFees
        );
        user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;

        //if the balance decrease is equal to the previous principal (user is repaying the whole loan)
        //and the rate mode is stable, we reset the interest rate mode of the user
        if (_repaidWholeLoan) {
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = 0;
        }
        user.originationFee = user.originationFee.sub(_originationFeeRepaid);

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

    }

    /**
    * @dev updates the state of the user as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is performing the rate swap
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the the principal amount borrowed by the user
    * @param _compoundedBorrowBalance the principal amount plus the accrued interest
    * @param _currentRateMode the rate mode at which the user borrowed
    **/
    function updateReserveStateOnSwapRateInternal(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _compoundedBorrowBalance,
        CoreLibrary.InterestRateMode _currentRateMode
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        //compounding reserve indexes
        reserve.updateCumulativeIndexes();

        if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {
            uint256 userCurrentStableRate = user.stableBorrowRate;

            //swap to variable
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _principalBorrowBalance,
                userCurrentStableRate
            ); //decreasing stable from old principal balance
            reserve.increaseTotalBorrowsVariable(_compoundedBorrowBalance); //increase variable borrows
        } else if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //swap to stable
            uint256 currentStableRate = reserve.currentStableBorrowRate;
            reserve.decreaseTotalBorrowsVariable(_principalBorrowBalance);
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _compoundedBorrowBalance,
                currentStableRate
            );

        } else {
            revert("Invalid rate mode received");
        }
    }

    /**
    * @dev updates the state of the user as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is performing the swap
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _currentRateMode the current rate mode of the user
    **/

    function updateUserStateOnSwapRateInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease,
        CoreLibrary.InterestRateMode _currentRateMode
    ) internal returns (CoreLibrary.InterestRateMode) {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        CoreLibrary.InterestRateMode newMode = CoreLibrary.InterestRateMode.NONE;

        if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //switch to stable
            newMode = CoreLibrary.InterestRateMode.STABLE;
            user.stableBorrowRate = reserve.currentStableBorrowRate;
            user.lastVariableBorrowCumulativeIndex = 0;
        } else if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {
            newMode = CoreLibrary.InterestRateMode.VARIABLE;
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        } else {
            revert("Invalid interest rate mode received");
        }
        //compounding cumulated interest
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);
        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

        return newMode;
    }

    /**
    * @dev updates the state of the principal reserve as a consequence of a liquidation action.
    * @param _principalReserve the address of the principal reserve that is being repaid
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updatePrincipalReserveStateOnLiquidationInternal(
        address _principalReserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_principalReserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_principalReserve];

        //update principal reserve data
        reserve.updateCumulativeIndexes();

        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(
            _principalReserve,
            _user
        );

        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            //increase the total borrows by the compounded interest
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _balanceIncrease,
                user.stableBorrowRate
            );

            //decrease by the actual amount to liquidate
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _amountToLiquidate,
                user.stableBorrowRate
            );

        } else {
            //increase the total borrows by the compounded interest
            reserve.increaseTotalBorrowsVariable(_balanceIncrease);

            //decrease by the actual amount to liquidate
            reserve.decreaseTotalBorrowsVariable(_amountToLiquidate);
        }

    }

    /**
    * @dev updates the state of the collateral reserve as a consequence of a liquidation action.
    * @param _collateralReserve the address of the collateral reserve that is being liquidated
    **/
    function updateCollateralReserveStateOnLiquidationInternal(
        address _collateralReserve
    ) internal {
        //update collateral reserve
        reserves[_collateralReserve].updateCumulativeIndexes();

    }

    /**
    * @dev updates the state of the user being liquidated as a consequence of a liquidation action.
    * @param _reserve the address of the principal reserve that is being repaid
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _feeLiquidated the amount of origination fee being liquidated
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/
    function updateUserStateOnLiquidationInternal(
        address _reserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _feeLiquidated,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        //first increase by the compounded interest, then decrease by the liquidated amount
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(
            _amountToLiquidate
        );

        if (
            getUserCurrentBorrowRateMode(_reserve, _user) == CoreLibrary.InterestRateMode.VARIABLE
        ) {
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        }

        if(_feeLiquidated > 0){
            user.originationFee = user.originationFee.sub(_feeLiquidated);
        }

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);
    }

    /**
    * @dev updates the state of the reserve as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateReserveStateOnRebalanceInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        reserve.updateCumulativeIndexes();

        reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
            _balanceIncrease,
            user.stableBorrowRate
        );

    }

    /**
    * @dev updates the state of the user as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateUserStateOnRebalanceInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);
        user.stableBorrowRate = reserve.currentStableBorrowRate;

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);
    }

    /**
    * @dev updates the state of the user as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _amountBorrowed the accrued interest on the borrowed amount
    **/
    function updateReserveTotalBorrowsByRateModeInternal(
        address _reserve,
        address _user,
        uint256 _principalBalance,
        uint256 _balanceIncrease,
        uint256 _amountBorrowed,
        CoreLibrary.InterestRateMode _newBorrowRateMode
    ) internal {
        CoreLibrary.InterestRateMode previousRateMode = getUserCurrentBorrowRateMode(
            _reserve,
            _user
        );
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        if (previousRateMode == CoreLibrary.InterestRateMode.STABLE) {
            CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _principalBalance,
                user.stableBorrowRate
            );
        } else if (previousRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            reserve.decreaseTotalBorrowsVariable(_principalBalance);
        }

        uint256 newPrincipalAmount = _principalBalance.add(_balanceIncrease).add(_amountBorrowed);
        if (_newBorrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                newPrincipalAmount,
                reserve.currentStableBorrowRate
            );
        } else if (_newBorrowRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            reserve.increaseTotalBorrowsVariable(newPrincipalAmount);
        } else {
            revert("Invalid new borrow rate mode");
        }
    }

    /**
    * @dev Updates the reserve current stable borrow rate Rf, the current variable borrow rate Rv and the current liquidity rate Rl.
    * Also updates the lastUpdateTimestamp value. Please refer to the whitepaper for further information.
    * @param _reserve the address of the reserve to be updated
    * @param _liquidityAdded the amount of liquidity added to the protocol (deposit or repay) in the previous action
    * @param _liquidityTaken the amount of liquidity taken from the protocol (redeem or borrow)
    **/

    function updateReserveInterestRatesAndTimestampInternal(
        address _reserve,
        uint256 _liquidityAdded,
        uint256 _liquidityTaken
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        (uint256 newLiquidityRate, uint256 newStableRate, uint256 newVariableRate) = IReserveInterestRateStrategy(
            reserve
            .interestRateStrategyAddress
        )
        .calculateInterestRates(
            _reserve,
            getReserveAvailableLiquidity(_reserve).add(_liquidityAdded).sub(_liquidityTaken),
            reserve.totalBorrowsStable,
            reserve.totalBorrowsVariable,
            reserve.currentAverageStableBorrowRate
        );

        reserve.currentLiquidityRate = newLiquidityRate;
        reserve.currentStableBorrowRate = newStableRate;
        reserve.currentVariableBorrowRate = newVariableRate;

        //solium-disable-next-line
        reserve.lastUpdateTimestamp = uint40(block.timestamp);

        emit ReserveUpdated(
            _reserve,
            newLiquidityRate,
            newStableRate,
            newVariableRate,
            reserve.lastLiquidityCumulativeIndex,
            reserve.lastVariableBorrowCumulativeIndex
        );
    }

    /**
    * @dev transfers to the protocol fees of a flashloan to the fees collection address
    * @param _token the address of the token being transferred
    * @param _amount the amount being transferred
    **/

    function transferFlashLoanProtocolFeeInternal(address _token, uint256 _amount) internal {
        address payable receiver = address(uint160(addressesProvider.getTokenDistributor()));

        if (_token != EthAddressLib.ethAddress()) {
            ERC20(_token).safeTransfer(receiver, _amount);
        } else {
            receiver.transfer(_amount);
        }
    }

    /**
    * @dev updates the internal configuration of the core
    **/
    function refreshConfigInternal() internal {
        lendingPoolAddress = addressesProvider.getLendingPool();
    }

    /**
    * @dev adds a reserve to the array of the reserves address
    **/
    function addReserveToListInternal(address _reserve) internal {
        bool reserveAlreadyAdded = false;
        for (uint256 i = 0; i < reservesList.length; i++)
            if (reservesList[i] == _reserve) {
                reserveAlreadyAdded = true;
            }
        if (!reserveAlreadyAdded) reservesList.push(_reserve);
    }

}


**project_name**: RealWorld_BA_124_LendingPoolCore

**Log File**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/WareHouse/RealWorld_BA_124_LendingPoolCore_RealWord_20240901043111.log

**ChatDevConfig**:
ChatEnvConfig.with_memory: False
ChatEnvConfig.clear_structure: True
ChatEnvConfig.git_management: False
ChatEnvConfig.gui_design: True
ChatEnvConfig.incremental_develop: False
ChatEnvConfig.background_prompt: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.


**ChatGPTConfig**:
ChatGPTConfig(temperature=0.2, top_p=1.0, n=1, stream=False, stop=None, max_tokens=None, presence_penalty=0.0, frequency_penalty=0.0, logit_bias={}, user='')



[2024-01-09 04:31:12 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | pragma solidity ^0.5.0; import "openzeppelin-solidity/contracts/math/SafeMath.sol"; import "openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol"; import "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol"; import "openzeppelin-solidity/contracts/utils/Address.sol"; import "../libraries/openzeppelin-upgradeability/VersionedInitializable.sol"; import "../libraries/CoreLibrary.sol"; import "../configuration/LendingPoolAddressesProvider.sol"; import "../interfaces/ILendingRateOracle.sol"; import "../interfaces/IReserveInterestRateStrategy.sol"; import "../libraries/WadRayMath.sol"; import "../tokenization/AToken.sol"; import "../libraries/EthAddressLib.sol"; / * @title LendingPoolCore contract * @author Aave * @notice Holds the state of the lending pool and all the funds deposited * @dev NOTE: The core does not enforce security checks on the update of the state * (eg, updateStateOnBorrow() does not enforce that borrowed is enabled on the reserve). * The check that an action can be performed is a duty of the overlying LendingPool contract. / contract LendingPoolCore is VersionedInitializable {     using SafeMath for uint256;     using WadRayMath for uint256;     using CoreLibrary for CoreLibrary.ReserveData;     using CoreLibrary for CoreLibrary.UserReserveData;     using SafeERC20 for ERC20;     using Address for address payable; /** * @dev Emitted when the state of a reserve is updated * @param reserve the address of the reserve * @param liquidityRate the new liquidity rate * @param stableBorrowRate the new stable borrow rate * @param variableBorrowRate the new variable borrow rate * @param liquidityIndex the new liquidity index * @param variableBorrowIndex the new variable borrow index **/ event ReserveUpdated(     address indexed reserve,     uint256 liquidityRate,     uint256 stableBorrowRate,     uint256 variableBorrowRate,     uint256 liquidityIndex,     uint256 variableBorrowIndex );  address public lendingPoolAddress;  LendingPoolAddressesProvider public addressesProvider;  /** * @dev only lending pools can use functions affected by this modifier **/ modifier onlyLendingPool {     require(lendingPoolAddress == msg.sender, "The caller must be a lending pool contract");     _; }  /** * @dev only lending pools configurator can use functions affected by this modifier **/ modifier onlyLendingPoolConfigurator {     require(         addressesProvider.getLendingPoolConfigurator() == msg.sender,         "The caller must be a lending pool configurator contract"     );     _; }  mapping(address =&gt; CoreLibrary.ReserveData) internal reserves; mapping(address =&gt; mapping(address =&gt; CoreLibrary.UserReserveData)) internal usersReserveData;  address[] public reservesList;  uint256 public constant CORE_REVISION = 0x4;  /** * @dev returns the revision number of the contract **/ function getRevision() internal pure returns (uint256) {     return CORE_REVISION; }  /** * @dev initializes the Core contract, invoked upon registration on the AddressesProvider * @param _addressesProvider the addressesProvider contract **/  function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {     addressesProvider = _addressesProvider;     refreshConfigInternal(); }  /** * @dev updates the state of the core as a result of a deposit action * @param _reserve the address of the reserve in which the deposit is happening * @param _user the address of the the user depositing * @param _amount the amount being deposited * @param _isFirstDeposit true if the user is depositing for the first time **/  function updateStateOnDeposit(     address _reserve,     address _user,     uint256 _amount,     bool _isFirstDeposit ) external onlyLendingPool {     reserves[_reserve].updateCumulativeIndexes();     updateReserveInterestRatesAndTimestampInternal(_reserve, _amount, 0);      if (_isFirstDeposit) {         //if this is the first deposit of the user, we configure the deposit as enabled to be used as collateral         setUserUseReserveAsCollateral(_reserve, _user, true);     } }  /** * @dev updates the state of the core as a result of a redeem action * @param _reserve the address of the reserve in which the redeem is happening * @param _user the address of the the user redeeming * @param _amountRedeemed the amount being redeemed * @param _userRedeemedEverything true if the user is redeeming everything **/ function updateStateOnRedeem(     address _reserve,     address _user,     uint256 _amountRedeemed,     bool _userRedeemedEverything ) external onlyLendingPool {     //compound liquidity and variable borrow interests     reserves[_reserve].updateCumulativeIndexes();     updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountRedeemed);      //if user redeemed everything the useReserveAsCollateral flag is reset     if (_userRedeemedEverything) {         setUserUseReserveAsCollateral(_reserve, _user, false);     } }  /** * @dev updates the state of the core as a result of a flashloan action * @param _reserve the address of the reserve in which the flashloan is happening * @param _income the income of the protocol as a result of the action **/ function updateStateOnFlashLoan(     address _reserve,     uint256 _availableLiquidityBefore,     uint256 _income,     uint256 _protocolFee ) external onlyLendingPool {     transferFlashLoanProtocolFeeInternal(_reserve, _protocolFee);      //compounding the cumulated interest     reserves[_reserve].updateCumulativeIndexes();      uint256 totalLiquidityBefore = _availableLiquidityBefore.add(         getReserveTotalBorrows(_reserve)     );      //compounding the received fee into the reserve     reserves[_reserve].cumulateToLiquidityIndex(totalLiquidityBefore, _income);      //refresh interest rates     updateReserveInterestRatesAndTimestampInternal(_reserve, _income, 0); }  /** * @dev updates the state of the core as a consequence of a borrow action. * @param _reserve the address of the reserve on which the user is borrowing * @param _user the address of the borrower * @param _amountBorrowed the new amount borrowed * @param _borrowFee the fee on the amount borrowed * @param _rateMode the borrow rate mode (stable, variable) * @return the new borrow rate for the user **/ function updateStateOnBorrow(     address _reserve,     address _user,     uint256 _amountBorrowed,     uint256 _borrowFee,     CoreLibrary.InterestRateMode _rateMode ) external onlyLendingPool returns (uint256, uint256) {     // getting the previous borrow data of the user     (uint256 principalBorrowBalance, , uint256 balanceIncrease) = getUserBorrowBalances(         _reserve,         _user     );      updateReserveStateOnBorrowInternal(         _reserve,         _user,         principalBorrowBalance,         balanceIncrease,         _amountBorrowed,         _rateMode     );      updateUserStateOnBorrowInternal(         _reserve,         _user,         _amountBorrowed,         balanceIncrease,         _borrowFee,         _rateMode     );      updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountBorrowed);      return (getUserCurrentBorrowRate(_reserve, _user), balanceIncrease); }  /** * @dev updates the state of the core as a consequence of a repay action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _paybackAmountMinusFees the amount being paid back minus fees * @param _originationFeeRepaid the fee on the amount that is being repaid * @param _balanceIncrease the accrued interest on the borrowed amount * @param _repaidWholeLoan true if the user is repaying the whole loan **/  function updateStateOnRepay(     address _reserve,     address _user,     uint256 _paybackAmountMinusFees,     uint256 _originationFeeRepaid,     uint256 _balanceIncrease,     bool _repaidWholeLoan ) external onlyLendingPool {     updateReserveStateOnRepayInternal(         _reserve,         _user,         _paybackAmountMinusFees,         _balanceIncrease     );     updateUserStateOnRepayInternal(         _reserve,         _user,         _paybackAmountMinusFees,         _originationFeeRepaid,         _balanceIncrease,         _repaidWholeLoan     );      updateReserveInterestRatesAndTimestampInternal(_reserve, _paybackAmountMinusFees, 0); }  /** * @dev updates the state of the core as a consequence of a swap rate action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _principalBorrowBalance the amount borrowed by the user * @param _compoundedBorrowBalance the amount borrowed plus accrued interest * @param _balanceIncrease the accrued interest on the borrowed amount * @param _currentRateMode the current interest rate mode for the user **/ function updateStateOnSwapRate(     address _reserve,     address _user,     uint256 _principalBorrowBalance,     uint256 _compoundedBorrowBalance,     uint256 _balanceIncrease,     CoreLibrary.InterestRateMode _currentRateMode ) external onlyLendingPool returns (CoreLibrary.InterestRateMode, uint256) {     updateReserveStateOnSwapRateInternal(         _reserve,         _user,         _principalBorrowBalance,         _compoundedBorrowBalance,         _currentRateMode     );      CoreLibrary.InterestRateMode newRateMode = updateUserStateOnSwapRateInternal(         _reserve,         _user,         _balanceIncrease,         _currentRateMode     );      updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);      return (newRateMode, getUserCurrentBorrowRate(_reserve, _user)); }  /** * @dev updates the state of the core as a consequence of a liquidation action. * @param _principalReserve the address of the principal reserve that is being repaid * @param _collateralReserve the address of the collateral reserve that is being liquidated * @param _user the address of the borrower * @param _amountToLiquidate the amount being repaid by the liquidator * @param _collateralToLiquidate the amount of collateral being liquidated * @param _feeLiquidated the amount of origination fee being liquidated * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus * @param _balanceIncrease the accrued interest on the borrowed amount * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise **/ function updateStateOnLiquidation(     address _principalReserve,     address _collateralReserve,     address _user,     uint256 _amountToLiquidate,     uint256 _collateralToLiquidate,     uint256 _feeLiquidated,     uint256 _liquidatedCollateralForFee,     uint256 _balanceIncrease,     bool _liquidatorReceivesAToken ) external onlyLendingPool {     updatePrincipalReserveStateOnLiquidationInternal(         _principalReserve,         _user,         _amountToLiquidate,         _balanceIncrease     );      updateCollateralReserveStateOnLiquidationInternal(         _collateralReserve     );      updateUserStateOnLiquidationInternal(         _principalReserve,         _user,         _amountToLiquidate,         _feeLiquidated,         _balanceIncrease     );      updateReserveInterestRatesAndTimestampInternal(_principalReserve, _amountToLiquidate, 0);      if (!_liquidatorReceivesAToken) {         updateReserveInterestRatesAndTimestampInternal(             _collateralReserve,             0,             _collateralToLiquidate.add(_liquidatedCollateralForFee)         );     }  }  /** * @dev updates the state of the core as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount * @return the new stable rate for the user **/ function updateStateOnRebalance(address _reserve, address _user, uint256 _balanceIncrease) external onlyLendingPool returns (uint256) {     updateReserveStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);      //update user data and rebalance the rate     updateUserStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);     updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);     return usersReserveData[_user][_reserve].stableBorrowRate; }  /** * @dev enables or disables a reserve as collateral * @param _reserve the address of the principal reserve where the user deposited * @param _user the address of the depositor * @param _useAsCollateral true if the depositor wants to use the reserve as collateral **/ function setUserUseReserveAsCollateral(address _reserve, address _user, bool _useAsCollateral) public onlyLendingPool {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     user.useAsCollateral = _useAsCollateral; }  /** * @notice ETH/token transfer functions **/  /** * @dev fallback function enforces that the caller is a contract, to support flashloan transfers **/ function() external payable {     //only contracts can send ETH to the core     require(msg.sender.isContract(), "Only contracts can send ether to the Lending pool core");  }  /** * @dev transfers to the user a specific amount from the reserve. * @param _reserve the address of the reserve where the transfer is happening * @param _user the address of the user receiving the transfer * @param _amount the amount being transferred **/ function transferToUser(address _reserve, address payable _user, uint256 _amount) external onlyLendingPool {     if (_reserve != EthAddressLib.ethAddress()) {         ERC20(_reserve).safeTransfer(_user, _amount);     } else {         //solium-disable-next-line         (bool result, ) = _user.call.value(_amount).gas(50000)("");         require(result, "Transfer of ETH failed");     } }  /** * @dev transfers the protocol fees to the fees collection address * @param _token the address of the token being transferred * @param _user the address of the user from where the transfer is happening * @param _amount the amount being transferred * @param _destination the fee receiver address **/  function transferToFeeCollectionAddress(     address _token,     address _user,     uint256 _amount,     address _destination ) external payable onlyLendingPool {     address payable feeAddress = address(uint160(_destination)); //cast the address to payable      if (_token != EthAddressLib.ethAddress()) {         require(             msg.value == 0,             "User is sending ETH along with the ERC20 transfer. Check the value attribute of the transaction"         );         ERC20(_token).safeTransferFrom(_user, feeAddress, _amount);     } else {         require(msg.value &gt;= _amount, "The amount and the value sent to deposit do not match");         //solium-disable-next-line         (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");         require(result, "Transfer of ETH failed");     } }  /** * @dev transfers the fees to the fees collection address in the case of liquidation * @param _token the address of the token being transferred * @param _amount the amount being transferred * @param _destination the fee receiver address **/ function liquidateFee(     address _token,     uint256 _amount,     address _destination ) external payable onlyLendingPool {     address payable feeAddress = address(uint160(_destination)); //cast the address to payable     require(         msg.value == 0,         "Fee liquidation does not require any transfer of value"     );      if (_token != EthAddressLib.ethAddress()) {         ERC20(_token).safeTransfer(feeAddress, _amount);     } else {         //solium-disable-next-line         (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");         require(result, "Transfer of ETH failed");     } }  /** * @dev transfers an amount from a user to the destination reserve * @param _reserve the address of the reserve where the amount is being transferred * @param _user the address of the user from where the transfer is happening * @param _amount the amount being transferred **/ function transferToReserve(address _reserve, address payable _user, uint256 _amount) external payable onlyLendingPool {     if (_reserve != EthAddressLib.ethAddress()) {         require(msg.value == 0, "User is sending ETH along with the ERC20 transfer.");         ERC20(_reserve).safeTransferFrom(_user, address(this), _amount);      } else {         require(msg.value &gt;= _amount, "The amount and the value sent to deposit do not match");          if (msg.value &gt; _amount) {             //send back excess ETH             uint256 excessAmount = msg.value.sub(_amount);             //solium-disable-next-line             (bool result, ) = _user.call.value(excessAmount).gas(50000)("");             require(result, "Transfer of ETH failed");         }     } }  /** * @notice data access functions **/  /** * @dev returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral) * needed to calculate the global account data in the LendingPoolDataProvider * @param _reserve the address of the reserve * @param _user the address of the user * @return the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not **/ function getUserBasicReserveData(address _reserve, address _user) external view returns (uint256, uint256, uint256, bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      uint256 underlyingBalance = getUserUnderlyingAssetBalance(_reserve, _user);      if (user.principalBorrowBalance == 0) {         return (underlyingBalance, 0, 0, user.useAsCollateral);     }      return (     underlyingBalance,     user.getCompoundedBorrowBalance(reserve),     user.originationFee,     user.useAsCollateral     ); }  /** * @dev checks if a user is allowed to borrow at a stable rate * @param _reserve the reserve address * @param _user the user * @param _amount the amount the the user wants to borrow * @return true if the user is allowed to borrow at a stable rate, false otherwise **/  function isUserAllowedToBorrowAtStable(address _reserve, address _user, uint256 _amount) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      if (!reserve.isStableBorrowRateEnabled) return false;      return     !user.useAsCollateral ||     !reserve.usageAsCollateralEnabled ||     _amount &gt; getUserUnderlyingAssetBalance(_reserve, _user); }  /** * @dev gets the underlying asset balance of a user based on the corresponding aToken balance. * @param _reserve the reserve address * @param _user the user address * @return the underlying deposit balance of the user **/  function getUserUnderlyingAssetBalance(address _reserve, address _user) public view returns (uint256) {     AToken aToken = AToken(reserves[_reserve].aTokenAddress);     return aToken.balanceOf(_user);  }  /** * @dev gets the interest rate strategy contract address for the reserve * @param _reserve the reserve address * @return the address of the interest rate strategy contract **/ function getReserveInterestRateStrategyAddress(address _reserve) public view returns (address) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.interestRateStrategyAddress; }  /** * @dev gets the aToken contract address for the reserve * @param _reserve the reserve address * @return the address of the aToken contract **/  function getReserveATokenAddress(address _reserve) public view returns (address) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.aTokenAddress; }  /** * @dev gets the available liquidity in the reserve. The available liquidity is the balance of the core contract * @param _reserve the reserve address * @return the available liquidity **/ function getReserveAvailableLiquidity(address _reserve) public view returns (uint256) {     uint256 balance = 0;      if (_reserve == EthAddressLib.ethAddress()) {         balance = address(this).balance;     } else {         balance = IERC20(_reserve).balanceOf(address(this));     }     return balance; }  /** * @dev gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows * @param _reserve the reserve address * @return the total liquidity **/ function getReserveTotalLiquidity(address _reserve) public view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return getReserveAvailableLiquidity(_reserve).add(reserve.getTotalBorrows()); }  /** * @dev gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there * there has been 100% income. * @param _reserve the reserve address * @return the reserve normalized income **/ function getReserveNormalizedIncome(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.getNormalizedIncome(); }  /** * @dev gets the reserve total borrows * @param _reserve the reserve address * @return the total borrows (stable + variable) **/ function getReserveTotalBorrows(address _reserve) public view returns (uint256) {     return reserves[_reserve].getTotalBorrows(); }  /** * @dev gets the reserve total borrows stable * @param _reserve the reserve address * @return the total borrows stable **/ function getReserveTotalBorrowsStable(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.totalBorrowsStable; }  /** * @dev gets the reserve total borrows variable * @param _reserve the reserve address * @return the total borrows variable **/  function getReserveTotalBorrowsVariable(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.totalBorrowsVariable; }  /** * @dev gets the reserve liquidation threshold * @param _reserve the reserve address * @return the reserve liquidation threshold **/  function getReserveLiquidationThreshold(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.liquidationThreshold; }  /** * @dev gets the reserve liquidation bonus * @param _reserve the reserve address * @return the reserve liquidation bonus **/  function getReserveLiquidationBonus(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.liquidationBonus; }  /** * @dev gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty * @param _reserve the reserve address * @return the reserve current variable borrow rate **/  function getReserveCurrentVariableBorrowRate(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      if (reserve.currentVariableBorrowRate == 0) {         return         IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)         .getBaseVariableBorrowRate();     }     return reserve.currentVariableBorrowRate; }  /** * @dev gets the reserve current stable borrow rate. Is the market rate if the reserve is empty * @param _reserve the reserve address * @return the reserve current stable borrow rate **/  function getReserveCurrentStableBorrowRate(address _reserve) public view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     ILendingRateOracle oracle = ILendingRateOracle(addressesProvider.getLendingRateOracle());      if (reserve.currentStableBorrowRate == 0) {         //no stable rate borrows yet         return oracle.getMarketBorrowRate(_reserve);     }      return reserve.currentStableBorrowRate; }  /** * @dev gets the reserve average stable borrow rate. The average stable rate is the weighted average * of all the loans taken at stable rate. * @param _reserve the reserve address * @return the reserve current average borrow rate **/ function getReserveCurrentAverageStableBorrowRate(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.currentAverageStableBorrowRate; }  /** * @dev gets the reserve liquidity rate * @param _reserve the reserve address * @return the reserve liquidity rate **/ function getReserveCurrentLiquidityRate(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.currentLiquidityRate; }  /** * @dev gets the reserve liquidity cumulative index * @param _reserve the reserve address * @return the reserve liquidity cumulative index **/ function getReserveLiquidityCumulativeIndex(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.lastLiquidityCumulativeIndex; }  /** * @dev gets the reserve variable borrow index * @param _reserve the reserve address * @return the reserve variable borrow index **/ function getReserveVariableBorrowsCumulativeIndex(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.lastVariableBorrowCumulativeIndex; }  /** * @dev this function aggregates the configuration parameters of the reserve. * It's used in the LendingPoolDataProvider specifically to save gas, and avoid * multiple external contract calls to fetch the same data. * @param _reserve the reserve address * @return the reserve decimals * @return the base ltv as collateral * @return the liquidation threshold * @return if the reserve is used as collateral or not **/ function getReserveConfiguration(address _reserve) external view returns (uint256, uint256, uint256, bool) {     uint256 decimals;     uint256 baseLTVasCollateral;     uint256 liquidationThreshold;     bool usageAsCollateralEnabled;      CoreLibrary.ReserveData storage reserve = reserves[_reserve];     decimals = reserve.decimals;     baseLTVasCollateral = reserve.baseLTVasCollateral;     liquidationThreshold = reserve.liquidationThreshold;     usageAsCollateralEnabled = reserve.usageAsCollateralEnabled;      return (decimals, baseLTVasCollateral, liquidationThreshold, usageAsCollateralEnabled); }  /** * @dev returns the decimals of the reserve * @param _reserve the reserve address * @return the reserve decimals **/ function getReserveDecimals(address _reserve) external view returns (uint256) {     return reserves[_reserve].decimals; }  /** * @dev returns true if the reserve is enabled for borrowing * @param _reserve the reserve address * @return true if the reserve is enabled for borrowing, false otherwise **/  function isReserveBorrowingEnabled(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.borrowingEnabled; }  /** * @dev returns true if the reserve is enabled as collateral * @param _reserve the reserve address * @return true if the reserve is enabled as collateral, false otherwise **/  function isReserveUsageAsCollateralEnabled(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.usageAsCollateralEnabled; }  /** * @dev returns true if the stable rate is enabled on reserve * @param _reserve the reserve address * @return true if the stable rate is enabled on reserve, false otherwise **/ function getReserveIsStableBorrowRateEnabled(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.isStableBorrowRateEnabled; }  /** * @dev returns true if the reserve is active * @param _reserve the reserve address * @return true if the reserve is active, false otherwise **/ function getReserveIsActive(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.isActive; }  /** * @notice returns if a reserve is freezed * @param _reserve the reserve for which the information is needed * @return true if the reserve is freezed, false otherwise **/  function getReserveIsFreezed(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.isFreezed; }  /** * @notice returns the timestamp of the last action on the reserve * @param _reserve the reserve for which the information is needed * @return the last updated timestamp of the reserve **/  function getReserveLastUpdate(address _reserve) external view returns (uint40 timestamp) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     timestamp = reserve.lastUpdateTimestamp; }  /** * @dev returns the utilization rate U of a specific reserve * @param _reserve the reserve for which the information is needed * @return the utilization rate in ray **/  function getReserveUtilizationRate(address _reserve) public view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      uint256 totalBorrows = reserve.getTotalBorrows();      if (totalBorrows == 0) {         return 0;     }      uint256 availableLiquidity = getReserveAvailableLiquidity(_reserve);      return totalBorrows.rayDiv(availableLiquidity.add(totalBorrows)); }  /** * @return the array of reserves configured on the core **/ function getReserves() external view returns (address[] memory) {     return reservesList; }  /** * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return true if the user has chosen to use the reserve as collateral, false otherwise **/ function isUserUseReserveAsCollateralEnabled(address _reserve, address _user) external view returns (bool) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.useAsCollateral; }  /** * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the origination fee for the user **/ function getUserOriginationFee(address _reserve, address _user) external view returns (uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.originationFee; }  /** * @dev users with no loans in progress have NONE as borrow rate mode * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the borrow rate mode for the user, **/  function getUserCurrentBorrowRateMode(address _reserve, address _user) public view returns (CoreLibrary.InterestRateMode) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      if (user.principalBorrowBalance == 0) {         return CoreLibrary.InterestRateMode.NONE;     }      return     user.stableBorrowRate &gt; 0     ? CoreLibrary.InterestRateMode.STABLE     : CoreLibrary.InterestRateMode.VARIABLE; }  /** * @dev gets the current borrow rate of the user * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the borrow rate for the user, **/ function getUserCurrentBorrowRate(address _reserve, address _user) internal view returns (uint256) {     CoreLibrary.InterestRateMode rateMode = getUserCurrentBorrowRateMode(_reserve, _user);      if (rateMode == CoreLibrary.InterestRateMode.NONE) {         return 0;     }      return     rateMode == CoreLibrary.InterestRateMode.STABLE     ? usersReserveData[_user][_reserve].stableBorrowRate     : reserves[_reserve].currentVariableBorrowRate; }  /** * @dev the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the user stable rate **/ function getUserCurrentStableBorrowRate(address _reserve, address _user) external view returns (uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.stableBorrowRate; }  /** * @dev calculates and returns the borrow balances of the user * @param _reserve the address of the reserve * @param _user the address of the user * @return the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance **/  function getUserBorrowBalances(address _reserve, address _user) public view returns (uint256, uint256, uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     if (user.principalBorrowBalance == 0) {         return (0, 0, 0);     }      uint256 principal = user.principalBorrowBalance;     uint256 compoundedBalance = CoreLibrary.getCompoundedBorrowBalance(         user,         reserves[_reserve]     );     return (principal, compoundedBalance, compoundedBalance.sub(principal)); }  /** * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the variable borrow index for the user **/  function getUserVariableBorrowCumulativeIndex(address _reserve, address _user) external view returns (uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.lastVariableBorrowCumulativeIndex; }  /** * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the variable borrow index for the user **/  function getUserLastUpdate(address _reserve, address _user) external view returns (uint256 timestamp) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     timestamp = user.lastUpdateTimestamp; }  /** * @dev updates the lending pool core configuration **/ function refreshConfiguration() external onlyLendingPoolConfigurator {     refreshConfigInternal(); }  /** * @dev initializes a reserve * @param _reserve the address of the reserve * @param _aTokenAddress the address of the overlying aToken contract * @param _decimals the decimals of the reserve currency * @param _interestRateStrategyAddress the address of the interest rate strategy contract **/ function initReserve(     address _reserve,     address _aTokenAddress,     uint256 _decimals,     address _interestRateStrategyAddress ) external onlyLendingPoolConfigurator {     reserves[_reserve].init(_aTokenAddress, _decimals, _interestRateStrategyAddress);     addReserveToListInternal(_reserve);  }    /** * @dev removes the last added reserve in the reservesList array * @param _reserveToRemove the address of the reserve **/ function removeLastAddedReserve(address _reserveToRemove) external onlyLendingPoolConfigurator {      address lastReserve = reservesList[reservesList.length-1];      require(lastReserve == _reserveToRemove, "Reserve being removed is different than the reserve requested");      //as we can't check if totalLiquidity is 0 (since the reserve added might not be an ERC20) we at least check that there is nothing borrowed     require(getReserveTotalBorrows(lastReserve) == 0, "Cannot remove a reserve with liquidity deposited");      reserves[lastReserve].isActive = false;     reserves[lastReserve].aTokenAddress = address(0);     reserves[lastReserve].decimals = 0;     reserves[lastReserve].lastLiquidityCumulativeIndex = 0;     reserves[lastReserve].lastVariableBorrowCumulativeIndex = 0;     reserves[lastReserve].borrowingEnabled = false;     reserves[lastReserve].usageAsCollateralEnabled = false;     reserves[lastReserve].baseLTVasCollateral = 0;     reserves[lastReserve].liquidationThreshold = 0;     reserves[lastReserve].liquidationBonus = 0;     reserves[lastReserve].interestRateStrategyAddress = address(0);      reservesList.pop(); }  /** * @dev updates the address of the interest rate strategy contract * @param _reserve the address of the reserve * @param _rateStrategyAddress the address of the interest rate strategy contract **/  function setReserveInterestRateStrategyAddress(address _reserve, address _rateStrategyAddress) external onlyLendingPoolConfigurator {     reserves[_reserve].interestRateStrategyAddress = _rateStrategyAddress; }  /** * @dev enables borrowing on a reserve. Also sets the stable rate borrowing * @param _reserve the address of the reserve * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise **/  function enableBorrowingOnReserve(address _reserve, bool _stableBorrowRateEnabled) external onlyLendingPoolConfigurator {     reserves[_reserve].enableBorrowing(_stableBorrowRateEnabled); }  /** * @dev disables borrowing on a reserve * @param _reserve the address of the reserve **/  function disableBorrowingOnReserve(address _reserve) external onlyLendingPoolConfigurator {     reserves[_reserve].disableBorrowing(); }  /** * @dev enables a reserve to be used as collateral * @param _reserve the address of the reserve **/ function enableReserveAsCollateral(     address _reserve,     uint256 _baseLTVasCollateral,     uint256 _liquidationThreshold,     uint256 _liquidationBonus ) external onlyLendingPoolConfigurator {     reserves[_reserve].enableAsCollateral(         _baseLTVasCollateral,         _liquidationThreshold,         _liquidationBonus     ); }  /** * @dev disables a reserve to be used as collateral * @param _reserve the address of the reserve **/ function disableReserveAsCollateral(address _reserve) external onlyLendingPoolConfigurator {     reserves[_reserve].disableAsCollateral(); }  /** * @dev enable the stable borrow rate mode on a reserve * @param _reserve the address of the reserve **/ function enableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isStableBorrowRateEnabled = true; }  /** * @dev disable the stable borrow rate mode on a reserve * @param _reserve the address of the reserve **/ function disableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isStableBorrowRateEnabled = false; }  /** * @dev activates a reserve * @param _reserve the address of the reserve **/ function activateReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      require(         reserve.lastLiquidityCumulativeIndex &gt; 0 &amp;&amp;         reserve.lastVariableBorrowCumulativeIndex &gt; 0,         "Reserve has not been initialized yet"     );     reserve.isActive = true; }  /** * @dev deactivates a reserve * @param _reserve the address of the reserve **/ function deactivateReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isActive = false; }  /** * @notice allows the configurator to freeze the reserve. * A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance. * @param _reserve the address of the reserve **/ function freezeReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isFreezed = true; }  /** * @notice allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed. * @param _reserve the address of the reserve **/ function unfreezeReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isFreezed = false; }  /** * @notice allows the configurator to update the loan to value of a reserve * @param _reserve the address of the reserve * @param _ltv the new loan to value **/ function setReserveBaseLTVasCollateral(address _reserve, uint256 _ltv) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.baseLTVasCollateral = _ltv; }  /** * @notice allows the configurator to update the liquidation threshold of a reserve * @param _reserve the address of the reserve * @param _threshold the new liquidation threshold **/ function setReserveLiquidationThreshold(address _reserve, uint256 _threshold) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.liquidationThreshold = _threshold; }  /** * @notice allows the configurator to update the liquidation bonus of a reserve * @param _reserve the address of the reserve * @param _bonus the new liquidation bonus **/ function setReserveLiquidationBonus(address _reserve, uint256 _bonus) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.liquidationBonus = _bonus; }  /** * @notice allows the configurator to update the reserve decimals * @param _reserve the address of the reserve * @param _decimals the decimals of the reserve **/ function setReserveDecimals(address _reserve, uint256 _decimals) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.decimals = _decimals; }  /** * @notice internal functions **/  /** * @dev updates the state of a reserve as a consequence of a borrow action. * @param _reserve the address of the reserve on which the user is borrowing * @param _user the address of the borrower * @param _principalBorrowBalance the previous borrow balance of the borrower before the action * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount * @param _amountBorrowed the new amount borrowed * @param _rateMode the borrow rate mode (stable, variable) **/  function updateReserveStateOnBorrowInternal(     address _reserve,     address _user,     uint256 _principalBorrowBalance,     uint256 _balanceIncrease,     uint256 _amountBorrowed,     CoreLibrary.InterestRateMode _rateMode ) internal {     reserves[_reserve].updateCumulativeIndexes();      //increasing reserve total borrows to account for the new borrow balance of the user     //NOTE: Depending on the previous borrow mode, the borrows might need to be switched from variable to stable or vice versa      updateReserveTotalBorrowsByRateModeInternal(         _reserve,         _user,         _principalBorrowBalance,         _balanceIncrease,         _amountBorrowed,         _rateMode     ); }  /** * @dev updates the state of a user as a consequence of a borrow action. * @param _reserve the address of the reserve on which the user is borrowing * @param _user the address of the borrower * @param _amountBorrowed the amount borrowed * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount * @param _rateMode the borrow rate mode (stable, variable) * @return the final borrow rate for the user. Emitted by the borrow() event **/  function updateUserStateOnBorrowInternal(     address _reserve,     address _user,     uint256 _amountBorrowed,     uint256 _balanceIncrease,     uint256 _fee,     CoreLibrary.InterestRateMode _rateMode ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      if (_rateMode == CoreLibrary.InterestRateMode.STABLE) {         //stable         //reset the user variable index, and update the stable rate         user.stableBorrowRate = reserve.currentStableBorrowRate;         user.lastVariableBorrowCumulativeIndex = 0;     } else if (_rateMode == CoreLibrary.InterestRateMode.VARIABLE) {         //variable         //reset the user stable rate, and store the new borrow index         user.stableBorrowRate = 0;         user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;     } else {         revert("Invalid borrow rate mode");     }     //increase the principal borrows and the origination fee     user.principalBorrowBalance = user.principalBorrowBalance.add(_amountBorrowed).add(         _balanceIncrease     );     user.originationFee = user.originationFee.add(_fee);      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp);  }  /** * @dev updates the state of the reserve as a consequence of a repay action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _paybackAmountMinusFees the amount being paid back minus fees * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updateReserveStateOnRepayInternal(     address _reserve,     address _user,     uint256 _paybackAmountMinusFees,     uint256 _balanceIncrease ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_reserve][_user];      CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(_reserve, _user);      //update the indexes     reserves[_reserve].updateCumulativeIndexes();      //compound the cumulated interest to the borrow balance and then subtracting the payback amount     if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             _balanceIncrease,             user.stableBorrowRate         );         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _paybackAmountMinusFees,             user.stableBorrowRate         );     } else {         reserve.increaseTotalBorrowsVariable(_balanceIncrease);         reserve.decreaseTotalBorrowsVariable(_paybackAmountMinusFees);     } }  /** * @dev updates the state of the user as a consequence of a repay action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _paybackAmountMinusFees the amount being paid back minus fees * @param _originationFeeRepaid the fee on the amount that is being repaid * @param _balanceIncrease the accrued interest on the borrowed amount * @param _repaidWholeLoan true if the user is repaying the whole loan **/ function updateUserStateOnRepayInternal(     address _reserve,     address _user,     uint256 _paybackAmountMinusFees,     uint256 _originationFeeRepaid,     uint256 _balanceIncrease,     bool _repaidWholeLoan ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      //update the user principal borrow balance, adding the cumulated interest and then subtracting the payback amount     user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(         _paybackAmountMinusFees     );     user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;      //if the balance decrease is equal to the previous principal (user is repaying the whole loan)     //and the rate mode is stable, we reset the interest rate mode of the user     if (_repaidWholeLoan) {         user.stableBorrowRate = 0;         user.lastVariableBorrowCumulativeIndex = 0;     }     user.originationFee = user.originationFee.sub(_originationFeeRepaid);      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp);  }  /** * @dev updates the state of the user as a consequence of a swap rate action. * @param _reserve the address of the reserve on which the user is performing the rate swap * @param _user the address of the borrower * @param _principalBorrowBalance the the principal amount borrowed by the user * @param _compoundedBorrowBalance the principal amount plus the accrued interest * @param _currentRateMode the rate mode at which the user borrowed **/ function updateReserveStateOnSwapRateInternal(     address _reserve,     address _user,     uint256 _principalBorrowBalance,     uint256 _compoundedBorrowBalance,     CoreLibrary.InterestRateMode _currentRateMode ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      //compounding reserve indexes     reserve.updateCumulativeIndexes();      if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {         uint256 userCurrentStableRate = user.stableBorrowRate;          //swap to variable         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _principalBorrowBalance,             userCurrentStableRate         ); //decreasing stable from old principal balance         reserve.increaseTotalBorrowsVariable(_compoundedBorrowBalance); //increase variable borrows     } else if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         //swap to stable         uint256 currentStableRate = reserve.currentStableBorrowRate;         reserve.decreaseTotalBorrowsVariable(_principalBorrowBalance);         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             _compoundedBorrowBalance,             currentStableRate         );      } else {         revert("Invalid rate mode received");     } }  /** * @dev updates the state of the user as a consequence of a swap rate action. * @param _reserve the address of the reserve on which the user is performing the swap * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount * @param _currentRateMode the current rate mode of the user **/  function updateUserStateOnSwapRateInternal(     address _reserve,     address _user,     uint256 _balanceIncrease,     CoreLibrary.InterestRateMode _currentRateMode ) internal returns (CoreLibrary.InterestRateMode) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      CoreLibrary.InterestRateMode newMode = CoreLibrary.InterestRateMode.NONE;      if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         //switch to stable         newMode = CoreLibrary.InterestRateMode.STABLE;         user.stableBorrowRate = reserve.currentStableBorrowRate;         user.lastVariableBorrowCumulativeIndex = 0;     } else if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {         newMode = CoreLibrary.InterestRateMode.VARIABLE;         user.stableBorrowRate = 0;         user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;     } else {         revert("Invalid interest rate mode received");     }     //compounding cumulated interest     user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);     //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp);      return newMode; }  /** * @dev updates the state of the principal reserve as a consequence of a liquidation action. * @param _principalReserve the address of the principal reserve that is being repaid * @param _user the address of the borrower * @param _amountToLiquidate the amount being repaid by the liquidator * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updatePrincipalReserveStateOnLiquidationInternal(     address _principalReserve,     address _user,     uint256 _amountToLiquidate,     uint256 _balanceIncrease ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_principalReserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_principalReserve];      //update principal reserve data     reserve.updateCumulativeIndexes();      CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(         _principalReserve,         _user     );      if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {         //increase the total borrows by the compounded interest         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             _balanceIncrease,             user.stableBorrowRate         );          //decrease by the actual amount to liquidate         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _amountToLiquidate,             user.stableBorrowRate         );      } else {         //increase the total borrows by the compounded interest         reserve.increaseTotalBorrowsVariable(_balanceIncrease);          //decrease by the actual amount to liquidate         reserve.decreaseTotalBorrowsVariable(_amountToLiquidate);     }  }  /** * @dev updates the state of the collateral reserve as a consequence of a liquidation action. * @param _collateralReserve the address of the collateral reserve that is being liquidated **/ function updateCollateralReserveStateOnLiquidationInternal(     address _collateralReserve ) internal {     //update collateral reserve     reserves[_collateralReserve].updateCumulativeIndexes();  }  /** * @dev updates the state of the user being liquidated as a consequence of a liquidation action. * @param _reserve the address of the principal reserve that is being repaid * @param _user the address of the borrower * @param _amountToLiquidate the amount being repaid by the liquidator * @param _feeLiquidated the amount of origination fee being liquidated * @param _balanceIncrease the accrued interest on the borrowed amount **/ function updateUserStateOnLiquidationInternal(     address _reserve,     address _user,     uint256 _amountToLiquidate,     uint256 _feeLiquidated,     uint256 _balanceIncrease ) internal {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     //first increase by the compounded interest, then decrease by the liquidated amount     user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(         _amountToLiquidate     );      if (         getUserCurrentBorrowRateMode(_reserve, _user) == CoreLibrary.InterestRateMode.VARIABLE     ) {         user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;     }      if(_feeLiquidated &gt; 0){         user.originationFee = user.originationFee.sub(_feeLiquidated);     }      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp); }  /** * @dev updates the state of the reserve as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updateReserveStateOnRebalanceInternal(     address _reserve,     address _user,     uint256 _balanceIncrease ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      reserve.updateCumulativeIndexes();      reserve.increaseTotalBorrowsStableAndUpdateAverageRate(         _balanceIncrease,         user.stableBorrowRate     );  }  /** * @dev updates the state of the user as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updateUserStateOnRebalanceInternal(     address _reserve,     address _user,     uint256 _balanceIncrease ) internal {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);     user.stableBorrowRate = reserve.currentStableBorrowRate;      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp); }  /** * @dev updates the state of the user as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount * @param _amountBorrowed the accrued interest on the borrowed amount **/ function updateReserveTotalBorrowsByRateModeInternal(     address _reserve,     address _user,     uint256 _principalBalance,     uint256 _balanceIncrease,     uint256 _amountBorrowed,     CoreLibrary.InterestRateMode _newBorrowRateMode ) internal {     CoreLibrary.InterestRateMode previousRateMode = getUserCurrentBorrowRateMode(         _reserve,         _user     );     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      if (previousRateMode == CoreLibrary.InterestRateMode.STABLE) {         CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _principalBalance,             user.stableBorrowRate         );     } else if (previousRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         reserve.decreaseTotalBorrowsVariable(_principalBalance);     }      uint256 newPrincipalAmount = _principalBalance.add(_balanceIncrease).add(_amountBorrowed);     if (_newBorrowRateMode == CoreLibrary.InterestRateMode.STABLE) {         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             newPrincipalAmount,             reserve.currentStableBorrowRate         );     } else if (_newBorrowRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         reserve.increaseTotalBorrowsVariable(newPrincipalAmount);     } else {         revert("Invalid new borrow rate mode");     } }  /** * @dev Updates the reserve current stable borrow rate Rf, the current variable borrow rate Rv and the current liquidity rate Rl. * Also updates the lastUpdateTimestamp value. Please refer to the whitepaper for further information. * @param _reserve the address of the reserve to be updated * @param _liquidityAdded the amount of liquidity added to the protocol (deposit or repay) in the previous action * @param _liquidityTaken the amount of liquidity taken from the protocol (redeem or borrow) **/  function updateReserveInterestRatesAndTimestampInternal(     address _reserve,     uint256 _liquidityAdded,     uint256 _liquidityTaken ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     (uint256 newLiquidityRate, uint256 newStableRate, uint256 newVariableRate) = IReserveInterestRateStrategy(         reserve         .interestRateStrategyAddress     )     .calculateInterestRates(         _reserve,         getReserveAvailableLiquidity(_reserve).add(_liquidityAdded).sub(_liquidityTaken),         reserve.totalBorrowsStable,         reserve.totalBorrowsVariable,         reserve.currentAverageStableBorrowRate     );      reserve.currentLiquidityRate = newLiquidityRate;     reserve.currentStableBorrowRate = newStableRate;     reserve.currentVariableBorrowRate = newVariableRate;      //solium-disable-next-line     reserve.lastUpdateTimestamp = uint40(block.timestamp);      emit ReserveUpdated(         _reserve,         newLiquidityRate,         newStableRate,         newVariableRate,         reserve.lastLiquidityCumulativeIndex,         reserve.lastVariableBorrowCumulativeIndex     ); }  /** * @dev transfers to the protocol fees of a flashloan to the fees collection address * @param _token the address of the token being transferred * @param _amount the amount being transferred **/  function transferFlashLoanProtocolFeeInternal(address _token, uint256 _amount) internal {     address payable receiver = address(uint160(addressesProvider.getTokenDistributor()));      if (_token != EthAddressLib.ethAddress()) {         ERC20(_token).safeTransfer(receiver, _amount);     } else {         receiver.transfer(_amount);     } }  /** * @dev updates the internal configuration of the core **/ function refreshConfigInternal() internal {     lendingPoolAddress = addressesProvider.getLendingPool(); }  /** * @dev adds a reserve to the array of the reserves address **/ function addReserveToListInternal(address _reserve) internal {     bool reserveAlreadyAdded = false;     for (uint256 i = 0; i &lt; reservesList.length; i++)         if (reservesList[i] == _reserve) {             reserveAlreadyAdded = true;         }     if (!reserveAlreadyAdded) reservesList.push(_reserve); }  } |
| **need_reflect** | True |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **phase_prompt** | We excel in generating innovative approaches and enhancements for Solidity smart contract code. Here's a Solidity contract provided by the user: "{task}". As the {assistant_role}, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user. Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions". |
| **phase_name** | ContractAnalysis |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': 'pragma solidity ^0.5.0;\n\nimport "openzeppelin-solidity/contracts/math/SafeMath.sol";\nimport "openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol";\nimport "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol";\nimport "openzeppelin-solidity/contracts/utils/Address.sol";\nimport "../libraries/openzeppelin-upgradeability/VersionedInitializable.sol";\n\nimport "../libraries/CoreLibrary.sol";\nimport "../configuration/LendingPoolAddressesProvider.sol";\nimport "../interfaces/ILendingRateOracle.sol";\nimport "../interfaces/IReserveInterestRateStrategy.sol";\nimport "../libraries/WadRayMath.sol";\nimport "../tokenization/AToken.sol";\nimport "../libraries/EthAddressLib.sol";\n\n/\n @title LendingPoolCore contract\n @author Aave\n @notice Holds the state of the lending pool and all the funds deposited\n @dev NOTE: The core does not enforce security checks on the update of the state\n (eg, updateStateOnBorrow() does not enforce that borrowed is enabled on the reserve).\n The check that an action can be performed is a duty of the overlying LendingPool contract.\n/\n\ncontract LendingPoolCore is VersionedInitializable {\n    using SafeMath for uint256;\n    using WadRayMath for uint256;\n    using CoreLibrary for CoreLibrary.ReserveData;\n    using CoreLibrary for CoreLibrary.UserReserveData;\n    using SafeERC20 for ERC20;\n    using Address for address payable;\n\n    /\n    * @dev Emitted when the state of a reserve is updated\n    * @param reserve the address of the reserve\n    * @param liquidityRate the new liquidity rate\n    * @param stableBorrowRate the new stable borrow rate\n    * @param variableBorrowRate the new variable borrow rate\n    * @param liquidityIndex the new liquidity index\n    * @param variableBorrowIndex the new variable borrow index\n    /\n    event ReserveUpdated(\n        address indexed reserve,\n        uint256 liquidityRate,\n        uint256 stableBorrowRate,\n        uint256 variableBorrowRate,\n        uint256 liquidityIndex,\n        uint256 variableBorrowIndex\n    );\n\n    address public lendingPoolAddress;\n\n    LendingPoolAddressesProvider public addressesProvider;\n\n    /\n    * @dev only lending pools can use functions affected by this modifier\n    /\n    modifier onlyLendingPool {\n        require(lendingPoolAddress == msg.sender, "The caller must be a lending pool contract");\n        ;\n    }\n\n    /\n    * @dev only lending pools configurator can use functions affected by this modifier\n    /\n    modifier onlyLendingPoolConfigurator {\n        require(\n            addressesProvider.getLendingPoolConfigurator() == msg.sender,\n            "The caller must be a lending pool configurator contract"\n        );\n        ;\n    }\n\n    mapping(address =&gt; CoreLibrary.ReserveData) internal reserves;\n    mapping(address =&gt; mapping(address =&gt; CoreLibrary.UserReserveData)) internal usersReserveData;\n\n    address[] public reservesList;\n\n    uint256 public constant CORE_REVISION = 0x4;\n\n    /\n    * @dev returns the revision number of the contract\n    /\n    function getRevision() internal pure returns (uint256) {\n        return CORE_REVISION;\n    }\n\n    /\n    * @dev initializes the Core contract, invoked upon registration on the AddressesProvider\n    * @param _addressesProvider the addressesProvider contract\n    /\n\n    function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {\n        addressesProvider = _addressesProvider;\n        refreshConfigInternal();\n    }\n\n    /\n    * @dev updates the state of the core as a result of a deposit action\n    * @param _reserve the address of the reserve in which the deposit is happening\n    * @param _user the address of the the user depositing\n    * @param _amount the amount being deposited\n    * @param _isFirstDeposit true if the user is depositing for the first time\n    /\n\n    function updateStateOnDeposit(\n        address _reserve,\n        address _user,\n        uint256 _amount,\n        bool _isFirstDeposit\n    ) external onlyLendingPool {\n        reserves[_reserve].updateCumulativeIndexes();\n        updateReserveInterestRatesAndTimestampInternal(_reserve, _amount, 0);\n\n        if (_isFirstDeposit) {\n            //if this is the first deposit of the user, we configure the deposit as enabled to be used as collateral\n            setUserUseReserveAsCollateral(_reserve, _user, true);\n        }\n    }\n\n    /\n    * @dev updates the state of the core as a result of a redeem action\n    * @param _reserve the address of the reserve in which the redeem is happening\n    * @param _user the address of the the user redeeming\n    * @param _amountRedeemed the amount being redeemed\n    * @param _userRedeemedEverything true if the user is redeeming everything\n    /\n    function updateStateOnRedeem(\n        address _reserve,\n        address _user,\n        uint256 _amountRedeemed,\n        bool _userRedeemedEverything\n    ) external onlyLendingPool {\n        //compound liquidity and variable borrow interests\n        reserves[_reserve].updateCumulativeIndexes();\n        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountRedeemed);\n\n        //if user redeemed everything the useReserveAsCollateral flag is reset\n        if (_userRedeemedEverything) {\n            setUserUseReserveAsCollateral(_reserve, _user, false);\n        }\n    }\n\n    /\n    * @dev updates the state of the core as a result of a flashloan action\n    * @param _reserve the address of the reserve in which the flashloan is happening\n    * @param _income the income of the protocol as a result of the action\n    /\n    function updateStateOnFlashLoan(\n        address _reserve,\n        uint256 _availableLiquidityBefore,\n        uint256 _income,\n        uint256 _protocolFee\n    ) external onlyLendingPool {\n        transferFlashLoanProtocolFeeInternal(_reserve, _protocolFee);\n\n        //compounding the cumulated interest\n        reserves[_reserve].updateCumulativeIndexes();\n\n        uint256 totalLiquidityBefore = _availableLiquidityBefore.add(\n            getReserveTotalBorrows(_reserve)\n        );\n\n        //compounding the received fee into the reserve\n        reserves[_reserve].cumulateToLiquidityIndex(totalLiquidityBefore, _income);\n\n        //refresh interest rates\n        updateReserveInterestRatesAndTimestampInternal(_reserve, _income, 0);\n    }\n\n    /\n    * @dev updates the state of the core as a consequence of a borrow action.\n    * @param _reserve the address of the reserve on which the user is borrowing\n    * @param _user the address of the borrower\n    * @param _amountBorrowed the new amount borrowed\n    * @param _borrowFee the fee on the amount borrowed\n    * @param _rateMode the borrow rate mode (stable, variable)\n    * @return the new borrow rate for the user\n    /\n    function updateStateOnBorrow(\n        address _reserve,\n        address _user,\n        uint256 _amountBorrowed,\n        uint256 _borrowFee,\n        CoreLibrary.InterestRateMode _rateMode\n    ) external onlyLendingPool returns (uint256, uint256) {\n        // getting the previous borrow data of the user\n        (uint256 principalBorrowBalance, , uint256 balanceIncrease) = getUserBorrowBalances(\n            _reserve,\n            _user\n        );\n\n        updateReserveStateOnBorrowInternal(\n            _reserve,\n            _user,\n            principalBorrowBalance,\n            balanceIncrease,\n            _amountBorrowed,\n            _rateMode\n        );\n\n        updateUserStateOnBorrowInternal(\n            _reserve,\n            _user,\n            _amountBorrowed,\n            balanceIncrease,\n            _borrowFee,\n            _rateMode\n        );\n\n        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountBorrowed);\n\n        return (getUserCurrentBorrowRate(_reserve, _user), balanceIncrease);\n    }\n\n    /\n    * @dev updates the state of the core as a consequence of a repay action.\n    * @param _reserve the address of the reserve on which the user is repaying\n    * @param _user the address of the borrower\n    * @param _paybackAmountMinusFees the amount being paid back minus fees\n    * @param _originationFeeRepaid the fee on the amount that is being repaid\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    * @param _repaidWholeLoan true if the user is repaying the whole loan\n    /\n\n    function updateStateOnRepay(\n        address _reserve,\n        address _user,\n        uint256 _paybackAmountMinusFees,\n        uint256 _originationFeeRepaid,\n        uint256 _balanceIncrease,\n        bool _repaidWholeLoan\n    ) external onlyLendingPool {\n        updateReserveStateOnRepayInternal(\n            _reserve,\n            _user,\n            _paybackAmountMinusFees,\n            _balanceIncrease\n        );\n        updateUserStateOnRepayInternal(\n            _reserve,\n            _user,\n            _paybackAmountMinusFees,\n            _originationFeeRepaid,\n            _balanceIncrease,\n            _repaidWholeLoan\n        );\n\n        updateReserveInterestRatesAndTimestampInternal(_reserve, _paybackAmountMinusFees, 0);\n    }\n\n    /\n    * @dev updates the state of the core as a consequence of a swap rate action.\n    * @param _reserve the address of the reserve on which the user is repaying\n    * @param _user the address of the borrower\n    * @param _principalBorrowBalance the amount borrowed by the user\n    * @param _compoundedBorrowBalance the amount borrowed plus accrued interest\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    * @param _currentRateMode the current interest rate mode for the user\n    /\n    function updateStateOnSwapRate(\n        address _reserve,\n        address _user,\n        uint256 _principalBorrowBalance,\n        uint256 _compoundedBorrowBalance,\n        uint256 _balanceIncrease,\n        CoreLibrary.InterestRateMode _currentRateMode\n    ) external onlyLendingPool returns (CoreLibrary.InterestRateMode, uint256) {\n        updateReserveStateOnSwapRateInternal(\n            _reserve,\n            _user,\n            _principalBorrowBalance,\n            _compoundedBorrowBalance,\n            _currentRateMode\n        );\n\n        CoreLibrary.InterestRateMode newRateMode = updateUserStateOnSwapRateInternal(\n            _reserve,\n            _user,\n            _balanceIncrease,\n            _currentRateMode\n        );\n\n        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);\n\n        return (newRateMode, getUserCurrentBorrowRate(_reserve, _user));\n    }\n\n    /\n    * @dev updates the state of the core as a consequence of a liquidation action.\n    * @param _principalReserve the address of the principal reserve that is being repaid\n    * @param _collateralReserve the address of the collateral reserve that is being liquidated\n    * @param _user the address of the borrower\n    * @param _amountToLiquidate the amount being repaid by the liquidator\n    * @param _collateralToLiquidate the amount of collateral being liquidated\n    * @param _feeLiquidated the amount of origination fee being liquidated\n    * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise\n    /\n    function updateStateOnLiquidation(\n        address _principalReserve,\n        address _collateralReserve,\n        address _user,\n        uint256 _amountToLiquidate,\n        uint256 _collateralToLiquidate,\n        uint256 _feeLiquidated,\n        uint256 _liquidatedCollateralForFee,\n        uint256 _balanceIncrease,\n        bool _liquidatorReceivesAToken\n    ) external onlyLendingPool {\n        updatePrincipalReserveStateOnLiquidationInternal(\n            _principalReserve,\n            _user,\n            _amountToLiquidate,\n            _balanceIncrease\n        );\n\n        updateCollateralReserveStateOnLiquidationInternal(\n            _collateralReserve\n        );\n\n        updateUserStateOnLiquidationInternal(\n            _principalReserve,\n            _user,\n            _amountToLiquidate,\n            _feeLiquidated,\n            _balanceIncrease\n        );\n\n        updateReserveInterestRatesAndTimestampInternal(_principalReserve, _amountToLiquidate, 0);\n\n        if (!_liquidatorReceivesAToken) {\n            updateReserveInterestRatesAndTimestampInternal(\n                _collateralReserve,\n                0,\n                _collateralToLiquidate.add(_liquidatedCollateralForFee)\n            );\n        }\n\n    }\n\n    /\n    * @dev updates the state of the core as a consequence of a stable rate rebalance\n    * @param _reserve the address of the principal reserve where the user borrowed\n    * @param _user the address of the borrower\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    * @return the new stable rate for the user\n    /\n    function updateStateOnRebalance(address _reserve, address _user, uint256 _balanceIncrease)\n    external\n    onlyLendingPool\n    returns (uint256)\n    {\n        updateReserveStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);\n\n        //update user data and rebalance the rate\n        updateUserStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);\n        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);\n        return usersReserveData[_user][_reserve].stableBorrowRate;\n    }\n\n    /\n    * @dev enables or disables a reserve as collateral\n    * @param _reserve the address of the principal reserve where the user deposited\n    * @param _user the address of the depositor\n    * @param _useAsCollateral true if the depositor wants to use the reserve as collateral\n    /\n    function setUserUseReserveAsCollateral(address _reserve, address _user, bool _useAsCollateral)\n    public\n    onlyLendingPool\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        user.useAsCollateral = _useAsCollateral;\n    }\n\n    /\n    * @notice ETH/token transfer functions\n    /\n\n    /\n    * @dev fallback function enforces that the caller is a contract, to support flashloan transfers\n    /\n    function() external payable {\n        //only contracts can send ETH to the core\n        require(msg.sender.isContract(), "Only contracts can send ether to the Lending pool core");\n\n    }\n\n    /\n    * @dev transfers to the user a specific amount from the reserve.\n    * @param _reserve the address of the reserve where the transfer is happening\n    * @param _user the address of the user receiving the transfer\n    * @param _amount the amount being transferred\n    /\n    function transferToUser(address _reserve, address payable _user, uint256 _amount)\n    external\n    onlyLendingPool\n    {\n        if (_reserve != EthAddressLib.ethAddress()) {\n            ERC20(_reserve).safeTransfer(_user, _amount);\n        } else {\n            //solium-disable-next-line\n            (bool result, ) = _user.call.value(_amount).gas(50000)("");\n            require(result, "Transfer of ETH failed");\n        }\n    }\n\n    /\n    * @dev transfers the protocol fees to the fees collection address\n    * @param _token the address of the token being transferred\n    * @param _user the address of the user from where the transfer is happening\n    * @param _amount the amount being transferred\n    * @param _destination the fee receiver address\n    /\n\n    function transferToFeeCollectionAddress(\n        address _token,\n        address _user,\n        uint256 _amount,\n        address _destination\n    ) external payable onlyLendingPool {\n        address payable feeAddress = address(uint160(_destination)); //cast the address to payable\n\n        if (_token != EthAddressLib.ethAddress()) {\n            require(\n                msg.value == 0,\n                "User is sending ETH along with the ERC20 transfer. Check the value attribute of the transaction"\n            );\n            ERC20(_token).safeTransferFrom(_user, feeAddress, _amount);\n        } else {\n            require(msg.value &gt;= _amount, "The amount and the value sent to deposit do not match");\n            //solium-disable-next-line\n            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");\n            require(result, "Transfer of ETH failed");\n        }\n    }\n\n    /\n    * @dev transfers the fees to the fees collection address in the case of liquidation\n    * @param _token the address of the token being transferred\n    * @param _amount the amount being transferred\n    * @param _destination the fee receiver address\n    /\n    function liquidateFee(\n        address _token,\n        uint256 _amount,\n        address _destination\n    ) external payable onlyLendingPool {\n        address payable feeAddress = address(uint160(_destination)); //cast the address to payable\n        require(\n            msg.value == 0,\n            "Fee liquidation does not require any transfer of value"\n        );\n\n        if (_token != EthAddressLib.ethAddress()) {\n            ERC20(_token).safeTransfer(feeAddress, _amount);\n        } else {\n            //solium-disable-next-line\n            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");\n            require(result, "Transfer of ETH failed");\n        }\n    }\n\n    /\n    * @dev transfers an amount from a user to the destination reserve\n    * @param _reserve the address of the reserve where the amount is being transferred\n    * @param _user the address of the user from where the transfer is happening\n    * @param _amount the amount being transferred\n    /\n    function transferToReserve(address _reserve, address payable _user, uint256 _amount)\n    external\n    payable\n    onlyLendingPool\n    {\n        if (_reserve != EthAddressLib.ethAddress()) {\n            require(msg.value == 0, "User is sending ETH along with the ERC20 transfer.");\n            ERC20(_reserve).safeTransferFrom(_user, address(this), _amount);\n\n        } else {\n            require(msg.value &gt;= _amount, "The amount and the value sent to deposit do not match");\n\n            if (msg.value &gt; _amount) {\n                //send back excess ETH\n                uint256 excessAmount = msg.value.sub(_amount);\n                //solium-disable-next-line\n                (bool result, ) = _user.call.value(excessAmount).gas(50000)("");\n                require(result, "Transfer of ETH failed");\n            }\n        }\n    }\n\n    /\n    * @notice data access functions\n    /\n\n    /\n    * @dev returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral)\n    * needed to calculate the global account data in the LendingPoolDataProvider\n    * @param _reserve the address of the reserve\n    * @param _user the address of the user\n    * @return the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not\n    /\n    function getUserBasicReserveData(address _reserve, address _user)\n    external\n    view\n    returns (uint256, uint256, uint256, bool)\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n\n        uint256 underlyingBalance = getUserUnderlyingAssetBalance(_reserve, _user);\n\n        if (user.principalBorrowBalance == 0) {\n            return (underlyingBalance, 0, 0, user.useAsCollateral);\n        }\n\n        return (\n        underlyingBalance,\n        user.getCompoundedBorrowBalance(reserve),\n        user.originationFee,\n        user.useAsCollateral\n        );\n    }\n\n    /\n    * @dev checks if a user is allowed to borrow at a stable rate\n    * @param _reserve the reserve address\n    * @param _user the user\n    * @param _amount the amount the the user wants to borrow\n    * @return true if the user is allowed to borrow at a stable rate, false otherwise\n    /\n\n    function isUserAllowedToBorrowAtStable(address _reserve, address _user, uint256 _amount)\n    external\n    view\n    returns (bool)\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n\n        if (!reserve.isStableBorrowRateEnabled) return false;\n\n        return\n        !user.useAsCollateral ||\n        !reserve.usageAsCollateralEnabled ||\n        _amount &gt; getUserUnderlyingAssetBalance(_reserve, _user);\n    }\n\n    /\n    * @dev gets the underlying asset balance of a user based on the corresponding aToken balance.\n    * @param _reserve the reserve address\n    * @param _user the user address\n    * @return the underlying deposit balance of the user\n    /\n\n    function getUserUnderlyingAssetBalance(address _reserve, address _user)\n    public\n    view\n    returns (uint256)\n    {\n        AToken aToken = AToken(reserves[_reserve].aTokenAddress);\n        return aToken.balanceOf(_user);\n\n    }\n\n    /\n    * @dev gets the interest rate strategy contract address for the reserve\n    * @param _reserve the reserve address\n    * @return the address of the interest rate strategy contract\n    /\n    function getReserveInterestRateStrategyAddress(address _reserve) public view returns (address) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.interestRateStrategyAddress;\n    }\n\n    /\n    * @dev gets the aToken contract address for the reserve\n    * @param _reserve the reserve address\n    * @return the address of the aToken contract\n    /\n\n    function getReserveATokenAddress(address _reserve) public view returns (address) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.aTokenAddress;\n    }\n\n    /\n    * @dev gets the available liquidity in the reserve. The available liquidity is the balance of the core contract\n    * @param _reserve the reserve address\n    * @return the available liquidity\n    /\n    function getReserveAvailableLiquidity(address _reserve) public view returns (uint256) {\n        uint256 balance = 0;\n\n        if (_reserve == EthAddressLib.ethAddress()) {\n            balance = address(this).balance;\n        } else {\n            balance = IERC20(_reserve).balanceOf(address(this));\n        }\n        return balance;\n    }\n\n    /\n    * @dev gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows\n    * @param _reserve the reserve address\n    * @return the total liquidity\n    /\n    function getReserveTotalLiquidity(address _reserve) public view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return getReserveAvailableLiquidity(_reserve).add(reserve.getTotalBorrows());\n    }\n\n    /\n    * @dev gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there\n    * there has been 100% income.\n    * @param _reserve the reserve address\n    * @return the reserve normalized income\n    /\n    function getReserveNormalizedIncome(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.getNormalizedIncome();\n    }\n\n    /\n    * @dev gets the reserve total borrows\n    * @param _reserve the reserve address\n    * @return the total borrows (stable + variable)\n    /\n    function getReserveTotalBorrows(address _reserve) public view returns (uint256) {\n        return reserves[_reserve].getTotalBorrows();\n    }\n\n    /\n    * @dev gets the reserve total borrows stable\n    * @param _reserve the reserve address\n    * @return the total borrows stable\n    /\n    function getReserveTotalBorrowsStable(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.totalBorrowsStable;\n    }\n\n    /\n    * @dev gets the reserve total borrows variable\n    * @param _reserve the reserve address\n    * @return the total borrows variable\n    /\n\n    function getReserveTotalBorrowsVariable(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.totalBorrowsVariable;\n    }\n\n    /\n    * @dev gets the reserve liquidation threshold\n    * @param _reserve the reserve address\n    * @return the reserve liquidation threshold\n    /\n\n    function getReserveLiquidationThreshold(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.liquidationThreshold;\n    }\n\n    /\n    * @dev gets the reserve liquidation bonus\n    * @param _reserve the reserve address\n    * @return the reserve liquidation bonus\n    /\n\n    function getReserveLiquidationBonus(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.liquidationBonus;\n    }\n\n    /\n    * @dev gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty\n    * @param _reserve the reserve address\n    * @return the reserve current variable borrow rate\n    /\n\n    function getReserveCurrentVariableBorrowRate(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n\n        if (reserve.currentVariableBorrowRate == 0) {\n            return\n            IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)\n            .getBaseVariableBorrowRate();\n        }\n        return reserve.currentVariableBorrowRate;\n    }\n\n    /\n    * @dev gets the reserve current stable borrow rate. Is the market rate if the reserve is empty\n    * @param _reserve the reserve address\n    * @return the reserve current stable borrow rate\n    /\n\n    function getReserveCurrentStableBorrowRate(address _reserve) public view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        ILendingRateOracle oracle = ILendingRateOracle(addressesProvider.getLendingRateOracle());\n\n        if (reserve.currentStableBorrowRate == 0) {\n            //no stable rate borrows yet\n            return oracle.getMarketBorrowRate(_reserve);\n        }\n\n        return reserve.currentStableBorrowRate;\n    }\n\n    /\n    * @dev gets the reserve average stable borrow rate. The average stable rate is the weighted average\n    * of all the loans taken at stable rate.\n    * @param _reserve the reserve address\n    * @return the reserve current average borrow rate\n    /\n    function getReserveCurrentAverageStableBorrowRate(address _reserve)\n    external\n    view\n    returns (uint256)\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.currentAverageStableBorrowRate;\n    }\n\n    /\n    * @dev gets the reserve liquidity rate\n    * @param _reserve the reserve address\n    * @return the reserve liquidity rate\n    /\n    function getReserveCurrentLiquidityRate(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.currentLiquidityRate;\n    }\n\n    /\n    * @dev gets the reserve liquidity cumulative index\n    * @param _reserve the reserve address\n    * @return the reserve liquidity cumulative index\n    /\n    function getReserveLiquidityCumulativeIndex(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.lastLiquidityCumulativeIndex;\n    }\n\n    /\n    * @dev gets the reserve variable borrow index\n    * @param _reserve the reserve address\n    * @return the reserve variable borrow index\n    /\n    function getReserveVariableBorrowsCumulativeIndex(address _reserve)\n    external\n    view\n    returns (uint256)\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.lastVariableBorrowCumulativeIndex;\n    }\n\n    /\n    * @dev this function aggregates the configuration parameters of the reserve.\n    * It\'s used in the LendingPoolDataProvider specifically to save gas, and avoid\n    * multiple external contract calls to fetch the same data.\n    * @param _reserve the reserve address\n    * @return the reserve decimals\n    * @return the base ltv as collateral\n    * @return the liquidation threshold\n    * @return if the reserve is used as collateral or not\n    /\n    function getReserveConfiguration(address _reserve)\n    external\n    view\n    returns (uint256, uint256, uint256, bool)\n    {\n        uint256 decimals;\n        uint256 baseLTVasCollateral;\n        uint256 liquidationThreshold;\n        bool usageAsCollateralEnabled;\n\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        decimals = reserve.decimals;\n        baseLTVasCollateral = reserve.baseLTVasCollateral;\n        liquidationThreshold = reserve.liquidationThreshold;\n        usageAsCollateralEnabled = reserve.usageAsCollateralEnabled;\n\n        return (decimals, baseLTVasCollateral, liquidationThreshold, usageAsCollateralEnabled);\n    }\n\n    /\n    * @dev returns the decimals of the reserve\n    * @param _reserve the reserve address\n    * @return the reserve decimals\n    /\n    function getReserveDecimals(address _reserve) external view returns (uint256) {\n        return reserves[_reserve].decimals;\n    }\n\n    /\n    * @dev returns true if the reserve is enabled for borrowing\n    * @param _reserve the reserve address\n    * @return true if the reserve is enabled for borrowing, false otherwise\n    /\n\n    function isReserveBorrowingEnabled(address _reserve) external view returns (bool) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.borrowingEnabled;\n    }\n\n    /\n    * @dev returns true if the reserve is enabled as collateral\n    * @param _reserve the reserve address\n    * @return true if the reserve is enabled as collateral, false otherwise\n    /\n\n    function isReserveUsageAsCollateralEnabled(address _reserve) external view returns (bool) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.usageAsCollateralEnabled;\n    }\n\n    /\n    * @dev returns true if the stable rate is enabled on reserve\n    * @param _reserve the reserve address\n    * @return true if the stable rate is enabled on reserve, false otherwise\n    /\n    function getReserveIsStableBorrowRateEnabled(address _reserve) external view returns (bool) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.isStableBorrowRateEnabled;\n    }\n\n    /\n    * @dev returns true if the reserve is active\n    * @param _reserve the reserve address\n    * @return true if the reserve is active, false otherwise\n    /\n    function getReserveIsActive(address _reserve) external view returns (bool) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.isActive;\n    }\n\n    /\n    * @notice returns if a reserve is freezed\n    * @param _reserve the reserve for which the information is needed\n    * @return true if the reserve is freezed, false otherwise\n    /\n\n    function getReserveIsFreezed(address _reserve) external view returns (bool) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.isFreezed;\n    }\n\n    /\n    * @notice returns the timestamp of the last action on the reserve\n    * @param _reserve the reserve for which the information is needed\n    * @return the last updated timestamp of the reserve\n    /\n\n    function getReserveLastUpdate(address _reserve) external view returns (uint40 timestamp) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        timestamp = reserve.lastUpdateTimestamp;\n    }\n\n    /\n    * @dev returns the utilization rate U of a specific reserve\n    * @param _reserve the reserve for which the information is needed\n    * @return the utilization rate in ray\n    /\n\n    function getReserveUtilizationRate(address _reserve) public view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n\n        uint256 totalBorrows = reserve.getTotalBorrows();\n\n        if (totalBorrows == 0) {\n            return 0;\n        }\n\n        uint256 availableLiquidity = getReserveAvailableLiquidity(_reserve);\n\n        return totalBorrows.rayDiv(availableLiquidity.add(totalBorrows));\n    }\n\n    /\n    * @return the array of reserves configured on the core\n    /\n    function getReserves() external view returns (address[] memory) {\n        return reservesList;\n    }\n\n    /\n    * @param _reserve the address of the reserve for which the information is needed\n    * @param _user the address of the user for which the information is needed\n    * @return true if the user has chosen to use the reserve as collateral, false otherwise\n    /\n    function isUserUseReserveAsCollateralEnabled(address _reserve, address _user)\n    external\n    view\n    returns (bool)\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        return user.useAsCollateral;\n    }\n\n    /\n    * @param _reserve the address of the reserve for which the information is needed\n    * @param _user the address of the user for which the information is needed\n    * @return the origination fee for the user\n    /\n    function getUserOriginationFee(address _reserve, address _user)\n    external\n    view\n    returns (uint256)\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        return user.originationFee;\n    }\n\n    /\n    * @dev users with no loans in progress have NONE as borrow rate mode\n    * @param _reserve the address of the reserve for which the information is needed\n    * @param _user the address of the user for which the information is needed\n    * @return the borrow rate mode for the user,\n    /\n\n    function getUserCurrentBorrowRateMode(address _reserve, address _user)\n    public\n    view\n    returns (CoreLibrary.InterestRateMode)\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n\n        if (user.principalBorrowBalance == 0) {\n            return CoreLibrary.InterestRateMode.NONE;\n        }\n\n        return\n        user.stableBorrowRate &gt; 0\n        ? CoreLibrary.InterestRateMode.STABLE\n        : CoreLibrary.InterestRateMode.VARIABLE;\n    }\n\n    /\n    * @dev gets the current borrow rate of the user\n    * @param _reserve the address of the reserve for which the information is needed\n    * @param _user the address of the user for which the information is needed\n    * @return the borrow rate for the user,\n    /\n    function getUserCurrentBorrowRate(address _reserve, address _user)\n    internal\n    view\n    returns (uint256)\n    {\n        CoreLibrary.InterestRateMode rateMode = getUserCurrentBorrowRateMode(_reserve, _user);\n\n        if (rateMode == CoreLibrary.InterestRateMode.NONE) {\n            return 0;\n        }\n\n        return\n        rateMode == CoreLibrary.InterestRateMode.STABLE\n        ? usersReserveData[_user][_reserve].stableBorrowRate\n        : reserves[_reserve].currentVariableBorrowRate;\n    }\n\n    /\n    * @dev the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all\n    * @param _reserve the address of the reserve for which the information is needed\n    * @param _user the address of the user for which the information is needed\n    * @return the user stable rate\n    /\n    function getUserCurrentStableBorrowRate(address _reserve, address _user)\n    external\n    view\n    returns (uint256)\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        return user.stableBorrowRate;\n    }\n\n    /\n    * @dev calculates and returns the borrow balances of the user\n    * @param _reserve the address of the reserve\n    * @param _user the address of the user\n    * @return the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance\n    /\n\n    function getUserBorrowBalances(address _reserve, address _user)\n    public\n    view\n    returns (uint256, uint256, uint256)\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        if (user.principalBorrowBalance == 0) {\n            return (0, 0, 0);\n        }\n\n        uint256 principal = user.principalBorrowBalance;\n        uint256 compoundedBalance = CoreLibrary.getCompoundedBorrowBalance(\n            user,\n            reserves[_reserve]\n        );\n        return (principal, compoundedBalance, compoundedBalance.sub(principal));\n    }\n\n    /\n    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable\n    * @param _reserve the address of the reserve for which the information is needed\n    * @param _user the address of the user for which the information is needed\n    * @return the variable borrow index for the user\n    /\n\n    function getUserVariableBorrowCumulativeIndex(address _reserve, address _user)\n    external\n    view\n    returns (uint256)\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        return user.lastVariableBorrowCumulativeIndex;\n    }\n\n    /\n    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable\n    * @param _reserve the address of the reserve for which the information is needed\n    * @param _user the address of the user for which the information is needed\n    * @return the variable borrow index for the user\n    /\n\n    function getUserLastUpdate(address _reserve, address _user)\n    external\n    view\n    returns (uint256 timestamp)\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        timestamp = user.lastUpdateTimestamp;\n    }\n\n    /\n    * @dev updates the lending pool core configuration\n    /\n    function refreshConfiguration() external onlyLendingPoolConfigurator {\n        refreshConfigInternal();\n    }\n\n    /\n    * @dev initializes a reserve\n    * @param _reserve the address of the reserve\n    * @param _aTokenAddress the address of the overlying aToken contract\n    * @param _decimals the decimals of the reserve currency\n    * @param _interestRateStrategyAddress the address of the interest rate strategy contract\n    /\n    function initReserve(\n        address _reserve,\n        address _aTokenAddress,\n        uint256 _decimals,\n        address _interestRateStrategyAddress\n    ) external onlyLendingPoolConfigurator {\n        reserves[_reserve].init(_aTokenAddress, _decimals, _interestRateStrategyAddress);\n        addReserveToListInternal(_reserve);\n\n    }\n\n\n\n    /\n    * @dev removes the last added reserve in the reservesList array\n    * @param _reserveToRemove the address of the reserve\n    /\n    function removeLastAddedReserve(address _reserveToRemove)\n    external onlyLendingPoolConfigurator {\n\n        address lastReserve = reservesList[reservesList.length-1];\n\n        require(lastReserve == _reserveToRemove, "Reserve being removed is different than the reserve requested");\n\n        //as we can\'t check if totalLiquidity is 0 (since the reserve added might not be an ERC20) we at least check that there is nothing borrowed\n        require(getReserveTotalBorrows(lastReserve) == 0, "Cannot remove a reserve with liquidity deposited");\n\n        reserves[lastReserve].isActive = false;\n        reserves[lastReserve].aTokenAddress = address(0);\n        reserves[lastReserve].decimals = 0;\n        reserves[lastReserve].lastLiquidityCumulativeIndex = 0;\n        reserves[lastReserve].lastVariableBorrowCumulativeIndex = 0;\n        reserves[lastReserve].borrowingEnabled = false;\n        reserves[lastReserve].usageAsCollateralEnabled = false;\n        reserves[lastReserve].baseLTVasCollateral = 0;\n        reserves[lastReserve].liquidationThreshold = 0;\n        reserves[lastReserve].liquidationBonus = 0;\n        reserves[lastReserve].interestRateStrategyAddress = address(0);\n\n        reservesList.pop();\n    }\n\n    /\n    * @dev updates the address of the interest rate strategy contract\n    * @param _reserve the address of the reserve\n    * @param _rateStrategyAddress the address of the interest rate strategy contract\n    /\n\n    function setReserveInterestRateStrategyAddress(address _reserve, address _rateStrategyAddress)\n    external\n    onlyLendingPoolConfigurator\n    {\n        reserves[_reserve].interestRateStrategyAddress = _rateStrategyAddress;\n    }\n\n    /\n    * @dev enables borrowing on a reserve. Also sets the stable rate borrowing\n    * @param _reserve the address of the reserve\n    * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise\n    /\n\n    function enableBorrowingOnReserve(address _reserve, bool _stableBorrowRateEnabled)\n    external\n    onlyLendingPoolConfigurator\n    {\n        reserves[_reserve].enableBorrowing(_stableBorrowRateEnabled);\n    }\n\n    /\n    * @dev disables borrowing on a reserve\n    * @param _reserve the address of the reserve\n    /\n\n    function disableBorrowingOnReserve(address _reserve) external onlyLendingPoolConfigurator {\n        reserves[_reserve].disableBorrowing();\n    }\n\n    /\n    * @dev enables a reserve to be used as collateral\n    * @param _reserve the address of the reserve\n    /\n    function enableReserveAsCollateral(\n        address _reserve,\n        uint256 _baseLTVasCollateral,\n        uint256 _liquidationThreshold,\n        uint256 _liquidationBonus\n    ) external onlyLendingPoolConfigurator {\n        reserves[_reserve].enableAsCollateral(\n            _baseLTVasCollateral,\n            _liquidationThreshold,\n            _liquidationBonus\n        );\n    }\n\n    /\n    * @dev disables a reserve to be used as collateral\n    * @param _reserve the address of the reserve\n    /\n    function disableReserveAsCollateral(address _reserve) external onlyLendingPoolConfigurator {\n        reserves[_reserve].disableAsCollateral();\n    }\n\n    /\n    * @dev enable the stable borrow rate mode on a reserve\n    * @param _reserve the address of the reserve\n    /\n    function enableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.isStableBorrowRateEnabled = true;\n    }\n\n    /\n    * @dev disable the stable borrow rate mode on a reserve\n    * @param _reserve the address of the reserve\n    /\n    function disableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.isStableBorrowRateEnabled = false;\n    }\n\n    /\n    * @dev activates a reserve\n    * @param _reserve the address of the reserve\n    /\n    function activateReserve(address _reserve) external onlyLendingPoolConfigurator {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n\n        require(\n            reserve.lastLiquidityCumulativeIndex &gt; 0 &amp;&amp;\n            reserve.lastVariableBorrowCumulativeIndex &gt; 0,\n            "Reserve has not been initialized yet"\n        );\n        reserve.isActive = true;\n    }\n\n    /\n    * @dev deactivates a reserve\n    * @param _reserve the address of the reserve\n    /\n    function deactivateReserve(address _reserve) external onlyLendingPoolConfigurator {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.isActive = false;\n    }\n\n    /\n    * @notice allows the configurator to freeze the reserve.\n    * A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance.\n    * @param _reserve the address of the reserve\n    /\n    function freezeReserve(address _reserve) external onlyLendingPoolConfigurator {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.isFreezed = true;\n    }\n\n    /\n    * @notice allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed.\n    * @param _reserve the address of the reserve\n    /\n    function unfreezeReserve(address _reserve) external onlyLendingPoolConfigurator {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.isFreezed = false;\n    }\n\n    /\n    * @notice allows the configurator to update the loan to value of a reserve\n    * @param _reserve the address of the reserve\n    * @param _ltv the new loan to value\n    /\n    function setReserveBaseLTVasCollateral(address _reserve, uint256 _ltv)\n    external\n    onlyLendingPoolConfigurator\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.baseLTVasCollateral = _ltv;\n    }\n\n    /\n    * @notice allows the configurator to update the liquidation threshold of a reserve\n    * @param _reserve the address of the reserve\n    * @param _threshold the new liquidation threshold\n    /\n    function setReserveLiquidationThreshold(address _reserve, uint256 _threshold)\n    external\n    onlyLendingPoolConfigurator\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.liquidationThreshold = _threshold;\n    }\n\n    /\n    * @notice allows the configurator to update the liquidation bonus of a reserve\n    * @param _reserve the address of the reserve\n    * @param _bonus the new liquidation bonus\n    /\n    function setReserveLiquidationBonus(address _reserve, uint256 _bonus)\n    external\n    onlyLendingPoolConfigurator\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.liquidationBonus = _bonus;\n    }\n\n    /\n    * @notice allows the configurator to update the reserve decimals\n    * @param _reserve the address of the reserve\n    * @param _decimals the decimals of the reserve\n    /\n    function setReserveDecimals(address _reserve, uint256 _decimals)\n    external\n    onlyLendingPoolConfigurator\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.decimals = _decimals;\n    }\n\n    /\n    * @notice internal functions\n    /\n\n    /\n    * @dev updates the state of a reserve as a consequence of a borrow action.\n    * @param _reserve the address of the reserve on which the user is borrowing\n    * @param _user the address of the borrower\n    * @param _principalBorrowBalance the previous borrow balance of the borrower before the action\n    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount\n    * @param _amountBorrowed the new amount borrowed\n    * @param _rateMode the borrow rate mode (stable, variable)\n    /\n\n    function updateReserveStateOnBorrowInternal(\n        address _reserve,\n        address _user,\n        uint256 _principalBorrowBalance,\n        uint256 _balanceIncrease,\n        uint256 _amountBorrowed,\n        CoreLibrary.InterestRateMode _rateMode\n    ) internal {\n        reserves[_reserve].updateCumulativeIndexes();\n\n        //increasing reserve total borrows to account for the new borrow balance of the user\n        //NOTE: Depending on the previous borrow mode, the borrows might need to be switched from variable to stable or vice versa\n\n        updateReserveTotalBorrowsByRateModeInternal(\n            _reserve,\n            _user,\n            _principalBorrowBalance,\n            _balanceIncrease,\n            _amountBorrowed,\n            _rateMode\n        );\n    }\n\n    /\n    * @dev updates the state of a user as a consequence of a borrow action.\n    * @param _reserve the address of the reserve on which the user is borrowing\n    * @param _user the address of the borrower\n    * @param _amountBorrowed the amount borrowed\n    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount\n    * @param _rateMode the borrow rate mode (stable, variable)\n    * @return the final borrow rate for the user. Emitted by the borrow() event\n    /\n\n    function updateUserStateOnBorrowInternal(\n        address _reserve,\n        address _user,\n        uint256 _amountBorrowed,\n        uint256 _balanceIncrease,\n        uint256 _fee,\n        CoreLibrary.InterestRateMode _rateMode\n    ) internal {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n\n        if (_rateMode == CoreLibrary.InterestRateMode.STABLE) {\n            //stable\n            //reset the user variable index, and update the stable rate\n            user.stableBorrowRate = reserve.currentStableBorrowRate;\n            user.lastVariableBorrowCumulativeIndex = 0;\n        } else if (_rateMode == CoreLibrary.InterestRateMode.VARIABLE) {\n            //variable\n            //reset the user stable rate, and store the new borrow index\n            user.stableBorrowRate = 0;\n            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;\n        } else {\n            revert("Invalid borrow rate mode");\n        }\n        //increase the principal borrows and the origination fee\n        user.principalBorrowBalance = user.principalBorrowBalance.add(_amountBorrowed).add(\n            _balanceIncrease\n        );\n        user.originationFee = user.originationFee.add(_fee);\n\n        //solium-disable-next-line\n        user.lastUpdateTimestamp = uint40(block.timestamp);\n\n    }\n\n    /\n    * @dev updates the state of the reserve as a consequence of a repay action.\n    * @param _reserve the address of the reserve on which the user is repaying\n    * @param _user the address of the borrower\n    * @param _paybackAmountMinusFees the amount being paid back minus fees\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    /\n\n    function updateReserveStateOnRepayInternal(\n        address _reserve,\n        address _user,\n        uint256 _paybackAmountMinusFees,\n        uint256 _balanceIncrease\n    ) internal {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_reserve][_user];\n\n        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(_reserve, _user);\n\n        //update the indexes\n        reserves[_reserve].updateCumulativeIndexes();\n\n        //compound the cumulated interest to the borrow balance and then subtracting the payback amount\n        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {\n            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(\n                _balanceIncrease,\n                user.stableBorrowRate\n            );\n            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(\n                _paybackAmountMinusFees,\n                user.stableBorrowRate\n            );\n        } else {\n            reserve.increaseTotalBorrowsVariable(_balanceIncrease);\n            reserve.decreaseTotalBorrowsVariable(_paybackAmountMinusFees);\n        }\n    }\n\n    /\n    * @dev updates the state of the user as a consequence of a repay action.\n    * @param _reserve the address of the reserve on which the user is repaying\n    * @param _user the address of the borrower\n    * @param _paybackAmountMinusFees the amount being paid back minus fees\n    * @param _originationFeeRepaid the fee on the amount that is being repaid\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    * @param _repaidWholeLoan true if the user is repaying the whole loan\n    /\n    function updateUserStateOnRepayInternal(\n        address _reserve,\n        address _user,\n        uint256 _paybackAmountMinusFees,\n        uint256 _originationFeeRepaid,\n        uint256 _balanceIncrease,\n        bool _repaidWholeLoan\n    ) internal {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n\n        //update the user principal borrow balance, adding the cumulated interest and then subtracting the payback amount\n        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(\n            _paybackAmountMinusFees\n        );\n        user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;\n\n        //if the balance decrease is equal to the previous principal (user is repaying the whole loan)\n        //and the rate mode is stable, we reset the interest rate mode of the user\n        if (_repaidWholeLoan) {\n            user.stableBorrowRate = 0;\n            user.lastVariableBorrowCumulativeIndex = 0;\n        }\n        user.originationFee = user.originationFee.sub(_originationFeeRepaid);\n\n        //solium-disable-next-line\n        user.lastUpdateTimestamp = uint40(block.timestamp);\n\n    }\n\n    /\n    * @dev updates the state of the user as a consequence of a swap rate action.\n    * @param _reserve the address of the reserve on which the user is performing the rate swap\n    * @param _user the address of the borrower\n    * @param _principalBorrowBalance the the principal amount borrowed by the user\n    * @param _compoundedBorrowBalance the principal amount plus the accrued interest\n    * @param _currentRateMode the rate mode at which the user borrowed\n    /\n    function updateReserveStateOnSwapRateInternal(\n        address _reserve,\n        address _user,\n        uint256 _principalBorrowBalance,\n        uint256 _compoundedBorrowBalance,\n        CoreLibrary.InterestRateMode _currentRateMode\n    ) internal {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n\n        //compounding reserve indexes\n        reserve.updateCumulativeIndexes();\n\n        if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {\n            uint256 userCurrentStableRate = user.stableBorrowRate;\n\n            //swap to variable\n            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(\n                _principalBorrowBalance,\n                userCurrentStableRate\n            ); //decreasing stable from old principal balance\n            reserve.increaseTotalBorrowsVariable(_compoundedBorrowBalance); //increase variable borrows\n        } else if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {\n            //swap to stable\n            uint256 currentStableRate = reserve.currentStableBorrowRate;\n            reserve.decreaseTotalBorrowsVariable(_principalBorrowBalance);\n            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(\n                _compoundedBorrowBalance,\n                currentStableRate\n            );\n\n        } else {\n            revert("Invalid rate mode received");\n        }\n    }\n\n    /\n    * @dev updates the state of the user as a consequence of a swap rate action.\n    * @param _reserve the address of the reserve on which the user is performing the swap\n    * @param _user the address of the borrower\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    * @param _currentRateMode the current rate mode of the user\n    /\n\n    function updateUserStateOnSwapRateInternal(\n        address _reserve,\n        address _user,\n        uint256 _balanceIncrease,\n        CoreLibrary.InterestRateMode _currentRateMode\n    ) internal returns (CoreLibrary.InterestRateMode) {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n\n        CoreLibrary.InterestRateMode newMode = CoreLibrary.InterestRateMode.NONE;\n\n        if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {\n            //switch to stable\n            newMode = CoreLibrary.InterestRateMode.STABLE;\n            user.stableBorrowRate = reserve.currentStableBorrowRate;\n            user.lastVariableBorrowCumulativeIndex = 0;\n        } else if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {\n            newMode = CoreLibrary.InterestRateMode.VARIABLE;\n            user.stableBorrowRate = 0;\n            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;\n        } else {\n            revert("Invalid interest rate mode received");\n        }\n        //compounding cumulated interest\n        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);\n        //solium-disable-next-line\n        user.lastUpdateTimestamp = uint40(block.timestamp);\n\n        return newMode;\n    }\n\n    /\n    * @dev updates the state of the principal reserve as a consequence of a liquidation action.\n    * @param _principalReserve the address of the principal reserve that is being repaid\n    * @param _user the address of the borrower\n    * @param _amountToLiquidate the amount being repaid by the liquidator\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    /\n\n    function updatePrincipalReserveStateOnLiquidationInternal(\n        address _principalReserve,\n        address _user,\n        uint256 _amountToLiquidate,\n        uint256 _balanceIncrease\n    ) internal {\n        CoreLibrary.ReserveData storage reserve = reserves[_principalReserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_principalReserve];\n\n        //update principal reserve data\n        reserve.updateCumulativeIndexes();\n\n        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(\n            _principalReserve,\n            _user\n        );\n\n        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {\n            //increase the total borrows by the compounded interest\n            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(\n                _balanceIncrease,\n                user.stableBorrowRate\n            );\n\n            //decrease by the actual amount to liquidate\n            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(\n                _amountToLiquidate,\n                user.stableBorrowRate\n            );\n\n        } else {\n            //increase the total borrows by the compounded interest\n            reserve.increaseTotalBorrowsVariable(_balanceIncrease);\n\n            //decrease by the actual amount to liquidate\n            reserve.decreaseTotalBorrowsVariable(_amountToLiquidate);\n        }\n\n    }\n\n    /\n    * @dev updates the state of the collateral reserve as a consequence of a liquidation action.\n    * @param _collateralReserve the address of the collateral reserve that is being liquidated\n    /\n    function updateCollateralReserveStateOnLiquidationInternal(\n        address _collateralReserve\n    ) internal {\n        //update collateral reserve\n        reserves[_collateralReserve].updateCumulativeIndexes();\n\n    }\n\n    /\n    * @dev updates the state of the user being liquidated as a consequence of a liquidation action.\n    * @param _reserve the address of the principal reserve that is being repaid\n    * @param _user the address of the borrower\n    * @param _amountToLiquidate the amount being repaid by the liquidator\n    * @param _feeLiquidated the amount of origination fee being liquidated\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    /\n    function updateUserStateOnLiquidationInternal(\n        address _reserve,\n        address _user,\n        uint256 _amountToLiquidate,\n        uint256 _feeLiquidated,\n        uint256 _balanceIncrease\n    ) internal {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        //first increase by the compounded interest, then decrease by the liquidated amount\n        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(\n            _amountToLiquidate\n        );\n\n        if (\n            getUserCurrentBorrowRateMode(_reserve, _user) == CoreLibrary.InterestRateMode.VARIABLE\n        ) {\n            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;\n        }\n\n        if(_feeLiquidated &gt; 0){\n            user.originationFee = user.originationFee.sub(_feeLiquidated);\n        }\n\n        //solium-disable-next-line\n        user.lastUpdateTimestamp = uint40(block.timestamp);\n    }\n\n    /\n    * @dev updates the state of the reserve as a consequence of a stable rate rebalance\n    * @param _reserve the address of the principal reserve where the user borrowed\n    * @param _user the address of the borrower\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    /\n\n    function updateReserveStateOnRebalanceInternal(\n        address _reserve,\n        address _user,\n        uint256 _balanceIncrease\n    ) internal {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n\n        reserve.updateCumulativeIndexes();\n\n        reserve.increaseTotalBorrowsStableAndUpdateAverageRate(\n            _balanceIncrease,\n            user.stableBorrowRate\n        );\n\n    }\n\n    /\n    * @dev updates the state of the user as a consequence of a stable rate rebalance\n    * @param _reserve the address of the principal reserve where the user borrowed\n    * @param _user the address of the borrower\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    /\n\n    function updateUserStateOnRebalanceInternal(\n        address _reserve,\n        address _user,\n        uint256 _balanceIncrease\n    ) internal {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n\n        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);\n        user.stableBorrowRate = reserve.currentStableBorrowRate;\n\n        //solium-disable-next-line\n        user.lastUpdateTimestamp = uint40(block.timestamp);\n    }\n\n    /\n    * @dev updates the state of the user as a consequence of a stable rate rebalance\n    * @param _reserve the address of the principal reserve where the user borrowed\n    * @param _user the address of the borrower\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    * @param _amountBorrowed the accrued interest on the borrowed amount\n    /\n    function updateReserveTotalBorrowsByRateModeInternal(\n        address _reserve,\n        address _user,\n        uint256 _principalBalance,\n        uint256 _balanceIncrease,\n        uint256 _amountBorrowed,\n        CoreLibrary.InterestRateMode _newBorrowRateMode\n    ) internal {\n        CoreLibrary.InterestRateMode previousRateMode = getUserCurrentBorrowRateMode(\n            _reserve,\n            _user\n        );\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n\n        if (previousRateMode == CoreLibrary.InterestRateMode.STABLE) {\n            CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(\n                _principalBalance,\n                user.stableBorrowRate\n            );\n        } else if (previousRateMode == CoreLibrary.InterestRateMode.VARIABLE) {\n            reserve.decreaseTotalBorrowsVariable(_principalBalance);\n        }\n\n        uint256 newPrincipalAmount = _principalBalance.add(_balanceIncrease).add(_amountBorrowed);\n        if (_newBorrowRateMode == CoreLibrary.InterestRateMode.STABLE) {\n            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(\n                newPrincipalAmount,\n                reserve.currentStableBorrowRate\n            );\n        } else if (_newBorrowRateMode == CoreLibrary.InterestRateMode.VARIABLE) {\n            reserve.increaseTotalBorrowsVariable(newPrincipalAmount);\n        } else {\n            revert("Invalid new borrow rate mode");\n        }\n    }\n\n    /\n    * @dev Updates the reserve current stable borrow rate Rf, the current variable borrow rate Rv and the current liquidity rate Rl.\n    * Also updates the lastUpdateTimestamp value. Please refer to the whitepaper for further information.\n    * @param _reserve the address of the reserve to be updated\n    * @param _liquidityAdded the amount of liquidity added to the protocol (deposit or repay) in the previous action\n    * @param _liquidityTaken the amount of liquidity taken from the protocol (redeem or borrow)\n    /\n\n    function updateReserveInterestRatesAndTimestampInternal(\n        address _reserve,\n        uint256 _liquidityAdded,\n        uint256 _liquidityTaken\n    ) internal {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        (uint256 newLiquidityRate, uint256 newStableRate, uint256 newVariableRate) = IReserveInterestRateStrategy(\n            reserve\n            .interestRateStrategyAddress\n        )\n        .calculateInterestRates(\n            _reserve,\n            getReserveAvailableLiquidity(_reserve).add(_liquidityAdded).sub(_liquidityTaken),\n            reserve.totalBorrowsStable,\n            reserve.totalBorrowsVariable,\n            reserve.currentAverageStableBorrowRate\n        );\n\n        reserve.currentLiquidityRate = newLiquidityRate;\n        reserve.currentStableBorrowRate = newStableRate;\n        reserve.currentVariableBorrowRate = newVariableRate;\n\n        //solium-disable-next-line\n        reserve.lastUpdateTimestamp = uint40(block.timestamp);\n\n        emit ReserveUpdated(\n            _reserve,\n            newLiquidityRate,\n            newStableRate,\n            newVariableRate,\n            reserve.lastLiquidityCumulativeIndex,\n            reserve.lastVariableBorrowCumulativeIndex\n        );\n    }\n\n    /\n    * @dev transfers to the protocol fees of a flashloan to the fees collection address\n    * @param _token the address of the token being transferred\n    * @param _amount the amount being transferred\n    /\n\n    function transferFlashLoanProtocolFeeInternal(address _token, uint256 _amount) internal {\n        address payable receiver = address(uint160(addressesProvider.getTokenDistributor()));\n\n        if (_token != EthAddressLib.ethAddress()) {\n            ERC20(_token).safeTransfer(receiver, _amount);\n        } else {\n            receiver.transfer(_amount);\n        }\n    }\n\n    /\n    * @dev updates the internal configuration of the core\n    /\n    function refreshConfigInternal() internal {\n        lendingPoolAddress = addressesProvider.getLendingPool();\n    }\n\n    /\n    * @dev adds a reserve to the array of the reserves address\n    /\n    function addReserveToListInternal(address _reserve) internal {\n        bool reserveAlreadyAdded = false;\n        for (uint256 i = 0; i &lt; reservesList.length; i++)\n            if (reservesList[i] == _reserve) {\n                reserveAlreadyAdded = true;\n            }\n        if (!reserveAlreadyAdded) reservesList.push(_reserve);\n    }\n\n}\n'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 04:31:12 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **task_prompt** | pragma solidity ^0.5.0; import "openzeppelin-solidity/contracts/math/SafeMath.sol"; import "openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol"; import "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol"; import "openzeppelin-solidity/contracts/utils/Address.sol"; import "../libraries/openzeppelin-upgradeability/VersionedInitializable.sol"; import "../libraries/CoreLibrary.sol"; import "../configuration/LendingPoolAddressesProvider.sol"; import "../interfaces/ILendingRateOracle.sol"; import "../interfaces/IReserveInterestRateStrategy.sol"; import "../libraries/WadRayMath.sol"; import "../tokenization/AToken.sol"; import "../libraries/EthAddressLib.sol"; / * @title LendingPoolCore contract * @author Aave * @notice Holds the state of the lending pool and all the funds deposited * @dev NOTE: The core does not enforce security checks on the update of the state * (eg, updateStateOnBorrow() does not enforce that borrowed is enabled on the reserve). * The check that an action can be performed is a duty of the overlying LendingPool contract. / contract LendingPoolCore is VersionedInitializable {     using SafeMath for uint256;     using WadRayMath for uint256;     using CoreLibrary for CoreLibrary.ReserveData;     using CoreLibrary for CoreLibrary.UserReserveData;     using SafeERC20 for ERC20;     using Address for address payable; /** * @dev Emitted when the state of a reserve is updated * @param reserve the address of the reserve * @param liquidityRate the new liquidity rate * @param stableBorrowRate the new stable borrow rate * @param variableBorrowRate the new variable borrow rate * @param liquidityIndex the new liquidity index * @param variableBorrowIndex the new variable borrow index **/ event ReserveUpdated(     address indexed reserve,     uint256 liquidityRate,     uint256 stableBorrowRate,     uint256 variableBorrowRate,     uint256 liquidityIndex,     uint256 variableBorrowIndex );  address public lendingPoolAddress;  LendingPoolAddressesProvider public addressesProvider;  /** * @dev only lending pools can use functions affected by this modifier **/ modifier onlyLendingPool {     require(lendingPoolAddress == msg.sender, "The caller must be a lending pool contract");     _; }  /** * @dev only lending pools configurator can use functions affected by this modifier **/ modifier onlyLendingPoolConfigurator {     require(         addressesProvider.getLendingPoolConfigurator() == msg.sender,         "The caller must be a lending pool configurator contract"     );     _; }  mapping(address =&gt; CoreLibrary.ReserveData) internal reserves; mapping(address =&gt; mapping(address =&gt; CoreLibrary.UserReserveData)) internal usersReserveData;  address[] public reservesList;  uint256 public constant CORE_REVISION = 0x4;  /** * @dev returns the revision number of the contract **/ function getRevision() internal pure returns (uint256) {     return CORE_REVISION; }  /** * @dev initializes the Core contract, invoked upon registration on the AddressesProvider * @param _addressesProvider the addressesProvider contract **/  function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {     addressesProvider = _addressesProvider;     refreshConfigInternal(); }  /** * @dev updates the state of the core as a result of a deposit action * @param _reserve the address of the reserve in which the deposit is happening * @param _user the address of the the user depositing * @param _amount the amount being deposited * @param _isFirstDeposit true if the user is depositing for the first time **/  function updateStateOnDeposit(     address _reserve,     address _user,     uint256 _amount,     bool _isFirstDeposit ) external onlyLendingPool {     reserves[_reserve].updateCumulativeIndexes();     updateReserveInterestRatesAndTimestampInternal(_reserve, _amount, 0);      if (_isFirstDeposit) {         //if this is the first deposit of the user, we configure the deposit as enabled to be used as collateral         setUserUseReserveAsCollateral(_reserve, _user, true);     } }  /** * @dev updates the state of the core as a result of a redeem action * @param _reserve the address of the reserve in which the redeem is happening * @param _user the address of the the user redeeming * @param _amountRedeemed the amount being redeemed * @param _userRedeemedEverything true if the user is redeeming everything **/ function updateStateOnRedeem(     address _reserve,     address _user,     uint256 _amountRedeemed,     bool _userRedeemedEverything ) external onlyLendingPool {     //compound liquidity and variable borrow interests     reserves[_reserve].updateCumulativeIndexes();     updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountRedeemed);      //if user redeemed everything the useReserveAsCollateral flag is reset     if (_userRedeemedEverything) {         setUserUseReserveAsCollateral(_reserve, _user, false);     } }  /** * @dev updates the state of the core as a result of a flashloan action * @param _reserve the address of the reserve in which the flashloan is happening * @param _income the income of the protocol as a result of the action **/ function updateStateOnFlashLoan(     address _reserve,     uint256 _availableLiquidityBefore,     uint256 _income,     uint256 _protocolFee ) external onlyLendingPool {     transferFlashLoanProtocolFeeInternal(_reserve, _protocolFee);      //compounding the cumulated interest     reserves[_reserve].updateCumulativeIndexes();      uint256 totalLiquidityBefore = _availableLiquidityBefore.add(         getReserveTotalBorrows(_reserve)     );      //compounding the received fee into the reserve     reserves[_reserve].cumulateToLiquidityIndex(totalLiquidityBefore, _income);      //refresh interest rates     updateReserveInterestRatesAndTimestampInternal(_reserve, _income, 0); }  /** * @dev updates the state of the core as a consequence of a borrow action. * @param _reserve the address of the reserve on which the user is borrowing * @param _user the address of the borrower * @param _amountBorrowed the new amount borrowed * @param _borrowFee the fee on the amount borrowed * @param _rateMode the borrow rate mode (stable, variable) * @return the new borrow rate for the user **/ function updateStateOnBorrow(     address _reserve,     address _user,     uint256 _amountBorrowed,     uint256 _borrowFee,     CoreLibrary.InterestRateMode _rateMode ) external onlyLendingPool returns (uint256, uint256) {     // getting the previous borrow data of the user     (uint256 principalBorrowBalance, , uint256 balanceIncrease) = getUserBorrowBalances(         _reserve,         _user     );      updateReserveStateOnBorrowInternal(         _reserve,         _user,         principalBorrowBalance,         balanceIncrease,         _amountBorrowed,         _rateMode     );      updateUserStateOnBorrowInternal(         _reserve,         _user,         _amountBorrowed,         balanceIncrease,         _borrowFee,         _rateMode     );      updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountBorrowed);      return (getUserCurrentBorrowRate(_reserve, _user), balanceIncrease); }  /** * @dev updates the state of the core as a consequence of a repay action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _paybackAmountMinusFees the amount being paid back minus fees * @param _originationFeeRepaid the fee on the amount that is being repaid * @param _balanceIncrease the accrued interest on the borrowed amount * @param _repaidWholeLoan true if the user is repaying the whole loan **/  function updateStateOnRepay(     address _reserve,     address _user,     uint256 _paybackAmountMinusFees,     uint256 _originationFeeRepaid,     uint256 _balanceIncrease,     bool _repaidWholeLoan ) external onlyLendingPool {     updateReserveStateOnRepayInternal(         _reserve,         _user,         _paybackAmountMinusFees,         _balanceIncrease     );     updateUserStateOnRepayInternal(         _reserve,         _user,         _paybackAmountMinusFees,         _originationFeeRepaid,         _balanceIncrease,         _repaidWholeLoan     );      updateReserveInterestRatesAndTimestampInternal(_reserve, _paybackAmountMinusFees, 0); }  /** * @dev updates the state of the core as a consequence of a swap rate action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _principalBorrowBalance the amount borrowed by the user * @param _compoundedBorrowBalance the amount borrowed plus accrued interest * @param _balanceIncrease the accrued interest on the borrowed amount * @param _currentRateMode the current interest rate mode for the user **/ function updateStateOnSwapRate(     address _reserve,     address _user,     uint256 _principalBorrowBalance,     uint256 _compoundedBorrowBalance,     uint256 _balanceIncrease,     CoreLibrary.InterestRateMode _currentRateMode ) external onlyLendingPool returns (CoreLibrary.InterestRateMode, uint256) {     updateReserveStateOnSwapRateInternal(         _reserve,         _user,         _principalBorrowBalance,         _compoundedBorrowBalance,         _currentRateMode     );      CoreLibrary.InterestRateMode newRateMode = updateUserStateOnSwapRateInternal(         _reserve,         _user,         _balanceIncrease,         _currentRateMode     );      updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);      return (newRateMode, getUserCurrentBorrowRate(_reserve, _user)); }  /** * @dev updates the state of the core as a consequence of a liquidation action. * @param _principalReserve the address of the principal reserve that is being repaid * @param _collateralReserve the address of the collateral reserve that is being liquidated * @param _user the address of the borrower * @param _amountToLiquidate the amount being repaid by the liquidator * @param _collateralToLiquidate the amount of collateral being liquidated * @param _feeLiquidated the amount of origination fee being liquidated * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus * @param _balanceIncrease the accrued interest on the borrowed amount * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise **/ function updateStateOnLiquidation(     address _principalReserve,     address _collateralReserve,     address _user,     uint256 _amountToLiquidate,     uint256 _collateralToLiquidate,     uint256 _feeLiquidated,     uint256 _liquidatedCollateralForFee,     uint256 _balanceIncrease,     bool _liquidatorReceivesAToken ) external onlyLendingPool {     updatePrincipalReserveStateOnLiquidationInternal(         _principalReserve,         _user,         _amountToLiquidate,         _balanceIncrease     );      updateCollateralReserveStateOnLiquidationInternal(         _collateralReserve     );      updateUserStateOnLiquidationInternal(         _principalReserve,         _user,         _amountToLiquidate,         _feeLiquidated,         _balanceIncrease     );      updateReserveInterestRatesAndTimestampInternal(_principalReserve, _amountToLiquidate, 0);      if (!_liquidatorReceivesAToken) {         updateReserveInterestRatesAndTimestampInternal(             _collateralReserve,             0,             _collateralToLiquidate.add(_liquidatedCollateralForFee)         );     }  }  /** * @dev updates the state of the core as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount * @return the new stable rate for the user **/ function updateStateOnRebalance(address _reserve, address _user, uint256 _balanceIncrease) external onlyLendingPool returns (uint256) {     updateReserveStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);      //update user data and rebalance the rate     updateUserStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);     updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);     return usersReserveData[_user][_reserve].stableBorrowRate; }  /** * @dev enables or disables a reserve as collateral * @param _reserve the address of the principal reserve where the user deposited * @param _user the address of the depositor * @param _useAsCollateral true if the depositor wants to use the reserve as collateral **/ function setUserUseReserveAsCollateral(address _reserve, address _user, bool _useAsCollateral) public onlyLendingPool {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     user.useAsCollateral = _useAsCollateral; }  /** * @notice ETH/token transfer functions **/  /** * @dev fallback function enforces that the caller is a contract, to support flashloan transfers **/ function() external payable {     //only contracts can send ETH to the core     require(msg.sender.isContract(), "Only contracts can send ether to the Lending pool core");  }  /** * @dev transfers to the user a specific amount from the reserve. * @param _reserve the address of the reserve where the transfer is happening * @param _user the address of the user receiving the transfer * @param _amount the amount being transferred **/ function transferToUser(address _reserve, address payable _user, uint256 _amount) external onlyLendingPool {     if (_reserve != EthAddressLib.ethAddress()) {         ERC20(_reserve).safeTransfer(_user, _amount);     } else {         //solium-disable-next-line         (bool result, ) = _user.call.value(_amount).gas(50000)("");         require(result, "Transfer of ETH failed");     } }  /** * @dev transfers the protocol fees to the fees collection address * @param _token the address of the token being transferred * @param _user the address of the user from where the transfer is happening * @param _amount the amount being transferred * @param _destination the fee receiver address **/  function transferToFeeCollectionAddress(     address _token,     address _user,     uint256 _amount,     address _destination ) external payable onlyLendingPool {     address payable feeAddress = address(uint160(_destination)); //cast the address to payable      if (_token != EthAddressLib.ethAddress()) {         require(             msg.value == 0,             "User is sending ETH along with the ERC20 transfer. Check the value attribute of the transaction"         );         ERC20(_token).safeTransferFrom(_user, feeAddress, _amount);     } else {         require(msg.value &gt;= _amount, "The amount and the value sent to deposit do not match");         //solium-disable-next-line         (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");         require(result, "Transfer of ETH failed");     } }  /** * @dev transfers the fees to the fees collection address in the case of liquidation * @param _token the address of the token being transferred * @param _amount the amount being transferred * @param _destination the fee receiver address **/ function liquidateFee(     address _token,     uint256 _amount,     address _destination ) external payable onlyLendingPool {     address payable feeAddress = address(uint160(_destination)); //cast the address to payable     require(         msg.value == 0,         "Fee liquidation does not require any transfer of value"     );      if (_token != EthAddressLib.ethAddress()) {         ERC20(_token).safeTransfer(feeAddress, _amount);     } else {         //solium-disable-next-line         (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");         require(result, "Transfer of ETH failed");     } }  /** * @dev transfers an amount from a user to the destination reserve * @param _reserve the address of the reserve where the amount is being transferred * @param _user the address of the user from where the transfer is happening * @param _amount the amount being transferred **/ function transferToReserve(address _reserve, address payable _user, uint256 _amount) external payable onlyLendingPool {     if (_reserve != EthAddressLib.ethAddress()) {         require(msg.value == 0, "User is sending ETH along with the ERC20 transfer.");         ERC20(_reserve).safeTransferFrom(_user, address(this), _amount);      } else {         require(msg.value &gt;= _amount, "The amount and the value sent to deposit do not match");          if (msg.value &gt; _amount) {             //send back excess ETH             uint256 excessAmount = msg.value.sub(_amount);             //solium-disable-next-line             (bool result, ) = _user.call.value(excessAmount).gas(50000)("");             require(result, "Transfer of ETH failed");         }     } }  /** * @notice data access functions **/  /** * @dev returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral) * needed to calculate the global account data in the LendingPoolDataProvider * @param _reserve the address of the reserve * @param _user the address of the user * @return the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not **/ function getUserBasicReserveData(address _reserve, address _user) external view returns (uint256, uint256, uint256, bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      uint256 underlyingBalance = getUserUnderlyingAssetBalance(_reserve, _user);      if (user.principalBorrowBalance == 0) {         return (underlyingBalance, 0, 0, user.useAsCollateral);     }      return (     underlyingBalance,     user.getCompoundedBorrowBalance(reserve),     user.originationFee,     user.useAsCollateral     ); }  /** * @dev checks if a user is allowed to borrow at a stable rate * @param _reserve the reserve address * @param _user the user * @param _amount the amount the the user wants to borrow * @return true if the user is allowed to borrow at a stable rate, false otherwise **/  function isUserAllowedToBorrowAtStable(address _reserve, address _user, uint256 _amount) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      if (!reserve.isStableBorrowRateEnabled) return false;      return     !user.useAsCollateral ||     !reserve.usageAsCollateralEnabled ||     _amount &gt; getUserUnderlyingAssetBalance(_reserve, _user); }  /** * @dev gets the underlying asset balance of a user based on the corresponding aToken balance. * @param _reserve the reserve address * @param _user the user address * @return the underlying deposit balance of the user **/  function getUserUnderlyingAssetBalance(address _reserve, address _user) public view returns (uint256) {     AToken aToken = AToken(reserves[_reserve].aTokenAddress);     return aToken.balanceOf(_user);  }  /** * @dev gets the interest rate strategy contract address for the reserve * @param _reserve the reserve address * @return the address of the interest rate strategy contract **/ function getReserveInterestRateStrategyAddress(address _reserve) public view returns (address) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.interestRateStrategyAddress; }  /** * @dev gets the aToken contract address for the reserve * @param _reserve the reserve address * @return the address of the aToken contract **/  function getReserveATokenAddress(address _reserve) public view returns (address) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.aTokenAddress; }  /** * @dev gets the available liquidity in the reserve. The available liquidity is the balance of the core contract * @param _reserve the reserve address * @return the available liquidity **/ function getReserveAvailableLiquidity(address _reserve) public view returns (uint256) {     uint256 balance = 0;      if (_reserve == EthAddressLib.ethAddress()) {         balance = address(this).balance;     } else {         balance = IERC20(_reserve).balanceOf(address(this));     }     return balance; }  /** * @dev gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows * @param _reserve the reserve address * @return the total liquidity **/ function getReserveTotalLiquidity(address _reserve) public view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return getReserveAvailableLiquidity(_reserve).add(reserve.getTotalBorrows()); }  /** * @dev gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there * there has been 100% income. * @param _reserve the reserve address * @return the reserve normalized income **/ function getReserveNormalizedIncome(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.getNormalizedIncome(); }  /** * @dev gets the reserve total borrows * @param _reserve the reserve address * @return the total borrows (stable + variable) **/ function getReserveTotalBorrows(address _reserve) public view returns (uint256) {     return reserves[_reserve].getTotalBorrows(); }  /** * @dev gets the reserve total borrows stable * @param _reserve the reserve address * @return the total borrows stable **/ function getReserveTotalBorrowsStable(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.totalBorrowsStable; }  /** * @dev gets the reserve total borrows variable * @param _reserve the reserve address * @return the total borrows variable **/  function getReserveTotalBorrowsVariable(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.totalBorrowsVariable; }  /** * @dev gets the reserve liquidation threshold * @param _reserve the reserve address * @return the reserve liquidation threshold **/  function getReserveLiquidationThreshold(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.liquidationThreshold; }  /** * @dev gets the reserve liquidation bonus * @param _reserve the reserve address * @return the reserve liquidation bonus **/  function getReserveLiquidationBonus(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.liquidationBonus; }  /** * @dev gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty * @param _reserve the reserve address * @return the reserve current variable borrow rate **/  function getReserveCurrentVariableBorrowRate(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      if (reserve.currentVariableBorrowRate == 0) {         return         IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)         .getBaseVariableBorrowRate();     }     return reserve.currentVariableBorrowRate; }  /** * @dev gets the reserve current stable borrow rate. Is the market rate if the reserve is empty * @param _reserve the reserve address * @return the reserve current stable borrow rate **/  function getReserveCurrentStableBorrowRate(address _reserve) public view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     ILendingRateOracle oracle = ILendingRateOracle(addressesProvider.getLendingRateOracle());      if (reserve.currentStableBorrowRate == 0) {         //no stable rate borrows yet         return oracle.getMarketBorrowRate(_reserve);     }      return reserve.currentStableBorrowRate; }  /** * @dev gets the reserve average stable borrow rate. The average stable rate is the weighted average * of all the loans taken at stable rate. * @param _reserve the reserve address * @return the reserve current average borrow rate **/ function getReserveCurrentAverageStableBorrowRate(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.currentAverageStableBorrowRate; }  /** * @dev gets the reserve liquidity rate * @param _reserve the reserve address * @return the reserve liquidity rate **/ function getReserveCurrentLiquidityRate(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.currentLiquidityRate; }  /** * @dev gets the reserve liquidity cumulative index * @param _reserve the reserve address * @return the reserve liquidity cumulative index **/ function getReserveLiquidityCumulativeIndex(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.lastLiquidityCumulativeIndex; }  /** * @dev gets the reserve variable borrow index * @param _reserve the reserve address * @return the reserve variable borrow index **/ function getReserveVariableBorrowsCumulativeIndex(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.lastVariableBorrowCumulativeIndex; }  /** * @dev this function aggregates the configuration parameters of the reserve. * It's used in the LendingPoolDataProvider specifically to save gas, and avoid * multiple external contract calls to fetch the same data. * @param _reserve the reserve address * @return the reserve decimals * @return the base ltv as collateral * @return the liquidation threshold * @return if the reserve is used as collateral or not **/ function getReserveConfiguration(address _reserve) external view returns (uint256, uint256, uint256, bool) {     uint256 decimals;     uint256 baseLTVasCollateral;     uint256 liquidationThreshold;     bool usageAsCollateralEnabled;      CoreLibrary.ReserveData storage reserve = reserves[_reserve];     decimals = reserve.decimals;     baseLTVasCollateral = reserve.baseLTVasCollateral;     liquidationThreshold = reserve.liquidationThreshold;     usageAsCollateralEnabled = reserve.usageAsCollateralEnabled;      return (decimals, baseLTVasCollateral, liquidationThreshold, usageAsCollateralEnabled); }  /** * @dev returns the decimals of the reserve * @param _reserve the reserve address * @return the reserve decimals **/ function getReserveDecimals(address _reserve) external view returns (uint256) {     return reserves[_reserve].decimals; }  /** * @dev returns true if the reserve is enabled for borrowing * @param _reserve the reserve address * @return true if the reserve is enabled for borrowing, false otherwise **/  function isReserveBorrowingEnabled(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.borrowingEnabled; }  /** * @dev returns true if the reserve is enabled as collateral * @param _reserve the reserve address * @return true if the reserve is enabled as collateral, false otherwise **/  function isReserveUsageAsCollateralEnabled(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.usageAsCollateralEnabled; }  /** * @dev returns true if the stable rate is enabled on reserve * @param _reserve the reserve address * @return true if the stable rate is enabled on reserve, false otherwise **/ function getReserveIsStableBorrowRateEnabled(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.isStableBorrowRateEnabled; }  /** * @dev returns true if the reserve is active * @param _reserve the reserve address * @return true if the reserve is active, false otherwise **/ function getReserveIsActive(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.isActive; }  /** * @notice returns if a reserve is freezed * @param _reserve the reserve for which the information is needed * @return true if the reserve is freezed, false otherwise **/  function getReserveIsFreezed(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.isFreezed; }  /** * @notice returns the timestamp of the last action on the reserve * @param _reserve the reserve for which the information is needed * @return the last updated timestamp of the reserve **/  function getReserveLastUpdate(address _reserve) external view returns (uint40 timestamp) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     timestamp = reserve.lastUpdateTimestamp; }  /** * @dev returns the utilization rate U of a specific reserve * @param _reserve the reserve for which the information is needed * @return the utilization rate in ray **/  function getReserveUtilizationRate(address _reserve) public view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      uint256 totalBorrows = reserve.getTotalBorrows();      if (totalBorrows == 0) {         return 0;     }      uint256 availableLiquidity = getReserveAvailableLiquidity(_reserve);      return totalBorrows.rayDiv(availableLiquidity.add(totalBorrows)); }  /** * @return the array of reserves configured on the core **/ function getReserves() external view returns (address[] memory) {     return reservesList; }  /** * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return true if the user has chosen to use the reserve as collateral, false otherwise **/ function isUserUseReserveAsCollateralEnabled(address _reserve, address _user) external view returns (bool) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.useAsCollateral; }  /** * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the origination fee for the user **/ function getUserOriginationFee(address _reserve, address _user) external view returns (uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.originationFee; }  /** * @dev users with no loans in progress have NONE as borrow rate mode * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the borrow rate mode for the user, **/  function getUserCurrentBorrowRateMode(address _reserve, address _user) public view returns (CoreLibrary.InterestRateMode) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      if (user.principalBorrowBalance == 0) {         return CoreLibrary.InterestRateMode.NONE;     }      return     user.stableBorrowRate &gt; 0     ? CoreLibrary.InterestRateMode.STABLE     : CoreLibrary.InterestRateMode.VARIABLE; }  /** * @dev gets the current borrow rate of the user * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the borrow rate for the user, **/ function getUserCurrentBorrowRate(address _reserve, address _user) internal view returns (uint256) {     CoreLibrary.InterestRateMode rateMode = getUserCurrentBorrowRateMode(_reserve, _user);      if (rateMode == CoreLibrary.InterestRateMode.NONE) {         return 0;     }      return     rateMode == CoreLibrary.InterestRateMode.STABLE     ? usersReserveData[_user][_reserve].stableBorrowRate     : reserves[_reserve].currentVariableBorrowRate; }  /** * @dev the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the user stable rate **/ function getUserCurrentStableBorrowRate(address _reserve, address _user) external view returns (uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.stableBorrowRate; }  /** * @dev calculates and returns the borrow balances of the user * @param _reserve the address of the reserve * @param _user the address of the user * @return the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance **/  function getUserBorrowBalances(address _reserve, address _user) public view returns (uint256, uint256, uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     if (user.principalBorrowBalance == 0) {         return (0, 0, 0);     }      uint256 principal = user.principalBorrowBalance;     uint256 compoundedBalance = CoreLibrary.getCompoundedBorrowBalance(         user,         reserves[_reserve]     );     return (principal, compoundedBalance, compoundedBalance.sub(principal)); }  /** * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the variable borrow index for the user **/  function getUserVariableBorrowCumulativeIndex(address _reserve, address _user) external view returns (uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.lastVariableBorrowCumulativeIndex; }  /** * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the variable borrow index for the user **/  function getUserLastUpdate(address _reserve, address _user) external view returns (uint256 timestamp) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     timestamp = user.lastUpdateTimestamp; }  /** * @dev updates the lending pool core configuration **/ function refreshConfiguration() external onlyLendingPoolConfigurator {     refreshConfigInternal(); }  /** * @dev initializes a reserve * @param _reserve the address of the reserve * @param _aTokenAddress the address of the overlying aToken contract * @param _decimals the decimals of the reserve currency * @param _interestRateStrategyAddress the address of the interest rate strategy contract **/ function initReserve(     address _reserve,     address _aTokenAddress,     uint256 _decimals,     address _interestRateStrategyAddress ) external onlyLendingPoolConfigurator {     reserves[_reserve].init(_aTokenAddress, _decimals, _interestRateStrategyAddress);     addReserveToListInternal(_reserve);  }    /** * @dev removes the last added reserve in the reservesList array * @param _reserveToRemove the address of the reserve **/ function removeLastAddedReserve(address _reserveToRemove) external onlyLendingPoolConfigurator {      address lastReserve = reservesList[reservesList.length-1];      require(lastReserve == _reserveToRemove, "Reserve being removed is different than the reserve requested");      //as we can't check if totalLiquidity is 0 (since the reserve added might not be an ERC20) we at least check that there is nothing borrowed     require(getReserveTotalBorrows(lastReserve) == 0, "Cannot remove a reserve with liquidity deposited");      reserves[lastReserve].isActive = false;     reserves[lastReserve].aTokenAddress = address(0);     reserves[lastReserve].decimals = 0;     reserves[lastReserve].lastLiquidityCumulativeIndex = 0;     reserves[lastReserve].lastVariableBorrowCumulativeIndex = 0;     reserves[lastReserve].borrowingEnabled = false;     reserves[lastReserve].usageAsCollateralEnabled = false;     reserves[lastReserve].baseLTVasCollateral = 0;     reserves[lastReserve].liquidationThreshold = 0;     reserves[lastReserve].liquidationBonus = 0;     reserves[lastReserve].interestRateStrategyAddress = address(0);      reservesList.pop(); }  /** * @dev updates the address of the interest rate strategy contract * @param _reserve the address of the reserve * @param _rateStrategyAddress the address of the interest rate strategy contract **/  function setReserveInterestRateStrategyAddress(address _reserve, address _rateStrategyAddress) external onlyLendingPoolConfigurator {     reserves[_reserve].interestRateStrategyAddress = _rateStrategyAddress; }  /** * @dev enables borrowing on a reserve. Also sets the stable rate borrowing * @param _reserve the address of the reserve * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise **/  function enableBorrowingOnReserve(address _reserve, bool _stableBorrowRateEnabled) external onlyLendingPoolConfigurator {     reserves[_reserve].enableBorrowing(_stableBorrowRateEnabled); }  /** * @dev disables borrowing on a reserve * @param _reserve the address of the reserve **/  function disableBorrowingOnReserve(address _reserve) external onlyLendingPoolConfigurator {     reserves[_reserve].disableBorrowing(); }  /** * @dev enables a reserve to be used as collateral * @param _reserve the address of the reserve **/ function enableReserveAsCollateral(     address _reserve,     uint256 _baseLTVasCollateral,     uint256 _liquidationThreshold,     uint256 _liquidationBonus ) external onlyLendingPoolConfigurator {     reserves[_reserve].enableAsCollateral(         _baseLTVasCollateral,         _liquidationThreshold,         _liquidationBonus     ); }  /** * @dev disables a reserve to be used as collateral * @param _reserve the address of the reserve **/ function disableReserveAsCollateral(address _reserve) external onlyLendingPoolConfigurator {     reserves[_reserve].disableAsCollateral(); }  /** * @dev enable the stable borrow rate mode on a reserve * @param _reserve the address of the reserve **/ function enableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isStableBorrowRateEnabled = true; }  /** * @dev disable the stable borrow rate mode on a reserve * @param _reserve the address of the reserve **/ function disableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isStableBorrowRateEnabled = false; }  /** * @dev activates a reserve * @param _reserve the address of the reserve **/ function activateReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      require(         reserve.lastLiquidityCumulativeIndex &gt; 0 &amp;&amp;         reserve.lastVariableBorrowCumulativeIndex &gt; 0,         "Reserve has not been initialized yet"     );     reserve.isActive = true; }  /** * @dev deactivates a reserve * @param _reserve the address of the reserve **/ function deactivateReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isActive = false; }  /** * @notice allows the configurator to freeze the reserve. * A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance. * @param _reserve the address of the reserve **/ function freezeReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isFreezed = true; }  /** * @notice allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed. * @param _reserve the address of the reserve **/ function unfreezeReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isFreezed = false; }  /** * @notice allows the configurator to update the loan to value of a reserve * @param _reserve the address of the reserve * @param _ltv the new loan to value **/ function setReserveBaseLTVasCollateral(address _reserve, uint256 _ltv) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.baseLTVasCollateral = _ltv; }  /** * @notice allows the configurator to update the liquidation threshold of a reserve * @param _reserve the address of the reserve * @param _threshold the new liquidation threshold **/ function setReserveLiquidationThreshold(address _reserve, uint256 _threshold) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.liquidationThreshold = _threshold; }  /** * @notice allows the configurator to update the liquidation bonus of a reserve * @param _reserve the address of the reserve * @param _bonus the new liquidation bonus **/ function setReserveLiquidationBonus(address _reserve, uint256 _bonus) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.liquidationBonus = _bonus; }  /** * @notice allows the configurator to update the reserve decimals * @param _reserve the address of the reserve * @param _decimals the decimals of the reserve **/ function setReserveDecimals(address _reserve, uint256 _decimals) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.decimals = _decimals; }  /** * @notice internal functions **/  /** * @dev updates the state of a reserve as a consequence of a borrow action. * @param _reserve the address of the reserve on which the user is borrowing * @param _user the address of the borrower * @param _principalBorrowBalance the previous borrow balance of the borrower before the action * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount * @param _amountBorrowed the new amount borrowed * @param _rateMode the borrow rate mode (stable, variable) **/  function updateReserveStateOnBorrowInternal(     address _reserve,     address _user,     uint256 _principalBorrowBalance,     uint256 _balanceIncrease,     uint256 _amountBorrowed,     CoreLibrary.InterestRateMode _rateMode ) internal {     reserves[_reserve].updateCumulativeIndexes();      //increasing reserve total borrows to account for the new borrow balance of the user     //NOTE: Depending on the previous borrow mode, the borrows might need to be switched from variable to stable or vice versa      updateReserveTotalBorrowsByRateModeInternal(         _reserve,         _user,         _principalBorrowBalance,         _balanceIncrease,         _amountBorrowed,         _rateMode     ); }  /** * @dev updates the state of a user as a consequence of a borrow action. * @param _reserve the address of the reserve on which the user is borrowing * @param _user the address of the borrower * @param _amountBorrowed the amount borrowed * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount * @param _rateMode the borrow rate mode (stable, variable) * @return the final borrow rate for the user. Emitted by the borrow() event **/  function updateUserStateOnBorrowInternal(     address _reserve,     address _user,     uint256 _amountBorrowed,     uint256 _balanceIncrease,     uint256 _fee,     CoreLibrary.InterestRateMode _rateMode ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      if (_rateMode == CoreLibrary.InterestRateMode.STABLE) {         //stable         //reset the user variable index, and update the stable rate         user.stableBorrowRate = reserve.currentStableBorrowRate;         user.lastVariableBorrowCumulativeIndex = 0;     } else if (_rateMode == CoreLibrary.InterestRateMode.VARIABLE) {         //variable         //reset the user stable rate, and store the new borrow index         user.stableBorrowRate = 0;         user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;     } else {         revert("Invalid borrow rate mode");     }     //increase the principal borrows and the origination fee     user.principalBorrowBalance = user.principalBorrowBalance.add(_amountBorrowed).add(         _balanceIncrease     );     user.originationFee = user.originationFee.add(_fee);      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp);  }  /** * @dev updates the state of the reserve as a consequence of a repay action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _paybackAmountMinusFees the amount being paid back minus fees * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updateReserveStateOnRepayInternal(     address _reserve,     address _user,     uint256 _paybackAmountMinusFees,     uint256 _balanceIncrease ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_reserve][_user];      CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(_reserve, _user);      //update the indexes     reserves[_reserve].updateCumulativeIndexes();      //compound the cumulated interest to the borrow balance and then subtracting the payback amount     if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             _balanceIncrease,             user.stableBorrowRate         );         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _paybackAmountMinusFees,             user.stableBorrowRate         );     } else {         reserve.increaseTotalBorrowsVariable(_balanceIncrease);         reserve.decreaseTotalBorrowsVariable(_paybackAmountMinusFees);     } }  /** * @dev updates the state of the user as a consequence of a repay action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _paybackAmountMinusFees the amount being paid back minus fees * @param _originationFeeRepaid the fee on the amount that is being repaid * @param _balanceIncrease the accrued interest on the borrowed amount * @param _repaidWholeLoan true if the user is repaying the whole loan **/ function updateUserStateOnRepayInternal(     address _reserve,     address _user,     uint256 _paybackAmountMinusFees,     uint256 _originationFeeRepaid,     uint256 _balanceIncrease,     bool _repaidWholeLoan ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      //update the user principal borrow balance, adding the cumulated interest and then subtracting the payback amount     user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(         _paybackAmountMinusFees     );     user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;      //if the balance decrease is equal to the previous principal (user is repaying the whole loan)     //and the rate mode is stable, we reset the interest rate mode of the user     if (_repaidWholeLoan) {         user.stableBorrowRate = 0;         user.lastVariableBorrowCumulativeIndex = 0;     }     user.originationFee = user.originationFee.sub(_originationFeeRepaid);      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp);  }  /** * @dev updates the state of the user as a consequence of a swap rate action. * @param _reserve the address of the reserve on which the user is performing the rate swap * @param _user the address of the borrower * @param _principalBorrowBalance the the principal amount borrowed by the user * @param _compoundedBorrowBalance the principal amount plus the accrued interest * @param _currentRateMode the rate mode at which the user borrowed **/ function updateReserveStateOnSwapRateInternal(     address _reserve,     address _user,     uint256 _principalBorrowBalance,     uint256 _compoundedBorrowBalance,     CoreLibrary.InterestRateMode _currentRateMode ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      //compounding reserve indexes     reserve.updateCumulativeIndexes();      if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {         uint256 userCurrentStableRate = user.stableBorrowRate;          //swap to variable         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _principalBorrowBalance,             userCurrentStableRate         ); //decreasing stable from old principal balance         reserve.increaseTotalBorrowsVariable(_compoundedBorrowBalance); //increase variable borrows     } else if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         //swap to stable         uint256 currentStableRate = reserve.currentStableBorrowRate;         reserve.decreaseTotalBorrowsVariable(_principalBorrowBalance);         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             _compoundedBorrowBalance,             currentStableRate         );      } else {         revert("Invalid rate mode received");     } }  /** * @dev updates the state of the user as a consequence of a swap rate action. * @param _reserve the address of the reserve on which the user is performing the swap * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount * @param _currentRateMode the current rate mode of the user **/  function updateUserStateOnSwapRateInternal(     address _reserve,     address _user,     uint256 _balanceIncrease,     CoreLibrary.InterestRateMode _currentRateMode ) internal returns (CoreLibrary.InterestRateMode) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      CoreLibrary.InterestRateMode newMode = CoreLibrary.InterestRateMode.NONE;      if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         //switch to stable         newMode = CoreLibrary.InterestRateMode.STABLE;         user.stableBorrowRate = reserve.currentStableBorrowRate;         user.lastVariableBorrowCumulativeIndex = 0;     } else if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {         newMode = CoreLibrary.InterestRateMode.VARIABLE;         user.stableBorrowRate = 0;         user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;     } else {         revert("Invalid interest rate mode received");     }     //compounding cumulated interest     user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);     //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp);      return newMode; }  /** * @dev updates the state of the principal reserve as a consequence of a liquidation action. * @param _principalReserve the address of the principal reserve that is being repaid * @param _user the address of the borrower * @param _amountToLiquidate the amount being repaid by the liquidator * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updatePrincipalReserveStateOnLiquidationInternal(     address _principalReserve,     address _user,     uint256 _amountToLiquidate,     uint256 _balanceIncrease ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_principalReserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_principalReserve];      //update principal reserve data     reserve.updateCumulativeIndexes();      CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(         _principalReserve,         _user     );      if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {         //increase the total borrows by the compounded interest         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             _balanceIncrease,             user.stableBorrowRate         );          //decrease by the actual amount to liquidate         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _amountToLiquidate,             user.stableBorrowRate         );      } else {         //increase the total borrows by the compounded interest         reserve.increaseTotalBorrowsVariable(_balanceIncrease);          //decrease by the actual amount to liquidate         reserve.decreaseTotalBorrowsVariable(_amountToLiquidate);     }  }  /** * @dev updates the state of the collateral reserve as a consequence of a liquidation action. * @param _collateralReserve the address of the collateral reserve that is being liquidated **/ function updateCollateralReserveStateOnLiquidationInternal(     address _collateralReserve ) internal {     //update collateral reserve     reserves[_collateralReserve].updateCumulativeIndexes();  }  /** * @dev updates the state of the user being liquidated as a consequence of a liquidation action. * @param _reserve the address of the principal reserve that is being repaid * @param _user the address of the borrower * @param _amountToLiquidate the amount being repaid by the liquidator * @param _feeLiquidated the amount of origination fee being liquidated * @param _balanceIncrease the accrued interest on the borrowed amount **/ function updateUserStateOnLiquidationInternal(     address _reserve,     address _user,     uint256 _amountToLiquidate,     uint256 _feeLiquidated,     uint256 _balanceIncrease ) internal {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     //first increase by the compounded interest, then decrease by the liquidated amount     user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(         _amountToLiquidate     );      if (         getUserCurrentBorrowRateMode(_reserve, _user) == CoreLibrary.InterestRateMode.VARIABLE     ) {         user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;     }      if(_feeLiquidated &gt; 0){         user.originationFee = user.originationFee.sub(_feeLiquidated);     }      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp); }  /** * @dev updates the state of the reserve as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updateReserveStateOnRebalanceInternal(     address _reserve,     address _user,     uint256 _balanceIncrease ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      reserve.updateCumulativeIndexes();      reserve.increaseTotalBorrowsStableAndUpdateAverageRate(         _balanceIncrease,         user.stableBorrowRate     );  }  /** * @dev updates the state of the user as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updateUserStateOnRebalanceInternal(     address _reserve,     address _user,     uint256 _balanceIncrease ) internal {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);     user.stableBorrowRate = reserve.currentStableBorrowRate;      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp); }  /** * @dev updates the state of the user as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount * @param _amountBorrowed the accrued interest on the borrowed amount **/ function updateReserveTotalBorrowsByRateModeInternal(     address _reserve,     address _user,     uint256 _principalBalance,     uint256 _balanceIncrease,     uint256 _amountBorrowed,     CoreLibrary.InterestRateMode _newBorrowRateMode ) internal {     CoreLibrary.InterestRateMode previousRateMode = getUserCurrentBorrowRateMode(         _reserve,         _user     );     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      if (previousRateMode == CoreLibrary.InterestRateMode.STABLE) {         CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _principalBalance,             user.stableBorrowRate         );     } else if (previousRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         reserve.decreaseTotalBorrowsVariable(_principalBalance);     }      uint256 newPrincipalAmount = _principalBalance.add(_balanceIncrease).add(_amountBorrowed);     if (_newBorrowRateMode == CoreLibrary.InterestRateMode.STABLE) {         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             newPrincipalAmount,             reserve.currentStableBorrowRate         );     } else if (_newBorrowRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         reserve.increaseTotalBorrowsVariable(newPrincipalAmount);     } else {         revert("Invalid new borrow rate mode");     } }  /** * @dev Updates the reserve current stable borrow rate Rf, the current variable borrow rate Rv and the current liquidity rate Rl. * Also updates the lastUpdateTimestamp value. Please refer to the whitepaper for further information. * @param _reserve the address of the reserve to be updated * @param _liquidityAdded the amount of liquidity added to the protocol (deposit or repay) in the previous action * @param _liquidityTaken the amount of liquidity taken from the protocol (redeem or borrow) **/  function updateReserveInterestRatesAndTimestampInternal(     address _reserve,     uint256 _liquidityAdded,     uint256 _liquidityTaken ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     (uint256 newLiquidityRate, uint256 newStableRate, uint256 newVariableRate) = IReserveInterestRateStrategy(         reserve         .interestRateStrategyAddress     )     .calculateInterestRates(         _reserve,         getReserveAvailableLiquidity(_reserve).add(_liquidityAdded).sub(_liquidityTaken),         reserve.totalBorrowsStable,         reserve.totalBorrowsVariable,         reserve.currentAverageStableBorrowRate     );      reserve.currentLiquidityRate = newLiquidityRate;     reserve.currentStableBorrowRate = newStableRate;     reserve.currentVariableBorrowRate = newVariableRate;      //solium-disable-next-line     reserve.lastUpdateTimestamp = uint40(block.timestamp);      emit ReserveUpdated(         _reserve,         newLiquidityRate,         newStableRate,         newVariableRate,         reserve.lastLiquidityCumulativeIndex,         reserve.lastVariableBorrowCumulativeIndex     ); }  /** * @dev transfers to the protocol fees of a flashloan to the fees collection address * @param _token the address of the token being transferred * @param _amount the amount being transferred **/  function transferFlashLoanProtocolFeeInternal(address _token, uint256 _amount) internal {     address payable receiver = address(uint160(addressesProvider.getTokenDistributor()));      if (_token != EthAddressLib.ethAddress()) {         ERC20(_token).safeTransfer(receiver, _amount);     } else {         receiver.transfer(_amount);     } }  /** * @dev updates the internal configuration of the core **/ function refreshConfigInternal() internal {     lendingPoolAddress = addressesProvider.getLendingPool(); }  /** * @dev adds a reserve to the array of the reserves address **/ function addReserveToListInternal(address _reserve) internal {     bool reserveAlreadyAdded = false;     for (uint256 i = 0; i &lt; reservesList.length; i++)         if (reservesList[i] == _reserve) {             reserveAlreadyAdded = true;         }     if (!reserveAlreadyAdded) reservesList.push(_reserve); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 04:31:12 INFO] Chief Executive Officer: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: pragma solidity ^0.5.0;

import "openzeppelin-solidity/contracts/math/SafeMath.sol";
import "openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol";
import "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol";
import "openzeppelin-solidity/contracts/utils/Address.sol";
import "../libraries/openzeppelin-upgradeability/VersionedInitializable.sol";

import "../libraries/CoreLibrary.sol";
import "../configuration/LendingPoolAddressesProvider.sol";
import "../interfaces/ILendingRateOracle.sol";
import "../interfaces/IReserveInterestRateStrategy.sol";
import "../libraries/WadRayMath.sol";
import "../tokenization/AToken.sol";
import "../libraries/EthAddressLib.sol";

/**
* @title LendingPoolCore contract
* @author Aave
* @notice Holds the state of the lending pool and all the funds deposited
* @dev NOTE: The core does not enforce security checks on the update of the state
* (eg, updateStateOnBorrow() does not enforce that borrowed is enabled on the reserve).
* The check that an action can be performed is a duty of the overlying LendingPool contract.
**/

contract LendingPoolCore is VersionedInitializable {
    using SafeMath for uint256;
    using WadRayMath for uint256;
    using CoreLibrary for CoreLibrary.ReserveData;
    using CoreLibrary for CoreLibrary.UserReserveData;
    using SafeERC20 for ERC20;
    using Address for address payable;

    /**
    * @dev Emitted when the state of a reserve is updated
    * @param reserve the address of the reserve
    * @param liquidityRate the new liquidity rate
    * @param stableBorrowRate the new stable borrow rate
    * @param variableBorrowRate the new variable borrow rate
    * @param liquidityIndex the new liquidity index
    * @param variableBorrowIndex the new variable borrow index
    **/
    event ReserveUpdated(
        address indexed reserve,
        uint256 liquidityRate,
        uint256 stableBorrowRate,
        uint256 variableBorrowRate,
        uint256 liquidityIndex,
        uint256 variableBorrowIndex
    );

    address public lendingPoolAddress;

    LendingPoolAddressesProvider public addressesProvider;

    /**
    * @dev only lending pools can use functions affected by this modifier
    **/
    modifier onlyLendingPool {
        require(lendingPoolAddress == msg.sender, "The caller must be a lending pool contract");
        _;
    }

    /**
    * @dev only lending pools configurator can use functions affected by this modifier
    **/
    modifier onlyLendingPoolConfigurator {
        require(
            addressesProvider.getLendingPoolConfigurator() == msg.sender,
            "The caller must be a lending pool configurator contract"
        );
        _;
    }

    mapping(address => CoreLibrary.ReserveData) internal reserves;
    mapping(address => mapping(address => CoreLibrary.UserReserveData)) internal usersReserveData;

    address[] public reservesList;

    uint256 public constant CORE_REVISION = 0x4;

    /**
    * @dev returns the revision number of the contract
    **/
    function getRevision() internal pure returns (uint256) {
        return CORE_REVISION;
    }

    /**
    * @dev initializes the Core contract, invoked upon registration on the AddressesProvider
    * @param _addressesProvider the addressesProvider contract
    **/

    function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {
        addressesProvider = _addressesProvider;
        refreshConfigInternal();
    }

    /**
    * @dev updates the state of the core as a result of a deposit action
    * @param _reserve the address of the reserve in which the deposit is happening
    * @param _user the address of the the user depositing
    * @param _amount the amount being deposited
    * @param _isFirstDeposit true if the user is depositing for the first time
    **/

    function updateStateOnDeposit(
        address _reserve,
        address _user,
        uint256 _amount,
        bool _isFirstDeposit
    ) external onlyLendingPool {
        reserves[_reserve].updateCumulativeIndexes();
        updateReserveInterestRatesAndTimestampInternal(_reserve, _amount, 0);

        if (_isFirstDeposit) {
            //if this is the first deposit of the user, we configure the deposit as enabled to be used as collateral
            setUserUseReserveAsCollateral(_reserve, _user, true);
        }
    }

    /**
    * @dev updates the state of the core as a result of a redeem action
    * @param _reserve the address of the reserve in which the redeem is happening
    * @param _user the address of the the user redeeming
    * @param _amountRedeemed the amount being redeemed
    * @param _userRedeemedEverything true if the user is redeeming everything
    **/
    function updateStateOnRedeem(
        address _reserve,
        address _user,
        uint256 _amountRedeemed,
        bool _userRedeemedEverything
    ) external onlyLendingPool {
        //compound liquidity and variable borrow interests
        reserves[_reserve].updateCumulativeIndexes();
        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountRedeemed);

        //if user redeemed everything the useReserveAsCollateral flag is reset
        if (_userRedeemedEverything) {
            setUserUseReserveAsCollateral(_reserve, _user, false);
        }
    }

    /**
    * @dev updates the state of the core as a result of a flashloan action
    * @param _reserve the address of the reserve in which the flashloan is happening
    * @param _income the income of the protocol as a result of the action
    **/
    function updateStateOnFlashLoan(
        address _reserve,
        uint256 _availableLiquidityBefore,
        uint256 _income,
        uint256 _protocolFee
    ) external onlyLendingPool {
        transferFlashLoanProtocolFeeInternal(_reserve, _protocolFee);

        //compounding the cumulated interest
        reserves[_reserve].updateCumulativeIndexes();

        uint256 totalLiquidityBefore = _availableLiquidityBefore.add(
            getReserveTotalBorrows(_reserve)
        );

        //compounding the received fee into the reserve
        reserves[_reserve].cumulateToLiquidityIndex(totalLiquidityBefore, _income);

        //refresh interest rates
        updateReserveInterestRatesAndTimestampInternal(_reserve, _income, 0);
    }

    /**
    * @dev updates the state of the core as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _amountBorrowed the new amount borrowed
    * @param _borrowFee the fee on the amount borrowed
    * @param _rateMode the borrow rate mode (stable, variable)
    * @return the new borrow rate for the user
    **/
    function updateStateOnBorrow(
        address _reserve,
        address _user,
        uint256 _amountBorrowed,
        uint256 _borrowFee,
        CoreLibrary.InterestRateMode _rateMode
    ) external onlyLendingPool returns (uint256, uint256) {
        // getting the previous borrow data of the user
        (uint256 principalBorrowBalance, , uint256 balanceIncrease) = getUserBorrowBalances(
            _reserve,
            _user
        );

        updateReserveStateOnBorrowInternal(
            _reserve,
            _user,
            principalBorrowBalance,
            balanceIncrease,
            _amountBorrowed,
            _rateMode
        );

        updateUserStateOnBorrowInternal(
            _reserve,
            _user,
            _amountBorrowed,
            balanceIncrease,
            _borrowFee,
            _rateMode
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountBorrowed);

        return (getUserCurrentBorrowRate(_reserve, _user), balanceIncrease);
    }

    /**
    * @dev updates the state of the core as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _originationFeeRepaid the fee on the amount that is being repaid
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _repaidWholeLoan true if the user is repaying the whole loan
    **/

    function updateStateOnRepay(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _originationFeeRepaid,
        uint256 _balanceIncrease,
        bool _repaidWholeLoan
    ) external onlyLendingPool {
        updateReserveStateOnRepayInternal(
            _reserve,
            _user,
            _paybackAmountMinusFees,
            _balanceIncrease
        );
        updateUserStateOnRepayInternal(
            _reserve,
            _user,
            _paybackAmountMinusFees,
            _originationFeeRepaid,
            _balanceIncrease,
            _repaidWholeLoan
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, _paybackAmountMinusFees, 0);
    }

    /**
    * @dev updates the state of the core as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the amount borrowed by the user
    * @param _compoundedBorrowBalance the amount borrowed plus accrued interest
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _currentRateMode the current interest rate mode for the user
    **/
    function updateStateOnSwapRate(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _compoundedBorrowBalance,
        uint256 _balanceIncrease,
        CoreLibrary.InterestRateMode _currentRateMode
    ) external onlyLendingPool returns (CoreLibrary.InterestRateMode, uint256) {
        updateReserveStateOnSwapRateInternal(
            _reserve,
            _user,
            _principalBorrowBalance,
            _compoundedBorrowBalance,
            _currentRateMode
        );

        CoreLibrary.InterestRateMode newRateMode = updateUserStateOnSwapRateInternal(
            _reserve,
            _user,
            _balanceIncrease,
            _currentRateMode
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);

        return (newRateMode, getUserCurrentBorrowRate(_reserve, _user));
    }

    /**
    * @dev updates the state of the core as a consequence of a liquidation action.
    * @param _principalReserve the address of the principal reserve that is being repaid
    * @param _collateralReserve the address of the collateral reserve that is being liquidated
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _collateralToLiquidate the amount of collateral being liquidated
    * @param _feeLiquidated the amount of origination fee being liquidated
    * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise
    **/
    function updateStateOnLiquidation(
        address _principalReserve,
        address _collateralReserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _collateralToLiquidate,
        uint256 _feeLiquidated,
        uint256 _liquidatedCollateralForFee,
        uint256 _balanceIncrease,
        bool _liquidatorReceivesAToken
    ) external onlyLendingPool {
        updatePrincipalReserveStateOnLiquidationInternal(
            _principalReserve,
            _user,
            _amountToLiquidate,
            _balanceIncrease
        );

        updateCollateralReserveStateOnLiquidationInternal(
            _collateralReserve
        );

        updateUserStateOnLiquidationInternal(
            _principalReserve,
            _user,
            _amountToLiquidate,
            _feeLiquidated,
            _balanceIncrease
        );

        updateReserveInterestRatesAndTimestampInternal(_principalReserve, _amountToLiquidate, 0);

        if (!_liquidatorReceivesAToken) {
            updateReserveInterestRatesAndTimestampInternal(
                _collateralReserve,
                0,
                _collateralToLiquidate.add(_liquidatedCollateralForFee)
            );
        }

    }

    /**
    * @dev updates the state of the core as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @return the new stable rate for the user
    **/
    function updateStateOnRebalance(address _reserve, address _user, uint256 _balanceIncrease)
    external
    onlyLendingPool
    returns (uint256)
    {
        updateReserveStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);

        //update user data and rebalance the rate
        updateUserStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);
        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);
        return usersReserveData[_user][_reserve].stableBorrowRate;
    }

    /**
    * @dev enables or disables a reserve as collateral
    * @param _reserve the address of the principal reserve where the user deposited
    * @param _user the address of the depositor
    * @param _useAsCollateral true if the depositor wants to use the reserve as collateral
    **/
    function setUserUseReserveAsCollateral(address _reserve, address _user, bool _useAsCollateral)
    public
    onlyLendingPool
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        user.useAsCollateral = _useAsCollateral;
    }

    /**
    * @notice ETH/token transfer functions
    **/

    /**
    * @dev fallback function enforces that the caller is a contract, to support flashloan transfers
    **/
    function() external payable {
        //only contracts can send ETH to the core
        require(msg.sender.isContract(), "Only contracts can send ether to the Lending pool core");

    }

    /**
    * @dev transfers to the user a specific amount from the reserve.
    * @param _reserve the address of the reserve where the transfer is happening
    * @param _user the address of the user receiving the transfer
    * @param _amount the amount being transferred
    **/
    function transferToUser(address _reserve, address payable _user, uint256 _amount)
    external
    onlyLendingPool
    {
        if (_reserve != EthAddressLib.ethAddress()) {
            ERC20(_reserve).safeTransfer(_user, _amount);
        } else {
            //solium-disable-next-line
            (bool result, ) = _user.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers the protocol fees to the fees collection address
    * @param _token the address of the token being transferred
    * @param _user the address of the user from where the transfer is happening
    * @param _amount the amount being transferred
    * @param _destination the fee receiver address
    **/

    function transferToFeeCollectionAddress(
        address _token,
        address _user,
        uint256 _amount,
        address _destination
    ) external payable onlyLendingPool {
        address payable feeAddress = address(uint160(_destination)); //cast the address to payable

        if (_token != EthAddressLib.ethAddress()) {
            require(
                msg.value == 0,
                "User is sending ETH along with the ERC20 transfer. Check the value attribute of the transaction"
            );
            ERC20(_token).safeTransferFrom(_user, feeAddress, _amount);
        } else {
            require(msg.value >= _amount, "The amount and the value sent to deposit do not match");
            //solium-disable-next-line
            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers the fees to the fees collection address in the case of liquidation
    * @param _token the address of the token being transferred
    * @param _amount the amount being transferred
    * @param _destination the fee receiver address
    **/
    function liquidateFee(
        address _token,
        uint256 _amount,
        address _destination
    ) external payable onlyLendingPool {
        address payable feeAddress = address(uint160(_destination)); //cast the address to payable
        require(
            msg.value == 0,
            "Fee liquidation does not require any transfer of value"
        );

        if (_token != EthAddressLib.ethAddress()) {
            ERC20(_token).safeTransfer(feeAddress, _amount);
        } else {
            //solium-disable-next-line
            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers an amount from a user to the destination reserve
    * @param _reserve the address of the reserve where the amount is being transferred
    * @param _user the address of the user from where the transfer is happening
    * @param _amount the amount being transferred
    **/
    function transferToReserve(address _reserve, address payable _user, uint256 _amount)
    external
    payable
    onlyLendingPool
    {
        if (_reserve != EthAddressLib.ethAddress()) {
            require(msg.value == 0, "User is sending ETH along with the ERC20 transfer.");
            ERC20(_reserve).safeTransferFrom(_user, address(this), _amount);

        } else {
            require(msg.value >= _amount, "The amount and the value sent to deposit do not match");

            if (msg.value > _amount) {
                //send back excess ETH
                uint256 excessAmount = msg.value.sub(_amount);
                //solium-disable-next-line
                (bool result, ) = _user.call.value(excessAmount).gas(50000)("");
                require(result, "Transfer of ETH failed");
            }
        }
    }

    /**
    * @notice data access functions
    **/

    /**
    * @dev returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral)
    * needed to calculate the global account data in the LendingPoolDataProvider
    * @param _reserve the address of the reserve
    * @param _user the address of the user
    * @return the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not
    **/
    function getUserBasicReserveData(address _reserve, address _user)
    external
    view
    returns (uint256, uint256, uint256, bool)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        uint256 underlyingBalance = getUserUnderlyingAssetBalance(_reserve, _user);

        if (user.principalBorrowBalance == 0) {
            return (underlyingBalance, 0, 0, user.useAsCollateral);
        }

        return (
        underlyingBalance,
        user.getCompoundedBorrowBalance(reserve),
        user.originationFee,
        user.useAsCollateral
        );
    }

    /**
    * @dev checks if a user is allowed to borrow at a stable rate
    * @param _reserve the reserve address
    * @param _user the user
    * @param _amount the amount the the user wants to borrow
    * @return true if the user is allowed to borrow at a stable rate, false otherwise
    **/

    function isUserAllowedToBorrowAtStable(address _reserve, address _user, uint256 _amount)
    external
    view
    returns (bool)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (!reserve.isStableBorrowRateEnabled) return false;

        return
        !user.useAsCollateral ||
        !reserve.usageAsCollateralEnabled ||
        _amount > getUserUnderlyingAssetBalance(_reserve, _user);
    }

    /**
    * @dev gets the underlying asset balance of a user based on the corresponding aToken balance.
    * @param _reserve the reserve address
    * @param _user the user address
    * @return the underlying deposit balance of the user
    **/

    function getUserUnderlyingAssetBalance(address _reserve, address _user)
    public
    view
    returns (uint256)
    {
        AToken aToken = AToken(reserves[_reserve].aTokenAddress);
        return aToken.balanceOf(_user);

    }

    /**
    * @dev gets the interest rate strategy contract address for the reserve
    * @param _reserve the reserve address
    * @return the address of the interest rate strategy contract
    **/
    function getReserveInterestRateStrategyAddress(address _reserve) public view returns (address) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.interestRateStrategyAddress;
    }

    /**
    * @dev gets the aToken contract address for the reserve
    * @param _reserve the reserve address
    * @return the address of the aToken contract
    **/

    function getReserveATokenAddress(address _reserve) public view returns (address) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.aTokenAddress;
    }

    /**
    * @dev gets the available liquidity in the reserve. The available liquidity is the balance of the core contract
    * @param _reserve the reserve address
    * @return the available liquidity
    **/
    function getReserveAvailableLiquidity(address _reserve) public view returns (uint256) {
        uint256 balance = 0;

        if (_reserve == EthAddressLib.ethAddress()) {
            balance = address(this).balance;
        } else {
            balance = IERC20(_reserve).balanceOf(address(this));
        }
        return balance;
    }

    /**
    * @dev gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows
    * @param _reserve the reserve address
    * @return the total liquidity
    **/
    function getReserveTotalLiquidity(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return getReserveAvailableLiquidity(_reserve).add(reserve.getTotalBorrows());
    }

    /**
    * @dev gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there
    * there has been 100% income.
    * @param _reserve the reserve address
    * @return the reserve normalized income
    **/
    function getReserveNormalizedIncome(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.getNormalizedIncome();
    }

    /**
    * @dev gets the reserve total borrows
    * @param _reserve the reserve address
    * @return the total borrows (stable + variable)
    **/
    function getReserveTotalBorrows(address _reserve) public view returns (uint256) {
        return reserves[_reserve].getTotalBorrows();
    }

    /**
    * @dev gets the reserve total borrows stable
    * @param _reserve the reserve address
    * @return the total borrows stable
    **/
    function getReserveTotalBorrowsStable(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.totalBorrowsStable;
    }

    /**
    * @dev gets the reserve total borrows variable
    * @param _reserve the reserve address
    * @return the total borrows variable
    **/

    function getReserveTotalBorrowsVariable(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.totalBorrowsVariable;
    }

    /**
    * @dev gets the reserve liquidation threshold
    * @param _reserve the reserve address
    * @return the reserve liquidation threshold
    **/

    function getReserveLiquidationThreshold(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.liquidationThreshold;
    }

    /**
    * @dev gets the reserve liquidation bonus
    * @param _reserve the reserve address
    * @return the reserve liquidation bonus
    **/

    function getReserveLiquidationBonus(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.liquidationBonus;
    }

    /**
    * @dev gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty
    * @param _reserve the reserve address
    * @return the reserve current variable borrow rate
    **/

    function getReserveCurrentVariableBorrowRate(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        if (reserve.currentVariableBorrowRate == 0) {
            return
            IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)
            .getBaseVariableBorrowRate();
        }
        return reserve.currentVariableBorrowRate;
    }

    /**
    * @dev gets the reserve current stable borrow rate. Is the market rate if the reserve is empty
    * @param _reserve the reserve address
    * @return the reserve current stable borrow rate
    **/

    function getReserveCurrentStableBorrowRate(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        ILendingRateOracle oracle = ILendingRateOracle(addressesProvider.getLendingRateOracle());

        if (reserve.currentStableBorrowRate == 0) {
            //no stable rate borrows yet
            return oracle.getMarketBorrowRate(_reserve);
        }

        return reserve.currentStableBorrowRate;
    }

    /**
    * @dev gets the reserve average stable borrow rate. The average stable rate is the weighted average
    * of all the loans taken at stable rate.
    * @param _reserve the reserve address
    * @return the reserve current average borrow rate
    **/
    function getReserveCurrentAverageStableBorrowRate(address _reserve)
    external
    view
    returns (uint256)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.currentAverageStableBorrowRate;
    }

    /**
    * @dev gets the reserve liquidity rate
    * @param _reserve the reserve address
    * @return the reserve liquidity rate
    **/
    function getReserveCurrentLiquidityRate(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.currentLiquidityRate;
    }

    /**
    * @dev gets the reserve liquidity cumulative index
    * @param _reserve the reserve address
    * @return the reserve liquidity cumulative index
    **/
    function getReserveLiquidityCumulativeIndex(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.lastLiquidityCumulativeIndex;
    }

    /**
    * @dev gets the reserve variable borrow index
    * @param _reserve the reserve address
    * @return the reserve variable borrow index
    **/
    function getReserveVariableBorrowsCumulativeIndex(address _reserve)
    external
    view
    returns (uint256)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.lastVariableBorrowCumulativeIndex;
    }

    /**
    * @dev this function aggregates the configuration parameters of the reserve.
    * It's used in the LendingPoolDataProvider specifically to save gas, and avoid
    * multiple external contract calls to fetch the same data.
    * @param _reserve the reserve address
    * @return the reserve decimals
    * @return the base ltv as collateral
    * @return the liquidation threshold
    * @return if the reserve is used as collateral or not
    **/
    function getReserveConfiguration(address _reserve)
    external
    view
    returns (uint256, uint256, uint256, bool)
    {
        uint256 decimals;
        uint256 baseLTVasCollateral;
        uint256 liquidationThreshold;
        bool usageAsCollateralEnabled;

        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        decimals = reserve.decimals;
        baseLTVasCollateral = reserve.baseLTVasCollateral;
        liquidationThreshold = reserve.liquidationThreshold;
        usageAsCollateralEnabled = reserve.usageAsCollateralEnabled;

        return (decimals, baseLTVasCollateral, liquidationThreshold, usageAsCollateralEnabled);
    }

    /**
    * @dev returns the decimals of the reserve
    * @param _reserve the reserve address
    * @return the reserve decimals
    **/
    function getReserveDecimals(address _reserve) external view returns (uint256) {
        return reserves[_reserve].decimals;
    }

    /**
    * @dev returns true if the reserve is enabled for borrowing
    * @param _reserve the reserve address
    * @return true if the reserve is enabled for borrowing, false otherwise
    **/

    function isReserveBorrowingEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.borrowingEnabled;
    }

    /**
    * @dev returns true if the reserve is enabled as collateral
    * @param _reserve the reserve address
    * @return true if the reserve is enabled as collateral, false otherwise
    **/

    function isReserveUsageAsCollateralEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.usageAsCollateralEnabled;
    }

    /**
    * @dev returns true if the stable rate is enabled on reserve
    * @param _reserve the reserve address
    * @return true if the stable rate is enabled on reserve, false otherwise
    **/
    function getReserveIsStableBorrowRateEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isStableBorrowRateEnabled;
    }

    /**
    * @dev returns true if the reserve is active
    * @param _reserve the reserve address
    * @return true if the reserve is active, false otherwise
    **/
    function getReserveIsActive(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isActive;
    }

    /**
    * @notice returns if a reserve is freezed
    * @param _reserve the reserve for which the information is needed
    * @return true if the reserve is freezed, false otherwise
    **/

    function getReserveIsFreezed(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isFreezed;
    }

    /**
    * @notice returns the timestamp of the last action on the reserve
    * @param _reserve the reserve for which the information is needed
    * @return the last updated timestamp of the reserve
    **/

    function getReserveLastUpdate(address _reserve) external view returns (uint40 timestamp) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        timestamp = reserve.lastUpdateTimestamp;
    }

    /**
    * @dev returns the utilization rate U of a specific reserve
    * @param _reserve the reserve for which the information is needed
    * @return the utilization rate in ray
    **/

    function getReserveUtilizationRate(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        uint256 totalBorrows = reserve.getTotalBorrows();

        if (totalBorrows == 0) {
            return 0;
        }

        uint256 availableLiquidity = getReserveAvailableLiquidity(_reserve);

        return totalBorrows.rayDiv(availableLiquidity.add(totalBorrows));
    }

    /**
    * @return the array of reserves configured on the core
    **/
    function getReserves() external view returns (address[] memory) {
        return reservesList;
    }

    /**
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return true if the user has chosen to use the reserve as collateral, false otherwise
    **/
    function isUserUseReserveAsCollateralEnabled(address _reserve, address _user)
    external
    view
    returns (bool)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.useAsCollateral;
    }

    /**
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the origination fee for the user
    **/
    function getUserOriginationFee(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.originationFee;
    }

    /**
    * @dev users with no loans in progress have NONE as borrow rate mode
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the borrow rate mode for the user,
    **/

    function getUserCurrentBorrowRateMode(address _reserve, address _user)
    public
    view
    returns (CoreLibrary.InterestRateMode)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (user.principalBorrowBalance == 0) {
            return CoreLibrary.InterestRateMode.NONE;
        }

        return
        user.stableBorrowRate > 0
        ? CoreLibrary.InterestRateMode.STABLE
        : CoreLibrary.InterestRateMode.VARIABLE;
    }

    /**
    * @dev gets the current borrow rate of the user
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the borrow rate for the user,
    **/
    function getUserCurrentBorrowRate(address _reserve, address _user)
    internal
    view
    returns (uint256)
    {
        CoreLibrary.InterestRateMode rateMode = getUserCurrentBorrowRateMode(_reserve, _user);

        if (rateMode == CoreLibrary.InterestRateMode.NONE) {
            return 0;
        }

        return
        rateMode == CoreLibrary.InterestRateMode.STABLE
        ? usersReserveData[_user][_reserve].stableBorrowRate
        : reserves[_reserve].currentVariableBorrowRate;
    }

    /**
    * @dev the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the user stable rate
    **/
    function getUserCurrentStableBorrowRate(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.stableBorrowRate;
    }

    /**
    * @dev calculates and returns the borrow balances of the user
    * @param _reserve the address of the reserve
    * @param _user the address of the user
    * @return the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance
    **/

    function getUserBorrowBalances(address _reserve, address _user)
    public
    view
    returns (uint256, uint256, uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        if (user.principalBorrowBalance == 0) {
            return (0, 0, 0);
        }

        uint256 principal = user.principalBorrowBalance;
        uint256 compoundedBalance = CoreLibrary.getCompoundedBorrowBalance(
            user,
            reserves[_reserve]
        );
        return (principal, compoundedBalance, compoundedBalance.sub(principal));
    }

    /**
    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the variable borrow index for the user
    **/

    function getUserVariableBorrowCumulativeIndex(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.lastVariableBorrowCumulativeIndex;
    }

    /**
    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the variable borrow index for the user
    **/

    function getUserLastUpdate(address _reserve, address _user)
    external
    view
    returns (uint256 timestamp)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        timestamp = user.lastUpdateTimestamp;
    }

    /**
    * @dev updates the lending pool core configuration
    **/
    function refreshConfiguration() external onlyLendingPoolConfigurator {
        refreshConfigInternal();
    }

    /**
    * @dev initializes a reserve
    * @param _reserve the address of the reserve
    * @param _aTokenAddress the address of the overlying aToken contract
    * @param _decimals the decimals of the reserve currency
    * @param _interestRateStrategyAddress the address of the interest rate strategy contract
    **/
    function initReserve(
        address _reserve,
        address _aTokenAddress,
        uint256 _decimals,
        address _interestRateStrategyAddress
    ) external onlyLendingPoolConfigurator {
        reserves[_reserve].init(_aTokenAddress, _decimals, _interestRateStrategyAddress);
        addReserveToListInternal(_reserve);

    }



    /**
    * @dev removes the last added reserve in the reservesList array
    * @param _reserveToRemove the address of the reserve
    **/
    function removeLastAddedReserve(address _reserveToRemove)
    external onlyLendingPoolConfigurator {

        address lastReserve = reservesList[reservesList.length-1];

        require(lastReserve == _reserveToRemove, "Reserve being removed is different than the reserve requested");

        //as we can't check if totalLiquidity is 0 (since the reserve added might not be an ERC20) we at least check that there is nothing borrowed
        require(getReserveTotalBorrows(lastReserve) == 0, "Cannot remove a reserve with liquidity deposited");

        reserves[lastReserve].isActive = false;
        reserves[lastReserve].aTokenAddress = address(0);
        reserves[lastReserve].decimals = 0;
        reserves[lastReserve].lastLiquidityCumulativeIndex = 0;
        reserves[lastReserve].lastVariableBorrowCumulativeIndex = 0;
        reserves[lastReserve].borrowingEnabled = false;
        reserves[lastReserve].usageAsCollateralEnabled = false;
        reserves[lastReserve].baseLTVasCollateral = 0;
        reserves[lastReserve].liquidationThreshold = 0;
        reserves[lastReserve].liquidationBonus = 0;
        reserves[lastReserve].interestRateStrategyAddress = address(0);

        reservesList.pop();
    }

    /**
    * @dev updates the address of the interest rate strategy contract
    * @param _reserve the address of the reserve
    * @param _rateStrategyAddress the address of the interest rate strategy contract
    **/

    function setReserveInterestRateStrategyAddress(address _reserve, address _rateStrategyAddress)
    external
    onlyLendingPoolConfigurator
    {
        reserves[_reserve].interestRateStrategyAddress = _rateStrategyAddress;
    }

    /**
    * @dev enables borrowing on a reserve. Also sets the stable rate borrowing
    * @param _reserve the address of the reserve
    * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise
    **/

    function enableBorrowingOnReserve(address _reserve, bool _stableBorrowRateEnabled)
    external
    onlyLendingPoolConfigurator
    {
        reserves[_reserve].enableBorrowing(_stableBorrowRateEnabled);
    }

    /**
    * @dev disables borrowing on a reserve
    * @param _reserve the address of the reserve
    **/

    function disableBorrowingOnReserve(address _reserve) external onlyLendingPoolConfigurator {
        reserves[_reserve].disableBorrowing();
    }

    /**
    * @dev enables a reserve to be used as collateral
    * @param _reserve the address of the reserve
    **/
    function enableReserveAsCollateral(
        address _reserve,
        uint256 _baseLTVasCollateral,
        uint256 _liquidationThreshold,
        uint256 _liquidationBonus
    ) external onlyLendingPoolConfigurator {
        reserves[_reserve].enableAsCollateral(
            _baseLTVasCollateral,
            _liquidationThreshold,
            _liquidationBonus
        );
    }

    /**
    * @dev disables a reserve to be used as collateral
    * @param _reserve the address of the reserve
    **/
    function disableReserveAsCollateral(address _reserve) external onlyLendingPoolConfigurator {
        reserves[_reserve].disableAsCollateral();
    }

    /**
    * @dev enable the stable borrow rate mode on a reserve
    * @param _reserve the address of the reserve
    **/
    function enableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isStableBorrowRateEnabled = true;
    }

    /**
    * @dev disable the stable borrow rate mode on a reserve
    * @param _reserve the address of the reserve
    **/
    function disableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isStableBorrowRateEnabled = false;
    }

    /**
    * @dev activates a reserve
    * @param _reserve the address of the reserve
    **/
    function activateReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        require(
            reserve.lastLiquidityCumulativeIndex > 0 &&
            reserve.lastVariableBorrowCumulativeIndex > 0,
            "Reserve has not been initialized yet"
        );
        reserve.isActive = true;
    }

    /**
    * @dev deactivates a reserve
    * @param _reserve the address of the reserve
    **/
    function deactivateReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isActive = false;
    }

    /**
    * @notice allows the configurator to freeze the reserve.
    * A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance.
    * @param _reserve the address of the reserve
    **/
    function freezeReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isFreezed = true;
    }

    /**
    * @notice allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed.
    * @param _reserve the address of the reserve
    **/
    function unfreezeReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isFreezed = false;
    }

    /**
    * @notice allows the configurator to update the loan to value of a reserve
    * @param _reserve the address of the reserve
    * @param _ltv the new loan to value
    **/
    function setReserveBaseLTVasCollateral(address _reserve, uint256 _ltv)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.baseLTVasCollateral = _ltv;
    }

    /**
    * @notice allows the configurator to update the liquidation threshold of a reserve
    * @param _reserve the address of the reserve
    * @param _threshold the new liquidation threshold
    **/
    function setReserveLiquidationThreshold(address _reserve, uint256 _threshold)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.liquidationThreshold = _threshold;
    }

    /**
    * @notice allows the configurator to update the liquidation bonus of a reserve
    * @param _reserve the address of the reserve
    * @param _bonus the new liquidation bonus
    **/
    function setReserveLiquidationBonus(address _reserve, uint256 _bonus)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.liquidationBonus = _bonus;
    }

    /**
    * @notice allows the configurator to update the reserve decimals
    * @param _reserve the address of the reserve
    * @param _decimals the decimals of the reserve
    **/
    function setReserveDecimals(address _reserve, uint256 _decimals)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.decimals = _decimals;
    }

    /**
    * @notice internal functions
    **/

    /**
    * @dev updates the state of a reserve as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the previous borrow balance of the borrower before the action
    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount
    * @param _amountBorrowed the new amount borrowed
    * @param _rateMode the borrow rate mode (stable, variable)
    **/

    function updateReserveStateOnBorrowInternal(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _balanceIncrease,
        uint256 _amountBorrowed,
        CoreLibrary.InterestRateMode _rateMode
    ) internal {
        reserves[_reserve].updateCumulativeIndexes();

        //increasing reserve total borrows to account for the new borrow balance of the user
        //NOTE: Depending on the previous borrow mode, the borrows might need to be switched from variable to stable or vice versa

        updateReserveTotalBorrowsByRateModeInternal(
            _reserve,
            _user,
            _principalBorrowBalance,
            _balanceIncrease,
            _amountBorrowed,
            _rateMode
        );
    }

    /**
    * @dev updates the state of a user as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _amountBorrowed the amount borrowed
    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount
    * @param _rateMode the borrow rate mode (stable, variable)
    * @return the final borrow rate for the user. Emitted by the borrow() event
    **/

    function updateUserStateOnBorrowInternal(
        address _reserve,
        address _user,
        uint256 _amountBorrowed,
        uint256 _balanceIncrease,
        uint256 _fee,
        CoreLibrary.InterestRateMode _rateMode
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (_rateMode == CoreLibrary.InterestRateMode.STABLE) {
            //stable
            //reset the user variable index, and update the stable rate
            user.stableBorrowRate = reserve.currentStableBorrowRate;
            user.lastVariableBorrowCumulativeIndex = 0;
        } else if (_rateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //variable
            //reset the user stable rate, and store the new borrow index
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        } else {
            revert("Invalid borrow rate mode");
        }
        //increase the principal borrows and the origination fee
        user.principalBorrowBalance = user.principalBorrowBalance.add(_amountBorrowed).add(
            _balanceIncrease
        );
        user.originationFee = user.originationFee.add(_fee);

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

    }

    /**
    * @dev updates the state of the reserve as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateReserveStateOnRepayInternal(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_reserve][_user];

        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(_reserve, _user);

        //update the indexes
        reserves[_reserve].updateCumulativeIndexes();

        //compound the cumulated interest to the borrow balance and then subtracting the payback amount
        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _balanceIncrease,
                user.stableBorrowRate
            );
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _paybackAmountMinusFees,
                user.stableBorrowRate
            );
        } else {
            reserve.increaseTotalBorrowsVariable(_balanceIncrease);
            reserve.decreaseTotalBorrowsVariable(_paybackAmountMinusFees);
        }
    }

    /**
    * @dev updates the state of the user as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _originationFeeRepaid the fee on the amount that is being repaid
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _repaidWholeLoan true if the user is repaying the whole loan
    **/
    function updateUserStateOnRepayInternal(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _originationFeeRepaid,
        uint256 _balanceIncrease,
        bool _repaidWholeLoan
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        //update the user principal borrow balance, adding the cumulated interest and then subtracting the payback amount
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(
            _paybackAmountMinusFees
        );
        user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;

        //if the balance decrease is equal to the previous principal (user is repaying the whole loan)
        //and the rate mode is stable, we reset the interest rate mode of the user
        if (_repaidWholeLoan) {
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = 0;
        }
        user.originationFee = user.originationFee.sub(_originationFeeRepaid);

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

    }

    /**
    * @dev updates the state of the user as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is performing the rate swap
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the the principal amount borrowed by the user
    * @param _compoundedBorrowBalance the principal amount plus the accrued interest
    * @param _currentRateMode the rate mode at which the user borrowed
    **/
    function updateReserveStateOnSwapRateInternal(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _compoundedBorrowBalance,
        CoreLibrary.InterestRateMode _currentRateMode
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        //compounding reserve indexes
        reserve.updateCumulativeIndexes();

        if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {
            uint256 userCurrentStableRate = user.stableBorrowRate;

            //swap to variable
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _principalBorrowBalance,
                userCurrentStableRate
            ); //decreasing stable from old principal balance
            reserve.increaseTotalBorrowsVariable(_compoundedBorrowBalance); //increase variable borrows
        } else if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //swap to stable
            uint256 currentStableRate = reserve.currentStableBorrowRate;
            reserve.decreaseTotalBorrowsVariable(_principalBorrowBalance);
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _compoundedBorrowBalance,
                currentStableRate
            );

        } else {
            revert("Invalid rate mode received");
        }
    }

    /**
    * @dev updates the state of the user as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is performing the swap
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _currentRateMode the current rate mode of the user
    **/

    function updateUserStateOnSwapRateInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease,
        CoreLibrary.InterestRateMode _currentRateMode
    ) internal returns (CoreLibrary.InterestRateMode) {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        CoreLibrary.InterestRateMode newMode = CoreLibrary.InterestRateMode.NONE;

        if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //switch to stable
            newMode = CoreLibrary.InterestRateMode.STABLE;
            user.stableBorrowRate = reserve.currentStableBorrowRate;
            user.lastVariableBorrowCumulativeIndex = 0;
        } else if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {
            newMode = CoreLibrary.InterestRateMode.VARIABLE;
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        } else {
            revert("Invalid interest rate mode received");
        }
        //compounding cumulated interest
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);
        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

        return newMode;
    }

    /**
    * @dev updates the state of the principal reserve as a consequence of a liquidation action.
    * @param _principalReserve the address of the principal reserve that is being repaid
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updatePrincipalReserveStateOnLiquidationInternal(
        address _principalReserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_principalReserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_principalReserve];

        //update principal reserve data
        reserve.updateCumulativeIndexes();

        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(
            _principalReserve,
            _user
        );

        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            //increase the total borrows by the compounded interest
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _balanceIncrease,
                user.stableBorrowRate
            );

            //decrease by the actual amount to liquidate
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _amountToLiquidate,
                user.stableBorrowRate
            );

        } else {
            //increase the total borrows by the compounded interest
            reserve.increaseTotalBorrowsVariable(_balanceIncrease);

            //decrease by the actual amount to liquidate
            reserve.decreaseTotalBorrowsVariable(_amountToLiquidate);
        }

    }

    /**
    * @dev updates the state of the collateral reserve as a consequence of a liquidation action.
    * @param _collateralReserve the address of the collateral reserve that is being liquidated
    **/
    function updateCollateralReserveStateOnLiquidationInternal(
        address _collateralReserve
    ) internal {
        //update collateral reserve
        reserves[_collateralReserve].updateCumulativeIndexes();

    }

    /**
    * @dev updates the state of the user being liquidated as a consequence of a liquidation action.
    * @param _reserve the address of the principal reserve that is being repaid
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _feeLiquidated the amount of origination fee being liquidated
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/
    function updateUserStateOnLiquidationInternal(
        address _reserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _feeLiquidated,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        //first increase by the compounded interest, then decrease by the liquidated amount
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(
            _amountToLiquidate
        );

        if (
            getUserCurrentBorrowRateMode(_reserve, _user) == CoreLibrary.InterestRateMode.VARIABLE
        ) {
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        }

        if(_feeLiquidated > 0){
            user.originationFee = user.originationFee.sub(_feeLiquidated);
        }

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);
    }

    /**
    * @dev updates the state of the reserve as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateReserveStateOnRebalanceInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        reserve.updateCumulativeIndexes();

        reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
            _balanceIncrease,
            user.stableBorrowRate
        );

    }

    /**
    * @dev updates the state of the user as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateUserStateOnRebalanceInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);
        user.stableBorrowRate = reserve.currentStableBorrowRate;

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);
    }

    /**
    * @dev updates the state of the user as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _amountBorrowed the accrued interest on the borrowed amount
    **/
    function updateReserveTotalBorrowsByRateModeInternal(
        address _reserve,
        address _user,
        uint256 _principalBalance,
        uint256 _balanceIncrease,
        uint256 _amountBorrowed,
        CoreLibrary.InterestRateMode _newBorrowRateMode
    ) internal {
        CoreLibrary.InterestRateMode previousRateMode = getUserCurrentBorrowRateMode(
            _reserve,
            _user
        );
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        if (previousRateMode == CoreLibrary.InterestRateMode.STABLE) {
            CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _principalBalance,
                user.stableBorrowRate
            );
        } else if (previousRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            reserve.decreaseTotalBorrowsVariable(_principalBalance);
        }

        uint256 newPrincipalAmount = _principalBalance.add(_balanceIncrease).add(_amountBorrowed);
        if (_newBorrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                newPrincipalAmount,
                reserve.currentStableBorrowRate
            );
        } else if (_newBorrowRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            reserve.increaseTotalBorrowsVariable(newPrincipalAmount);
        } else {
            revert("Invalid new borrow rate mode");
        }
    }

    /**
    * @dev Updates the reserve current stable borrow rate Rf, the current variable borrow rate Rv and the current liquidity rate Rl.
    * Also updates the lastUpdateTimestamp value. Please refer to the whitepaper for further information.
    * @param _reserve the address of the reserve to be updated
    * @param _liquidityAdded the amount of liquidity added to the protocol (deposit or repay) in the previous action
    * @param _liquidityTaken the amount of liquidity taken from the protocol (redeem or borrow)
    **/

    function updateReserveInterestRatesAndTimestampInternal(
        address _reserve,
        uint256 _liquidityAdded,
        uint256 _liquidityTaken
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        (uint256 newLiquidityRate, uint256 newStableRate, uint256 newVariableRate) = IReserveInterestRateStrategy(
            reserve
            .interestRateStrategyAddress
        )
        .calculateInterestRates(
            _reserve,
            getReserveAvailableLiquidity(_reserve).add(_liquidityAdded).sub(_liquidityTaken),
            reserve.totalBorrowsStable,
            reserve.totalBorrowsVariable,
            reserve.currentAverageStableBorrowRate
        );

        reserve.currentLiquidityRate = newLiquidityRate;
        reserve.currentStableBorrowRate = newStableRate;
        reserve.currentVariableBorrowRate = newVariableRate;

        //solium-disable-next-line
        reserve.lastUpdateTimestamp = uint40(block.timestamp);

        emit ReserveUpdated(
            _reserve,
            newLiquidityRate,
            newStableRate,
            newVariableRate,
            reserve.lastLiquidityCumulativeIndex,
            reserve.lastVariableBorrowCumulativeIndex
        );
    }

    /**
    * @dev transfers to the protocol fees of a flashloan to the fees collection address
    * @param _token the address of the token being transferred
    * @param _amount the amount being transferred
    **/

    function transferFlashLoanProtocolFeeInternal(address _token, uint256 _amount) internal {
        address payable receiver = address(uint160(addressesProvider.getTokenDistributor()));

        if (_token != EthAddressLib.ethAddress()) {
            ERC20(_token).safeTransfer(receiver, _amount);
        } else {
            receiver.transfer(_amount);
        }
    }

    /**
    * @dev updates the internal configuration of the core
    **/
    function refreshConfigInternal() internal {
        lendingPoolAddress = addressesProvider.getLendingPool();
    }

    /**
    * @dev adds a reserve to the array of the reserves address
    **/
    function addReserveToListInternal(address _reserve) internal {
        bool reserveAlreadyAdded = false;
        for (uint256 i = 0; i < reservesList.length; i++)
            if (reservesList[i] == _reserve) {
                reserveAlreadyAdded = true;
            }
        if (!reserveAlreadyAdded) reservesList.push(_reserve);
    }

}
.]

We excel in generating innovative approaches and enhancements for Solidity smart contract code.

Here's a Solidity contract provided by the user: "pragma solidity ^0.5.0;

import "openzeppelin-solidity/contracts/math/SafeMath.sol";
import "openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol";
import "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol";
import "openzeppelin-solidity/contracts/utils/Address.sol";
import "../libraries/openzeppelin-upgradeability/VersionedInitializable.sol";

import "../libraries/CoreLibrary.sol";
import "../configuration/LendingPoolAddressesProvider.sol";
import "../interfaces/ILendingRateOracle.sol";
import "../interfaces/IReserveInterestRateStrategy.sol";
import "../libraries/WadRayMath.sol";
import "../tokenization/AToken.sol";
import "../libraries/EthAddressLib.sol";

/**
* @title LendingPoolCore contract
* @author Aave
* @notice Holds the state of the lending pool and all the funds deposited
* @dev NOTE: The core does not enforce security checks on the update of the state
* (eg, updateStateOnBorrow() does not enforce that borrowed is enabled on the reserve).
* The check that an action can be performed is a duty of the overlying LendingPool contract.
**/

contract LendingPoolCore is VersionedInitializable {
    using SafeMath for uint256;
    using WadRayMath for uint256;
    using CoreLibrary for CoreLibrary.ReserveData;
    using CoreLibrary for CoreLibrary.UserReserveData;
    using SafeERC20 for ERC20;
    using Address for address payable;

    /**
    * @dev Emitted when the state of a reserve is updated
    * @param reserve the address of the reserve
    * @param liquidityRate the new liquidity rate
    * @param stableBorrowRate the new stable borrow rate
    * @param variableBorrowRate the new variable borrow rate
    * @param liquidityIndex the new liquidity index
    * @param variableBorrowIndex the new variable borrow index
    **/
    event ReserveUpdated(
        address indexed reserve,
        uint256 liquidityRate,
        uint256 stableBorrowRate,
        uint256 variableBorrowRate,
        uint256 liquidityIndex,
        uint256 variableBorrowIndex
    );

    address public lendingPoolAddress;

    LendingPoolAddressesProvider public addressesProvider;

    /**
    * @dev only lending pools can use functions affected by this modifier
    **/
    modifier onlyLendingPool {
        require(lendingPoolAddress == msg.sender, "The caller must be a lending pool contract");
        _;
    }

    /**
    * @dev only lending pools configurator can use functions affected by this modifier
    **/
    modifier onlyLendingPoolConfigurator {
        require(
            addressesProvider.getLendingPoolConfigurator() == msg.sender,
            "The caller must be a lending pool configurator contract"
        );
        _;
    }

    mapping(address => CoreLibrary.ReserveData) internal reserves;
    mapping(address => mapping(address => CoreLibrary.UserReserveData)) internal usersReserveData;

    address[] public reservesList;

    uint256 public constant CORE_REVISION = 0x4;

    /**
    * @dev returns the revision number of the contract
    **/
    function getRevision() internal pure returns (uint256) {
        return CORE_REVISION;
    }

    /**
    * @dev initializes the Core contract, invoked upon registration on the AddressesProvider
    * @param _addressesProvider the addressesProvider contract
    **/

    function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {
        addressesProvider = _addressesProvider;
        refreshConfigInternal();
    }

    /**
    * @dev updates the state of the core as a result of a deposit action
    * @param _reserve the address of the reserve in which the deposit is happening
    * @param _user the address of the the user depositing
    * @param _amount the amount being deposited
    * @param _isFirstDeposit true if the user is depositing for the first time
    **/

    function updateStateOnDeposit(
        address _reserve,
        address _user,
        uint256 _amount,
        bool _isFirstDeposit
    ) external onlyLendingPool {
        reserves[_reserve].updateCumulativeIndexes();
        updateReserveInterestRatesAndTimestampInternal(_reserve, _amount, 0);

        if (_isFirstDeposit) {
            //if this is the first deposit of the user, we configure the deposit as enabled to be used as collateral
            setUserUseReserveAsCollateral(_reserve, _user, true);
        }
    }

    /**
    * @dev updates the state of the core as a result of a redeem action
    * @param _reserve the address of the reserve in which the redeem is happening
    * @param _user the address of the the user redeeming
    * @param _amountRedeemed the amount being redeemed
    * @param _userRedeemedEverything true if the user is redeeming everything
    **/
    function updateStateOnRedeem(
        address _reserve,
        address _user,
        uint256 _amountRedeemed,
        bool _userRedeemedEverything
    ) external onlyLendingPool {
        //compound liquidity and variable borrow interests
        reserves[_reserve].updateCumulativeIndexes();
        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountRedeemed);

        //if user redeemed everything the useReserveAsCollateral flag is reset
        if (_userRedeemedEverything) {
            setUserUseReserveAsCollateral(_reserve, _user, false);
        }
    }

    /**
    * @dev updates the state of the core as a result of a flashloan action
    * @param _reserve the address of the reserve in which the flashloan is happening
    * @param _income the income of the protocol as a result of the action
    **/
    function updateStateOnFlashLoan(
        address _reserve,
        uint256 _availableLiquidityBefore,
        uint256 _income,
        uint256 _protocolFee
    ) external onlyLendingPool {
        transferFlashLoanProtocolFeeInternal(_reserve, _protocolFee);

        //compounding the cumulated interest
        reserves[_reserve].updateCumulativeIndexes();

        uint256 totalLiquidityBefore = _availableLiquidityBefore.add(
            getReserveTotalBorrows(_reserve)
        );

        //compounding the received fee into the reserve
        reserves[_reserve].cumulateToLiquidityIndex(totalLiquidityBefore, _income);

        //refresh interest rates
        updateReserveInterestRatesAndTimestampInternal(_reserve, _income, 0);
    }

    /**
    * @dev updates the state of the core as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _amountBorrowed the new amount borrowed
    * @param _borrowFee the fee on the amount borrowed
    * @param _rateMode the borrow rate mode (stable, variable)
    * @return the new borrow rate for the user
    **/
    function updateStateOnBorrow(
        address _reserve,
        address _user,
        uint256 _amountBorrowed,
        uint256 _borrowFee,
        CoreLibrary.InterestRateMode _rateMode
    ) external onlyLendingPool returns (uint256, uint256) {
        // getting the previous borrow data of the user
        (uint256 principalBorrowBalance, , uint256 balanceIncrease) = getUserBorrowBalances(
            _reserve,
            _user
        );

        updateReserveStateOnBorrowInternal(
            _reserve,
            _user,
            principalBorrowBalance,
            balanceIncrease,
            _amountBorrowed,
            _rateMode
        );

        updateUserStateOnBorrowInternal(
            _reserve,
            _user,
            _amountBorrowed,
            balanceIncrease,
            _borrowFee,
            _rateMode
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountBorrowed);

        return (getUserCurrentBorrowRate(_reserve, _user), balanceIncrease);
    }

    /**
    * @dev updates the state of the core as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _originationFeeRepaid the fee on the amount that is being repaid
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _repaidWholeLoan true if the user is repaying the whole loan
    **/

    function updateStateOnRepay(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _originationFeeRepaid,
        uint256 _balanceIncrease,
        bool _repaidWholeLoan
    ) external onlyLendingPool {
        updateReserveStateOnRepayInternal(
            _reserve,
            _user,
            _paybackAmountMinusFees,
            _balanceIncrease
        );
        updateUserStateOnRepayInternal(
            _reserve,
            _user,
            _paybackAmountMinusFees,
            _originationFeeRepaid,
            _balanceIncrease,
            _repaidWholeLoan
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, _paybackAmountMinusFees, 0);
    }

    /**
    * @dev updates the state of the core as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the amount borrowed by the user
    * @param _compoundedBorrowBalance the amount borrowed plus accrued interest
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _currentRateMode the current interest rate mode for the user
    **/
    function updateStateOnSwapRate(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _compoundedBorrowBalance,
        uint256 _balanceIncrease,
        CoreLibrary.InterestRateMode _currentRateMode
    ) external onlyLendingPool returns (CoreLibrary.InterestRateMode, uint256) {
        updateReserveStateOnSwapRateInternal(
            _reserve,
            _user,
            _principalBorrowBalance,
            _compoundedBorrowBalance,
            _currentRateMode
        );

        CoreLibrary.InterestRateMode newRateMode = updateUserStateOnSwapRateInternal(
            _reserve,
            _user,
            _balanceIncrease,
            _currentRateMode
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);

        return (newRateMode, getUserCurrentBorrowRate(_reserve, _user));
    }

    /**
    * @dev updates the state of the core as a consequence of a liquidation action.
    * @param _principalReserve the address of the principal reserve that is being repaid
    * @param _collateralReserve the address of the collateral reserve that is being liquidated
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _collateralToLiquidate the amount of collateral being liquidated
    * @param _feeLiquidated the amount of origination fee being liquidated
    * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise
    **/
    function updateStateOnLiquidation(
        address _principalReserve,
        address _collateralReserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _collateralToLiquidate,
        uint256 _feeLiquidated,
        uint256 _liquidatedCollateralForFee,
        uint256 _balanceIncrease,
        bool _liquidatorReceivesAToken
    ) external onlyLendingPool {
        updatePrincipalReserveStateOnLiquidationInternal(
            _principalReserve,
            _user,
            _amountToLiquidate,
            _balanceIncrease
        );

        updateCollateralReserveStateOnLiquidationInternal(
            _collateralReserve
        );

        updateUserStateOnLiquidationInternal(
            _principalReserve,
            _user,
            _amountToLiquidate,
            _feeLiquidated,
            _balanceIncrease
        );

        updateReserveInterestRatesAndTimestampInternal(_principalReserve, _amountToLiquidate, 0);

        if (!_liquidatorReceivesAToken) {
            updateReserveInterestRatesAndTimestampInternal(
                _collateralReserve,
                0,
                _collateralToLiquidate.add(_liquidatedCollateralForFee)
            );
        }

    }

    /**
    * @dev updates the state of the core as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @return the new stable rate for the user
    **/
    function updateStateOnRebalance(address _reserve, address _user, uint256 _balanceIncrease)
    external
    onlyLendingPool
    returns (uint256)
    {
        updateReserveStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);

        //update user data and rebalance the rate
        updateUserStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);
        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);
        return usersReserveData[_user][_reserve].stableBorrowRate;
    }

    /**
    * @dev enables or disables a reserve as collateral
    * @param _reserve the address of the principal reserve where the user deposited
    * @param _user the address of the depositor
    * @param _useAsCollateral true if the depositor wants to use the reserve as collateral
    **/
    function setUserUseReserveAsCollateral(address _reserve, address _user, bool _useAsCollateral)
    public
    onlyLendingPool
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        user.useAsCollateral = _useAsCollateral;
    }

    /**
    * @notice ETH/token transfer functions
    **/

    /**
    * @dev fallback function enforces that the caller is a contract, to support flashloan transfers
    **/
    function() external payable {
        //only contracts can send ETH to the core
        require(msg.sender.isContract(), "Only contracts can send ether to the Lending pool core");

    }

    /**
    * @dev transfers to the user a specific amount from the reserve.
    * @param _reserve the address of the reserve where the transfer is happening
    * @param _user the address of the user receiving the transfer
    * @param _amount the amount being transferred
    **/
    function transferToUser(address _reserve, address payable _user, uint256 _amount)
    external
    onlyLendingPool
    {
        if (_reserve != EthAddressLib.ethAddress()) {
            ERC20(_reserve).safeTransfer(_user, _amount);
        } else {
            //solium-disable-next-line
            (bool result, ) = _user.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers the protocol fees to the fees collection address
    * @param _token the address of the token being transferred
    * @param _user the address of the user from where the transfer is happening
    * @param _amount the amount being transferred
    * @param _destination the fee receiver address
    **/

    function transferToFeeCollectionAddress(
        address _token,
        address _user,
        uint256 _amount,
        address _destination
    ) external payable onlyLendingPool {
        address payable feeAddress = address(uint160(_destination)); //cast the address to payable

        if (_token != EthAddressLib.ethAddress()) {
            require(
                msg.value == 0,
                "User is sending ETH along with the ERC20 transfer. Check the value attribute of the transaction"
            );
            ERC20(_token).safeTransferFrom(_user, feeAddress, _amount);
        } else {
            require(msg.value >= _amount, "The amount and the value sent to deposit do not match");
            //solium-disable-next-line
            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers the fees to the fees collection address in the case of liquidation
    * @param _token the address of the token being transferred
    * @param _amount the amount being transferred
    * @param _destination the fee receiver address
    **/
    function liquidateFee(
        address _token,
        uint256 _amount,
        address _destination
    ) external payable onlyLendingPool {
        address payable feeAddress = address(uint160(_destination)); //cast the address to payable
        require(
            msg.value == 0,
            "Fee liquidation does not require any transfer of value"
        );

        if (_token != EthAddressLib.ethAddress()) {
            ERC20(_token).safeTransfer(feeAddress, _amount);
        } else {
            //solium-disable-next-line
            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers an amount from a user to the destination reserve
    * @param _reserve the address of the reserve where the amount is being transferred
    * @param _user the address of the user from where the transfer is happening
    * @param _amount the amount being transferred
    **/
    function transferToReserve(address _reserve, address payable _user, uint256 _amount)
    external
    payable
    onlyLendingPool
    {
        if (_reserve != EthAddressLib.ethAddress()) {
            require(msg.value == 0, "User is sending ETH along with the ERC20 transfer.");
            ERC20(_reserve).safeTransferFrom(_user, address(this), _amount);

        } else {
            require(msg.value >= _amount, "The amount and the value sent to deposit do not match");

            if (msg.value > _amount) {
                //send back excess ETH
                uint256 excessAmount = msg.value.sub(_amount);
                //solium-disable-next-line
                (bool result, ) = _user.call.value(excessAmount).gas(50000)("");
                require(result, "Transfer of ETH failed");
            }
        }
    }

    /**
    * @notice data access functions
    **/

    /**
    * @dev returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral)
    * needed to calculate the global account data in the LendingPoolDataProvider
    * @param _reserve the address of the reserve
    * @param _user the address of the user
    * @return the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not
    **/
    function getUserBasicReserveData(address _reserve, address _user)
    external
    view
    returns (uint256, uint256, uint256, bool)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        uint256 underlyingBalance = getUserUnderlyingAssetBalance(_reserve, _user);

        if (user.principalBorrowBalance == 0) {
            return (underlyingBalance, 0, 0, user.useAsCollateral);
        }

        return (
        underlyingBalance,
        user.getCompoundedBorrowBalance(reserve),
        user.originationFee,
        user.useAsCollateral
        );
    }

    /**
    * @dev checks if a user is allowed to borrow at a stable rate
    * @param _reserve the reserve address
    * @param _user the user
    * @param _amount the amount the the user wants to borrow
    * @return true if the user is allowed to borrow at a stable rate, false otherwise
    **/

    function isUserAllowedToBorrowAtStable(address _reserve, address _user, uint256 _amount)
    external
    view
    returns (bool)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (!reserve.isStableBorrowRateEnabled) return false;

        return
        !user.useAsCollateral ||
        !reserve.usageAsCollateralEnabled ||
        _amount > getUserUnderlyingAssetBalance(_reserve, _user);
    }

    /**
    * @dev gets the underlying asset balance of a user based on the corresponding aToken balance.
    * @param _reserve the reserve address
    * @param _user the user address
    * @return the underlying deposit balance of the user
    **/

    function getUserUnderlyingAssetBalance(address _reserve, address _user)
    public
    view
    returns (uint256)
    {
        AToken aToken = AToken(reserves[_reserve].aTokenAddress);
        return aToken.balanceOf(_user);

    }

    /**
    * @dev gets the interest rate strategy contract address for the reserve
    * @param _reserve the reserve address
    * @return the address of the interest rate strategy contract
    **/
    function getReserveInterestRateStrategyAddress(address _reserve) public view returns (address) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.interestRateStrategyAddress;
    }

    /**
    * @dev gets the aToken contract address for the reserve
    * @param _reserve the reserve address
    * @return the address of the aToken contract
    **/

    function getReserveATokenAddress(address _reserve) public view returns (address) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.aTokenAddress;
    }

    /**
    * @dev gets the available liquidity in the reserve. The available liquidity is the balance of the core contract
    * @param _reserve the reserve address
    * @return the available liquidity
    **/
    function getReserveAvailableLiquidity(address _reserve) public view returns (uint256) {
        uint256 balance = 0;

        if (_reserve == EthAddressLib.ethAddress()) {
            balance = address(this).balance;
        } else {
            balance = IERC20(_reserve).balanceOf(address(this));
        }
        return balance;
    }

    /**
    * @dev gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows
    * @param _reserve the reserve address
    * @return the total liquidity
    **/
    function getReserveTotalLiquidity(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return getReserveAvailableLiquidity(_reserve).add(reserve.getTotalBorrows());
    }

    /**
    * @dev gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there
    * there has been 100% income.
    * @param _reserve the reserve address
    * @return the reserve normalized income
    **/
    function getReserveNormalizedIncome(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.getNormalizedIncome();
    }

    /**
    * @dev gets the reserve total borrows
    * @param _reserve the reserve address
    * @return the total borrows (stable + variable)
    **/
    function getReserveTotalBorrows(address _reserve) public view returns (uint256) {
        return reserves[_reserve].getTotalBorrows();
    }

    /**
    * @dev gets the reserve total borrows stable
    * @param _reserve the reserve address
    * @return the total borrows stable
    **/
    function getReserveTotalBorrowsStable(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.totalBorrowsStable;
    }

    /**
    * @dev gets the reserve total borrows variable
    * @param _reserve the reserve address
    * @return the total borrows variable
    **/

    function getReserveTotalBorrowsVariable(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.totalBorrowsVariable;
    }

    /**
    * @dev gets the reserve liquidation threshold
    * @param _reserve the reserve address
    * @return the reserve liquidation threshold
    **/

    function getReserveLiquidationThreshold(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.liquidationThreshold;
    }

    /**
    * @dev gets the reserve liquidation bonus
    * @param _reserve the reserve address
    * @return the reserve liquidation bonus
    **/

    function getReserveLiquidationBonus(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.liquidationBonus;
    }

    /**
    * @dev gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty
    * @param _reserve the reserve address
    * @return the reserve current variable borrow rate
    **/

    function getReserveCurrentVariableBorrowRate(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        if (reserve.currentVariableBorrowRate == 0) {
            return
            IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)
            .getBaseVariableBorrowRate();
        }
        return reserve.currentVariableBorrowRate;
    }

    /**
    * @dev gets the reserve current stable borrow rate. Is the market rate if the reserve is empty
    * @param _reserve the reserve address
    * @return the reserve current stable borrow rate
    **/

    function getReserveCurrentStableBorrowRate(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        ILendingRateOracle oracle = ILendingRateOracle(addressesProvider.getLendingRateOracle());

        if (reserve.currentStableBorrowRate == 0) {
            //no stable rate borrows yet
            return oracle.getMarketBorrowRate(_reserve);
        }

        return reserve.currentStableBorrowRate;
    }

    /**
    * @dev gets the reserve average stable borrow rate. The average stable rate is the weighted average
    * of all the loans taken at stable rate.
    * @param _reserve the reserve address
    * @return the reserve current average borrow rate
    **/
    function getReserveCurrentAverageStableBorrowRate(address _reserve)
    external
    view
    returns (uint256)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.currentAverageStableBorrowRate;
    }

    /**
    * @dev gets the reserve liquidity rate
    * @param _reserve the reserve address
    * @return the reserve liquidity rate
    **/
    function getReserveCurrentLiquidityRate(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.currentLiquidityRate;
    }

    /**
    * @dev gets the reserve liquidity cumulative index
    * @param _reserve the reserve address
    * @return the reserve liquidity cumulative index
    **/
    function getReserveLiquidityCumulativeIndex(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.lastLiquidityCumulativeIndex;
    }

    /**
    * @dev gets the reserve variable borrow index
    * @param _reserve the reserve address
    * @return the reserve variable borrow index
    **/
    function getReserveVariableBorrowsCumulativeIndex(address _reserve)
    external
    view
    returns (uint256)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.lastVariableBorrowCumulativeIndex;
    }

    /**
    * @dev this function aggregates the configuration parameters of the reserve.
    * It's used in the LendingPoolDataProvider specifically to save gas, and avoid
    * multiple external contract calls to fetch the same data.
    * @param _reserve the reserve address
    * @return the reserve decimals
    * @return the base ltv as collateral
    * @return the liquidation threshold
    * @return if the reserve is used as collateral or not
    **/
    function getReserveConfiguration(address _reserve)
    external
    view
    returns (uint256, uint256, uint256, bool)
    {
        uint256 decimals;
        uint256 baseLTVasCollateral;
        uint256 liquidationThreshold;
        bool usageAsCollateralEnabled;

        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        decimals = reserve.decimals;
        baseLTVasCollateral = reserve.baseLTVasCollateral;
        liquidationThreshold = reserve.liquidationThreshold;
        usageAsCollateralEnabled = reserve.usageAsCollateralEnabled;

        return (decimals, baseLTVasCollateral, liquidationThreshold, usageAsCollateralEnabled);
    }

    /**
    * @dev returns the decimals of the reserve
    * @param _reserve the reserve address
    * @return the reserve decimals
    **/
    function getReserveDecimals(address _reserve) external view returns (uint256) {
        return reserves[_reserve].decimals;
    }

    /**
    * @dev returns true if the reserve is enabled for borrowing
    * @param _reserve the reserve address
    * @return true if the reserve is enabled for borrowing, false otherwise
    **/

    function isReserveBorrowingEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.borrowingEnabled;
    }

    /**
    * @dev returns true if the reserve is enabled as collateral
    * @param _reserve the reserve address
    * @return true if the reserve is enabled as collateral, false otherwise
    **/

    function isReserveUsageAsCollateralEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.usageAsCollateralEnabled;
    }

    /**
    * @dev returns true if the stable rate is enabled on reserve
    * @param _reserve the reserve address
    * @return true if the stable rate is enabled on reserve, false otherwise
    **/
    function getReserveIsStableBorrowRateEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isStableBorrowRateEnabled;
    }

    /**
    * @dev returns true if the reserve is active
    * @param _reserve the reserve address
    * @return true if the reserve is active, false otherwise
    **/
    function getReserveIsActive(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isActive;
    }

    /**
    * @notice returns if a reserve is freezed
    * @param _reserve the reserve for which the information is needed
    * @return true if the reserve is freezed, false otherwise
    **/

    function getReserveIsFreezed(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isFreezed;
    }

    /**
    * @notice returns the timestamp of the last action on the reserve
    * @param _reserve the reserve for which the information is needed
    * @return the last updated timestamp of the reserve
    **/

    function getReserveLastUpdate(address _reserve) external view returns (uint40 timestamp) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        timestamp = reserve.lastUpdateTimestamp;
    }

    /**
    * @dev returns the utilization rate U of a specific reserve
    * @param _reserve the reserve for which the information is needed
    * @return the utilization rate in ray
    **/

    function getReserveUtilizationRate(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        uint256 totalBorrows = reserve.getTotalBorrows();

        if (totalBorrows == 0) {
            return 0;
        }

        uint256 availableLiquidity = getReserveAvailableLiquidity(_reserve);

        return totalBorrows.rayDiv(availableLiquidity.add(totalBorrows));
    }

    /**
    * @return the array of reserves configured on the core
    **/
    function getReserves() external view returns (address[] memory) {
        return reservesList;
    }

    /**
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return true if the user has chosen to use the reserve as collateral, false otherwise
    **/
    function isUserUseReserveAsCollateralEnabled(address _reserve, address _user)
    external
    view
    returns (bool)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.useAsCollateral;
    }

    /**
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the origination fee for the user
    **/
    function getUserOriginationFee(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.originationFee;
    }

    /**
    * @dev users with no loans in progress have NONE as borrow rate mode
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the borrow rate mode for the user,
    **/

    function getUserCurrentBorrowRateMode(address _reserve, address _user)
    public
    view
    returns (CoreLibrary.InterestRateMode)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (user.principalBorrowBalance == 0) {
            return CoreLibrary.InterestRateMode.NONE;
        }

        return
        user.stableBorrowRate > 0
        ? CoreLibrary.InterestRateMode.STABLE
        : CoreLibrary.InterestRateMode.VARIABLE;
    }

    /**
    * @dev gets the current borrow rate of the user
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the borrow rate for the user,
    **/
    function getUserCurrentBorrowRate(address _reserve, address _user)
    internal
    view
    returns (uint256)
    {
        CoreLibrary.InterestRateMode rateMode = getUserCurrentBorrowRateMode(_reserve, _user);

        if (rateMode == CoreLibrary.InterestRateMode.NONE) {
            return 0;
        }

        return
        rateMode == CoreLibrary.InterestRateMode.STABLE
        ? usersReserveData[_user][_reserve].stableBorrowRate
        : reserves[_reserve].currentVariableBorrowRate;
    }

    /**
    * @dev the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the user stable rate
    **/
    function getUserCurrentStableBorrowRate(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.stableBorrowRate;
    }

    /**
    * @dev calculates and returns the borrow balances of the user
    * @param _reserve the address of the reserve
    * @param _user the address of the user
    * @return the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance
    **/

    function getUserBorrowBalances(address _reserve, address _user)
    public
    view
    returns (uint256, uint256, uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        if (user.principalBorrowBalance == 0) {
            return (0, 0, 0);
        }

        uint256 principal = user.principalBorrowBalance;
        uint256 compoundedBalance = CoreLibrary.getCompoundedBorrowBalance(
            user,
            reserves[_reserve]
        );
        return (principal, compoundedBalance, compoundedBalance.sub(principal));
    }

    /**
    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the variable borrow index for the user
    **/

    function getUserVariableBorrowCumulativeIndex(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.lastVariableBorrowCumulativeIndex;
    }

    /**
    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the variable borrow index for the user
    **/

    function getUserLastUpdate(address _reserve, address _user)
    external
    view
    returns (uint256 timestamp)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        timestamp = user.lastUpdateTimestamp;
    }

    /**
    * @dev updates the lending pool core configuration
    **/
    function refreshConfiguration() external onlyLendingPoolConfigurator {
        refreshConfigInternal();
    }

    /**
    * @dev initializes a reserve
    * @param _reserve the address of the reserve
    * @param _aTokenAddress the address of the overlying aToken contract
    * @param _decimals the decimals of the reserve currency
    * @param _interestRateStrategyAddress the address of the interest rate strategy contract
    **/
    function initReserve(
        address _reserve,
        address _aTokenAddress,
        uint256 _decimals,
        address _interestRateStrategyAddress
    ) external onlyLendingPoolConfigurator {
        reserves[_reserve].init(_aTokenAddress, _decimals, _interestRateStrategyAddress);
        addReserveToListInternal(_reserve);

    }



    /**
    * @dev removes the last added reserve in the reservesList array
    * @param _reserveToRemove the address of the reserve
    **/
    function removeLastAddedReserve(address _reserveToRemove)
    external onlyLendingPoolConfigurator {

        address lastReserve = reservesList[reservesList.length-1];

        require(lastReserve == _reserveToRemove, "Reserve being removed is different than the reserve requested");

        //as we can't check if totalLiquidity is 0 (since the reserve added might not be an ERC20) we at least check that there is nothing borrowed
        require(getReserveTotalBorrows(lastReserve) == 0, "Cannot remove a reserve with liquidity deposited");

        reserves[lastReserve].isActive = false;
        reserves[lastReserve].aTokenAddress = address(0);
        reserves[lastReserve].decimals = 0;
        reserves[lastReserve].lastLiquidityCumulativeIndex = 0;
        reserves[lastReserve].lastVariableBorrowCumulativeIndex = 0;
        reserves[lastReserve].borrowingEnabled = false;
        reserves[lastReserve].usageAsCollateralEnabled = false;
        reserves[lastReserve].baseLTVasCollateral = 0;
        reserves[lastReserve].liquidationThreshold = 0;
        reserves[lastReserve].liquidationBonus = 0;
        reserves[lastReserve].interestRateStrategyAddress = address(0);

        reservesList.pop();
    }

    /**
    * @dev updates the address of the interest rate strategy contract
    * @param _reserve the address of the reserve
    * @param _rateStrategyAddress the address of the interest rate strategy contract
    **/

    function setReserveInterestRateStrategyAddress(address _reserve, address _rateStrategyAddress)
    external
    onlyLendingPoolConfigurator
    {
        reserves[_reserve].interestRateStrategyAddress = _rateStrategyAddress;
    }

    /**
    * @dev enables borrowing on a reserve. Also sets the stable rate borrowing
    * @param _reserve the address of the reserve
    * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise
    **/

    function enableBorrowingOnReserve(address _reserve, bool _stableBorrowRateEnabled)
    external
    onlyLendingPoolConfigurator
    {
        reserves[_reserve].enableBorrowing(_stableBorrowRateEnabled);
    }

    /**
    * @dev disables borrowing on a reserve
    * @param _reserve the address of the reserve
    **/

    function disableBorrowingOnReserve(address _reserve) external onlyLendingPoolConfigurator {
        reserves[_reserve].disableBorrowing();
    }

    /**
    * @dev enables a reserve to be used as collateral
    * @param _reserve the address of the reserve
    **/
    function enableReserveAsCollateral(
        address _reserve,
        uint256 _baseLTVasCollateral,
        uint256 _liquidationThreshold,
        uint256 _liquidationBonus
    ) external onlyLendingPoolConfigurator {
        reserves[_reserve].enableAsCollateral(
            _baseLTVasCollateral,
            _liquidationThreshold,
            _liquidationBonus
        );
    }

    /**
    * @dev disables a reserve to be used as collateral
    * @param _reserve the address of the reserve
    **/
    function disableReserveAsCollateral(address _reserve) external onlyLendingPoolConfigurator {
        reserves[_reserve].disableAsCollateral();
    }

    /**
    * @dev enable the stable borrow rate mode on a reserve
    * @param _reserve the address of the reserve
    **/
    function enableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isStableBorrowRateEnabled = true;
    }

    /**
    * @dev disable the stable borrow rate mode on a reserve
    * @param _reserve the address of the reserve
    **/
    function disableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isStableBorrowRateEnabled = false;
    }

    /**
    * @dev activates a reserve
    * @param _reserve the address of the reserve
    **/
    function activateReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        require(
            reserve.lastLiquidityCumulativeIndex > 0 &&
            reserve.lastVariableBorrowCumulativeIndex > 0,
            "Reserve has not been initialized yet"
        );
        reserve.isActive = true;
    }

    /**
    * @dev deactivates a reserve
    * @param _reserve the address of the reserve
    **/
    function deactivateReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isActive = false;
    }

    /**
    * @notice allows the configurator to freeze the reserve.
    * A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance.
    * @param _reserve the address of the reserve
    **/
    function freezeReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isFreezed = true;
    }

    /**
    * @notice allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed.
    * @param _reserve the address of the reserve
    **/
    function unfreezeReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isFreezed = false;
    }

    /**
    * @notice allows the configurator to update the loan to value of a reserve
    * @param _reserve the address of the reserve
    * @param _ltv the new loan to value
    **/
    function setReserveBaseLTVasCollateral(address _reserve, uint256 _ltv)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.baseLTVasCollateral = _ltv;
    }

    /**
    * @notice allows the configurator to update the liquidation threshold of a reserve
    * @param _reserve the address of the reserve
    * @param _threshold the new liquidation threshold
    **/
    function setReserveLiquidationThreshold(address _reserve, uint256 _threshold)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.liquidationThreshold = _threshold;
    }

    /**
    * @notice allows the configurator to update the liquidation bonus of a reserve
    * @param _reserve the address of the reserve
    * @param _bonus the new liquidation bonus
    **/
    function setReserveLiquidationBonus(address _reserve, uint256 _bonus)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.liquidationBonus = _bonus;
    }

    /**
    * @notice allows the configurator to update the reserve decimals
    * @param _reserve the address of the reserve
    * @param _decimals the decimals of the reserve
    **/
    function setReserveDecimals(address _reserve, uint256 _decimals)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.decimals = _decimals;
    }

    /**
    * @notice internal functions
    **/

    /**
    * @dev updates the state of a reserve as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the previous borrow balance of the borrower before the action
    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount
    * @param _amountBorrowed the new amount borrowed
    * @param _rateMode the borrow rate mode (stable, variable)
    **/

    function updateReserveStateOnBorrowInternal(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _balanceIncrease,
        uint256 _amountBorrowed,
        CoreLibrary.InterestRateMode _rateMode
    ) internal {
        reserves[_reserve].updateCumulativeIndexes();

        //increasing reserve total borrows to account for the new borrow balance of the user
        //NOTE: Depending on the previous borrow mode, the borrows might need to be switched from variable to stable or vice versa

        updateReserveTotalBorrowsByRateModeInternal(
            _reserve,
            _user,
            _principalBorrowBalance,
            _balanceIncrease,
            _amountBorrowed,
            _rateMode
        );
    }

    /**
    * @dev updates the state of a user as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _amountBorrowed the amount borrowed
    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount
    * @param _rateMode the borrow rate mode (stable, variable)
    * @return the final borrow rate for the user. Emitted by the borrow() event
    **/

    function updateUserStateOnBorrowInternal(
        address _reserve,
        address _user,
        uint256 _amountBorrowed,
        uint256 _balanceIncrease,
        uint256 _fee,
        CoreLibrary.InterestRateMode _rateMode
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (_rateMode == CoreLibrary.InterestRateMode.STABLE) {
            //stable
            //reset the user variable index, and update the stable rate
            user.stableBorrowRate = reserve.currentStableBorrowRate;
            user.lastVariableBorrowCumulativeIndex = 0;
        } else if (_rateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //variable
            //reset the user stable rate, and store the new borrow index
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        } else {
            revert("Invalid borrow rate mode");
        }
        //increase the principal borrows and the origination fee
        user.principalBorrowBalance = user.principalBorrowBalance.add(_amountBorrowed).add(
            _balanceIncrease
        );
        user.originationFee = user.originationFee.add(_fee);

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

    }

    /**
    * @dev updates the state of the reserve as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateReserveStateOnRepayInternal(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_reserve][_user];

        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(_reserve, _user);

        //update the indexes
        reserves[_reserve].updateCumulativeIndexes();

        //compound the cumulated interest to the borrow balance and then subtracting the payback amount
        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _balanceIncrease,
                user.stableBorrowRate
            );
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _paybackAmountMinusFees,
                user.stableBorrowRate
            );
        } else {
            reserve.increaseTotalBorrowsVariable(_balanceIncrease);
            reserve.decreaseTotalBorrowsVariable(_paybackAmountMinusFees);
        }
    }

    /**
    * @dev updates the state of the user as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _originationFeeRepaid the fee on the amount that is being repaid
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _repaidWholeLoan true if the user is repaying the whole loan
    **/
    function updateUserStateOnRepayInternal(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _originationFeeRepaid,
        uint256 _balanceIncrease,
        bool _repaidWholeLoan
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        //update the user principal borrow balance, adding the cumulated interest and then subtracting the payback amount
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(
            _paybackAmountMinusFees
        );
        user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;

        //if the balance decrease is equal to the previous principal (user is repaying the whole loan)
        //and the rate mode is stable, we reset the interest rate mode of the user
        if (_repaidWholeLoan) {
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = 0;
        }
        user.originationFee = user.originationFee.sub(_originationFeeRepaid);

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

    }

    /**
    * @dev updates the state of the user as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is performing the rate swap
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the the principal amount borrowed by the user
    * @param _compoundedBorrowBalance the principal amount plus the accrued interest
    * @param _currentRateMode the rate mode at which the user borrowed
    **/
    function updateReserveStateOnSwapRateInternal(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _compoundedBorrowBalance,
        CoreLibrary.InterestRateMode _currentRateMode
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        //compounding reserve indexes
        reserve.updateCumulativeIndexes();

        if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {
            uint256 userCurrentStableRate = user.stableBorrowRate;

            //swap to variable
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _principalBorrowBalance,
                userCurrentStableRate
            ); //decreasing stable from old principal balance
            reserve.increaseTotalBorrowsVariable(_compoundedBorrowBalance); //increase variable borrows
        } else if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //swap to stable
            uint256 currentStableRate = reserve.currentStableBorrowRate;
            reserve.decreaseTotalBorrowsVariable(_principalBorrowBalance);
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _compoundedBorrowBalance,
                currentStableRate
            );

        } else {
            revert("Invalid rate mode received");
        }
    }

    /**
    * @dev updates the state of the user as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is performing the swap
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _currentRateMode the current rate mode of the user
    **/

    function updateUserStateOnSwapRateInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease,
        CoreLibrary.InterestRateMode _currentRateMode
    ) internal returns (CoreLibrary.InterestRateMode) {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        CoreLibrary.InterestRateMode newMode = CoreLibrary.InterestRateMode.NONE;

        if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //switch to stable
            newMode = CoreLibrary.InterestRateMode.STABLE;
            user.stableBorrowRate = reserve.currentStableBorrowRate;
            user.lastVariableBorrowCumulativeIndex = 0;
        } else if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {
            newMode = CoreLibrary.InterestRateMode.VARIABLE;
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        } else {
            revert("Invalid interest rate mode received");
        }
        //compounding cumulated interest
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);
        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

        return newMode;
    }

    /**
    * @dev updates the state of the principal reserve as a consequence of a liquidation action.
    * @param _principalReserve the address of the principal reserve that is being repaid
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updatePrincipalReserveStateOnLiquidationInternal(
        address _principalReserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_principalReserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_principalReserve];

        //update principal reserve data
        reserve.updateCumulativeIndexes();

        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(
            _principalReserve,
            _user
        );

        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            //increase the total borrows by the compounded interest
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _balanceIncrease,
                user.stableBorrowRate
            );

            //decrease by the actual amount to liquidate
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _amountToLiquidate,
                user.stableBorrowRate
            );

        } else {
            //increase the total borrows by the compounded interest
            reserve.increaseTotalBorrowsVariable(_balanceIncrease);

            //decrease by the actual amount to liquidate
            reserve.decreaseTotalBorrowsVariable(_amountToLiquidate);
        }

    }

    /**
    * @dev updates the state of the collateral reserve as a consequence of a liquidation action.
    * @param _collateralReserve the address of the collateral reserve that is being liquidated
    **/
    function updateCollateralReserveStateOnLiquidationInternal(
        address _collateralReserve
    ) internal {
        //update collateral reserve
        reserves[_collateralReserve].updateCumulativeIndexes();

    }

    /**
    * @dev updates the state of the user being liquidated as a consequence of a liquidation action.
    * @param _reserve the address of the principal reserve that is being repaid
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _feeLiquidated the amount of origination fee being liquidated
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/
    function updateUserStateOnLiquidationInternal(
        address _reserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _feeLiquidated,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        //first increase by the compounded interest, then decrease by the liquidated amount
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(
            _amountToLiquidate
        );

        if (
            getUserCurrentBorrowRateMode(_reserve, _user) == CoreLibrary.InterestRateMode.VARIABLE
        ) {
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        }

        if(_feeLiquidated > 0){
            user.originationFee = user.originationFee.sub(_feeLiquidated);
        }

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);
    }

    /**
    * @dev updates the state of the reserve as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateReserveStateOnRebalanceInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        reserve.updateCumulativeIndexes();

        reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
            _balanceIncrease,
            user.stableBorrowRate
        );

    }

    /**
    * @dev updates the state of the user as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateUserStateOnRebalanceInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);
        user.stableBorrowRate = reserve.currentStableBorrowRate;

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);
    }

    /**
    * @dev updates the state of the user as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _amountBorrowed the accrued interest on the borrowed amount
    **/
    function updateReserveTotalBorrowsByRateModeInternal(
        address _reserve,
        address _user,
        uint256 _principalBalance,
        uint256 _balanceIncrease,
        uint256 _amountBorrowed,
        CoreLibrary.InterestRateMode _newBorrowRateMode
    ) internal {
        CoreLibrary.InterestRateMode previousRateMode = getUserCurrentBorrowRateMode(
            _reserve,
            _user
        );
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        if (previousRateMode == CoreLibrary.InterestRateMode.STABLE) {
            CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _principalBalance,
                user.stableBorrowRate
            );
        } else if (previousRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            reserve.decreaseTotalBorrowsVariable(_principalBalance);
        }

        uint256 newPrincipalAmount = _principalBalance.add(_balanceIncrease).add(_amountBorrowed);
        if (_newBorrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                newPrincipalAmount,
                reserve.currentStableBorrowRate
            );
        } else if (_newBorrowRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            reserve.increaseTotalBorrowsVariable(newPrincipalAmount);
        } else {
            revert("Invalid new borrow rate mode");
        }
    }

    /**
    * @dev Updates the reserve current stable borrow rate Rf, the current variable borrow rate Rv and the current liquidity rate Rl.
    * Also updates the lastUpdateTimestamp value. Please refer to the whitepaper for further information.
    * @param _reserve the address of the reserve to be updated
    * @param _liquidityAdded the amount of liquidity added to the protocol (deposit or repay) in the previous action
    * @param _liquidityTaken the amount of liquidity taken from the protocol (redeem or borrow)
    **/

    function updateReserveInterestRatesAndTimestampInternal(
        address _reserve,
        uint256 _liquidityAdded,
        uint256 _liquidityTaken
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        (uint256 newLiquidityRate, uint256 newStableRate, uint256 newVariableRate) = IReserveInterestRateStrategy(
            reserve
            .interestRateStrategyAddress
        )
        .calculateInterestRates(
            _reserve,
            getReserveAvailableLiquidity(_reserve).add(_liquidityAdded).sub(_liquidityTaken),
            reserve.totalBorrowsStable,
            reserve.totalBorrowsVariable,
            reserve.currentAverageStableBorrowRate
        );

        reserve.currentLiquidityRate = newLiquidityRate;
        reserve.currentStableBorrowRate = newStableRate;
        reserve.currentVariableBorrowRate = newVariableRate;

        //solium-disable-next-line
        reserve.lastUpdateTimestamp = uint40(block.timestamp);

        emit ReserveUpdated(
            _reserve,
            newLiquidityRate,
            newStableRate,
            newVariableRate,
            reserve.lastLiquidityCumulativeIndex,
            reserve.lastVariableBorrowCumulativeIndex
        );
    }

    /**
    * @dev transfers to the protocol fees of a flashloan to the fees collection address
    * @param _token the address of the token being transferred
    * @param _amount the amount being transferred
    **/

    function transferFlashLoanProtocolFeeInternal(address _token, uint256 _amount) internal {
        address payable receiver = address(uint160(addressesProvider.getTokenDistributor()));

        if (_token != EthAddressLib.ethAddress()) {
            ERC20(_token).safeTransfer(receiver, _amount);
        } else {
            receiver.transfer(_amount);
        }
    }

    /**
    * @dev updates the internal configuration of the core
    **/
    function refreshConfigInternal() internal {
        lendingPoolAddress = addressesProvider.getLendingPool();
    }

    /**
    * @dev adds a reserve to the array of the reserves address
    **/
    function addReserveToListInternal(address _reserve) internal {
        bool reserveAlreadyAdded = false;
        for (uint256 i = 0; i < reservesList.length; i++)
            if (reservesList[i] == _reserve) {
                reserveAlreadyAdded = true;
            }
        if (!reserveAlreadyAdded) reservesList.push(_reserve);
    }

}
".

As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.

Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

[2024-01-09 04:31:16 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 04:31:16 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 28829
completion_tokens: 1
total_tokens: 28830
cost: $-1.000000


[2024-01-09 04:31:16 INFO] Security Analyst: **Security Analyst<->Chief Executive Officer on : ContractAnalysis, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: pragma solidity ^0.5.0;

import "openzeppelin-solidity/contracts/math/SafeMath.sol";
import "openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol";
import "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol";
import "openzeppelin-solidity/contracts/utils/Address.sol";
import "../libraries/openzeppelin-upgradeability/VersionedInitializable.sol";

import "../libraries/CoreLibrary.sol";
import "../configuration/LendingPoolAddressesProvider.sol";
import "../interfaces/ILendingRateOracle.sol";
import "../interfaces/IReserveInterestRateStrategy.sol";
import "../libraries/WadRayMath.sol";
import "../tokenization/AToken.sol";
import "../libraries/EthAddressLib.sol";

/**
* @title LendingPoolCore contract
* @author Aave
* @notice Holds the state of the lending pool and all the funds deposited
* @dev NOTE: The core does not enforce security checks on the update of the state
* (eg, updateStateOnBorrow() does not enforce that borrowed is enabled on the reserve).
* The check that an action can be performed is a duty of the overlying LendingPool contract.
**/

contract LendingPoolCore is VersionedInitializable {
    using SafeMath for uint256;
    using WadRayMath for uint256;
    using CoreLibrary for CoreLibrary.ReserveData;
    using CoreLibrary for CoreLibrary.UserReserveData;
    using SafeERC20 for ERC20;
    using Address for address payable;

    /**
    * @dev Emitted when the state of a reserve is updated
    * @param reserve the address of the reserve
    * @param liquidityRate the new liquidity rate
    * @param stableBorrowRate the new stable borrow rate
    * @param variableBorrowRate the new variable borrow rate
    * @param liquidityIndex the new liquidity index
    * @param variableBorrowIndex the new variable borrow index
    **/
    event ReserveUpdated(
        address indexed reserve,
        uint256 liquidityRate,
        uint256 stableBorrowRate,
        uint256 variableBorrowRate,
        uint256 liquidityIndex,
        uint256 variableBorrowIndex
    );

    address public lendingPoolAddress;

    LendingPoolAddressesProvider public addressesProvider;

    /**
    * @dev only lending pools can use functions affected by this modifier
    **/
    modifier onlyLendingPool {
        require(lendingPoolAddress == msg.sender, "The caller must be a lending pool contract");
        _;
    }

    /**
    * @dev only lending pools configurator can use functions affected by this modifier
    **/
    modifier onlyLendingPoolConfigurator {
        require(
            addressesProvider.getLendingPoolConfigurator() == msg.sender,
            "The caller must be a lending pool configurator contract"
        );
        _;
    }

    mapping(address => CoreLibrary.ReserveData) internal reserves;
    mapping(address => mapping(address => CoreLibrary.UserReserveData)) internal usersReserveData;

    address[] public reservesList;

    uint256 public constant CORE_REVISION = 0x4;

    /**
    * @dev returns the revision number of the contract
    **/
    function getRevision() internal pure returns (uint256) {
        return CORE_REVISION;
    }

    /**
    * @dev initializes the Core contract, invoked upon registration on the AddressesProvider
    * @param _addressesProvider the addressesProvider contract
    **/

    function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {
        addressesProvider = _addressesProvider;
        refreshConfigInternal();
    }

    /**
    * @dev updates the state of the core as a result of a deposit action
    * @param _reserve the address of the reserve in which the deposit is happening
    * @param _user the address of the the user depositing
    * @param _amount the amount being deposited
    * @param _isFirstDeposit true if the user is depositing for the first time
    **/

    function updateStateOnDeposit(
        address _reserve,
        address _user,
        uint256 _amount,
        bool _isFirstDeposit
    ) external onlyLendingPool {
        reserves[_reserve].updateCumulativeIndexes();
        updateReserveInterestRatesAndTimestampInternal(_reserve, _amount, 0);

        if (_isFirstDeposit) {
            //if this is the first deposit of the user, we configure the deposit as enabled to be used as collateral
            setUserUseReserveAsCollateral(_reserve, _user, true);
        }
    }

    /**
    * @dev updates the state of the core as a result of a redeem action
    * @param _reserve the address of the reserve in which the redeem is happening
    * @param _user the address of the the user redeeming
    * @param _amountRedeemed the amount being redeemed
    * @param _userRedeemedEverything true if the user is redeeming everything
    **/
    function updateStateOnRedeem(
        address _reserve,
        address _user,
        uint256 _amountRedeemed,
        bool _userRedeemedEverything
    ) external onlyLendingPool {
        //compound liquidity and variable borrow interests
        reserves[_reserve].updateCumulativeIndexes();
        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountRedeemed);

        //if user redeemed everything the useReserveAsCollateral flag is reset
        if (_userRedeemedEverything) {
            setUserUseReserveAsCollateral(_reserve, _user, false);
        }
    }

    /**
    * @dev updates the state of the core as a result of a flashloan action
    * @param _reserve the address of the reserve in which the flashloan is happening
    * @param _income the income of the protocol as a result of the action
    **/
    function updateStateOnFlashLoan(
        address _reserve,
        uint256 _availableLiquidityBefore,
        uint256 _income,
        uint256 _protocolFee
    ) external onlyLendingPool {
        transferFlashLoanProtocolFeeInternal(_reserve, _protocolFee);

        //compounding the cumulated interest
        reserves[_reserve].updateCumulativeIndexes();

        uint256 totalLiquidityBefore = _availableLiquidityBefore.add(
            getReserveTotalBorrows(_reserve)
        );

        //compounding the received fee into the reserve
        reserves[_reserve].cumulateToLiquidityIndex(totalLiquidityBefore, _income);

        //refresh interest rates
        updateReserveInterestRatesAndTimestampInternal(_reserve, _income, 0);
    }

    /**
    * @dev updates the state of the core as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _amountBorrowed the new amount borrowed
    * @param _borrowFee the fee on the amount borrowed
    * @param _rateMode the borrow rate mode (stable, variable)
    * @return the new borrow rate for the user
    **/
    function updateStateOnBorrow(
        address _reserve,
        address _user,
        uint256 _amountBorrowed,
        uint256 _borrowFee,
        CoreLibrary.InterestRateMode _rateMode
    ) external onlyLendingPool returns (uint256, uint256) {
        // getting the previous borrow data of the user
        (uint256 principalBorrowBalance, , uint256 balanceIncrease) = getUserBorrowBalances(
            _reserve,
            _user
        );

        updateReserveStateOnBorrowInternal(
            _reserve,
            _user,
            principalBorrowBalance,
            balanceIncrease,
            _amountBorrowed,
            _rateMode
        );

        updateUserStateOnBorrowInternal(
            _reserve,
            _user,
            _amountBorrowed,
            balanceIncrease,
            _borrowFee,
            _rateMode
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountBorrowed);

        return (getUserCurrentBorrowRate(_reserve, _user), balanceIncrease);
    }

    /**
    * @dev updates the state of the core as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _originationFeeRepaid the fee on the amount that is being repaid
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _repaidWholeLoan true if the user is repaying the whole loan
    **/

    function updateStateOnRepay(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _originationFeeRepaid,
        uint256 _balanceIncrease,
        bool _repaidWholeLoan
    ) external onlyLendingPool {
        updateReserveStateOnRepayInternal(
            _reserve,
            _user,
            _paybackAmountMinusFees,
            _balanceIncrease
        );
        updateUserStateOnRepayInternal(
            _reserve,
            _user,
            _paybackAmountMinusFees,
            _originationFeeRepaid,
            _balanceIncrease,
            _repaidWholeLoan
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, _paybackAmountMinusFees, 0);
    }

    /**
    * @dev updates the state of the core as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the amount borrowed by the user
    * @param _compoundedBorrowBalance the amount borrowed plus accrued interest
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _currentRateMode the current interest rate mode for the user
    **/
    function updateStateOnSwapRate(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _compoundedBorrowBalance,
        uint256 _balanceIncrease,
        CoreLibrary.InterestRateMode _currentRateMode
    ) external onlyLendingPool returns (CoreLibrary.InterestRateMode, uint256) {
        updateReserveStateOnSwapRateInternal(
            _reserve,
            _user,
            _principalBorrowBalance,
            _compoundedBorrowBalance,
            _currentRateMode
        );

        CoreLibrary.InterestRateMode newRateMode = updateUserStateOnSwapRateInternal(
            _reserve,
            _user,
            _balanceIncrease,
            _currentRateMode
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);

        return (newRateMode, getUserCurrentBorrowRate(_reserve, _user));
    }

    /**
    * @dev updates the state of the core as a consequence of a liquidation action.
    * @param _principalReserve the address of the principal reserve that is being repaid
    * @param _collateralReserve the address of the collateral reserve that is being liquidated
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _collateralToLiquidate the amount of collateral being liquidated
    * @param _feeLiquidated the amount of origination fee being liquidated
    * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise
    **/
    function updateStateOnLiquidation(
        address _principalReserve,
        address _collateralReserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _collateralToLiquidate,
        uint256 _feeLiquidated,
        uint256 _liquidatedCollateralForFee,
        uint256 _balanceIncrease,
        bool _liquidatorReceivesAToken
    ) external onlyLendingPool {
        updatePrincipalReserveStateOnLiquidationInternal(
            _principalReserve,
            _user,
            _amountToLiquidate,
            _balanceIncrease
        );

        updateCollateralReserveStateOnLiquidationInternal(
            _collateralReserve
        );

        updateUserStateOnLiquidationInternal(
            _principalReserve,
            _user,
            _amountToLiquidate,
            _feeLiquidated,
            _balanceIncrease
        );

        updateReserveInterestRatesAndTimestampInternal(_principalReserve, _amountToLiquidate, 0);

        if (!_liquidatorReceivesAToken) {
            updateReserveInterestRatesAndTimestampInternal(
                _collateralReserve,
                0,
                _collateralToLiquidate.add(_liquidatedCollateralForFee)
            );
        }

    }

    /**
    * @dev updates the state of the core as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @return the new stable rate for the user
    **/
    function updateStateOnRebalance(address _reserve, address _user, uint256 _balanceIncrease)
    external
    onlyLendingPool
    returns (uint256)
    {
        updateReserveStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);

        //update user data and rebalance the rate
        updateUserStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);
        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);
        return usersReserveData[_user][_reserve].stableBorrowRate;
    }

    /**
    * @dev enables or disables a reserve as collateral
    * @param _reserve the address of the principal reserve where the user deposited
    * @param _user the address of the depositor
    * @param _useAsCollateral true if the depositor wants to use the reserve as collateral
    **/
    function setUserUseReserveAsCollateral(address _reserve, address _user, bool _useAsCollateral)
    public
    onlyLendingPool
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        user.useAsCollateral = _useAsCollateral;
    }

    /**
    * @notice ETH/token transfer functions
    **/

    /**
    * @dev fallback function enforces that the caller is a contract, to support flashloan transfers
    **/
    function() external payable {
        //only contracts can send ETH to the core
        require(msg.sender.isContract(), "Only contracts can send ether to the Lending pool core");

    }

    /**
    * @dev transfers to the user a specific amount from the reserve.
    * @param _reserve the address of the reserve where the transfer is happening
    * @param _user the address of the user receiving the transfer
    * @param _amount the amount being transferred
    **/
    function transferToUser(address _reserve, address payable _user, uint256 _amount)
    external
    onlyLendingPool
    {
        if (_reserve != EthAddressLib.ethAddress()) {
            ERC20(_reserve).safeTransfer(_user, _amount);
        } else {
            //solium-disable-next-line
            (bool result, ) = _user.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers the protocol fees to the fees collection address
    * @param _token the address of the token being transferred
    * @param _user the address of the user from where the transfer is happening
    * @param _amount the amount being transferred
    * @param _destination the fee receiver address
    **/

    function transferToFeeCollectionAddress(
        address _token,
        address _user,
        uint256 _amount,
        address _destination
    ) external payable onlyLendingPool {
        address payable feeAddress = address(uint160(_destination)); //cast the address to payable

        if (_token != EthAddressLib.ethAddress()) {
            require(
                msg.value == 0,
                "User is sending ETH along with the ERC20 transfer. Check the value attribute of the transaction"
            );
            ERC20(_token).safeTransferFrom(_user, feeAddress, _amount);
        } else {
            require(msg.value >= _amount, "The amount and the value sent to deposit do not match");
            //solium-disable-next-line
            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers the fees to the fees collection address in the case of liquidation
    * @param _token the address of the token being transferred
    * @param _amount the amount being transferred
    * @param _destination the fee receiver address
    **/
    function liquidateFee(
        address _token,
        uint256 _amount,
        address _destination
    ) external payable onlyLendingPool {
        address payable feeAddress = address(uint160(_destination)); //cast the address to payable
        require(
            msg.value == 0,
            "Fee liquidation does not require any transfer of value"
        );

        if (_token != EthAddressLib.ethAddress()) {
            ERC20(_token).safeTransfer(feeAddress, _amount);
        } else {
            //solium-disable-next-line
            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers an amount from a user to the destination reserve
    * @param _reserve the address of the reserve where the amount is being transferred
    * @param _user the address of the user from where the transfer is happening
    * @param _amount the amount being transferred
    **/
    function transferToReserve(address _reserve, address payable _user, uint256 _amount)
    external
    payable
    onlyLendingPool
    {
        if (_reserve != EthAddressLib.ethAddress()) {
            require(msg.value == 0, "User is sending ETH along with the ERC20 transfer.");
            ERC20(_reserve).safeTransferFrom(_user, address(this), _amount);

        } else {
            require(msg.value >= _amount, "The amount and the value sent to deposit do not match");

            if (msg.value > _amount) {
                //send back excess ETH
                uint256 excessAmount = msg.value.sub(_amount);
                //solium-disable-next-line
                (bool result, ) = _user.call.value(excessAmount).gas(50000)("");
                require(result, "Transfer of ETH failed");
            }
        }
    }

    /**
    * @notice data access functions
    **/

    /**
    * @dev returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral)
    * needed to calculate the global account data in the LendingPoolDataProvider
    * @param _reserve the address of the reserve
    * @param _user the address of the user
    * @return the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not
    **/
    function getUserBasicReserveData(address _reserve, address _user)
    external
    view
    returns (uint256, uint256, uint256, bool)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        uint256 underlyingBalance = getUserUnderlyingAssetBalance(_reserve, _user);

        if (user.principalBorrowBalance == 0) {
            return (underlyingBalance, 0, 0, user.useAsCollateral);
        }

        return (
        underlyingBalance,
        user.getCompoundedBorrowBalance(reserve),
        user.originationFee,
        user.useAsCollateral
        );
    }

    /**
    * @dev checks if a user is allowed to borrow at a stable rate
    * @param _reserve the reserve address
    * @param _user the user
    * @param _amount the amount the the user wants to borrow
    * @return true if the user is allowed to borrow at a stable rate, false otherwise
    **/

    function isUserAllowedToBorrowAtStable(address _reserve, address _user, uint256 _amount)
    external
    view
    returns (bool)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (!reserve.isStableBorrowRateEnabled) return false;

        return
        !user.useAsCollateral ||
        !reserve.usageAsCollateralEnabled ||
        _amount > getUserUnderlyingAssetBalance(_reserve, _user);
    }

    /**
    * @dev gets the underlying asset balance of a user based on the corresponding aToken balance.
    * @param _reserve the reserve address
    * @param _user the user address
    * @return the underlying deposit balance of the user
    **/

    function getUserUnderlyingAssetBalance(address _reserve, address _user)
    public
    view
    returns (uint256)
    {
        AToken aToken = AToken(reserves[_reserve].aTokenAddress);
        return aToken.balanceOf(_user);

    }

    /**
    * @dev gets the interest rate strategy contract address for the reserve
    * @param _reserve the reserve address
    * @return the address of the interest rate strategy contract
    **/
    function getReserveInterestRateStrategyAddress(address _reserve) public view returns (address) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.interestRateStrategyAddress;
    }

    /**
    * @dev gets the aToken contract address for the reserve
    * @param _reserve the reserve address
    * @return the address of the aToken contract
    **/

    function getReserveATokenAddress(address _reserve) public view returns (address) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.aTokenAddress;
    }

    /**
    * @dev gets the available liquidity in the reserve. The available liquidity is the balance of the core contract
    * @param _reserve the reserve address
    * @return the available liquidity
    **/
    function getReserveAvailableLiquidity(address _reserve) public view returns (uint256) {
        uint256 balance = 0;

        if (_reserve == EthAddressLib.ethAddress()) {
            balance = address(this).balance;
        } else {
            balance = IERC20(_reserve).balanceOf(address(this));
        }
        return balance;
    }

    /**
    * @dev gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows
    * @param _reserve the reserve address
    * @return the total liquidity
    **/
    function getReserveTotalLiquidity(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return getReserveAvailableLiquidity(_reserve).add(reserve.getTotalBorrows());
    }

    /**
    * @dev gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there
    * there has been 100% income.
    * @param _reserve the reserve address
    * @return the reserve normalized income
    **/
    function getReserveNormalizedIncome(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.getNormalizedIncome();
    }

    /**
    * @dev gets the reserve total borrows
    * @param _reserve the reserve address
    * @return the total borrows (stable + variable)
    **/
    function getReserveTotalBorrows(address _reserve) public view returns (uint256) {
        return reserves[_reserve].getTotalBorrows();
    }

    /**
    * @dev gets the reserve total borrows stable
    * @param _reserve the reserve address
    * @return the total borrows stable
    **/
    function getReserveTotalBorrowsStable(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.totalBorrowsStable;
    }

    /**
    * @dev gets the reserve total borrows variable
    * @param _reserve the reserve address
    * @return the total borrows variable
    **/

    function getReserveTotalBorrowsVariable(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.totalBorrowsVariable;
    }

    /**
    * @dev gets the reserve liquidation threshold
    * @param _reserve the reserve address
    * @return the reserve liquidation threshold
    **/

    function getReserveLiquidationThreshold(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.liquidationThreshold;
    }

    /**
    * @dev gets the reserve liquidation bonus
    * @param _reserve the reserve address
    * @return the reserve liquidation bonus
    **/

    function getReserveLiquidationBonus(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.liquidationBonus;
    }

    /**
    * @dev gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty
    * @param _reserve the reserve address
    * @return the reserve current variable borrow rate
    **/

    function getReserveCurrentVariableBorrowRate(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        if (reserve.currentVariableBorrowRate == 0) {
            return
            IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)
            .getBaseVariableBorrowRate();
        }
        return reserve.currentVariableBorrowRate;
    }

    /**
    * @dev gets the reserve current stable borrow rate. Is the market rate if the reserve is empty
    * @param _reserve the reserve address
    * @return the reserve current stable borrow rate
    **/

    function getReserveCurrentStableBorrowRate(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        ILendingRateOracle oracle = ILendingRateOracle(addressesProvider.getLendingRateOracle());

        if (reserve.currentStableBorrowRate == 0) {
            //no stable rate borrows yet
            return oracle.getMarketBorrowRate(_reserve);
        }

        return reserve.currentStableBorrowRate;
    }

    /**
    * @dev gets the reserve average stable borrow rate. The average stable rate is the weighted average
    * of all the loans taken at stable rate.
    * @param _reserve the reserve address
    * @return the reserve current average borrow rate
    **/
    function getReserveCurrentAverageStableBorrowRate(address _reserve)
    external
    view
    returns (uint256)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.currentAverageStableBorrowRate;
    }

    /**
    * @dev gets the reserve liquidity rate
    * @param _reserve the reserve address
    * @return the reserve liquidity rate
    **/
    function getReserveCurrentLiquidityRate(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.currentLiquidityRate;
    }

    /**
    * @dev gets the reserve liquidity cumulative index
    * @param _reserve the reserve address
    * @return the reserve liquidity cumulative index
    **/
    function getReserveLiquidityCumulativeIndex(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.lastLiquidityCumulativeIndex;
    }

    /**
    * @dev gets the reserve variable borrow index
    * @param _reserve the reserve address
    * @return the reserve variable borrow index
    **/
    function getReserveVariableBorrowsCumulativeIndex(address _reserve)
    external
    view
    returns (uint256)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.lastVariableBorrowCumulativeIndex;
    }

    /**
    * @dev this function aggregates the configuration parameters of the reserve.
    * It's used in the LendingPoolDataProvider specifically to save gas, and avoid
    * multiple external contract calls to fetch the same data.
    * @param _reserve the reserve address
    * @return the reserve decimals
    * @return the base ltv as collateral
    * @return the liquidation threshold
    * @return if the reserve is used as collateral or not
    **/
    function getReserveConfiguration(address _reserve)
    external
    view
    returns (uint256, uint256, uint256, bool)
    {
        uint256 decimals;
        uint256 baseLTVasCollateral;
        uint256 liquidationThreshold;
        bool usageAsCollateralEnabled;

        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        decimals = reserve.decimals;
        baseLTVasCollateral = reserve.baseLTVasCollateral;
        liquidationThreshold = reserve.liquidationThreshold;
        usageAsCollateralEnabled = reserve.usageAsCollateralEnabled;

        return (decimals, baseLTVasCollateral, liquidationThreshold, usageAsCollateralEnabled);
    }

    /**
    * @dev returns the decimals of the reserve
    * @param _reserve the reserve address
    * @return the reserve decimals
    **/
    function getReserveDecimals(address _reserve) external view returns (uint256) {
        return reserves[_reserve].decimals;
    }

    /**
    * @dev returns true if the reserve is enabled for borrowing
    * @param _reserve the reserve address
    * @return true if the reserve is enabled for borrowing, false otherwise
    **/

    function isReserveBorrowingEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.borrowingEnabled;
    }

    /**
    * @dev returns true if the reserve is enabled as collateral
    * @param _reserve the reserve address
    * @return true if the reserve is enabled as collateral, false otherwise
    **/

    function isReserveUsageAsCollateralEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.usageAsCollateralEnabled;
    }

    /**
    * @dev returns true if the stable rate is enabled on reserve
    * @param _reserve the reserve address
    * @return true if the stable rate is enabled on reserve, false otherwise
    **/
    function getReserveIsStableBorrowRateEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isStableBorrowRateEnabled;
    }

    /**
    * @dev returns true if the reserve is active
    * @param _reserve the reserve address
    * @return true if the reserve is active, false otherwise
    **/
    function getReserveIsActive(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isActive;
    }

    /**
    * @notice returns if a reserve is freezed
    * @param _reserve the reserve for which the information is needed
    * @return true if the reserve is freezed, false otherwise
    **/

    function getReserveIsFreezed(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isFreezed;
    }

    /**
    * @notice returns the timestamp of the last action on the reserve
    * @param _reserve the reserve for which the information is needed
    * @return the last updated timestamp of the reserve
    **/

    function getReserveLastUpdate(address _reserve) external view returns (uint40 timestamp) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        timestamp = reserve.lastUpdateTimestamp;
    }

    /**
    * @dev returns the utilization rate U of a specific reserve
    * @param _reserve the reserve for which the information is needed
    * @return the utilization rate in ray
    **/

    function getReserveUtilizationRate(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        uint256 totalBorrows = reserve.getTotalBorrows();

        if (totalBorrows == 0) {
            return 0;
        }

        uint256 availableLiquidity = getReserveAvailableLiquidity(_reserve);

        return totalBorrows.rayDiv(availableLiquidity.add(totalBorrows));
    }

    /**
    * @return the array of reserves configured on the core
    **/
    function getReserves() external view returns (address[] memory) {
        return reservesList;
    }

    /**
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return true if the user has chosen to use the reserve as collateral, false otherwise
    **/
    function isUserUseReserveAsCollateralEnabled(address _reserve, address _user)
    external
    view
    returns (bool)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.useAsCollateral;
    }

    /**
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the origination fee for the user
    **/
    function getUserOriginationFee(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.originationFee;
    }

    /**
    * @dev users with no loans in progress have NONE as borrow rate mode
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the borrow rate mode for the user,
    **/

    function getUserCurrentBorrowRateMode(address _reserve, address _user)
    public
    view
    returns (CoreLibrary.InterestRateMode)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (user.principalBorrowBalance == 0) {
            return CoreLibrary.InterestRateMode.NONE;
        }

        return
        user.stableBorrowRate > 0
        ? CoreLibrary.InterestRateMode.STABLE
        : CoreLibrary.InterestRateMode.VARIABLE;
    }

    /**
    * @dev gets the current borrow rate of the user
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the borrow rate for the user,
    **/
    function getUserCurrentBorrowRate(address _reserve, address _user)
    internal
    view
    returns (uint256)
    {
        CoreLibrary.InterestRateMode rateMode = getUserCurrentBorrowRateMode(_reserve, _user);

        if (rateMode == CoreLibrary.InterestRateMode.NONE) {
            return 0;
        }

        return
        rateMode == CoreLibrary.InterestRateMode.STABLE
        ? usersReserveData[_user][_reserve].stableBorrowRate
        : reserves[_reserve].currentVariableBorrowRate;
    }

    /**
    * @dev the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the user stable rate
    **/
    function getUserCurrentStableBorrowRate(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.stableBorrowRate;
    }

    /**
    * @dev calculates and returns the borrow balances of the user
    * @param _reserve the address of the reserve
    * @param _user the address of the user
    * @return the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance
    **/

    function getUserBorrowBalances(address _reserve, address _user)
    public
    view
    returns (uint256, uint256, uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        if (user.principalBorrowBalance == 0) {
            return (0, 0, 0);
        }

        uint256 principal = user.principalBorrowBalance;
        uint256 compoundedBalance = CoreLibrary.getCompoundedBorrowBalance(
            user,
            reserves[_reserve]
        );
        return (principal, compoundedBalance, compoundedBalance.sub(principal));
    }

    /**
    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the variable borrow index for the user
    **/

    function getUserVariableBorrowCumulativeIndex(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.lastVariableBorrowCumulativeIndex;
    }

    /**
    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the variable borrow index for the user
    **/

    function getUserLastUpdate(address _reserve, address _user)
    external
    view
    returns (uint256 timestamp)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        timestamp = user.lastUpdateTimestamp;
    }

    /**
    * @dev updates the lending pool core configuration
    **/
    function refreshConfiguration() external onlyLendingPoolConfigurator {
        refreshConfigInternal();
    }

    /**
    * @dev initializes a reserve
    * @param _reserve the address of the reserve
    * @param _aTokenAddress the address of the overlying aToken contract
    * @param _decimals the decimals of the reserve currency
    * @param _interestRateStrategyAddress the address of the interest rate strategy contract
    **/
    function initReserve(
        address _reserve,
        address _aTokenAddress,
        uint256 _decimals,
        address _interestRateStrategyAddress
    ) external onlyLendingPoolConfigurator {
        reserves[_reserve].init(_aTokenAddress, _decimals, _interestRateStrategyAddress);
        addReserveToListInternal(_reserve);

    }



    /**
    * @dev removes the last added reserve in the reservesList array
    * @param _reserveToRemove the address of the reserve
    **/
    function removeLastAddedReserve(address _reserveToRemove)
    external onlyLendingPoolConfigurator {

        address lastReserve = reservesList[reservesList.length-1];

        require(lastReserve == _reserveToRemove, "Reserve being removed is different than the reserve requested");

        //as we can't check if totalLiquidity is 0 (since the reserve added might not be an ERC20) we at least check that there is nothing borrowed
        require(getReserveTotalBorrows(lastReserve) == 0, "Cannot remove a reserve with liquidity deposited");

        reserves[lastReserve].isActive = false;
        reserves[lastReserve].aTokenAddress = address(0);
        reserves[lastReserve].decimals = 0;
        reserves[lastReserve].lastLiquidityCumulativeIndex = 0;
        reserves[lastReserve].lastVariableBorrowCumulativeIndex = 0;
        reserves[lastReserve].borrowingEnabled = false;
        reserves[lastReserve].usageAsCollateralEnabled = false;
        reserves[lastReserve].baseLTVasCollateral = 0;
        reserves[lastReserve].liquidationThreshold = 0;
        reserves[lastReserve].liquidationBonus = 0;
        reserves[lastReserve].interestRateStrategyAddress = address(0);

        reservesList.pop();
    }

    /**
    * @dev updates the address of the interest rate strategy contract
    * @param _reserve the address of the reserve
    * @param _rateStrategyAddress the address of the interest rate strategy contract
    **/

    function setReserveInterestRateStrategyAddress(address _reserve, address _rateStrategyAddress)
    external
    onlyLendingPoolConfigurator
    {
        reserves[_reserve].interestRateStrategyAddress = _rateStrategyAddress;
    }

    /**
    * @dev enables borrowing on a reserve. Also sets the stable rate borrowing
    * @param _reserve the address of the reserve
    * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise
    **/

    function enableBorrowingOnReserve(address _reserve, bool _stableBorrowRateEnabled)
    external
    onlyLendingPoolConfigurator
    {
        reserves[_reserve].enableBorrowing(_stableBorrowRateEnabled);
    }

    /**
    * @dev disables borrowing on a reserve
    * @param _reserve the address of the reserve
    **/

    function disableBorrowingOnReserve(address _reserve) external onlyLendingPoolConfigurator {
        reserves[_reserve].disableBorrowing();
    }

    /**
    * @dev enables a reserve to be used as collateral
    * @param _reserve the address of the reserve
    **/
    function enableReserveAsCollateral(
        address _reserve,
        uint256 _baseLTVasCollateral,
        uint256 _liquidationThreshold,
        uint256 _liquidationBonus
    ) external onlyLendingPoolConfigurator {
        reserves[_reserve].enableAsCollateral(
            _baseLTVasCollateral,
            _liquidationThreshold,
            _liquidationBonus
        );
    }

    /**
    * @dev disables a reserve to be used as collateral
    * @param _reserve the address of the reserve
    **/
    function disableReserveAsCollateral(address _reserve) external onlyLendingPoolConfigurator {
        reserves[_reserve].disableAsCollateral();
    }

    /**
    * @dev enable the stable borrow rate mode on a reserve
    * @param _reserve the address of the reserve
    **/
    function enableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isStableBorrowRateEnabled = true;
    }

    /**
    * @dev disable the stable borrow rate mode on a reserve
    * @param _reserve the address of the reserve
    **/
    function disableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isStableBorrowRateEnabled = false;
    }

    /**
    * @dev activates a reserve
    * @param _reserve the address of the reserve
    **/
    function activateReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        require(
            reserve.lastLiquidityCumulativeIndex > 0 &&
            reserve.lastVariableBorrowCumulativeIndex > 0,
            "Reserve has not been initialized yet"
        );
        reserve.isActive = true;
    }

    /**
    * @dev deactivates a reserve
    * @param _reserve the address of the reserve
    **/
    function deactivateReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isActive = false;
    }

    /**
    * @notice allows the configurator to freeze the reserve.
    * A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance.
    * @param _reserve the address of the reserve
    **/
    function freezeReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isFreezed = true;
    }

    /**
    * @notice allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed.
    * @param _reserve the address of the reserve
    **/
    function unfreezeReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isFreezed = false;
    }

    /**
    * @notice allows the configurator to update the loan to value of a reserve
    * @param _reserve the address of the reserve
    * @param _ltv the new loan to value
    **/
    function setReserveBaseLTVasCollateral(address _reserve, uint256 _ltv)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.baseLTVasCollateral = _ltv;
    }

    /**
    * @notice allows the configurator to update the liquidation threshold of a reserve
    * @param _reserve the address of the reserve
    * @param _threshold the new liquidation threshold
    **/
    function setReserveLiquidationThreshold(address _reserve, uint256 _threshold)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.liquidationThreshold = _threshold;
    }

    /**
    * @notice allows the configurator to update the liquidation bonus of a reserve
    * @param _reserve the address of the reserve
    * @param _bonus the new liquidation bonus
    **/
    function setReserveLiquidationBonus(address _reserve, uint256 _bonus)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.liquidationBonus = _bonus;
    }

    /**
    * @notice allows the configurator to update the reserve decimals
    * @param _reserve the address of the reserve
    * @param _decimals the decimals of the reserve
    **/
    function setReserveDecimals(address _reserve, uint256 _decimals)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.decimals = _decimals;
    }

    /**
    * @notice internal functions
    **/

    /**
    * @dev updates the state of a reserve as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the previous borrow balance of the borrower before the action
    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount
    * @param _amountBorrowed the new amount borrowed
    * @param _rateMode the borrow rate mode (stable, variable)
    **/

    function updateReserveStateOnBorrowInternal(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _balanceIncrease,
        uint256 _amountBorrowed,
        CoreLibrary.InterestRateMode _rateMode
    ) internal {
        reserves[_reserve].updateCumulativeIndexes();

        //increasing reserve total borrows to account for the new borrow balance of the user
        //NOTE: Depending on the previous borrow mode, the borrows might need to be switched from variable to stable or vice versa

        updateReserveTotalBorrowsByRateModeInternal(
            _reserve,
            _user,
            _principalBorrowBalance,
            _balanceIncrease,
            _amountBorrowed,
            _rateMode
        );
    }

    /**
    * @dev updates the state of a user as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _amountBorrowed the amount borrowed
    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount
    * @param _rateMode the borrow rate mode (stable, variable)
    * @return the final borrow rate for the user. Emitted by the borrow() event
    **/

    function updateUserStateOnBorrowInternal(
        address _reserve,
        address _user,
        uint256 _amountBorrowed,
        uint256 _balanceIncrease,
        uint256 _fee,
        CoreLibrary.InterestRateMode _rateMode
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (_rateMode == CoreLibrary.InterestRateMode.STABLE) {
            //stable
            //reset the user variable index, and update the stable rate
            user.stableBorrowRate = reserve.currentStableBorrowRate;
            user.lastVariableBorrowCumulativeIndex = 0;
        } else if (_rateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //variable
            //reset the user stable rate, and store the new borrow index
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        } else {
            revert("Invalid borrow rate mode");
        }
        //increase the principal borrows and the origination fee
        user.principalBorrowBalance = user.principalBorrowBalance.add(_amountBorrowed).add(
            _balanceIncrease
        );
        user.originationFee = user.originationFee.add(_fee);

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

    }

    /**
    * @dev updates the state of the reserve as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateReserveStateOnRepayInternal(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_reserve][_user];

        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(_reserve, _user);

        //update the indexes
        reserves[_reserve].updateCumulativeIndexes();

        //compound the cumulated interest to the borrow balance and then subtracting the payback amount
        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _balanceIncrease,
                user.stableBorrowRate
            );
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _paybackAmountMinusFees,
                user.stableBorrowRate
            );
        } else {
            reserve.increaseTotalBorrowsVariable(_balanceIncrease);
            reserve.decreaseTotalBorrowsVariable(_paybackAmountMinusFees);
        }
    }

    /**
    * @dev updates the state of the user as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _originationFeeRepaid the fee on the amount that is being repaid
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _repaidWholeLoan true if the user is repaying the whole loan
    **/
    function updateUserStateOnRepayInternal(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _originationFeeRepaid,
        uint256 _balanceIncrease,
        bool _repaidWholeLoan
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        //update the user principal borrow balance, adding the cumulated interest and then subtracting the payback amount
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(
            _paybackAmountMinusFees
        );
        user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;

        //if the balance decrease is equal to the previous principal (user is repaying the whole loan)
        //and the rate mode is stable, we reset the interest rate mode of the user
        if (_repaidWholeLoan) {
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = 0;
        }
        user.originationFee = user.originationFee.sub(_originationFeeRepaid);

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

    }

    /**
    * @dev updates the state of the user as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is performing the rate swap
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the the principal amount borrowed by the user
    * @param _compoundedBorrowBalance the principal amount plus the accrued interest
    * @param _currentRateMode the rate mode at which the user borrowed
    **/
    function updateReserveStateOnSwapRateInternal(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _compoundedBorrowBalance,
        CoreLibrary.InterestRateMode _currentRateMode
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        //compounding reserve indexes
        reserve.updateCumulativeIndexes();

        if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {
            uint256 userCurrentStableRate = user.stableBorrowRate;

            //swap to variable
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _principalBorrowBalance,
                userCurrentStableRate
            ); //decreasing stable from old principal balance
            reserve.increaseTotalBorrowsVariable(_compoundedBorrowBalance); //increase variable borrows
        } else if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //swap to stable
            uint256 currentStableRate = reserve.currentStableBorrowRate;
            reserve.decreaseTotalBorrowsVariable(_principalBorrowBalance);
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _compoundedBorrowBalance,
                currentStableRate
            );

        } else {
            revert("Invalid rate mode received");
        }
    }

    /**
    * @dev updates the state of the user as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is performing the swap
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _currentRateMode the current rate mode of the user
    **/

    function updateUserStateOnSwapRateInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease,
        CoreLibrary.InterestRateMode _currentRateMode
    ) internal returns (CoreLibrary.InterestRateMode) {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        CoreLibrary.InterestRateMode newMode = CoreLibrary.InterestRateMode.NONE;

        if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //switch to stable
            newMode = CoreLibrary.InterestRateMode.STABLE;
            user.stableBorrowRate = reserve.currentStableBorrowRate;
            user.lastVariableBorrowCumulativeIndex = 0;
        } else if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {
            newMode = CoreLibrary.InterestRateMode.VARIABLE;
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        } else {
            revert("Invalid interest rate mode received");
        }
        //compounding cumulated interest
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);
        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

        return newMode;
    }

    /**
    * @dev updates the state of the principal reserve as a consequence of a liquidation action.
    * @param _principalReserve the address of the principal reserve that is being repaid
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updatePrincipalReserveStateOnLiquidationInternal(
        address _principalReserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_principalReserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_principalReserve];

        //update principal reserve data
        reserve.updateCumulativeIndexes();

        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(
            _principalReserve,
            _user
        );

        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            //increase the total borrows by the compounded interest
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _balanceIncrease,
                user.stableBorrowRate
            );

            //decrease by the actual amount to liquidate
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _amountToLiquidate,
                user.stableBorrowRate
            );

        } else {
            //increase the total borrows by the compounded interest
            reserve.increaseTotalBorrowsVariable(_balanceIncrease);

            //decrease by the actual amount to liquidate
            reserve.decreaseTotalBorrowsVariable(_amountToLiquidate);
        }

    }

    /**
    * @dev updates the state of the collateral reserve as a consequence of a liquidation action.
    * @param _collateralReserve the address of the collateral reserve that is being liquidated
    **/
    function updateCollateralReserveStateOnLiquidationInternal(
        address _collateralReserve
    ) internal {
        //update collateral reserve
        reserves[_collateralReserve].updateCumulativeIndexes();

    }

    /**
    * @dev updates the state of the user being liquidated as a consequence of a liquidation action.
    * @param _reserve the address of the principal reserve that is being repaid
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _feeLiquidated the amount of origination fee being liquidated
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/
    function updateUserStateOnLiquidationInternal(
        address _reserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _feeLiquidated,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        //first increase by the compounded interest, then decrease by the liquidated amount
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(
            _amountToLiquidate
        );

        if (
            getUserCurrentBorrowRateMode(_reserve, _user) == CoreLibrary.InterestRateMode.VARIABLE
        ) {
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        }

        if(_feeLiquidated > 0){
            user.originationFee = user.originationFee.sub(_feeLiquidated);
        }

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);
    }

    /**
    * @dev updates the state of the reserve as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateReserveStateOnRebalanceInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        reserve.updateCumulativeIndexes();

        reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
            _balanceIncrease,
            user.stableBorrowRate
        );

    }

    /**
    * @dev updates the state of the user as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateUserStateOnRebalanceInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);
        user.stableBorrowRate = reserve.currentStableBorrowRate;

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);
    }

    /**
    * @dev updates the state of the user as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _amountBorrowed the accrued interest on the borrowed amount
    **/
    function updateReserveTotalBorrowsByRateModeInternal(
        address _reserve,
        address _user,
        uint256 _principalBalance,
        uint256 _balanceIncrease,
        uint256 _amountBorrowed,
        CoreLibrary.InterestRateMode _newBorrowRateMode
    ) internal {
        CoreLibrary.InterestRateMode previousRateMode = getUserCurrentBorrowRateMode(
            _reserve,
            _user
        );
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        if (previousRateMode == CoreLibrary.InterestRateMode.STABLE) {
            CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _principalBalance,
                user.stableBorrowRate
            );
        } else if (previousRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            reserve.decreaseTotalBorrowsVariable(_principalBalance);
        }

        uint256 newPrincipalAmount = _principalBalance.add(_balanceIncrease).add(_amountBorrowed);
        if (_newBorrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                newPrincipalAmount,
                reserve.currentStableBorrowRate
            );
        } else if (_newBorrowRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            reserve.increaseTotalBorrowsVariable(newPrincipalAmount);
        } else {
            revert("Invalid new borrow rate mode");
        }
    }

    /**
    * @dev Updates the reserve current stable borrow rate Rf, the current variable borrow rate Rv and the current liquidity rate Rl.
    * Also updates the lastUpdateTimestamp value. Please refer to the whitepaper for further information.
    * @param _reserve the address of the reserve to be updated
    * @param _liquidityAdded the amount of liquidity added to the protocol (deposit or repay) in the previous action
    * @param _liquidityTaken the amount of liquidity taken from the protocol (redeem or borrow)
    **/

    function updateReserveInterestRatesAndTimestampInternal(
        address _reserve,
        uint256 _liquidityAdded,
        uint256 _liquidityTaken
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        (uint256 newLiquidityRate, uint256 newStableRate, uint256 newVariableRate) = IReserveInterestRateStrategy(
            reserve
            .interestRateStrategyAddress
        )
        .calculateInterestRates(
            _reserve,
            getReserveAvailableLiquidity(_reserve).add(_liquidityAdded).sub(_liquidityTaken),
            reserve.totalBorrowsStable,
            reserve.totalBorrowsVariable,
            reserve.currentAverageStableBorrowRate
        );

        reserve.currentLiquidityRate = newLiquidityRate;
        reserve.currentStableBorrowRate = newStableRate;
        reserve.currentVariableBorrowRate = newVariableRate;

        //solium-disable-next-line
        reserve.lastUpdateTimestamp = uint40(block.timestamp);

        emit ReserveUpdated(
            _reserve,
            newLiquidityRate,
            newStableRate,
            newVariableRate,
            reserve.lastLiquidityCumulativeIndex,
            reserve.lastVariableBorrowCumulativeIndex
        );
    }

    /**
    * @dev transfers to the protocol fees of a flashloan to the fees collection address
    * @param _token the address of the token being transferred
    * @param _amount the amount being transferred
    **/

    function transferFlashLoanProtocolFeeInternal(address _token, uint256 _amount) internal {
        address payable receiver = address(uint160(addressesProvider.getTokenDistributor()));

        if (_token != EthAddressLib.ethAddress()) {
            ERC20(_token).safeTransfer(receiver, _amount);
        } else {
            receiver.transfer(_amount);
        }
    }

    /**
    * @dev updates the internal configuration of the core
    **/
    function refreshConfigInternal() internal {
        lendingPoolAddress = addressesProvider.getLendingPool();
    }

    /**
    * @dev adds a reserve to the array of the reserves address
    **/
    function addReserveToListInternal(address _reserve) internal {
        bool reserveAlreadyAdded = false;
        for (uint256 i = 0; i < reservesList.length; i++)
            if (reservesList[i] == _reserve) {
                reserveAlreadyAdded = true;
            }
        if (!reserveAlreadyAdded) reservesList.push(_reserve);
    }

}
.]

Let's

[2024-01-09 04:31:20 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | pragma solidity ^0.5.0; import "openzeppelin-solidity/contracts/math/SafeMath.sol"; import "openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol"; import "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol"; import "openzeppelin-solidity/contracts/utils/Address.sol"; import "../libraries/openzeppelin-upgradeability/VersionedInitializable.sol"; import "../libraries/CoreLibrary.sol"; import "../configuration/LendingPoolAddressesProvider.sol"; import "../interfaces/ILendingRateOracle.sol"; import "../interfaces/IReserveInterestRateStrategy.sol"; import "../libraries/WadRayMath.sol"; import "../tokenization/AToken.sol"; import "../libraries/EthAddressLib.sol"; / * @title LendingPoolCore contract * @author Aave * @notice Holds the state of the lending pool and all the funds deposited * @dev NOTE: The core does not enforce security checks on the update of the state * (eg, updateStateOnBorrow() does not enforce that borrowed is enabled on the reserve). * The check that an action can be performed is a duty of the overlying LendingPool contract. / contract LendingPoolCore is VersionedInitializable {     using SafeMath for uint256;     using WadRayMath for uint256;     using CoreLibrary for CoreLibrary.ReserveData;     using CoreLibrary for CoreLibrary.UserReserveData;     using SafeERC20 for ERC20;     using Address for address payable; /** * @dev Emitted when the state of a reserve is updated * @param reserve the address of the reserve * @param liquidityRate the new liquidity rate * @param stableBorrowRate the new stable borrow rate * @param variableBorrowRate the new variable borrow rate * @param liquidityIndex the new liquidity index * @param variableBorrowIndex the new variable borrow index **/ event ReserveUpdated(     address indexed reserve,     uint256 liquidityRate,     uint256 stableBorrowRate,     uint256 variableBorrowRate,     uint256 liquidityIndex,     uint256 variableBorrowIndex );  address public lendingPoolAddress;  LendingPoolAddressesProvider public addressesProvider;  /** * @dev only lending pools can use functions affected by this modifier **/ modifier onlyLendingPool {     require(lendingPoolAddress == msg.sender, "The caller must be a lending pool contract");     _; }  /** * @dev only lending pools configurator can use functions affected by this modifier **/ modifier onlyLendingPoolConfigurator {     require(         addressesProvider.getLendingPoolConfigurator() == msg.sender,         "The caller must be a lending pool configurator contract"     );     _; }  mapping(address =&gt; CoreLibrary.ReserveData) internal reserves; mapping(address =&gt; mapping(address =&gt; CoreLibrary.UserReserveData)) internal usersReserveData;  address[] public reservesList;  uint256 public constant CORE_REVISION = 0x4;  /** * @dev returns the revision number of the contract **/ function getRevision() internal pure returns (uint256) {     return CORE_REVISION; }  /** * @dev initializes the Core contract, invoked upon registration on the AddressesProvider * @param _addressesProvider the addressesProvider contract **/  function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {     addressesProvider = _addressesProvider;     refreshConfigInternal(); }  /** * @dev updates the state of the core as a result of a deposit action * @param _reserve the address of the reserve in which the deposit is happening * @param _user the address of the the user depositing * @param _amount the amount being deposited * @param _isFirstDeposit true if the user is depositing for the first time **/  function updateStateOnDeposit(     address _reserve,     address _user,     uint256 _amount,     bool _isFirstDeposit ) external onlyLendingPool {     reserves[_reserve].updateCumulativeIndexes();     updateReserveInterestRatesAndTimestampInternal(_reserve, _amount, 0);      if (_isFirstDeposit) {         //if this is the first deposit of the user, we configure the deposit as enabled to be used as collateral         setUserUseReserveAsCollateral(_reserve, _user, true);     } }  /** * @dev updates the state of the core as a result of a redeem action * @param _reserve the address of the reserve in which the redeem is happening * @param _user the address of the the user redeeming * @param _amountRedeemed the amount being redeemed * @param _userRedeemedEverything true if the user is redeeming everything **/ function updateStateOnRedeem(     address _reserve,     address _user,     uint256 _amountRedeemed,     bool _userRedeemedEverything ) external onlyLendingPool {     //compound liquidity and variable borrow interests     reserves[_reserve].updateCumulativeIndexes();     updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountRedeemed);      //if user redeemed everything the useReserveAsCollateral flag is reset     if (_userRedeemedEverything) {         setUserUseReserveAsCollateral(_reserve, _user, false);     } }  /** * @dev updates the state of the core as a result of a flashloan action * @param _reserve the address of the reserve in which the flashloan is happening * @param _income the income of the protocol as a result of the action **/ function updateStateOnFlashLoan(     address _reserve,     uint256 _availableLiquidityBefore,     uint256 _income,     uint256 _protocolFee ) external onlyLendingPool {     transferFlashLoanProtocolFeeInternal(_reserve, _protocolFee);      //compounding the cumulated interest     reserves[_reserve].updateCumulativeIndexes();      uint256 totalLiquidityBefore = _availableLiquidityBefore.add(         getReserveTotalBorrows(_reserve)     );      //compounding the received fee into the reserve     reserves[_reserve].cumulateToLiquidityIndex(totalLiquidityBefore, _income);      //refresh interest rates     updateReserveInterestRatesAndTimestampInternal(_reserve, _income, 0); }  /** * @dev updates the state of the core as a consequence of a borrow action. * @param _reserve the address of the reserve on which the user is borrowing * @param _user the address of the borrower * @param _amountBorrowed the new amount borrowed * @param _borrowFee the fee on the amount borrowed * @param _rateMode the borrow rate mode (stable, variable) * @return the new borrow rate for the user **/ function updateStateOnBorrow(     address _reserve,     address _user,     uint256 _amountBorrowed,     uint256 _borrowFee,     CoreLibrary.InterestRateMode _rateMode ) external onlyLendingPool returns (uint256, uint256) {     // getting the previous borrow data of the user     (uint256 principalBorrowBalance, , uint256 balanceIncrease) = getUserBorrowBalances(         _reserve,         _user     );      updateReserveStateOnBorrowInternal(         _reserve,         _user,         principalBorrowBalance,         balanceIncrease,         _amountBorrowed,         _rateMode     );      updateUserStateOnBorrowInternal(         _reserve,         _user,         _amountBorrowed,         balanceIncrease,         _borrowFee,         _rateMode     );      updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountBorrowed);      return (getUserCurrentBorrowRate(_reserve, _user), balanceIncrease); }  /** * @dev updates the state of the core as a consequence of a repay action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _paybackAmountMinusFees the amount being paid back minus fees * @param _originationFeeRepaid the fee on the amount that is being repaid * @param _balanceIncrease the accrued interest on the borrowed amount * @param _repaidWholeLoan true if the user is repaying the whole loan **/  function updateStateOnRepay(     address _reserve,     address _user,     uint256 _paybackAmountMinusFees,     uint256 _originationFeeRepaid,     uint256 _balanceIncrease,     bool _repaidWholeLoan ) external onlyLendingPool {     updateReserveStateOnRepayInternal(         _reserve,         _user,         _paybackAmountMinusFees,         _balanceIncrease     );     updateUserStateOnRepayInternal(         _reserve,         _user,         _paybackAmountMinusFees,         _originationFeeRepaid,         _balanceIncrease,         _repaidWholeLoan     );      updateReserveInterestRatesAndTimestampInternal(_reserve, _paybackAmountMinusFees, 0); }  /** * @dev updates the state of the core as a consequence of a swap rate action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _principalBorrowBalance the amount borrowed by the user * @param _compoundedBorrowBalance the amount borrowed plus accrued interest * @param _balanceIncrease the accrued interest on the borrowed amount * @param _currentRateMode the current interest rate mode for the user **/ function updateStateOnSwapRate(     address _reserve,     address _user,     uint256 _principalBorrowBalance,     uint256 _compoundedBorrowBalance,     uint256 _balanceIncrease,     CoreLibrary.InterestRateMode _currentRateMode ) external onlyLendingPool returns (CoreLibrary.InterestRateMode, uint256) {     updateReserveStateOnSwapRateInternal(         _reserve,         _user,         _principalBorrowBalance,         _compoundedBorrowBalance,         _currentRateMode     );      CoreLibrary.InterestRateMode newRateMode = updateUserStateOnSwapRateInternal(         _reserve,         _user,         _balanceIncrease,         _currentRateMode     );      updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);      return (newRateMode, getUserCurrentBorrowRate(_reserve, _user)); }  /** * @dev updates the state of the core as a consequence of a liquidation action. * @param _principalReserve the address of the principal reserve that is being repaid * @param _collateralReserve the address of the collateral reserve that is being liquidated * @param _user the address of the borrower * @param _amountToLiquidate the amount being repaid by the liquidator * @param _collateralToLiquidate the amount of collateral being liquidated * @param _feeLiquidated the amount of origination fee being liquidated * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus * @param _balanceIncrease the accrued interest on the borrowed amount * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise **/ function updateStateOnLiquidation(     address _principalReserve,     address _collateralReserve,     address _user,     uint256 _amountToLiquidate,     uint256 _collateralToLiquidate,     uint256 _feeLiquidated,     uint256 _liquidatedCollateralForFee,     uint256 _balanceIncrease,     bool _liquidatorReceivesAToken ) external onlyLendingPool {     updatePrincipalReserveStateOnLiquidationInternal(         _principalReserve,         _user,         _amountToLiquidate,         _balanceIncrease     );      updateCollateralReserveStateOnLiquidationInternal(         _collateralReserve     );      updateUserStateOnLiquidationInternal(         _principalReserve,         _user,         _amountToLiquidate,         _feeLiquidated,         _balanceIncrease     );      updateReserveInterestRatesAndTimestampInternal(_principalReserve, _amountToLiquidate, 0);      if (!_liquidatorReceivesAToken) {         updateReserveInterestRatesAndTimestampInternal(             _collateralReserve,             0,             _collateralToLiquidate.add(_liquidatedCollateralForFee)         );     }  }  /** * @dev updates the state of the core as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount * @return the new stable rate for the user **/ function updateStateOnRebalance(address _reserve, address _user, uint256 _balanceIncrease) external onlyLendingPool returns (uint256) {     updateReserveStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);      //update user data and rebalance the rate     updateUserStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);     updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);     return usersReserveData[_user][_reserve].stableBorrowRate; }  /** * @dev enables or disables a reserve as collateral * @param _reserve the address of the principal reserve where the user deposited * @param _user the address of the depositor * @param _useAsCollateral true if the depositor wants to use the reserve as collateral **/ function setUserUseReserveAsCollateral(address _reserve, address _user, bool _useAsCollateral) public onlyLendingPool {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     user.useAsCollateral = _useAsCollateral; }  /** * @notice ETH/token transfer functions **/  /** * @dev fallback function enforces that the caller is a contract, to support flashloan transfers **/ function() external payable {     //only contracts can send ETH to the core     require(msg.sender.isContract(), "Only contracts can send ether to the Lending pool core");  }  /** * @dev transfers to the user a specific amount from the reserve. * @param _reserve the address of the reserve where the transfer is happening * @param _user the address of the user receiving the transfer * @param _amount the amount being transferred **/ function transferToUser(address _reserve, address payable _user, uint256 _amount) external onlyLendingPool {     if (_reserve != EthAddressLib.ethAddress()) {         ERC20(_reserve).safeTransfer(_user, _amount);     } else {         //solium-disable-next-line         (bool result, ) = _user.call.value(_amount).gas(50000)("");         require(result, "Transfer of ETH failed");     } }  /** * @dev transfers the protocol fees to the fees collection address * @param _token the address of the token being transferred * @param _user the address of the user from where the transfer is happening * @param _amount the amount being transferred * @param _destination the fee receiver address **/  function transferToFeeCollectionAddress(     address _token,     address _user,     uint256 _amount,     address _destination ) external payable onlyLendingPool {     address payable feeAddress = address(uint160(_destination)); //cast the address to payable      if (_token != EthAddressLib.ethAddress()) {         require(             msg.value == 0,             "User is sending ETH along with the ERC20 transfer. Check the value attribute of the transaction"         );         ERC20(_token).safeTransferFrom(_user, feeAddress, _amount);     } else {         require(msg.value &gt;= _amount, "The amount and the value sent to deposit do not match");         //solium-disable-next-line         (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");         require(result, "Transfer of ETH failed");     } }  /** * @dev transfers the fees to the fees collection address in the case of liquidation * @param _token the address of the token being transferred * @param _amount the amount being transferred * @param _destination the fee receiver address **/ function liquidateFee(     address _token,     uint256 _amount,     address _destination ) external payable onlyLendingPool {     address payable feeAddress = address(uint160(_destination)); //cast the address to payable     require(         msg.value == 0,         "Fee liquidation does not require any transfer of value"     );      if (_token != EthAddressLib.ethAddress()) {         ERC20(_token).safeTransfer(feeAddress, _amount);     } else {         //solium-disable-next-line         (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");         require(result, "Transfer of ETH failed");     } }  /** * @dev transfers an amount from a user to the destination reserve * @param _reserve the address of the reserve where the amount is being transferred * @param _user the address of the user from where the transfer is happening * @param _amount the amount being transferred **/ function transferToReserve(address _reserve, address payable _user, uint256 _amount) external payable onlyLendingPool {     if (_reserve != EthAddressLib.ethAddress()) {         require(msg.value == 0, "User is sending ETH along with the ERC20 transfer.");         ERC20(_reserve).safeTransferFrom(_user, address(this), _amount);      } else {         require(msg.value &gt;= _amount, "The amount and the value sent to deposit do not match");          if (msg.value &gt; _amount) {             //send back excess ETH             uint256 excessAmount = msg.value.sub(_amount);             //solium-disable-next-line             (bool result, ) = _user.call.value(excessAmount).gas(50000)("");             require(result, "Transfer of ETH failed");         }     } }  /** * @notice data access functions **/  /** * @dev returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral) * needed to calculate the global account data in the LendingPoolDataProvider * @param _reserve the address of the reserve * @param _user the address of the user * @return the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not **/ function getUserBasicReserveData(address _reserve, address _user) external view returns (uint256, uint256, uint256, bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      uint256 underlyingBalance = getUserUnderlyingAssetBalance(_reserve, _user);      if (user.principalBorrowBalance == 0) {         return (underlyingBalance, 0, 0, user.useAsCollateral);     }      return (     underlyingBalance,     user.getCompoundedBorrowBalance(reserve),     user.originationFee,     user.useAsCollateral     ); }  /** * @dev checks if a user is allowed to borrow at a stable rate * @param _reserve the reserve address * @param _user the user * @param _amount the amount the the user wants to borrow * @return true if the user is allowed to borrow at a stable rate, false otherwise **/  function isUserAllowedToBorrowAtStable(address _reserve, address _user, uint256 _amount) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      if (!reserve.isStableBorrowRateEnabled) return false;      return     !user.useAsCollateral ||     !reserve.usageAsCollateralEnabled ||     _amount &gt; getUserUnderlyingAssetBalance(_reserve, _user); }  /** * @dev gets the underlying asset balance of a user based on the corresponding aToken balance. * @param _reserve the reserve address * @param _user the user address * @return the underlying deposit balance of the user **/  function getUserUnderlyingAssetBalance(address _reserve, address _user) public view returns (uint256) {     AToken aToken = AToken(reserves[_reserve].aTokenAddress);     return aToken.balanceOf(_user);  }  /** * @dev gets the interest rate strategy contract address for the reserve * @param _reserve the reserve address * @return the address of the interest rate strategy contract **/ function getReserveInterestRateStrategyAddress(address _reserve) public view returns (address) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.interestRateStrategyAddress; }  /** * @dev gets the aToken contract address for the reserve * @param _reserve the reserve address * @return the address of the aToken contract **/  function getReserveATokenAddress(address _reserve) public view returns (address) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.aTokenAddress; }  /** * @dev gets the available liquidity in the reserve. The available liquidity is the balance of the core contract * @param _reserve the reserve address * @return the available liquidity **/ function getReserveAvailableLiquidity(address _reserve) public view returns (uint256) {     uint256 balance = 0;      if (_reserve == EthAddressLib.ethAddress()) {         balance = address(this).balance;     } else {         balance = IERC20(_reserve).balanceOf(address(this));     }     return balance; }  /** * @dev gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows * @param _reserve the reserve address * @return the total liquidity **/ function getReserveTotalLiquidity(address _reserve) public view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return getReserveAvailableLiquidity(_reserve).add(reserve.getTotalBorrows()); }  /** * @dev gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there * there has been 100% income. * @param _reserve the reserve address * @return the reserve normalized income **/ function getReserveNormalizedIncome(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.getNormalizedIncome(); }  /** * @dev gets the reserve total borrows * @param _reserve the reserve address * @return the total borrows (stable + variable) **/ function getReserveTotalBorrows(address _reserve) public view returns (uint256) {     return reserves[_reserve].getTotalBorrows(); }  /** * @dev gets the reserve total borrows stable * @param _reserve the reserve address * @return the total borrows stable **/ function getReserveTotalBorrowsStable(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.totalBorrowsStable; }  /** * @dev gets the reserve total borrows variable * @param _reserve the reserve address * @return the total borrows variable **/  function getReserveTotalBorrowsVariable(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.totalBorrowsVariable; }  /** * @dev gets the reserve liquidation threshold * @param _reserve the reserve address * @return the reserve liquidation threshold **/  function getReserveLiquidationThreshold(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.liquidationThreshold; }  /** * @dev gets the reserve liquidation bonus * @param _reserve the reserve address * @return the reserve liquidation bonus **/  function getReserveLiquidationBonus(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.liquidationBonus; }  /** * @dev gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty * @param _reserve the reserve address * @return the reserve current variable borrow rate **/  function getReserveCurrentVariableBorrowRate(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      if (reserve.currentVariableBorrowRate == 0) {         return         IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)         .getBaseVariableBorrowRate();     }     return reserve.currentVariableBorrowRate; }  /** * @dev gets the reserve current stable borrow rate. Is the market rate if the reserve is empty * @param _reserve the reserve address * @return the reserve current stable borrow rate **/  function getReserveCurrentStableBorrowRate(address _reserve) public view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     ILendingRateOracle oracle = ILendingRateOracle(addressesProvider.getLendingRateOracle());      if (reserve.currentStableBorrowRate == 0) {         //no stable rate borrows yet         return oracle.getMarketBorrowRate(_reserve);     }      return reserve.currentStableBorrowRate; }  /** * @dev gets the reserve average stable borrow rate. The average stable rate is the weighted average * of all the loans taken at stable rate. * @param _reserve the reserve address * @return the reserve current average borrow rate **/ function getReserveCurrentAverageStableBorrowRate(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.currentAverageStableBorrowRate; }  /** * @dev gets the reserve liquidity rate * @param _reserve the reserve address * @return the reserve liquidity rate **/ function getReserveCurrentLiquidityRate(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.currentLiquidityRate; }  /** * @dev gets the reserve liquidity cumulative index * @param _reserve the reserve address * @return the reserve liquidity cumulative index **/ function getReserveLiquidityCumulativeIndex(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.lastLiquidityCumulativeIndex; }  /** * @dev gets the reserve variable borrow index * @param _reserve the reserve address * @return the reserve variable borrow index **/ function getReserveVariableBorrowsCumulativeIndex(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.lastVariableBorrowCumulativeIndex; }  /** * @dev this function aggregates the configuration parameters of the reserve. * It's used in the LendingPoolDataProvider specifically to save gas, and avoid * multiple external contract calls to fetch the same data. * @param _reserve the reserve address * @return the reserve decimals * @return the base ltv as collateral * @return the liquidation threshold * @return if the reserve is used as collateral or not **/ function getReserveConfiguration(address _reserve) external view returns (uint256, uint256, uint256, bool) {     uint256 decimals;     uint256 baseLTVasCollateral;     uint256 liquidationThreshold;     bool usageAsCollateralEnabled;      CoreLibrary.ReserveData storage reserve = reserves[_reserve];     decimals = reserve.decimals;     baseLTVasCollateral = reserve.baseLTVasCollateral;     liquidationThreshold = reserve.liquidationThreshold;     usageAsCollateralEnabled = reserve.usageAsCollateralEnabled;      return (decimals, baseLTVasCollateral, liquidationThreshold, usageAsCollateralEnabled); }  /** * @dev returns the decimals of the reserve * @param _reserve the reserve address * @return the reserve decimals **/ function getReserveDecimals(address _reserve) external view returns (uint256) {     return reserves[_reserve].decimals; }  /** * @dev returns true if the reserve is enabled for borrowing * @param _reserve the reserve address * @return true if the reserve is enabled for borrowing, false otherwise **/  function isReserveBorrowingEnabled(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.borrowingEnabled; }  /** * @dev returns true if the reserve is enabled as collateral * @param _reserve the reserve address * @return true if the reserve is enabled as collateral, false otherwise **/  function isReserveUsageAsCollateralEnabled(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.usageAsCollateralEnabled; }  /** * @dev returns true if the stable rate is enabled on reserve * @param _reserve the reserve address * @return true if the stable rate is enabled on reserve, false otherwise **/ function getReserveIsStableBorrowRateEnabled(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.isStableBorrowRateEnabled; }  /** * @dev returns true if the reserve is active * @param _reserve the reserve address * @return true if the reserve is active, false otherwise **/ function getReserveIsActive(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.isActive; }  /** * @notice returns if a reserve is freezed * @param _reserve the reserve for which the information is needed * @return true if the reserve is freezed, false otherwise **/  function getReserveIsFreezed(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.isFreezed; }  /** * @notice returns the timestamp of the last action on the reserve * @param _reserve the reserve for which the information is needed * @return the last updated timestamp of the reserve **/  function getReserveLastUpdate(address _reserve) external view returns (uint40 timestamp) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     timestamp = reserve.lastUpdateTimestamp; }  /** * @dev returns the utilization rate U of a specific reserve * @param _reserve the reserve for which the information is needed * @return the utilization rate in ray **/  function getReserveUtilizationRate(address _reserve) public view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      uint256 totalBorrows = reserve.getTotalBorrows();      if (totalBorrows == 0) {         return 0;     }      uint256 availableLiquidity = getReserveAvailableLiquidity(_reserve);      return totalBorrows.rayDiv(availableLiquidity.add(totalBorrows)); }  /** * @return the array of reserves configured on the core **/ function getReserves() external view returns (address[] memory) {     return reservesList; }  /** * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return true if the user has chosen to use the reserve as collateral, false otherwise **/ function isUserUseReserveAsCollateralEnabled(address _reserve, address _user) external view returns (bool) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.useAsCollateral; }  /** * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the origination fee for the user **/ function getUserOriginationFee(address _reserve, address _user) external view returns (uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.originationFee; }  /** * @dev users with no loans in progress have NONE as borrow rate mode * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the borrow rate mode for the user, **/  function getUserCurrentBorrowRateMode(address _reserve, address _user) public view returns (CoreLibrary.InterestRateMode) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      if (user.principalBorrowBalance == 0) {         return CoreLibrary.InterestRateMode.NONE;     }      return     user.stableBorrowRate &gt; 0     ? CoreLibrary.InterestRateMode.STABLE     : CoreLibrary.InterestRateMode.VARIABLE; }  /** * @dev gets the current borrow rate of the user * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the borrow rate for the user, **/ function getUserCurrentBorrowRate(address _reserve, address _user) internal view returns (uint256) {     CoreLibrary.InterestRateMode rateMode = getUserCurrentBorrowRateMode(_reserve, _user);      if (rateMode == CoreLibrary.InterestRateMode.NONE) {         return 0;     }      return     rateMode == CoreLibrary.InterestRateMode.STABLE     ? usersReserveData[_user][_reserve].stableBorrowRate     : reserves[_reserve].currentVariableBorrowRate; }  /** * @dev the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the user stable rate **/ function getUserCurrentStableBorrowRate(address _reserve, address _user) external view returns (uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.stableBorrowRate; }  /** * @dev calculates and returns the borrow balances of the user * @param _reserve the address of the reserve * @param _user the address of the user * @return the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance **/  function getUserBorrowBalances(address _reserve, address _user) public view returns (uint256, uint256, uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     if (user.principalBorrowBalance == 0) {         return (0, 0, 0);     }      uint256 principal = user.principalBorrowBalance;     uint256 compoundedBalance = CoreLibrary.getCompoundedBorrowBalance(         user,         reserves[_reserve]     );     return (principal, compoundedBalance, compoundedBalance.sub(principal)); }  /** * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the variable borrow index for the user **/  function getUserVariableBorrowCumulativeIndex(address _reserve, address _user) external view returns (uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.lastVariableBorrowCumulativeIndex; }  /** * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the variable borrow index for the user **/  function getUserLastUpdate(address _reserve, address _user) external view returns (uint256 timestamp) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     timestamp = user.lastUpdateTimestamp; }  /** * @dev updates the lending pool core configuration **/ function refreshConfiguration() external onlyLendingPoolConfigurator {     refreshConfigInternal(); }  /** * @dev initializes a reserve * @param _reserve the address of the reserve * @param _aTokenAddress the address of the overlying aToken contract * @param _decimals the decimals of the reserve currency * @param _interestRateStrategyAddress the address of the interest rate strategy contract **/ function initReserve(     address _reserve,     address _aTokenAddress,     uint256 _decimals,     address _interestRateStrategyAddress ) external onlyLendingPoolConfigurator {     reserves[_reserve].init(_aTokenAddress, _decimals, _interestRateStrategyAddress);     addReserveToListInternal(_reserve);  }    /** * @dev removes the last added reserve in the reservesList array * @param _reserveToRemove the address of the reserve **/ function removeLastAddedReserve(address _reserveToRemove) external onlyLendingPoolConfigurator {      address lastReserve = reservesList[reservesList.length-1];      require(lastReserve == _reserveToRemove, "Reserve being removed is different than the reserve requested");      //as we can't check if totalLiquidity is 0 (since the reserve added might not be an ERC20) we at least check that there is nothing borrowed     require(getReserveTotalBorrows(lastReserve) == 0, "Cannot remove a reserve with liquidity deposited");      reserves[lastReserve].isActive = false;     reserves[lastReserve].aTokenAddress = address(0);     reserves[lastReserve].decimals = 0;     reserves[lastReserve].lastLiquidityCumulativeIndex = 0;     reserves[lastReserve].lastVariableBorrowCumulativeIndex = 0;     reserves[lastReserve].borrowingEnabled = false;     reserves[lastReserve].usageAsCollateralEnabled = false;     reserves[lastReserve].baseLTVasCollateral = 0;     reserves[lastReserve].liquidationThreshold = 0;     reserves[lastReserve].liquidationBonus = 0;     reserves[lastReserve].interestRateStrategyAddress = address(0);      reservesList.pop(); }  /** * @dev updates the address of the interest rate strategy contract * @param _reserve the address of the reserve * @param _rateStrategyAddress the address of the interest rate strategy contract **/  function setReserveInterestRateStrategyAddress(address _reserve, address _rateStrategyAddress) external onlyLendingPoolConfigurator {     reserves[_reserve].interestRateStrategyAddress = _rateStrategyAddress; }  /** * @dev enables borrowing on a reserve. Also sets the stable rate borrowing * @param _reserve the address of the reserve * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise **/  function enableBorrowingOnReserve(address _reserve, bool _stableBorrowRateEnabled) external onlyLendingPoolConfigurator {     reserves[_reserve].enableBorrowing(_stableBorrowRateEnabled); }  /** * @dev disables borrowing on a reserve * @param _reserve the address of the reserve **/  function disableBorrowingOnReserve(address _reserve) external onlyLendingPoolConfigurator {     reserves[_reserve].disableBorrowing(); }  /** * @dev enables a reserve to be used as collateral * @param _reserve the address of the reserve **/ function enableReserveAsCollateral(     address _reserve,     uint256 _baseLTVasCollateral,     uint256 _liquidationThreshold,     uint256 _liquidationBonus ) external onlyLendingPoolConfigurator {     reserves[_reserve].enableAsCollateral(         _baseLTVasCollateral,         _liquidationThreshold,         _liquidationBonus     ); }  /** * @dev disables a reserve to be used as collateral * @param _reserve the address of the reserve **/ function disableReserveAsCollateral(address _reserve) external onlyLendingPoolConfigurator {     reserves[_reserve].disableAsCollateral(); }  /** * @dev enable the stable borrow rate mode on a reserve * @param _reserve the address of the reserve **/ function enableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isStableBorrowRateEnabled = true; }  /** * @dev disable the stable borrow rate mode on a reserve * @param _reserve the address of the reserve **/ function disableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isStableBorrowRateEnabled = false; }  /** * @dev activates a reserve * @param _reserve the address of the reserve **/ function activateReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      require(         reserve.lastLiquidityCumulativeIndex &gt; 0 &amp;&amp;         reserve.lastVariableBorrowCumulativeIndex &gt; 0,         "Reserve has not been initialized yet"     );     reserve.isActive = true; }  /** * @dev deactivates a reserve * @param _reserve the address of the reserve **/ function deactivateReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isActive = false; }  /** * @notice allows the configurator to freeze the reserve. * A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance. * @param _reserve the address of the reserve **/ function freezeReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isFreezed = true; }  /** * @notice allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed. * @param _reserve the address of the reserve **/ function unfreezeReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isFreezed = false; }  /** * @notice allows the configurator to update the loan to value of a reserve * @param _reserve the address of the reserve * @param _ltv the new loan to value **/ function setReserveBaseLTVasCollateral(address _reserve, uint256 _ltv) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.baseLTVasCollateral = _ltv; }  /** * @notice allows the configurator to update the liquidation threshold of a reserve * @param _reserve the address of the reserve * @param _threshold the new liquidation threshold **/ function setReserveLiquidationThreshold(address _reserve, uint256 _threshold) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.liquidationThreshold = _threshold; }  /** * @notice allows the configurator to update the liquidation bonus of a reserve * @param _reserve the address of the reserve * @param _bonus the new liquidation bonus **/ function setReserveLiquidationBonus(address _reserve, uint256 _bonus) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.liquidationBonus = _bonus; }  /** * @notice allows the configurator to update the reserve decimals * @param _reserve the address of the reserve * @param _decimals the decimals of the reserve **/ function setReserveDecimals(address _reserve, uint256 _decimals) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.decimals = _decimals; }  /** * @notice internal functions **/  /** * @dev updates the state of a reserve as a consequence of a borrow action. * @param _reserve the address of the reserve on which the user is borrowing * @param _user the address of the borrower * @param _principalBorrowBalance the previous borrow balance of the borrower before the action * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount * @param _amountBorrowed the new amount borrowed * @param _rateMode the borrow rate mode (stable, variable) **/  function updateReserveStateOnBorrowInternal(     address _reserve,     address _user,     uint256 _principalBorrowBalance,     uint256 _balanceIncrease,     uint256 _amountBorrowed,     CoreLibrary.InterestRateMode _rateMode ) internal {     reserves[_reserve].updateCumulativeIndexes();      //increasing reserve total borrows to account for the new borrow balance of the user     //NOTE: Depending on the previous borrow mode, the borrows might need to be switched from variable to stable or vice versa      updateReserveTotalBorrowsByRateModeInternal(         _reserve,         _user,         _principalBorrowBalance,         _balanceIncrease,         _amountBorrowed,         _rateMode     ); }  /** * @dev updates the state of a user as a consequence of a borrow action. * @param _reserve the address of the reserve on which the user is borrowing * @param _user the address of the borrower * @param _amountBorrowed the amount borrowed * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount * @param _rateMode the borrow rate mode (stable, variable) * @return the final borrow rate for the user. Emitted by the borrow() event **/  function updateUserStateOnBorrowInternal(     address _reserve,     address _user,     uint256 _amountBorrowed,     uint256 _balanceIncrease,     uint256 _fee,     CoreLibrary.InterestRateMode _rateMode ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      if (_rateMode == CoreLibrary.InterestRateMode.STABLE) {         //stable         //reset the user variable index, and update the stable rate         user.stableBorrowRate = reserve.currentStableBorrowRate;         user.lastVariableBorrowCumulativeIndex = 0;     } else if (_rateMode == CoreLibrary.InterestRateMode.VARIABLE) {         //variable         //reset the user stable rate, and store the new borrow index         user.stableBorrowRate = 0;         user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;     } else {         revert("Invalid borrow rate mode");     }     //increase the principal borrows and the origination fee     user.principalBorrowBalance = user.principalBorrowBalance.add(_amountBorrowed).add(         _balanceIncrease     );     user.originationFee = user.originationFee.add(_fee);      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp);  }  /** * @dev updates the state of the reserve as a consequence of a repay action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _paybackAmountMinusFees the amount being paid back minus fees * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updateReserveStateOnRepayInternal(     address _reserve,     address _user,     uint256 _paybackAmountMinusFees,     uint256 _balanceIncrease ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_reserve][_user];      CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(_reserve, _user);      //update the indexes     reserves[_reserve].updateCumulativeIndexes();      //compound the cumulated interest to the borrow balance and then subtracting the payback amount     if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             _balanceIncrease,             user.stableBorrowRate         );         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _paybackAmountMinusFees,             user.stableBorrowRate         );     } else {         reserve.increaseTotalBorrowsVariable(_balanceIncrease);         reserve.decreaseTotalBorrowsVariable(_paybackAmountMinusFees);     } }  /** * @dev updates the state of the user as a consequence of a repay action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _paybackAmountMinusFees the amount being paid back minus fees * @param _originationFeeRepaid the fee on the amount that is being repaid * @param _balanceIncrease the accrued interest on the borrowed amount * @param _repaidWholeLoan true if the user is repaying the whole loan **/ function updateUserStateOnRepayInternal(     address _reserve,     address _user,     uint256 _paybackAmountMinusFees,     uint256 _originationFeeRepaid,     uint256 _balanceIncrease,     bool _repaidWholeLoan ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      //update the user principal borrow balance, adding the cumulated interest and then subtracting the payback amount     user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(         _paybackAmountMinusFees     );     user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;      //if the balance decrease is equal to the previous principal (user is repaying the whole loan)     //and the rate mode is stable, we reset the interest rate mode of the user     if (_repaidWholeLoan) {         user.stableBorrowRate = 0;         user.lastVariableBorrowCumulativeIndex = 0;     }     user.originationFee = user.originationFee.sub(_originationFeeRepaid);      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp);  }  /** * @dev updates the state of the user as a consequence of a swap rate action. * @param _reserve the address of the reserve on which the user is performing the rate swap * @param _user the address of the borrower * @param _principalBorrowBalance the the principal amount borrowed by the user * @param _compoundedBorrowBalance the principal amount plus the accrued interest * @param _currentRateMode the rate mode at which the user borrowed **/ function updateReserveStateOnSwapRateInternal(     address _reserve,     address _user,     uint256 _principalBorrowBalance,     uint256 _compoundedBorrowBalance,     CoreLibrary.InterestRateMode _currentRateMode ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      //compounding reserve indexes     reserve.updateCumulativeIndexes();      if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {         uint256 userCurrentStableRate = user.stableBorrowRate;          //swap to variable         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _principalBorrowBalance,             userCurrentStableRate         ); //decreasing stable from old principal balance         reserve.increaseTotalBorrowsVariable(_compoundedBorrowBalance); //increase variable borrows     } else if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         //swap to stable         uint256 currentStableRate = reserve.currentStableBorrowRate;         reserve.decreaseTotalBorrowsVariable(_principalBorrowBalance);         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             _compoundedBorrowBalance,             currentStableRate         );      } else {         revert("Invalid rate mode received");     } }  /** * @dev updates the state of the user as a consequence of a swap rate action. * @param _reserve the address of the reserve on which the user is performing the swap * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount * @param _currentRateMode the current rate mode of the user **/  function updateUserStateOnSwapRateInternal(     address _reserve,     address _user,     uint256 _balanceIncrease,     CoreLibrary.InterestRateMode _currentRateMode ) internal returns (CoreLibrary.InterestRateMode) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      CoreLibrary.InterestRateMode newMode = CoreLibrary.InterestRateMode.NONE;      if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         //switch to stable         newMode = CoreLibrary.InterestRateMode.STABLE;         user.stableBorrowRate = reserve.currentStableBorrowRate;         user.lastVariableBorrowCumulativeIndex = 0;     } else if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {         newMode = CoreLibrary.InterestRateMode.VARIABLE;         user.stableBorrowRate = 0;         user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;     } else {         revert("Invalid interest rate mode received");     }     //compounding cumulated interest     user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);     //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp);      return newMode; }  /** * @dev updates the state of the principal reserve as a consequence of a liquidation action. * @param _principalReserve the address of the principal reserve that is being repaid * @param _user the address of the borrower * @param _amountToLiquidate the amount being repaid by the liquidator * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updatePrincipalReserveStateOnLiquidationInternal(     address _principalReserve,     address _user,     uint256 _amountToLiquidate,     uint256 _balanceIncrease ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_principalReserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_principalReserve];      //update principal reserve data     reserve.updateCumulativeIndexes();      CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(         _principalReserve,         _user     );      if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {         //increase the total borrows by the compounded interest         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             _balanceIncrease,             user.stableBorrowRate         );          //decrease by the actual amount to liquidate         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _amountToLiquidate,             user.stableBorrowRate         );      } else {         //increase the total borrows by the compounded interest         reserve.increaseTotalBorrowsVariable(_balanceIncrease);          //decrease by the actual amount to liquidate         reserve.decreaseTotalBorrowsVariable(_amountToLiquidate);     }  }  /** * @dev updates the state of the collateral reserve as a consequence of a liquidation action. * @param _collateralReserve the address of the collateral reserve that is being liquidated **/ function updateCollateralReserveStateOnLiquidationInternal(     address _collateralReserve ) internal {     //update collateral reserve     reserves[_collateralReserve].updateCumulativeIndexes();  }  /** * @dev updates the state of the user being liquidated as a consequence of a liquidation action. * @param _reserve the address of the principal reserve that is being repaid * @param _user the address of the borrower * @param _amountToLiquidate the amount being repaid by the liquidator * @param _feeLiquidated the amount of origination fee being liquidated * @param _balanceIncrease the accrued interest on the borrowed amount **/ function updateUserStateOnLiquidationInternal(     address _reserve,     address _user,     uint256 _amountToLiquidate,     uint256 _feeLiquidated,     uint256 _balanceIncrease ) internal {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     //first increase by the compounded interest, then decrease by the liquidated amount     user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(         _amountToLiquidate     );      if (         getUserCurrentBorrowRateMode(_reserve, _user) == CoreLibrary.InterestRateMode.VARIABLE     ) {         user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;     }      if(_feeLiquidated &gt; 0){         user.originationFee = user.originationFee.sub(_feeLiquidated);     }      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp); }  /** * @dev updates the state of the reserve as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updateReserveStateOnRebalanceInternal(     address _reserve,     address _user,     uint256 _balanceIncrease ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      reserve.updateCumulativeIndexes();      reserve.increaseTotalBorrowsStableAndUpdateAverageRate(         _balanceIncrease,         user.stableBorrowRate     );  }  /** * @dev updates the state of the user as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updateUserStateOnRebalanceInternal(     address _reserve,     address _user,     uint256 _balanceIncrease ) internal {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);     user.stableBorrowRate = reserve.currentStableBorrowRate;      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp); }  /** * @dev updates the state of the user as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount * @param _amountBorrowed the accrued interest on the borrowed amount **/ function updateReserveTotalBorrowsByRateModeInternal(     address _reserve,     address _user,     uint256 _principalBalance,     uint256 _balanceIncrease,     uint256 _amountBorrowed,     CoreLibrary.InterestRateMode _newBorrowRateMode ) internal {     CoreLibrary.InterestRateMode previousRateMode = getUserCurrentBorrowRateMode(         _reserve,         _user     );     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      if (previousRateMode == CoreLibrary.InterestRateMode.STABLE) {         CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _principalBalance,             user.stableBorrowRate         );     } else if (previousRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         reserve.decreaseTotalBorrowsVariable(_principalBalance);     }      uint256 newPrincipalAmount = _principalBalance.add(_balanceIncrease).add(_amountBorrowed);     if (_newBorrowRateMode == CoreLibrary.InterestRateMode.STABLE) {         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             newPrincipalAmount,             reserve.currentStableBorrowRate         );     } else if (_newBorrowRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         reserve.increaseTotalBorrowsVariable(newPrincipalAmount);     } else {         revert("Invalid new borrow rate mode");     } }  /** * @dev Updates the reserve current stable borrow rate Rf, the current variable borrow rate Rv and the current liquidity rate Rl. * Also updates the lastUpdateTimestamp value. Please refer to the whitepaper for further information. * @param _reserve the address of the reserve to be updated * @param _liquidityAdded the amount of liquidity added to the protocol (deposit or repay) in the previous action * @param _liquidityTaken the amount of liquidity taken from the protocol (redeem or borrow) **/  function updateReserveInterestRatesAndTimestampInternal(     address _reserve,     uint256 _liquidityAdded,     uint256 _liquidityTaken ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     (uint256 newLiquidityRate, uint256 newStableRate, uint256 newVariableRate) = IReserveInterestRateStrategy(         reserve         .interestRateStrategyAddress     )     .calculateInterestRates(         _reserve,         getReserveAvailableLiquidity(_reserve).add(_liquidityAdded).sub(_liquidityTaken),         reserve.totalBorrowsStable,         reserve.totalBorrowsVariable,         reserve.currentAverageStableBorrowRate     );      reserve.currentLiquidityRate = newLiquidityRate;     reserve.currentStableBorrowRate = newStableRate;     reserve.currentVariableBorrowRate = newVariableRate;      //solium-disable-next-line     reserve.lastUpdateTimestamp = uint40(block.timestamp);      emit ReserveUpdated(         _reserve,         newLiquidityRate,         newStableRate,         newVariableRate,         reserve.lastLiquidityCumulativeIndex,         reserve.lastVariableBorrowCumulativeIndex     ); }  /** * @dev transfers to the protocol fees of a flashloan to the fees collection address * @param _token the address of the token being transferred * @param _amount the amount being transferred **/  function transferFlashLoanProtocolFeeInternal(address _token, uint256 _amount) internal {     address payable receiver = address(uint160(addressesProvider.getTokenDistributor()));      if (_token != EthAddressLib.ethAddress()) {         ERC20(_token).safeTransfer(receiver, _amount);     } else {         receiver.transfer(_amount);     } }  /** * @dev updates the internal configuration of the core **/ function refreshConfigInternal() internal {     lendingPoolAddress = addressesProvider.getLendingPool(); }  /** * @dev adds a reserve to the array of the reserves address **/ function addReserveToListInternal(address _reserve) internal {     bool reserveAlreadyAdded = false;     for (uint256 i = 0; i &lt; reservesList.length; i++)         if (reservesList[i] == _reserve) {             reserveAlreadyAdded = true;         }     if (!reserveAlreadyAdded) reservesList.push(_reserve); }  } |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **phase_prompt** | Here is a conversation between two roles: {conversations} {question} |
| **phase_name** | Reflection |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **placeholders** | {'conversations': 'Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.\nYou are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.\nYou can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites\nHere is a new customer\'s task: pragma solidity ^0.5.0;\nimport "openzeppelin-solidity/contracts/math/SafeMath.sol";\nimport "openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol";\nimport "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol";\nimport "openzeppelin-solidity/contracts/utils/Address.sol";\nimport "../libraries/openzeppelin-upgradeability/VersionedInitializable.sol";\nimport "../libraries/CoreLibrary.sol";\nimport "../configuration/LendingPoolAddressesProvider.sol";\nimport "../interfaces/ILendingRateOracle.sol";\nimport "../interfaces/IReserveInterestRateStrategy.sol";\nimport "../libraries/WadRayMath.sol";\nimport "../tokenization/AToken.sol";\nimport "../libraries/EthAddressLib.sol";\n/\n @title LendingPoolCore contract\n @author Aave\n @notice Holds the state of the lending pool and all the funds deposited\n @dev NOTE: The core does not enforce security checks on the update of the state\n (eg, updateStateOnBorrow() does not enforce that borrowed is enabled on the reserve).\n The check that an action can be performed is a duty of the overlying LendingPool contract.\n/\ncontract LendingPoolCore is VersionedInitializable {\n    using SafeMath for uint256;\n    using WadRayMath for uint256;\n    using CoreLibrary for CoreLibrary.ReserveData;\n    using CoreLibrary for CoreLibrary.UserReserveData;\n    using SafeERC20 for ERC20;\n    using Address for address payable;\n    /\n    * @dev Emitted when the state of a reserve is updated\n    * @param reserve the address of the reserve\n    * @param liquidityRate the new liquidity rate\n    * @param stableBorrowRate the new stable borrow rate\n    * @param variableBorrowRate the new variable borrow rate\n    * @param liquidityIndex the new liquidity index\n    * @param variableBorrowIndex the new variable borrow index\n    /\n    event ReserveUpdated(\n        address indexed reserve,\n        uint256 liquidityRate,\n        uint256 stableBorrowRate,\n        uint256 variableBorrowRate,\n        uint256 liquidityIndex,\n        uint256 variableBorrowIndex\n    );\n    address public lendingPoolAddress;\n    LendingPoolAddressesProvider public addressesProvider;\n    /\n    * @dev only lending pools can use functions affected by this modifier\n    /\n    modifier onlyLendingPool {\n        require(lendingPoolAddress == msg.sender, "The caller must be a lending pool contract");\n        ;\n    }\n    /\n    * @dev only lending pools configurator can use functions affected by this modifier\n    /\n    modifier onlyLendingPoolConfigurator {\n        require(\n            addressesProvider.getLendingPoolConfigurator() == msg.sender,\n            "The caller must be a lending pool configurator contract"\n        );\n        ;\n    }\n    mapping(address =&gt; CoreLibrary.ReserveData) internal reserves;\n    mapping(address =&gt; mapping(address =&gt; CoreLibrary.UserReserveData)) internal usersReserveData;\n    address[] public reservesList;\n    uint256 public constant CORE_REVISION = 0x4;\n    /\n    * @dev returns the revision number of the contract\n    /\n    function getRevision() internal pure returns (uint256) {\n        return CORE_REVISION;\n    }\n    /\n    * @dev initializes the Core contract, invoked upon registration on the AddressesProvider\n    * @param _addressesProvider the addressesProvider contract\n    /\n    function initialize(LendingPoolAddressesProvider addressesProvider) public initializer {\n        addressesProvider = _addressesProvider;\n        refreshConfigInternal();\n    }\n    /\n    * @dev updates the state of the core as a result of a deposit action\n    * @param _reserve the address of the reserve in which the deposit is happening\n    * @param _user the address of the the user depositing\n    * @param _amount the amount being deposited\n    * @param _isFirstDeposit true if the user is depositing for the first time\n    /\n    function updateStateOnDeposit(\n        address _reserve,\n        address _user,\n        uint256 _amount,\n        bool _isFirstDeposit\n    ) external onlyLendingPool {\n        reserves[_reserve].updateCumulativeIndexes();\n        updateReserveInterestRatesAndTimestampInternal(_reserve, _amount, 0);\n        if (_isFirstDeposit) {\n            //if this is the first deposit of the user, we configure the deposit as enabled to be used as collateral\n            setUserUseReserveAsCollateral(_reserve, _user, true);\n        }\n    }\n    /\n    * @dev updates the state of the core as a result of a redeem action\n    * @param _reserve the address of the reserve in which the redeem is happening\n    * @param _user the address of the the user redeeming\n    * @param _amountRedeemed the amount being redeemed\n    * @param _userRedeemedEverything true if the user is redeeming everything\n    /\n    function updateStateOnRedeem(\n        address _reserve,\n        address _user,\n        uint256 _amountRedeemed,\n        bool _userRedeemedEverything\n    ) external onlyLendingPool {\n        //compound liquidity and variable borrow interests\n        reserves[_reserve].updateCumulativeIndexes();\n        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountRedeemed);\n        //if user redeemed everything the useReserveAsCollateral flag is reset\n        if (_userRedeemedEverything) {\n            setUserUseReserveAsCollateral(_reserve, _user, false);\n        }\n    }\n    /\n    * @dev updates the state of the core as a result of a flashloan action\n    * @param _reserve the address of the reserve in which the flashloan is happening\n    * @param _income the income of the protocol as a result of the action\n    /\n    function updateStateOnFlashLoan(\n        address _reserve,\n        uint256 _availableLiquidityBefore,\n        uint256 _income,\n        uint256 _protocolFee\n    ) external onlyLendingPool {\n        transferFlashLoanProtocolFeeInternal(_reserve, _protocolFee);\n        //compounding the cumulated interest\n        reserves[_reserve].updateCumulativeIndexes();\n        uint256 totalLiquidityBefore = _availableLiquidityBefore.add(\n            getReserveTotalBorrows(_reserve)\n        );\n        //compounding the received fee into the reserve\n        reserves[_reserve].cumulateToLiquidityIndex(totalLiquidityBefore, _income);\n        //refresh interest rates\n        updateReserveInterestRatesAndTimestampInternal(_reserve, _income, 0);\n    }\n    /\n    * @dev updates the state of the core as a consequence of a borrow action.\n    * @param _reserve the address of the reserve on which the user is borrowing\n    * @param _user the address of the borrower\n    * @param _amountBorrowed the new amount borrowed\n    * @param _borrowFee the fee on the amount borrowed\n    * @param _rateMode the borrow rate mode (stable, variable)\n    * @return the new borrow rate for the user\n    /\n    function updateStateOnBorrow(\n        address _reserve,\n        address _user,\n        uint256 _amountBorrowed,\n        uint256 _borrowFee,\n        CoreLibrary.InterestRateMode _rateMode\n    ) external onlyLendingPool returns (uint256, uint256) {\n        // getting the previous borrow data of the user\n        (uint256 principalBorrowBalance, , uint256 balanceIncrease) = getUserBorrowBalances(\n            _reserve,\n            _user\n        );\n        updateReserveStateOnBorrowInternal(\n            _reserve,\n            _user,\n            principalBorrowBalance,\n            balanceIncrease,\n            _amountBorrowed,\n            _rateMode\n        );\n        updateUserStateOnBorrowInternal(\n            _reserve,\n            _user,\n            _amountBorrowed,\n            balanceIncrease,\n            _borrowFee,\n            _rateMode\n        );\n        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountBorrowed);\n        return (getUserCurrentBorrowRate(_reserve, _user), balanceIncrease);\n    }\n    /\n    * @dev updates the state of the core as a consequence of a repay action.\n    * @param _reserve the address of the reserve on which the user is repaying\n    * @param _user the address of the borrower\n    * @param _paybackAmountMinusFees the amount being paid back minus fees\n    * @param _originationFeeRepaid the fee on the amount that is being repaid\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    * @param _repaidWholeLoan true if the user is repaying the whole loan\n    /\n    function updateStateOnRepay(\n        address _reserve,\n        address _user,\n        uint256 _paybackAmountMinusFees,\n        uint256 _originationFeeRepaid,\n        uint256 _balanceIncrease,\n        bool _repaidWholeLoan\n    ) external onlyLendingPool {\n        updateReserveStateOnRepayInternal(\n            _reserve,\n            _user,\n            _paybackAmountMinusFees,\n            _balanceIncrease\n        );\n        updateUserStateOnRepayInternal(\n            _reserve,\n            _user,\n            _paybackAmountMinusFees,\n            _originationFeeRepaid,\n            _balanceIncrease,\n            _repaidWholeLoan\n        );\n        updateReserveInterestRatesAndTimestampInternal(_reserve, _paybackAmountMinusFees, 0);\n    }\n    /\n    * @dev updates the state of the core as a consequence of a swap rate action.\n    * @param _reserve the address of the reserve on which the user is repaying\n    * @param _user the address of the borrower\n    * @param _principalBorrowBalance the amount borrowed by the user\n    * @param _compoundedBorrowBalance the amount borrowed plus accrued interest\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    * @param _currentRateMode the current interest rate mode for the user\n    /\n    function updateStateOnSwapRate(\n        address _reserve,\n        address _user,\n        uint256 _principalBorrowBalance,\n        uint256 _compoundedBorrowBalance,\n        uint256 _balanceIncrease,\n        CoreLibrary.InterestRateMode _currentRateMode\n    ) external onlyLendingPool returns (CoreLibrary.InterestRateMode, uint256) {\n        updateReserveStateOnSwapRateInternal(\n            _reserve,\n            _user,\n            _principalBorrowBalance,\n            _compoundedBorrowBalance,\n            _currentRateMode\n        );\n        CoreLibrary.InterestRateMode newRateMode = updateUserStateOnSwapRateInternal(\n            _reserve,\n            _user,\n            _balanceIncrease,\n            _currentRateMode\n        );\n        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);\n        return (newRateMode, getUserCurrentBorrowRate(_reserve, _user));\n    }\n    /\n    * @dev updates the state of the core as a consequence of a liquidation action.\n    * @param _principalReserve the address of the principal reserve that is being repaid\n    * @param _collateralReserve the address of the collateral reserve that is being liquidated\n    * @param _user the address of the borrower\n    * @param _amountToLiquidate the amount being repaid by the liquidator\n    * @param _collateralToLiquidate the amount of collateral being liquidated\n    * @param _feeLiquidated the amount of origination fee being liquidated\n    * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise\n    /\n    function updateStateOnLiquidation(\n        address _principalReserve,\n        address _collateralReserve,\n        address _user,\n        uint256 _amountToLiquidate,\n        uint256 _collateralToLiquidate,\n        uint256 _feeLiquidated,\n        uint256 _liquidatedCollateralForFee,\n        uint256 _balanceIncrease,\n        bool _liquidatorReceivesAToken\n    ) external onlyLendingPool {\n        updatePrincipalReserveStateOnLiquidationInternal(\n            _principalReserve,\n            _user,\n            _amountToLiquidate,\n            _balanceIncrease\n        );\n        updateCollateralReserveStateOnLiquidationInternal(\n            _collateralReserve\n        );\n        updateUserStateOnLiquidationInternal(\n            _principalReserve,\n            _user,\n            _amountToLiquidate,\n            _feeLiquidated,\n            _balanceIncrease\n        );\n        updateReserveInterestRatesAndTimestampInternal(_principalReserve, _amountToLiquidate, 0);\n        if (!_liquidatorReceivesAToken) {\n            updateReserveInterestRatesAndTimestampInternal(\n                _collateralReserve,\n                0,\n                _collateralToLiquidate.add(_liquidatedCollateralForFee)\n            );\n        }\n    }\n    /\n    * @dev updates the state of the core as a consequence of a stable rate rebalance\n    * @param _reserve the address of the principal reserve where the user borrowed\n    * @param _user the address of the borrower\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    * @return the new stable rate for the user\n    /\n    function updateStateOnRebalance(address _reserve, address _user, uint256 _balanceIncrease)\n    external\n    onlyLendingPool\n    returns (uint256)\n    {\n        updateReserveStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);\n        //update user data and rebalance the rate\n        updateUserStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);\n        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);\n        return usersReserveData[_user][_reserve].stableBorrowRate;\n    }\n    /\n    * @dev enables or disables a reserve as collateral\n    * @param _reserve the address of the principal reserve where the user deposited\n    * @param _user the address of the depositor\n    * @param _useAsCollateral true if the depositor wants to use the reserve as collateral\n    /\n    function setUserUseReserveAsCollateral(address _reserve, address _user, bool _useAsCollateral)\n    public\n    onlyLendingPool\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        user.useAsCollateral = _useAsCollateral;\n    }\n    /\n    * @notice ETH/token transfer functions\n    /\n    /\n    * @dev fallback function enforces that the caller is a contract, to support flashloan transfers\n    /\n    function() external payable {\n        //only contracts can send ETH to the core\n        require(msg.sender.isContract(), "Only contracts can send ether to the Lending pool core");\n    }\n    /\n    * @dev transfers to the user a specific amount from the reserve.\n    * @param _reserve the address of the reserve where the transfer is happening\n    * @param _user the address of the user receiving the transfer\n    * @param _amount the amount being transferred\n    /\n    function transferToUser(address _reserve, address payable _user, uint256 _amount)\n    external\n    onlyLendingPool\n    {\n        if (_reserve != EthAddressLib.ethAddress()) {\n            ERC20(_reserve).safeTransfer(_user, _amount);\n        } else {\n            //solium-disable-next-line\n            (bool result, ) = _user.call.value(_amount).gas(50000)("");\n            require(result, "Transfer of ETH failed");\n        }\n    }\n    /\n    * @dev transfers the protocol fees to the fees collection address\n    * @param _token the address of the token being transferred\n    * @param _user the address of the user from where the transfer is happening\n    * @param _amount the amount being transferred\n    * @param _destination the fee receiver address\n    /\n    function transferToFeeCollectionAddress(\n        address _token,\n        address _user,\n        uint256 _amount,\n        address _destination\n    ) external payable onlyLendingPool {\n        address payable feeAddress = address(uint160(_destination)); //cast the address to payable\n        if (_token != EthAddressLib.ethAddress()) {\n            require(\n                msg.value == 0,\n                "User is sending ETH along with the ERC20 transfer. Check the value attribute of the transaction"\n            );\n            ERC20(_token).safeTransferFrom(_user, feeAddress, _amount);\n        } else {\n            require(msg.value &gt;= _amount, "The amount and the value sent to deposit do not match");\n            //solium-disable-next-line\n            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");\n            require(result, "Transfer of ETH failed");\n        }\n    }\n    /\n    * @dev transfers the fees to the fees collection address in the case of liquidation\n    * @param _token the address of the token being transferred\n    * @param _amount the amount being transferred\n    * @param _destination the fee receiver address\n    /\n    function liquidateFee(\n        address _token,\n        uint256 _amount,\n        address _destination\n    ) external payable onlyLendingPool {\n        address payable feeAddress = address(uint160(_destination)); //cast the address to payable\n        require(\n            msg.value == 0,\n            "Fee liquidation does not require any transfer of value"\n        );\n        if (_token != EthAddressLib.ethAddress()) {\n            ERC20(_token).safeTransfer(feeAddress, _amount);\n        } else {\n            //solium-disable-next-line\n            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");\n            require(result, "Transfer of ETH failed");\n        }\n    }\n    /\n    * @dev transfers an amount from a user to the destination reserve\n    * @param _reserve the address of the reserve where the amount is being transferred\n    * @param _user the address of the user from where the transfer is happening\n    * @param _amount the amount being transferred\n    /\n    function transferToReserve(address _reserve, address payable _user, uint256 _amount)\n    external\n    payable\n    onlyLendingPool\n    {\n        if (_reserve != EthAddressLib.ethAddress()) {\n            require(msg.value == 0, "User is sending ETH along with the ERC20 transfer.");\n            ERC20(_reserve).safeTransferFrom(_user, address(this), _amount);\n        } else {\n            require(msg.value &gt;= _amount, "The amount and the value sent to deposit do not match");\n            if (msg.value &gt; _amount) {\n                //send back excess ETH\n                uint256 excessAmount = msg.value.sub(_amount);\n                //solium-disable-next-line\n                (bool result, ) = _user.call.value(excessAmount).gas(50000)("");\n                require(result, "Transfer of ETH failed");\n            }\n        }\n    }\n    /\n    * @notice data access functions\n    /\n    /\n    * @dev returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral)\n    * needed to calculate the global account data in the LendingPoolDataProvider\n    * @param _reserve the address of the reserve\n    * @param _user the address of the user\n    * @return the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not\n    /\n    function getUserBasicReserveData(address _reserve, address _user)\n    external\n    view\n    returns (uint256, uint256, uint256, bool)\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        uint256 underlyingBalance = getUserUnderlyingAssetBalance(_reserve, _user);\n        if (user.principalBorrowBalance == 0) {\n            return (underlyingBalance, 0, 0, user.useAsCollateral);\n        }\n        return (\n        underlyingBalance,\n        user.getCompoundedBorrowBalance(reserve),\n        user.originationFee,\n        user.useAsCollateral\n        );\n    }\n    /\n    * @dev checks if a user is allowed to borrow at a stable rate\n    * @param _reserve the reserve address\n    * @param _user the user\n    * @param _amount the amount the the user wants to borrow\n    * @return true if the user is allowed to borrow at a stable rate, false otherwise\n    /\n    function isUserAllowedToBorrowAtStable(address _reserve, address _user, uint256 _amount)\n    external\n    view\n    returns (bool)\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        if (!reserve.isStableBorrowRateEnabled) return false;\n        return\n        !user.useAsCollateral ||\n        !reserve.usageAsCollateralEnabled ||\n        _amount &gt; getUserUnderlyingAssetBalance(_reserve, _user);\n    }\n    /\n    * @dev gets the underlying asset balance of a user based on the corresponding aToken balance.\n    * @param _reserve the reserve address\n    * @param _user the user address\n    * @return the underlying deposit balance of the user\n    /\n    function getUserUnderlyingAssetBalance(address _reserve, address _user)\n    public\n    view\n    returns (uint256)\n    {\n        AToken aToken = AToken(reserves[_reserve].aTokenAddress);\n        return aToken.balanceOf(_user);\n    }\n    /\n    * @dev gets the interest rate strategy contract address for the reserve\n    * @param _reserve the reserve address\n    * @return the address of the interest rate strategy contract\n    /\n    function getReserveInterestRateStrategyAddress(address _reserve) public view returns (address) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.interestRateStrategyAddress;\n    }\n    /\n    * @dev gets the aToken contract address for the reserve\n    * @param _reserve the reserve address\n    * @return the address of the aToken contract\n    /\n    function getReserveATokenAddress(address _reserve) public view returns (address) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.aTokenAddress;\n    }\n    /\n    * @dev gets the available liquidity in the reserve. The available liquidity is the balance of the core contract\n    * @param _reserve the reserve address\n    * @return the available liquidity\n    /\n    function getReserveAvailableLiquidity(address _reserve) public view returns (uint256) {\n        uint256 balance = 0;\n        if (_reserve == EthAddressLib.ethAddress()) {\n            balance = address(this).balance;\n        } else {\n            balance = IERC20(_reserve).balanceOf(address(this));\n        }\n        return balance;\n    }\n    /\n    * @dev gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows\n    * @param _reserve the reserve address\n    * @return the total liquidity\n    /\n    function getReserveTotalLiquidity(address _reserve) public view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return getReserveAvailableLiquidity(_reserve).add(reserve.getTotalBorrows());\n    }\n    /\n    * @dev gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there\n    * there has been 100% income.\n    * @param _reserve the reserve address\n    * @return the reserve normalized income\n    /\n    function getReserveNormalizedIncome(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.getNormalizedIncome();\n    }\n    /\n    * @dev gets the reserve total borrows\n    * @param _reserve the reserve address\n    * @return the total borrows (stable + variable)\n    /\n    function getReserveTotalBorrows(address _reserve) public view returns (uint256) {\n        return reserves[_reserve].getTotalBorrows();\n    }\n    /\n    * @dev gets the reserve total borrows stable\n    * @param _reserve the reserve address\n    * @return the total borrows stable\n    /\n    function getReserveTotalBorrowsStable(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.totalBorrowsStable;\n    }\n    /\n    * @dev gets the reserve total borrows variable\n    * @param _reserve the reserve address\n    * @return the total borrows variable\n    /\n    function getReserveTotalBorrowsVariable(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.totalBorrowsVariable;\n    }\n    /\n    * @dev gets the reserve liquidation threshold\n    * @param _reserve the reserve address\n    * @return the reserve liquidation threshold\n    /\n    function getReserveLiquidationThreshold(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.liquidationThreshold;\n    }\n    /\n    * @dev gets the reserve liquidation bonus\n    * @param _reserve the reserve address\n    * @return the reserve liquidation bonus\n    /\n    function getReserveLiquidationBonus(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.liquidationBonus;\n    }\n    /\n    * @dev gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty\n    * @param _reserve the reserve address\n    * @return the reserve current variable borrow rate\n    /\n    function getReserveCurrentVariableBorrowRate(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        if (reserve.currentVariableBorrowRate == 0) {\n            return\n            IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)\n            .getBaseVariableBorrowRate();\n        }\n        return reserve.currentVariableBorrowRate;\n    }\n    /\n    * @dev gets the reserve current stable borrow rate. Is the market rate if the reserve is empty\n    * @param _reserve the reserve address\n    * @return the reserve current stable borrow rate\n    /\n    function getReserveCurrentStableBorrowRate(address _reserve) public view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        ILendingRateOracle oracle = ILendingRateOracle(addressesProvider.getLendingRateOracle());\n        if (reserve.currentStableBorrowRate == 0) {\n            //no stable rate borrows yet\n            return oracle.getMarketBorrowRate(_reserve);\n        }\n        return reserve.currentStableBorrowRate;\n    }\n    /\n    * @dev gets the reserve average stable borrow rate. The average stable rate is the weighted average\n    * of all the loans taken at stable rate.\n    * @param _reserve the reserve address\n    * @return the reserve current average borrow rate\n    /\n    function getReserveCurrentAverageStableBorrowRate(address _reserve)\n    external\n    view\n    returns (uint256)\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.currentAverageStableBorrowRate;\n    }\n    /\n    * @dev gets the reserve liquidity rate\n    * @param _reserve the reserve address\n    * @return the reserve liquidity rate\n    /\n    function getReserveCurrentLiquidityRate(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.currentLiquidityRate;\n    }\n    /\n    * @dev gets the reserve liquidity cumulative index\n    * @param _reserve the reserve address\n    * @return the reserve liquidity cumulative index\n    /\n    function getReserveLiquidityCumulativeIndex(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.lastLiquidityCumulativeIndex;\n    }\n    /\n    * @dev gets the reserve variable borrow index\n    * @param _reserve the reserve address\n    * @return the reserve variable borrow index\n    /\n    function getReserveVariableBorrowsCumulativeIndex(address _reserve)\n    external\n    view\n    returns (uint256)\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.lastVariableBorrowCumulativeIndex;\n    }\n    /\n    * @dev this function aggregates the configuration parameters of the reserve.\n    * It\'s used in the LendingPoolDataProvider specifically to save gas, and avoid\n    * multiple external contract calls to fetch the same data.\n    * @param _reserve the reserve address\n    * @return the reserve decimals\n    * @return the base ltv as collateral\n    * @return the liquidation threshold\n    * @return if the reserve is used as collateral or not\n    /\n    function getReserveConfiguration(address _reserve)\n    external\n    view\n    returns (uint256, uint256, uint256, bool)\n    {\n        uint256 decimals;\n        uint256 baseLTVasCollateral;\n        uint256 liquidationThreshold;\n        bool usageAsCollateralEnabled;\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        decimals = reserve.decimals;\n        baseLTVasCollateral = reserve.baseLTVasCollateral;\n        liquidationThreshold = reserve.liquidationThreshold;\n        usageAsCollateralEnabled = reserve.usageAsCollateralEnabled;\n        return (decimals, baseLTVasCollateral, liquidationThreshold, usageAsCollateralEnabled);\n    }\n    /\n    * @dev returns the decimals of the reserve\n    * @param _reserve the reserve address\n    * @return the reserve decimals\n    /\n    function getReserveDecimals(address _reserve) external view returns (uint256) {\n        return reserves[_reserve].decimals;\n    }\n    /\n    * @dev returns true if the reserve is enabled for borrowing\n    * @param _reserve the reserve address\n    * @return true if the reserve is enabled for borrowing, false otherwise\n    /\n    function isReserveBorrowingEnabled(address _reserve) external view returns (bool) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.borrowingEnabled;\n    }\n    /\n    * @dev returns true if the reserve is enabled as collateral\n    * @param _reserve the reserve address\n    * @return true if the reserve is enabled as collateral, false otherwise\n    /\n    function isReserveUsageAsCollateralEnabled(address _reserve) external view returns (bool) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.usageAsCollateralEnabled;\n    }\n    /\n    * @dev returns true if the stable rate is enabled on reserve\n    * @param _reserve the reserve address\n    * @return true if the stable rate is enabled on reserve, false otherwise\n    /\n    function getReserveIsStableBorrowRateEnabled(address _reserve) external view returns (bool) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.isStableBorrowRateEnabled;\n    }\n    /\n    * @dev returns true if the reserve is active\n    * @param _reserve the reserve address\n    * @return true if the reserve is active, false otherwise\n    /\n    function getReserveIsActive(address _reserve) external view returns (bool) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.isActive;\n    }\n    /\n    * @notice returns if a reserve is freezed\n    * @param _reserve the reserve for which the information is needed\n    * @return true if the reserve is freezed, false otherwise\n    /\n    function getReserveIsFreezed(address _reserve) external view returns (bool) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.isFreezed;\n    }\n    /\n    * @notice returns the timestamp of the last action on the reserve\n    * @param _reserve the reserve for which the information is needed\n    * @return the last updated timestamp of the reserve\n    /\n    function getReserveLastUpdate(address _reserve) external view returns (uint40 timestamp) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        timestamp = reserve.lastUpdateTimestamp;\n    }\n    /\n    * @dev returns the utilization rate U of a specific reserve\n    * @param _reserve the reserve for which the information is needed\n    * @return the utilization rate in ray\n    /\n    function getReserveUtilizationRate(address _reserve) public view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        uint256 totalBorrows = reserve.getTotalBorrows();\n        if (totalBorrows == 0) {\n            return 0;\n        }\n        uint256 availableLiquidity = getReserveAvailableLiquidity(_reserve);\n        return totalBorrows.rayDiv(availableLiquidity.add(totalBorrows));\n    }\n    /\n    * @return the array of reserves configured on the core\n    /\n    function getReserves() external view returns (address[] memory) {\n        return reservesList;\n    }\n    /\n    * @param _reserve the address of the reserve for which the information is needed\n    * @param _user the address of the user for which the information is needed\n    * @return true if the user has chosen to use the reserve as collateral, false otherwise\n    /\n    function isUserUseReserveAsCollateralEnabled(address _reserve, address _user)\n    external\n    view\n    returns (bool)\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        return user.useAsCollateral;\n    }\n    /\n    * @param _reserve the address of the reserve for which the information is needed\n    * @param _user the address of the user for which the information is needed\n    * @return the origination fee for the user\n    /\n    function getUserOriginationFee(address _reserve, address _user)\n    external\n    view\n    returns (uint256)\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        return user.originationFee;\n    }\n    /\n    * @dev users with no loans in progress have NONE as borrow rate mode\n    * @param _reserve the address of the reserve for which the information is needed\n    * @param _user the address of the user for which the information is needed\n    * @return the borrow rate mode for the user,\n    /\n    function getUserCurrentBorrowRateMode(address _reserve, address _user)\n    public\n    view\n    returns (CoreLibrary.InterestRateMode)\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        if (user.principalBorrowBalance == 0) {\n            return CoreLibrary.InterestRateMode.NONE;\n        }\n        return\n        user.stableBorrowRate &gt; 0\n        ? CoreLibrary.InterestRateMode.STABLE\n        : CoreLibrary.InterestRateMode.VARIABLE;\n    }\n    /\n    * @dev gets the current borrow rate of the user\n    * @param _reserve the address of the reserve for which the information is needed\n    * @param _user the address of the user for which the information is needed\n    * @return the borrow rate for the user,\n    /\n    function getUserCurrentBorrowRate(address _reserve, address _user)\n    internal\n    view\n    returns (uint256)\n    {\n        CoreLibrary.InterestRateMode rateMode = getUserCurrentBorrowRateMode(_reserve, _user);\n        if (rateMode == CoreLibrary.InterestRateMode.NONE) {\n            return 0;\n        }\n        return\n        rateMode == CoreLibrary.InterestRateMode.STABLE\n        ? usersReserveData[_user][_reserve].stableBorrowRate\n        : reserves[_reserve].currentVariableBorrowRate;\n    }\n    /\n    * @dev the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all\n    * @param _reserve the address of the reserve for which the information is needed\n    * @param _user the address of the user for which the information is needed\n    * @return the user stable rate\n    /\n    function getUserCurrentStableBorrowRate(address _reserve, address _user)\n    external\n    view\n    returns (uint256)\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        return user.stableBorrowRate;\n    }\n    /\n    * @dev calculates and returns the borrow balances of the user\n    * @param _reserve the address of the reserve\n    * @param _user the address of the user\n    * @return the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance\n    /\n    function getUserBorrowBalances(address _reserve, address _user)\n    public\n    view\n    returns (uint256, uint256, uint256)\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        if (user.principalBorrowBalance == 0) {\n            return (0, 0, 0);\n        }\n        uint256 principal = user.principalBorrowBalance;\n        uint256 compoundedBalance = CoreLibrary.getCompoundedBorrowBalance(\n            user,\n            reserves[_reserve]\n        );\n        return (principal, compoundedBalance, compoundedBalance.sub(principal));\n    }\n    /\n    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable\n    * @param _reserve the address of the reserve for which the information is needed\n    * @param _user the address of the user for which the information is needed\n    * @return the variable borrow index for the user\n    /\n    function getUserVariableBorrowCumulativeIndex(address _reserve, address _user)\n    external\n    view\n    returns (uint256)\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        return user.lastVariableBorrowCumulativeIndex;\n    }\n    /\n    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable\n    * @param _reserve the address of the reserve for which the information is needed\n    * @param _user the address of the user for which the information is needed\n    * @return the variable borrow index for the user\n    /\n    function getUserLastUpdate(address _reserve, address _user)\n    external\n    view\n    returns (uint256 timestamp)\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        timestamp = user.lastUpdateTimestamp;\n    }\n    /\n    * @dev updates the lending pool core configuration\n    /\n    function refreshConfiguration() external onlyLendingPoolConfigurator {\n        refreshConfigInternal();\n    }\n    /\n    * @dev initializes a reserve\n    * @param _reserve the address of the reserve\n    * @param _aTokenAddress the address of the overlying aToken contract\n    * @param _decimals the decimals of the reserve currency\n    * @param _interestRateStrategyAddress the address of the interest rate strategy contract\n    /\n    function initReserve(\n        address _reserve,\n        address _aTokenAddress,\n        uint256 _decimals,\n        address _interestRateStrategyAddress\n    ) external onlyLendingPoolConfigurator {\n        reserves[_reserve].init(_aTokenAddress, _decimals, _interestRateStrategyAddress);\n        addReserveToListInternal(_reserve);\n    }\n\n    /\n    * @dev removes the last added reserve in the reservesList array\n    * @param _reserveToRemove the address of the reserve\n    /\n    function removeLastAddedReserve(address _reserveToRemove)\n    external onlyLendingPoolConfigurator {\n        address lastReserve = reservesList[reservesList.length-1];\n        require(lastReserve == _reserveToRemove, "Reserve being removed is different than the reserve requested");\n        //as we can\'t check if totalLiquidity is 0 (since the reserve added might not be an ERC20) we at least check that there is nothing borrowed\n        require(getReserveTotalBorrows(lastReserve) == 0, "Cannot remove a reserve with liquidity deposited");\n        reserves[lastReserve].isActive = false;\n        reserves[lastReserve].aTokenAddress = address(0);\n        reserves[lastReserve].decimals = 0;\n        reserves[lastReserve].lastLiquidityCumulativeIndex = 0;\n        reserves[lastReserve].lastVariableBorrowCumulativeIndex = 0;\n        reserves[lastReserve].borrowingEnabled = false;\n        reserves[lastReserve].usageAsCollateralEnabled = false;\n        reserves[lastReserve].baseLTVasCollateral = 0;\n        reserves[lastReserve].liquidationThreshold = 0;\n        reserves[lastReserve].liquidationBonus = 0;\n        reserves[lastReserve].interestRateStrategyAddress = address(0);\n        reservesList.pop();\n    }\n    /\n    * @dev updates the address of the interest rate strategy contract\n    * @param _reserve the address of the reserve\n    * @param _rateStrategyAddress the address of the interest rate strategy contract\n    /\n    function setReserveInterestRateStrategyAddress(address _reserve, address _rateStrategyAddress)\n    external\n    onlyLendingPoolConfigurator\n    {\n        reserves[_reserve].interestRateStrategyAddress = _rateStrategyAddress;\n    }\n    /\n    * @dev enables borrowing on a reserve. Also sets the stable rate borrowing\n    * @param _reserve the address of the reserve\n    * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise\n    /\n    function enableBorrowingOnReserve(address _reserve, bool _stableBorrowRateEnabled)\n    external\n    onlyLendingPoolConfigurator\n    {\n        reserves[_reserve].enableBorrowing(_stableBorrowRateEnabled);\n    }\n    /\n    * @dev disables borrowing on a reserve\n    * @param _reserve the address of the reserve\n    /\n    function disableBorrowingOnReserve(address _reserve) external onlyLendingPoolConfigurator {\n        reserves[_reserve].disableBorrowing();\n    }\n    /\n    * @dev enables a reserve to be used as collateral\n    * @param _reserve the address of the reserve\n    /\n    function enableReserveAsCollateral(\n        address _reserve,\n        uint256 _baseLTVasCollateral,\n        uint256 _liquidationThreshold,\n        uint256 _liquidationBonus\n    ) external onlyLendingPoolConfigurator {\n        reserves[_reserve].enableAsCollateral(\n            _baseLTVasCollateral,\n            _liquidationThreshold,\n            _liquidationBonus\n        );\n    }\n    /\n    * @dev disables a reserve to be used as collateral\n    * @param _reserve the address of the reserve\n    /\n    function disableReserveAsCollateral(address _reserve) external onlyLendingPoolConfigurator {\n        reserves[_reserve].disableAsCollateral();\n    }\n    /\n    * @dev enable the stable borrow rate mode on a reserve\n    * @param _reserve the address of the reserve\n    /\n    function enableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.isStableBorrowRateEnabled = true;\n    }\n    /\n    * @dev disable the stable borrow rate mode on a reserve\n    * @param _reserve the address of the reserve\n    /\n    function disableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.isStableBorrowRateEnabled = false;\n    }\n    /\n    * @dev activates a reserve\n    * @param _reserve the address of the reserve\n    /\n    function activateReserve(address _reserve) external onlyLendingPoolConfigurator {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        require(\n            reserve.lastLiquidityCumulativeIndex &gt; 0 &amp;&amp;\n            reserve.lastVariableBorrowCumulativeIndex &gt; 0,\n            "Reserve has not been initialized yet"\n        );\n        reserve.isActive = true;\n    }\n    /\n    * @dev deactivates a reserve\n    * @param _reserve the address of the reserve\n    /\n    function deactivateReserve(address _reserve) external onlyLendingPoolConfigurator {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.isActive = false;\n    }\n    /\n    * @notice allows the configurator to freeze the reserve.\n    * A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance.\n    * @param _reserve the address of the reserve\n    /\n    function freezeReserve(address _reserve) external onlyLendingPoolConfigurator {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.isFreezed = true;\n    }\n    /\n    * @notice allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed.\n    * @param _reserve the address of the reserve\n    /\n    function unfreezeReserve(address _reserve) external onlyLendingPoolConfigurator {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.isFreezed = false;\n    }\n    /\n    * @notice allows the configurator to update the loan to value of a reserve\n    * @param _reserve the address of the reserve\n    * @param _ltv the new loan to value\n    /\n    function setReserveBaseLTVasCollateral(address _reserve, uint256 _ltv)\n    external\n    onlyLendingPoolConfigurator\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.baseLTVasCollateral = _ltv;\n    }\n    /\n    * @notice allows the configurator to update the liquidation threshold of a reserve\n    * @param _reserve the address of the reserve\n    * @param _threshold the new liquidation threshold\n    /\n    function setReserveLiquidationThreshold(address _reserve, uint256 _threshold)\n    external\n    onlyLendingPoolConfigurator\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.liquidationThreshold = _threshold;\n    }\n    /\n    * @notice allows the configurator to update the liquidation bonus of a reserve\n    * @param _reserve the address of the reserve\n    * @param _bonus the new liquidation bonus\n    /\n    function setReserveLiquidationBonus(address _reserve, uint256 _bonus)\n    external\n    onlyLendingPoolConfigurator\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.liquidationBonus = _bonus;\n    }\n    /\n    * @notice allows the configurator to update the reserve decimals\n    * @param _reserve the address of the reserve\n    * @param _decimals the decimals of the reserve\n    /\n    function setReserveDecimals(address _reserve, uint256 _decimals)\n    external\n    onlyLendingPoolConfigurator\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.decimals = _decimals;\n    }\n    /\n    * @notice internal functions\n    /\n    /\n    * @dev updates the state of a reserve as a consequence of a borrow action.\n    * @param _reserve the address of the reserve on which the user is borrowing\n    * @param _user the address of the borrower\n    * @param _principalBorrowBalance the previous borrow balance of the borrower before the action\n    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount\n    * @param _amountBorrowed the new amount borrowed\n    * @param _rateMode the borrow rate mode (stable, variable)\n    /\n    function updateReserveStateOnBorrowInternal(\n        address _reserve,\n        address _user,\n        uint256 _principalBorrowBalance,\n        uint256 _balanceIncrease,\n        uint256 _amountBorrowed,\n        CoreLibrary.InterestRateMode _rateMode\n    ) internal {\n        reserves[_reserve].updateCumulativeIndexes();\n        //increasing reserve total borrows to account for the new borrow balance of the user\n        //NOTE: Depending on the previous borrow mode, the borrows might need to be switched from variable to stable or vice versa\n        updateReserveTotalBorrowsByRateModeInternal(\n            _reserve,\n            _user,\n            _principalBorrowBalance,\n            _balanceIncrease,\n            _amountBorrowed,\n            _rateMode\n        );\n    }\n    /\n    * @dev updates the state of a user as a consequence of a borrow action.\n    * @param _reserve the address of the reserve on which the user is borrowing\n    * @param _user the address of the borrower\n    * @param _amountBorrowed the amount borrowed\n    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount\n    * @param _rateMode the borrow rate mode (stable, variable)\n    * @return the final borrow rate for the user. Emitted by the borrow() event\n    /\n    function updateUserStateOnBorrowInternal(\n        address _reserve,\n        address _user,\n        uint256 _amountBorrowed,\n        uint256 _balanceIncrease,\n        uint256 _fee,\n        CoreLibrary.InterestRateMode _rateMode\n    ) internal {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        if (_rateMode == CoreLibrary.InterestRateMode.STABLE) {\n            //stable\n            //reset the user variable index, and update the stable rate\n            user.stableBorrowRate = reserve.currentStableBorrowRate;\n            user.lastVariableBorrowCumulativeIndex = 0;\n        } else if (_rateMode == CoreLibrary.InterestRateMode.VARIABLE) {\n            //variable\n            //reset the user stable rate, and store the new borrow index\n            user.stableBorrowRate = 0;\n            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;\n        } else {\n            revert("Invalid borrow rate mode");\n        }\n        //increase the principal borrows and the origination fee\n        user.principalBorrowBalance = user.principalBorrowBalance.add(_amountBorrowed).add(\n            _balanceIncrease\n        );\n        user.originationFee = user.originationFee.add(_fee);\n        //solium-disable-next-line\n        user.lastUpdateTimestamp = uint40(block.timestamp);\n    }\n    /\n    * @dev updates the state of the reserve as a consequence of a repay action.\n    * @param _reserve the address of the reserve on which the user is repaying\n    * @param _user the address of the borrower\n    * @param _paybackAmountMinusFees the amount being paid back minus fees\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    /\n    function updateReserveStateOnRepayInternal(\n        address _reserve,\n        address _user,\n        uint256 _paybackAmountMinusFees,\n        uint256 _balanceIncrease\n    ) internal {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_reserve][_user];\n        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(_reserve, _user);\n        //update the indexes\n        reserves[_reserve].updateCumulativeIndexes();\n        //compound the cumulated interest to the borrow balance and then subtracting the payback amount\n        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {\n            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(\n                _balanceIncrease,\n                user.stableBorrowRate\n            );\n            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(\n                _paybackAmountMinusFees,\n                user.stableBorrowRate\n            );\n        } else {\n            reserve.increaseTotalBorrowsVariable(_balanceIncrease);\n            reserve.decreaseTotalBorrowsVariable(_paybackAmountMinusFees);\n        }\n    }\n    /\n    * @dev updates the state of the user as a consequence of a repay action.\n    * @param _reserve the address of the reserve on which the user is repaying\n    * @param _user the address of the borrower\n    * @param _paybackAmountMinusFees the amount being paid back minus fees\n    * @param _originationFeeRepaid the fee on the amount that is being repaid\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    * @param _repaidWholeLoan true if the user is repaying the whole loan\n    /\n    function updateUserStateOnRepayInternal(\n        address _reserve,\n        address _user,\n        uint256 _paybackAmountMinusFees,\n        uint256 _originationFeeRepaid,\n        uint256 _balanceIncrease,\n        bool _repaidWholeLoan\n    ) internal {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        //update the user principal borrow balance, adding the cumulated interest and then subtracting the payback amount\n        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(\n            _paybackAmountMinusFees\n        );\n        user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;\n        //if the balance decrease is equal to the previous principal (user is repaying the whole loan)\n        //and the rate mode is stable, we reset the interest rate mode of the user\n        if (_repaidWholeLoan) {\n            user.stableBorrowRate = 0;\n            user.lastVariableBorrowCumulativeIndex = 0;\n        }\n        user.originationFee = user.originationFee.sub(_originationFeeRepaid);\n        //solium-disable-next-line\n        user.lastUpdateTimestamp = uint40(block.timestamp);\n    }\n    /\n    * @dev updates the state of the user as a consequence of a swap rate action.\n    * @param _reserve the address of the reserve on which the user is performing the rate swap\n    * @param _user the address of the borrower\n    * @param _principalBorrowBalance the the principal amount borrowed by the user\n    * @param _compoundedBorrowBalance the principal amount plus the accrued interest\n    * @param _currentRateMode the rate mode at which the user borrowed\n    /\n    function updateReserveStateOnSwapRateInternal(\n        address _reserve,\n        address _user,\n        uint256 _principalBorrowBalance,\n        uint256 _compoundedBorrowBalance,\n        CoreLibrary.InterestRateMode _currentRateMode\n    ) internal {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        //compounding reserve indexes\n        reserve.updateCumulativeIndexes();\n        if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {\n            uint256 userCurrentStableRate = user.stableBorrowRate;\n            //swap to variable\n            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(\n                _principalBorrowBalance,\n                userCurrentStableRate\n            ); //decreasing stable from old principal balance\n            reserve.increaseTotalBorrowsVariable(_compoundedBorrowBalance); //increase variable borrows\n        } else if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {\n            //swap to stable\n            uint256 currentStableRate = reserve.currentStableBorrowRate;\n            reserve.decreaseTotalBorrowsVariable(_principalBorrowBalance);\n            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(\n                _compoundedBorrowBalance,\n                currentStableRate\n            );\n        } else {\n            revert("Invalid rate mode received");\n        }\n    }\n    /\n    * @dev updates the state of the user as a consequence of a swap rate action.\n    * @param _reserve the address of the reserve on which the user is performing the swap\n    * @param _user the address of the borrower\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    * @param _currentRateMode the current rate mode of the user\n    /\n    function updateUserStateOnSwapRateInternal(\n        address _reserve,\n        address _user,\n        uint256 _balanceIncrease,\n        CoreLibrary.InterestRateMode _currentRateMode\n    ) internal returns (CoreLibrary.InterestRateMode) {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        CoreLibrary.InterestRateMode newMode = CoreLibrary.InterestRateMode.NONE;\n        if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {\n            //switch to stable\n            newMode = CoreLibrary.InterestRateMode.STABLE;\n            user.stableBorrowRate = reserve.currentStableBorrowRate;\n            user.lastVariableBorrowCumulativeIndex = 0;\n        } else if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {\n            newMode = CoreLibrary.InterestRateMode.VARIABLE;\n            user.stableBorrowRate = 0;\n            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;\n        } else {\n            revert("Invalid interest rate mode received");\n        }\n        //compounding cumulated interest\n        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);\n        //solium-disable-next-line\n        user.lastUpdateTimestamp = uint40(block.timestamp);\n        return newMode;\n    }\n    /\n    * @dev updates the state of the principal reserve as a consequence of a liquidation action.\n    * @param _principalReserve the address of the principal reserve that is being repaid\n    * @param _user the address of the borrower\n    * @param _amountToLiquidate the amount being repaid by the liquidator\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    /\n    function updatePrincipalReserveStateOnLiquidationInternal(\n        address _principalReserve,\n        address _user,\n        uint256 _amountToLiquidate,\n        uint256 _balanceIncrease\n    ) internal {\n        CoreLibrary.ReserveData storage reserve = reserves[_principalReserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_principalReserve];\n        //update principal reserve data\n        reserve.updateCumulativeIndexes();\n        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(\n            _principalReserve,\n            _user\n        );\n        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {\n            //increase the total borrows by the compounded interest\n            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(\n                _balanceIncrease,\n                user.stableBorrowRate\n            );\n            //decrease by the actual amount to liquidate\n            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(\n                _amountToLiquidate,\n                user.stableBorrowRate\n            );\n        } else {\n            //increase the total borrows by the compounded interest\n            reserve.increaseTotalBorrowsVariable(_balanceIncrease);\n            //decrease by the actual amount to liquidate\n            reserve.decreaseTotalBorrowsVariable(_amountToLiquidate);\n        }\n    }\n    /\n    * @dev updates the state of the collateral reserve as a consequence of a liquidation action.\n    * @param _collateralReserve the address of the collateral reserve that is being liquidated\n    /\n    function updateCollateralReserveStateOnLiquidationInternal(\n        address _collateralReserve\n    ) internal {\n        //update collateral reserve\n        reserves[_collateralReserve].updateCumulativeIndexes();\n    }\n    /\n    * @dev updates the state of the user being liquidated as a consequence of a liquidation action.\n    * @param _reserve the address of the principal reserve that is being repaid\n    * @param _user the address of the borrower\n    * @param _amountToLiquidate the amount being repaid by the liquidator\n    * @param _feeLiquidated the amount of origination fee being liquidated\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    /\n    function updateUserStateOnLiquidationInternal(\n        address _reserve,\n        address _user,\n        uint256 _amountToLiquidate,\n        uint256 _feeLiquidated,\n        uint256 _balanceIncrease\n    ) internal {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        //first increase by the compounded interest, then decrease by the liquidated amount\n        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(\n            _amountToLiquidate\n        );\n        if (\n            getUserCurrentBorrowRateMode(_reserve, _user) == CoreLibrary.InterestRateMode.VARIABLE\n        ) {\n            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;\n        }\n        if(_feeLiquidated &gt; 0){\n            user.originationFee = user.originationFee.sub(_feeLiquidated);\n        }\n        //solium-disable-next-line\n        user.lastUpdateTimestamp = uint40(block.timestamp);\n    }\n    /\n    * @dev updates the state of the reserve as a consequence of a stable rate rebalance\n    * @param _reserve the address of the principal reserve where the user borrowed\n    * @param _user the address of the borrower\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    /\n    function updateReserveStateOnRebalanceInternal(\n        address _reserve,\n        address _user,\n        uint256 _balanceIncrease\n    ) internal {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        reserve.updateCumulativeIndexes();\n        reserve.increaseTotalBorrowsStableAndUpdateAverageRate(\n            _balanceIncrease,\n            user.stableBorrowRate\n        );\n    }\n    /\n    * @dev updates the state of the user as a consequence of a stable rate rebalance\n    * @param _reserve the address of the principal reserve where the user borrowed\n    * @param _user the address of the borrower\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    /\n    function updateUserStateOnRebalanceInternal(\n        address _reserve,\n        address _user,\n        uint256 _balanceIncrease\n    ) internal {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);\n        user.stableBorrowRate = reserve.currentStableBorrowRate;\n        //solium-disable-next-line\n        user.lastUpdateTimestamp = uint40(block.timestamp);\n    }\n    /\n    * @dev updates the state of the user as a consequence of a stable rate rebalance\n    * @param _reserve the address of the principal reserve where the user borrowed\n    * @param _user the address of the borrower\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    * @param _amountBorrowed the accrued interest on the borrowed amount\n    /\n    function updateReserveTotalBorrowsByRateModeInternal(\n        address _reserve,\n        address _user,\n        uint256 _principalBalance,\n        uint256 _balanceIncrease,\n        uint256 _amountBorrowed,\n        CoreLibrary.InterestRateMode _newBorrowRateMode\n    ) internal {\n        CoreLibrary.InterestRateMode previousRateMode = getUserCurrentBorrowRateMode(\n            _reserve,\n            _user\n        );\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        if (previousRateMode == CoreLibrary.InterestRateMode.STABLE) {\n            CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(\n                _principalBalance,\n                user.stableBorrowRate\n            );\n        } else if (previousRateMode == CoreLibrary.InterestRateMode.VARIABLE) {\n            reserve.decreaseTotalBorrowsVariable(_principalBalance);\n        }\n        uint256 newPrincipalAmount = _principalBalance.add(_balanceIncrease).add(_amountBorrowed);\n        if (_newBorrowRateMode == CoreLibrary.InterestRateMode.STABLE) {\n            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(\n                newPrincipalAmount,\n                reserve.currentStableBorrowRate\n            );\n        } else if (_newBorrowRateMode == CoreLibrary.InterestRateMode.VARIABLE) {\n            reserve.increaseTotalBorrowsVariable(newPrincipalAmount);\n        } else {\n            revert("Invalid new borrow rate mode");\n        }\n    }\n    /\n    * @dev Updates the reserve current stable borrow rate Rf, the current variable borrow rate Rv and the current liquidity rate Rl.\n    * Also updates the lastUpdateTimestamp value. Please refer to the whitepaper for further information.\n    * @param _reserve the address of the reserve to be updated\n    * @param _liquidityAdded the amount of liquidity added to the protocol (deposit or repay) in the previous action\n    * @param _liquidityTaken the amount of liquidity taken from the protocol (redeem or borrow)\n    /\n    function updateReserveInterestRatesAndTimestampInternal(\n        address _reserve,\n        uint256 _liquidityAdded,\n        uint256 _liquidityTaken\n    ) internal {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        (uint256 newLiquidityRate, uint256 newStableRate, uint256 newVariableRate) = IReserveInterestRateStrategy(\n            reserve\n            .interestRateStrategyAddress\n        )\n        .calculateInterestRates(\n            _reserve,\n            getReserveAvailableLiquidity(_reserve).add(_liquidityAdded).sub(_liquidityTaken),\n            reserve.totalBorrowsStable,\n            reserve.totalBorrowsVariable,\n            reserve.currentAverageStableBorrowRate\n        );\n        reserve.currentLiquidityRate = newLiquidityRate;\n        reserve.currentStableBorrowRate = newStableRate;\n        reserve.currentVariableBorrowRate = newVariableRate;\n        //solium-disable-next-line\n        reserve.lastUpdateTimestamp = uint40(block.timestamp);\n        emit ReserveUpdated(\n            _reserve,\n            newLiquidityRate,\n            newStableRate,\n            newVariableRate,\n            reserve.lastLiquidityCumulativeIndex,\n            reserve.lastVariableBorrowCumulativeIndex\n        );\n    }\n    /\n    * @dev transfers to the protocol fees of a flashloan to the fees collection address\n    * @param _token the address of the token being transferred\n    * @param _amount the amount being transferred\n    /\n    function transferFlashLoanProtocolFeeInternal(address _token, uint256 _amount) internal {\n        address payable receiver = address(uint160(addressesProvider.getTokenDistributor()));\n        if (_token != EthAddressLib.ethAddress()) {\n            ERC20(_token).safeTransfer(receiver, _amount);\n        } else {\n            receiver.transfer(_amount);\n        }\n    }\n    /\n    * @dev updates the internal configuration of the core\n    /\n    function refreshConfigInternal() internal {\n        lendingPoolAddress = addressesProvider.getLendingPool();\n    }\n    /\n    * @dev adds a reserve to the array of the reserves address\n    /\n    function addReserveToListInternal(address _reserve) internal {\n        bool reserveAlreadyAdded = false;\n        for (uint256 i = 0; i &lt; reservesList.length; i++)\n            if (reservesList[i] == _reserve) {\n                reserveAlreadyAdded = true;\n            }\n        if (!reserveAlreadyAdded) reservesList.push(_reserve);\n    }\n}\n.\n\nChief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.\nHere\'s a Solidity contract provided by the user: "pragma solidity ^0.5.0;\nimport "openzeppelin-solidity/contracts/math/SafeMath.sol";\nimport "openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol";\nimport "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol";\nimport "openzeppelin-solidity/contracts/utils/Address.sol";\nimport "../libraries/openzeppelin-upgradeability/VersionedInitializable.sol";\nimport "../libraries/CoreLibrary.sol";\nimport "../configuration/LendingPoolAddressesProvider.sol";\nimport "../interfaces/ILendingRateOracle.sol";\nimport "../interfaces/IReserveInterestRateStrategy.sol";\nimport "../libraries/WadRayMath.sol";\nimport "../tokenization/AToken.sol";\nimport "../libraries/EthAddressLib.sol";\n/\n @title LendingPoolCore contract\n @author Aave\n @notice Holds the state of the lending pool and all the funds deposited\n @dev NOTE: The core does not enforce security checks on the update of the state\n (eg, updateStateOnBorrow() does not enforce that borrowed is enabled on the reserve).\n The check that an action can be performed is a duty of the overlying LendingPool contract.\n/\ncontract LendingPoolCore is VersionedInitializable {\n    using SafeMath for uint256;\n    using WadRayMath for uint256;\n    using CoreLibrary for CoreLibrary.ReserveData;\n    using CoreLibrary for CoreLibrary.UserReserveData;\n    using SafeERC20 for ERC20;\n    using Address for address payable;\n    /\n    * @dev Emitted when the state of a reserve is updated\n    * @param reserve the address of the reserve\n    * @param liquidityRate the new liquidity rate\n    * @param stableBorrowRate the new stable borrow rate\n    * @param variableBorrowRate the new variable borrow rate\n    * @param liquidityIndex the new liquidity index\n    * @param variableBorrowIndex the new variable borrow index\n    /\n    event ReserveUpdated(\n        address indexed reserve,\n        uint256 liquidityRate,\n        uint256 stableBorrowRate,\n        uint256 variableBorrowRate,\n        uint256 liquidityIndex,\n        uint256 variableBorrowIndex\n    );\n    address public lendingPoolAddress;\n    LendingPoolAddressesProvider public addressesProvider;\n    /\n    * @dev only lending pools can use functions affected by this modifier\n    /\n    modifier onlyLendingPool {\n        require(lendingPoolAddress == msg.sender, "The caller must be a lending pool contract");\n        ;\n    }\n    /\n    * @dev only lending pools configurator can use functions affected by this modifier\n    /\n    modifier onlyLendingPoolConfigurator {\n        require(\n            addressesProvider.getLendingPoolConfigurator() == msg.sender,\n            "The caller must be a lending pool configurator contract"\n        );\n        _;\n    }\n    mapping(address =&gt; CoreLibrary.ReserveData) internal reserves;\n    mapping(address =&gt; mapping(address =&gt; CoreLibrary.UserReserveData)) internal usersReserveData;\n    address[] public reservesList;\n    uint256 public constant CORE_REVISION = 0x4;\n    /\n    * @dev returns the revision number of the contract\n    /\n    function getRevision() internal pure returns (uint256) {\n        return CORE_REVISION;\n    }\n    /\n    * @dev initializes the Core contract, invoked upon registration on the AddressesProvider\n    * @param _addressesProvider the addressesProvider contract\n    /\n    function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {\n        addressesProvider = _addressesProvider;\n        refreshConfigInternal();\n    }\n    /\n    * @dev updates the state of the core as a result of a deposit action\n    * @param _reserve the address of the reserve in which the deposit is happening\n    * @param _user the address of the the user depositing\n    * @param _amount the amount being deposited\n    * @param _isFirstDeposit true if the user is depositing for the first time\n    /\n    function updateStateOnDeposit(\n        address _reserve,\n        address _user,\n        uint256 _amount,\n        bool _isFirstDeposit\n    ) external onlyLendingPool {\n        reserves[_reserve].updateCumulativeIndexes();\n        updateReserveInterestRatesAndTimestampInternal(_reserve, _amount, 0);\n        if (_isFirstDeposit) {\n            //if this is the first deposit of the user, we configure the deposit as enabled to be used as collateral\n            setUserUseReserveAsCollateral(_reserve, _user, true);\n        }\n    }\n    /\n    * @dev updates the state of the core as a result of a redeem action\n    * @param _reserve the address of the reserve in which the redeem is happening\n    * @param _user the address of the the user redeeming\n    * @param _amountRedeemed the amount being redeemed\n    * @param _userRedeemedEverything true if the user is redeeming everything\n    /\n    function updateStateOnRedeem(\n        address _reserve,\n        address _user,\n        uint256 _amountRedeemed,\n        bool _userRedeemedEverything\n    ) external onlyLendingPool {\n        //compound liquidity and variable borrow interests\n        reserves[_reserve].updateCumulativeIndexes();\n        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountRedeemed);\n        //if user redeemed everything the useReserveAsCollateral flag is reset\n        if (_userRedeemedEverything) {\n            setUserUseReserveAsCollateral(_reserve, _user, false);\n        }\n    }\n    /\n    * @dev updates the state of the core as a result of a flashloan action\n    * @param _reserve the address of the reserve in which the flashloan is happening\n    * @param _income the income of the protocol as a result of the action\n    /\n    function updateStateOnFlashLoan(\n        address _reserve,\n        uint256 _availableLiquidityBefore,\n        uint256 _income,\n        uint256 _protocolFee\n    ) external onlyLendingPool {\n        transferFlashLoanProtocolFeeInternal(_reserve, _protocolFee);\n        //compounding the cumulated interest\n        reserves[_reserve].updateCumulativeIndexes();\n        uint256 totalLiquidityBefore = _availableLiquidityBefore.add(\n            getReserveTotalBorrows(_reserve)\n        );\n        //compounding the received fee into the reserve\n        reserves[_reserve].cumulateToLiquidityIndex(totalLiquidityBefore, _income);\n        //refresh interest rates\n        updateReserveInterestRatesAndTimestampInternal(_reserve, _income, 0);\n    }\n    /\n    * @dev updates the state of the core as a consequence of a borrow action.\n    * @param _reserve the address of the reserve on which the user is borrowing\n    * @param _user the address of the borrower\n    * @param _amountBorrowed the new amount borrowed\n    * @param _borrowFee the fee on the amount borrowed\n    * @param _rateMode the borrow rate mode (stable, variable)\n    * @return the new borrow rate for the user\n    /\n    function updateStateOnBorrow(\n        address _reserve,\n        address _user,\n        uint256 _amountBorrowed,\n        uint256 _borrowFee,\n        CoreLibrary.InterestRateMode _rateMode\n    ) external onlyLendingPool returns (uint256, uint256) {\n        // getting the previous borrow data of the user\n        (uint256 principalBorrowBalance, , uint256 balanceIncrease) = getUserBorrowBalances(\n            _reserve,\n            _user\n        );\n        updateReserveStateOnBorrowInternal(\n            _reserve,\n            _user,\n            principalBorrowBalance,\n            balanceIncrease,\n            _amountBorrowed,\n            _rateMode\n        );\n        updateUserStateOnBorrowInternal(\n            _reserve,\n            _user,\n            _amountBorrowed,\n            balanceIncrease,\n            _borrowFee,\n            _rateMode\n        );\n        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountBorrowed);\n        return (getUserCurrentBorrowRate(_reserve, _user), balanceIncrease);\n    }\n    /\n    * @dev updates the state of the core as a consequence of a repay action.\n    * @param _reserve the address of the reserve on which the user is repaying\n    * @param _user the address of the borrower\n    * @param _paybackAmountMinusFees the amount being paid back minus fees\n    * @param _originationFeeRepaid the fee on the amount that is being repaid\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    * @param _repaidWholeLoan true if the user is repaying the whole loan\n    /\n    function updateStateOnRepay(\n        address _reserve,\n        address _user,\n        uint256 _paybackAmountMinusFees,\n        uint256 _originationFeeRepaid,\n        uint256 _balanceIncrease,\n        bool _repaidWholeLoan\n    ) external onlyLendingPool {\n        updateReserveStateOnRepayInternal(\n            _reserve,\n            _user,\n            _paybackAmountMinusFees,\n            _balanceIncrease\n        );\n        updateUserStateOnRepayInternal(\n            _reserve,\n            _user,\n            _paybackAmountMinusFees,\n            _originationFeeRepaid,\n            _balanceIncrease,\n            _repaidWholeLoan\n        );\n        updateReserveInterestRatesAndTimestampInternal(_reserve, _paybackAmountMinusFees, 0);\n    }\n    /\n    * @dev updates the state of the core as a consequence of a swap rate action.\n    * @param _reserve the address of the reserve on which the user is repaying\n    * @param _user the address of the borrower\n    * @param _principalBorrowBalance the amount borrowed by the user\n    * @param _compoundedBorrowBalance the amount borrowed plus accrued interest\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    * @param _currentRateMode the current interest rate mode for the user\n    /\n    function updateStateOnSwapRate(\n        address _reserve,\n        address _user,\n        uint256 _principalBorrowBalance,\n        uint256 _compoundedBorrowBalance,\n        uint256 _balanceIncrease,\n        CoreLibrary.InterestRateMode _currentRateMode\n    ) external onlyLendingPool returns (CoreLibrary.InterestRateMode, uint256) {\n        updateReserveStateOnSwapRateInternal(\n            _reserve,\n            _user,\n            _principalBorrowBalance,\n            _compoundedBorrowBalance,\n            _currentRateMode\n        );\n        CoreLibrary.InterestRateMode newRateMode = updateUserStateOnSwapRateInternal(\n            _reserve,\n            _user,\n            _balanceIncrease,\n            _currentRateMode\n        );\n        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);\n        return (newRateMode, getUserCurrentBorrowRate(_reserve, _user));\n    }\n    /\n    * @dev updates the state of the core as a consequence of a liquidation action.\n    * @param _principalReserve the address of the principal reserve that is being repaid\n    * @param _collateralReserve the address of the collateral reserve that is being liquidated\n    * @param _user the address of the borrower\n    * @param _amountToLiquidate the amount being repaid by the liquidator\n    * @param _collateralToLiquidate the amount of collateral being liquidated\n    * @param _feeLiquidated the amount of origination fee being liquidated\n    * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise\n    /\n    function updateStateOnLiquidation(\n        address _principalReserve,\n        address _collateralReserve,\n        address _user,\n        uint256 _amountToLiquidate,\n        uint256 _collateralToLiquidate,\n        uint256 _feeLiquidated,\n        uint256 _liquidatedCollateralForFee,\n        uint256 _balanceIncrease,\n        bool _liquidatorReceivesAToken\n    ) external onlyLendingPool {\n        updatePrincipalReserveStateOnLiquidationInternal(\n            _principalReserve,\n            _user,\n            _amountToLiquidate,\n            _balanceIncrease\n        );\n        updateCollateralReserveStateOnLiquidationInternal(\n            _collateralReserve\n        );\n        updateUserStateOnLiquidationInternal(\n            _principalReserve,\n            _user,\n            _amountToLiquidate,\n            _feeLiquidated,\n            _balanceIncrease\n        );\n        updateReserveInterestRatesAndTimestampInternal(_principalReserve, _amountToLiquidate, 0);\n        if (!_liquidatorReceivesAToken) {\n            updateReserveInterestRatesAndTimestampInternal(\n                _collateralReserve,\n                0,\n                _collateralToLiquidate.add(_liquidatedCollateralForFee)\n            );\n        }\n    }\n    /\n    * @dev updates the state of the core as a consequence of a stable rate rebalance\n    * @param _reserve the address of the principal reserve where the user borrowed\n    * @param _user the address of the borrower\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    * @return the new stable rate for the user\n    /\n    function updateStateOnRebalance(address _reserve, address _user, uint256 _balanceIncrease)\n    external\n    onlyLendingPool\n    returns (uint256)\n    {\n        updateReserveStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);\n        //update user data and rebalance the rate\n        updateUserStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);\n        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);\n        return usersReserveData[_user][_reserve].stableBorrowRate;\n    }\n    /\n    * @dev enables or disables a reserve as collateral\n    * @param _reserve the address of the principal reserve where the user deposited\n    * @param _user the address of the depositor\n    * @param _useAsCollateral true if the depositor wants to use the reserve as collateral\n    /\n    function setUserUseReserveAsCollateral(address _reserve, address _user, bool _useAsCollateral)\n    public\n    onlyLendingPool\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        user.useAsCollateral = _useAsCollateral;\n    }\n    /\n    * @notice ETH/token transfer functions\n    /\n    /\n    * @dev fallback function enforces that the caller is a contract, to support flashloan transfers\n    /\n    function() external payable {\n        //only contracts can send ETH to the core\n        require(msg.sender.isContract(), "Only contracts can send ether to the Lending pool core");\n    }\n    /\n    * @dev transfers to the user a specific amount from the reserve.\n    * @param _reserve the address of the reserve where the transfer is happening\n    * @param _user the address of the user receiving the transfer\n    * @param _amount the amount being transferred\n    /\n    function transferToUser(address _reserve, address payable _user, uint256 _amount)\n    external\n    onlyLendingPool\n    {\n        if (_reserve != EthAddressLib.ethAddress()) {\n            ERC20(_reserve).safeTransfer(_user, _amount);\n        } else {\n            //solium-disable-next-line\n            (bool result, ) = _user.call.value(_amount).gas(50000)("");\n            require(result, "Transfer of ETH failed");\n        }\n    }\n    /\n    * @dev transfers the protocol fees to the fees collection address\n    * @param _token the address of the token being transferred\n    * @param _user the address of the user from where the transfer is happening\n    * @param _amount the amount being transferred\n    * @param _destination the fee receiver address\n    /\n    function transferToFeeCollectionAddress(\n        address _token,\n        address _user,\n        uint256 _amount,\n        address _destination\n    ) external payable onlyLendingPool {\n        address payable feeAddress = address(uint160(_destination)); //cast the address to payable\n        if (_token != EthAddressLib.ethAddress()) {\n            require(\n                msg.value == 0,\n                "User is sending ETH along with the ERC20 transfer. Check the value attribute of the transaction"\n            );\n            ERC20(_token).safeTransferFrom(_user, feeAddress, _amount);\n        } else {\n            require(msg.value &gt;= _amount, "The amount and the value sent to deposit do not match");\n            //solium-disable-next-line\n            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");\n            require(result, "Transfer of ETH failed");\n        }\n    }\n    /\n    * @dev transfers the fees to the fees collection address in the case of liquidation\n    * @param _token the address of the token being transferred\n    * @param _amount the amount being transferred\n    * @param _destination the fee receiver address\n    /\n    function liquidateFee(\n        address _token,\n        uint256 _amount,\n        address _destination\n    ) external payable onlyLendingPool {\n        address payable feeAddress = address(uint160(_destination)); //cast the address to payable\n        require(\n            msg.value == 0,\n            "Fee liquidation does not require any transfer of value"\n        );\n        if (_token != EthAddressLib.ethAddress()) {\n            ERC20(_token).safeTransfer(feeAddress, _amount);\n        } else {\n            //solium-disable-next-line\n            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");\n            require(result, "Transfer of ETH failed");\n        }\n    }\n    /\n    * @dev transfers an amount from a user to the destination reserve\n    * @param _reserve the address of the reserve where the amount is being transferred\n    * @param _user the address of the user from where the transfer is happening\n    * @param _amount the amount being transferred\n    /\n    function transferToReserve(address _reserve, address payable _user, uint256 _amount)\n    external\n    payable\n    onlyLendingPool\n    {\n        if (_reserve != EthAddressLib.ethAddress()) {\n            require(msg.value == 0, "User is sending ETH along with the ERC20 transfer.");\n            ERC20(_reserve).safeTransferFrom(_user, address(this), _amount);\n        } else {\n            require(msg.value &gt;= _amount, "The amount and the value sent to deposit do not match");\n            if (msg.value &gt; _amount) {\n                //send back excess ETH\n                uint256 excessAmount = msg.value.sub(_amount);\n                //solium-disable-next-line\n                (bool result, ) = _user.call.value(excessAmount).gas(50000)("");\n                require(result, "Transfer of ETH failed");\n            }\n        }\n    }\n    /\n    * @notice data access functions\n    /\n    /\n    * @dev returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral)\n    * needed to calculate the global account data in the LendingPoolDataProvider\n    * @param _reserve the address of the reserve\n    * @param _user the address of the user\n    * @return the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not\n    /\n    function getUserBasicReserveData(address _reserve, address _user)\n    external\n    view\n    returns (uint256, uint256, uint256, bool)\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        uint256 underlyingBalance = getUserUnderlyingAssetBalance(_reserve, _user);\n        if (user.principalBorrowBalance == 0) {\n            return (underlyingBalance, 0, 0, user.useAsCollateral);\n        }\n        return (\n        underlyingBalance,\n        user.getCompoundedBorrowBalance(reserve),\n        user.originationFee,\n        user.useAsCollateral\n        );\n    }\n    /\n    * @dev checks if a user is allowed to borrow at a stable rate\n    * @param _reserve the reserve address\n    * @param _user the user\n    * @param _amount the amount the the user wants to borrow\n    * @return true if the user is allowed to borrow at a stable rate, false otherwise\n    /\n    function isUserAllowedToBorrowAtStable(address _reserve, address _user, uint256 _amount)\n    external\n    view\n    returns (bool)\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        if (!reserve.isStableBorrowRateEnabled) return false;\n        return\n        !user.useAsCollateral ||\n        !reserve.usageAsCollateralEnabled ||\n        _amount &gt; getUserUnderlyingAssetBalance(_reserve, _user);\n    }\n    /\n    * @dev gets the underlying asset balance of a user based on the corresponding aToken balance.\n    * @param _reserve the reserve address\n    * @param _user the user address\n    * @return the underlying deposit balance of the user\n    /\n    function getUserUnderlyingAssetBalance(address _reserve, address _user)\n    public\n    view\n    returns (uint256)\n    {\n        AToken aToken = AToken(reserves[_reserve].aTokenAddress);\n        return aToken.balanceOf(_user);\n    }\n    /\n    * @dev gets the interest rate strategy contract address for the reserve\n    * @param _reserve the reserve address\n    * @return the address of the interest rate strategy contract\n    /\n    function getReserveInterestRateStrategyAddress(address _reserve) public view returns (address) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.interestRateStrategyAddress;\n    }\n    /\n    * @dev gets the aToken contract address for the reserve\n    * @param _reserve the reserve address\n    * @return the address of the aToken contract\n    /\n    function getReserveATokenAddress(address _reserve) public view returns (address) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.aTokenAddress;\n    }\n    /\n    * @dev gets the available liquidity in the reserve. The available liquidity is the balance of the core contract\n    * @param _reserve the reserve address\n    * @return the available liquidity\n    /\n    function getReserveAvailableLiquidity(address _reserve) public view returns (uint256) {\n        uint256 balance = 0;\n        if (_reserve == EthAddressLib.ethAddress()) {\n            balance = address(this).balance;\n        } else {\n            balance = IERC20(_reserve).balanceOf(address(this));\n        }\n        return balance;\n    }\n    /\n    * @dev gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows\n    * @param _reserve the reserve address\n    * @return the total liquidity\n    /\n    function getReserveTotalLiquidity(address _reserve) public view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return getReserveAvailableLiquidity(_reserve).add(reserve.getTotalBorrows());\n    }\n    /\n    * @dev gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there\n    * there has been 100% income.\n    * @param _reserve the reserve address\n    * @return the reserve normalized income\n    /\n    function getReserveNormalizedIncome(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.getNormalizedIncome();\n    }\n    /\n    * @dev gets the reserve total borrows\n    * @param _reserve the reserve address\n    * @return the total borrows (stable + variable)\n    /\n    function getReserveTotalBorrows(address _reserve) public view returns (uint256) {\n        return reserves[_reserve].getTotalBorrows();\n    }\n    /\n    * @dev gets the reserve total borrows stable\n    * @param _reserve the reserve address\n    * @return the total borrows stable\n    /\n    function getReserveTotalBorrowsStable(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.totalBorrowsStable;\n    }\n    /\n    * @dev gets the reserve total borrows variable\n    * @param _reserve the reserve address\n    * @return the total borrows variable\n    /\n    function getReserveTotalBorrowsVariable(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.totalBorrowsVariable;\n    }\n    /\n    * @dev gets the reserve liquidation threshold\n    * @param _reserve the reserve address\n    * @return the reserve liquidation threshold\n    /\n    function getReserveLiquidationThreshold(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.liquidationThreshold;\n    }\n    /\n    * @dev gets the reserve liquidation bonus\n    * @param _reserve the reserve address\n    * @return the reserve liquidation bonus\n    /\n    function getReserveLiquidationBonus(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.liquidationBonus;\n    }\n    /\n    * @dev gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty\n    * @param _reserve the reserve address\n    * @return the reserve current variable borrow rate\n    /\n    function getReserveCurrentVariableBorrowRate(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        if (reserve.currentVariableBorrowRate == 0) {\n            return\n            IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)\n            .getBaseVariableBorrowRate();\n        }\n        return reserve.currentVariableBorrowRate;\n    }\n    /\n    * @dev gets the reserve current stable borrow rate. Is the market rate if the reserve is empty\n    * @param _reserve the reserve address\n    * @return the reserve current stable borrow rate\n    /\n    function getReserveCurrentStableBorrowRate(address _reserve) public view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        ILendingRateOracle oracle = ILendingRateOracle(addressesProvider.getLendingRateOracle());\n        if (reserve.currentStableBorrowRate == 0) {\n            //no stable rate borrows yet\n            return oracle.getMarketBorrowRate(_reserve);\n        }\n        return reserve.currentStableBorrowRate;\n    }\n    /\n    * @dev gets the reserve average stable borrow rate. The average stable rate is the weighted average\n    * of all the loans taken at stable rate.\n    * @param _reserve the reserve address\n    * @return the reserve current average borrow rate\n    /\n    function getReserveCurrentAverageStableBorrowRate(address _reserve)\n    external\n    view\n    returns (uint256)\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.currentAverageStableBorrowRate;\n    }\n    /\n    * @dev gets the reserve liquidity rate\n    * @param _reserve the reserve address\n    * @return the reserve liquidity rate\n    /\n    function getReserveCurrentLiquidityRate(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.currentLiquidityRate;\n    }\n    /\n    * @dev gets the reserve liquidity cumulative index\n    * @param _reserve the reserve address\n    * @return the reserve liquidity cumulative index\n    /\n    function getReserveLiquidityCumulativeIndex(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.lastLiquidityCumulativeIndex;\n    }\n    /\n    * @dev gets the reserve variable borrow index\n    * @param _reserve the reserve address\n    * @return the reserve variable borrow index\n    /\n    function getReserveVariableBorrowsCumulativeIndex(address _reserve)\n    external\n    view\n    returns (uint256)\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.lastVariableBorrowCumulativeIndex;\n    }\n    /\n    * @dev this function aggregates the configuration parameters of the reserve.\n    * It\'s used in the LendingPoolDataProvider specifically to save gas, and avoid\n    * multiple external contract calls to fetch the same data.\n    * @param _reserve the reserve address\n    * @return the reserve decimals\n    * @return the base ltv as collateral\n    * @return the liquidation threshold\n    * @return if the reserve is used as collateral or not\n    /\n    function getReserveConfiguration(address _reserve)\n    external\n    view\n    returns (uint256, uint256, uint256, bool)\n    {\n        uint256 decimals;\n        uint256 baseLTVasCollateral;\n        uint256 liquidationThreshold;\n        bool usageAsCollateralEnabled;\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        decimals = reserve.decimals;\n        baseLTVasCollateral = reserve.baseLTVasCollateral;\n        liquidationThreshold = reserve.liquidationThreshold;\n        usageAsCollateralEnabled = reserve.usageAsCollateralEnabled;\n        return (decimals, baseLTVasCollateral, liquidationThreshold, usageAsCollateralEnabled);\n    }\n    /\n    * @dev returns the decimals of the reserve\n    * @param _reserve the reserve address\n    * @return the reserve decimals\n    /\n    function getReserveDecimals(address _reserve) external view returns (uint256) {\n        return reserves[_reserve].decimals;\n    }\n    /\n    * @dev returns true if the reserve is enabled for borrowing\n    * @param _reserve the reserve address\n    * @return true if the reserve is enabled for borrowing, false otherwise\n    /\n    function isReserveBorrowingEnabled(address _reserve) external view returns (bool) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.borrowingEnabled;\n    }\n    /\n    * @dev returns true if the reserve is enabled as collateral\n    * @param _reserve the reserve address\n    * @return true if the reserve is enabled as collateral, false otherwise\n    /\n    function isReserveUsageAsCollateralEnabled(address _reserve) external view returns (bool) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.usageAsCollateralEnabled;\n    }\n    /\n    * @dev returns true if the stable rate is enabled on reserve\n    * @param _reserve the reserve address\n    * @return true if the stable rate is enabled on reserve, false otherwise\n    /\n    function getReserveIsStableBorrowRateEnabled(address _reserve) external view returns (bool) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.isStableBorrowRateEnabled;\n    }\n    /\n    * @dev returns true if the reserve is active\n    * @param _reserve the reserve address\n    * @return true if the reserve is active, false otherwise\n    /\n    function getReserveIsActive(address _reserve) external view returns (bool) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.isActive;\n    }\n    /\n    * @notice returns if a reserve is freezed\n    * @param _reserve the reserve for which the information is needed\n    * @return true if the reserve is freezed, false otherwise\n    /\n    function getReserveIsFreezed(address _reserve) external view returns (bool) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.isFreezed;\n    }\n    /\n    * @notice returns the timestamp of the last action on the reserve\n    * @param _reserve the reserve for which the information is needed\n    * @return the last updated timestamp of the reserve\n    /\n    function getReserveLastUpdate(address _reserve) external view returns (uint40 timestamp) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        timestamp = reserve.lastUpdateTimestamp;\n    }\n    /\n    * @dev returns the utilization rate U of a specific reserve\n    * @param _reserve the reserve for which the information is needed\n    * @return the utilization rate in ray\n    /\n    function getReserveUtilizationRate(address _reserve) public view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        uint256 totalBorrows = reserve.getTotalBorrows();\n        if (totalBorrows == 0) {\n            return 0;\n        }\n        uint256 availableLiquidity = getReserveAvailableLiquidity(_reserve);\n        return totalBorrows.rayDiv(availableLiquidity.add(totalBorrows));\n    }\n    /\n    * @return the array of reserves configured on the core\n    /\n    function getReserves() external view returns (address[] memory) {\n        return reservesList;\n    }\n    /\n    * @param _reserve the address of the reserve for which the information is needed\n    * @param _user the address of the user for which the information is needed\n    * @return true if the user has chosen to use the reserve as collateral, false otherwise\n    /\n    function isUserUseReserveAsCollateralEnabled(address _reserve, address _user)\n    external\n    view\n    returns (bool)\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        return user.useAsCollateral;\n    }\n    /\n    * @param _reserve the address of the reserve for which the information is needed\n    * @param _user the address of the user for which the information is needed\n    * @return the origination fee for the user\n    /\n    function getUserOriginationFee(address _reserve, address _user)\n    external\n    view\n    returns (uint256)\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        return user.originationFee;\n    }\n    /\n    * @dev users with no loans in progress have NONE as borrow rate mode\n    * @param _reserve the address of the reserve for which the information is needed\n    * @param _user the address of the user for which the information is needed\n    * @return the borrow rate mode for the user,\n    /\n    function getUserCurrentBorrowRateMode(address _reserve, address _user)\n    public\n    view\n    returns (CoreLibrary.InterestRateMode)\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        if (user.principalBorrowBalance == 0) {\n            return CoreLibrary.InterestRateMode.NONE;\n        }\n        return\n        user.stableBorrowRate &gt; 0\n        ? CoreLibrary.InterestRateMode.STABLE\n        : CoreLibrary.InterestRateMode.VARIABLE;\n    }\n    /\n    * @dev gets the current borrow rate of the user\n    * @param _reserve the address of the reserve for which the information is needed\n    * @param _user the address of the user for which the information is needed\n    * @return the borrow rate for the user,\n    /\n    function getUserCurrentBorrowRate(address _reserve, address _user)\n    internal\n    view\n    returns (uint256)\n    {\n        CoreLibrary.InterestRateMode rateMode = getUserCurrentBorrowRateMode(_reserve, _user);\n        if (rateMode == CoreLibrary.InterestRateMode.NONE) {\n            return 0;\n        }\n        return\n        rateMode == CoreLibrary.InterestRateMode.STABLE\n        ? usersReserveData[_user][_reserve].stableBorrowRate\n        : reserves[_reserve].currentVariableBorrowRate;\n    }\n    /\n    * @dev the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all\n    * @param _reserve the address of the reserve for which the information is needed\n    * @param _user the address of the user for which the information is needed\n    * @return the user stable rate\n    /\n    function getUserCurrentStableBorrowRate(address _reserve, address _user)\n    external\n    view\n    returns (uint256)\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        return user.stableBorrowRate;\n    }\n    /\n    * @dev calculates and returns the borrow balances of the user\n    * @param _reserve the address of the reserve\n    * @param _user the address of the user\n    * @return the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance\n    /\n    function getUserBorrowBalances(address _reserve, address _user)\n    public\n    view\n    returns (uint256, uint256, uint256)\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        if (user.principalBorrowBalance == 0) {\n            return (0, 0, 0);\n        }\n        uint256 principal = user.principalBorrowBalance;\n        uint256 compoundedBalance = CoreLibrary.getCompoundedBorrowBalance(\n            user,\n            reserves[_reserve]\n        );\n        return (principal, compoundedBalance, compoundedBalance.sub(principal));\n    }\n    /\n    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable\n    * @param _reserve the address of the reserve for which the information is needed\n    * @param _user the address of the user for which the information is needed\n    * @return the variable borrow index for the user\n    /\n    function getUserVariableBorrowCumulativeIndex(address _reserve, address _user)\n    external\n    view\n    returns (uint256)\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        return user.lastVariableBorrowCumulativeIndex;\n    }\n    /\n    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable\n    * @param _reserve the address of the reserve for which the information is needed\n    * @param _user the address of the user for which the information is needed\n    * @return the variable borrow index for the user\n    /\n    function getUserLastUpdate(address _reserve, address _user)\n    external\n    view\n    returns (uint256 timestamp)\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        timestamp = user.lastUpdateTimestamp;\n    }\n    /\n    * @dev updates the lending pool core configuration\n    /\n    function refreshConfiguration() external onlyLendingPoolConfigurator {\n        refreshConfigInternal();\n    }\n    /\n    * @dev initializes a reserve\n    * @param _reserve the address of the reserve\n    * @param _aTokenAddress the address of the overlying aToken contract\n    * @param _decimals the decimals of the reserve currency\n    * @param _interestRateStrategyAddress the address of the interest rate strategy contract\n    /\n    function initReserve(\n        address _reserve,\n        address _aTokenAddress,\n        uint256 _decimals,\n        address _interestRateStrategyAddress\n    ) external onlyLendingPoolConfigurator {\n        reserves[_reserve].init(_aTokenAddress, _decimals, _interestRateStrategyAddress);\n        addReserveToListInternal(_reserve);\n    }\n\n    /\n    * @dev removes the last added reserve in the reservesList array\n    * @param _reserveToRemove the address of the reserve\n    /\n    function removeLastAddedReserve(address _reserveToRemove)\n    external onlyLendingPoolConfigurator {\n        address lastReserve = reservesList[reservesList.length-1];\n        require(lastReserve == _reserveToRemove, "Reserve being removed is different than the reserve requested");\n        //as we can\'t check if totalLiquidity is 0 (since the reserve added might not be an ERC20) we at least check that there is nothing borrowed\n        require(getReserveTotalBorrows(lastReserve) == 0, "Cannot remove a reserve with liquidity deposited");\n        reserves[lastReserve].isActive = false;\n        reserves[lastReserve].aTokenAddress = address(0);\n        reserves[lastReserve].decimals = 0;\n        reserves[lastReserve].lastLiquidityCumulativeIndex = 0;\n        reserves[lastReserve].lastVariableBorrowCumulativeIndex = 0;\n        reserves[lastReserve].borrowingEnabled = false;\n        reserves[lastReserve].usageAsCollateralEnabled = false;\n        reserves[lastReserve].baseLTVasCollateral = 0;\n        reserves[lastReserve].liquidationThreshold = 0;\n        reserves[lastReserve].liquidationBonus = 0;\n        reserves[lastReserve].interestRateStrategyAddress = address(0);\n        reservesList.pop();\n    }\n    /\n    * @dev updates the address of the interest rate strategy contract\n    * @param _reserve the address of the reserve\n    * @param _rateStrategyAddress the address of the interest rate strategy contract\n    /\n    function setReserveInterestRateStrategyAddress(address _reserve, address _rateStrategyAddress)\n    external\n    onlyLendingPoolConfigurator\n    {\n        reserves[_reserve].interestRateStrategyAddress = _rateStrategyAddress;\n    }\n    /\n    * @dev enables borrowing on a reserve. Also sets the stable rate borrowing\n    * @param _reserve the address of the reserve\n    * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise\n    /\n    function enableBorrowingOnReserve(address _reserve, bool _stableBorrowRateEnabled)\n    external\n    onlyLendingPoolConfigurator\n    {\n        reserves[_reserve].enableBorrowing(_stableBorrowRateEnabled);\n    }\n    /\n    * @dev disables borrowing on a reserve\n    * @param _reserve the address of the reserve\n    /\n    function disableBorrowingOnReserve(address _reserve) external onlyLendingPoolConfigurator {\n        reserves[_reserve].disableBorrowing();\n    }\n    /\n    * @dev enables a reserve to be used as collateral\n    * @param _reserve the address of the reserve\n    /\n    function enableReserveAsCollateral(\n        address _reserve,\n        uint256 _baseLTVasCollateral,\n        uint256 _liquidationThreshold,\n        uint256 _liquidationBonus\n    ) external onlyLendingPoolConfigurator {\n        reserves[_reserve].enableAsCollateral(\n            _baseLTVasCollateral,\n            _liquidationThreshold,\n            _liquidationBonus\n        );\n    }\n    /\n    * @dev disables a reserve to be used as collateral\n    * @param _reserve the address of the reserve\n    /\n    function disableReserveAsCollateral(address _reserve) external onlyLendingPoolConfigurator {\n        reserves[_reserve].disableAsCollateral();\n    }\n    /\n    * @dev enable the stable borrow rate mode on a reserve\n    * @param _reserve the address of the reserve\n    /\n    function enableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.isStableBorrowRateEnabled = true;\n    }\n    /\n    * @dev disable the stable borrow rate mode on a reserve\n    * @param _reserve the address of the reserve\n    /\n    function disableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.isStableBorrowRateEnabled = false;\n    }\n    /\n    * @dev activates a reserve\n    * @param _reserve the address of the reserve\n    /\n    function activateReserve(address _reserve) external onlyLendingPoolConfigurator {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        require(\n            reserve.lastLiquidityCumulativeIndex &gt; 0 &amp;&amp;\n            reserve.lastVariableBorrowCumulativeIndex &gt; 0,\n            "Reserve has not been initialized yet"\n        );\n        reserve.isActive = true;\n    }\n    /\n    * @dev deactivates a reserve\n    * @param _reserve the address of the reserve\n    /\n    function deactivateReserve(address _reserve) external onlyLendingPoolConfigurator {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.isActive = false;\n    }\n    /\n    * @notice allows the configurator to freeze the reserve.\n    * A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance.\n    * @param _reserve the address of the reserve\n    /\n    function freezeReserve(address _reserve) external onlyLendingPoolConfigurator {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.isFreezed = true;\n    }\n    /\n    * @notice allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed.\n    * @param _reserve the address of the reserve\n    /\n    function unfreezeReserve(address _reserve) external onlyLendingPoolConfigurator {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.isFreezed = false;\n    }\n    /\n    * @notice allows the configurator to update the loan to value of a reserve\n    * @param _reserve the address of the reserve\n    * @param _ltv the new loan to value\n    /\n    function setReserveBaseLTVasCollateral(address _reserve, uint256 _ltv)\n    external\n    onlyLendingPoolConfigurator\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.baseLTVasCollateral = _ltv;\n    }\n    /\n    * @notice allows the configurator to update the liquidation threshold of a reserve\n    * @param _reserve the address of the reserve\n    * @param _threshold the new liquidation threshold\n    /\n    function setReserveLiquidationThreshold(address _reserve, uint256 _threshold)\n    external\n    onlyLendingPoolConfigurator\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.liquidationThreshold = _threshold;\n    }\n    /\n    * @notice allows the configurator to update the liquidation bonus of a reserve\n    * @param _reserve the address of the reserve\n    * @param _bonus the new liquidation bonus\n    /\n    function setReserveLiquidationBonus(address _reserve, uint256 _bonus)\n    external\n    onlyLendingPoolConfigurator\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.liquidationBonus = _bonus;\n    }\n    /\n    * @notice allows the configurator to update the reserve decimals\n    * @param _reserve the address of the reserve\n    * @param _decimals the decimals of the reserve\n    /\n    function setReserveDecimals(address _reserve, uint256 _decimals)\n    external\n    onlyLendingPoolConfigurator\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.decimals = _decimals;\n    }\n    /\n    * @notice internal functions\n    /\n    /\n    * @dev updates the state of a reserve as a consequence of a borrow action.\n    * @param _reserve the address of the reserve on which the user is borrowing\n    * @param _user the address of the borrower\n    * @param _principalBorrowBalance the previous borrow balance of the borrower before the action\n    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount\n    * @param _amountBorrowed the new amount borrowed\n    * @param _rateMode the borrow rate mode (stable, variable)\n    /\n    function updateReserveStateOnBorrowInternal(\n        address _reserve,\n        address _user,\n        uint256 _principalBorrowBalance,\n        uint256 _balanceIncrease,\n        uint256 _amountBorrowed,\n        CoreLibrary.InterestRateMode _rateMode\n    ) internal {\n        reserves[_reserve].updateCumulativeIndexes();\n        //increasing reserve total borrows to account for the new borrow balance of the user\n        //NOTE: Depending on the previous borrow mode, the borrows might need to be switched from variable to stable or vice versa\n        updateReserveTotalBorrowsByRateModeInternal(\n            _reserve,\n            _user,\n            _principalBorrowBalance,\n            _balanceIncrease,\n            _amountBorrowed,\n            _rateMode\n        );\n    }\n    /\n    * @dev updates the state of a user as a consequence of a borrow action.\n    * @param _reserve the address of the reserve on which the user is borrowing\n    * @param _user the address of the borrower\n    * @param _amountBorrowed the amount borrowed\n    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount\n    * @param _rateMode the borrow rate mode (stable, variable)\n    * @return the final borrow rate for the user. Emitted by the borrow() event\n    /\n    function updateUserStateOnBorrowInternal(\n        address _reserve,\n        address _user,\n        uint256 _amountBorrowed,\n        uint256 _balanceIncrease,\n        uint256 _fee,\n        CoreLibrary.InterestRateMode _rateMode\n    ) internal {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        if (_rateMode == CoreLibrary.InterestRateMode.STABLE) {\n            //stable\n            //reset the user variable index, and update the stable rate\n            user.stableBorrowRate = reserve.currentStableBorrowRate;\n            user.lastVariableBorrowCumulativeIndex = 0;\n        } else if (_rateMode == CoreLibrary.InterestRateMode.VARIABLE) {\n            //variable\n            //reset the user stable rate, and store the new borrow index\n            user.stableBorrowRate = 0;\n            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;\n        } else {\n            revert("Invalid borrow rate mode");\n        }\n        //increase the principal borrows and the origination fee\n        user.principalBorrowBalance = user.principalBorrowBalance.add(_amountBorrowed).add(\n            _balanceIncrease\n        );\n        user.originationFee = user.originationFee.add(_fee);\n        //solium-disable-next-line\n        user.lastUpdateTimestamp = uint40(block.timestamp);\n    }\n    /\n    * @dev updates the state of the reserve as a consequence of a repay action.\n    * @param _reserve the address of the reserve on which the user is repaying\n    * @param _user the address of the borrower\n    * @param _paybackAmountMinusFees the amount being paid back minus fees\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    /\n    function updateReserveStateOnRepayInternal(\n        address _reserve,\n        address _user,\n        uint256 _paybackAmountMinusFees,\n        uint256 _balanceIncrease\n    ) internal {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_reserve][_user];\n        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(_reserve, _user);\n        //update the indexes\n        reserves[_reserve].updateCumulativeIndexes();\n        //compound the cumulated interest to the borrow balance and then subtracting the payback amount\n        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {\n            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(\n                _balanceIncrease,\n                user.stableBorrowRate\n            );\n            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(\n                _paybackAmountMinusFees,\n                user.stableBorrowRate\n            );\n        } else {\n            reserve.increaseTotalBorrowsVariable(_balanceIncrease);\n            reserve.decreaseTotalBorrowsVariable(_paybackAmountMinusFees);\n        }\n    }\n    /\n    * @dev updates the state of the user as a consequence of a repay action.\n    * @param _reserve the address of the reserve on which the user is repaying\n    * @param _user the address of the borrower\n    * @param _paybackAmountMinusFees the amount being paid back minus fees\n    * @param _originationFeeRepaid the fee on the amount that is being repaid\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    * @param _repaidWholeLoan true if the user is repaying the whole loan\n    /\n    function updateUserStateOnRepayInternal(\n        address _reserve,\n        address _user,\n        uint256 _paybackAmountMinusFees,\n        uint256 _originationFeeRepaid,\n        uint256 _balanceIncrease,\n        bool _repaidWholeLoan\n    ) internal {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        //update the user principal borrow balance, adding the cumulated interest and then subtracting the payback amount\n        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(\n            _paybackAmountMinusFees\n        );\n        user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;\n        //if the balance decrease is equal to the previous principal (user is repaying the whole loan)\n        //and the rate mode is stable, we reset the interest rate mode of the user\n        if (_repaidWholeLoan) {\n            user.stableBorrowRate = 0;\n            user.lastVariableBorrowCumulativeIndex = 0;\n        }\n        user.originationFee = user.originationFee.sub(_originationFeeRepaid);\n        //solium-disable-next-line\n        user.lastUpdateTimestamp = uint40(block.timestamp);\n    }\n    /\n    * @dev updates the state of the user as a consequence of a swap rate action.\n    * @param _reserve the address of the reserve on which the user is performing the rate swap\n    * @param _user the address of the borrower\n    * @param _principalBorrowBalance the the principal amount borrowed by the user\n    * @param _compoundedBorrowBalance the principal amount plus the accrued interest\n    * @param _currentRateMode the rate mode at which the user borrowed\n    /\n    function updateReserveStateOnSwapRateInternal(\n        address _reserve,\n        address _user,\n        uint256 _principalBorrowBalance,\n        uint256 _compoundedBorrowBalance,\n        CoreLibrary.InterestRateMode _currentRateMode\n    ) internal {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        //compounding reserve indexes\n        reserve.updateCumulativeIndexes();\n        if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {\n            uint256 userCurrentStableRate = user.stableBorrowRate;\n            //swap to variable\n            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(\n                _principalBorrowBalance,\n                userCurrentStableRate\n            ); //decreasing stable from old principal balance\n            reserve.increaseTotalBorrowsVariable(_compoundedBorrowBalance); //increase variable borrows\n        } else if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {\n            //swap to stable\n            uint256 currentStableRate = reserve.currentStableBorrowRate;\n            reserve.decreaseTotalBorrowsVariable(_principalBorrowBalance);\n            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(\n                _compoundedBorrowBalance,\n                currentStableRate\n            );\n        } else {\n            revert("Invalid rate mode received");\n        }\n    }\n    /\n    * @dev updates the state of the user as a consequence of a swap rate action.\n    * @param _reserve the address of the reserve on which the user is performing the swap\n    * @param _user the address of the borrower\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    * @param _currentRateMode the current rate mode of the user\n    /\n    function updateUserStateOnSwapRateInternal(\n        address _reserve,\n        address _user,\n        uint256 _balanceIncrease,\n        CoreLibrary.InterestRateMode _currentRateMode\n    ) internal returns (CoreLibrary.InterestRateMode) {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        CoreLibrary.InterestRateMode newMode = CoreLibrary.InterestRateMode.NONE;\n        if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {\n            //switch to stable\n            newMode = CoreLibrary.InterestRateMode.STABLE;\n            user.stableBorrowRate = reserve.currentStableBorrowRate;\n            user.lastVariableBorrowCumulativeIndex = 0;\n        } else if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {\n            newMode = CoreLibrary.InterestRateMode.VARIABLE;\n            user.stableBorrowRate = 0;\n            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;\n        } else {\n            revert("Invalid interest rate mode received");\n        }\n        //compounding cumulated interest\n        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);\n        //solium-disable-next-line\n        user.lastUpdateTimestamp = uint40(block.timestamp);\n        return newMode;\n    }\n    /\n    * @dev updates the state of the principal reserve as a consequence of a liquidation action.\n    * @param _principalReserve the address of the principal reserve that is being repaid\n    * @param _user the address of the borrower\n    * @param _amountToLiquidate the amount being repaid by the liquidator\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    /\n    function updatePrincipalReserveStateOnLiquidationInternal(\n        address _principalReserve,\n        address _user,\n        uint256 _amountToLiquidate,\n        uint256 _balanceIncrease\n    ) internal {\n        CoreLibrary.ReserveData storage reserve = reserves[_principalReserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_principalReserve];\n        //update principal reserve data\n        reserve.updateCumulativeIndexes();\n        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(\n            _principalReserve,\n            _user\n        );\n        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {\n            //increase the total borrows by the compounded interest\n            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(\n                _balanceIncrease,\n                user.stableBorrowRate\n            );\n            //decrease by the actual amount to liquidate\n            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(\n                _amountToLiquidate,\n                user.stableBorrowRate\n            );\n        } else {\n            //increase the total borrows by the compounded interest\n            reserve.increaseTotalBorrowsVariable(_balanceIncrease);\n            //decrease by the actual amount to liquidate\n            reserve.decreaseTotalBorrowsVariable(_amountToLiquidate);\n        }\n    }\n    /\n    * @dev updates the state of the collateral reserve as a consequence of a liquidation action.\n    * @param _collateralReserve the address of the collateral reserve that is being liquidated\n    /\n    function updateCollateralReserveStateOnLiquidationInternal(\n        address _collateralReserve\n    ) internal {\n        //update collateral reserve\n        reserves[_collateralReserve].updateCumulativeIndexes();\n    }\n    /\n    * @dev updates the state of the user being liquidated as a consequence of a liquidation action.\n    * @param _reserve the address of the principal reserve that is being repaid\n    * @param _user the address of the borrower\n    * @param _amountToLiquidate the amount being repaid by the liquidator\n    * @param _feeLiquidated the amount of origination fee being liquidated\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    /\n    function updateUserStateOnLiquidationInternal(\n        address _reserve,\n        address _user,\n        uint256 _amountToLiquidate,\n        uint256 _feeLiquidated,\n        uint256 _balanceIncrease\n    ) internal {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        //first increase by the compounded interest, then decrease by the liquidated amount\n        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(\n            _amountToLiquidate\n        );\n        if (\n            getUserCurrentBorrowRateMode(_reserve, _user) == CoreLibrary.InterestRateMode.VARIABLE\n        ) {\n            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;\n        }\n        if(_feeLiquidated &gt; 0){\n            user.originationFee = user.originationFee.sub(_feeLiquidated);\n        }\n        //solium-disable-next-line\n        user.lastUpdateTimestamp = uint40(block.timestamp);\n    }\n    /\n    * @dev updates the state of the reserve as a consequence of a stable rate rebalance\n    * @param _reserve the address of the principal reserve where the user borrowed\n    * @param _user the address of the borrower\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    /\n    function updateReserveStateOnRebalanceInternal(\n        address _reserve,\n        address _user,\n        uint256 _balanceIncrease\n    ) internal {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        reserve.updateCumulativeIndexes();\n        reserve.increaseTotalBorrowsStableAndUpdateAverageRate(\n            _balanceIncrease,\n            user.stableBorrowRate\n        );\n    }\n    /\n    * @dev updates the state of the user as a consequence of a stable rate rebalance\n    * @param _reserve the address of the principal reserve where the user borrowed\n    * @param _user the address of the borrower\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    /\n    function updateUserStateOnRebalanceInternal(\n        address _reserve,\n        address _user,\n        uint256 _balanceIncrease\n    ) internal {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);\n        user.stableBorrowRate = reserve.currentStableBorrowRate;\n        //solium-disable-next-line\n        user.lastUpdateTimestamp = uint40(block.timestamp);\n    }\n    /\n    * @dev updates the state of the user as a consequence of a stable rate rebalance\n    * @param _reserve the address of the principal reserve where the user borrowed\n    * @param _user the address of the borrower\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    * @param _amountBorrowed the accrued interest on the borrowed amount\n    /\n    function updateReserveTotalBorrowsByRateModeInternal(\n        address _reserve,\n        address _user,\n        uint256 _principalBalance,\n        uint256 _balanceIncrease,\n        uint256 _amountBorrowed,\n        CoreLibrary.InterestRateMode _newBorrowRateMode\n    ) internal {\n        CoreLibrary.InterestRateMode previousRateMode = getUserCurrentBorrowRateMode(\n            _reserve,\n            _user\n        );\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        if (previousRateMode == CoreLibrary.InterestRateMode.STABLE) {\n            CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(\n                _principalBalance,\n                user.stableBorrowRate\n            );\n        } else if (previousRateMode == CoreLibrary.InterestRateMode.VARIABLE) {\n            reserve.decreaseTotalBorrowsVariable(_principalBalance);\n        }\n        uint256 newPrincipalAmount = _principalBalance.add(_balanceIncrease).add(_amountBorrowed);\n        if (_newBorrowRateMode == CoreLibrary.InterestRateMode.STABLE) {\n            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(\n                newPrincipalAmount,\n                reserve.currentStableBorrowRate\n            );\n        } else if (_newBorrowRateMode == CoreLibrary.InterestRateMode.VARIABLE) {\n            reserve.increaseTotalBorrowsVariable(newPrincipalAmount);\n        } else {\n            revert("Invalid new borrow rate mode");\n        }\n    }\n    /\n    * @dev Updates the reserve current stable borrow rate Rf, the current variable borrow rate Rv and the current liquidity rate Rl.\n    * Also updates the lastUpdateTimestamp value. Please refer to the whitepaper for further information.\n    * @param _reserve the address of the reserve to be updated\n    * @param _liquidityAdded the amount of liquidity added to the protocol (deposit or repay) in the previous action\n    * @param _liquidityTaken the amount of liquidity taken from the protocol (redeem or borrow)\n    /\n    function updateReserveInterestRatesAndTimestampInternal(\n        address _reserve,\n        uint256 _liquidityAdded,\n        uint256 _liquidityTaken\n    ) internal {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        (uint256 newLiquidityRate, uint256 newStableRate, uint256 newVariableRate) = IReserveInterestRateStrategy(\n            reserve\n            .interestRateStrategyAddress\n        )\n        .calculateInterestRates(\n            _reserve,\n            getReserveAvailableLiquidity(_reserve).add(_liquidityAdded).sub(_liquidityTaken),\n            reserve.totalBorrowsStable,\n            reserve.totalBorrowsVariable,\n            reserve.currentAverageStableBorrowRate\n        );\n        reserve.currentLiquidityRate = newLiquidityRate;\n        reserve.currentStableBorrowRate = newStableRate;\n        reserve.currentVariableBorrowRate = newVariableRate;\n        //solium-disable-next-line\n        reserve.lastUpdateTimestamp = uint40(block.timestamp);\n        emit ReserveUpdated(\n            _reserve,\n            newLiquidityRate,\n            newStableRate,\n            newVariableRate,\n            reserve.lastLiquidityCumulativeIndex,\n            reserve.lastVariableBorrowCumulativeIndex\n        );\n    }\n    /\n    * @dev transfers to the protocol fees of a flashloan to the fees collection address\n    * @param _token the address of the token being transferred\n    * @param _amount the amount being transferred\n    /\n    function transferFlashLoanProtocolFeeInternal(address _token, uint256 _amount) internal {\n        address payable receiver = address(uint160(addressesProvider.getTokenDistributor()));\n        if (_token != EthAddressLib.ethAddress()) {\n            ERC20(_token).safeTransfer(receiver, _amount);\n        } else {\n            receiver.transfer(_amount);\n        }\n    }\n    /\n    * @dev updates the internal configuration of the core\n    /\n    function refreshConfigInternal() internal {\n        lendingPoolAddress = addressesProvider.getLendingPool();\n    }\n    /\n    * @dev adds a reserve to the array of the reserves address\n    /\n    function addReserveToListInternal(address _reserve) internal {\n        bool reserveAlreadyAdded = false;\n        for (uint256 i = 0; i &lt; reservesList.length; i++)\n            if (reservesList[i] == _reserve) {\n                reserveAlreadyAdded = true;\n            }\n        if (!reserveAlreadyAdded) reservesList.push(_reserve);\n    }\n}\n".\nAs the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.\nNote that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we\'ve collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions".\n\nSecurity Analyst: Let\'s', 'question': 'Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" '} |
| **need_reflect** | False |
| **memory** | No existed memory |
| **chat_turn_limit** | 1 |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 04:31:20 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **task_prompt** | pragma solidity ^0.5.0; import "openzeppelin-solidity/contracts/math/SafeMath.sol"; import "openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol"; import "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol"; import "openzeppelin-solidity/contracts/utils/Address.sol"; import "../libraries/openzeppelin-upgradeability/VersionedInitializable.sol"; import "../libraries/CoreLibrary.sol"; import "../configuration/LendingPoolAddressesProvider.sol"; import "../interfaces/ILendingRateOracle.sol"; import "../interfaces/IReserveInterestRateStrategy.sol"; import "../libraries/WadRayMath.sol"; import "../tokenization/AToken.sol"; import "../libraries/EthAddressLib.sol"; / * @title LendingPoolCore contract * @author Aave * @notice Holds the state of the lending pool and all the funds deposited * @dev NOTE: The core does not enforce security checks on the update of the state * (eg, updateStateOnBorrow() does not enforce that borrowed is enabled on the reserve). * The check that an action can be performed is a duty of the overlying LendingPool contract. / contract LendingPoolCore is VersionedInitializable {     using SafeMath for uint256;     using WadRayMath for uint256;     using CoreLibrary for CoreLibrary.ReserveData;     using CoreLibrary for CoreLibrary.UserReserveData;     using SafeERC20 for ERC20;     using Address for address payable; /** * @dev Emitted when the state of a reserve is updated * @param reserve the address of the reserve * @param liquidityRate the new liquidity rate * @param stableBorrowRate the new stable borrow rate * @param variableBorrowRate the new variable borrow rate * @param liquidityIndex the new liquidity index * @param variableBorrowIndex the new variable borrow index **/ event ReserveUpdated(     address indexed reserve,     uint256 liquidityRate,     uint256 stableBorrowRate,     uint256 variableBorrowRate,     uint256 liquidityIndex,     uint256 variableBorrowIndex );  address public lendingPoolAddress;  LendingPoolAddressesProvider public addressesProvider;  /** * @dev only lending pools can use functions affected by this modifier **/ modifier onlyLendingPool {     require(lendingPoolAddress == msg.sender, "The caller must be a lending pool contract");     _; }  /** * @dev only lending pools configurator can use functions affected by this modifier **/ modifier onlyLendingPoolConfigurator {     require(         addressesProvider.getLendingPoolConfigurator() == msg.sender,         "The caller must be a lending pool configurator contract"     );     _; }  mapping(address =&gt; CoreLibrary.ReserveData) internal reserves; mapping(address =&gt; mapping(address =&gt; CoreLibrary.UserReserveData)) internal usersReserveData;  address[] public reservesList;  uint256 public constant CORE_REVISION = 0x4;  /** * @dev returns the revision number of the contract **/ function getRevision() internal pure returns (uint256) {     return CORE_REVISION; }  /** * @dev initializes the Core contract, invoked upon registration on the AddressesProvider * @param _addressesProvider the addressesProvider contract **/  function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {     addressesProvider = _addressesProvider;     refreshConfigInternal(); }  /** * @dev updates the state of the core as a result of a deposit action * @param _reserve the address of the reserve in which the deposit is happening * @param _user the address of the the user depositing * @param _amount the amount being deposited * @param _isFirstDeposit true if the user is depositing for the first time **/  function updateStateOnDeposit(     address _reserve,     address _user,     uint256 _amount,     bool _isFirstDeposit ) external onlyLendingPool {     reserves[_reserve].updateCumulativeIndexes();     updateReserveInterestRatesAndTimestampInternal(_reserve, _amount, 0);      if (_isFirstDeposit) {         //if this is the first deposit of the user, we configure the deposit as enabled to be used as collateral         setUserUseReserveAsCollateral(_reserve, _user, true);     } }  /** * @dev updates the state of the core as a result of a redeem action * @param _reserve the address of the reserve in which the redeem is happening * @param _user the address of the the user redeeming * @param _amountRedeemed the amount being redeemed * @param _userRedeemedEverything true if the user is redeeming everything **/ function updateStateOnRedeem(     address _reserve,     address _user,     uint256 _amountRedeemed,     bool _userRedeemedEverything ) external onlyLendingPool {     //compound liquidity and variable borrow interests     reserves[_reserve].updateCumulativeIndexes();     updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountRedeemed);      //if user redeemed everything the useReserveAsCollateral flag is reset     if (_userRedeemedEverything) {         setUserUseReserveAsCollateral(_reserve, _user, false);     } }  /** * @dev updates the state of the core as a result of a flashloan action * @param _reserve the address of the reserve in which the flashloan is happening * @param _income the income of the protocol as a result of the action **/ function updateStateOnFlashLoan(     address _reserve,     uint256 _availableLiquidityBefore,     uint256 _income,     uint256 _protocolFee ) external onlyLendingPool {     transferFlashLoanProtocolFeeInternal(_reserve, _protocolFee);      //compounding the cumulated interest     reserves[_reserve].updateCumulativeIndexes();      uint256 totalLiquidityBefore = _availableLiquidityBefore.add(         getReserveTotalBorrows(_reserve)     );      //compounding the received fee into the reserve     reserves[_reserve].cumulateToLiquidityIndex(totalLiquidityBefore, _income);      //refresh interest rates     updateReserveInterestRatesAndTimestampInternal(_reserve, _income, 0); }  /** * @dev updates the state of the core as a consequence of a borrow action. * @param _reserve the address of the reserve on which the user is borrowing * @param _user the address of the borrower * @param _amountBorrowed the new amount borrowed * @param _borrowFee the fee on the amount borrowed * @param _rateMode the borrow rate mode (stable, variable) * @return the new borrow rate for the user **/ function updateStateOnBorrow(     address _reserve,     address _user,     uint256 _amountBorrowed,     uint256 _borrowFee,     CoreLibrary.InterestRateMode _rateMode ) external onlyLendingPool returns (uint256, uint256) {     // getting the previous borrow data of the user     (uint256 principalBorrowBalance, , uint256 balanceIncrease) = getUserBorrowBalances(         _reserve,         _user     );      updateReserveStateOnBorrowInternal(         _reserve,         _user,         principalBorrowBalance,         balanceIncrease,         _amountBorrowed,         _rateMode     );      updateUserStateOnBorrowInternal(         _reserve,         _user,         _amountBorrowed,         balanceIncrease,         _borrowFee,         _rateMode     );      updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountBorrowed);      return (getUserCurrentBorrowRate(_reserve, _user), balanceIncrease); }  /** * @dev updates the state of the core as a consequence of a repay action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _paybackAmountMinusFees the amount being paid back minus fees * @param _originationFeeRepaid the fee on the amount that is being repaid * @param _balanceIncrease the accrued interest on the borrowed amount * @param _repaidWholeLoan true if the user is repaying the whole loan **/  function updateStateOnRepay(     address _reserve,     address _user,     uint256 _paybackAmountMinusFees,     uint256 _originationFeeRepaid,     uint256 _balanceIncrease,     bool _repaidWholeLoan ) external onlyLendingPool {     updateReserveStateOnRepayInternal(         _reserve,         _user,         _paybackAmountMinusFees,         _balanceIncrease     );     updateUserStateOnRepayInternal(         _reserve,         _user,         _paybackAmountMinusFees,         _originationFeeRepaid,         _balanceIncrease,         _repaidWholeLoan     );      updateReserveInterestRatesAndTimestampInternal(_reserve, _paybackAmountMinusFees, 0); }  /** * @dev updates the state of the core as a consequence of a swap rate action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _principalBorrowBalance the amount borrowed by the user * @param _compoundedBorrowBalance the amount borrowed plus accrued interest * @param _balanceIncrease the accrued interest on the borrowed amount * @param _currentRateMode the current interest rate mode for the user **/ function updateStateOnSwapRate(     address _reserve,     address _user,     uint256 _principalBorrowBalance,     uint256 _compoundedBorrowBalance,     uint256 _balanceIncrease,     CoreLibrary.InterestRateMode _currentRateMode ) external onlyLendingPool returns (CoreLibrary.InterestRateMode, uint256) {     updateReserveStateOnSwapRateInternal(         _reserve,         _user,         _principalBorrowBalance,         _compoundedBorrowBalance,         _currentRateMode     );      CoreLibrary.InterestRateMode newRateMode = updateUserStateOnSwapRateInternal(         _reserve,         _user,         _balanceIncrease,         _currentRateMode     );      updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);      return (newRateMode, getUserCurrentBorrowRate(_reserve, _user)); }  /** * @dev updates the state of the core as a consequence of a liquidation action. * @param _principalReserve the address of the principal reserve that is being repaid * @param _collateralReserve the address of the collateral reserve that is being liquidated * @param _user the address of the borrower * @param _amountToLiquidate the amount being repaid by the liquidator * @param _collateralToLiquidate the amount of collateral being liquidated * @param _feeLiquidated the amount of origination fee being liquidated * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus * @param _balanceIncrease the accrued interest on the borrowed amount * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise **/ function updateStateOnLiquidation(     address _principalReserve,     address _collateralReserve,     address _user,     uint256 _amountToLiquidate,     uint256 _collateralToLiquidate,     uint256 _feeLiquidated,     uint256 _liquidatedCollateralForFee,     uint256 _balanceIncrease,     bool _liquidatorReceivesAToken ) external onlyLendingPool {     updatePrincipalReserveStateOnLiquidationInternal(         _principalReserve,         _user,         _amountToLiquidate,         _balanceIncrease     );      updateCollateralReserveStateOnLiquidationInternal(         _collateralReserve     );      updateUserStateOnLiquidationInternal(         _principalReserve,         _user,         _amountToLiquidate,         _feeLiquidated,         _balanceIncrease     );      updateReserveInterestRatesAndTimestampInternal(_principalReserve, _amountToLiquidate, 0);      if (!_liquidatorReceivesAToken) {         updateReserveInterestRatesAndTimestampInternal(             _collateralReserve,             0,             _collateralToLiquidate.add(_liquidatedCollateralForFee)         );     }  }  /** * @dev updates the state of the core as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount * @return the new stable rate for the user **/ function updateStateOnRebalance(address _reserve, address _user, uint256 _balanceIncrease) external onlyLendingPool returns (uint256) {     updateReserveStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);      //update user data and rebalance the rate     updateUserStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);     updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);     return usersReserveData[_user][_reserve].stableBorrowRate; }  /** * @dev enables or disables a reserve as collateral * @param _reserve the address of the principal reserve where the user deposited * @param _user the address of the depositor * @param _useAsCollateral true if the depositor wants to use the reserve as collateral **/ function setUserUseReserveAsCollateral(address _reserve, address _user, bool _useAsCollateral) public onlyLendingPool {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     user.useAsCollateral = _useAsCollateral; }  /** * @notice ETH/token transfer functions **/  /** * @dev fallback function enforces that the caller is a contract, to support flashloan transfers **/ function() external payable {     //only contracts can send ETH to the core     require(msg.sender.isContract(), "Only contracts can send ether to the Lending pool core");  }  /** * @dev transfers to the user a specific amount from the reserve. * @param _reserve the address of the reserve where the transfer is happening * @param _user the address of the user receiving the transfer * @param _amount the amount being transferred **/ function transferToUser(address _reserve, address payable _user, uint256 _amount) external onlyLendingPool {     if (_reserve != EthAddressLib.ethAddress()) {         ERC20(_reserve).safeTransfer(_user, _amount);     } else {         //solium-disable-next-line         (bool result, ) = _user.call.value(_amount).gas(50000)("");         require(result, "Transfer of ETH failed");     } }  /** * @dev transfers the protocol fees to the fees collection address * @param _token the address of the token being transferred * @param _user the address of the user from where the transfer is happening * @param _amount the amount being transferred * @param _destination the fee receiver address **/  function transferToFeeCollectionAddress(     address _token,     address _user,     uint256 _amount,     address _destination ) external payable onlyLendingPool {     address payable feeAddress = address(uint160(_destination)); //cast the address to payable      if (_token != EthAddressLib.ethAddress()) {         require(             msg.value == 0,             "User is sending ETH along with the ERC20 transfer. Check the value attribute of the transaction"         );         ERC20(_token).safeTransferFrom(_user, feeAddress, _amount);     } else {         require(msg.value &gt;= _amount, "The amount and the value sent to deposit do not match");         //solium-disable-next-line         (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");         require(result, "Transfer of ETH failed");     } }  /** * @dev transfers the fees to the fees collection address in the case of liquidation * @param _token the address of the token being transferred * @param _amount the amount being transferred * @param _destination the fee receiver address **/ function liquidateFee(     address _token,     uint256 _amount,     address _destination ) external payable onlyLendingPool {     address payable feeAddress = address(uint160(_destination)); //cast the address to payable     require(         msg.value == 0,         "Fee liquidation does not require any transfer of value"     );      if (_token != EthAddressLib.ethAddress()) {         ERC20(_token).safeTransfer(feeAddress, _amount);     } else {         //solium-disable-next-line         (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");         require(result, "Transfer of ETH failed");     } }  /** * @dev transfers an amount from a user to the destination reserve * @param _reserve the address of the reserve where the amount is being transferred * @param _user the address of the user from where the transfer is happening * @param _amount the amount being transferred **/ function transferToReserve(address _reserve, address payable _user, uint256 _amount) external payable onlyLendingPool {     if (_reserve != EthAddressLib.ethAddress()) {         require(msg.value == 0, "User is sending ETH along with the ERC20 transfer.");         ERC20(_reserve).safeTransferFrom(_user, address(this), _amount);      } else {         require(msg.value &gt;= _amount, "The amount and the value sent to deposit do not match");          if (msg.value &gt; _amount) {             //send back excess ETH             uint256 excessAmount = msg.value.sub(_amount);             //solium-disable-next-line             (bool result, ) = _user.call.value(excessAmount).gas(50000)("");             require(result, "Transfer of ETH failed");         }     } }  /** * @notice data access functions **/  /** * @dev returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral) * needed to calculate the global account data in the LendingPoolDataProvider * @param _reserve the address of the reserve * @param _user the address of the user * @return the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not **/ function getUserBasicReserveData(address _reserve, address _user) external view returns (uint256, uint256, uint256, bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      uint256 underlyingBalance = getUserUnderlyingAssetBalance(_reserve, _user);      if (user.principalBorrowBalance == 0) {         return (underlyingBalance, 0, 0, user.useAsCollateral);     }      return (     underlyingBalance,     user.getCompoundedBorrowBalance(reserve),     user.originationFee,     user.useAsCollateral     ); }  /** * @dev checks if a user is allowed to borrow at a stable rate * @param _reserve the reserve address * @param _user the user * @param _amount the amount the the user wants to borrow * @return true if the user is allowed to borrow at a stable rate, false otherwise **/  function isUserAllowedToBorrowAtStable(address _reserve, address _user, uint256 _amount) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      if (!reserve.isStableBorrowRateEnabled) return false;      return     !user.useAsCollateral ||     !reserve.usageAsCollateralEnabled ||     _amount &gt; getUserUnderlyingAssetBalance(_reserve, _user); }  /** * @dev gets the underlying asset balance of a user based on the corresponding aToken balance. * @param _reserve the reserve address * @param _user the user address * @return the underlying deposit balance of the user **/  function getUserUnderlyingAssetBalance(address _reserve, address _user) public view returns (uint256) {     AToken aToken = AToken(reserves[_reserve].aTokenAddress);     return aToken.balanceOf(_user);  }  /** * @dev gets the interest rate strategy contract address for the reserve * @param _reserve the reserve address * @return the address of the interest rate strategy contract **/ function getReserveInterestRateStrategyAddress(address _reserve) public view returns (address) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.interestRateStrategyAddress; }  /** * @dev gets the aToken contract address for the reserve * @param _reserve the reserve address * @return the address of the aToken contract **/  function getReserveATokenAddress(address _reserve) public view returns (address) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.aTokenAddress; }  /** * @dev gets the available liquidity in the reserve. The available liquidity is the balance of the core contract * @param _reserve the reserve address * @return the available liquidity **/ function getReserveAvailableLiquidity(address _reserve) public view returns (uint256) {     uint256 balance = 0;      if (_reserve == EthAddressLib.ethAddress()) {         balance = address(this).balance;     } else {         balance = IERC20(_reserve).balanceOf(address(this));     }     return balance; }  /** * @dev gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows * @param _reserve the reserve address * @return the total liquidity **/ function getReserveTotalLiquidity(address _reserve) public view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return getReserveAvailableLiquidity(_reserve).add(reserve.getTotalBorrows()); }  /** * @dev gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there * there has been 100% income. * @param _reserve the reserve address * @return the reserve normalized income **/ function getReserveNormalizedIncome(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.getNormalizedIncome(); }  /** * @dev gets the reserve total borrows * @param _reserve the reserve address * @return the total borrows (stable + variable) **/ function getReserveTotalBorrows(address _reserve) public view returns (uint256) {     return reserves[_reserve].getTotalBorrows(); }  /** * @dev gets the reserve total borrows stable * @param _reserve the reserve address * @return the total borrows stable **/ function getReserveTotalBorrowsStable(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.totalBorrowsStable; }  /** * @dev gets the reserve total borrows variable * @param _reserve the reserve address * @return the total borrows variable **/  function getReserveTotalBorrowsVariable(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.totalBorrowsVariable; }  /** * @dev gets the reserve liquidation threshold * @param _reserve the reserve address * @return the reserve liquidation threshold **/  function getReserveLiquidationThreshold(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.liquidationThreshold; }  /** * @dev gets the reserve liquidation bonus * @param _reserve the reserve address * @return the reserve liquidation bonus **/  function getReserveLiquidationBonus(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.liquidationBonus; }  /** * @dev gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty * @param _reserve the reserve address * @return the reserve current variable borrow rate **/  function getReserveCurrentVariableBorrowRate(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      if (reserve.currentVariableBorrowRate == 0) {         return         IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)         .getBaseVariableBorrowRate();     }     return reserve.currentVariableBorrowRate; }  /** * @dev gets the reserve current stable borrow rate. Is the market rate if the reserve is empty * @param _reserve the reserve address * @return the reserve current stable borrow rate **/  function getReserveCurrentStableBorrowRate(address _reserve) public view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     ILendingRateOracle oracle = ILendingRateOracle(addressesProvider.getLendingRateOracle());      if (reserve.currentStableBorrowRate == 0) {         //no stable rate borrows yet         return oracle.getMarketBorrowRate(_reserve);     }      return reserve.currentStableBorrowRate; }  /** * @dev gets the reserve average stable borrow rate. The average stable rate is the weighted average * of all the loans taken at stable rate. * @param _reserve the reserve address * @return the reserve current average borrow rate **/ function getReserveCurrentAverageStableBorrowRate(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.currentAverageStableBorrowRate; }  /** * @dev gets the reserve liquidity rate * @param _reserve the reserve address * @return the reserve liquidity rate **/ function getReserveCurrentLiquidityRate(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.currentLiquidityRate; }  /** * @dev gets the reserve liquidity cumulative index * @param _reserve the reserve address * @return the reserve liquidity cumulative index **/ function getReserveLiquidityCumulativeIndex(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.lastLiquidityCumulativeIndex; }  /** * @dev gets the reserve variable borrow index * @param _reserve the reserve address * @return the reserve variable borrow index **/ function getReserveVariableBorrowsCumulativeIndex(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.lastVariableBorrowCumulativeIndex; }  /** * @dev this function aggregates the configuration parameters of the reserve. * It's used in the LendingPoolDataProvider specifically to save gas, and avoid * multiple external contract calls to fetch the same data. * @param _reserve the reserve address * @return the reserve decimals * @return the base ltv as collateral * @return the liquidation threshold * @return if the reserve is used as collateral or not **/ function getReserveConfiguration(address _reserve) external view returns (uint256, uint256, uint256, bool) {     uint256 decimals;     uint256 baseLTVasCollateral;     uint256 liquidationThreshold;     bool usageAsCollateralEnabled;      CoreLibrary.ReserveData storage reserve = reserves[_reserve];     decimals = reserve.decimals;     baseLTVasCollateral = reserve.baseLTVasCollateral;     liquidationThreshold = reserve.liquidationThreshold;     usageAsCollateralEnabled = reserve.usageAsCollateralEnabled;      return (decimals, baseLTVasCollateral, liquidationThreshold, usageAsCollateralEnabled); }  /** * @dev returns the decimals of the reserve * @param _reserve the reserve address * @return the reserve decimals **/ function getReserveDecimals(address _reserve) external view returns (uint256) {     return reserves[_reserve].decimals; }  /** * @dev returns true if the reserve is enabled for borrowing * @param _reserve the reserve address * @return true if the reserve is enabled for borrowing, false otherwise **/  function isReserveBorrowingEnabled(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.borrowingEnabled; }  /** * @dev returns true if the reserve is enabled as collateral * @param _reserve the reserve address * @return true if the reserve is enabled as collateral, false otherwise **/  function isReserveUsageAsCollateralEnabled(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.usageAsCollateralEnabled; }  /** * @dev returns true if the stable rate is enabled on reserve * @param _reserve the reserve address * @return true if the stable rate is enabled on reserve, false otherwise **/ function getReserveIsStableBorrowRateEnabled(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.isStableBorrowRateEnabled; }  /** * @dev returns true if the reserve is active * @param _reserve the reserve address * @return true if the reserve is active, false otherwise **/ function getReserveIsActive(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.isActive; }  /** * @notice returns if a reserve is freezed * @param _reserve the reserve for which the information is needed * @return true if the reserve is freezed, false otherwise **/  function getReserveIsFreezed(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.isFreezed; }  /** * @notice returns the timestamp of the last action on the reserve * @param _reserve the reserve for which the information is needed * @return the last updated timestamp of the reserve **/  function getReserveLastUpdate(address _reserve) external view returns (uint40 timestamp) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     timestamp = reserve.lastUpdateTimestamp; }  /** * @dev returns the utilization rate U of a specific reserve * @param _reserve the reserve for which the information is needed * @return the utilization rate in ray **/  function getReserveUtilizationRate(address _reserve) public view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      uint256 totalBorrows = reserve.getTotalBorrows();      if (totalBorrows == 0) {         return 0;     }      uint256 availableLiquidity = getReserveAvailableLiquidity(_reserve);      return totalBorrows.rayDiv(availableLiquidity.add(totalBorrows)); }  /** * @return the array of reserves configured on the core **/ function getReserves() external view returns (address[] memory) {     return reservesList; }  /** * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return true if the user has chosen to use the reserve as collateral, false otherwise **/ function isUserUseReserveAsCollateralEnabled(address _reserve, address _user) external view returns (bool) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.useAsCollateral; }  /** * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the origination fee for the user **/ function getUserOriginationFee(address _reserve, address _user) external view returns (uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.originationFee; }  /** * @dev users with no loans in progress have NONE as borrow rate mode * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the borrow rate mode for the user, **/  function getUserCurrentBorrowRateMode(address _reserve, address _user) public view returns (CoreLibrary.InterestRateMode) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      if (user.principalBorrowBalance == 0) {         return CoreLibrary.InterestRateMode.NONE;     }      return     user.stableBorrowRate &gt; 0     ? CoreLibrary.InterestRateMode.STABLE     : CoreLibrary.InterestRateMode.VARIABLE; }  /** * @dev gets the current borrow rate of the user * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the borrow rate for the user, **/ function getUserCurrentBorrowRate(address _reserve, address _user) internal view returns (uint256) {     CoreLibrary.InterestRateMode rateMode = getUserCurrentBorrowRateMode(_reserve, _user);      if (rateMode == CoreLibrary.InterestRateMode.NONE) {         return 0;     }      return     rateMode == CoreLibrary.InterestRateMode.STABLE     ? usersReserveData[_user][_reserve].stableBorrowRate     : reserves[_reserve].currentVariableBorrowRate; }  /** * @dev the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the user stable rate **/ function getUserCurrentStableBorrowRate(address _reserve, address _user) external view returns (uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.stableBorrowRate; }  /** * @dev calculates and returns the borrow balances of the user * @param _reserve the address of the reserve * @param _user the address of the user * @return the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance **/  function getUserBorrowBalances(address _reserve, address _user) public view returns (uint256, uint256, uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     if (user.principalBorrowBalance == 0) {         return (0, 0, 0);     }      uint256 principal = user.principalBorrowBalance;     uint256 compoundedBalance = CoreLibrary.getCompoundedBorrowBalance(         user,         reserves[_reserve]     );     return (principal, compoundedBalance, compoundedBalance.sub(principal)); }  /** * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the variable borrow index for the user **/  function getUserVariableBorrowCumulativeIndex(address _reserve, address _user) external view returns (uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.lastVariableBorrowCumulativeIndex; }  /** * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the variable borrow index for the user **/  function getUserLastUpdate(address _reserve, address _user) external view returns (uint256 timestamp) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     timestamp = user.lastUpdateTimestamp; }  /** * @dev updates the lending pool core configuration **/ function refreshConfiguration() external onlyLendingPoolConfigurator {     refreshConfigInternal(); }  /** * @dev initializes a reserve * @param _reserve the address of the reserve * @param _aTokenAddress the address of the overlying aToken contract * @param _decimals the decimals of the reserve currency * @param _interestRateStrategyAddress the address of the interest rate strategy contract **/ function initReserve(     address _reserve,     address _aTokenAddress,     uint256 _decimals,     address _interestRateStrategyAddress ) external onlyLendingPoolConfigurator {     reserves[_reserve].init(_aTokenAddress, _decimals, _interestRateStrategyAddress);     addReserveToListInternal(_reserve);  }    /** * @dev removes the last added reserve in the reservesList array * @param _reserveToRemove the address of the reserve **/ function removeLastAddedReserve(address _reserveToRemove) external onlyLendingPoolConfigurator {      address lastReserve = reservesList[reservesList.length-1];      require(lastReserve == _reserveToRemove, "Reserve being removed is different than the reserve requested");      //as we can't check if totalLiquidity is 0 (since the reserve added might not be an ERC20) we at least check that there is nothing borrowed     require(getReserveTotalBorrows(lastReserve) == 0, "Cannot remove a reserve with liquidity deposited");      reserves[lastReserve].isActive = false;     reserves[lastReserve].aTokenAddress = address(0);     reserves[lastReserve].decimals = 0;     reserves[lastReserve].lastLiquidityCumulativeIndex = 0;     reserves[lastReserve].lastVariableBorrowCumulativeIndex = 0;     reserves[lastReserve].borrowingEnabled = false;     reserves[lastReserve].usageAsCollateralEnabled = false;     reserves[lastReserve].baseLTVasCollateral = 0;     reserves[lastReserve].liquidationThreshold = 0;     reserves[lastReserve].liquidationBonus = 0;     reserves[lastReserve].interestRateStrategyAddress = address(0);      reservesList.pop(); }  /** * @dev updates the address of the interest rate strategy contract * @param _reserve the address of the reserve * @param _rateStrategyAddress the address of the interest rate strategy contract **/  function setReserveInterestRateStrategyAddress(address _reserve, address _rateStrategyAddress) external onlyLendingPoolConfigurator {     reserves[_reserve].interestRateStrategyAddress = _rateStrategyAddress; }  /** * @dev enables borrowing on a reserve. Also sets the stable rate borrowing * @param _reserve the address of the reserve * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise **/  function enableBorrowingOnReserve(address _reserve, bool _stableBorrowRateEnabled) external onlyLendingPoolConfigurator {     reserves[_reserve].enableBorrowing(_stableBorrowRateEnabled); }  /** * @dev disables borrowing on a reserve * @param _reserve the address of the reserve **/  function disableBorrowingOnReserve(address _reserve) external onlyLendingPoolConfigurator {     reserves[_reserve].disableBorrowing(); }  /** * @dev enables a reserve to be used as collateral * @param _reserve the address of the reserve **/ function enableReserveAsCollateral(     address _reserve,     uint256 _baseLTVasCollateral,     uint256 _liquidationThreshold,     uint256 _liquidationBonus ) external onlyLendingPoolConfigurator {     reserves[_reserve].enableAsCollateral(         _baseLTVasCollateral,         _liquidationThreshold,         _liquidationBonus     ); }  /** * @dev disables a reserve to be used as collateral * @param _reserve the address of the reserve **/ function disableReserveAsCollateral(address _reserve) external onlyLendingPoolConfigurator {     reserves[_reserve].disableAsCollateral(); }  /** * @dev enable the stable borrow rate mode on a reserve * @param _reserve the address of the reserve **/ function enableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isStableBorrowRateEnabled = true; }  /** * @dev disable the stable borrow rate mode on a reserve * @param _reserve the address of the reserve **/ function disableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isStableBorrowRateEnabled = false; }  /** * @dev activates a reserve * @param _reserve the address of the reserve **/ function activateReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      require(         reserve.lastLiquidityCumulativeIndex &gt; 0 &amp;&amp;         reserve.lastVariableBorrowCumulativeIndex &gt; 0,         "Reserve has not been initialized yet"     );     reserve.isActive = true; }  /** * @dev deactivates a reserve * @param _reserve the address of the reserve **/ function deactivateReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isActive = false; }  /** * @notice allows the configurator to freeze the reserve. * A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance. * @param _reserve the address of the reserve **/ function freezeReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isFreezed = true; }  /** * @notice allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed. * @param _reserve the address of the reserve **/ function unfreezeReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isFreezed = false; }  /** * @notice allows the configurator to update the loan to value of a reserve * @param _reserve the address of the reserve * @param _ltv the new loan to value **/ function setReserveBaseLTVasCollateral(address _reserve, uint256 _ltv) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.baseLTVasCollateral = _ltv; }  /** * @notice allows the configurator to update the liquidation threshold of a reserve * @param _reserve the address of the reserve * @param _threshold the new liquidation threshold **/ function setReserveLiquidationThreshold(address _reserve, uint256 _threshold) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.liquidationThreshold = _threshold; }  /** * @notice allows the configurator to update the liquidation bonus of a reserve * @param _reserve the address of the reserve * @param _bonus the new liquidation bonus **/ function setReserveLiquidationBonus(address _reserve, uint256 _bonus) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.liquidationBonus = _bonus; }  /** * @notice allows the configurator to update the reserve decimals * @param _reserve the address of the reserve * @param _decimals the decimals of the reserve **/ function setReserveDecimals(address _reserve, uint256 _decimals) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.decimals = _decimals; }  /** * @notice internal functions **/  /** * @dev updates the state of a reserve as a consequence of a borrow action. * @param _reserve the address of the reserve on which the user is borrowing * @param _user the address of the borrower * @param _principalBorrowBalance the previous borrow balance of the borrower before the action * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount * @param _amountBorrowed the new amount borrowed * @param _rateMode the borrow rate mode (stable, variable) **/  function updateReserveStateOnBorrowInternal(     address _reserve,     address _user,     uint256 _principalBorrowBalance,     uint256 _balanceIncrease,     uint256 _amountBorrowed,     CoreLibrary.InterestRateMode _rateMode ) internal {     reserves[_reserve].updateCumulativeIndexes();      //increasing reserve total borrows to account for the new borrow balance of the user     //NOTE: Depending on the previous borrow mode, the borrows might need to be switched from variable to stable or vice versa      updateReserveTotalBorrowsByRateModeInternal(         _reserve,         _user,         _principalBorrowBalance,         _balanceIncrease,         _amountBorrowed,         _rateMode     ); }  /** * @dev updates the state of a user as a consequence of a borrow action. * @param _reserve the address of the reserve on which the user is borrowing * @param _user the address of the borrower * @param _amountBorrowed the amount borrowed * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount * @param _rateMode the borrow rate mode (stable, variable) * @return the final borrow rate for the user. Emitted by the borrow() event **/  function updateUserStateOnBorrowInternal(     address _reserve,     address _user,     uint256 _amountBorrowed,     uint256 _balanceIncrease,     uint256 _fee,     CoreLibrary.InterestRateMode _rateMode ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      if (_rateMode == CoreLibrary.InterestRateMode.STABLE) {         //stable         //reset the user variable index, and update the stable rate         user.stableBorrowRate = reserve.currentStableBorrowRate;         user.lastVariableBorrowCumulativeIndex = 0;     } else if (_rateMode == CoreLibrary.InterestRateMode.VARIABLE) {         //variable         //reset the user stable rate, and store the new borrow index         user.stableBorrowRate = 0;         user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;     } else {         revert("Invalid borrow rate mode");     }     //increase the principal borrows and the origination fee     user.principalBorrowBalance = user.principalBorrowBalance.add(_amountBorrowed).add(         _balanceIncrease     );     user.originationFee = user.originationFee.add(_fee);      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp);  }  /** * @dev updates the state of the reserve as a consequence of a repay action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _paybackAmountMinusFees the amount being paid back minus fees * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updateReserveStateOnRepayInternal(     address _reserve,     address _user,     uint256 _paybackAmountMinusFees,     uint256 _balanceIncrease ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_reserve][_user];      CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(_reserve, _user);      //update the indexes     reserves[_reserve].updateCumulativeIndexes();      //compound the cumulated interest to the borrow balance and then subtracting the payback amount     if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             _balanceIncrease,             user.stableBorrowRate         );         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _paybackAmountMinusFees,             user.stableBorrowRate         );     } else {         reserve.increaseTotalBorrowsVariable(_balanceIncrease);         reserve.decreaseTotalBorrowsVariable(_paybackAmountMinusFees);     } }  /** * @dev updates the state of the user as a consequence of a repay action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _paybackAmountMinusFees the amount being paid back minus fees * @param _originationFeeRepaid the fee on the amount that is being repaid * @param _balanceIncrease the accrued interest on the borrowed amount * @param _repaidWholeLoan true if the user is repaying the whole loan **/ function updateUserStateOnRepayInternal(     address _reserve,     address _user,     uint256 _paybackAmountMinusFees,     uint256 _originationFeeRepaid,     uint256 _balanceIncrease,     bool _repaidWholeLoan ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      //update the user principal borrow balance, adding the cumulated interest and then subtracting the payback amount     user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(         _paybackAmountMinusFees     );     user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;      //if the balance decrease is equal to the previous principal (user is repaying the whole loan)     //and the rate mode is stable, we reset the interest rate mode of the user     if (_repaidWholeLoan) {         user.stableBorrowRate = 0;         user.lastVariableBorrowCumulativeIndex = 0;     }     user.originationFee = user.originationFee.sub(_originationFeeRepaid);      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp);  }  /** * @dev updates the state of the user as a consequence of a swap rate action. * @param _reserve the address of the reserve on which the user is performing the rate swap * @param _user the address of the borrower * @param _principalBorrowBalance the the principal amount borrowed by the user * @param _compoundedBorrowBalance the principal amount plus the accrued interest * @param _currentRateMode the rate mode at which the user borrowed **/ function updateReserveStateOnSwapRateInternal(     address _reserve,     address _user,     uint256 _principalBorrowBalance,     uint256 _compoundedBorrowBalance,     CoreLibrary.InterestRateMode _currentRateMode ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      //compounding reserve indexes     reserve.updateCumulativeIndexes();      if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {         uint256 userCurrentStableRate = user.stableBorrowRate;          //swap to variable         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _principalBorrowBalance,             userCurrentStableRate         ); //decreasing stable from old principal balance         reserve.increaseTotalBorrowsVariable(_compoundedBorrowBalance); //increase variable borrows     } else if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         //swap to stable         uint256 currentStableRate = reserve.currentStableBorrowRate;         reserve.decreaseTotalBorrowsVariable(_principalBorrowBalance);         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             _compoundedBorrowBalance,             currentStableRate         );      } else {         revert("Invalid rate mode received");     } }  /** * @dev updates the state of the user as a consequence of a swap rate action. * @param _reserve the address of the reserve on which the user is performing the swap * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount * @param _currentRateMode the current rate mode of the user **/  function updateUserStateOnSwapRateInternal(     address _reserve,     address _user,     uint256 _balanceIncrease,     CoreLibrary.InterestRateMode _currentRateMode ) internal returns (CoreLibrary.InterestRateMode) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      CoreLibrary.InterestRateMode newMode = CoreLibrary.InterestRateMode.NONE;      if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         //switch to stable         newMode = CoreLibrary.InterestRateMode.STABLE;         user.stableBorrowRate = reserve.currentStableBorrowRate;         user.lastVariableBorrowCumulativeIndex = 0;     } else if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {         newMode = CoreLibrary.InterestRateMode.VARIABLE;         user.stableBorrowRate = 0;         user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;     } else {         revert("Invalid interest rate mode received");     }     //compounding cumulated interest     user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);     //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp);      return newMode; }  /** * @dev updates the state of the principal reserve as a consequence of a liquidation action. * @param _principalReserve the address of the principal reserve that is being repaid * @param _user the address of the borrower * @param _amountToLiquidate the amount being repaid by the liquidator * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updatePrincipalReserveStateOnLiquidationInternal(     address _principalReserve,     address _user,     uint256 _amountToLiquidate,     uint256 _balanceIncrease ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_principalReserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_principalReserve];      //update principal reserve data     reserve.updateCumulativeIndexes();      CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(         _principalReserve,         _user     );      if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {         //increase the total borrows by the compounded interest         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             _balanceIncrease,             user.stableBorrowRate         );          //decrease by the actual amount to liquidate         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _amountToLiquidate,             user.stableBorrowRate         );      } else {         //increase the total borrows by the compounded interest         reserve.increaseTotalBorrowsVariable(_balanceIncrease);          //decrease by the actual amount to liquidate         reserve.decreaseTotalBorrowsVariable(_amountToLiquidate);     }  }  /** * @dev updates the state of the collateral reserve as a consequence of a liquidation action. * @param _collateralReserve the address of the collateral reserve that is being liquidated **/ function updateCollateralReserveStateOnLiquidationInternal(     address _collateralReserve ) internal {     //update collateral reserve     reserves[_collateralReserve].updateCumulativeIndexes();  }  /** * @dev updates the state of the user being liquidated as a consequence of a liquidation action. * @param _reserve the address of the principal reserve that is being repaid * @param _user the address of the borrower * @param _amountToLiquidate the amount being repaid by the liquidator * @param _feeLiquidated the amount of origination fee being liquidated * @param _balanceIncrease the accrued interest on the borrowed amount **/ function updateUserStateOnLiquidationInternal(     address _reserve,     address _user,     uint256 _amountToLiquidate,     uint256 _feeLiquidated,     uint256 _balanceIncrease ) internal {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     //first increase by the compounded interest, then decrease by the liquidated amount     user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(         _amountToLiquidate     );      if (         getUserCurrentBorrowRateMode(_reserve, _user) == CoreLibrary.InterestRateMode.VARIABLE     ) {         user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;     }      if(_feeLiquidated &gt; 0){         user.originationFee = user.originationFee.sub(_feeLiquidated);     }      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp); }  /** * @dev updates the state of the reserve as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updateReserveStateOnRebalanceInternal(     address _reserve,     address _user,     uint256 _balanceIncrease ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      reserve.updateCumulativeIndexes();      reserve.increaseTotalBorrowsStableAndUpdateAverageRate(         _balanceIncrease,         user.stableBorrowRate     );  }  /** * @dev updates the state of the user as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updateUserStateOnRebalanceInternal(     address _reserve,     address _user,     uint256 _balanceIncrease ) internal {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);     user.stableBorrowRate = reserve.currentStableBorrowRate;      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp); }  /** * @dev updates the state of the user as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount * @param _amountBorrowed the accrued interest on the borrowed amount **/ function updateReserveTotalBorrowsByRateModeInternal(     address _reserve,     address _user,     uint256 _principalBalance,     uint256 _balanceIncrease,     uint256 _amountBorrowed,     CoreLibrary.InterestRateMode _newBorrowRateMode ) internal {     CoreLibrary.InterestRateMode previousRateMode = getUserCurrentBorrowRateMode(         _reserve,         _user     );     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      if (previousRateMode == CoreLibrary.InterestRateMode.STABLE) {         CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _principalBalance,             user.stableBorrowRate         );     } else if (previousRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         reserve.decreaseTotalBorrowsVariable(_principalBalance);     }      uint256 newPrincipalAmount = _principalBalance.add(_balanceIncrease).add(_amountBorrowed);     if (_newBorrowRateMode == CoreLibrary.InterestRateMode.STABLE) {         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             newPrincipalAmount,             reserve.currentStableBorrowRate         );     } else if (_newBorrowRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         reserve.increaseTotalBorrowsVariable(newPrincipalAmount);     } else {         revert("Invalid new borrow rate mode");     } }  /** * @dev Updates the reserve current stable borrow rate Rf, the current variable borrow rate Rv and the current liquidity rate Rl. * Also updates the lastUpdateTimestamp value. Please refer to the whitepaper for further information. * @param _reserve the address of the reserve to be updated * @param _liquidityAdded the amount of liquidity added to the protocol (deposit or repay) in the previous action * @param _liquidityTaken the amount of liquidity taken from the protocol (redeem or borrow) **/  function updateReserveInterestRatesAndTimestampInternal(     address _reserve,     uint256 _liquidityAdded,     uint256 _liquidityTaken ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     (uint256 newLiquidityRate, uint256 newStableRate, uint256 newVariableRate) = IReserveInterestRateStrategy(         reserve         .interestRateStrategyAddress     )     .calculateInterestRates(         _reserve,         getReserveAvailableLiquidity(_reserve).add(_liquidityAdded).sub(_liquidityTaken),         reserve.totalBorrowsStable,         reserve.totalBorrowsVariable,         reserve.currentAverageStableBorrowRate     );      reserve.currentLiquidityRate = newLiquidityRate;     reserve.currentStableBorrowRate = newStableRate;     reserve.currentVariableBorrowRate = newVariableRate;      //solium-disable-next-line     reserve.lastUpdateTimestamp = uint40(block.timestamp);      emit ReserveUpdated(         _reserve,         newLiquidityRate,         newStableRate,         newVariableRate,         reserve.lastLiquidityCumulativeIndex,         reserve.lastVariableBorrowCumulativeIndex     ); }  /** * @dev transfers to the protocol fees of a flashloan to the fees collection address * @param _token the address of the token being transferred * @param _amount the amount being transferred **/  function transferFlashLoanProtocolFeeInternal(address _token, uint256 _amount) internal {     address payable receiver = address(uint160(addressesProvider.getTokenDistributor()));      if (_token != EthAddressLib.ethAddress()) {         ERC20(_token).safeTransfer(receiver, _amount);     } else {         receiver.transfer(_amount);     } }  /** * @dev updates the internal configuration of the core **/ function refreshConfigInternal() internal {     lendingPoolAddress = addressesProvider.getLendingPool(); }  /** * @dev adds a reserve to the array of the reserves address **/ function addReserveToListInternal(address _reserve) internal {     bool reserveAlreadyAdded = false;     for (uint256 i = 0; i &lt; reservesList.length; i++)         if (reservesList[i] == _reserve) {             reserveAlreadyAdded = true;         }     if (!reserveAlreadyAdded) reservesList.push(_reserve); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 04:31:20 INFO] Counselor: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: pragma solidity ^0.5.0;

import "openzeppelin-solidity/contracts/math/SafeMath.sol";
import "openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol";
import "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol";
import "openzeppelin-solidity/contracts/utils/Address.sol";
import "../libraries/openzeppelin-upgradeability/VersionedInitializable.sol";

import "../libraries/CoreLibrary.sol";
import "../configuration/LendingPoolAddressesProvider.sol";
import "../interfaces/ILendingRateOracle.sol";
import "../interfaces/IReserveInterestRateStrategy.sol";
import "../libraries/WadRayMath.sol";
import "../tokenization/AToken.sol";
import "../libraries/EthAddressLib.sol";

/**
* @title LendingPoolCore contract
* @author Aave
* @notice Holds the state of the lending pool and all the funds deposited
* @dev NOTE: The core does not enforce security checks on the update of the state
* (eg, updateStateOnBorrow() does not enforce that borrowed is enabled on the reserve).
* The check that an action can be performed is a duty of the overlying LendingPool contract.
**/

contract LendingPoolCore is VersionedInitializable {
    using SafeMath for uint256;
    using WadRayMath for uint256;
    using CoreLibrary for CoreLibrary.ReserveData;
    using CoreLibrary for CoreLibrary.UserReserveData;
    using SafeERC20 for ERC20;
    using Address for address payable;

    /**
    * @dev Emitted when the state of a reserve is updated
    * @param reserve the address of the reserve
    * @param liquidityRate the new liquidity rate
    * @param stableBorrowRate the new stable borrow rate
    * @param variableBorrowRate the new variable borrow rate
    * @param liquidityIndex the new liquidity index
    * @param variableBorrowIndex the new variable borrow index
    **/
    event ReserveUpdated(
        address indexed reserve,
        uint256 liquidityRate,
        uint256 stableBorrowRate,
        uint256 variableBorrowRate,
        uint256 liquidityIndex,
        uint256 variableBorrowIndex
    );

    address public lendingPoolAddress;

    LendingPoolAddressesProvider public addressesProvider;

    /**
    * @dev only lending pools can use functions affected by this modifier
    **/
    modifier onlyLendingPool {
        require(lendingPoolAddress == msg.sender, "The caller must be a lending pool contract");
        _;
    }

    /**
    * @dev only lending pools configurator can use functions affected by this modifier
    **/
    modifier onlyLendingPoolConfigurator {
        require(
            addressesProvider.getLendingPoolConfigurator() == msg.sender,
            "The caller must be a lending pool configurator contract"
        );
        _;
    }

    mapping(address => CoreLibrary.ReserveData) internal reserves;
    mapping(address => mapping(address => CoreLibrary.UserReserveData)) internal usersReserveData;

    address[] public reservesList;

    uint256 public constant CORE_REVISION = 0x4;

    /**
    * @dev returns the revision number of the contract
    **/
    function getRevision() internal pure returns (uint256) {
        return CORE_REVISION;
    }

    /**
    * @dev initializes the Core contract, invoked upon registration on the AddressesProvider
    * @param _addressesProvider the addressesProvider contract
    **/

    function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {
        addressesProvider = _addressesProvider;
        refreshConfigInternal();
    }

    /**
    * @dev updates the state of the core as a result of a deposit action
    * @param _reserve the address of the reserve in which the deposit is happening
    * @param _user the address of the the user depositing
    * @param _amount the amount being deposited
    * @param _isFirstDeposit true if the user is depositing for the first time
    **/

    function updateStateOnDeposit(
        address _reserve,
        address _user,
        uint256 _amount,
        bool _isFirstDeposit
    ) external onlyLendingPool {
        reserves[_reserve].updateCumulativeIndexes();
        updateReserveInterestRatesAndTimestampInternal(_reserve, _amount, 0);

        if (_isFirstDeposit) {
            //if this is the first deposit of the user, we configure the deposit as enabled to be used as collateral
            setUserUseReserveAsCollateral(_reserve, _user, true);
        }
    }

    /**
    * @dev updates the state of the core as a result of a redeem action
    * @param _reserve the address of the reserve in which the redeem is happening
    * @param _user the address of the the user redeeming
    * @param _amountRedeemed the amount being redeemed
    * @param _userRedeemedEverything true if the user is redeeming everything
    **/
    function updateStateOnRedeem(
        address _reserve,
        address _user,
        uint256 _amountRedeemed,
        bool _userRedeemedEverything
    ) external onlyLendingPool {
        //compound liquidity and variable borrow interests
        reserves[_reserve].updateCumulativeIndexes();
        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountRedeemed);

        //if user redeemed everything the useReserveAsCollateral flag is reset
        if (_userRedeemedEverything) {
            setUserUseReserveAsCollateral(_reserve, _user, false);
        }
    }

    /**
    * @dev updates the state of the core as a result of a flashloan action
    * @param _reserve the address of the reserve in which the flashloan is happening
    * @param _income the income of the protocol as a result of the action
    **/
    function updateStateOnFlashLoan(
        address _reserve,
        uint256 _availableLiquidityBefore,
        uint256 _income,
        uint256 _protocolFee
    ) external onlyLendingPool {
        transferFlashLoanProtocolFeeInternal(_reserve, _protocolFee);

        //compounding the cumulated interest
        reserves[_reserve].updateCumulativeIndexes();

        uint256 totalLiquidityBefore = _availableLiquidityBefore.add(
            getReserveTotalBorrows(_reserve)
        );

        //compounding the received fee into the reserve
        reserves[_reserve].cumulateToLiquidityIndex(totalLiquidityBefore, _income);

        //refresh interest rates
        updateReserveInterestRatesAndTimestampInternal(_reserve, _income, 0);
    }

    /**
    * @dev updates the state of the core as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _amountBorrowed the new amount borrowed
    * @param _borrowFee the fee on the amount borrowed
    * @param _rateMode the borrow rate mode (stable, variable)
    * @return the new borrow rate for the user
    **/
    function updateStateOnBorrow(
        address _reserve,
        address _user,
        uint256 _amountBorrowed,
        uint256 _borrowFee,
        CoreLibrary.InterestRateMode _rateMode
    ) external onlyLendingPool returns (uint256, uint256) {
        // getting the previous borrow data of the user
        (uint256 principalBorrowBalance, , uint256 balanceIncrease) = getUserBorrowBalances(
            _reserve,
            _user
        );

        updateReserveStateOnBorrowInternal(
            _reserve,
            _user,
            principalBorrowBalance,
            balanceIncrease,
            _amountBorrowed,
            _rateMode
        );

        updateUserStateOnBorrowInternal(
            _reserve,
            _user,
            _amountBorrowed,
            balanceIncrease,
            _borrowFee,
            _rateMode
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountBorrowed);

        return (getUserCurrentBorrowRate(_reserve, _user), balanceIncrease);
    }

    /**
    * @dev updates the state of the core as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _originationFeeRepaid the fee on the amount that is being repaid
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _repaidWholeLoan true if the user is repaying the whole loan
    **/

    function updateStateOnRepay(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _originationFeeRepaid,
        uint256 _balanceIncrease,
        bool _repaidWholeLoan
    ) external onlyLendingPool {
        updateReserveStateOnRepayInternal(
            _reserve,
            _user,
            _paybackAmountMinusFees,
            _balanceIncrease
        );
        updateUserStateOnRepayInternal(
            _reserve,
            _user,
            _paybackAmountMinusFees,
            _originationFeeRepaid,
            _balanceIncrease,
            _repaidWholeLoan
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, _paybackAmountMinusFees, 0);
    }

    /**
    * @dev updates the state of the core as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the amount borrowed by the user
    * @param _compoundedBorrowBalance the amount borrowed plus accrued interest
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _currentRateMode the current interest rate mode for the user
    **/
    function updateStateOnSwapRate(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _compoundedBorrowBalance,
        uint256 _balanceIncrease,
        CoreLibrary.InterestRateMode _currentRateMode
    ) external onlyLendingPool returns (CoreLibrary.InterestRateMode, uint256) {
        updateReserveStateOnSwapRateInternal(
            _reserve,
            _user,
            _principalBorrowBalance,
            _compoundedBorrowBalance,
            _currentRateMode
        );

        CoreLibrary.InterestRateMode newRateMode = updateUserStateOnSwapRateInternal(
            _reserve,
            _user,
            _balanceIncrease,
            _currentRateMode
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);

        return (newRateMode, getUserCurrentBorrowRate(_reserve, _user));
    }

    /**
    * @dev updates the state of the core as a consequence of a liquidation action.
    * @param _principalReserve the address of the principal reserve that is being repaid
    * @param _collateralReserve the address of the collateral reserve that is being liquidated
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _collateralToLiquidate the amount of collateral being liquidated
    * @param _feeLiquidated the amount of origination fee being liquidated
    * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise
    **/
    function updateStateOnLiquidation(
        address _principalReserve,
        address _collateralReserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _collateralToLiquidate,
        uint256 _feeLiquidated,
        uint256 _liquidatedCollateralForFee,
        uint256 _balanceIncrease,
        bool _liquidatorReceivesAToken
    ) external onlyLendingPool {
        updatePrincipalReserveStateOnLiquidationInternal(
            _principalReserve,
            _user,
            _amountToLiquidate,
            _balanceIncrease
        );

        updateCollateralReserveStateOnLiquidationInternal(
            _collateralReserve
        );

        updateUserStateOnLiquidationInternal(
            _principalReserve,
            _user,
            _amountToLiquidate,
            _feeLiquidated,
            _balanceIncrease
        );

        updateReserveInterestRatesAndTimestampInternal(_principalReserve, _amountToLiquidate, 0);

        if (!_liquidatorReceivesAToken) {
            updateReserveInterestRatesAndTimestampInternal(
                _collateralReserve,
                0,
                _collateralToLiquidate.add(_liquidatedCollateralForFee)
            );
        }

    }

    /**
    * @dev updates the state of the core as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @return the new stable rate for the user
    **/
    function updateStateOnRebalance(address _reserve, address _user, uint256 _balanceIncrease)
    external
    onlyLendingPool
    returns (uint256)
    {
        updateReserveStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);

        //update user data and rebalance the rate
        updateUserStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);
        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);
        return usersReserveData[_user][_reserve].stableBorrowRate;
    }

    /**
    * @dev enables or disables a reserve as collateral
    * @param _reserve the address of the principal reserve where the user deposited
    * @param _user the address of the depositor
    * @param _useAsCollateral true if the depositor wants to use the reserve as collateral
    **/
    function setUserUseReserveAsCollateral(address _reserve, address _user, bool _useAsCollateral)
    public
    onlyLendingPool
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        user.useAsCollateral = _useAsCollateral;
    }

    /**
    * @notice ETH/token transfer functions
    **/

    /**
    * @dev fallback function enforces that the caller is a contract, to support flashloan transfers
    **/
    function() external payable {
        //only contracts can send ETH to the core
        require(msg.sender.isContract(), "Only contracts can send ether to the Lending pool core");

    }

    /**
    * @dev transfers to the user a specific amount from the reserve.
    * @param _reserve the address of the reserve where the transfer is happening
    * @param _user the address of the user receiving the transfer
    * @param _amount the amount being transferred
    **/
    function transferToUser(address _reserve, address payable _user, uint256 _amount)
    external
    onlyLendingPool
    {
        if (_reserve != EthAddressLib.ethAddress()) {
            ERC20(_reserve).safeTransfer(_user, _amount);
        } else {
            //solium-disable-next-line
            (bool result, ) = _user.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers the protocol fees to the fees collection address
    * @param _token the address of the token being transferred
    * @param _user the address of the user from where the transfer is happening
    * @param _amount the amount being transferred
    * @param _destination the fee receiver address
    **/

    function transferToFeeCollectionAddress(
        address _token,
        address _user,
        uint256 _amount,
        address _destination
    ) external payable onlyLendingPool {
        address payable feeAddress = address(uint160(_destination)); //cast the address to payable

        if (_token != EthAddressLib.ethAddress()) {
            require(
                msg.value == 0,
                "User is sending ETH along with the ERC20 transfer. Check the value attribute of the transaction"
            );
            ERC20(_token).safeTransferFrom(_user, feeAddress, _amount);
        } else {
            require(msg.value >= _amount, "The amount and the value sent to deposit do not match");
            //solium-disable-next-line
            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers the fees to the fees collection address in the case of liquidation
    * @param _token the address of the token being transferred
    * @param _amount the amount being transferred
    * @param _destination the fee receiver address
    **/
    function liquidateFee(
        address _token,
        uint256 _amount,
        address _destination
    ) external payable onlyLendingPool {
        address payable feeAddress = address(uint160(_destination)); //cast the address to payable
        require(
            msg.value == 0,
            "Fee liquidation does not require any transfer of value"
        );

        if (_token != EthAddressLib.ethAddress()) {
            ERC20(_token).safeTransfer(feeAddress, _amount);
        } else {
            //solium-disable-next-line
            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers an amount from a user to the destination reserve
    * @param _reserve the address of the reserve where the amount is being transferred
    * @param _user the address of the user from where the transfer is happening
    * @param _amount the amount being transferred
    **/
    function transferToReserve(address _reserve, address payable _user, uint256 _amount)
    external
    payable
    onlyLendingPool
    {
        if (_reserve != EthAddressLib.ethAddress()) {
            require(msg.value == 0, "User is sending ETH along with the ERC20 transfer.");
            ERC20(_reserve).safeTransferFrom(_user, address(this), _amount);

        } else {
            require(msg.value >= _amount, "The amount and the value sent to deposit do not match");

            if (msg.value > _amount) {
                //send back excess ETH
                uint256 excessAmount = msg.value.sub(_amount);
                //solium-disable-next-line
                (bool result, ) = _user.call.value(excessAmount).gas(50000)("");
                require(result, "Transfer of ETH failed");
            }
        }
    }

    /**
    * @notice data access functions
    **/

    /**
    * @dev returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral)
    * needed to calculate the global account data in the LendingPoolDataProvider
    * @param _reserve the address of the reserve
    * @param _user the address of the user
    * @return the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not
    **/
    function getUserBasicReserveData(address _reserve, address _user)
    external
    view
    returns (uint256, uint256, uint256, bool)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        uint256 underlyingBalance = getUserUnderlyingAssetBalance(_reserve, _user);

        if (user.principalBorrowBalance == 0) {
            return (underlyingBalance, 0, 0, user.useAsCollateral);
        }

        return (
        underlyingBalance,
        user.getCompoundedBorrowBalance(reserve),
        user.originationFee,
        user.useAsCollateral
        );
    }

    /**
    * @dev checks if a user is allowed to borrow at a stable rate
    * @param _reserve the reserve address
    * @param _user the user
    * @param _amount the amount the the user wants to borrow
    * @return true if the user is allowed to borrow at a stable rate, false otherwise
    **/

    function isUserAllowedToBorrowAtStable(address _reserve, address _user, uint256 _amount)
    external
    view
    returns (bool)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (!reserve.isStableBorrowRateEnabled) return false;

        return
        !user.useAsCollateral ||
        !reserve.usageAsCollateralEnabled ||
        _amount > getUserUnderlyingAssetBalance(_reserve, _user);
    }

    /**
    * @dev gets the underlying asset balance of a user based on the corresponding aToken balance.
    * @param _reserve the reserve address
    * @param _user the user address
    * @return the underlying deposit balance of the user
    **/

    function getUserUnderlyingAssetBalance(address _reserve, address _user)
    public
    view
    returns (uint256)
    {
        AToken aToken = AToken(reserves[_reserve].aTokenAddress);
        return aToken.balanceOf(_user);

    }

    /**
    * @dev gets the interest rate strategy contract address for the reserve
    * @param _reserve the reserve address
    * @return the address of the interest rate strategy contract
    **/
    function getReserveInterestRateStrategyAddress(address _reserve) public view returns (address) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.interestRateStrategyAddress;
    }

    /**
    * @dev gets the aToken contract address for the reserve
    * @param _reserve the reserve address
    * @return the address of the aToken contract
    **/

    function getReserveATokenAddress(address _reserve) public view returns (address) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.aTokenAddress;
    }

    /**
    * @dev gets the available liquidity in the reserve. The available liquidity is the balance of the core contract
    * @param _reserve the reserve address
    * @return the available liquidity
    **/
    function getReserveAvailableLiquidity(address _reserve) public view returns (uint256) {
        uint256 balance = 0;

        if (_reserve == EthAddressLib.ethAddress()) {
            balance = address(this).balance;
        } else {
            balance = IERC20(_reserve).balanceOf(address(this));
        }
        return balance;
    }

    /**
    * @dev gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows
    * @param _reserve the reserve address
    * @return the total liquidity
    **/
    function getReserveTotalLiquidity(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return getReserveAvailableLiquidity(_reserve).add(reserve.getTotalBorrows());
    }

    /**
    * @dev gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there
    * there has been 100% income.
    * @param _reserve the reserve address
    * @return the reserve normalized income
    **/
    function getReserveNormalizedIncome(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.getNormalizedIncome();
    }

    /**
    * @dev gets the reserve total borrows
    * @param _reserve the reserve address
    * @return the total borrows (stable + variable)
    **/
    function getReserveTotalBorrows(address _reserve) public view returns (uint256) {
        return reserves[_reserve].getTotalBorrows();
    }

    /**
    * @dev gets the reserve total borrows stable
    * @param _reserve the reserve address
    * @return the total borrows stable
    **/
    function getReserveTotalBorrowsStable(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.totalBorrowsStable;
    }

    /**
    * @dev gets the reserve total borrows variable
    * @param _reserve the reserve address
    * @return the total borrows variable
    **/

    function getReserveTotalBorrowsVariable(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.totalBorrowsVariable;
    }

    /**
    * @dev gets the reserve liquidation threshold
    * @param _reserve the reserve address
    * @return the reserve liquidation threshold
    **/

    function getReserveLiquidationThreshold(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.liquidationThreshold;
    }

    /**
    * @dev gets the reserve liquidation bonus
    * @param _reserve the reserve address
    * @return the reserve liquidation bonus
    **/

    function getReserveLiquidationBonus(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.liquidationBonus;
    }

    /**
    * @dev gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty
    * @param _reserve the reserve address
    * @return the reserve current variable borrow rate
    **/

    function getReserveCurrentVariableBorrowRate(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        if (reserve.currentVariableBorrowRate == 0) {
            return
            IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)
            .getBaseVariableBorrowRate();
        }
        return reserve.currentVariableBorrowRate;
    }

    /**
    * @dev gets the reserve current stable borrow rate. Is the market rate if the reserve is empty
    * @param _reserve the reserve address
    * @return the reserve current stable borrow rate
    **/

    function getReserveCurrentStableBorrowRate(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        ILendingRateOracle oracle = ILendingRateOracle(addressesProvider.getLendingRateOracle());

        if (reserve.currentStableBorrowRate == 0) {
            //no stable rate borrows yet
            return oracle.getMarketBorrowRate(_reserve);
        }

        return reserve.currentStableBorrowRate;
    }

    /**
    * @dev gets the reserve average stable borrow rate. The average stable rate is the weighted average
    * of all the loans taken at stable rate.
    * @param _reserve the reserve address
    * @return the reserve current average borrow rate
    **/
    function getReserveCurrentAverageStableBorrowRate(address _reserve)
    external
    view
    returns (uint256)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.currentAverageStableBorrowRate;
    }

    /**
    * @dev gets the reserve liquidity rate
    * @param _reserve the reserve address
    * @return the reserve liquidity rate
    **/
    function getReserveCurrentLiquidityRate(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.currentLiquidityRate;
    }

    /**
    * @dev gets the reserve liquidity cumulative index
    * @param _reserve the reserve address
    * @return the reserve liquidity cumulative index
    **/
    function getReserveLiquidityCumulativeIndex(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.lastLiquidityCumulativeIndex;
    }

    /**
    * @dev gets the reserve variable borrow index
    * @param _reserve the reserve address
    * @return the reserve variable borrow index
    **/
    function getReserveVariableBorrowsCumulativeIndex(address _reserve)
    external
    view
    returns (uint256)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.lastVariableBorrowCumulativeIndex;
    }

    /**
    * @dev this function aggregates the configuration parameters of the reserve.
    * It's used in the LendingPoolDataProvider specifically to save gas, and avoid
    * multiple external contract calls to fetch the same data.
    * @param _reserve the reserve address
    * @return the reserve decimals
    * @return the base ltv as collateral
    * @return the liquidation threshold
    * @return if the reserve is used as collateral or not
    **/
    function getReserveConfiguration(address _reserve)
    external
    view
    returns (uint256, uint256, uint256, bool)
    {
        uint256 decimals;
        uint256 baseLTVasCollateral;
        uint256 liquidationThreshold;
        bool usageAsCollateralEnabled;

        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        decimals = reserve.decimals;
        baseLTVasCollateral = reserve.baseLTVasCollateral;
        liquidationThreshold = reserve.liquidationThreshold;
        usageAsCollateralEnabled = reserve.usageAsCollateralEnabled;

        return (decimals, baseLTVasCollateral, liquidationThreshold, usageAsCollateralEnabled);
    }

    /**
    * @dev returns the decimals of the reserve
    * @param _reserve the reserve address
    * @return the reserve decimals
    **/
    function getReserveDecimals(address _reserve) external view returns (uint256) {
        return reserves[_reserve].decimals;
    }

    /**
    * @dev returns true if the reserve is enabled for borrowing
    * @param _reserve the reserve address
    * @return true if the reserve is enabled for borrowing, false otherwise
    **/

    function isReserveBorrowingEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.borrowingEnabled;
    }

    /**
    * @dev returns true if the reserve is enabled as collateral
    * @param _reserve the reserve address
    * @return true if the reserve is enabled as collateral, false otherwise
    **/

    function isReserveUsageAsCollateralEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.usageAsCollateralEnabled;
    }

    /**
    * @dev returns true if the stable rate is enabled on reserve
    * @param _reserve the reserve address
    * @return true if the stable rate is enabled on reserve, false otherwise
    **/
    function getReserveIsStableBorrowRateEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isStableBorrowRateEnabled;
    }

    /**
    * @dev returns true if the reserve is active
    * @param _reserve the reserve address
    * @return true if the reserve is active, false otherwise
    **/
    function getReserveIsActive(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isActive;
    }

    /**
    * @notice returns if a reserve is freezed
    * @param _reserve the reserve for which the information is needed
    * @return true if the reserve is freezed, false otherwise
    **/

    function getReserveIsFreezed(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isFreezed;
    }

    /**
    * @notice returns the timestamp of the last action on the reserve
    * @param _reserve the reserve for which the information is needed
    * @return the last updated timestamp of the reserve
    **/

    function getReserveLastUpdate(address _reserve) external view returns (uint40 timestamp) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        timestamp = reserve.lastUpdateTimestamp;
    }

    /**
    * @dev returns the utilization rate U of a specific reserve
    * @param _reserve the reserve for which the information is needed
    * @return the utilization rate in ray
    **/

    function getReserveUtilizationRate(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        uint256 totalBorrows = reserve.getTotalBorrows();

        if (totalBorrows == 0) {
            return 0;
        }

        uint256 availableLiquidity = getReserveAvailableLiquidity(_reserve);

        return totalBorrows.rayDiv(availableLiquidity.add(totalBorrows));
    }

    /**
    * @return the array of reserves configured on the core
    **/
    function getReserves() external view returns (address[] memory) {
        return reservesList;
    }

    /**
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return true if the user has chosen to use the reserve as collateral, false otherwise
    **/
    function isUserUseReserveAsCollateralEnabled(address _reserve, address _user)
    external
    view
    returns (bool)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.useAsCollateral;
    }

    /**
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the origination fee for the user
    **/
    function getUserOriginationFee(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.originationFee;
    }

    /**
    * @dev users with no loans in progress have NONE as borrow rate mode
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the borrow rate mode for the user,
    **/

    function getUserCurrentBorrowRateMode(address _reserve, address _user)
    public
    view
    returns (CoreLibrary.InterestRateMode)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (user.principalBorrowBalance == 0) {
            return CoreLibrary.InterestRateMode.NONE;
        }

        return
        user.stableBorrowRate > 0
        ? CoreLibrary.InterestRateMode.STABLE
        : CoreLibrary.InterestRateMode.VARIABLE;
    }

    /**
    * @dev gets the current borrow rate of the user
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the borrow rate for the user,
    **/
    function getUserCurrentBorrowRate(address _reserve, address _user)
    internal
    view
    returns (uint256)
    {
        CoreLibrary.InterestRateMode rateMode = getUserCurrentBorrowRateMode(_reserve, _user);

        if (rateMode == CoreLibrary.InterestRateMode.NONE) {
            return 0;
        }

        return
        rateMode == CoreLibrary.InterestRateMode.STABLE
        ? usersReserveData[_user][_reserve].stableBorrowRate
        : reserves[_reserve].currentVariableBorrowRate;
    }

    /**
    * @dev the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the user stable rate
    **/
    function getUserCurrentStableBorrowRate(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.stableBorrowRate;
    }

    /**
    * @dev calculates and returns the borrow balances of the user
    * @param _reserve the address of the reserve
    * @param _user the address of the user
    * @return the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance
    **/

    function getUserBorrowBalances(address _reserve, address _user)
    public
    view
    returns (uint256, uint256, uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        if (user.principalBorrowBalance == 0) {
            return (0, 0, 0);
        }

        uint256 principal = user.principalBorrowBalance;
        uint256 compoundedBalance = CoreLibrary.getCompoundedBorrowBalance(
            user,
            reserves[_reserve]
        );
        return (principal, compoundedBalance, compoundedBalance.sub(principal));
    }

    /**
    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the variable borrow index for the user
    **/

    function getUserVariableBorrowCumulativeIndex(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.lastVariableBorrowCumulativeIndex;
    }

    /**
    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the variable borrow index for the user
    **/

    function getUserLastUpdate(address _reserve, address _user)
    external
    view
    returns (uint256 timestamp)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        timestamp = user.lastUpdateTimestamp;
    }

    /**
    * @dev updates the lending pool core configuration
    **/
    function refreshConfiguration() external onlyLendingPoolConfigurator {
        refreshConfigInternal();
    }

    /**
    * @dev initializes a reserve
    * @param _reserve the address of the reserve
    * @param _aTokenAddress the address of the overlying aToken contract
    * @param _decimals the decimals of the reserve currency
    * @param _interestRateStrategyAddress the address of the interest rate strategy contract
    **/
    function initReserve(
        address _reserve,
        address _aTokenAddress,
        uint256 _decimals,
        address _interestRateStrategyAddress
    ) external onlyLendingPoolConfigurator {
        reserves[_reserve].init(_aTokenAddress, _decimals, _interestRateStrategyAddress);
        addReserveToListInternal(_reserve);

    }



    /**
    * @dev removes the last added reserve in the reservesList array
    * @param _reserveToRemove the address of the reserve
    **/
    function removeLastAddedReserve(address _reserveToRemove)
    external onlyLendingPoolConfigurator {

        address lastReserve = reservesList[reservesList.length-1];

        require(lastReserve == _reserveToRemove, "Reserve being removed is different than the reserve requested");

        //as we can't check if totalLiquidity is 0 (since the reserve added might not be an ERC20) we at least check that there is nothing borrowed
        require(getReserveTotalBorrows(lastReserve) == 0, "Cannot remove a reserve with liquidity deposited");

        reserves[lastReserve].isActive = false;
        reserves[lastReserve].aTokenAddress = address(0);
        reserves[lastReserve].decimals = 0;
        reserves[lastReserve].lastLiquidityCumulativeIndex = 0;
        reserves[lastReserve].lastVariableBorrowCumulativeIndex = 0;
        reserves[lastReserve].borrowingEnabled = false;
        reserves[lastReserve].usageAsCollateralEnabled = false;
        reserves[lastReserve].baseLTVasCollateral = 0;
        reserves[lastReserve].liquidationThreshold = 0;
        reserves[lastReserve].liquidationBonus = 0;
        reserves[lastReserve].interestRateStrategyAddress = address(0);

        reservesList.pop();
    }

    /**
    * @dev updates the address of the interest rate strategy contract
    * @param _reserve the address of the reserve
    * @param _rateStrategyAddress the address of the interest rate strategy contract
    **/

    function setReserveInterestRateStrategyAddress(address _reserve, address _rateStrategyAddress)
    external
    onlyLendingPoolConfigurator
    {
        reserves[_reserve].interestRateStrategyAddress = _rateStrategyAddress;
    }

    /**
    * @dev enables borrowing on a reserve. Also sets the stable rate borrowing
    * @param _reserve the address of the reserve
    * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise
    **/

    function enableBorrowingOnReserve(address _reserve, bool _stableBorrowRateEnabled)
    external
    onlyLendingPoolConfigurator
    {
        reserves[_reserve].enableBorrowing(_stableBorrowRateEnabled);
    }

    /**
    * @dev disables borrowing on a reserve
    * @param _reserve the address of the reserve
    **/

    function disableBorrowingOnReserve(address _reserve) external onlyLendingPoolConfigurator {
        reserves[_reserve].disableBorrowing();
    }

    /**
    * @dev enables a reserve to be used as collateral
    * @param _reserve the address of the reserve
    **/
    function enableReserveAsCollateral(
        address _reserve,
        uint256 _baseLTVasCollateral,
        uint256 _liquidationThreshold,
        uint256 _liquidationBonus
    ) external onlyLendingPoolConfigurator {
        reserves[_reserve].enableAsCollateral(
            _baseLTVasCollateral,
            _liquidationThreshold,
            _liquidationBonus
        );
    }

    /**
    * @dev disables a reserve to be used as collateral
    * @param _reserve the address of the reserve
    **/
    function disableReserveAsCollateral(address _reserve) external onlyLendingPoolConfigurator {
        reserves[_reserve].disableAsCollateral();
    }

    /**
    * @dev enable the stable borrow rate mode on a reserve
    * @param _reserve the address of the reserve
    **/
    function enableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isStableBorrowRateEnabled = true;
    }

    /**
    * @dev disable the stable borrow rate mode on a reserve
    * @param _reserve the address of the reserve
    **/
    function disableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isStableBorrowRateEnabled = false;
    }

    /**
    * @dev activates a reserve
    * @param _reserve the address of the reserve
    **/
    function activateReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        require(
            reserve.lastLiquidityCumulativeIndex > 0 &&
            reserve.lastVariableBorrowCumulativeIndex > 0,
            "Reserve has not been initialized yet"
        );
        reserve.isActive = true;
    }

    /**
    * @dev deactivates a reserve
    * @param _reserve the address of the reserve
    **/
    function deactivateReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isActive = false;
    }

    /**
    * @notice allows the configurator to freeze the reserve.
    * A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance.
    * @param _reserve the address of the reserve
    **/
    function freezeReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isFreezed = true;
    }

    /**
    * @notice allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed.
    * @param _reserve the address of the reserve
    **/
    function unfreezeReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isFreezed = false;
    }

    /**
    * @notice allows the configurator to update the loan to value of a reserve
    * @param _reserve the address of the reserve
    * @param _ltv the new loan to value
    **/
    function setReserveBaseLTVasCollateral(address _reserve, uint256 _ltv)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.baseLTVasCollateral = _ltv;
    }

    /**
    * @notice allows the configurator to update the liquidation threshold of a reserve
    * @param _reserve the address of the reserve
    * @param _threshold the new liquidation threshold
    **/
    function setReserveLiquidationThreshold(address _reserve, uint256 _threshold)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.liquidationThreshold = _threshold;
    }

    /**
    * @notice allows the configurator to update the liquidation bonus of a reserve
    * @param _reserve the address of the reserve
    * @param _bonus the new liquidation bonus
    **/
    function setReserveLiquidationBonus(address _reserve, uint256 _bonus)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.liquidationBonus = _bonus;
    }

    /**
    * @notice allows the configurator to update the reserve decimals
    * @param _reserve the address of the reserve
    * @param _decimals the decimals of the reserve
    **/
    function setReserveDecimals(address _reserve, uint256 _decimals)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.decimals = _decimals;
    }

    /**
    * @notice internal functions
    **/

    /**
    * @dev updates the state of a reserve as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the previous borrow balance of the borrower before the action
    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount
    * @param _amountBorrowed the new amount borrowed
    * @param _rateMode the borrow rate mode (stable, variable)
    **/

    function updateReserveStateOnBorrowInternal(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _balanceIncrease,
        uint256 _amountBorrowed,
        CoreLibrary.InterestRateMode _rateMode
    ) internal {
        reserves[_reserve].updateCumulativeIndexes();

        //increasing reserve total borrows to account for the new borrow balance of the user
        //NOTE: Depending on the previous borrow mode, the borrows might need to be switched from variable to stable or vice versa

        updateReserveTotalBorrowsByRateModeInternal(
            _reserve,
            _user,
            _principalBorrowBalance,
            _balanceIncrease,
            _amountBorrowed,
            _rateMode
        );
    }

    /**
    * @dev updates the state of a user as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _amountBorrowed the amount borrowed
    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount
    * @param _rateMode the borrow rate mode (stable, variable)
    * @return the final borrow rate for the user. Emitted by the borrow() event
    **/

    function updateUserStateOnBorrowInternal(
        address _reserve,
        address _user,
        uint256 _amountBorrowed,
        uint256 _balanceIncrease,
        uint256 _fee,
        CoreLibrary.InterestRateMode _rateMode
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (_rateMode == CoreLibrary.InterestRateMode.STABLE) {
            //stable
            //reset the user variable index, and update the stable rate
            user.stableBorrowRate = reserve.currentStableBorrowRate;
            user.lastVariableBorrowCumulativeIndex = 0;
        } else if (_rateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //variable
            //reset the user stable rate, and store the new borrow index
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        } else {
            revert("Invalid borrow rate mode");
        }
        //increase the principal borrows and the origination fee
        user.principalBorrowBalance = user.principalBorrowBalance.add(_amountBorrowed).add(
            _balanceIncrease
        );
        user.originationFee = user.originationFee.add(_fee);

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

    }

    /**
    * @dev updates the state of the reserve as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateReserveStateOnRepayInternal(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_reserve][_user];

        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(_reserve, _user);

        //update the indexes
        reserves[_reserve].updateCumulativeIndexes();

        //compound the cumulated interest to the borrow balance and then subtracting the payback amount
        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _balanceIncrease,
                user.stableBorrowRate
            );
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _paybackAmountMinusFees,
                user.stableBorrowRate
            );
        } else {
            reserve.increaseTotalBorrowsVariable(_balanceIncrease);
            reserve.decreaseTotalBorrowsVariable(_paybackAmountMinusFees);
        }
    }

    /**
    * @dev updates the state of the user as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _originationFeeRepaid the fee on the amount that is being repaid
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _repaidWholeLoan true if the user is repaying the whole loan
    **/
    function updateUserStateOnRepayInternal(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _originationFeeRepaid,
        uint256 _balanceIncrease,
        bool _repaidWholeLoan
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        //update the user principal borrow balance, adding the cumulated interest and then subtracting the payback amount
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(
            _paybackAmountMinusFees
        );
        user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;

        //if the balance decrease is equal to the previous principal (user is repaying the whole loan)
        //and the rate mode is stable, we reset the interest rate mode of the user
        if (_repaidWholeLoan) {
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = 0;
        }
        user.originationFee = user.originationFee.sub(_originationFeeRepaid);

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

    }

    /**
    * @dev updates the state of the user as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is performing the rate swap
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the the principal amount borrowed by the user
    * @param _compoundedBorrowBalance the principal amount plus the accrued interest
    * @param _currentRateMode the rate mode at which the user borrowed
    **/
    function updateReserveStateOnSwapRateInternal(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _compoundedBorrowBalance,
        CoreLibrary.InterestRateMode _currentRateMode
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        //compounding reserve indexes
        reserve.updateCumulativeIndexes();

        if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {
            uint256 userCurrentStableRate = user.stableBorrowRate;

            //swap to variable
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _principalBorrowBalance,
                userCurrentStableRate
            ); //decreasing stable from old principal balance
            reserve.increaseTotalBorrowsVariable(_compoundedBorrowBalance); //increase variable borrows
        } else if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //swap to stable
            uint256 currentStableRate = reserve.currentStableBorrowRate;
            reserve.decreaseTotalBorrowsVariable(_principalBorrowBalance);
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _compoundedBorrowBalance,
                currentStableRate
            );

        } else {
            revert("Invalid rate mode received");
        }
    }

    /**
    * @dev updates the state of the user as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is performing the swap
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _currentRateMode the current rate mode of the user
    **/

    function updateUserStateOnSwapRateInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease,
        CoreLibrary.InterestRateMode _currentRateMode
    ) internal returns (CoreLibrary.InterestRateMode) {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        CoreLibrary.InterestRateMode newMode = CoreLibrary.InterestRateMode.NONE;

        if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //switch to stable
            newMode = CoreLibrary.InterestRateMode.STABLE;
            user.stableBorrowRate = reserve.currentStableBorrowRate;
            user.lastVariableBorrowCumulativeIndex = 0;
        } else if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {
            newMode = CoreLibrary.InterestRateMode.VARIABLE;
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        } else {
            revert("Invalid interest rate mode received");
        }
        //compounding cumulated interest
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);
        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

        return newMode;
    }

    /**
    * @dev updates the state of the principal reserve as a consequence of a liquidation action.
    * @param _principalReserve the address of the principal reserve that is being repaid
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updatePrincipalReserveStateOnLiquidationInternal(
        address _principalReserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_principalReserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_principalReserve];

        //update principal reserve data
        reserve.updateCumulativeIndexes();

        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(
            _principalReserve,
            _user
        );

        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            //increase the total borrows by the compounded interest
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _balanceIncrease,
                user.stableBorrowRate
            );

            //decrease by the actual amount to liquidate
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _amountToLiquidate,
                user.stableBorrowRate
            );

        } else {
            //increase the total borrows by the compounded interest
            reserve.increaseTotalBorrowsVariable(_balanceIncrease);

            //decrease by the actual amount to liquidate
            reserve.decreaseTotalBorrowsVariable(_amountToLiquidate);
        }

    }

    /**
    * @dev updates the state of the collateral reserve as a consequence of a liquidation action.
    * @param _collateralReserve the address of the collateral reserve that is being liquidated
    **/
    function updateCollateralReserveStateOnLiquidationInternal(
        address _collateralReserve
    ) internal {
        //update collateral reserve
        reserves[_collateralReserve].updateCumulativeIndexes();

    }

    /**
    * @dev updates the state of the user being liquidated as a consequence of a liquidation action.
    * @param _reserve the address of the principal reserve that is being repaid
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _feeLiquidated the amount of origination fee being liquidated
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/
    function updateUserStateOnLiquidationInternal(
        address _reserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _feeLiquidated,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        //first increase by the compounded interest, then decrease by the liquidated amount
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(
            _amountToLiquidate
        );

        if (
            getUserCurrentBorrowRateMode(_reserve, _user) == CoreLibrary.InterestRateMode.VARIABLE
        ) {
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        }

        if(_feeLiquidated > 0){
            user.originationFee = user.originationFee.sub(_feeLiquidated);
        }

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);
    }

    /**
    * @dev updates the state of the reserve as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateReserveStateOnRebalanceInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        reserve.updateCumulativeIndexes();

        reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
            _balanceIncrease,
            user.stableBorrowRate
        );

    }

    /**
    * @dev updates the state of the user as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateUserStateOnRebalanceInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);
        user.stableBorrowRate = reserve.currentStableBorrowRate;

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);
    }

    /**
    * @dev updates the state of the user as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _amountBorrowed the accrued interest on the borrowed amount
    **/
    function updateReserveTotalBorrowsByRateModeInternal(
        address _reserve,
        address _user,
        uint256 _principalBalance,
        uint256 _balanceIncrease,
        uint256 _amountBorrowed,
        CoreLibrary.InterestRateMode _newBorrowRateMode
    ) internal {
        CoreLibrary.InterestRateMode previousRateMode = getUserCurrentBorrowRateMode(
            _reserve,
            _user
        );
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        if (previousRateMode == CoreLibrary.InterestRateMode.STABLE) {
            CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _principalBalance,
                user.stableBorrowRate
            );
        } else if (previousRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            reserve.decreaseTotalBorrowsVariable(_principalBalance);
        }

        uint256 newPrincipalAmount = _principalBalance.add(_balanceIncrease).add(_amountBorrowed);
        if (_newBorrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                newPrincipalAmount,
                reserve.currentStableBorrowRate
            );
        } else if (_newBorrowRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            reserve.increaseTotalBorrowsVariable(newPrincipalAmount);
        } else {
            revert("Invalid new borrow rate mode");
        }
    }

    /**
    * @dev Updates the reserve current stable borrow rate Rf, the current variable borrow rate Rv and the current liquidity rate Rl.
    * Also updates the lastUpdateTimestamp value. Please refer to the whitepaper for further information.
    * @param _reserve the address of the reserve to be updated
    * @param _liquidityAdded the amount of liquidity added to the protocol (deposit or repay) in the previous action
    * @param _liquidityTaken the amount of liquidity taken from the protocol (redeem or borrow)
    **/

    function updateReserveInterestRatesAndTimestampInternal(
        address _reserve,
        uint256 _liquidityAdded,
        uint256 _liquidityTaken
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        (uint256 newLiquidityRate, uint256 newStableRate, uint256 newVariableRate) = IReserveInterestRateStrategy(
            reserve
            .interestRateStrategyAddress
        )
        .calculateInterestRates(
            _reserve,
            getReserveAvailableLiquidity(_reserve).add(_liquidityAdded).sub(_liquidityTaken),
            reserve.totalBorrowsStable,
            reserve.totalBorrowsVariable,
            reserve.currentAverageStableBorrowRate
        );

        reserve.currentLiquidityRate = newLiquidityRate;
        reserve.currentStableBorrowRate = newStableRate;
        reserve.currentVariableBorrowRate = newVariableRate;

        //solium-disable-next-line
        reserve.lastUpdateTimestamp = uint40(block.timestamp);

        emit ReserveUpdated(
            _reserve,
            newLiquidityRate,
            newStableRate,
            newVariableRate,
            reserve.lastLiquidityCumulativeIndex,
            reserve.lastVariableBorrowCumulativeIndex
        );
    }

    /**
    * @dev transfers to the protocol fees of a flashloan to the fees collection address
    * @param _token the address of the token being transferred
    * @param _amount the amount being transferred
    **/

    function transferFlashLoanProtocolFeeInternal(address _token, uint256 _amount) internal {
        address payable receiver = address(uint160(addressesProvider.getTokenDistributor()));

        if (_token != EthAddressLib.ethAddress()) {
            ERC20(_token).safeTransfer(receiver, _amount);
        } else {
            receiver.transfer(_amount);
        }
    }

    /**
    * @dev updates the internal configuration of the core
    **/
    function refreshConfigInternal() internal {
        lendingPoolAddress = addressesProvider.getLendingPool();
    }

    /**
    * @dev adds a reserve to the array of the reserves address
    **/
    function addReserveToListInternal(address _reserve) internal {
        bool reserveAlreadyAdded = false;
        for (uint256 i = 0; i < reservesList.length; i++)
            if (reservesList[i] == _reserve) {
                reserveAlreadyAdded = true;
            }
        if (!reserveAlreadyAdded) reservesList.push(_reserve);
    }

}
.]

Here is a conversation between two roles: Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: pragma solidity ^0.5.0;
import "openzeppelin-solidity/contracts/math/SafeMath.sol";
import "openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol";
import "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol";
import "openzeppelin-solidity/contracts/utils/Address.sol";
import "../libraries/openzeppelin-upgradeability/VersionedInitializable.sol";
import "../libraries/CoreLibrary.sol";
import "../configuration/LendingPoolAddressesProvider.sol";
import "../interfaces/ILendingRateOracle.sol";
import "../interfaces/IReserveInterestRateStrategy.sol";
import "../libraries/WadRayMath.sol";
import "../tokenization/AToken.sol";
import "../libraries/EthAddressLib.sol";
/**
* @title LendingPoolCore contract
* @author Aave
* @notice Holds the state of the lending pool and all the funds deposited
* @dev NOTE: The core does not enforce security checks on the update of the state
* (eg, updateStateOnBorrow() does not enforce that borrowed is enabled on the reserve).
* The check that an action can be performed is a duty of the overlying LendingPool contract.
**/
contract LendingPoolCore is VersionedInitializable {
    using SafeMath for uint256;
    using WadRayMath for uint256;
    using CoreLibrary for CoreLibrary.ReserveData;
    using CoreLibrary for CoreLibrary.UserReserveData;
    using SafeERC20 for ERC20;
    using Address for address payable;
    /**
    * @dev Emitted when the state of a reserve is updated
    * @param reserve the address of the reserve
    * @param liquidityRate the new liquidity rate
    * @param stableBorrowRate the new stable borrow rate
    * @param variableBorrowRate the new variable borrow rate
    * @param liquidityIndex the new liquidity index
    * @param variableBorrowIndex the new variable borrow index
    **/
    event ReserveUpdated(
        address indexed reserve,
        uint256 liquidityRate,
        uint256 stableBorrowRate,
        uint256 variableBorrowRate,
        uint256 liquidityIndex,
        uint256 variableBorrowIndex
    );
    address public lendingPoolAddress;
    LendingPoolAddressesProvider public addressesProvider;
    /**
    * @dev only lending pools can use functions affected by this modifier
    **/
    modifier onlyLendingPool {
        require(lendingPoolAddress == msg.sender, "The caller must be a lending pool contract");
        _;
    }
    /**
    * @dev only lending pools configurator can use functions affected by this modifier
    **/
    modifier onlyLendingPoolConfigurator {
        require(
            addressesProvider.getLendingPoolConfigurator() == msg.sender,
            "The caller must be a lending pool configurator contract"
        );
        _;
    }
    mapping(address => CoreLibrary.ReserveData) internal reserves;
    mapping(address => mapping(address => CoreLibrary.UserReserveData)) internal usersReserveData;
    address[] public reservesList;
    uint256 public constant CORE_REVISION = 0x4;
    /**
    * @dev returns the revision number of the contract
    **/
    function getRevision() internal pure returns (uint256) {
        return CORE_REVISION;
    }
    /**
    * @dev initializes the Core contract, invoked upon registration on the AddressesProvider
    * @param _addressesProvider the addressesProvider contract
    **/
    function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {
        addressesProvider = _addressesProvider;
        refreshConfigInternal();
    }
    /**
    * @dev updates the state of the core as a result of a deposit action
    * @param _reserve the address of the reserve in which the deposit is happening
    * @param _user the address of the the user depositing
    * @param _amount the amount being deposited
    * @param _isFirstDeposit true if the user is depositing for the first time
    **/
    function updateStateOnDeposit(
        address _reserve,
        address _user,
        uint256 _amount,
        bool _isFirstDeposit
    ) external onlyLendingPool {
        reserves[_reserve].updateCumulativeIndexes();
        updateReserveInterestRatesAndTimestampInternal(_reserve, _amount, 0);
        if (_isFirstDeposit) {
            //if this is the first deposit of the user, we configure the deposit as enabled to be used as collateral
            setUserUseReserveAsCollateral(_reserve, _user, true);
        }
    }
    /**
    * @dev updates the state of the core as a result of a redeem action
    * @param _reserve the address of the reserve in which the redeem is happening
    * @param _user the address of the the user redeeming
    * @param _amountRedeemed the amount being redeemed
    * @param _userRedeemedEverything true if the user is redeeming everything
    **/
    function updateStateOnRedeem(
        address _reserve,
        address _user,
        uint256 _amountRedeemed,
        bool _userRedeemedEverything
    ) external onlyLendingPool {
        //compound liquidity and variable borrow interests
        reserves[_reserve].updateCumulativeIndexes();
        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountRedeemed);
        //if user redeemed everything the useReserveAsCollateral flag is reset
        if (_userRedeemedEverything) {
            setUserUseReserveAsCollateral(_reserve, _user, false);
        }
    }
    /**
    * @dev updates the state of the core as a result of a flashloan action
    * @param _reserve the address of the reserve in which the flashloan is happening
    * @param _income the income of the protocol as a result of the action
    **/
    function updateStateOnFlashLoan(
        address _reserve,
        uint256 _availableLiquidityBefore,
        uint256 _income,
        uint256 _protocolFee
    ) external onlyLendingPool {
        transferFlashLoanProtocolFeeInternal(_reserve, _protocolFee);
        //compounding the cumulated interest
        reserves[_reserve].updateCumulativeIndexes();
        uint256 totalLiquidityBefore = _availableLiquidityBefore.add(
            getReserveTotalBorrows(_reserve)
        );
        //compounding the received fee into the reserve
        reserves[_reserve].cumulateToLiquidityIndex(totalLiquidityBefore, _income);
        //refresh interest rates
        updateReserveInterestRatesAndTimestampInternal(_reserve, _income, 0);
    }
    /**
    * @dev updates the state of the core as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _amountBorrowed the new amount borrowed
    * @param _borrowFee the fee on the amount borrowed
    * @param _rateMode the borrow rate mode (stable, variable)
    * @return the new borrow rate for the user
    **/
    function updateStateOnBorrow(
        address _reserve,
        address _user,
        uint256 _amountBorrowed,
        uint256 _borrowFee,
        CoreLibrary.InterestRateMode _rateMode
    ) external onlyLendingPool returns (uint256, uint256) {
        // getting the previous borrow data of the user
        (uint256 principalBorrowBalance, , uint256 balanceIncrease) = getUserBorrowBalances(
            _reserve,
            _user
        );
        updateReserveStateOnBorrowInternal(
            _reserve,
            _user,
            principalBorrowBalance,
            balanceIncrease,
            _amountBorrowed,
            _rateMode
        );
        updateUserStateOnBorrowInternal(
            _reserve,
            _user,
            _amountBorrowed,
            balanceIncrease,
            _borrowFee,
            _rateMode
        );
        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountBorrowed);
        return (getUserCurrentBorrowRate(_reserve, _user), balanceIncrease);
    }
    /**
    * @dev updates the state of the core as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _originationFeeRepaid the fee on the amount that is being repaid
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _repaidWholeLoan true if the user is repaying the whole loan
    **/
    function updateStateOnRepay(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _originationFeeRepaid,
        uint256 _balanceIncrease,
        bool _repaidWholeLoan
    ) external onlyLendingPool {
        updateReserveStateOnRepayInternal(
            _reserve,
            _user,
            _paybackAmountMinusFees,
            _balanceIncrease
        );
        updateUserStateOnRepayInternal(
            _reserve,
            _user,
            _paybackAmountMinusFees,
            _originationFeeRepaid,
            _balanceIncrease,
            _repaidWholeLoan
        );
        updateReserveInterestRatesAndTimestampInternal(_reserve, _paybackAmountMinusFees, 0);
    }
    /**
    * @dev updates the state of the core as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the amount borrowed by the user
    * @param _compoundedBorrowBalance the amount borrowed plus accrued interest
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _currentRateMode the current interest rate mode for the user
    **/
    function updateStateOnSwapRate(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _compoundedBorrowBalance,
        uint256 _balanceIncrease,
        CoreLibrary.InterestRateMode _currentRateMode
    ) external onlyLendingPool returns (CoreLibrary.InterestRateMode, uint256) {
        updateReserveStateOnSwapRateInternal(
            _reserve,
            _user,
            _principalBorrowBalance,
            _compoundedBorrowBalance,
            _currentRateMode
        );
        CoreLibrary.InterestRateMode newRateMode = updateUserStateOnSwapRateInternal(
            _reserve,
            _user,
            _balanceIncrease,
            _currentRateMode
        );
        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);
        return (newRateMode, getUserCurrentBorrowRate(_reserve, _user));
    }
    /**
    * @dev updates the state of the core as a consequence of a liquidation action.
    * @param _principalReserve the address of the principal reserve that is being repaid
    * @param _collateralReserve the address of the collateral reserve that is being liquidated
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _collateralToLiquidate the amount of collateral being liquidated
    * @param _feeLiquidated the amount of origination fee being liquidated
    * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise
    **/
    function updateStateOnLiquidation(
        address _principalReserve,
        address _collateralReserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _collateralToLiquidate,
        uint256 _feeLiquidated,
        uint256 _liquidatedCollateralForFee,
        uint256 _balanceIncrease,
        bool _liquidatorReceivesAToken
    ) external onlyLendingPool {
        updatePrincipalReserveStateOnLiquidationInternal(
            _principalReserve,
            _user,
            _amountToLiquidate,
            _balanceIncrease
        );
        updateCollateralReserveStateOnLiquidationInternal(
            _collateralReserve
        );
        updateUserStateOnLiquidationInternal(
            _principalReserve,
            _user,
            _amountToLiquidate,
            _feeLiquidated,
            _balanceIncrease
        );
        updateReserveInterestRatesAndTimestampInternal(_principalReserve, _amountToLiquidate, 0);
        if (!_liquidatorReceivesAToken) {
            updateReserveInterestRatesAndTimestampInternal(
                _collateralReserve,
                0,
                _collateralToLiquidate.add(_liquidatedCollateralForFee)
            );
        }
    }
    /**
    * @dev updates the state of the core as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @return the new stable rate for the user
    **/
    function updateStateOnRebalance(address _reserve, address _user, uint256 _balanceIncrease)
    external
    onlyLendingPool
    returns (uint256)
    {
        updateReserveStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);
        //update user data and rebalance the rate
        updateUserStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);
        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);
        return usersReserveData[_user][_reserve].stableBorrowRate;
    }
    /**
    * @dev enables or disables a reserve as collateral
    * @param _reserve the address of the principal reserve where the user deposited
    * @param _user the address of the depositor
    * @param _useAsCollateral true if the depositor wants to use the reserve as collateral
    **/
    function setUserUseReserveAsCollateral(address _reserve, address _user, bool _useAsCollateral)
    public
    onlyLendingPool
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        user.useAsCollateral = _useAsCollateral;
    }
    /**
    * @notice ETH/token transfer functions
    **/
    /**
    * @dev fallback function enforces that the caller is a contract, to support flashloan transfers
    **/
    function() external payable {
        //only contracts can send ETH to the core
        require(msg.sender.isContract(), "Only contracts can send ether to the Lending pool core");
    }
    /**
    * @dev transfers to the user a specific amount from the reserve.
    * @param _reserve the address of the reserve where the transfer is happening
    * @param _user the address of the user receiving the transfer
    * @param _amount the amount being transferred
    **/
    function transferToUser(address _reserve, address payable _user, uint256 _amount)
    external
    onlyLendingPool
    {
        if (_reserve != EthAddressLib.ethAddress()) {
            ERC20(_reserve).safeTransfer(_user, _amount);
        } else {
            //solium-disable-next-line
            (bool result, ) = _user.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }
    /**
    * @dev transfers the protocol fees to the fees collection address
    * @param _token the address of the token being transferred
    * @param _user the address of the user from where the transfer is happening
    * @param _amount the amount being transferred
    * @param _destination the fee receiver address
    **/
    function transferToFeeCollectionAddress(
        address _token,
        address _user,
        uint256 _amount,
        address _destination
    ) external payable onlyLendingPool {
        address payable feeAddress = address(uint160(_destination)); //cast the address to payable
        if (_token != EthAddressLib.ethAddress()) {
            require(
                msg.value == 0,
                "User is sending ETH along with the ERC20 transfer. Check the value attribute of the transaction"
            );
            ERC20(_token).safeTransferFrom(_user, feeAddress, _amount);
        } else {
            require(msg.value >= _amount, "The amount and the value sent to deposit do not match");
            //solium-disable-next-line
            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }
    /**
    * @dev transfers the fees to the fees collection address in the case of liquidation
    * @param _token the address of the token being transferred
    * @param _amount the amount being transferred
    * @param _destination the fee receiver address
    **/
    function liquidateFee(
        address _token,
        uint256 _amount,
        address _destination
    ) external payable onlyLendingPool {
        address payable feeAddress = address(uint160(_destination)); //cast the address to payable
        require(
            msg.value == 0,
            "Fee liquidation does not require any transfer of value"
        );
        if (_token != EthAddressLib.ethAddress()) {
            ERC20(_token).safeTransfer(feeAddress, _amount);
        } else {
            //solium-disable-next-line
            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }
    /**
    * @dev transfers an amount from a user to the destination reserve
    * @param _reserve the address of the reserve where the amount is being transferred
    * @param _user the address of the user from where the transfer is happening
    * @param _amount the amount being transferred
    **/
    function transferToReserve(address _reserve, address payable _user, uint256 _amount)
    external
    payable
    onlyLendingPool
    {
        if (_reserve != EthAddressLib.ethAddress()) {
            require(msg.value == 0, "User is sending ETH along with the ERC20 transfer.");
            ERC20(_reserve).safeTransferFrom(_user, address(this), _amount);
        } else {
            require(msg.value >= _amount, "The amount and the value sent to deposit do not match");
            if (msg.value > _amount) {
                //send back excess ETH
                uint256 excessAmount = msg.value.sub(_amount);
                //solium-disable-next-line
                (bool result, ) = _user.call.value(excessAmount).gas(50000)("");
                require(result, "Transfer of ETH failed");
            }
        }
    }
    /**
    * @notice data access functions
    **/
    /**
    * @dev returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral)
    * needed to calculate the global account data in the LendingPoolDataProvider
    * @param _reserve the address of the reserve
    * @param _user the address of the user
    * @return the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not
    **/
    function getUserBasicReserveData(address _reserve, address _user)
    external
    view
    returns (uint256, uint256, uint256, bool)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        uint256 underlyingBalance = getUserUnderlyingAssetBalance(_reserve, _user);
        if (user.principalBorrowBalance == 0) {
            return (underlyingBalance, 0, 0, user.useAsCollateral);
        }
        return (
        underlyingBalance,
        user.getCompoundedBorrowBalance(reserve),
        user.originationFee,
        user.useAsCollateral
        );
    }
    /**
    * @dev checks if a user is allowed to borrow at a stable rate
    * @param _reserve the reserve address
    * @param _user the user
    * @param _amount the amount the the user wants to borrow
    * @return true if the user is allowed to borrow at a stable rate, false otherwise
    **/
    function isUserAllowedToBorrowAtStable(address _reserve, address _user, uint256 _amount)
    external
    view
    returns (bool)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        if (!reserve.isStableBorrowRateEnabled) return false;
        return
        !user.useAsCollateral ||
        !reserve.usageAsCollateralEnabled ||
        _amount > getUserUnderlyingAssetBalance(_reserve, _user);
    }
    /**
    * @dev gets the underlying asset balance of a user based on the corresponding aToken balance.
    * @param _reserve the reserve address
    * @param _user the user address
    * @return the underlying deposit balance of the user
    **/
    function getUserUnderlyingAssetBalance(address _reserve, address _user)
    public
    view
    returns (uint256)
    {
        AToken aToken = AToken(reserves[_reserve].aTokenAddress);
        return aToken.balanceOf(_user);
    }
    /**
    * @dev gets the interest rate strategy contract address for the reserve
    * @param _reserve the reserve address
    * @return the address of the interest rate strategy contract
    **/
    function getReserveInterestRateStrategyAddress(address _reserve) public view returns (address) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.interestRateStrategyAddress;
    }
    /**
    * @dev gets the aToken contract address for the reserve
    * @param _reserve the reserve address
    * @return the address of the aToken contract
    **/
    function getReserveATokenAddress(address _reserve) public view returns (address) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.aTokenAddress;
    }
    /**
    * @dev gets the available liquidity in the reserve. The available liquidity is the balance of the core contract
    * @param _reserve the reserve address
    * @return the available liquidity
    **/
    function getReserveAvailableLiquidity(address _reserve) public view returns (uint256) {
        uint256 balance = 0;
        if (_reserve == EthAddressLib.ethAddress()) {
            balance = address(this).balance;
        } else {
            balance = IERC20(_reserve).balanceOf(address(this));
        }
        return balance;
    }
    /**
    * @dev gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows
    * @param _reserve the reserve address
    * @return the total liquidity
    **/
    function getReserveTotalLiquidity(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return getReserveAvailableLiquidity(_reserve).add(reserve.getTotalBorrows());
    }
    /**
    * @dev gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there
    * there has been 100% income.
    * @param _reserve the reserve address
    * @return the reserve normalized income
    **/
    function getReserveNormalizedIncome(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.getNormalizedIncome();
    }
    /**
    * @dev gets the reserve total borrows
    * @param _reserve the reserve address
    * @return the total borrows (stable + variable)
    **/
    function getReserveTotalBorrows(address _reserve) public view returns (uint256) {
        return reserves[_reserve].getTotalBorrows();
    }
    /**
    * @dev gets the reserve total borrows stable
    * @param _reserve the reserve address
    * @return the total borrows stable
    **/
    function getReserveTotalBorrowsStable(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.totalBorrowsStable;
    }
    /**
    * @dev gets the reserve total borrows variable
    * @param _reserve the reserve address
    * @return the total borrows variable
    **/
    function getReserveTotalBorrowsVariable(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.totalBorrowsVariable;
    }
    /**
    * @dev gets the reserve liquidation threshold
    * @param _reserve the reserve address
    * @return the reserve liquidation threshold
    **/
    function getReserveLiquidationThreshold(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.liquidationThreshold;
    }
    /**
    * @dev gets the reserve liquidation bonus
    * @param _reserve the reserve address
    * @return the reserve liquidation bonus
    **/
    function getReserveLiquidationBonus(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.liquidationBonus;
    }
    /**
    * @dev gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty
    * @param _reserve the reserve address
    * @return the reserve current variable borrow rate
    **/
    function getReserveCurrentVariableBorrowRate(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        if (reserve.currentVariableBorrowRate == 0) {
            return
            IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)
            .getBaseVariableBorrowRate();
        }
        return reserve.currentVariableBorrowRate;
    }
    /**
    * @dev gets the reserve current stable borrow rate. Is the market rate if the reserve is empty
    * @param _reserve the reserve address
    * @return the reserve current stable borrow rate
    **/
    function getReserveCurrentStableBorrowRate(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        ILendingRateOracle oracle = ILendingRateOracle(addressesProvider.getLendingRateOracle());
        if (reserve.currentStableBorrowRate == 0) {
            //no stable rate borrows yet
            return oracle.getMarketBorrowRate(_reserve);
        }
        return reserve.currentStableBorrowRate;
    }
    /**
    * @dev gets the reserve average stable borrow rate. The average stable rate is the weighted average
    * of all the loans taken at stable rate.
    * @param _reserve the reserve address
    * @return the reserve current average borrow rate
    **/
    function getReserveCurrentAverageStableBorrowRate(address _reserve)
    external
    view
    returns (uint256)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.currentAverageStableBorrowRate;
    }
    /**
    * @dev gets the reserve liquidity rate
    * @param _reserve the reserve address
    * @return the reserve liquidity rate
    **/
    function getReserveCurrentLiquidityRate(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.currentLiquidityRate;
    }
    /**
    * @dev gets the reserve liquidity cumulative index
    * @param _reserve the reserve address
    * @return the reserve liquidity cumulative index
    **/
    function getReserveLiquidityCumulativeIndex(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.lastLiquidityCumulativeIndex;
    }
    /**
    * @dev gets the reserve variable borrow index
    * @param _reserve the reserve address
    * @return the reserve variable borrow index
    **/
    function getReserveVariableBorrowsCumulativeIndex(address _reserve)
    external
    view
    returns (uint256)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.lastVariableBorrowCumulativeIndex;
    }
    /**
    * @dev this function aggregates the configuration parameters of the reserve.
    * It's used in the LendingPoolDataProvider specifically to save gas, and avoid
    * multiple external contract calls to fetch the same data.
    * @param _reserve the reserve address
    * @return the reserve decimals
    * @return the base ltv as collateral
    * @return the liquidation threshold
    * @return if the reserve is used as collateral or not
    **/
    function getReserveConfiguration(address _reserve)
    external
    view
    returns (uint256, uint256, uint256, bool)
    {
        uint256 decimals;
        uint256 baseLTVasCollateral;
        uint256 liquidationThreshold;
        bool usageAsCollateralEnabled;
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        decimals = reserve.decimals;
        baseLTVasCollateral = reserve.baseLTVasCollateral;
        liquidationThreshold = reserve.liquidationThreshold;
        usageAsCollateralEnabled = reserve.usageAsCollateralEnabled;
        return (decimals, baseLTVasCollateral, liquidationThreshold, usageAsCollateralEnabled);
    }
    /**
    * @dev returns the decimals of the reserve
    * @param _reserve the reserve address
    * @return the reserve decimals
    **/
    function getReserveDecimals(address _reserve) external view returns (uint256) {
        return reserves[_reserve].decimals;
    }
    /**
    * @dev returns true if the reserve is enabled for borrowing
    * @param _reserve the reserve address
    * @return true if the reserve is enabled for borrowing, false otherwise
    **/
    function isReserveBorrowingEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.borrowingEnabled;
    }
    /**
    * @dev returns true if the reserve is enabled as collateral
    * @param _reserve the reserve address
    * @return true if the reserve is enabled as collateral, false otherwise
    **/
    function isReserveUsageAsCollateralEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.usageAsCollateralEnabled;
    }
    /**
    * @dev returns true if the stable rate is enabled on reserve
    * @param _reserve the reserve address
    * @return true if the stable rate is enabled on reserve, false otherwise
    **/
    function getReserveIsStableBorrowRateEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isStableBorrowRateEnabled;
    }
    /**
    * @dev returns true if the reserve is active
    * @param _reserve the reserve address
    * @return true if the reserve is active, false otherwise
    **/
    function getReserveIsActive(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isActive;
    }
    /**
    * @notice returns if a reserve is freezed
    * @param _reserve the reserve for which the information is needed
    * @return true if the reserve is freezed, false otherwise
    **/
    function getReserveIsFreezed(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isFreezed;
    }
    /**
    * @notice returns the timestamp of the last action on the reserve
    * @param _reserve the reserve for which the information is needed
    * @return the last updated timestamp of the reserve
    **/
    function getReserveLastUpdate(address _reserve) external view returns (uint40 timestamp) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        timestamp = reserve.lastUpdateTimestamp;
    }
    /**
    * @dev returns the utilization rate U of a specific reserve
    * @param _reserve the reserve for which the information is needed
    * @return the utilization rate in ray
    **/
    function getReserveUtilizationRate(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        uint256 totalBorrows = reserve.getTotalBorrows();
        if (totalBorrows == 0) {
            return 0;
        }
        uint256 availableLiquidity = getReserveAvailableLiquidity(_reserve);
        return totalBorrows.rayDiv(availableLiquidity.add(totalBorrows));
    }
    /**
    * @return the array of reserves configured on the core
    **/
    function getReserves() external view returns (address[] memory) {
        return reservesList;
    }
    /**
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return true if the user has chosen to use the reserve as collateral, false otherwise
    **/
    function isUserUseReserveAsCollateralEnabled(address _reserve, address _user)
    external
    view
    returns (bool)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.useAsCollateral;
    }
    /**
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the origination fee for the user
    **/
    function getUserOriginationFee(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.originationFee;
    }
    /**
    * @dev users with no loans in progress have NONE as borrow rate mode
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the borrow rate mode for the user,
    **/
    function getUserCurrentBorrowRateMode(address _reserve, address _user)
    public
    view
    returns (CoreLibrary.InterestRateMode)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        if (user.principalBorrowBalance == 0) {
            return CoreLibrary.InterestRateMode.NONE;
        }
        return
        user.stableBorrowRate > 0
        ? CoreLibrary.InterestRateMode.STABLE
        : CoreLibrary.InterestRateMode.VARIABLE;
    }
    /**
    * @dev gets the current borrow rate of the user
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the borrow rate for the user,
    **/
    function getUserCurrentBorrowRate(address _reserve, address _user)
    internal
    view
    returns (uint256)
    {
        CoreLibrary.InterestRateMode rateMode = getUserCurrentBorrowRateMode(_reserve, _user);
        if (rateMode == CoreLibrary.InterestRateMode.NONE) {
            return 0;
        }
        return
        rateMode == CoreLibrary.InterestRateMode.STABLE
        ? usersReserveData[_user][_reserve].stableBorrowRate
        : reserves[_reserve].currentVariableBorrowRate;
    }
    /**
    * @dev the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the user stable rate
    **/
    function getUserCurrentStableBorrowRate(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.stableBorrowRate;
    }
    /**
    * @dev calculates and returns the borrow balances of the user
    * @param _reserve the address of the reserve
    * @param _user the address of the user
    * @return the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance
    **/
    function getUserBorrowBalances(address _reserve, address _user)
    public
    view
    returns (uint256, uint256, uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        if (user.principalBorrowBalance == 0) {
            return (0, 0, 0);
        }
        uint256 principal = user.principalBorrowBalance;
        uint256 compoundedBalance = CoreLibrary.getCompoundedBorrowBalance(
            user,
            reserves[_reserve]
        );
        return (principal, compoundedBalance, compoundedBalance.sub(principal));
    }
    /**
    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the variable borrow index for the user
    **/
    function getUserVariableBorrowCumulativeIndex(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.lastVariableBorrowCumulativeIndex;
    }
    /**
    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the variable borrow index for the user
    **/
    function getUserLastUpdate(address _reserve, address _user)
    external
    view
    returns (uint256 timestamp)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        timestamp = user.lastUpdateTimestamp;
    }
    /**
    * @dev updates the lending pool core configuration
    **/
    function refreshConfiguration() external onlyLendingPoolConfigurator {
        refreshConfigInternal();
    }
    /**
    * @dev initializes a reserve
    * @param _reserve the address of the reserve
    * @param _aTokenAddress the address of the overlying aToken contract
    * @param _decimals the decimals of the reserve currency
    * @param _interestRateStrategyAddress the address of the interest rate strategy contract
    **/
    function initReserve(
        address _reserve,
        address _aTokenAddress,
        uint256 _decimals,
        address _interestRateStrategyAddress
    ) external onlyLendingPoolConfigurator {
        reserves[_reserve].init(_aTokenAddress, _decimals, _interestRateStrategyAddress);
        addReserveToListInternal(_reserve);
    }

    /**
    * @dev removes the last added reserve in the reservesList array
    * @param _reserveToRemove the address of the reserve
    **/
    function removeLastAddedReserve(address _reserveToRemove)
    external onlyLendingPoolConfigurator {
        address lastReserve = reservesList[reservesList.length-1];
        require(lastReserve == _reserveToRemove, "Reserve being removed is different than the reserve requested");
        //as we can't check if totalLiquidity is 0 (since the reserve added might not be an ERC20) we at least check that there is nothing borrowed
        require(getReserveTotalBorrows(lastReserve) == 0, "Cannot remove a reserve with liquidity deposited");
        reserves[lastReserve].isActive = false;
        reserves[lastReserve].aTokenAddress = address(0);
        reserves[lastReserve].decimals = 0;
        reserves[lastReserve].lastLiquidityCumulativeIndex = 0;
        reserves[lastReserve].lastVariableBorrowCumulativeIndex = 0;
        reserves[lastReserve].borrowingEnabled = false;
        reserves[lastReserve].usageAsCollateralEnabled = false;
        reserves[lastReserve].baseLTVasCollateral = 0;
        reserves[lastReserve].liquidationThreshold = 0;
        reserves[lastReserve].liquidationBonus = 0;
        reserves[lastReserve].interestRateStrategyAddress = address(0);
        reservesList.pop();
    }
    /**
    * @dev updates the address of the interest rate strategy contract
    * @param _reserve the address of the reserve
    * @param _rateStrategyAddress the address of the interest rate strategy contract
    **/
    function setReserveInterestRateStrategyAddress(address _reserve, address _rateStrategyAddress)
    external
    onlyLendingPoolConfigurator
    {
        reserves[_reserve].interestRateStrategyAddress = _rateStrategyAddress;
    }
    /**
    * @dev enables borrowing on a reserve. Also sets the stable rate borrowing
    * @param _reserve the address of the reserve
    * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise
    **/
    function enableBorrowingOnReserve(address _reserve, bool _stableBorrowRateEnabled)
    external
    onlyLendingPoolConfigurator
    {
        reserves[_reserve].enableBorrowing(_stableBorrowRateEnabled);
    }
    /**
    * @dev disables borrowing on a reserve
    * @param _reserve the address of the reserve
    **/
    function disableBorrowingOnReserve(address _reserve) external onlyLendingPoolConfigurator {
        reserves[_reserve].disableBorrowing();
    }
    /**
    * @dev enables a reserve to be used as collateral
    * @param _reserve the address of the reserve
    **/
    function enableReserveAsCollateral(
        address _reserve,
        uint256 _baseLTVasCollateral,
        uint256 _liquidationThreshold,
        uint256 _liquidationBonus
    ) external onlyLendingPoolConfigurator {
        reserves[_reserve].enableAsCollateral(
            _baseLTVasCollateral,
            _liquidationThreshold,
            _liquidationBonus
        );
    }
    /**
    * @dev disables a reserve to be used as collateral
    * @param _reserve the address of the reserve
    **/
    function disableReserveAsCollateral(address _reserve) external onlyLendingPoolConfigurator {
        reserves[_reserve].disableAsCollateral();
    }
    /**
    * @dev enable the stable borrow rate mode on a reserve
    * @param _reserve the address of the reserve
    **/
    function enableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isStableBorrowRateEnabled = true;
    }
    /**
    * @dev disable the stable borrow rate mode on a reserve
    * @param _reserve the address of the reserve
    **/
    function disableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isStableBorrowRateEnabled = false;
    }
    /**
    * @dev activates a reserve
    * @param _reserve the address of the reserve
    **/
    function activateReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        require(
            reserve.lastLiquidityCumulativeIndex > 0 &&
            reserve.lastVariableBorrowCumulativeIndex > 0,
            "Reserve has not been initialized yet"
        );
        reserve.isActive = true;
    }
    /**
    * @dev deactivates a reserve
    * @param _reserve the address of the reserve
    **/
    function deactivateReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isActive = false;
    }
    /**
    * @notice allows the configurator to freeze the reserve.
    * A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance.
    * @param _reserve the address of the reserve
    **/
    function freezeReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isFreezed = true;
    }
    /**
    * @notice allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed.
    * @param _reserve the address of the reserve
    **/
    function unfreezeReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isFreezed = false;
    }
    /**
    * @notice allows the configurator to update the loan to value of a reserve
    * @param _reserve the address of the reserve
    * @param _ltv the new loan to value
    **/
    function setReserveBaseLTVasCollateral(address _reserve, uint256 _ltv)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.baseLTVasCollateral = _ltv;
    }
    /**
    * @notice allows the configurator to update the liquidation threshold of a reserve
    * @param _reserve the address of the reserve
    * @param _threshold the new liquidation threshold
    **/
    function setReserveLiquidationThreshold(address _reserve, uint256 _threshold)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.liquidationThreshold = _threshold;
    }
    /**
    * @notice allows the configurator to update the liquidation bonus of a reserve
    * @param _reserve the address of the reserve
    * @param _bonus the new liquidation bonus
    **/
    function setReserveLiquidationBonus(address _reserve, uint256 _bonus)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.liquidationBonus = _bonus;
    }
    /**
    * @notice allows the configurator to update the reserve decimals
    * @param _reserve the address of the reserve
    * @param _decimals the decimals of the reserve
    **/
    function setReserveDecimals(address _reserve, uint256 _decimals)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.decimals = _decimals;
    }
    /**
    * @notice internal functions
    **/
    /**
    * @dev updates the state of a reserve as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the previous borrow balance of the borrower before the action
    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount
    * @param _amountBorrowed the new amount borrowed
    * @param _rateMode the borrow rate mode (stable, variable)
    **/
    function updateReserveStateOnBorrowInternal(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _balanceIncrease,
        uint256 _amountBorrowed,
        CoreLibrary.InterestRateMode _rateMode
    ) internal {
        reserves[_reserve].updateCumulativeIndexes();
        //increasing reserve total borrows to account for the new borrow balance of the user
        //NOTE: Depending on the previous borrow mode, the borrows might need to be switched from variable to stable or vice versa
        updateReserveTotalBorrowsByRateModeInternal(
            _reserve,
            _user,
            _principalBorrowBalance,
            _balanceIncrease,
            _amountBorrowed,
            _rateMode
        );
    }
    /**
    * @dev updates the state of a user as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _amountBorrowed the amount borrowed
    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount
    * @param _rateMode the borrow rate mode (stable, variable)
    * @return the final borrow rate for the user. Emitted by the borrow() event
    **/
    function updateUserStateOnBorrowInternal(
        address _reserve,
        address _user,
        uint256 _amountBorrowed,
        uint256 _balanceIncrease,
        uint256 _fee,
        CoreLibrary.InterestRateMode _rateMode
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        if (_rateMode == CoreLibrary.InterestRateMode.STABLE) {
            //stable
            //reset the user variable index, and update the stable rate
            user.stableBorrowRate = reserve.currentStableBorrowRate;
            user.lastVariableBorrowCumulativeIndex = 0;
        } else if (_rateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //variable
            //reset the user stable rate, and store the new borrow index
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        } else {
            revert("Invalid borrow rate mode");
        }
        //increase the principal borrows and the origination fee
        user.principalBorrowBalance = user.principalBorrowBalance.add(_amountBorrowed).add(
            _balanceIncrease
        );
        user.originationFee = user.originationFee.add(_fee);
        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);
    }
    /**
    * @dev updates the state of the reserve as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/
    function updateReserveStateOnRepayInternal(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_reserve][_user];
        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(_reserve, _user);
        //update the indexes
        reserves[_reserve].updateCumulativeIndexes();
        //compound the cumulated interest to the borrow balance and then subtracting the payback amount
        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _balanceIncrease,
                user.stableBorrowRate
            );
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _paybackAmountMinusFees,
                user.stableBorrowRate
            );
        } else {
            reserve.increaseTotalBorrowsVariable(_balanceIncrease);
            reserve.decreaseTotalBorrowsVariable(_paybackAmountMinusFees);
        }
    }
    /**
    * @dev updates the state of the user as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _originationFeeRepaid the fee on the amount that is being repaid
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _repaidWholeLoan true if the user is repaying the whole loan
    **/
    function updateUserStateOnRepayInternal(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _originationFeeRepaid,
        uint256 _balanceIncrease,
        bool _repaidWholeLoan
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        //update the user principal borrow balance, adding the cumulated interest and then subtracting the payback amount
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(
            _paybackAmountMinusFees
        );
        user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        //if the balance decrease is equal to the previous principal (user is repaying the whole loan)
        //and the rate mode is stable, we reset the interest rate mode of the user
        if (_repaidWholeLoan) {
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = 0;
        }
        user.originationFee = user.originationFee.sub(_originationFeeRepaid);
        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);
    }
    /**
    * @dev updates the state of the user as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is performing the rate swap
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the the principal amount borrowed by the user
    * @param _compoundedBorrowBalance the principal amount plus the accrued interest
    * @param _currentRateMode the rate mode at which the user borrowed
    **/
    function updateReserveStateOnSwapRateInternal(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _compoundedBorrowBalance,
        CoreLibrary.InterestRateMode _currentRateMode
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        //compounding reserve indexes
        reserve.updateCumulativeIndexes();
        if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {
            uint256 userCurrentStableRate = user.stableBorrowRate;
            //swap to variable
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _principalBorrowBalance,
                userCurrentStableRate
            ); //decreasing stable from old principal balance
            reserve.increaseTotalBorrowsVariable(_compoundedBorrowBalance); //increase variable borrows
        } else if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //swap to stable
            uint256 currentStableRate = reserve.currentStableBorrowRate;
            reserve.decreaseTotalBorrowsVariable(_principalBorrowBalance);
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _compoundedBorrowBalance,
                currentStableRate
            );
        } else {
            revert("Invalid rate mode received");
        }
    }
    /**
    * @dev updates the state of the user as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is performing the swap
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _currentRateMode the current rate mode of the user
    **/
    function updateUserStateOnSwapRateInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease,
        CoreLibrary.InterestRateMode _currentRateMode
    ) internal returns (CoreLibrary.InterestRateMode) {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.InterestRateMode newMode = CoreLibrary.InterestRateMode.NONE;
        if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //switch to stable
            newMode = CoreLibrary.InterestRateMode.STABLE;
            user.stableBorrowRate = reserve.currentStableBorrowRate;
            user.lastVariableBorrowCumulativeIndex = 0;
        } else if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {
            newMode = CoreLibrary.InterestRateMode.VARIABLE;
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        } else {
            revert("Invalid interest rate mode received");
        }
        //compounding cumulated interest
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);
        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);
        return newMode;
    }
    /**
    * @dev updates the state of the principal reserve as a consequence of a liquidation action.
    * @param _principalReserve the address of the principal reserve that is being repaid
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/
    function updatePrincipalReserveStateOnLiquidationInternal(
        address _principalReserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_principalReserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_principalReserve];
        //update principal reserve data
        reserve.updateCumulativeIndexes();
        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(
            _principalReserve,
            _user
        );
        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            //increase the total borrows by the compounded interest
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _balanceIncrease,
                user.stableBorrowRate
            );
            //decrease by the actual amount to liquidate
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _amountToLiquidate,
                user.stableBorrowRate
            );
        } else {
            //increase the total borrows by the compounded interest
            reserve.increaseTotalBorrowsVariable(_balanceIncrease);
            //decrease by the actual amount to liquidate
            reserve.decreaseTotalBorrowsVariable(_amountToLiquidate);
        }
    }
    /**
    * @dev updates the state of the collateral reserve as a consequence of a liquidation action.
    * @param _collateralReserve the address of the collateral reserve that is being liquidated
    **/
    function updateCollateralReserveStateOnLiquidationInternal(
        address _collateralReserve
    ) internal {
        //update collateral reserve
        reserves[_collateralReserve].updateCumulativeIndexes();
    }
    /**
    * @dev updates the state of the user being liquidated as a consequence of a liquidation action.
    * @param _reserve the address of the principal reserve that is being repaid
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _feeLiquidated the amount of origination fee being liquidated
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/
    function updateUserStateOnLiquidationInternal(
        address _reserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _feeLiquidated,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        //first increase by the compounded interest, then decrease by the liquidated amount
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(
            _amountToLiquidate
        );
        if (
            getUserCurrentBorrowRateMode(_reserve, _user) == CoreLibrary.InterestRateMode.VARIABLE
        ) {
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        }
        if(_feeLiquidated > 0){
            user.originationFee = user.originationFee.sub(_feeLiquidated);
        }
        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);
    }
    /**
    * @dev updates the state of the reserve as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/
    function updateReserveStateOnRebalanceInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        reserve.updateCumulativeIndexes();
        reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
            _balanceIncrease,
            user.stableBorrowRate
        );
    }
    /**
    * @dev updates the state of the user as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/
    function updateUserStateOnRebalanceInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);
        user.stableBorrowRate = reserve.currentStableBorrowRate;
        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);
    }
    /**
    * @dev updates the state of the user as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _amountBorrowed the accrued interest on the borrowed amount
    **/
    function updateReserveTotalBorrowsByRateModeInternal(
        address _reserve,
        address _user,
        uint256 _principalBalance,
        uint256 _balanceIncrease,
        uint256 _amountBorrowed,
        CoreLibrary.InterestRateMode _newBorrowRateMode
    ) internal {
        CoreLibrary.InterestRateMode previousRateMode = getUserCurrentBorrowRateMode(
            _reserve,
            _user
        );
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        if (previousRateMode == CoreLibrary.InterestRateMode.STABLE) {
            CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _principalBalance,
                user.stableBorrowRate
            );
        } else if (previousRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            reserve.decreaseTotalBorrowsVariable(_principalBalance);
        }
        uint256 newPrincipalAmount = _principalBalance.add(_balanceIncrease).add(_amountBorrowed);
        if (_newBorrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                newPrincipalAmount,
                reserve.currentStableBorrowRate
            );
        } else if (_newBorrowRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            reserve.increaseTotalBorrowsVariable(newPrincipalAmount);
        } else {
            revert("Invalid new borrow rate mode");
        }
    }
    /**
    * @dev Updates the reserve current stable borrow rate Rf, the current variable borrow rate Rv and the current liquidity rate Rl.
    * Also updates the lastUpdateTimestamp value. Please refer to the whitepaper for further information.
    * @param _reserve the address of the reserve to be updated
    * @param _liquidityAdded the amount of liquidity added to the protocol (deposit or repay) in the previous action
    * @param _liquidityTaken the amount of liquidity taken from the protocol (redeem or borrow)
    **/
    function updateReserveInterestRatesAndTimestampInternal(
        address _reserve,
        uint256 _liquidityAdded,
        uint256 _liquidityTaken
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        (uint256 newLiquidityRate, uint256 newStableRate, uint256 newVariableRate) = IReserveInterestRateStrategy(
            reserve
            .interestRateStrategyAddress
        )
        .calculateInterestRates(
            _reserve,
            getReserveAvailableLiquidity(_reserve).add(_liquidityAdded).sub(_liquidityTaken),
            reserve.totalBorrowsStable,
            reserve.totalBorrowsVariable,
            reserve.currentAverageStableBorrowRate
        );
        reserve.currentLiquidityRate = newLiquidityRate;
        reserve.currentStableBorrowRate = newStableRate;
        reserve.currentVariableBorrowRate = newVariableRate;
        //solium-disable-next-line
        reserve.lastUpdateTimestamp = uint40(block.timestamp);
        emit ReserveUpdated(
            _reserve,
            newLiquidityRate,
            newStableRate,
            newVariableRate,
            reserve.lastLiquidityCumulativeIndex,
            reserve.lastVariableBorrowCumulativeIndex
        );
    }
    /**
    * @dev transfers to the protocol fees of a flashloan to the fees collection address
    * @param _token the address of the token being transferred
    * @param _amount the amount being transferred
    **/
    function transferFlashLoanProtocolFeeInternal(address _token, uint256 _amount) internal {
        address payable receiver = address(uint160(addressesProvider.getTokenDistributor()));
        if (_token != EthAddressLib.ethAddress()) {
            ERC20(_token).safeTransfer(receiver, _amount);
        } else {
            receiver.transfer(_amount);
        }
    }
    /**
    * @dev updates the internal configuration of the core
    **/
    function refreshConfigInternal() internal {
        lendingPoolAddress = addressesProvider.getLendingPool();
    }
    /**
    * @dev adds a reserve to the array of the reserves address
    **/
    function addReserveToListInternal(address _reserve) internal {
        bool reserveAlreadyAdded = false;
        for (uint256 i = 0; i < reservesList.length; i++)
            if (reservesList[i] == _reserve) {
                reserveAlreadyAdded = true;
            }
        if (!reserveAlreadyAdded) reservesList.push(_reserve);
    }
}
.

Chief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.
Here's a Solidity contract provided by the user: "pragma solidity ^0.5.0;
import "openzeppelin-solidity/contracts/math/SafeMath.sol";
import "openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol";
import "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol";
import "openzeppelin-solidity/contracts/utils/Address.sol";
import "../libraries/openzeppelin-upgradeability/VersionedInitializable.sol";
import "../libraries/CoreLibrary.sol";
import "../configuration/LendingPoolAddressesProvider.sol";
import "../interfaces/ILendingRateOracle.sol";
import "../interfaces/IReserveInterestRateStrategy.sol";
import "../libraries/WadRayMath.sol";
import "../tokenization/AToken.sol";
import "../libraries/EthAddressLib.sol";
/**
* @title LendingPoolCore contract
* @author Aave
* @notice Holds the state of the lending pool and all the funds deposited
* @dev NOTE: The core does not enforce security checks on the update of the state
* (eg, updateStateOnBorrow() does not enforce that borrowed is enabled on the reserve).
* The check that an action can be performed is a duty of the overlying LendingPool contract.
**/
contract LendingPoolCore is VersionedInitializable {
    using SafeMath for uint256;
    using WadRayMath for uint256;
    using CoreLibrary for CoreLibrary.ReserveData;
    using CoreLibrary for CoreLibrary.UserReserveData;
    using SafeERC20 for ERC20;
    using Address for address payable;
    /**
    * @dev Emitted when the state of a reserve is updated
    * @param reserve the address of the reserve
    * @param liquidityRate the new liquidity rate
    * @param stableBorrowRate the new stable borrow rate
    * @param variableBorrowRate the new variable borrow rate
    * @param liquidityIndex the new liquidity index
    * @param variableBorrowIndex the new variable borrow index
    **/
    event ReserveUpdated(
        address indexed reserve,
        uint256 liquidityRate,
        uint256 stableBorrowRate,
        uint256 variableBorrowRate,
        uint256 liquidityIndex,
        uint256 variableBorrowIndex
    );
    address public lendingPoolAddress;
    LendingPoolAddressesProvider public addressesProvider;
    /**
    * @dev only lending pools can use functions affected by this modifier
    **/
    modifier onlyLendingPool {
        require(lendingPoolAddress == msg.sender, "The caller must be a lending pool contract");
        _;
    }
    /**
    * @dev only lending pools configurator can use functions affected by this modifier
    **/
    modifier onlyLendingPoolConfigurator {
        require(
            addressesProvider.getLendingPoolConfigurator() == msg.sender,
            "The caller must be a lending pool configurator contract"
        );
        _;
    }
    mapping(address => CoreLibrary.ReserveData) internal reserves;
    mapping(address => mapping(address => CoreLibrary.UserReserveData)) internal usersReserveData;
    address[] public reservesList;
    uint256 public constant CORE_REVISION = 0x4;
    /**
    * @dev returns the revision number of the contract
    **/
    function getRevision() internal pure returns (uint256) {
        return CORE_REVISION;
    }
    /**
    * @dev initializes the Core contract, invoked upon registration on the AddressesProvider
    * @param _addressesProvider the addressesProvider contract
    **/
    function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {
        addressesProvider = _addressesProvider;
        refreshConfigInternal();
    }
    /**
    * @dev updates the state of the core as a result of a deposit action
    * @param _reserve the address of the reserve in which the deposit is happening
    * @param _user the address of the the user depositing
    * @param _amount the amount being deposited
    * @param _isFirstDeposit true if the user is depositing for the first time
    **/
    function updateStateOnDeposit(
        address _reserve,
        address _user,
        uint256 _amount,
        bool _isFirstDeposit
    ) external onlyLendingPool {
        reserves[_reserve].updateCumulativeIndexes();
        updateReserveInterestRatesAndTimestampInternal(_reserve, _amount, 0);
        if (_isFirstDeposit) {
            //if this is the first deposit of the user, we configure the deposit as enabled to be used as collateral
            setUserUseReserveAsCollateral(_reserve, _user, true);
        }
    }
    /**
    * @dev updates the state of the core as a result of a redeem action
    * @param _reserve the address of the reserve in which the redeem is happening
    * @param _user the address of the the user redeeming
    * @param _amountRedeemed the amount being redeemed
    * @param _userRedeemedEverything true if the user is redeeming everything
    **/
    function updateStateOnRedeem(
        address _reserve,
        address _user,
        uint256 _amountRedeemed,
        bool _userRedeemedEverything
    ) external onlyLendingPool {
        //compound liquidity and variable borrow interests
        reserves[_reserve].updateCumulativeIndexes();
        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountRedeemed);
        //if user redeemed everything the useReserveAsCollateral flag is reset
        if (_userRedeemedEverything) {
            setUserUseReserveAsCollateral(_reserve, _user, false);
        }
    }
    /**
    * @dev updates the state of the core as a result of a flashloan action
    * @param _reserve the address of the reserve in which the flashloan is happening
    * @param _income the income of the protocol as a result of the action
    **/
    function updateStateOnFlashLoan(
        address _reserve,
        uint256 _availableLiquidityBefore,
        uint256 _income,
        uint256 _protocolFee
    ) external onlyLendingPool {
        transferFlashLoanProtocolFeeInternal(_reserve, _protocolFee);
        //compounding the cumulated interest
        reserves[_reserve].updateCumulativeIndexes();
        uint256 totalLiquidityBefore = _availableLiquidityBefore.add(
            getReserveTotalBorrows(_reserve)
        );
        //compounding the received fee into the reserve
        reserves[_reserve].cumulateToLiquidityIndex(totalLiquidityBefore, _income);
        //refresh interest rates
        updateReserveInterestRatesAndTimestampInternal(_reserve, _income, 0);
    }
    /**
    * @dev updates the state of the core as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _amountBorrowed the new amount borrowed
    * @param _borrowFee the fee on the amount borrowed
    * @param _rateMode the borrow rate mode (stable, variable)
    * @return the new borrow rate for the user
    **/
    function updateStateOnBorrow(
        address _reserve,
        address _user,
        uint256 _amountBorrowed,
        uint256 _borrowFee,
        CoreLibrary.InterestRateMode _rateMode
    ) external onlyLendingPool returns (uint256, uint256) {
        // getting the previous borrow data of the user
        (uint256 principalBorrowBalance, , uint256 balanceIncrease) = getUserBorrowBalances(
            _reserve,
            _user
        );
        updateReserveStateOnBorrowInternal(
            _reserve,
            _user,
            principalBorrowBalance,
            balanceIncrease,
            _amountBorrowed,
            _rateMode
        );
        updateUserStateOnBorrowInternal(
            _reserve,
            _user,
            _amountBorrowed,
            balanceIncrease,
            _borrowFee,
            _rateMode
        );
        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountBorrowed);
        return (getUserCurrentBorrowRate(_reserve, _user), balanceIncrease);
    }
    /**
    * @dev updates the state of the core as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _originationFeeRepaid the fee on the amount that is being repaid
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _repaidWholeLoan true if the user is repaying the whole loan
    **/
    function updateStateOnRepay(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _originationFeeRepaid,
        uint256 _balanceIncrease,
        bool _repaidWholeLoan
    ) external onlyLendingPool {
        updateReserveStateOnRepayInternal(
            _reserve,
            _user,
            _paybackAmountMinusFees,
            _balanceIncrease
        );
        updateUserStateOnRepayInternal(
            _reserve,
            _user,
            _paybackAmountMinusFees,
            _originationFeeRepaid,
            _balanceIncrease,
            _repaidWholeLoan
        );
        updateReserveInterestRatesAndTimestampInternal(_reserve, _paybackAmountMinusFees, 0);
    }
    /**
    * @dev updates the state of the core as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the amount borrowed by the user
    * @param _compoundedBorrowBalance the amount borrowed plus accrued interest
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _currentRateMode the current interest rate mode for the user
    **/
    function updateStateOnSwapRate(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _compoundedBorrowBalance,
        uint256 _balanceIncrease,
        CoreLibrary.InterestRateMode _currentRateMode
    ) external onlyLendingPool returns (CoreLibrary.InterestRateMode, uint256) {
        updateReserveStateOnSwapRateInternal(
            _reserve,
            _user,
            _principalBorrowBalance,
            _compoundedBorrowBalance,
            _currentRateMode
        );
        CoreLibrary.InterestRateMode newRateMode = updateUserStateOnSwapRateInternal(
            _reserve,
            _user,
            _balanceIncrease,
            _currentRateMode
        );
        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);
        return (newRateMode, getUserCurrentBorrowRate(_reserve, _user));
    }
    /**
    * @dev updates the state of the core as a consequence of a liquidation action.
    * @param _principalReserve the address of the principal reserve that is being repaid
    * @param _collateralReserve the address of the collateral reserve that is being liquidated
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _collateralToLiquidate the amount of collateral being liquidated
    * @param _feeLiquidated the amount of origination fee being liquidated
    * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise
    **/
    function updateStateOnLiquidation(
        address _principalReserve,
        address _collateralReserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _collateralToLiquidate,
        uint256 _feeLiquidated,
        uint256 _liquidatedCollateralForFee,
        uint256 _balanceIncrease,
        bool _liquidatorReceivesAToken
    ) external onlyLendingPool {
        updatePrincipalReserveStateOnLiquidationInternal(
            _principalReserve,
            _user,
            _amountToLiquidate,
            _balanceIncrease
        );
        updateCollateralReserveStateOnLiquidationInternal(
            _collateralReserve
        );
        updateUserStateOnLiquidationInternal(
            _principalReserve,
            _user,
            _amountToLiquidate,
            _feeLiquidated,
            _balanceIncrease
        );
        updateReserveInterestRatesAndTimestampInternal(_principalReserve, _amountToLiquidate, 0);
        if (!_liquidatorReceivesAToken) {
            updateReserveInterestRatesAndTimestampInternal(
                _collateralReserve,
                0,
                _collateralToLiquidate.add(_liquidatedCollateralForFee)
            );
        }
    }
    /**
    * @dev updates the state of the core as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @return the new stable rate for the user
    **/
    function updateStateOnRebalance(address _reserve, address _user, uint256 _balanceIncrease)
    external
    onlyLendingPool
    returns (uint256)
    {
        updateReserveStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);
        //update user data and rebalance the rate
        updateUserStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);
        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);
        return usersReserveData[_user][_reserve].stableBorrowRate;
    }
    /**
    * @dev enables or disables a reserve as collateral
    * @param _reserve the address of the principal reserve where the user deposited
    * @param _user the address of the depositor
    * @param _useAsCollateral true if the depositor wants to use the reserve as collateral
    **/
    function setUserUseReserveAsCollateral(address _reserve, address _user, bool _useAsCollateral)
    public
    onlyLendingPool
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        user.useAsCollateral = _useAsCollateral;
    }
    /**
    * @notice ETH/token transfer functions
    **/
    /**
    * @dev fallback function enforces that the caller is a contract, to support flashloan transfers
    **/
    function() external payable {
        //only contracts can send ETH to the core
        require(msg.sender.isContract(), "Only contracts can send ether to the Lending pool core");
    }
    /**
    * @dev transfers to the user a specific amount from the reserve.
    * @param _reserve the address of the reserve where the transfer is happening
    * @param _user the address of the user receiving the transfer
    * @param _amount the amount being transferred
    **/
    function transferToUser(address _reserve, address payable _user, uint256 _amount)
    external
    onlyLendingPool
    {
        if (_reserve != EthAddressLib.ethAddress()) {
            ERC20(_reserve).safeTransfer(_user, _amount);
        } else {
            //solium-disable-next-line
            (bool result, ) = _user.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }
    /**
    * @dev transfers the protocol fees to the fees collection address
    * @param _token the address of the token being transferred
    * @param _user the address of the user from where the transfer is happening
    * @param _amount the amount being transferred
    * @param _destination the fee receiver address
    **/
    function transferToFeeCollectionAddress(
        address _token,
        address _user,
        uint256 _amount,
        address _destination
    ) external payable onlyLendingPool {
        address payable feeAddress = address(uint160(_destination)); //cast the address to payable
        if (_token != EthAddressLib.ethAddress()) {
            require(
                msg.value == 0,
                "User is sending ETH along with the ERC20 transfer. Check the value attribute of the transaction"
            );
            ERC20(_token).safeTransferFrom(_user, feeAddress, _amount);
        } else {
            require(msg.value >= _amount, "The amount and the value sent to deposit do not match");
            //solium-disable-next-line
            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }
    /**
    * @dev transfers the fees to the fees collection address in the case of liquidation
    * @param _token the address of the token being transferred
    * @param _amount the amount being transferred
    * @param _destination the fee receiver address
    **/
    function liquidateFee(
        address _token,
        uint256 _amount,
        address _destination
    ) external payable onlyLendingPool {
        address payable feeAddress = address(uint160(_destination)); //cast the address to payable
        require(
            msg.value == 0,
            "Fee liquidation does not require any transfer of value"
        );
        if (_token != EthAddressLib.ethAddress()) {
            ERC20(_token).safeTransfer(feeAddress, _amount);
        } else {
            //solium-disable-next-line
            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }
    /**
    * @dev transfers an amount from a user to the destination reserve
    * @param _reserve the address of the reserve where the amount is being transferred
    * @param _user the address of the user from where the transfer is happening
    * @param _amount the amount being transferred
    **/
    function transferToReserve(address _reserve, address payable _user, uint256 _amount)
    external
    payable
    onlyLendingPool
    {
        if (_reserve != EthAddressLib.ethAddress()) {
            require(msg.value == 0, "User is sending ETH along with the ERC20 transfer.");
            ERC20(_reserve).safeTransferFrom(_user, address(this), _amount);
        } else {
            require(msg.value >= _amount, "The amount and the value sent to deposit do not match");
            if (msg.value > _amount) {
                //send back excess ETH
                uint256 excessAmount = msg.value.sub(_amount);
                //solium-disable-next-line
                (bool result, ) = _user.call.value(excessAmount).gas(50000)("");
                require(result, "Transfer of ETH failed");
            }
        }
    }
    /**
    * @notice data access functions
    **/
    /**
    * @dev returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral)
    * needed to calculate the global account data in the LendingPoolDataProvider
    * @param _reserve the address of the reserve
    * @param _user the address of the user
    * @return the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not
    **/
    function getUserBasicReserveData(address _reserve, address _user)
    external
    view
    returns (uint256, uint256, uint256, bool)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        uint256 underlyingBalance = getUserUnderlyingAssetBalance(_reserve, _user);
        if (user.principalBorrowBalance == 0) {
            return (underlyingBalance, 0, 0, user.useAsCollateral);
        }
        return (
        underlyingBalance,
        user.getCompoundedBorrowBalance(reserve),
        user.originationFee,
        user.useAsCollateral
        );
    }
    /**
    * @dev checks if a user is allowed to borrow at a stable rate
    * @param _reserve the reserve address
    * @param _user the user
    * @param _amount the amount the the user wants to borrow
    * @return true if the user is allowed to borrow at a stable rate, false otherwise
    **/
    function isUserAllowedToBorrowAtStable(address _reserve, address _user, uint256 _amount)
    external
    view
    returns (bool)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        if (!reserve.isStableBorrowRateEnabled) return false;
        return
        !user.useAsCollateral ||
        !reserve.usageAsCollateralEnabled ||
        _amount > getUserUnderlyingAssetBalance(_reserve, _user);
    }
    /**
    * @dev gets the underlying asset balance of a user based on the corresponding aToken balance.
    * @param _reserve the reserve address
    * @param _user the user address
    * @return the underlying deposit balance of the user
    **/
    function getUserUnderlyingAssetBalance(address _reserve, address _user)
    public
    view
    returns (uint256)
    {
        AToken aToken = AToken(reserves[_reserve].aTokenAddress);
        return aToken.balanceOf(_user);
    }
    /**
    * @dev gets the interest rate strategy contract address for the reserve
    * @param _reserve the reserve address
    * @return the address of the interest rate strategy contract
    **/
    function getReserveInterestRateStrategyAddress(address _reserve) public view returns (address) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.interestRateStrategyAddress;
    }
    /**
    * @dev gets the aToken contract address for the reserve
    * @param _reserve the reserve address
    * @return the address of the aToken contract
    **/
    function getReserveATokenAddress(address _reserve) public view returns (address) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.aTokenAddress;
    }
    /**
    * @dev gets the available liquidity in the reserve. The available liquidity is the balance of the core contract
    * @param _reserve the reserve address
    * @return the available liquidity
    **/
    function getReserveAvailableLiquidity(address _reserve) public view returns (uint256) {
        uint256 balance = 0;
        if (_reserve == EthAddressLib.ethAddress()) {
            balance = address(this).balance;
        } else {
            balance = IERC20(_reserve).balanceOf(address(this));
        }
        return balance;
    }
    /**
    * @dev gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows
    * @param _reserve the reserve address
    * @return the total liquidity
    **/
    function getReserveTotalLiquidity(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return getReserveAvailableLiquidity(_reserve).add(reserve.getTotalBorrows());
    }
    /**
    * @dev gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there
    * there has been 100% income.
    * @param _reserve the reserve address
    * @return the reserve normalized income
    **/
    function getReserveNormalizedIncome(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.getNormalizedIncome();
    }
    /**
    * @dev gets the reserve total borrows
    * @param _reserve the reserve address
    * @return the total borrows (stable + variable)
    **/
    function getReserveTotalBorrows(address _reserve) public view returns (uint256) {
        return reserves[_reserve].getTotalBorrows();
    }
    /**
    * @dev gets the reserve total borrows stable
    * @param _reserve the reserve address
    * @return the total borrows stable
    **/
    function getReserveTotalBorrowsStable(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.totalBorrowsStable;
    }
    /**
    * @dev gets the reserve total borrows variable
    * @param _reserve the reserve address
    * @return the total borrows variable
    **/
    function getReserveTotalBorrowsVariable(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.totalBorrowsVariable;
    }
    /**
    * @dev gets the reserve liquidation threshold
    * @param _reserve the reserve address
    * @return the reserve liquidation threshold
    **/
    function getReserveLiquidationThreshold(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.liquidationThreshold;
    }
    /**
    * @dev gets the reserve liquidation bonus
    * @param _reserve the reserve address
    * @return the reserve liquidation bonus
    **/
    function getReserveLiquidationBonus(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.liquidationBonus;
    }
    /**
    * @dev gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty
    * @param _reserve the reserve address
    * @return the reserve current variable borrow rate
    **/
    function getReserveCurrentVariableBorrowRate(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        if (reserve.currentVariableBorrowRate == 0) {
            return
            IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)
            .getBaseVariableBorrowRate();
        }
        return reserve.currentVariableBorrowRate;
    }
    /**
    * @dev gets the reserve current stable borrow rate. Is the market rate if the reserve is empty
    * @param _reserve the reserve address
    * @return the reserve current stable borrow rate
    **/
    function getReserveCurrentStableBorrowRate(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        ILendingRateOracle oracle = ILendingRateOracle(addressesProvider.getLendingRateOracle());
        if (reserve.currentStableBorrowRate == 0) {
            //no stable rate borrows yet
            return oracle.getMarketBorrowRate(_reserve);
        }
        return reserve.currentStableBorrowRate;
    }
    /**
    * @dev gets the reserve average stable borrow rate. The average stable rate is the weighted average
    * of all the loans taken at stable rate.
    * @param _reserve the reserve address
    * @return the reserve current average borrow rate
    **/
    function getReserveCurrentAverageStableBorrowRate(address _reserve)
    external
    view
    returns (uint256)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.currentAverageStableBorrowRate;
    }
    /**
    * @dev gets the reserve liquidity rate
    * @param _reserve the reserve address
    * @return the reserve liquidity rate
    **/
    function getReserveCurrentLiquidityRate(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.currentLiquidityRate;
    }
    /**
    * @dev gets the reserve liquidity cumulative index
    * @param _reserve the reserve address
    * @return the reserve liquidity cumulative index
    **/
    function getReserveLiquidityCumulativeIndex(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.lastLiquidityCumulativeIndex;
    }
    /**
    * @dev gets the reserve variable borrow index
    * @param _reserve the reserve address
    * @return the reserve variable borrow index
    **/
    function getReserveVariableBorrowsCumulativeIndex(address _reserve)
    external
    view
    returns (uint256)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.lastVariableBorrowCumulativeIndex;
    }
    /**
    * @dev this function aggregates the configuration parameters of the reserve.
    * It's used in the LendingPoolDataProvider specifically to save gas, and avoid
    * multiple external contract calls to fetch the same data.
    * @param _reserve the reserve address
    * @return the reserve decimals
    * @return the base ltv as collateral
    * @return the liquidation threshold
    * @return if the reserve is used as collateral or not
    **/
    function getReserveConfiguration(address _reserve)
    external
    view
    returns (uint256, uint256, uint256, bool)
    {
        uint256 decimals;
        uint256 baseLTVasCollateral;
        uint256 liquidationThreshold;
        bool usageAsCollateralEnabled;
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        decimals = reserve.decimals;
        baseLTVasCollateral = reserve.baseLTVasCollateral;
        liquidationThreshold = reserve.liquidationThreshold;
        usageAsCollateralEnabled = reserve.usageAsCollateralEnabled;
        return (decimals, baseLTVasCollateral, liquidationThreshold, usageAsCollateralEnabled);
    }
    /**
    * @dev returns the decimals of the reserve
    * @param _reserve the reserve address
    * @return the reserve decimals
    **/
    function getReserveDecimals(address _reserve) external view returns (uint256) {
        return reserves[_reserve].decimals;
    }
    /**
    * @dev returns true if the reserve is enabled for borrowing
    * @param _reserve the reserve address
    * @return true if the reserve is enabled for borrowing, false otherwise
    **/
    function isReserveBorrowingEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.borrowingEnabled;
    }
    /**
    * @dev returns true if the reserve is enabled as collateral
    * @param _reserve the reserve address
    * @return true if the reserve is enabled as collateral, false otherwise
    **/
    function isReserveUsageAsCollateralEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.usageAsCollateralEnabled;
    }
    /**
    * @dev returns true if the stable rate is enabled on reserve
    * @param _reserve the reserve address
    * @return true if the stable rate is enabled on reserve, false otherwise
    **/
    function getReserveIsStableBorrowRateEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isStableBorrowRateEnabled;
    }
    /**
    * @dev returns true if the reserve is active
    * @param _reserve the reserve address
    * @return true if the reserve is active, false otherwise
    **/
    function getReserveIsActive(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isActive;
    }
    /**
    * @notice returns if a reserve is freezed
    * @param _reserve the reserve for which the information is needed
    * @return true if the reserve is freezed, false otherwise
    **/
    function getReserveIsFreezed(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isFreezed;
    }
    /**
    * @notice returns the timestamp of the last action on the reserve
    * @param _reserve the reserve for which the information is needed
    * @return the last updated timestamp of the reserve
    **/
    function getReserveLastUpdate(address _reserve) external view returns (uint40 timestamp) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        timestamp = reserve.lastUpdateTimestamp;
    }
    /**
    * @dev returns the utilization rate U of a specific reserve
    * @param _reserve the reserve for which the information is needed
    * @return the utilization rate in ray
    **/
    function getReserveUtilizationRate(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        uint256 totalBorrows = reserve.getTotalBorrows();
        if (totalBorrows == 0) {
            return 0;
        }
        uint256 availableLiquidity = getReserveAvailableLiquidity(_reserve);
        return totalBorrows.rayDiv(availableLiquidity.add(totalBorrows));
    }
    /**
    * @return the array of reserves configured on the core
    **/
    function getReserves() external view returns (address[] memory) {
        return reservesList;
    }
    /**
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return true if the user has chosen to use the reserve as collateral, false otherwise
    **/
    function isUserUseReserveAsCollateralEnabled(address _reserve, address _user)
    external
    view
    returns (bool)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.useAsCollateral;
    }
    /**
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the origination fee for the user
    **/
    function getUserOriginationFee(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.originationFee;
    }
    /**
    * @dev users with no loans in progress have NONE as borrow rate mode
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the borrow rate mode for the user,
    **/
    function getUserCurrentBorrowRateMode(address _reserve, address _user)
    public
    view
    returns (CoreLibrary.InterestRateMode)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        if (user.principalBorrowBalance == 0) {
            return CoreLibrary.InterestRateMode.NONE;
        }
        return
        user.stableBorrowRate > 0
        ? CoreLibrary.InterestRateMode.STABLE
        : CoreLibrary.InterestRateMode.VARIABLE;
    }
    /**
    * @dev gets the current borrow rate of the user
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the borrow rate for the user,
    **/
    function getUserCurrentBorrowRate(address _reserve, address _user)
    internal
    view
    returns (uint256)
    {
        CoreLibrary.InterestRateMode rateMode = getUserCurrentBorrowRateMode(_reserve, _user);
        if (rateMode == CoreLibrary.InterestRateMode.NONE) {
            return 0;
        }
        return
        rateMode == CoreLibrary.InterestRateMode.STABLE
        ? usersReserveData[_user][_reserve].stableBorrowRate
        : reserves[_reserve].currentVariableBorrowRate;
    }
    /**
    * @dev the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the user stable rate
    **/
    function getUserCurrentStableBorrowRate(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.stableBorrowRate;
    }
    /**
    * @dev calculates and returns the borrow balances of the user
    * @param _reserve the address of the reserve
    * @param _user the address of the user
    * @return the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance
    **/
    function getUserBorrowBalances(address _reserve, address _user)
    public
    view
    returns (uint256, uint256, uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        if (user.principalBorrowBalance == 0) {
            return (0, 0, 0);
        }
        uint256 principal = user.principalBorrowBalance;
        uint256 compoundedBalance = CoreLibrary.getCompoundedBorrowBalance(
            user,
            reserves[_reserve]
        );
        return (principal, compoundedBalance, compoundedBalance.sub(principal));
    }
    /**
    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the variable borrow index for the user
    **/
    function getUserVariableBorrowCumulativeIndex(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.lastVariableBorrowCumulativeIndex;
    }
    /**
    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the variable borrow index for the user
    **/
    function getUserLastUpdate(address _reserve, address _user)
    external
    view
    returns (uint256 timestamp)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        timestamp = user.lastUpdateTimestamp;
    }
    /**
    * @dev updates the lending pool core configuration
    **/
    function refreshConfiguration() external onlyLendingPoolConfigurator {
        refreshConfigInternal();
    }
    /**
    * @dev initializes a reserve
    * @param _reserve the address of the reserve
    * @param _aTokenAddress the address of the overlying aToken contract
    * @param _decimals the decimals of the reserve currency
    * @param _interestRateStrategyAddress the address of the interest rate strategy contract
    **/
    function initReserve(
        address _reserve,
        address _aTokenAddress,
        uint256 _decimals,
        address _interestRateStrategyAddress
    ) external onlyLendingPoolConfigurator {
        reserves[_reserve].init(_aTokenAddress, _decimals, _interestRateStrategyAddress);
        addReserveToListInternal(_reserve);
    }

    /**
    * @dev removes the last added reserve in the reservesList array
    * @param _reserveToRemove the address of the reserve
    **/
    function removeLastAddedReserve(address _reserveToRemove)
    external onlyLendingPoolConfigurator {
        address lastReserve = reservesList[reservesList.length-1];
        require(lastReserve == _reserveToRemove, "Reserve being removed is different than the reserve requested");
        //as we can't check if totalLiquidity is 0 (since the reserve added might not be an ERC20) we at least check that there is nothing borrowed
        require(getReserveTotalBorrows(lastReserve) == 0, "Cannot remove a reserve with liquidity deposited");
        reserves[lastReserve].isActive = false;
        reserves[lastReserve].aTokenAddress = address(0);
        reserves[lastReserve].decimals = 0;
        reserves[lastReserve].lastLiquidityCumulativeIndex = 0;
        reserves[lastReserve].lastVariableBorrowCumulativeIndex = 0;
        reserves[lastReserve].borrowingEnabled = false;
        reserves[lastReserve].usageAsCollateralEnabled = false;
        reserves[lastReserve].baseLTVasCollateral = 0;
        reserves[lastReserve].liquidationThreshold = 0;
        reserves[lastReserve].liquidationBonus = 0;
        reserves[lastReserve].interestRateStrategyAddress = address(0);
        reservesList.pop();
    }
    /**
    * @dev updates the address of the interest rate strategy contract
    * @param _reserve the address of the reserve
    * @param _rateStrategyAddress the address of the interest rate strategy contract
    **/
    function setReserveInterestRateStrategyAddress(address _reserve, address _rateStrategyAddress)
    external
    onlyLendingPoolConfigurator
    {
        reserves[_reserve].interestRateStrategyAddress = _rateStrategyAddress;
    }
    /**
    * @dev enables borrowing on a reserve. Also sets the stable rate borrowing
    * @param _reserve the address of the reserve
    * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise
    **/
    function enableBorrowingOnReserve(address _reserve, bool _stableBorrowRateEnabled)
    external
    onlyLendingPoolConfigurator
    {
        reserves[_reserve].enableBorrowing(_stableBorrowRateEnabled);
    }
    /**
    * @dev disables borrowing on a reserve
    * @param _reserve the address of the reserve
    **/
    function disableBorrowingOnReserve(address _reserve) external onlyLendingPoolConfigurator {
        reserves[_reserve].disableBorrowing();
    }
    /**
    * @dev enables a reserve to be used as collateral
    * @param _reserve the address of the reserve
    **/
    function enableReserveAsCollateral(
        address _reserve,
        uint256 _baseLTVasCollateral,
        uint256 _liquidationThreshold,
        uint256 _liquidationBonus
    ) external onlyLendingPoolConfigurator {
        reserves[_reserve].enableAsCollateral(
            _baseLTVasCollateral,
            _liquidationThreshold,
            _liquidationBonus
        );
    }
    /**
    * @dev disables a reserve to be used as collateral
    * @param _reserve the address of the reserve
    **/
    function disableReserveAsCollateral(address _reserve) external onlyLendingPoolConfigurator {
        reserves[_reserve].disableAsCollateral();
    }
    /**
    * @dev enable the stable borrow rate mode on a reserve
    * @param _reserve the address of the reserve
    **/
    function enableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isStableBorrowRateEnabled = true;
    }
    /**
    * @dev disable the stable borrow rate mode on a reserve
    * @param _reserve the address of the reserve
    **/
    function disableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isStableBorrowRateEnabled = false;
    }
    /**
    * @dev activates a reserve
    * @param _reserve the address of the reserve
    **/
    function activateReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        require(
            reserve.lastLiquidityCumulativeIndex > 0 &&
            reserve.lastVariableBorrowCumulativeIndex > 0,
            "Reserve has not been initialized yet"
        );
        reserve.isActive = true;
    }
    /**
    * @dev deactivates a reserve
    * @param _reserve the address of the reserve
    **/
    function deactivateReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isActive = false;
    }
    /**
    * @notice allows the configurator to freeze the reserve.
    * A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance.
    * @param _reserve the address of the reserve
    **/
    function freezeReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isFreezed = true;
    }
    /**
    * @notice allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed.
    * @param _reserve the address of the reserve
    **/
    function unfreezeReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isFreezed = false;
    }
    /**
    * @notice allows the configurator to update the loan to value of a reserve
    * @param _reserve the address of the reserve
    * @param _ltv the new loan to value
    **/
    function setReserveBaseLTVasCollateral(address _reserve, uint256 _ltv)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.baseLTVasCollateral = _ltv;
    }
    /**
    * @notice allows the configurator to update the liquidation threshold of a reserve
    * @param _reserve the address of the reserve
    * @param _threshold the new liquidation threshold
    **/
    function setReserveLiquidationThreshold(address _reserve, uint256 _threshold)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.liquidationThreshold = _threshold;
    }
    /**
    * @notice allows the configurator to update the liquidation bonus of a reserve
    * @param _reserve the address of the reserve
    * @param _bonus the new liquidation bonus
    **/
    function setReserveLiquidationBonus(address _reserve, uint256 _bonus)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.liquidationBonus = _bonus;
    }
    /**
    * @notice allows the configurator to update the reserve decimals
    * @param _reserve the address of the reserve
    * @param _decimals the decimals of the reserve
    **/
    function setReserveDecimals(address _reserve, uint256 _decimals)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.decimals = _decimals;
    }
    /**
    * @notice internal functions
    **/
    /**
    * @dev updates the state of a reserve as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the previous borrow balance of the borrower before the action
    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount
    * @param _amountBorrowed the new amount borrowed
    * @param _rateMode the borrow rate mode (stable, variable)
    **/
    function updateReserveStateOnBorrowInternal(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _balanceIncrease,
        uint256 _amountBorrowed,
        CoreLibrary.InterestRateMode _rateMode
    ) internal {
        reserves[_reserve].updateCumulativeIndexes();
        //increasing reserve total borrows to account for the new borrow balance of the user
        //NOTE: Depending on the previous borrow mode, the borrows might need to be switched from variable to stable or vice versa
        updateReserveTotalBorrowsByRateModeInternal(
            _reserve,
            _user,
            _principalBorrowBalance,
            _balanceIncrease,
            _amountBorrowed,
            _rateMode
        );
    }
    /**
    * @dev updates the state of a user as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _amountBorrowed the amount borrowed
    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount
    * @param _rateMode the borrow rate mode (stable, variable)
    * @return the final borrow rate for the user. Emitted by the borrow() event
    **/
    function updateUserStateOnBorrowInternal(
        address _reserve,
        address _user,
        uint256 _amountBorrowed,
        uint256 _balanceIncrease,
        uint256 _fee,
        CoreLibrary.InterestRateMode _rateMode
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        if (_rateMode == CoreLibrary.InterestRateMode.STABLE) {
            //stable
            //reset the user variable index, and update the stable rate
            user.stableBorrowRate = reserve.currentStableBorrowRate;
            user.lastVariableBorrowCumulativeIndex = 0;
        } else if (_rateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //variable
            //reset the user stable rate, and store the new borrow index
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        } else {
            revert("Invalid borrow rate mode");
        }
        //increase the principal borrows and the origination fee
        user.principalBorrowBalance = user.principalBorrowBalance.add(_amountBorrowed).add(
            _balanceIncrease
        );
        user.originationFee = user.originationFee.add(_fee);
        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);
    }
    /**
    * @dev updates the state of the reserve as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/
    function updateReserveStateOnRepayInternal(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_reserve][_user];
        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(_reserve, _user);
        //update the indexes
        reserves[_reserve].updateCumulativeIndexes();
        //compound the cumulated interest to the borrow balance and then subtracting the payback amount
        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _balanceIncrease,
                user.stableBorrowRate
            );
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _paybackAmountMinusFees,
                user.stableBorrowRate
            );
        } else {
            reserve.increaseTotalBorrowsVariable(_balanceIncrease);
            reserve.decreaseTotalBorrowsVariable(_paybackAmountMinusFees);
        }
    }
    /**
    * @dev updates the state of the user as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _originationFeeRepaid the fee on the amount that is being repaid
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _repaidWholeLoan true if the user is repaying the whole loan
    **/
    function updateUserStateOnRepayInternal(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _originationFeeRepaid,
        uint256 _balanceIncrease,
        bool _repaidWholeLoan
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        //update the user principal borrow balance, adding the cumulated interest and then subtracting the payback amount
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(
            _paybackAmountMinusFees
        );
        user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        //if the balance decrease is equal to the previous principal (user is repaying the whole loan)
        //and the rate mode is stable, we reset the interest rate mode of the user
        if (_repaidWholeLoan) {
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = 0;
        }
        user.originationFee = user.originationFee.sub(_originationFeeRepaid);
        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);
    }
    /**
    * @dev updates the state of the user as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is performing the rate swap
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the the principal amount borrowed by the user
    * @param _compoundedBorrowBalance the principal amount plus the accrued interest
    * @param _currentRateMode the rate mode at which the user borrowed
    **/
    function updateReserveStateOnSwapRateInternal(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _compoundedBorrowBalance,
        CoreLibrary.InterestRateMode _currentRateMode
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        //compounding reserve indexes
        reserve.updateCumulativeIndexes();
        if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {
            uint256 userCurrentStableRate = user.stableBorrowRate;
            //swap to variable
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _principalBorrowBalance,
                userCurrentStableRate
            ); //decreasing stable from old principal balance
            reserve.increaseTotalBorrowsVariable(_compoundedBorrowBalance); //increase variable borrows
        } else if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //swap to stable
            uint256 currentStableRate = reserve.currentStableBorrowRate;
            reserve.decreaseTotalBorrowsVariable(_principalBorrowBalance);
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _compoundedBorrowBalance,
                currentStableRate
            );
        } else {
            revert("Invalid rate mode received");
        }
    }
    /**
    * @dev updates the state of the user as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is performing the swap
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _currentRateMode the current rate mode of the user
    **/
    function updateUserStateOnSwapRateInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease,
        CoreLibrary.InterestRateMode _currentRateMode
    ) internal returns (CoreLibrary.InterestRateMode) {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.InterestRateMode newMode = CoreLibrary.InterestRateMode.NONE;
        if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //switch to stable
            newMode = CoreLibrary.InterestRateMode.STABLE;
            user.stableBorrowRate = reserve.currentStableBorrowRate;
            user.lastVariableBorrowCumulativeIndex = 0;
        } else if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {
            newMode = CoreLibrary.InterestRateMode.VARIABLE;
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        } else {
            revert("Invalid interest rate mode received");
        }
        //compounding cumulated interest
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);
        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);
        return newMode;
    }
    /**
    * @dev updates the state of the principal reserve as a consequence of a liquidation action.
    * @param _principalReserve the address of the principal reserve that is being repaid
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/
    function updatePrincipalReserveStateOnLiquidationInternal(
        address _principalReserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_principalReserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_principalReserve];
        //update principal reserve data
        reserve.updateCumulativeIndexes();
        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(
            _principalReserve,
            _user
        );
        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            //increase the total borrows by the compounded interest
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _balanceIncrease,
                user.stableBorrowRate
            );
            //decrease by the actual amount to liquidate
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _amountToLiquidate,
                user.stableBorrowRate
            );
        } else {
            //increase the total borrows by the compounded interest
            reserve.increaseTotalBorrowsVariable(_balanceIncrease);
            //decrease by the actual amount to liquidate
            reserve.decreaseTotalBorrowsVariable(_amountToLiquidate);
        }
    }
    /**
    * @dev updates the state of the collateral reserve as a consequence of a liquidation action.
    * @param _collateralReserve the address of the collateral reserve that is being liquidated
    **/
    function updateCollateralReserveStateOnLiquidationInternal(
        address _collateralReserve
    ) internal {
        //update collateral reserve
        reserves[_collateralReserve].updateCumulativeIndexes();
    }
    /**
    * @dev updates the state of the user being liquidated as a consequence of a liquidation action.
    * @param _reserve the address of the principal reserve that is being repaid
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _feeLiquidated the amount of origination fee being liquidated
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/
    function updateUserStateOnLiquidationInternal(
        address _reserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _feeLiquidated,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        //first increase by the compounded interest, then decrease by the liquidated amount
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(
            _amountToLiquidate
        );
        if (
            getUserCurrentBorrowRateMode(_reserve, _user) == CoreLibrary.InterestRateMode.VARIABLE
        ) {
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        }
        if(_feeLiquidated > 0){
            user.originationFee = user.originationFee.sub(_feeLiquidated);
        }
        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);
    }
    /**
    * @dev updates the state of the reserve as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/
    function updateReserveStateOnRebalanceInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        reserve.updateCumulativeIndexes();
        reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
            _balanceIncrease,
            user.stableBorrowRate
        );
    }
    /**
    * @dev updates the state of the user as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/
    function updateUserStateOnRebalanceInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);
        user.stableBorrowRate = reserve.currentStableBorrowRate;
        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);
    }
    /**
    * @dev updates the state of the user as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _amountBorrowed the accrued interest on the borrowed amount
    **/
    function updateReserveTotalBorrowsByRateModeInternal(
        address _reserve,
        address _user,
        uint256 _principalBalance,
        uint256 _balanceIncrease,
        uint256 _amountBorrowed,
        CoreLibrary.InterestRateMode _newBorrowRateMode
    ) internal {
        CoreLibrary.InterestRateMode previousRateMode = getUserCurrentBorrowRateMode(
            _reserve,
            _user
        );
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        if (previousRateMode == CoreLibrary.InterestRateMode.STABLE) {
            CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _principalBalance,
                user.stableBorrowRate
            );
        } else if (previousRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            reserve.decreaseTotalBorrowsVariable(_principalBalance);
        }
        uint256 newPrincipalAmount = _principalBalance.add(_balanceIncrease).add(_amountBorrowed);
        if (_newBorrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                newPrincipalAmount,
                reserve.currentStableBorrowRate
            );
        } else if (_newBorrowRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            reserve.increaseTotalBorrowsVariable(newPrincipalAmount);
        } else {
            revert("Invalid new borrow rate mode");
        }
    }
    /**
    * @dev Updates the reserve current stable borrow rate Rf, the current variable borrow rate Rv and the current liquidity rate Rl.
    * Also updates the lastUpdateTimestamp value. Please refer to the whitepaper for further information.
    * @param _reserve the address of the reserve to be updated
    * @param _liquidityAdded the amount of liquidity added to the protocol (deposit or repay) in the previous action
    * @param _liquidityTaken the amount of liquidity taken from the protocol (redeem or borrow)
    **/
    function updateReserveInterestRatesAndTimestampInternal(
        address _reserve,
        uint256 _liquidityAdded,
        uint256 _liquidityTaken
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        (uint256 newLiquidityRate, uint256 newStableRate, uint256 newVariableRate) = IReserveInterestRateStrategy(
            reserve
            .interestRateStrategyAddress
        )
        .calculateInterestRates(
            _reserve,
            getReserveAvailableLiquidity(_reserve).add(_liquidityAdded).sub(_liquidityTaken),
            reserve.totalBorrowsStable,
            reserve.totalBorrowsVariable,
            reserve.currentAverageStableBorrowRate
        );
        reserve.currentLiquidityRate = newLiquidityRate;
        reserve.currentStableBorrowRate = newStableRate;
        reserve.currentVariableBorrowRate = newVariableRate;
        //solium-disable-next-line
        reserve.lastUpdateTimestamp = uint40(block.timestamp);
        emit ReserveUpdated(
            _reserve,
            newLiquidityRate,
            newStableRate,
            newVariableRate,
            reserve.lastLiquidityCumulativeIndex,
            reserve.lastVariableBorrowCumulativeIndex
        );
    }
    /**
    * @dev transfers to the protocol fees of a flashloan to the fees collection address
    * @param _token the address of the token being transferred
    * @param _amount the amount being transferred
    **/
    function transferFlashLoanProtocolFeeInternal(address _token, uint256 _amount) internal {
        address payable receiver = address(uint160(addressesProvider.getTokenDistributor()));
        if (_token != EthAddressLib.ethAddress()) {
            ERC20(_token).safeTransfer(receiver, _amount);
        } else {
            receiver.transfer(_amount);
        }
    }
    /**
    * @dev updates the internal configuration of the core
    **/
    function refreshConfigInternal() internal {
        lendingPoolAddress = addressesProvider.getLendingPool();
    }
    /**
    * @dev adds a reserve to the array of the reserves address
    **/
    function addReserveToListInternal(address _reserve) internal {
        bool reserveAlreadyAdded = false;
        for (uint256 i = 0; i < reservesList.length; i++)
            if (reservesList[i] == _reserve) {
                reserveAlreadyAdded = true;
            }
        if (!reserveAlreadyAdded) reservesList.push(_reserve);
    }
}
".
As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.
Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

Security Analyst: Let's Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" 

[2024-01-09 04:31:25 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 04:31:25 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 43298
completion_tokens: 1
total_tokens: 43299
cost: $-1.000000


[2024-01-09 04:31:25 INFO] Chief Executive Officer: **Chief Executive Officer<->Counselor on : Reflection, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your main responsibilities include asking what user and customer think and provide your valuable suggestions. 
Here is a new customer's task: pragma solidity ^0.5.0;

import "openzeppelin-solidity/contracts/math/SafeMath.sol";
import "openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol";
import "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol";
import "openzeppelin-solidity/contracts/utils/Address.sol";
import "../libraries/openzeppelin-upgradeability/VersionedInitializable.sol";

import "../libraries/CoreLibrary.sol";
import "../configuration/LendingPoolAddressesProvider.sol";
import "../interfaces/ILendingRateOracle.sol";
import "../interfaces/IReserveInterestRateStrategy.sol";
import "../libraries/WadRayMath.sol";
import "../tokenization/AToken.sol";
import "../libraries/EthAddressLib.sol";

/**
* @title LendingPoolCore contract
* @author Aave
* @notice Holds the state of the lending pool and all the funds deposited
* @dev NOTE: The core does not enforce security checks on the update of the state
* (eg, updateStateOnBorrow() does not enforce that borrowed is enabled on the reserve).
* The check that an action can be performed is a duty of the overlying LendingPool contract.
**/

contract LendingPoolCore is VersionedInitializable {
    using SafeMath for uint256;
    using WadRayMath for uint256;
    using CoreLibrary for CoreLibrary.ReserveData;
    using CoreLibrary for CoreLibrary.UserReserveData;
    using SafeERC20 for ERC20;
    using Address for address payable;

    /**
    * @dev Emitted when the state of a reserve is updated
    * @param reserve the address of the reserve
    * @param liquidityRate the new liquidity rate
    * @param stableBorrowRate the new stable borrow rate
    * @param variableBorrowRate the new variable borrow rate
    * @param liquidityIndex the new liquidity index
    * @param variableBorrowIndex the new variable borrow index
    **/
    event ReserveUpdated(
        address indexed reserve,
        uint256 liquidityRate,
        uint256 stableBorrowRate,
        uint256 variableBorrowRate,
        uint256 liquidityIndex,
        uint256 variableBorrowIndex
    );

    address public lendingPoolAddress;

    LendingPoolAddressesProvider public addressesProvider;

    /**
    * @dev only lending pools can use functions affected by this modifier
    **/
    modifier onlyLendingPool {
        require(lendingPoolAddress == msg.sender, "The caller must be a lending pool contract");
        _;
    }

    /**
    * @dev only lending pools configurator can use functions affected by this modifier
    **/
    modifier onlyLendingPoolConfigurator {
        require(
            addressesProvider.getLendingPoolConfigurator() == msg.sender,
            "The caller must be a lending pool configurator contract"
        );
        _;
    }

    mapping(address => CoreLibrary.ReserveData) internal reserves;
    mapping(address => mapping(address => CoreLibrary.UserReserveData)) internal usersReserveData;

    address[] public reservesList;

    uint256 public constant CORE_REVISION = 0x4;

    /**
    * @dev returns the revision number of the contract
    **/
    function getRevision() internal pure returns (uint256) {
        return CORE_REVISION;
    }

    /**
    * @dev initializes the Core contract, invoked upon registration on the AddressesProvider
    * @param _addressesProvider the addressesProvider contract
    **/

    function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {
        addressesProvider = _addressesProvider;
        refreshConfigInternal();
    }

    /**
    * @dev updates the state of the core as a result of a deposit action
    * @param _reserve the address of the reserve in which the deposit is happening
    * @param _user the address of the the user depositing
    * @param _amount the amount being deposited
    * @param _isFirstDeposit true if the user is depositing for the first time
    **/

    function updateStateOnDeposit(
        address _reserve,
        address _user,
        uint256 _amount,
        bool _isFirstDeposit
    ) external onlyLendingPool {
        reserves[_reserve].updateCumulativeIndexes();
        updateReserveInterestRatesAndTimestampInternal(_reserve, _amount, 0);

        if (_isFirstDeposit) {
            //if this is the first deposit of the user, we configure the deposit as enabled to be used as collateral
            setUserUseReserveAsCollateral(_reserve, _user, true);
        }
    }

    /**
    * @dev updates the state of the core as a result of a redeem action
    * @param _reserve the address of the reserve in which the redeem is happening
    * @param _user the address of the the user redeeming
    * @param _amountRedeemed the amount being redeemed
    * @param _userRedeemedEverything true if the user is redeeming everything
    **/
    function updateStateOnRedeem(
        address _reserve,
        address _user,
        uint256 _amountRedeemed,
        bool _userRedeemedEverything
    ) external onlyLendingPool {
        //compound liquidity and variable borrow interests
        reserves[_reserve].updateCumulativeIndexes();
        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountRedeemed);

        //if user redeemed everything the useReserveAsCollateral flag is reset
        if (_userRedeemedEverything) {
            setUserUseReserveAsCollateral(_reserve, _user, false);
        }
    }

    /**
    * @dev updates the state of the core as a result of a flashloan action
    * @param _reserve the address of the reserve in which the flashloan is happening
    * @param _income the income of the protocol as a result of the action
    **/
    function updateStateOnFlashLoan(
        address _reserve,
        uint256 _availableLiquidityBefore,
        uint256 _income,
        uint256 _protocolFee
    ) external onlyLendingPool {
        transferFlashLoanProtocolFeeInternal(_reserve, _protocolFee);

        //compounding the cumulated interest
        reserves[_reserve].updateCumulativeIndexes();

        uint256 totalLiquidityBefore = _availableLiquidityBefore.add(
            getReserveTotalBorrows(_reserve)
        );

        //compounding the received fee into the reserve
        reserves[_reserve].cumulateToLiquidityIndex(totalLiquidityBefore, _income);

        //refresh interest rates
        updateReserveInterestRatesAndTimestampInternal(_reserve, _income, 0);
    }

    /**
    * @dev updates the state of the core as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _amountBorrowed the new amount borrowed
    * @param _borrowFee the fee on the amount borrowed
    * @param _rateMode the borrow rate mode (stable, variable)
    * @return the new borrow rate for the user
    **/
    function updateStateOnBorrow(
        address _reserve,
        address _user,
        uint256 _amountBorrowed,
        uint256 _borrowFee,
        CoreLibrary.InterestRateMode _rateMode
    ) external onlyLendingPool returns (uint256, uint256) {
        // getting the previous borrow data of the user
        (uint256 principalBorrowBalance, , uint256 balanceIncrease) = getUserBorrowBalances(
            _reserve,
            _user
        );

        updateReserveStateOnBorrowInternal(
            _reserve,
            _user,
            principalBorrowBalance,
            balanceIncrease,
            _amountBorrowed,
            _rateMode
        );

        updateUserStateOnBorrowInternal(
            _reserve,
            _user,
            _amountBorrowed,
            balanceIncrease,
            _borrowFee,
            _rateMode
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountBorrowed);

        return (getUserCurrentBorrowRate(_reserve, _user), balanceIncrease);
    }

    /**
    * @dev updates the state of the core as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _originationFeeRepaid the fee on the amount that is being repaid
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _repaidWholeLoan true if the user is repaying the whole loan
    **/

    function updateStateOnRepay(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _originationFeeRepaid,
        uint256 _balanceIncrease,
        bool _repaidWholeLoan
    ) external onlyLendingPool {
        updateReserveStateOnRepayInternal(
            _reserve,
            _user,
            _paybackAmountMinusFees,
            _balanceIncrease
        );
        updateUserStateOnRepayInternal(
            _reserve,
            _user,
            _paybackAmountMinusFees,
            _originationFeeRepaid,
            _balanceIncrease,
            _repaidWholeLoan
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, _paybackAmountMinusFees, 0);
    }

    /**
    * @dev updates the state of the core as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the amount borrowed by the user
    * @param _compoundedBorrowBalance the amount borrowed plus accrued interest
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _currentRateMode the current interest rate mode for the user
    **/
    function updateStateOnSwapRate(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _compoundedBorrowBalance,
        uint256 _balanceIncrease,
        CoreLibrary.InterestRateMode _currentRateMode
    ) external onlyLendingPool returns (CoreLibrary.InterestRateMode, uint256) {
        updateReserveStateOnSwapRateInternal(
            _reserve,
            _user,
            _principalBorrowBalance,
            _compoundedBorrowBalance,
            _currentRateMode
        );

        CoreLibrary.InterestRateMode newRateMode = updateUserStateOnSwapRateInternal(
            _reserve,
            _user,
            _balanceIncrease,
            _currentRateMode
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);

        return (newRateMode, getUserCurrentBorrowRate(_reserve, _user));
    }

    /**
    * @dev updates the state of the core as a consequence of a liquidation action.
    * @param _principalReserve the address of the principal reserve that is being repaid
    * @param _collateralReserve the address of the collateral reserve that is being liquidated
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _collateralToLiquidate the amount of collateral being liquidated
    * @param _feeLiquidated the amount of origination fee being liquidated
    * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise
    **/
    function updateStateOnLiquidation(
        address _principalReserve,
        address _collateralReserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _collateralToLiquidate,
        uint256 _feeLiquidated,
        uint256 _liquidatedCollateralForFee,
        uint256 _balanceIncrease,
        bool _liquidatorReceivesAToken
    ) external onlyLendingPool {
        updatePrincipalReserveStateOnLiquidationInternal(
            _principalReserve,
            _user,
            _amountToLiquidate,
            _balanceIncrease
        );

        updateCollateralReserveStateOnLiquidationInternal(
            _collateralReserve
        );

        updateUserStateOnLiquidationInternal(
            _principalReserve,
            _user,
            _amountToLiquidate,
            _feeLiquidated,
            _balanceIncrease
        );

        updateReserveInterestRatesAndTimestampInternal(_principalReserve, _amountToLiquidate, 0);

        if (!_liquidatorReceivesAToken) {
            updateReserveInterestRatesAndTimestampInternal(
                _collateralReserve,
                0,
                _collateralToLiquidate.add(_liquidatedCollateralForFee)
            );
        }

    }

    /**
    * @dev updates the state of the core as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @return the new stable rate for the user
    **/
    function updateStateOnRebalance(address _reserve, address _user, uint256 _balanceIncrease)
    external
    onlyLendingPool
    returns (uint256)
    {
        updateReserveStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);

        //update user data and rebalance the rate
        updateUserStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);
        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);
        return usersReserveData[_user][_reserve].stableBorrowRate;
    }

    /**
    * @dev enables or disables a reserve as collateral
    * @param _reserve the address of the principal reserve where the user deposited
    * @param _user the address of the depositor
    * @param _useAsCollateral true if the depositor wants to use the reserve as collateral
    **/
    function setUserUseReserveAsCollateral(address _reserve, address _user, bool _useAsCollateral)
    public
    onlyLendingPool
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        user.useAsCollateral = _useAsCollateral;
    }

    /**
    * @notice ETH/token transfer functions
    **/

    /**
    * @dev fallback function enforces that the caller is a contract, to support flashloan transfers
    **/
    function() external payable {
        //only contracts can send ETH to the core
        require(msg.sender.isContract(), "Only contracts can send ether to the Lending pool core");

    }

    /**
    * @dev transfers to the user a specific amount from the reserve.
    * @param _reserve the address of the reserve where the transfer is happening
    * @param _user the address of the user receiving the transfer
    * @param _amount the amount being transferred
    **/
    function transferToUser(address _reserve, address payable _user, uint256 _amount)
    external
    onlyLendingPool
    {
        if (_reserve != EthAddressLib.ethAddress()) {
            ERC20(_reserve).safeTransfer(_user, _amount);
        } else {
            //solium-disable-next-line
            (bool result, ) = _user.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers the protocol fees to the fees collection address
    * @param _token the address of the token being transferred
    * @param _user the address of the user from where the transfer is happening
    * @param _amount the amount being transferred
    * @param _destination the fee receiver address
    **/

    function transferToFeeCollectionAddress(
        address _token,
        address _user,
        uint256 _amount,
        address _destination
    ) external payable onlyLendingPool {
        address payable feeAddress = address(uint160(_destination)); //cast the address to payable

        if (_token != EthAddressLib.ethAddress()) {
            require(
                msg.value == 0,
                "User is sending ETH along with the ERC20 transfer. Check the value attribute of the transaction"
            );
            ERC20(_token).safeTransferFrom(_user, feeAddress, _amount);
        } else {
            require(msg.value >= _amount, "The amount and the value sent to deposit do not match");
            //solium-disable-next-line
            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers the fees to the fees collection address in the case of liquidation
    * @param _token the address of the token being transferred
    * @param _amount the amount being transferred
    * @param _destination the fee receiver address
    **/
    function liquidateFee(
        address _token,
        uint256 _amount,
        address _destination
    ) external payable onlyLendingPool {
        address payable feeAddress = address(uint160(_destination)); //cast the address to payable
        require(
            msg.value == 0,
            "Fee liquidation does not require any transfer of value"
        );

        if (_token != EthAddressLib.ethAddress()) {
            ERC20(_token).safeTransfer(feeAddress, _amount);
        } else {
            //solium-disable-next-line
            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers an amount from a user to the destination reserve
    * @param _reserve the address of the reserve where the amount is being transferred
    * @param _user the address of the user from where the transfer is happening
    * @param _amount the amount being transferred
    **/
    function transferToReserve(address _reserve, address payable _user, uint256 _amount)
    external
    payable
    onlyLendingPool
    {
        if (_reserve != EthAddressLib.ethAddress()) {
            require(msg.value == 0, "User is sending ETH along with the ERC20 transfer.");
            ERC20(_reserve).safeTransferFrom(_user, address(this), _amount);

        } else {
            require(msg.value >= _amount, "The amount and the value sent to deposit do not match");

            if (msg.value > _amount) {
                //send back excess ETH
                uint256 excessAmount = msg.value.sub(_amount);
                //solium-disable-next-line
                (bool result, ) = _user.call.value(excessAmount).gas(50000)("");
                require(result, "Transfer of ETH failed");
            }
        }
    }

    /**
    * @notice data access functions
    **/

    /**
    * @dev returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral)
    * needed to calculate the global account data in the LendingPoolDataProvider
    * @param _reserve the address of the reserve
    * @param _user the address of the user
    * @return the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not
    **/
    function getUserBasicReserveData(address _reserve, address _user)
    external
    view
    returns (uint256, uint256, uint256, bool)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        uint256 underlyingBalance = getUserUnderlyingAssetBalance(_reserve, _user);

        if (user.principalBorrowBalance == 0) {
            return (underlyingBalance, 0, 0, user.useAsCollateral);
        }

        return (
        underlyingBalance,
        user.getCompoundedBorrowBalance(reserve),
        user.originationFee,
        user.useAsCollateral
        );
    }

    /**
    * @dev checks if a user is allowed to borrow at a stable rate
    * @param _reserve the reserve address
    * @param _user the user
    * @param _amount the amount the the user wants to borrow
    * @return true if the user is allowed to borrow at a stable rate, false otherwise
    **/

    function isUserAllowedToBorrowAtStable(address _reserve, address _user, uint256 _amount)
    external
    view
    returns (bool)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (!reserve.isStableBorrowRateEnabled) return false;

        return
        !user.useAsCollateral ||
        !reserve.usageAsCollateralEnabled ||
        _amount > getUserUnderlyingAssetBalance(_reserve, _user);
    }

    /**
    * @dev gets the underlying asset balance of a user based on the corresponding aToken balance.
    * @param _reserve the reserve address
    * @param _user the user address
    * @return the underlying deposit balance of the user
    **/

    function getUserUnderlyingAssetBalance(address _reserve, address _user)
    public
    view
    returns (uint256)
    {
        AToken aToken = AToken(reserves[_reserve].aTokenAddress);
        return aToken.balanceOf(_user);

    }

    /**
    * @dev gets the interest rate strategy contract address for the reserve
    * @param _reserve the reserve address
    * @return the address of the interest rate strategy contract
    **/
    function getReserveInterestRateStrategyAddress(address _reserve) public view returns (address) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.interestRateStrategyAddress;
    }

    /**
    * @dev gets the aToken contract address for the reserve
    * @param _reserve the reserve address
    * @return the address of the aToken contract
    **/

    function getReserveATokenAddress(address _reserve) public view returns (address) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.aTokenAddress;
    }

    /**
    * @dev gets the available liquidity in the reserve. The available liquidity is the balance of the core contract
    * @param _reserve the reserve address
    * @return the available liquidity
    **/
    function getReserveAvailableLiquidity(address _reserve) public view returns (uint256) {
        uint256 balance = 0;

        if (_reserve == EthAddressLib.ethAddress()) {
            balance = address(this).balance;
        } else {
            balance = IERC20(_reserve).balanceOf(address(this));
        }
        return balance;
    }

    /**
    * @dev gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows
    * @param _reserve the reserve address
    * @return the total liquidity
    **/
    function getReserveTotalLiquidity(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return getReserveAvailableLiquidity(_reserve).add(reserve.getTotalBorrows());
    }

    /**
    * @dev gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there
    * there has been 100% income.
    * @param _reserve the reserve address
    * @return the reserve normalized income
    **/
    function getReserveNormalizedIncome(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.getNormalizedIncome();
    }

    /**
    * @dev gets the reserve total borrows
    * @param _reserve the reserve address
    * @return the total borrows (stable + variable)
    **/
    function getReserveTotalBorrows(address _reserve) public view returns (uint256) {
        return reserves[_reserve].getTotalBorrows();
    }

    /**
    * @dev gets the reserve total borrows stable
    * @param _reserve the reserve address
    * @return the total borrows stable
    **/
    function getReserveTotalBorrowsStable(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.totalBorrowsStable;
    }

    /**
    * @dev gets the reserve total borrows variable
    * @param _reserve the reserve address
    * @return the total borrows variable
    **/

    function getReserveTotalBorrowsVariable(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.totalBorrowsVariable;
    }

    /**
    * @dev gets the reserve liquidation threshold
    * @param _reserve the reserve address
    * @return the reserve liquidation threshold
    **/

    function getReserveLiquidationThreshold(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.liquidationThreshold;
    }

    /**
    * @dev gets the reserve liquidation bonus
    * @param _reserve the reserve address
    * @return the reserve liquidation bonus
    **/

    function getReserveLiquidationBonus(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.liquidationBonus;
    }

    /**
    * @dev gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty
    * @param _reserve the reserve address
    * @return the reserve current variable borrow rate
    **/

    function getReserveCurrentVariableBorrowRate(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        if (reserve.currentVariableBorrowRate == 0) {
            return
            IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)
            .getBaseVariableBorrowRate();
        }
        return reserve.currentVariableBorrowRate;
    }

    /**
    * @dev gets the reserve current stable borrow rate. Is the market rate if the reserve is empty
    * @param _reserve the reserve address
    * @return the reserve current stable borrow rate
    **/

    function getReserveCurrentStableBorrowRate(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        ILendingRateOracle oracle = ILendingRateOracle(addressesProvider.getLendingRateOracle());

        if (reserve.currentStableBorrowRate == 0) {
            //no stable rate borrows yet
            return oracle.getMarketBorrowRate(_reserve);
        }

        return reserve.currentStableBorrowRate;
    }

    /**
    * @dev gets the reserve average stable borrow rate. The average stable rate is the weighted average
    * of all the loans taken at stable rate.
    * @param _reserve the reserve address
    * @return the reserve current average borrow rate
    **/
    function getReserveCurrentAverageStableBorrowRate(address _reserve)
    external
    view
    returns (uint256)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.currentAverageStableBorrowRate;
    }

    /**
    * @dev gets the reserve liquidity rate
    * @param _reserve the reserve address
    * @return the reserve liquidity rate
    **/
    function getReserveCurrentLiquidityRate(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.currentLiquidityRate;
    }

    /**
    * @dev gets the reserve liquidity cumulative index
    * @param _reserve the reserve address
    * @return the reserve liquidity cumulative index
    **/
    function getReserveLiquidityCumulativeIndex(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.lastLiquidityCumulativeIndex;
    }

    /**
    * @dev gets the reserve variable borrow index
    * @param _reserve the reserve address
    * @return the reserve variable borrow index
    **/
    function getReserveVariableBorrowsCumulativeIndex(address _reserve)
    external
    view
    returns (uint256)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.lastVariableBorrowCumulativeIndex;
    }

    /**
    * @dev this function aggregates the configuration parameters of the reserve.
    * It's used in the LendingPoolDataProvider specifically to save gas, and avoid
    * multiple external contract calls to fetch the same data.
    * @param _reserve the reserve address
    * @return the reserve decimals
    * @return the base ltv as collateral
    * @return the liquidation threshold
    * @return if the reserve is used as collateral or not
    **/
    function getReserveConfiguration(address _reserve)
    external
    view
    returns (uint256, uint256, uint256, bool)
    {
        uint256 decimals;
        uint256 baseLTVasCollateral;
        uint256 liquidationThreshold;
        bool usageAsCollateralEnabled;

        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        decimals = reserve.decimals;
        baseLTVasCollateral = reserve.baseLTVasCollateral;
        liquidationThreshold = reserve.liquidationThreshold;
        usageAsCollateralEnabled = reserve.usageAsCollateralEnabled;

        return (decimals, baseLTVasCollateral, liquidationThreshold, usageAsCollateralEnabled);
    }

    /**
    * @dev returns the decimals of the reserve
    * @param _reserve the reserve address
    * @return the reserve decimals
    **/
    function getReserveDecimals(address _reserve) external view returns (uint256) {
        return reserves[_reserve].decimals;
    }

    /**
    * @dev returns true if the reserve is enabled for borrowing
    * @param _reserve the reserve address
    * @return true if the reserve is enabled for borrowing, false otherwise
    **/

    function isReserveBorrowingEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.borrowingEnabled;
    }

    /**
    * @dev returns true if the reserve is enabled as collateral
    * @param _reserve the reserve address
    * @return true if the reserve is enabled as collateral, false otherwise
    **/

    function isReserveUsageAsCollateralEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.usageAsCollateralEnabled;
    }

    /**
    * @dev returns true if the stable rate is enabled on reserve
    * @param _reserve the reserve address
    * @return true if the stable rate is enabled on reserve, false otherwise
    **/
    function getReserveIsStableBorrowRateEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isStableBorrowRateEnabled;
    }

    /**
    * @dev returns true if the reserve is active
    * @param _reserve the reserve address
    * @return true if the reserve is active, false otherwise
    **/
    function getReserveIsActive(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isActive;
    }

    /**
    * @notice returns if a reserve is freezed
    * @param _reserve the reserve for which the information is needed
    * @return true if the reserve is freezed, false otherwise
    **/

    function getReserveIsFreezed(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isFreezed;
    }

    /**
    * @notice returns the timestamp of the last action on the reserve
    * @param _reserve the reserve for which the information is needed
    * @return the last updated timestamp of the reserve
    **/

    function getReserveLastUpdate(address _reserve) external view returns (uint40 timestamp) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        timestamp = reserve.lastUpdateTimestamp;
    }

    /**
    * @dev returns the utilization rate U of a specific reserve
    * @param _reserve the reserve for which the information is needed
    * @return the utilization rate in ray
    **/

    function getReserveUtilizationRate(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        uint256 totalBorrows = reserve.getTotalBorrows();

        if (totalBorrows == 0) {
            return 0;
        }

        uint256 availableLiquidity = getReserveAvailableLiquidity(_reserve);

        return totalBorrows.rayDiv(availableLiquidity.add(totalBorrows));
    }

    /**
    * @return the array of reserves configured on the core
    **/
    function getReserves() external view returns (address[] memory) {
        return reservesList;
    }

    /**
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return true if the user has chosen to use the reserve as collateral, false otherwise
    **/
    function isUserUseReserveAsCollateralEnabled(address _reserve, address _user)
    external
    view
    returns (bool)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.useAsCollateral;
    }

    /**
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the origination fee for the user
    **/
    function getUserOriginationFee(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.originationFee;
    }

    /**
    * @dev users with no loans in progress have NONE as borrow rate mode
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the borrow rate mode for the user,
    **/

    function getUserCurrentBorrowRateMode(address _reserve, address _user)
    public
    view
    returns (CoreLibrary.InterestRateMode)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (user.principalBorrowBalance == 0) {
            return CoreLibrary.InterestRateMode.NONE;
        }

        return
        user.stableBorrowRate > 0
        ? CoreLibrary.InterestRateMode.STABLE
        : CoreLibrary.InterestRateMode.VARIABLE;
    }

    /**
    * @dev gets the current borrow rate of the user
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the borrow rate for the user,
    **/
    function getUserCurrentBorrowRate(address _reserve, address _user)
    internal
    view
    returns (uint256)
    {
        CoreLibrary.InterestRateMode rateMode = getUserCurrentBorrowRateMode(_reserve, _user);

        if (rateMode == CoreLibrary.InterestRateMode.NONE) {
            return 0;
        }

        return
        rateMode == CoreLibrary.InterestRateMode.STABLE
        ? usersReserveData[_user][_reserve].stableBorrowRate
        : reserves[_reserve].currentVariableBorrowRate;
    }

    /**
    * @dev the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the user stable rate
    **/
    function getUserCurrentStableBorrowRate(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.stableBorrowRate;
    }

    /**
    * @dev calculates and returns the borrow balances of the user
    * @param _reserve the address of the reserve
    * @param _user the address of the user
    * @return the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance
    **/

    function getUserBorrowBalances(address _reserve, address _user)
    public
    view
    returns (uint256, uint256, uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        if (user.principalBorrowBalance == 0) {
            return (0, 0, 0);
        }

        uint256 principal = user.principalBorrowBalance;
        uint256 compoundedBalance = CoreLibrary.getCompoundedBorrowBalance(
            user,
            reserves[_reserve]
        );
        return (principal, compoundedBalance, compoundedBalance.sub(principal));
    }

    /**
    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the variable borrow index for the user
    **/

    function getUserVariableBorrowCumulativeIndex(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.lastVariableBorrowCumulativeIndex;
    }

    /**
    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the variable borrow index for the user
    **/

    function getUserLastUpdate(address _reserve, address _user)
    external
    view
    returns (uint256 timestamp)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        timestamp = user.lastUpdateTimestamp;
    }

    /**
    * @dev updates the lending pool core configuration
    **/
    function refreshConfiguration() external onlyLendingPoolConfigurator {
        refreshConfigInternal();
    }

    /**
    * @dev initializes a reserve
    * @param _reserve the address of the reserve
    * @param _aTokenAddress the address of the overlying aToken contract
    * @param _decimals the decimals of the reserve currency
    * @param _interestRateStrategyAddress the address of the interest rate strategy contract
    **/
    function initReserve(
        address _reserve,
        address _aTokenAddress,
        uint256 _decimals,
        address _interestRateStrategyAddress
    ) external onlyLendingPoolConfigurator {
        reserves[_reserve].init(_aTokenAddress, _decimals, _interestRateStrategyAddress);
        addReserveToListInternal(_reserve);

    }



    /**
    * @dev removes the last added reserve in the reservesList array
    * @param _reserveToRemove the address of the reserve
    **/
    function removeLastAddedReserve(address _reserveToRemove)
    external onlyLendingPoolConfigurator {

        address lastReserve = reservesList[reservesList.length-1];

        require(lastReserve == _reserveToRemove, "Reserve being removed is different than the reserve requested");

        //as we can't check if totalLiquidity is 0 (since the reserve added might not be an ERC20) we at least check that there is nothing borrowed
        require(getReserveTotalBorrows(lastReserve) == 0, "Cannot remove a reserve with liquidity deposited");

        reserves[lastReserve].isActive = false;
        reserves[lastReserve].aTokenAddress = address(0);
        reserves[lastReserve].decimals = 0;
        reserves[lastReserve].lastLiquidityCumulativeIndex = 0;
        reserves[lastReserve].lastVariableBorrowCumulativeIndex = 0;
        reserves[lastReserve].borrowingEnabled = false;
        reserves[lastReserve].usageAsCollateralEnabled = false;
        reserves[lastReserve].baseLTVasCollateral = 0;
        reserves[lastReserve].liquidationThreshold = 0;
        reserves[lastReserve].liquidationBonus = 0;
        reserves[lastReserve].interestRateStrategyAddress = address(0);

        reservesList.pop();
    }

    /**
    * @dev updates the address of the interest rate strategy contract
    * @param _reserve the address of the reserve
    * @param _rateStrategyAddress the address of the interest rate strategy contract
    **/

    function setReserveInterestRateStrategyAddress(address _reserve, address _rateStrategyAddress)
    external
    onlyLendingPoolConfigurator
    {
        reserves[_reserve].interestRateStrategyAddress = _rateStrategyAddress;
    }

    /**
    * @dev enables borrowing on a reserve. Also sets the stable rate borrowing
    * @param _reserve the address of the reserve
    * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise
    **/

    function enableBorrowingOnReserve(address _reserve, bool _stableBorrowRateEnabled)
    external
    onlyLendingPoolConfigurator
    {
        reserves[_reserve].enableBorrowing(_stableBorrowRateEnabled);
    }

    /**
    * @dev disables borrowing on a reserve
    * @param _reserve the address of the reserve
    **/

    function disableBorrowingOnReserve(address _reserve) external onlyLendingPoolConfigurator {
        reserves[_reserve].disableBorrowing();
    }

    /**
    * @dev enables a reserve to be used as collateral
    * @param _reserve the address of the reserve
    **/
    function enableReserveAsCollateral(
        address _reserve,
        uint256 _baseLTVasCollateral,
        uint256 _liquidationThreshold,
        uint256 _liquidationBonus
    ) external onlyLendingPoolConfigurator {
        reserves[_reserve].enableAsCollateral(
            _baseLTVasCollateral,
            _liquidationThreshold,
            _liquidationBonus
        );
    }

    /**
    * @dev disables a reserve to be used as collateral
    * @param _reserve the address of the reserve
    **/
    function disableReserveAsCollateral(address _reserve) external onlyLendingPoolConfigurator {
        reserves[_reserve].disableAsCollateral();
    }

    /**
    * @dev enable the stable borrow rate mode on a reserve
    * @param _reserve the address of the reserve
    **/
    function enableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isStableBorrowRateEnabled = true;
    }

    /**
    * @dev disable the stable borrow rate mode on a reserve
    * @param _reserve the address of the reserve
    **/
    function disableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isStableBorrowRateEnabled = false;
    }

    /**
    * @dev activates a reserve
    * @param _reserve the address of the reserve
    **/
    function activateReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        require(
            reserve.lastLiquidityCumulativeIndex > 0 &&
            reserve.lastVariableBorrowCumulativeIndex > 0,
            "Reserve has not been initialized yet"
        );
        reserve.isActive = true;
    }

    /**
    * @dev deactivates a reserve
    * @param _reserve the address of the reserve
    **/
    function deactivateReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isActive = false;
    }

    /**
    * @notice allows the configurator to freeze the reserve.
    * A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance.
    * @param _reserve the address of the reserve
    **/
    function freezeReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isFreezed = true;
    }

    /**
    * @notice allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed.
    * @param _reserve the address of the reserve
    **/
    function unfreezeReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isFreezed = false;
    }

    /**
    * @notice allows the configurator to update the loan to value of a reserve
    * @param _reserve the address of the reserve
    * @param _ltv the new loan to value
    **/
    function setReserveBaseLTVasCollateral(address _reserve, uint256 _ltv)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.baseLTVasCollateral = _ltv;
    }

    /**
    * @notice allows the configurator to update the liquidation threshold of a reserve
    * @param _reserve the address of the reserve
    * @param _threshold the new liquidation threshold
    **/
    function setReserveLiquidationThreshold(address _reserve, uint256 _threshold)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.liquidationThreshold = _threshold;
    }

    /**
    * @notice allows the configurator to update the liquidation bonus of a reserve
    * @param _reserve the address of the reserve
    * @param _bonus the new liquidation bonus
    **/
    function setReserveLiquidationBonus(address _reserve, uint256 _bonus)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.liquidationBonus = _bonus;
    }

    /**
    * @notice allows the configurator to update the reserve decimals
    * @param _reserve the address of the reserve
    * @param _decimals the decimals of the reserve
    **/
    function setReserveDecimals(address _reserve, uint256 _decimals)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.decimals = _decimals;
    }

    /**
    * @notice internal functions
    **/

    /**
    * @dev updates the state of a reserve as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the previous borrow balance of the borrower before the action
    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount
    * @param _amountBorrowed the new amount borrowed
    * @param _rateMode the borrow rate mode (stable, variable)
    **/

    function updateReserveStateOnBorrowInternal(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _balanceIncrease,
        uint256 _amountBorrowed,
        CoreLibrary.InterestRateMode _rateMode
    ) internal {
        reserves[_reserve].updateCumulativeIndexes();

        //increasing reserve total borrows to account for the new borrow balance of the user
        //NOTE: Depending on the previous borrow mode, the borrows might need to be switched from variable to stable or vice versa

        updateReserveTotalBorrowsByRateModeInternal(
            _reserve,
            _user,
            _principalBorrowBalance,
            _balanceIncrease,
            _amountBorrowed,
            _rateMode
        );
    }

    /**
    * @dev updates the state of a user as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _amountBorrowed the amount borrowed
    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount
    * @param _rateMode the borrow rate mode (stable, variable)
    * @return the final borrow rate for the user. Emitted by the borrow() event
    **/

    function updateUserStateOnBorrowInternal(
        address _reserve,
        address _user,
        uint256 _amountBorrowed,
        uint256 _balanceIncrease,
        uint256 _fee,
        CoreLibrary.InterestRateMode _rateMode
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (_rateMode == CoreLibrary.InterestRateMode.STABLE) {
            //stable
            //reset the user variable index, and update the stable rate
            user.stableBorrowRate = reserve.currentStableBorrowRate;
            user.lastVariableBorrowCumulativeIndex = 0;
        } else if (_rateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //variable
            //reset the user stable rate, and store the new borrow index
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        } else {
            revert("Invalid borrow rate mode");
        }
        //increase the principal borrows and the origination fee
        user.principalBorrowBalance = user.principalBorrowBalance.add(_amountBorrowed).add(
            _balanceIncrease
        );
        user.originationFee = user.originationFee.add(_fee);

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

    }

    /**
    * @dev updates the state of the reserve as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateReserveStateOnRepayInternal(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_reserve][_user];

        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(_reserve, _user);

        //update the indexes
        reserves[_reserve].updateCumulativeIndexes();

        //compound the cumulated interest to the borrow balance and then subtracting the payback amount
        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _balanceIncrease,
                user.stableBorrowRate
            );
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _paybackAmountMinusFees,
                user.stableBorrowRate
            );
        } else {
            reserve.increaseTotalBorrowsVariable(_balanceIncrease);
            reserve.decreaseTotalBorrowsVariable(_paybackAmountMinusFees);
        }
    }

    /**
    * @dev updates the state of the user as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _originationFeeRepaid the fee on the amount that is being repaid
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _repaidWholeLoan true if the user is repaying the whole loan
    **/
    function updateUserStateOnRepayInternal(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _originationFeeRepaid,
        uint256 _balanceIncrease,
        bool _repaidWholeLoan
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        //update the user principal borrow balance, adding the cumulated interest and then subtracting the payback amount
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(
            _paybackAmountMinusFees
        );
        user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;

        //if the balance decrease is equal to the previous principal (user is repaying the whole loan)
        //and the rate mode is stable, we reset the interest rate mode of the user
        if (_repaidWholeLoan) {
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = 0;
        }
        user.originationFee = user.originationFee.sub(_originationFeeRepaid);

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

    }

    /**
    * @dev updates the state of the user as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is performing the rate swap
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the the principal amount borrowed by the user
    * @param _compoundedBorrowBalance the principal amount plus the accrued interest
    * @param _currentRateMode the rate mode at which the user borrowed
    **/
    function updateReserveStateOnSwapRateInternal(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _compoundedBorrowBalance,
        CoreLibrary.InterestRateMode _currentRateMode
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        //compounding reserve indexes
        reserve.updateCumulativeIndexes();

        if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {
            uint256 userCurrentStableRate = user.stableBorrowRate;

            //swap to variable
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _principalBorrowBalance,
                userCurrentStableRate
            ); //decreasing stable from old principal balance
            reserve.increaseTotalBorrowsVariable(_compoundedBorrowBalance); //increase variable borrows
        } else if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //swap to stable
            uint256 currentStableRate = reserve.currentStableBorrowRate;
            reserve.decreaseTotalBorrowsVariable(_principalBorrowBalance);
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _compoundedBorrowBalance,
                currentStableRate
            );

        } else {
            revert("Invalid rate mode received");
        }
    }

    /**
    * @dev updates the state of the user as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is performing the swap
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _currentRateMode the current rate mode of the user
    **/

    function updateUserStateOnSwapRateInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease,
        CoreLibrary.InterestRateMode _currentRateMode
    ) internal returns (CoreLibrary.InterestRateMode) {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        CoreLibrary.InterestRateMode newMode = CoreLibrary.InterestRateMode.NONE;

        if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //switch to stable
            newMode = CoreLibrary.InterestRateMode.STABLE;
            user.stableBorrowRate = reserve.currentStableBorrowRate;
            user.lastVariableBorrowCumulativeIndex = 0;
        } else if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {
            newMode = CoreLibrary.InterestRateMode.VARIABLE;
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        } else {
            revert("Invalid interest rate mode received");
        }
        //compounding cumulated interest
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);
        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

        return newMode;
    }

    /**
    * @dev updates the state of the principal reserve as a consequence of a liquidation action.
    * @param _principalReserve the address of the principal reserve that is being repaid
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updatePrincipalReserveStateOnLiquidationInternal(
        address _principalReserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_principalReserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_principalReserve];

        //update principal reserve data
        reserve.updateCumulativeIndexes();

        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(
            _principalReserve,
            _user
        );

        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            //increase the total borrows by the compounded interest
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _balanceIncrease,
                user.stableBorrowRate
            );

            //decrease by the actual amount to liquidate
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _amountToLiquidate,
                user.stableBorrowRate
            );

        } else {
            //increase the total borrows by the compounded interest
            reserve.increaseTotalBorrowsVariable(_balanceIncrease);

            //decrease by the actual amount to liquidate
            reserve.decreaseTotalBorrowsVariable(_amountToLiquidate);
        }

    }

    /**
    * @dev updates the state of the collateral reserve as a consequence of a liquidation action.
    * @param _collateralReserve the address of the collateral reserve that is being liquidated
    **/
    function updateCollateralReserveStateOnLiquidationInternal(
        address _collateralReserve
    ) internal {
        //update collateral reserve
        reserves[_collateralReserve].updateCumulativeIndexes();

    }

    /**
    * @dev updates the state of the user being liquidated as a consequence of a liquidation action.
    * @param _reserve the address of the principal reserve that is being repaid
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _feeLiquidated the amount of origination fee being liquidated
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/
    function updateUserStateOnLiquidationInternal(
        address _reserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _feeLiquidated,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        //first increase by the compounded interest, then decrease by the liquidated amount
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(
            _amountToLiquidate
        );

        if (
            getUserCurrentBorrowRateMode(_reserve, _user) == CoreLibrary.InterestRateMode.VARIABLE
        ) {
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        }

        if(_feeLiquidated > 0){
            user.originationFee = user.originationFee.sub(_feeLiquidated);
        }

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);
    }

    /**
    * @dev updates the state of the reserve as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateReserveStateOnRebalanceInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        reserve.updateCumulativeIndexes();

        reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
            _balanceIncrease,
            user.stableBorrowRate
        );

    }

    /**
    * @dev updates the state of the user as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateUserStateOnRebalanceInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);
        user.stableBorrowRate = reserve.currentStableBorrowRate;

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);
    }

    /**
    * @dev updates the state of the user as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _amountBorrowed the accrued interest on the borrowed amount
    **/
    function updateReserveTotalBorrowsByRateModeInternal(
        address _reserve,
        address _user,
        uint256 _principalBalance,
        uint256 _balanceIncrease,
        uint256 _amountBorrowed,
        CoreLibrary.InterestRateMode _newBorrowRateMode
    ) internal {
        CoreLibrary.InterestRateMode previousRateMode = getUserCurrentBorrowRateMode(
            _reserve,
            _user
        );
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        if (previousRateMode == CoreLibrary.InterestRateMode.STABLE) {
            CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _principalBalance,
                user.stableBorrowRate
            );
        } else if (previousRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            reserve.decreaseTotalBorrowsVariable(_principalBalance);
        }

        uint256 newPrincipalAmount = _principalBalance.add(_balanceIncrease).add(_amountBorrowed);
        if (_newBorrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                newPrincipalAmount,
                reserve.currentStableBorrowRate
            );
        } else if (_newBorrowRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            reserve.increaseTotalBorrowsVariable(newPrincipalAmount);
        } else {
            revert("Invalid new borrow rate mode");
        }
    }

    /**
    * @dev Updates the reserve current stable borrow rate Rf, the current variable borrow rate Rv and the current liquidity rate Rl.
    * Also updates the lastUpdateTimestamp value. Please refer to the whitepaper for further information.
    * @param _reserve the address of the reserve to be updated
    * @param _liquidityAdded the amount of liquidity added to the protocol (deposit or repay) in the previous action
    * @param _liquidityTaken the amount of liquidity taken from the protocol (redeem or borrow)
    **/

    function updateReserveInterestRatesAndTimestampInternal(
        address _reserve,
        uint256 _liquidityAdded,
        uint256 _liquidityTaken
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        (uint256 newLiquidityRate, uint256 newStableRate, uint256 newVariableRate) = IReserveInterestRateStrategy(
            reserve
            .interestRateStrategyAddress
        )
        .calculateInterestRates(
            _reserve,
            getReserveAvailableLiquidity(_reserve).add(_liquidityAdded).sub(_liquidityTaken),
            reserve.totalBorrowsStable,
            reserve.totalBorrowsVariable,
            reserve.currentAverageStableBorrowRate
        );

        reserve.currentLiquidityRate = newLiquidityRate;
        reserve.currentStableBorrowRate = newStableRate;
        reserve.currentVariableBorrowRate = newVariableRate;

        //solium-disable-next-line
        reserve.lastUpdateTimestamp = uint40(block.timestamp);

        emit ReserveUpdated(
            _reserve,
            newLiquidityRate,
            newStableRate,
            newVariableRate,
            reserve.lastLiquidityCumulativeIndex,
            reserve.lastVariableBorrowCumulativeIndex
        );
    }

    /**
    * @dev transfers to the protocol fees of a flashloan to the fees collection address
    * @param _token the address of the token being transferred
    * @param _amount the amount being transferred
    **/

    function transferFlashLoanProtocolFeeInternal(address _token, uint256 _amount) internal {
        address payable receiver = address(uint160(addressesProvider.getTokenDistributor()));

        if (_token != EthAddressLib.ethAddress()) {
            ERC20(_token).safeTransfer(receiver, _amount);
        } else {
            receiver.transfer(_amount);
        }
    }

    /**
    * @dev updates the internal configuration of the core
    **/
    function refreshConfigInternal() internal {
        lendingPoolAddress = addressesProvider.getLendingPool();
    }

    /**
    * @dev adds a reserve to the array of the reserves address
    **/
    function addReserveToListInternal(address _reserve) internal {
        bool reserveAlreadyAdded = false;
        for (uint256 i = 0; i < reservesList.length; i++)
            if (reservesList[i] == _reserve) {
                reserveAlreadyAdded = true;
            }
        if (!reserveAlreadyAdded) reservesList.push(_reserve);
    }

}
.]

Security

[2024-01-09 04:31:25 INFO] **[Seminar Conclusion]**:

 Security

[2024-01-09 04:31:25 INFO] **[Seminar Conclusion]**:

 <INFO> Security

[2024-01-09 04:31:25 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 1

[2024-01-09 04:31:26 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | pragma solidity ^0.5.0; import "openzeppelin-solidity/contracts/math/SafeMath.sol"; import "openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol"; import "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol"; import "openzeppelin-solidity/contracts/utils/Address.sol"; import "../libraries/openzeppelin-upgradeability/VersionedInitializable.sol"; import "../libraries/CoreLibrary.sol"; import "../configuration/LendingPoolAddressesProvider.sol"; import "../interfaces/ILendingRateOracle.sol"; import "../interfaces/IReserveInterestRateStrategy.sol"; import "../libraries/WadRayMath.sol"; import "../tokenization/AToken.sol"; import "../libraries/EthAddressLib.sol"; / * @title LendingPoolCore contract * @author Aave * @notice Holds the state of the lending pool and all the funds deposited * @dev NOTE: The core does not enforce security checks on the update of the state * (eg, updateStateOnBorrow() does not enforce that borrowed is enabled on the reserve). * The check that an action can be performed is a duty of the overlying LendingPool contract. / contract LendingPoolCore is VersionedInitializable {     using SafeMath for uint256;     using WadRayMath for uint256;     using CoreLibrary for CoreLibrary.ReserveData;     using CoreLibrary for CoreLibrary.UserReserveData;     using SafeERC20 for ERC20;     using Address for address payable; /** * @dev Emitted when the state of a reserve is updated * @param reserve the address of the reserve * @param liquidityRate the new liquidity rate * @param stableBorrowRate the new stable borrow rate * @param variableBorrowRate the new variable borrow rate * @param liquidityIndex the new liquidity index * @param variableBorrowIndex the new variable borrow index **/ event ReserveUpdated(     address indexed reserve,     uint256 liquidityRate,     uint256 stableBorrowRate,     uint256 variableBorrowRate,     uint256 liquidityIndex,     uint256 variableBorrowIndex );  address public lendingPoolAddress;  LendingPoolAddressesProvider public addressesProvider;  /** * @dev only lending pools can use functions affected by this modifier **/ modifier onlyLendingPool {     require(lendingPoolAddress == msg.sender, "The caller must be a lending pool contract");     _; }  /** * @dev only lending pools configurator can use functions affected by this modifier **/ modifier onlyLendingPoolConfigurator {     require(         addressesProvider.getLendingPoolConfigurator() == msg.sender,         "The caller must be a lending pool configurator contract"     );     _; }  mapping(address =&gt; CoreLibrary.ReserveData) internal reserves; mapping(address =&gt; mapping(address =&gt; CoreLibrary.UserReserveData)) internal usersReserveData;  address[] public reservesList;  uint256 public constant CORE_REVISION = 0x4;  /** * @dev returns the revision number of the contract **/ function getRevision() internal pure returns (uint256) {     return CORE_REVISION; }  /** * @dev initializes the Core contract, invoked upon registration on the AddressesProvider * @param _addressesProvider the addressesProvider contract **/  function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {     addressesProvider = _addressesProvider;     refreshConfigInternal(); }  /** * @dev updates the state of the core as a result of a deposit action * @param _reserve the address of the reserve in which the deposit is happening * @param _user the address of the the user depositing * @param _amount the amount being deposited * @param _isFirstDeposit true if the user is depositing for the first time **/  function updateStateOnDeposit(     address _reserve,     address _user,     uint256 _amount,     bool _isFirstDeposit ) external onlyLendingPool {     reserves[_reserve].updateCumulativeIndexes();     updateReserveInterestRatesAndTimestampInternal(_reserve, _amount, 0);      if (_isFirstDeposit) {         //if this is the first deposit of the user, we configure the deposit as enabled to be used as collateral         setUserUseReserveAsCollateral(_reserve, _user, true);     } }  /** * @dev updates the state of the core as a result of a redeem action * @param _reserve the address of the reserve in which the redeem is happening * @param _user the address of the the user redeeming * @param _amountRedeemed the amount being redeemed * @param _userRedeemedEverything true if the user is redeeming everything **/ function updateStateOnRedeem(     address _reserve,     address _user,     uint256 _amountRedeemed,     bool _userRedeemedEverything ) external onlyLendingPool {     //compound liquidity and variable borrow interests     reserves[_reserve].updateCumulativeIndexes();     updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountRedeemed);      //if user redeemed everything the useReserveAsCollateral flag is reset     if (_userRedeemedEverything) {         setUserUseReserveAsCollateral(_reserve, _user, false);     } }  /** * @dev updates the state of the core as a result of a flashloan action * @param _reserve the address of the reserve in which the flashloan is happening * @param _income the income of the protocol as a result of the action **/ function updateStateOnFlashLoan(     address _reserve,     uint256 _availableLiquidityBefore,     uint256 _income,     uint256 _protocolFee ) external onlyLendingPool {     transferFlashLoanProtocolFeeInternal(_reserve, _protocolFee);      //compounding the cumulated interest     reserves[_reserve].updateCumulativeIndexes();      uint256 totalLiquidityBefore = _availableLiquidityBefore.add(         getReserveTotalBorrows(_reserve)     );      //compounding the received fee into the reserve     reserves[_reserve].cumulateToLiquidityIndex(totalLiquidityBefore, _income);      //refresh interest rates     updateReserveInterestRatesAndTimestampInternal(_reserve, _income, 0); }  /** * @dev updates the state of the core as a consequence of a borrow action. * @param _reserve the address of the reserve on which the user is borrowing * @param _user the address of the borrower * @param _amountBorrowed the new amount borrowed * @param _borrowFee the fee on the amount borrowed * @param _rateMode the borrow rate mode (stable, variable) * @return the new borrow rate for the user **/ function updateStateOnBorrow(     address _reserve,     address _user,     uint256 _amountBorrowed,     uint256 _borrowFee,     CoreLibrary.InterestRateMode _rateMode ) external onlyLendingPool returns (uint256, uint256) {     // getting the previous borrow data of the user     (uint256 principalBorrowBalance, , uint256 balanceIncrease) = getUserBorrowBalances(         _reserve,         _user     );      updateReserveStateOnBorrowInternal(         _reserve,         _user,         principalBorrowBalance,         balanceIncrease,         _amountBorrowed,         _rateMode     );      updateUserStateOnBorrowInternal(         _reserve,         _user,         _amountBorrowed,         balanceIncrease,         _borrowFee,         _rateMode     );      updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountBorrowed);      return (getUserCurrentBorrowRate(_reserve, _user), balanceIncrease); }  /** * @dev updates the state of the core as a consequence of a repay action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _paybackAmountMinusFees the amount being paid back minus fees * @param _originationFeeRepaid the fee on the amount that is being repaid * @param _balanceIncrease the accrued interest on the borrowed amount * @param _repaidWholeLoan true if the user is repaying the whole loan **/  function updateStateOnRepay(     address _reserve,     address _user,     uint256 _paybackAmountMinusFees,     uint256 _originationFeeRepaid,     uint256 _balanceIncrease,     bool _repaidWholeLoan ) external onlyLendingPool {     updateReserveStateOnRepayInternal(         _reserve,         _user,         _paybackAmountMinusFees,         _balanceIncrease     );     updateUserStateOnRepayInternal(         _reserve,         _user,         _paybackAmountMinusFees,         _originationFeeRepaid,         _balanceIncrease,         _repaidWholeLoan     );      updateReserveInterestRatesAndTimestampInternal(_reserve, _paybackAmountMinusFees, 0); }  /** * @dev updates the state of the core as a consequence of a swap rate action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _principalBorrowBalance the amount borrowed by the user * @param _compoundedBorrowBalance the amount borrowed plus accrued interest * @param _balanceIncrease the accrued interest on the borrowed amount * @param _currentRateMode the current interest rate mode for the user **/ function updateStateOnSwapRate(     address _reserve,     address _user,     uint256 _principalBorrowBalance,     uint256 _compoundedBorrowBalance,     uint256 _balanceIncrease,     CoreLibrary.InterestRateMode _currentRateMode ) external onlyLendingPool returns (CoreLibrary.InterestRateMode, uint256) {     updateReserveStateOnSwapRateInternal(         _reserve,         _user,         _principalBorrowBalance,         _compoundedBorrowBalance,         _currentRateMode     );      CoreLibrary.InterestRateMode newRateMode = updateUserStateOnSwapRateInternal(         _reserve,         _user,         _balanceIncrease,         _currentRateMode     );      updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);      return (newRateMode, getUserCurrentBorrowRate(_reserve, _user)); }  /** * @dev updates the state of the core as a consequence of a liquidation action. * @param _principalReserve the address of the principal reserve that is being repaid * @param _collateralReserve the address of the collateral reserve that is being liquidated * @param _user the address of the borrower * @param _amountToLiquidate the amount being repaid by the liquidator * @param _collateralToLiquidate the amount of collateral being liquidated * @param _feeLiquidated the amount of origination fee being liquidated * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus * @param _balanceIncrease the accrued interest on the borrowed amount * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise **/ function updateStateOnLiquidation(     address _principalReserve,     address _collateralReserve,     address _user,     uint256 _amountToLiquidate,     uint256 _collateralToLiquidate,     uint256 _feeLiquidated,     uint256 _liquidatedCollateralForFee,     uint256 _balanceIncrease,     bool _liquidatorReceivesAToken ) external onlyLendingPool {     updatePrincipalReserveStateOnLiquidationInternal(         _principalReserve,         _user,         _amountToLiquidate,         _balanceIncrease     );      updateCollateralReserveStateOnLiquidationInternal(         _collateralReserve     );      updateUserStateOnLiquidationInternal(         _principalReserve,         _user,         _amountToLiquidate,         _feeLiquidated,         _balanceIncrease     );      updateReserveInterestRatesAndTimestampInternal(_principalReserve, _amountToLiquidate, 0);      if (!_liquidatorReceivesAToken) {         updateReserveInterestRatesAndTimestampInternal(             _collateralReserve,             0,             _collateralToLiquidate.add(_liquidatedCollateralForFee)         );     }  }  /** * @dev updates the state of the core as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount * @return the new stable rate for the user **/ function updateStateOnRebalance(address _reserve, address _user, uint256 _balanceIncrease) external onlyLendingPool returns (uint256) {     updateReserveStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);      //update user data and rebalance the rate     updateUserStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);     updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);     return usersReserveData[_user][_reserve].stableBorrowRate; }  /** * @dev enables or disables a reserve as collateral * @param _reserve the address of the principal reserve where the user deposited * @param _user the address of the depositor * @param _useAsCollateral true if the depositor wants to use the reserve as collateral **/ function setUserUseReserveAsCollateral(address _reserve, address _user, bool _useAsCollateral) public onlyLendingPool {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     user.useAsCollateral = _useAsCollateral; }  /** * @notice ETH/token transfer functions **/  /** * @dev fallback function enforces that the caller is a contract, to support flashloan transfers **/ function() external payable {     //only contracts can send ETH to the core     require(msg.sender.isContract(), "Only contracts can send ether to the Lending pool core");  }  /** * @dev transfers to the user a specific amount from the reserve. * @param _reserve the address of the reserve where the transfer is happening * @param _user the address of the user receiving the transfer * @param _amount the amount being transferred **/ function transferToUser(address _reserve, address payable _user, uint256 _amount) external onlyLendingPool {     if (_reserve != EthAddressLib.ethAddress()) {         ERC20(_reserve).safeTransfer(_user, _amount);     } else {         //solium-disable-next-line         (bool result, ) = _user.call.value(_amount).gas(50000)("");         require(result, "Transfer of ETH failed");     } }  /** * @dev transfers the protocol fees to the fees collection address * @param _token the address of the token being transferred * @param _user the address of the user from where the transfer is happening * @param _amount the amount being transferred * @param _destination the fee receiver address **/  function transferToFeeCollectionAddress(     address _token,     address _user,     uint256 _amount,     address _destination ) external payable onlyLendingPool {     address payable feeAddress = address(uint160(_destination)); //cast the address to payable      if (_token != EthAddressLib.ethAddress()) {         require(             msg.value == 0,             "User is sending ETH along with the ERC20 transfer. Check the value attribute of the transaction"         );         ERC20(_token).safeTransferFrom(_user, feeAddress, _amount);     } else {         require(msg.value &gt;= _amount, "The amount and the value sent to deposit do not match");         //solium-disable-next-line         (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");         require(result, "Transfer of ETH failed");     } }  /** * @dev transfers the fees to the fees collection address in the case of liquidation * @param _token the address of the token being transferred * @param _amount the amount being transferred * @param _destination the fee receiver address **/ function liquidateFee(     address _token,     uint256 _amount,     address _destination ) external payable onlyLendingPool {     address payable feeAddress = address(uint160(_destination)); //cast the address to payable     require(         msg.value == 0,         "Fee liquidation does not require any transfer of value"     );      if (_token != EthAddressLib.ethAddress()) {         ERC20(_token).safeTransfer(feeAddress, _amount);     } else {         //solium-disable-next-line         (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");         require(result, "Transfer of ETH failed");     } }  /** * @dev transfers an amount from a user to the destination reserve * @param _reserve the address of the reserve where the amount is being transferred * @param _user the address of the user from where the transfer is happening * @param _amount the amount being transferred **/ function transferToReserve(address _reserve, address payable _user, uint256 _amount) external payable onlyLendingPool {     if (_reserve != EthAddressLib.ethAddress()) {         require(msg.value == 0, "User is sending ETH along with the ERC20 transfer.");         ERC20(_reserve).safeTransferFrom(_user, address(this), _amount);      } else {         require(msg.value &gt;= _amount, "The amount and the value sent to deposit do not match");          if (msg.value &gt; _amount) {             //send back excess ETH             uint256 excessAmount = msg.value.sub(_amount);             //solium-disable-next-line             (bool result, ) = _user.call.value(excessAmount).gas(50000)("");             require(result, "Transfer of ETH failed");         }     } }  /** * @notice data access functions **/  /** * @dev returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral) * needed to calculate the global account data in the LendingPoolDataProvider * @param _reserve the address of the reserve * @param _user the address of the user * @return the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not **/ function getUserBasicReserveData(address _reserve, address _user) external view returns (uint256, uint256, uint256, bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      uint256 underlyingBalance = getUserUnderlyingAssetBalance(_reserve, _user);      if (user.principalBorrowBalance == 0) {         return (underlyingBalance, 0, 0, user.useAsCollateral);     }      return (     underlyingBalance,     user.getCompoundedBorrowBalance(reserve),     user.originationFee,     user.useAsCollateral     ); }  /** * @dev checks if a user is allowed to borrow at a stable rate * @param _reserve the reserve address * @param _user the user * @param _amount the amount the the user wants to borrow * @return true if the user is allowed to borrow at a stable rate, false otherwise **/  function isUserAllowedToBorrowAtStable(address _reserve, address _user, uint256 _amount) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      if (!reserve.isStableBorrowRateEnabled) return false;      return     !user.useAsCollateral ||     !reserve.usageAsCollateralEnabled ||     _amount &gt; getUserUnderlyingAssetBalance(_reserve, _user); }  /** * @dev gets the underlying asset balance of a user based on the corresponding aToken balance. * @param _reserve the reserve address * @param _user the user address * @return the underlying deposit balance of the user **/  function getUserUnderlyingAssetBalance(address _reserve, address _user) public view returns (uint256) {     AToken aToken = AToken(reserves[_reserve].aTokenAddress);     return aToken.balanceOf(_user);  }  /** * @dev gets the interest rate strategy contract address for the reserve * @param _reserve the reserve address * @return the address of the interest rate strategy contract **/ function getReserveInterestRateStrategyAddress(address _reserve) public view returns (address) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.interestRateStrategyAddress; }  /** * @dev gets the aToken contract address for the reserve * @param _reserve the reserve address * @return the address of the aToken contract **/  function getReserveATokenAddress(address _reserve) public view returns (address) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.aTokenAddress; }  /** * @dev gets the available liquidity in the reserve. The available liquidity is the balance of the core contract * @param _reserve the reserve address * @return the available liquidity **/ function getReserveAvailableLiquidity(address _reserve) public view returns (uint256) {     uint256 balance = 0;      if (_reserve == EthAddressLib.ethAddress()) {         balance = address(this).balance;     } else {         balance = IERC20(_reserve).balanceOf(address(this));     }     return balance; }  /** * @dev gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows * @param _reserve the reserve address * @return the total liquidity **/ function getReserveTotalLiquidity(address _reserve) public view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return getReserveAvailableLiquidity(_reserve).add(reserve.getTotalBorrows()); }  /** * @dev gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there * there has been 100% income. * @param _reserve the reserve address * @return the reserve normalized income **/ function getReserveNormalizedIncome(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.getNormalizedIncome(); }  /** * @dev gets the reserve total borrows * @param _reserve the reserve address * @return the total borrows (stable + variable) **/ function getReserveTotalBorrows(address _reserve) public view returns (uint256) {     return reserves[_reserve].getTotalBorrows(); }  /** * @dev gets the reserve total borrows stable * @param _reserve the reserve address * @return the total borrows stable **/ function getReserveTotalBorrowsStable(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.totalBorrowsStable; }  /** * @dev gets the reserve total borrows variable * @param _reserve the reserve address * @return the total borrows variable **/  function getReserveTotalBorrowsVariable(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.totalBorrowsVariable; }  /** * @dev gets the reserve liquidation threshold * @param _reserve the reserve address * @return the reserve liquidation threshold **/  function getReserveLiquidationThreshold(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.liquidationThreshold; }  /** * @dev gets the reserve liquidation bonus * @param _reserve the reserve address * @return the reserve liquidation bonus **/  function getReserveLiquidationBonus(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.liquidationBonus; }  /** * @dev gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty * @param _reserve the reserve address * @return the reserve current variable borrow rate **/  function getReserveCurrentVariableBorrowRate(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      if (reserve.currentVariableBorrowRate == 0) {         return         IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)         .getBaseVariableBorrowRate();     }     return reserve.currentVariableBorrowRate; }  /** * @dev gets the reserve current stable borrow rate. Is the market rate if the reserve is empty * @param _reserve the reserve address * @return the reserve current stable borrow rate **/  function getReserveCurrentStableBorrowRate(address _reserve) public view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     ILendingRateOracle oracle = ILendingRateOracle(addressesProvider.getLendingRateOracle());      if (reserve.currentStableBorrowRate == 0) {         //no stable rate borrows yet         return oracle.getMarketBorrowRate(_reserve);     }      return reserve.currentStableBorrowRate; }  /** * @dev gets the reserve average stable borrow rate. The average stable rate is the weighted average * of all the loans taken at stable rate. * @param _reserve the reserve address * @return the reserve current average borrow rate **/ function getReserveCurrentAverageStableBorrowRate(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.currentAverageStableBorrowRate; }  /** * @dev gets the reserve liquidity rate * @param _reserve the reserve address * @return the reserve liquidity rate **/ function getReserveCurrentLiquidityRate(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.currentLiquidityRate; }  /** * @dev gets the reserve liquidity cumulative index * @param _reserve the reserve address * @return the reserve liquidity cumulative index **/ function getReserveLiquidityCumulativeIndex(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.lastLiquidityCumulativeIndex; }  /** * @dev gets the reserve variable borrow index * @param _reserve the reserve address * @return the reserve variable borrow index **/ function getReserveVariableBorrowsCumulativeIndex(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.lastVariableBorrowCumulativeIndex; }  /** * @dev this function aggregates the configuration parameters of the reserve. * It's used in the LendingPoolDataProvider specifically to save gas, and avoid * multiple external contract calls to fetch the same data. * @param _reserve the reserve address * @return the reserve decimals * @return the base ltv as collateral * @return the liquidation threshold * @return if the reserve is used as collateral or not **/ function getReserveConfiguration(address _reserve) external view returns (uint256, uint256, uint256, bool) {     uint256 decimals;     uint256 baseLTVasCollateral;     uint256 liquidationThreshold;     bool usageAsCollateralEnabled;      CoreLibrary.ReserveData storage reserve = reserves[_reserve];     decimals = reserve.decimals;     baseLTVasCollateral = reserve.baseLTVasCollateral;     liquidationThreshold = reserve.liquidationThreshold;     usageAsCollateralEnabled = reserve.usageAsCollateralEnabled;      return (decimals, baseLTVasCollateral, liquidationThreshold, usageAsCollateralEnabled); }  /** * @dev returns the decimals of the reserve * @param _reserve the reserve address * @return the reserve decimals **/ function getReserveDecimals(address _reserve) external view returns (uint256) {     return reserves[_reserve].decimals; }  /** * @dev returns true if the reserve is enabled for borrowing * @param _reserve the reserve address * @return true if the reserve is enabled for borrowing, false otherwise **/  function isReserveBorrowingEnabled(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.borrowingEnabled; }  /** * @dev returns true if the reserve is enabled as collateral * @param _reserve the reserve address * @return true if the reserve is enabled as collateral, false otherwise **/  function isReserveUsageAsCollateralEnabled(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.usageAsCollateralEnabled; }  /** * @dev returns true if the stable rate is enabled on reserve * @param _reserve the reserve address * @return true if the stable rate is enabled on reserve, false otherwise **/ function getReserveIsStableBorrowRateEnabled(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.isStableBorrowRateEnabled; }  /** * @dev returns true if the reserve is active * @param _reserve the reserve address * @return true if the reserve is active, false otherwise **/ function getReserveIsActive(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.isActive; }  /** * @notice returns if a reserve is freezed * @param _reserve the reserve for which the information is needed * @return true if the reserve is freezed, false otherwise **/  function getReserveIsFreezed(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.isFreezed; }  /** * @notice returns the timestamp of the last action on the reserve * @param _reserve the reserve for which the information is needed * @return the last updated timestamp of the reserve **/  function getReserveLastUpdate(address _reserve) external view returns (uint40 timestamp) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     timestamp = reserve.lastUpdateTimestamp; }  /** * @dev returns the utilization rate U of a specific reserve * @param _reserve the reserve for which the information is needed * @return the utilization rate in ray **/  function getReserveUtilizationRate(address _reserve) public view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      uint256 totalBorrows = reserve.getTotalBorrows();      if (totalBorrows == 0) {         return 0;     }      uint256 availableLiquidity = getReserveAvailableLiquidity(_reserve);      return totalBorrows.rayDiv(availableLiquidity.add(totalBorrows)); }  /** * @return the array of reserves configured on the core **/ function getReserves() external view returns (address[] memory) {     return reservesList; }  /** * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return true if the user has chosen to use the reserve as collateral, false otherwise **/ function isUserUseReserveAsCollateralEnabled(address _reserve, address _user) external view returns (bool) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.useAsCollateral; }  /** * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the origination fee for the user **/ function getUserOriginationFee(address _reserve, address _user) external view returns (uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.originationFee; }  /** * @dev users with no loans in progress have NONE as borrow rate mode * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the borrow rate mode for the user, **/  function getUserCurrentBorrowRateMode(address _reserve, address _user) public view returns (CoreLibrary.InterestRateMode) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      if (user.principalBorrowBalance == 0) {         return CoreLibrary.InterestRateMode.NONE;     }      return     user.stableBorrowRate &gt; 0     ? CoreLibrary.InterestRateMode.STABLE     : CoreLibrary.InterestRateMode.VARIABLE; }  /** * @dev gets the current borrow rate of the user * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the borrow rate for the user, **/ function getUserCurrentBorrowRate(address _reserve, address _user) internal view returns (uint256) {     CoreLibrary.InterestRateMode rateMode = getUserCurrentBorrowRateMode(_reserve, _user);      if (rateMode == CoreLibrary.InterestRateMode.NONE) {         return 0;     }      return     rateMode == CoreLibrary.InterestRateMode.STABLE     ? usersReserveData[_user][_reserve].stableBorrowRate     : reserves[_reserve].currentVariableBorrowRate; }  /** * @dev the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the user stable rate **/ function getUserCurrentStableBorrowRate(address _reserve, address _user) external view returns (uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.stableBorrowRate; }  /** * @dev calculates and returns the borrow balances of the user * @param _reserve the address of the reserve * @param _user the address of the user * @return the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance **/  function getUserBorrowBalances(address _reserve, address _user) public view returns (uint256, uint256, uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     if (user.principalBorrowBalance == 0) {         return (0, 0, 0);     }      uint256 principal = user.principalBorrowBalance;     uint256 compoundedBalance = CoreLibrary.getCompoundedBorrowBalance(         user,         reserves[_reserve]     );     return (principal, compoundedBalance, compoundedBalance.sub(principal)); }  /** * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the variable borrow index for the user **/  function getUserVariableBorrowCumulativeIndex(address _reserve, address _user) external view returns (uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.lastVariableBorrowCumulativeIndex; }  /** * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the variable borrow index for the user **/  function getUserLastUpdate(address _reserve, address _user) external view returns (uint256 timestamp) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     timestamp = user.lastUpdateTimestamp; }  /** * @dev updates the lending pool core configuration **/ function refreshConfiguration() external onlyLendingPoolConfigurator {     refreshConfigInternal(); }  /** * @dev initializes a reserve * @param _reserve the address of the reserve * @param _aTokenAddress the address of the overlying aToken contract * @param _decimals the decimals of the reserve currency * @param _interestRateStrategyAddress the address of the interest rate strategy contract **/ function initReserve(     address _reserve,     address _aTokenAddress,     uint256 _decimals,     address _interestRateStrategyAddress ) external onlyLendingPoolConfigurator {     reserves[_reserve].init(_aTokenAddress, _decimals, _interestRateStrategyAddress);     addReserveToListInternal(_reserve);  }    /** * @dev removes the last added reserve in the reservesList array * @param _reserveToRemove the address of the reserve **/ function removeLastAddedReserve(address _reserveToRemove) external onlyLendingPoolConfigurator {      address lastReserve = reservesList[reservesList.length-1];      require(lastReserve == _reserveToRemove, "Reserve being removed is different than the reserve requested");      //as we can't check if totalLiquidity is 0 (since the reserve added might not be an ERC20) we at least check that there is nothing borrowed     require(getReserveTotalBorrows(lastReserve) == 0, "Cannot remove a reserve with liquidity deposited");      reserves[lastReserve].isActive = false;     reserves[lastReserve].aTokenAddress = address(0);     reserves[lastReserve].decimals = 0;     reserves[lastReserve].lastLiquidityCumulativeIndex = 0;     reserves[lastReserve].lastVariableBorrowCumulativeIndex = 0;     reserves[lastReserve].borrowingEnabled = false;     reserves[lastReserve].usageAsCollateralEnabled = false;     reserves[lastReserve].baseLTVasCollateral = 0;     reserves[lastReserve].liquidationThreshold = 0;     reserves[lastReserve].liquidationBonus = 0;     reserves[lastReserve].interestRateStrategyAddress = address(0);      reservesList.pop(); }  /** * @dev updates the address of the interest rate strategy contract * @param _reserve the address of the reserve * @param _rateStrategyAddress the address of the interest rate strategy contract **/  function setReserveInterestRateStrategyAddress(address _reserve, address _rateStrategyAddress) external onlyLendingPoolConfigurator {     reserves[_reserve].interestRateStrategyAddress = _rateStrategyAddress; }  /** * @dev enables borrowing on a reserve. Also sets the stable rate borrowing * @param _reserve the address of the reserve * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise **/  function enableBorrowingOnReserve(address _reserve, bool _stableBorrowRateEnabled) external onlyLendingPoolConfigurator {     reserves[_reserve].enableBorrowing(_stableBorrowRateEnabled); }  /** * @dev disables borrowing on a reserve * @param _reserve the address of the reserve **/  function disableBorrowingOnReserve(address _reserve) external onlyLendingPoolConfigurator {     reserves[_reserve].disableBorrowing(); }  /** * @dev enables a reserve to be used as collateral * @param _reserve the address of the reserve **/ function enableReserveAsCollateral(     address _reserve,     uint256 _baseLTVasCollateral,     uint256 _liquidationThreshold,     uint256 _liquidationBonus ) external onlyLendingPoolConfigurator {     reserves[_reserve].enableAsCollateral(         _baseLTVasCollateral,         _liquidationThreshold,         _liquidationBonus     ); }  /** * @dev disables a reserve to be used as collateral * @param _reserve the address of the reserve **/ function disableReserveAsCollateral(address _reserve) external onlyLendingPoolConfigurator {     reserves[_reserve].disableAsCollateral(); }  /** * @dev enable the stable borrow rate mode on a reserve * @param _reserve the address of the reserve **/ function enableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isStableBorrowRateEnabled = true; }  /** * @dev disable the stable borrow rate mode on a reserve * @param _reserve the address of the reserve **/ function disableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isStableBorrowRateEnabled = false; }  /** * @dev activates a reserve * @param _reserve the address of the reserve **/ function activateReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      require(         reserve.lastLiquidityCumulativeIndex &gt; 0 &amp;&amp;         reserve.lastVariableBorrowCumulativeIndex &gt; 0,         "Reserve has not been initialized yet"     );     reserve.isActive = true; }  /** * @dev deactivates a reserve * @param _reserve the address of the reserve **/ function deactivateReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isActive = false; }  /** * @notice allows the configurator to freeze the reserve. * A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance. * @param _reserve the address of the reserve **/ function freezeReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isFreezed = true; }  /** * @notice allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed. * @param _reserve the address of the reserve **/ function unfreezeReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isFreezed = false; }  /** * @notice allows the configurator to update the loan to value of a reserve * @param _reserve the address of the reserve * @param _ltv the new loan to value **/ function setReserveBaseLTVasCollateral(address _reserve, uint256 _ltv) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.baseLTVasCollateral = _ltv; }  /** * @notice allows the configurator to update the liquidation threshold of a reserve * @param _reserve the address of the reserve * @param _threshold the new liquidation threshold **/ function setReserveLiquidationThreshold(address _reserve, uint256 _threshold) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.liquidationThreshold = _threshold; }  /** * @notice allows the configurator to update the liquidation bonus of a reserve * @param _reserve the address of the reserve * @param _bonus the new liquidation bonus **/ function setReserveLiquidationBonus(address _reserve, uint256 _bonus) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.liquidationBonus = _bonus; }  /** * @notice allows the configurator to update the reserve decimals * @param _reserve the address of the reserve * @param _decimals the decimals of the reserve **/ function setReserveDecimals(address _reserve, uint256 _decimals) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.decimals = _decimals; }  /** * @notice internal functions **/  /** * @dev updates the state of a reserve as a consequence of a borrow action. * @param _reserve the address of the reserve on which the user is borrowing * @param _user the address of the borrower * @param _principalBorrowBalance the previous borrow balance of the borrower before the action * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount * @param _amountBorrowed the new amount borrowed * @param _rateMode the borrow rate mode (stable, variable) **/  function updateReserveStateOnBorrowInternal(     address _reserve,     address _user,     uint256 _principalBorrowBalance,     uint256 _balanceIncrease,     uint256 _amountBorrowed,     CoreLibrary.InterestRateMode _rateMode ) internal {     reserves[_reserve].updateCumulativeIndexes();      //increasing reserve total borrows to account for the new borrow balance of the user     //NOTE: Depending on the previous borrow mode, the borrows might need to be switched from variable to stable or vice versa      updateReserveTotalBorrowsByRateModeInternal(         _reserve,         _user,         _principalBorrowBalance,         _balanceIncrease,         _amountBorrowed,         _rateMode     ); }  /** * @dev updates the state of a user as a consequence of a borrow action. * @param _reserve the address of the reserve on which the user is borrowing * @param _user the address of the borrower * @param _amountBorrowed the amount borrowed * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount * @param _rateMode the borrow rate mode (stable, variable) * @return the final borrow rate for the user. Emitted by the borrow() event **/  function updateUserStateOnBorrowInternal(     address _reserve,     address _user,     uint256 _amountBorrowed,     uint256 _balanceIncrease,     uint256 _fee,     CoreLibrary.InterestRateMode _rateMode ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      if (_rateMode == CoreLibrary.InterestRateMode.STABLE) {         //stable         //reset the user variable index, and update the stable rate         user.stableBorrowRate = reserve.currentStableBorrowRate;         user.lastVariableBorrowCumulativeIndex = 0;     } else if (_rateMode == CoreLibrary.InterestRateMode.VARIABLE) {         //variable         //reset the user stable rate, and store the new borrow index         user.stableBorrowRate = 0;         user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;     } else {         revert("Invalid borrow rate mode");     }     //increase the principal borrows and the origination fee     user.principalBorrowBalance = user.principalBorrowBalance.add(_amountBorrowed).add(         _balanceIncrease     );     user.originationFee = user.originationFee.add(_fee);      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp);  }  /** * @dev updates the state of the reserve as a consequence of a repay action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _paybackAmountMinusFees the amount being paid back minus fees * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updateReserveStateOnRepayInternal(     address _reserve,     address _user,     uint256 _paybackAmountMinusFees,     uint256 _balanceIncrease ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_reserve][_user];      CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(_reserve, _user);      //update the indexes     reserves[_reserve].updateCumulativeIndexes();      //compound the cumulated interest to the borrow balance and then subtracting the payback amount     if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             _balanceIncrease,             user.stableBorrowRate         );         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _paybackAmountMinusFees,             user.stableBorrowRate         );     } else {         reserve.increaseTotalBorrowsVariable(_balanceIncrease);         reserve.decreaseTotalBorrowsVariable(_paybackAmountMinusFees);     } }  /** * @dev updates the state of the user as a consequence of a repay action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _paybackAmountMinusFees the amount being paid back minus fees * @param _originationFeeRepaid the fee on the amount that is being repaid * @param _balanceIncrease the accrued interest on the borrowed amount * @param _repaidWholeLoan true if the user is repaying the whole loan **/ function updateUserStateOnRepayInternal(     address _reserve,     address _user,     uint256 _paybackAmountMinusFees,     uint256 _originationFeeRepaid,     uint256 _balanceIncrease,     bool _repaidWholeLoan ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      //update the user principal borrow balance, adding the cumulated interest and then subtracting the payback amount     user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(         _paybackAmountMinusFees     );     user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;      //if the balance decrease is equal to the previous principal (user is repaying the whole loan)     //and the rate mode is stable, we reset the interest rate mode of the user     if (_repaidWholeLoan) {         user.stableBorrowRate = 0;         user.lastVariableBorrowCumulativeIndex = 0;     }     user.originationFee = user.originationFee.sub(_originationFeeRepaid);      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp);  }  /** * @dev updates the state of the user as a consequence of a swap rate action. * @param _reserve the address of the reserve on which the user is performing the rate swap * @param _user the address of the borrower * @param _principalBorrowBalance the the principal amount borrowed by the user * @param _compoundedBorrowBalance the principal amount plus the accrued interest * @param _currentRateMode the rate mode at which the user borrowed **/ function updateReserveStateOnSwapRateInternal(     address _reserve,     address _user,     uint256 _principalBorrowBalance,     uint256 _compoundedBorrowBalance,     CoreLibrary.InterestRateMode _currentRateMode ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      //compounding reserve indexes     reserve.updateCumulativeIndexes();      if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {         uint256 userCurrentStableRate = user.stableBorrowRate;          //swap to variable         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _principalBorrowBalance,             userCurrentStableRate         ); //decreasing stable from old principal balance         reserve.increaseTotalBorrowsVariable(_compoundedBorrowBalance); //increase variable borrows     } else if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         //swap to stable         uint256 currentStableRate = reserve.currentStableBorrowRate;         reserve.decreaseTotalBorrowsVariable(_principalBorrowBalance);         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             _compoundedBorrowBalance,             currentStableRate         );      } else {         revert("Invalid rate mode received");     } }  /** * @dev updates the state of the user as a consequence of a swap rate action. * @param _reserve the address of the reserve on which the user is performing the swap * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount * @param _currentRateMode the current rate mode of the user **/  function updateUserStateOnSwapRateInternal(     address _reserve,     address _user,     uint256 _balanceIncrease,     CoreLibrary.InterestRateMode _currentRateMode ) internal returns (CoreLibrary.InterestRateMode) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      CoreLibrary.InterestRateMode newMode = CoreLibrary.InterestRateMode.NONE;      if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         //switch to stable         newMode = CoreLibrary.InterestRateMode.STABLE;         user.stableBorrowRate = reserve.currentStableBorrowRate;         user.lastVariableBorrowCumulativeIndex = 0;     } else if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {         newMode = CoreLibrary.InterestRateMode.VARIABLE;         user.stableBorrowRate = 0;         user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;     } else {         revert("Invalid interest rate mode received");     }     //compounding cumulated interest     user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);     //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp);      return newMode; }  /** * @dev updates the state of the principal reserve as a consequence of a liquidation action. * @param _principalReserve the address of the principal reserve that is being repaid * @param _user the address of the borrower * @param _amountToLiquidate the amount being repaid by the liquidator * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updatePrincipalReserveStateOnLiquidationInternal(     address _principalReserve,     address _user,     uint256 _amountToLiquidate,     uint256 _balanceIncrease ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_principalReserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_principalReserve];      //update principal reserve data     reserve.updateCumulativeIndexes();      CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(         _principalReserve,         _user     );      if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {         //increase the total borrows by the compounded interest         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             _balanceIncrease,             user.stableBorrowRate         );          //decrease by the actual amount to liquidate         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _amountToLiquidate,             user.stableBorrowRate         );      } else {         //increase the total borrows by the compounded interest         reserve.increaseTotalBorrowsVariable(_balanceIncrease);          //decrease by the actual amount to liquidate         reserve.decreaseTotalBorrowsVariable(_amountToLiquidate);     }  }  /** * @dev updates the state of the collateral reserve as a consequence of a liquidation action. * @param _collateralReserve the address of the collateral reserve that is being liquidated **/ function updateCollateralReserveStateOnLiquidationInternal(     address _collateralReserve ) internal {     //update collateral reserve     reserves[_collateralReserve].updateCumulativeIndexes();  }  /** * @dev updates the state of the user being liquidated as a consequence of a liquidation action. * @param _reserve the address of the principal reserve that is being repaid * @param _user the address of the borrower * @param _amountToLiquidate the amount being repaid by the liquidator * @param _feeLiquidated the amount of origination fee being liquidated * @param _balanceIncrease the accrued interest on the borrowed amount **/ function updateUserStateOnLiquidationInternal(     address _reserve,     address _user,     uint256 _amountToLiquidate,     uint256 _feeLiquidated,     uint256 _balanceIncrease ) internal {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     //first increase by the compounded interest, then decrease by the liquidated amount     user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(         _amountToLiquidate     );      if (         getUserCurrentBorrowRateMode(_reserve, _user) == CoreLibrary.InterestRateMode.VARIABLE     ) {         user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;     }      if(_feeLiquidated &gt; 0){         user.originationFee = user.originationFee.sub(_feeLiquidated);     }      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp); }  /** * @dev updates the state of the reserve as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updateReserveStateOnRebalanceInternal(     address _reserve,     address _user,     uint256 _balanceIncrease ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      reserve.updateCumulativeIndexes();      reserve.increaseTotalBorrowsStableAndUpdateAverageRate(         _balanceIncrease,         user.stableBorrowRate     );  }  /** * @dev updates the state of the user as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updateUserStateOnRebalanceInternal(     address _reserve,     address _user,     uint256 _balanceIncrease ) internal {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);     user.stableBorrowRate = reserve.currentStableBorrowRate;      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp); }  /** * @dev updates the state of the user as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount * @param _amountBorrowed the accrued interest on the borrowed amount **/ function updateReserveTotalBorrowsByRateModeInternal(     address _reserve,     address _user,     uint256 _principalBalance,     uint256 _balanceIncrease,     uint256 _amountBorrowed,     CoreLibrary.InterestRateMode _newBorrowRateMode ) internal {     CoreLibrary.InterestRateMode previousRateMode = getUserCurrentBorrowRateMode(         _reserve,         _user     );     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      if (previousRateMode == CoreLibrary.InterestRateMode.STABLE) {         CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _principalBalance,             user.stableBorrowRate         );     } else if (previousRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         reserve.decreaseTotalBorrowsVariable(_principalBalance);     }      uint256 newPrincipalAmount = _principalBalance.add(_balanceIncrease).add(_amountBorrowed);     if (_newBorrowRateMode == CoreLibrary.InterestRateMode.STABLE) {         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             newPrincipalAmount,             reserve.currentStableBorrowRate         );     } else if (_newBorrowRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         reserve.increaseTotalBorrowsVariable(newPrincipalAmount);     } else {         revert("Invalid new borrow rate mode");     } }  /** * @dev Updates the reserve current stable borrow rate Rf, the current variable borrow rate Rv and the current liquidity rate Rl. * Also updates the lastUpdateTimestamp value. Please refer to the whitepaper for further information. * @param _reserve the address of the reserve to be updated * @param _liquidityAdded the amount of liquidity added to the protocol (deposit or repay) in the previous action * @param _liquidityTaken the amount of liquidity taken from the protocol (redeem or borrow) **/  function updateReserveInterestRatesAndTimestampInternal(     address _reserve,     uint256 _liquidityAdded,     uint256 _liquidityTaken ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     (uint256 newLiquidityRate, uint256 newStableRate, uint256 newVariableRate) = IReserveInterestRateStrategy(         reserve         .interestRateStrategyAddress     )     .calculateInterestRates(         _reserve,         getReserveAvailableLiquidity(_reserve).add(_liquidityAdded).sub(_liquidityTaken),         reserve.totalBorrowsStable,         reserve.totalBorrowsVariable,         reserve.currentAverageStableBorrowRate     );      reserve.currentLiquidityRate = newLiquidityRate;     reserve.currentStableBorrowRate = newStableRate;     reserve.currentVariableBorrowRate = newVariableRate;      //solium-disable-next-line     reserve.lastUpdateTimestamp = uint40(block.timestamp);      emit ReserveUpdated(         _reserve,         newLiquidityRate,         newStableRate,         newVariableRate,         reserve.lastLiquidityCumulativeIndex,         reserve.lastVariableBorrowCumulativeIndex     ); }  /** * @dev transfers to the protocol fees of a flashloan to the fees collection address * @param _token the address of the token being transferred * @param _amount the amount being transferred **/  function transferFlashLoanProtocolFeeInternal(address _token, uint256 _amount) internal {     address payable receiver = address(uint160(addressesProvider.getTokenDistributor()));      if (_token != EthAddressLib.ethAddress()) {         ERC20(_token).safeTransfer(receiver, _amount);     } else {         receiver.transfer(_amount);     } }  /** * @dev updates the internal configuration of the core **/ function refreshConfigInternal() internal {     lendingPoolAddress = addressesProvider.getLendingPool(); }  /** * @dev adds a reserve to the array of the reserves address **/ function addReserveToListInternal(address _reserve) internal {     bool reserveAlreadyAdded = false;     for (uint256 i = 0; i &lt; reservesList.length; i++)         if (reservesList[i] == _reserve) {             reserveAlreadyAdded = true;         }     if (!reserveAlreadyAdded) reservesList.push(_reserve); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': 'pragma solidity ^0.5.0;\n\nimport "openzeppelin-solidity/contracts/math/SafeMath.sol";\nimport "openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol";\nimport "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol";\nimport "openzeppelin-solidity/contracts/utils/Address.sol";\nimport "../libraries/openzeppelin-upgradeability/VersionedInitializable.sol";\n\nimport "../libraries/CoreLibrary.sol";\nimport "../configuration/LendingPoolAddressesProvider.sol";\nimport "../interfaces/ILendingRateOracle.sol";\nimport "../interfaces/IReserveInterestRateStrategy.sol";\nimport "../libraries/WadRayMath.sol";\nimport "../tokenization/AToken.sol";\nimport "../libraries/EthAddressLib.sol";\n\n/\n @title LendingPoolCore contract\n @author Aave\n @notice Holds the state of the lending pool and all the funds deposited\n @dev NOTE: The core does not enforce security checks on the update of the state\n (eg, updateStateOnBorrow() does not enforce that borrowed is enabled on the reserve).\n The check that an action can be performed is a duty of the overlying LendingPool contract.\n/\n\ncontract LendingPoolCore is VersionedInitializable {\n    using SafeMath for uint256;\n    using WadRayMath for uint256;\n    using CoreLibrary for CoreLibrary.ReserveData;\n    using CoreLibrary for CoreLibrary.UserReserveData;\n    using SafeERC20 for ERC20;\n    using Address for address payable;\n\n    /\n    * @dev Emitted when the state of a reserve is updated\n    * @param reserve the address of the reserve\n    * @param liquidityRate the new liquidity rate\n    * @param stableBorrowRate the new stable borrow rate\n    * @param variableBorrowRate the new variable borrow rate\n    * @param liquidityIndex the new liquidity index\n    * @param variableBorrowIndex the new variable borrow index\n    /\n    event ReserveUpdated(\n        address indexed reserve,\n        uint256 liquidityRate,\n        uint256 stableBorrowRate,\n        uint256 variableBorrowRate,\n        uint256 liquidityIndex,\n        uint256 variableBorrowIndex\n    );\n\n    address public lendingPoolAddress;\n\n    LendingPoolAddressesProvider public addressesProvider;\n\n    /\n    * @dev only lending pools can use functions affected by this modifier\n    /\n    modifier onlyLendingPool {\n        require(lendingPoolAddress == msg.sender, "The caller must be a lending pool contract");\n        ;\n    }\n\n    /\n    * @dev only lending pools configurator can use functions affected by this modifier\n    /\n    modifier onlyLendingPoolConfigurator {\n        require(\n            addressesProvider.getLendingPoolConfigurator() == msg.sender,\n            "The caller must be a lending pool configurator contract"\n        );\n        ;\n    }\n\n    mapping(address =&gt; CoreLibrary.ReserveData) internal reserves;\n    mapping(address =&gt; mapping(address =&gt; CoreLibrary.UserReserveData)) internal usersReserveData;\n\n    address[] public reservesList;\n\n    uint256 public constant CORE_REVISION = 0x4;\n\n    /\n    * @dev returns the revision number of the contract\n    /\n    function getRevision() internal pure returns (uint256) {\n        return CORE_REVISION;\n    }\n\n    /\n    * @dev initializes the Core contract, invoked upon registration on the AddressesProvider\n    * @param _addressesProvider the addressesProvider contract\n    /\n\n    function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {\n        addressesProvider = _addressesProvider;\n        refreshConfigInternal();\n    }\n\n    /\n    * @dev updates the state of the core as a result of a deposit action\n    * @param _reserve the address of the reserve in which the deposit is happening\n    * @param _user the address of the the user depositing\n    * @param _amount the amount being deposited\n    * @param _isFirstDeposit true if the user is depositing for the first time\n    /\n\n    function updateStateOnDeposit(\n        address _reserve,\n        address _user,\n        uint256 _amount,\n        bool _isFirstDeposit\n    ) external onlyLendingPool {\n        reserves[_reserve].updateCumulativeIndexes();\n        updateReserveInterestRatesAndTimestampInternal(_reserve, _amount, 0);\n\n        if (_isFirstDeposit) {\n            //if this is the first deposit of the user, we configure the deposit as enabled to be used as collateral\n            setUserUseReserveAsCollateral(_reserve, _user, true);\n        }\n    }\n\n    /\n    * @dev updates the state of the core as a result of a redeem action\n    * @param _reserve the address of the reserve in which the redeem is happening\n    * @param _user the address of the the user redeeming\n    * @param _amountRedeemed the amount being redeemed\n    * @param _userRedeemedEverything true if the user is redeeming everything\n    /\n    function updateStateOnRedeem(\n        address _reserve,\n        address _user,\n        uint256 _amountRedeemed,\n        bool _userRedeemedEverything\n    ) external onlyLendingPool {\n        //compound liquidity and variable borrow interests\n        reserves[_reserve].updateCumulativeIndexes();\n        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountRedeemed);\n\n        //if user redeemed everything the useReserveAsCollateral flag is reset\n        if (_userRedeemedEverything) {\n            setUserUseReserveAsCollateral(_reserve, _user, false);\n        }\n    }\n\n    /\n    * @dev updates the state of the core as a result of a flashloan action\n    * @param _reserve the address of the reserve in which the flashloan is happening\n    * @param _income the income of the protocol as a result of the action\n    /\n    function updateStateOnFlashLoan(\n        address _reserve,\n        uint256 _availableLiquidityBefore,\n        uint256 _income,\n        uint256 _protocolFee\n    ) external onlyLendingPool {\n        transferFlashLoanProtocolFeeInternal(_reserve, _protocolFee);\n\n        //compounding the cumulated interest\n        reserves[_reserve].updateCumulativeIndexes();\n\n        uint256 totalLiquidityBefore = _availableLiquidityBefore.add(\n            getReserveTotalBorrows(_reserve)\n        );\n\n        //compounding the received fee into the reserve\n        reserves[_reserve].cumulateToLiquidityIndex(totalLiquidityBefore, _income);\n\n        //refresh interest rates\n        updateReserveInterestRatesAndTimestampInternal(_reserve, _income, 0);\n    }\n\n    /\n    * @dev updates the state of the core as a consequence of a borrow action.\n    * @param _reserve the address of the reserve on which the user is borrowing\n    * @param _user the address of the borrower\n    * @param _amountBorrowed the new amount borrowed\n    * @param _borrowFee the fee on the amount borrowed\n    * @param _rateMode the borrow rate mode (stable, variable)\n    * @return the new borrow rate for the user\n    /\n    function updateStateOnBorrow(\n        address _reserve,\n        address _user,\n        uint256 _amountBorrowed,\n        uint256 _borrowFee,\n        CoreLibrary.InterestRateMode _rateMode\n    ) external onlyLendingPool returns (uint256, uint256) {\n        // getting the previous borrow data of the user\n        (uint256 principalBorrowBalance, , uint256 balanceIncrease) = getUserBorrowBalances(\n            _reserve,\n            _user\n        );\n\n        updateReserveStateOnBorrowInternal(\n            _reserve,\n            _user,\n            principalBorrowBalance,\n            balanceIncrease,\n            _amountBorrowed,\n            _rateMode\n        );\n\n        updateUserStateOnBorrowInternal(\n            _reserve,\n            _user,\n            _amountBorrowed,\n            balanceIncrease,\n            _borrowFee,\n            _rateMode\n        );\n\n        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountBorrowed);\n\n        return (getUserCurrentBorrowRate(_reserve, _user), balanceIncrease);\n    }\n\n    /\n    * @dev updates the state of the core as a consequence of a repay action.\n    * @param _reserve the address of the reserve on which the user is repaying\n    * @param _user the address of the borrower\n    * @param _paybackAmountMinusFees the amount being paid back minus fees\n    * @param _originationFeeRepaid the fee on the amount that is being repaid\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    * @param _repaidWholeLoan true if the user is repaying the whole loan\n    /\n\n    function updateStateOnRepay(\n        address _reserve,\n        address _user,\n        uint256 _paybackAmountMinusFees,\n        uint256 _originationFeeRepaid,\n        uint256 _balanceIncrease,\n        bool _repaidWholeLoan\n    ) external onlyLendingPool {\n        updateReserveStateOnRepayInternal(\n            _reserve,\n            _user,\n            _paybackAmountMinusFees,\n            _balanceIncrease\n        );\n        updateUserStateOnRepayInternal(\n            _reserve,\n            _user,\n            _paybackAmountMinusFees,\n            _originationFeeRepaid,\n            _balanceIncrease,\n            _repaidWholeLoan\n        );\n\n        updateReserveInterestRatesAndTimestampInternal(_reserve, _paybackAmountMinusFees, 0);\n    }\n\n    /\n    * @dev updates the state of the core as a consequence of a swap rate action.\n    * @param _reserve the address of the reserve on which the user is repaying\n    * @param _user the address of the borrower\n    * @param _principalBorrowBalance the amount borrowed by the user\n    * @param _compoundedBorrowBalance the amount borrowed plus accrued interest\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    * @param _currentRateMode the current interest rate mode for the user\n    /\n    function updateStateOnSwapRate(\n        address _reserve,\n        address _user,\n        uint256 _principalBorrowBalance,\n        uint256 _compoundedBorrowBalance,\n        uint256 _balanceIncrease,\n        CoreLibrary.InterestRateMode _currentRateMode\n    ) external onlyLendingPool returns (CoreLibrary.InterestRateMode, uint256) {\n        updateReserveStateOnSwapRateInternal(\n            _reserve,\n            _user,\n            _principalBorrowBalance,\n            _compoundedBorrowBalance,\n            _currentRateMode\n        );\n\n        CoreLibrary.InterestRateMode newRateMode = updateUserStateOnSwapRateInternal(\n            _reserve,\n            _user,\n            _balanceIncrease,\n            _currentRateMode\n        );\n\n        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);\n\n        return (newRateMode, getUserCurrentBorrowRate(_reserve, _user));\n    }\n\n    /\n    * @dev updates the state of the core as a consequence of a liquidation action.\n    * @param _principalReserve the address of the principal reserve that is being repaid\n    * @param _collateralReserve the address of the collateral reserve that is being liquidated\n    * @param _user the address of the borrower\n    * @param _amountToLiquidate the amount being repaid by the liquidator\n    * @param _collateralToLiquidate the amount of collateral being liquidated\n    * @param _feeLiquidated the amount of origination fee being liquidated\n    * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise\n    /\n    function updateStateOnLiquidation(\n        address _principalReserve,\n        address _collateralReserve,\n        address _user,\n        uint256 _amountToLiquidate,\n        uint256 _collateralToLiquidate,\n        uint256 _feeLiquidated,\n        uint256 _liquidatedCollateralForFee,\n        uint256 _balanceIncrease,\n        bool _liquidatorReceivesAToken\n    ) external onlyLendingPool {\n        updatePrincipalReserveStateOnLiquidationInternal(\n            _principalReserve,\n            _user,\n            _amountToLiquidate,\n            _balanceIncrease\n        );\n\n        updateCollateralReserveStateOnLiquidationInternal(\n            _collateralReserve\n        );\n\n        updateUserStateOnLiquidationInternal(\n            _principalReserve,\n            _user,\n            _amountToLiquidate,\n            _feeLiquidated,\n            _balanceIncrease\n        );\n\n        updateReserveInterestRatesAndTimestampInternal(_principalReserve, _amountToLiquidate, 0);\n\n        if (!_liquidatorReceivesAToken) {\n            updateReserveInterestRatesAndTimestampInternal(\n                _collateralReserve,\n                0,\n                _collateralToLiquidate.add(_liquidatedCollateralForFee)\n            );\n        }\n\n    }\n\n    /\n    * @dev updates the state of the core as a consequence of a stable rate rebalance\n    * @param _reserve the address of the principal reserve where the user borrowed\n    * @param _user the address of the borrower\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    * @return the new stable rate for the user\n    /\n    function updateStateOnRebalance(address _reserve, address _user, uint256 _balanceIncrease)\n    external\n    onlyLendingPool\n    returns (uint256)\n    {\n        updateReserveStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);\n\n        //update user data and rebalance the rate\n        updateUserStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);\n        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);\n        return usersReserveData[_user][_reserve].stableBorrowRate;\n    }\n\n    /\n    * @dev enables or disables a reserve as collateral\n    * @param _reserve the address of the principal reserve where the user deposited\n    * @param _user the address of the depositor\n    * @param _useAsCollateral true if the depositor wants to use the reserve as collateral\n    /\n    function setUserUseReserveAsCollateral(address _reserve, address _user, bool _useAsCollateral)\n    public\n    onlyLendingPool\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        user.useAsCollateral = _useAsCollateral;\n    }\n\n    /\n    * @notice ETH/token transfer functions\n    /\n\n    /\n    * @dev fallback function enforces that the caller is a contract, to support flashloan transfers\n    /\n    function() external payable {\n        //only contracts can send ETH to the core\n        require(msg.sender.isContract(), "Only contracts can send ether to the Lending pool core");\n\n    }\n\n    /\n    * @dev transfers to the user a specific amount from the reserve.\n    * @param _reserve the address of the reserve where the transfer is happening\n    * @param _user the address of the user receiving the transfer\n    * @param _amount the amount being transferred\n    /\n    function transferToUser(address _reserve, address payable _user, uint256 _amount)\n    external\n    onlyLendingPool\n    {\n        if (_reserve != EthAddressLib.ethAddress()) {\n            ERC20(_reserve).safeTransfer(_user, _amount);\n        } else {\n            //solium-disable-next-line\n            (bool result, ) = _user.call.value(_amount).gas(50000)("");\n            require(result, "Transfer of ETH failed");\n        }\n    }\n\n    /\n    * @dev transfers the protocol fees to the fees collection address\n    * @param _token the address of the token being transferred\n    * @param _user the address of the user from where the transfer is happening\n    * @param _amount the amount being transferred\n    * @param _destination the fee receiver address\n    /\n\n    function transferToFeeCollectionAddress(\n        address _token,\n        address _user,\n        uint256 _amount,\n        address _destination\n    ) external payable onlyLendingPool {\n        address payable feeAddress = address(uint160(_destination)); //cast the address to payable\n\n        if (_token != EthAddressLib.ethAddress()) {\n            require(\n                msg.value == 0,\n                "User is sending ETH along with the ERC20 transfer. Check the value attribute of the transaction"\n            );\n            ERC20(_token).safeTransferFrom(_user, feeAddress, _amount);\n        } else {\n            require(msg.value &gt;= _amount, "The amount and the value sent to deposit do not match");\n            //solium-disable-next-line\n            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");\n            require(result, "Transfer of ETH failed");\n        }\n    }\n\n    /\n    * @dev transfers the fees to the fees collection address in the case of liquidation\n    * @param _token the address of the token being transferred\n    * @param _amount the amount being transferred\n    * @param _destination the fee receiver address\n    /\n    function liquidateFee(\n        address _token,\n        uint256 _amount,\n        address _destination\n    ) external payable onlyLendingPool {\n        address payable feeAddress = address(uint160(_destination)); //cast the address to payable\n        require(\n            msg.value == 0,\n            "Fee liquidation does not require any transfer of value"\n        );\n\n        if (_token != EthAddressLib.ethAddress()) {\n            ERC20(_token).safeTransfer(feeAddress, _amount);\n        } else {\n            //solium-disable-next-line\n            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");\n            require(result, "Transfer of ETH failed");\n        }\n    }\n\n    /\n    * @dev transfers an amount from a user to the destination reserve\n    * @param _reserve the address of the reserve where the amount is being transferred\n    * @param _user the address of the user from where the transfer is happening\n    * @param _amount the amount being transferred\n    /\n    function transferToReserve(address _reserve, address payable _user, uint256 _amount)\n    external\n    payable\n    onlyLendingPool\n    {\n        if (_reserve != EthAddressLib.ethAddress()) {\n            require(msg.value == 0, "User is sending ETH along with the ERC20 transfer.");\n            ERC20(_reserve).safeTransferFrom(_user, address(this), _amount);\n\n        } else {\n            require(msg.value &gt;= _amount, "The amount and the value sent to deposit do not match");\n\n            if (msg.value &gt; _amount) {\n                //send back excess ETH\n                uint256 excessAmount = msg.value.sub(_amount);\n                //solium-disable-next-line\n                (bool result, ) = _user.call.value(excessAmount).gas(50000)("");\n                require(result, "Transfer of ETH failed");\n            }\n        }\n    }\n\n    /\n    * @notice data access functions\n    /\n\n    /\n    * @dev returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral)\n    * needed to calculate the global account data in the LendingPoolDataProvider\n    * @param _reserve the address of the reserve\n    * @param _user the address of the user\n    * @return the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not\n    /\n    function getUserBasicReserveData(address _reserve, address _user)\n    external\n    view\n    returns (uint256, uint256, uint256, bool)\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n\n        uint256 underlyingBalance = getUserUnderlyingAssetBalance(_reserve, _user);\n\n        if (user.principalBorrowBalance == 0) {\n            return (underlyingBalance, 0, 0, user.useAsCollateral);\n        }\n\n        return (\n        underlyingBalance,\n        user.getCompoundedBorrowBalance(reserve),\n        user.originationFee,\n        user.useAsCollateral\n        );\n    }\n\n    /\n    * @dev checks if a user is allowed to borrow at a stable rate\n    * @param _reserve the reserve address\n    * @param _user the user\n    * @param _amount the amount the the user wants to borrow\n    * @return true if the user is allowed to borrow at a stable rate, false otherwise\n    /\n\n    function isUserAllowedToBorrowAtStable(address _reserve, address _user, uint256 _amount)\n    external\n    view\n    returns (bool)\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n\n        if (!reserve.isStableBorrowRateEnabled) return false;\n\n        return\n        !user.useAsCollateral ||\n        !reserve.usageAsCollateralEnabled ||\n        _amount &gt; getUserUnderlyingAssetBalance(_reserve, _user);\n    }\n\n    /\n    * @dev gets the underlying asset balance of a user based on the corresponding aToken balance.\n    * @param _reserve the reserve address\n    * @param _user the user address\n    * @return the underlying deposit balance of the user\n    /\n\n    function getUserUnderlyingAssetBalance(address _reserve, address _user)\n    public\n    view\n    returns (uint256)\n    {\n        AToken aToken = AToken(reserves[_reserve].aTokenAddress);\n        return aToken.balanceOf(_user);\n\n    }\n\n    /\n    * @dev gets the interest rate strategy contract address for the reserve\n    * @param _reserve the reserve address\n    * @return the address of the interest rate strategy contract\n    /\n    function getReserveInterestRateStrategyAddress(address _reserve) public view returns (address) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.interestRateStrategyAddress;\n    }\n\n    /\n    * @dev gets the aToken contract address for the reserve\n    * @param _reserve the reserve address\n    * @return the address of the aToken contract\n    /\n\n    function getReserveATokenAddress(address _reserve) public view returns (address) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.aTokenAddress;\n    }\n\n    /\n    * @dev gets the available liquidity in the reserve. The available liquidity is the balance of the core contract\n    * @param _reserve the reserve address\n    * @return the available liquidity\n    /\n    function getReserveAvailableLiquidity(address _reserve) public view returns (uint256) {\n        uint256 balance = 0;\n\n        if (_reserve == EthAddressLib.ethAddress()) {\n            balance = address(this).balance;\n        } else {\n            balance = IERC20(_reserve).balanceOf(address(this));\n        }\n        return balance;\n    }\n\n    /\n    * @dev gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows\n    * @param _reserve the reserve address\n    * @return the total liquidity\n    /\n    function getReserveTotalLiquidity(address _reserve) public view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return getReserveAvailableLiquidity(_reserve).add(reserve.getTotalBorrows());\n    }\n\n    /\n    * @dev gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there\n    * there has been 100% income.\n    * @param _reserve the reserve address\n    * @return the reserve normalized income\n    /\n    function getReserveNormalizedIncome(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.getNormalizedIncome();\n    }\n\n    /\n    * @dev gets the reserve total borrows\n    * @param _reserve the reserve address\n    * @return the total borrows (stable + variable)\n    /\n    function getReserveTotalBorrows(address _reserve) public view returns (uint256) {\n        return reserves[_reserve].getTotalBorrows();\n    }\n\n    /\n    * @dev gets the reserve total borrows stable\n    * @param _reserve the reserve address\n    * @return the total borrows stable\n    /\n    function getReserveTotalBorrowsStable(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.totalBorrowsStable;\n    }\n\n    /\n    * @dev gets the reserve total borrows variable\n    * @param _reserve the reserve address\n    * @return the total borrows variable\n    /\n\n    function getReserveTotalBorrowsVariable(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.totalBorrowsVariable;\n    }\n\n    /\n    * @dev gets the reserve liquidation threshold\n    * @param _reserve the reserve address\n    * @return the reserve liquidation threshold\n    /\n\n    function getReserveLiquidationThreshold(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.liquidationThreshold;\n    }\n\n    /\n    * @dev gets the reserve liquidation bonus\n    * @param _reserve the reserve address\n    * @return the reserve liquidation bonus\n    /\n\n    function getReserveLiquidationBonus(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.liquidationBonus;\n    }\n\n    /\n    * @dev gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty\n    * @param _reserve the reserve address\n    * @return the reserve current variable borrow rate\n    /\n\n    function getReserveCurrentVariableBorrowRate(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n\n        if (reserve.currentVariableBorrowRate == 0) {\n            return\n            IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)\n            .getBaseVariableBorrowRate();\n        }\n        return reserve.currentVariableBorrowRate;\n    }\n\n    /\n    * @dev gets the reserve current stable borrow rate. Is the market rate if the reserve is empty\n    * @param _reserve the reserve address\n    * @return the reserve current stable borrow rate\n    /\n\n    function getReserveCurrentStableBorrowRate(address _reserve) public view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        ILendingRateOracle oracle = ILendingRateOracle(addressesProvider.getLendingRateOracle());\n\n        if (reserve.currentStableBorrowRate == 0) {\n            //no stable rate borrows yet\n            return oracle.getMarketBorrowRate(_reserve);\n        }\n\n        return reserve.currentStableBorrowRate;\n    }\n\n    /\n    * @dev gets the reserve average stable borrow rate. The average stable rate is the weighted average\n    * of all the loans taken at stable rate.\n    * @param _reserve the reserve address\n    * @return the reserve current average borrow rate\n    /\n    function getReserveCurrentAverageStableBorrowRate(address _reserve)\n    external\n    view\n    returns (uint256)\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.currentAverageStableBorrowRate;\n    }\n\n    /\n    * @dev gets the reserve liquidity rate\n    * @param _reserve the reserve address\n    * @return the reserve liquidity rate\n    /\n    function getReserveCurrentLiquidityRate(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.currentLiquidityRate;\n    }\n\n    /\n    * @dev gets the reserve liquidity cumulative index\n    * @param _reserve the reserve address\n    * @return the reserve liquidity cumulative index\n    /\n    function getReserveLiquidityCumulativeIndex(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.lastLiquidityCumulativeIndex;\n    }\n\n    /\n    * @dev gets the reserve variable borrow index\n    * @param _reserve the reserve address\n    * @return the reserve variable borrow index\n    /\n    function getReserveVariableBorrowsCumulativeIndex(address _reserve)\n    external\n    view\n    returns (uint256)\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.lastVariableBorrowCumulativeIndex;\n    }\n\n    /\n    * @dev this function aggregates the configuration parameters of the reserve.\n    * It\'s used in the LendingPoolDataProvider specifically to save gas, and avoid\n    * multiple external contract calls to fetch the same data.\n    * @param _reserve the reserve address\n    * @return the reserve decimals\n    * @return the base ltv as collateral\n    * @return the liquidation threshold\n    * @return if the reserve is used as collateral or not\n    /\n    function getReserveConfiguration(address _reserve)\n    external\n    view\n    returns (uint256, uint256, uint256, bool)\n    {\n        uint256 decimals;\n        uint256 baseLTVasCollateral;\n        uint256 liquidationThreshold;\n        bool usageAsCollateralEnabled;\n\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        decimals = reserve.decimals;\n        baseLTVasCollateral = reserve.baseLTVasCollateral;\n        liquidationThreshold = reserve.liquidationThreshold;\n        usageAsCollateralEnabled = reserve.usageAsCollateralEnabled;\n\n        return (decimals, baseLTVasCollateral, liquidationThreshold, usageAsCollateralEnabled);\n    }\n\n    /\n    * @dev returns the decimals of the reserve\n    * @param _reserve the reserve address\n    * @return the reserve decimals\n    /\n    function getReserveDecimals(address _reserve) external view returns (uint256) {\n        return reserves[_reserve].decimals;\n    }\n\n    /\n    * @dev returns true if the reserve is enabled for borrowing\n    * @param _reserve the reserve address\n    * @return true if the reserve is enabled for borrowing, false otherwise\n    /\n\n    function isReserveBorrowingEnabled(address _reserve) external view returns (bool) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.borrowingEnabled;\n    }\n\n    /\n    * @dev returns true if the reserve is enabled as collateral\n    * @param _reserve the reserve address\n    * @return true if the reserve is enabled as collateral, false otherwise\n    /\n\n    function isReserveUsageAsCollateralEnabled(address _reserve) external view returns (bool) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.usageAsCollateralEnabled;\n    }\n\n    /\n    * @dev returns true if the stable rate is enabled on reserve\n    * @param _reserve the reserve address\n    * @return true if the stable rate is enabled on reserve, false otherwise\n    /\n    function getReserveIsStableBorrowRateEnabled(address _reserve) external view returns (bool) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.isStableBorrowRateEnabled;\n    }\n\n    /\n    * @dev returns true if the reserve is active\n    * @param _reserve the reserve address\n    * @return true if the reserve is active, false otherwise\n    /\n    function getReserveIsActive(address _reserve) external view returns (bool) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.isActive;\n    }\n\n    /\n    * @notice returns if a reserve is freezed\n    * @param _reserve the reserve for which the information is needed\n    * @return true if the reserve is freezed, false otherwise\n    /\n\n    function getReserveIsFreezed(address _reserve) external view returns (bool) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.isFreezed;\n    }\n\n    /\n    * @notice returns the timestamp of the last action on the reserve\n    * @param _reserve the reserve for which the information is needed\n    * @return the last updated timestamp of the reserve\n    /\n\n    function getReserveLastUpdate(address _reserve) external view returns (uint40 timestamp) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        timestamp = reserve.lastUpdateTimestamp;\n    }\n\n    /\n    * @dev returns the utilization rate U of a specific reserve\n    * @param _reserve the reserve for which the information is needed\n    * @return the utilization rate in ray\n    /\n\n    function getReserveUtilizationRate(address _reserve) public view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n\n        uint256 totalBorrows = reserve.getTotalBorrows();\n\n        if (totalBorrows == 0) {\n            return 0;\n        }\n\n        uint256 availableLiquidity = getReserveAvailableLiquidity(_reserve);\n\n        return totalBorrows.rayDiv(availableLiquidity.add(totalBorrows));\n    }\n\n    /\n    * @return the array of reserves configured on the core\n    /\n    function getReserves() external view returns (address[] memory) {\n        return reservesList;\n    }\n\n    /\n    * @param _reserve the address of the reserve for which the information is needed\n    * @param _user the address of the user for which the information is needed\n    * @return true if the user has chosen to use the reserve as collateral, false otherwise\n    /\n    function isUserUseReserveAsCollateralEnabled(address _reserve, address _user)\n    external\n    view\n    returns (bool)\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        return user.useAsCollateral;\n    }\n\n    /\n    * @param _reserve the address of the reserve for which the information is needed\n    * @param _user the address of the user for which the information is needed\n    * @return the origination fee for the user\n    /\n    function getUserOriginationFee(address _reserve, address _user)\n    external\n    view\n    returns (uint256)\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        return user.originationFee;\n    }\n\n    /\n    * @dev users with no loans in progress have NONE as borrow rate mode\n    * @param _reserve the address of the reserve for which the information is needed\n    * @param _user the address of the user for which the information is needed\n    * @return the borrow rate mode for the user,\n    /\n\n    function getUserCurrentBorrowRateMode(address _reserve, address _user)\n    public\n    view\n    returns (CoreLibrary.InterestRateMode)\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n\n        if (user.principalBorrowBalance == 0) {\n            return CoreLibrary.InterestRateMode.NONE;\n        }\n\n        return\n        user.stableBorrowRate &gt; 0\n        ? CoreLibrary.InterestRateMode.STABLE\n        : CoreLibrary.InterestRateMode.VARIABLE;\n    }\n\n    /\n    * @dev gets the current borrow rate of the user\n    * @param _reserve the address of the reserve for which the information is needed\n    * @param _user the address of the user for which the information is needed\n    * @return the borrow rate for the user,\n    /\n    function getUserCurrentBorrowRate(address _reserve, address _user)\n    internal\n    view\n    returns (uint256)\n    {\n        CoreLibrary.InterestRateMode rateMode = getUserCurrentBorrowRateMode(_reserve, _user);\n\n        if (rateMode == CoreLibrary.InterestRateMode.NONE) {\n            return 0;\n        }\n\n        return\n        rateMode == CoreLibrary.InterestRateMode.STABLE\n        ? usersReserveData[_user][_reserve].stableBorrowRate\n        : reserves[_reserve].currentVariableBorrowRate;\n    }\n\n    /\n    * @dev the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all\n    * @param _reserve the address of the reserve for which the information is needed\n    * @param _user the address of the user for which the information is needed\n    * @return the user stable rate\n    /\n    function getUserCurrentStableBorrowRate(address _reserve, address _user)\n    external\n    view\n    returns (uint256)\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        return user.stableBorrowRate;\n    }\n\n    /\n    * @dev calculates and returns the borrow balances of the user\n    * @param _reserve the address of the reserve\n    * @param _user the address of the user\n    * @return the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance\n    /\n\n    function getUserBorrowBalances(address _reserve, address _user)\n    public\n    view\n    returns (uint256, uint256, uint256)\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        if (user.principalBorrowBalance == 0) {\n            return (0, 0, 0);\n        }\n\n        uint256 principal = user.principalBorrowBalance;\n        uint256 compoundedBalance = CoreLibrary.getCompoundedBorrowBalance(\n            user,\n            reserves[_reserve]\n        );\n        return (principal, compoundedBalance, compoundedBalance.sub(principal));\n    }\n\n    /\n    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable\n    * @param _reserve the address of the reserve for which the information is needed\n    * @param _user the address of the user for which the information is needed\n    * @return the variable borrow index for the user\n    /\n\n    function getUserVariableBorrowCumulativeIndex(address _reserve, address _user)\n    external\n    view\n    returns (uint256)\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        return user.lastVariableBorrowCumulativeIndex;\n    }\n\n    /\n    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable\n    * @param _reserve the address of the reserve for which the information is needed\n    * @param _user the address of the user for which the information is needed\n    * @return the variable borrow index for the user\n    /\n\n    function getUserLastUpdate(address _reserve, address _user)\n    external\n    view\n    returns (uint256 timestamp)\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        timestamp = user.lastUpdateTimestamp;\n    }\n\n    /\n    * @dev updates the lending pool core configuration\n    /\n    function refreshConfiguration() external onlyLendingPoolConfigurator {\n        refreshConfigInternal();\n    }\n\n    /\n    * @dev initializes a reserve\n    * @param _reserve the address of the reserve\n    * @param _aTokenAddress the address of the overlying aToken contract\n    * @param _decimals the decimals of the reserve currency\n    * @param _interestRateStrategyAddress the address of the interest rate strategy contract\n    /\n    function initReserve(\n        address _reserve,\n        address _aTokenAddress,\n        uint256 _decimals,\n        address _interestRateStrategyAddress\n    ) external onlyLendingPoolConfigurator {\n        reserves[_reserve].init(_aTokenAddress, _decimals, _interestRateStrategyAddress);\n        addReserveToListInternal(_reserve);\n\n    }\n\n\n\n    /\n    * @dev removes the last added reserve in the reservesList array\n    * @param _reserveToRemove the address of the reserve\n    /\n    function removeLastAddedReserve(address _reserveToRemove)\n    external onlyLendingPoolConfigurator {\n\n        address lastReserve = reservesList[reservesList.length-1];\n\n        require(lastReserve == _reserveToRemove, "Reserve being removed is different than the reserve requested");\n\n        //as we can\'t check if totalLiquidity is 0 (since the reserve added might not be an ERC20) we at least check that there is nothing borrowed\n        require(getReserveTotalBorrows(lastReserve) == 0, "Cannot remove a reserve with liquidity deposited");\n\n        reserves[lastReserve].isActive = false;\n        reserves[lastReserve].aTokenAddress = address(0);\n        reserves[lastReserve].decimals = 0;\n        reserves[lastReserve].lastLiquidityCumulativeIndex = 0;\n        reserves[lastReserve].lastVariableBorrowCumulativeIndex = 0;\n        reserves[lastReserve].borrowingEnabled = false;\n        reserves[lastReserve].usageAsCollateralEnabled = false;\n        reserves[lastReserve].baseLTVasCollateral = 0;\n        reserves[lastReserve].liquidationThreshold = 0;\n        reserves[lastReserve].liquidationBonus = 0;\n        reserves[lastReserve].interestRateStrategyAddress = address(0);\n\n        reservesList.pop();\n    }\n\n    /\n    * @dev updates the address of the interest rate strategy contract\n    * @param _reserve the address of the reserve\n    * @param _rateStrategyAddress the address of the interest rate strategy contract\n    /\n\n    function setReserveInterestRateStrategyAddress(address _reserve, address _rateStrategyAddress)\n    external\n    onlyLendingPoolConfigurator\n    {\n        reserves[_reserve].interestRateStrategyAddress = _rateStrategyAddress;\n    }\n\n    /\n    * @dev enables borrowing on a reserve. Also sets the stable rate borrowing\n    * @param _reserve the address of the reserve\n    * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise\n    /\n\n    function enableBorrowingOnReserve(address _reserve, bool _stableBorrowRateEnabled)\n    external\n    onlyLendingPoolConfigurator\n    {\n        reserves[_reserve].enableBorrowing(_stableBorrowRateEnabled);\n    }\n\n    /\n    * @dev disables borrowing on a reserve\n    * @param _reserve the address of the reserve\n    /\n\n    function disableBorrowingOnReserve(address _reserve) external onlyLendingPoolConfigurator {\n        reserves[_reserve].disableBorrowing();\n    }\n\n    /\n    * @dev enables a reserve to be used as collateral\n    * @param _reserve the address of the reserve\n    /\n    function enableReserveAsCollateral(\n        address _reserve,\n        uint256 _baseLTVasCollateral,\n        uint256 _liquidationThreshold,\n        uint256 _liquidationBonus\n    ) external onlyLendingPoolConfigurator {\n        reserves[_reserve].enableAsCollateral(\n            _baseLTVasCollateral,\n            _liquidationThreshold,\n            _liquidationBonus\n        );\n    }\n\n    /\n    * @dev disables a reserve to be used as collateral\n    * @param _reserve the address of the reserve\n    /\n    function disableReserveAsCollateral(address _reserve) external onlyLendingPoolConfigurator {\n        reserves[_reserve].disableAsCollateral();\n    }\n\n    /\n    * @dev enable the stable borrow rate mode on a reserve\n    * @param _reserve the address of the reserve\n    /\n    function enableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.isStableBorrowRateEnabled = true;\n    }\n\n    /\n    * @dev disable the stable borrow rate mode on a reserve\n    * @param _reserve the address of the reserve\n    /\n    function disableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.isStableBorrowRateEnabled = false;\n    }\n\n    /\n    * @dev activates a reserve\n    * @param _reserve the address of the reserve\n    /\n    function activateReserve(address _reserve) external onlyLendingPoolConfigurator {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n\n        require(\n            reserve.lastLiquidityCumulativeIndex &gt; 0 &amp;&amp;\n            reserve.lastVariableBorrowCumulativeIndex &gt; 0,\n            "Reserve has not been initialized yet"\n        );\n        reserve.isActive = true;\n    }\n\n    /\n    * @dev deactivates a reserve\n    * @param _reserve the address of the reserve\n    /\n    function deactivateReserve(address _reserve) external onlyLendingPoolConfigurator {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.isActive = false;\n    }\n\n    /\n    * @notice allows the configurator to freeze the reserve.\n    * A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance.\n    * @param _reserve the address of the reserve\n    /\n    function freezeReserve(address _reserve) external onlyLendingPoolConfigurator {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.isFreezed = true;\n    }\n\n    /\n    * @notice allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed.\n    * @param _reserve the address of the reserve\n    /\n    function unfreezeReserve(address _reserve) external onlyLendingPoolConfigurator {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.isFreezed = false;\n    }\n\n    /\n    * @notice allows the configurator to update the loan to value of a reserve\n    * @param _reserve the address of the reserve\n    * @param _ltv the new loan to value\n    /\n    function setReserveBaseLTVasCollateral(address _reserve, uint256 _ltv)\n    external\n    onlyLendingPoolConfigurator\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.baseLTVasCollateral = _ltv;\n    }\n\n    /\n    * @notice allows the configurator to update the liquidation threshold of a reserve\n    * @param _reserve the address of the reserve\n    * @param _threshold the new liquidation threshold\n    /\n    function setReserveLiquidationThreshold(address _reserve, uint256 _threshold)\n    external\n    onlyLendingPoolConfigurator\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.liquidationThreshold = _threshold;\n    }\n\n    /\n    * @notice allows the configurator to update the liquidation bonus of a reserve\n    * @param _reserve the address of the reserve\n    * @param _bonus the new liquidation bonus\n    /\n    function setReserveLiquidationBonus(address _reserve, uint256 _bonus)\n    external\n    onlyLendingPoolConfigurator\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.liquidationBonus = _bonus;\n    }\n\n    /\n    * @notice allows the configurator to update the reserve decimals\n    * @param _reserve the address of the reserve\n    * @param _decimals the decimals of the reserve\n    /\n    function setReserveDecimals(address _reserve, uint256 _decimals)\n    external\n    onlyLendingPoolConfigurator\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.decimals = _decimals;\n    }\n\n    /\n    * @notice internal functions\n    /\n\n    /\n    * @dev updates the state of a reserve as a consequence of a borrow action.\n    * @param _reserve the address of the reserve on which the user is borrowing\n    * @param _user the address of the borrower\n    * @param _principalBorrowBalance the previous borrow balance of the borrower before the action\n    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount\n    * @param _amountBorrowed the new amount borrowed\n    * @param _rateMode the borrow rate mode (stable, variable)\n    /\n\n    function updateReserveStateOnBorrowInternal(\n        address _reserve,\n        address _user,\n        uint256 _principalBorrowBalance,\n        uint256 _balanceIncrease,\n        uint256 _amountBorrowed,\n        CoreLibrary.InterestRateMode _rateMode\n    ) internal {\n        reserves[_reserve].updateCumulativeIndexes();\n\n        //increasing reserve total borrows to account for the new borrow balance of the user\n        //NOTE: Depending on the previous borrow mode, the borrows might need to be switched from variable to stable or vice versa\n\n        updateReserveTotalBorrowsByRateModeInternal(\n            _reserve,\n            _user,\n            _principalBorrowBalance,\n            _balanceIncrease,\n            _amountBorrowed,\n            _rateMode\n        );\n    }\n\n    /\n    * @dev updates the state of a user as a consequence of a borrow action.\n    * @param _reserve the address of the reserve on which the user is borrowing\n    * @param _user the address of the borrower\n    * @param _amountBorrowed the amount borrowed\n    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount\n    * @param _rateMode the borrow rate mode (stable, variable)\n    * @return the final borrow rate for the user. Emitted by the borrow() event\n    /\n\n    function updateUserStateOnBorrowInternal(\n        address _reserve,\n        address _user,\n        uint256 _amountBorrowed,\n        uint256 _balanceIncrease,\n        uint256 _fee,\n        CoreLibrary.InterestRateMode _rateMode\n    ) internal {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n\n        if (_rateMode == CoreLibrary.InterestRateMode.STABLE) {\n            //stable\n            //reset the user variable index, and update the stable rate\n            user.stableBorrowRate = reserve.currentStableBorrowRate;\n            user.lastVariableBorrowCumulativeIndex = 0;\n        } else if (_rateMode == CoreLibrary.InterestRateMode.VARIABLE) {\n            //variable\n            //reset the user stable rate, and store the new borrow index\n            user.stableBorrowRate = 0;\n            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;\n        } else {\n            revert("Invalid borrow rate mode");\n        }\n        //increase the principal borrows and the origination fee\n        user.principalBorrowBalance = user.principalBorrowBalance.add(_amountBorrowed).add(\n            _balanceIncrease\n        );\n        user.originationFee = user.originationFee.add(_fee);\n\n        //solium-disable-next-line\n        user.lastUpdateTimestamp = uint40(block.timestamp);\n\n    }\n\n    /\n    * @dev updates the state of the reserve as a consequence of a repay action.\n    * @param _reserve the address of the reserve on which the user is repaying\n    * @param _user the address of the borrower\n    * @param _paybackAmountMinusFees the amount being paid back minus fees\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    /\n\n    function updateReserveStateOnRepayInternal(\n        address _reserve,\n        address _user,\n        uint256 _paybackAmountMinusFees,\n        uint256 _balanceIncrease\n    ) internal {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_reserve][_user];\n\n        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(_reserve, _user);\n\n        //update the indexes\n        reserves[_reserve].updateCumulativeIndexes();\n\n        //compound the cumulated interest to the borrow balance and then subtracting the payback amount\n        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {\n            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(\n                _balanceIncrease,\n                user.stableBorrowRate\n            );\n            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(\n                _paybackAmountMinusFees,\n                user.stableBorrowRate\n            );\n        } else {\n            reserve.increaseTotalBorrowsVariable(_balanceIncrease);\n            reserve.decreaseTotalBorrowsVariable(_paybackAmountMinusFees);\n        }\n    }\n\n    /\n    * @dev updates the state of the user as a consequence of a repay action.\n    * @param _reserve the address of the reserve on which the user is repaying\n    * @param _user the address of the borrower\n    * @param _paybackAmountMinusFees the amount being paid back minus fees\n    * @param _originationFeeRepaid the fee on the amount that is being repaid\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    * @param _repaidWholeLoan true if the user is repaying the whole loan\n    /\n    function updateUserStateOnRepayInternal(\n        address _reserve,\n        address _user,\n        uint256 _paybackAmountMinusFees,\n        uint256 _originationFeeRepaid,\n        uint256 _balanceIncrease,\n        bool _repaidWholeLoan\n    ) internal {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n\n        //update the user principal borrow balance, adding the cumulated interest and then subtracting the payback amount\n        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(\n            _paybackAmountMinusFees\n        );\n        user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;\n\n        //if the balance decrease is equal to the previous principal (user is repaying the whole loan)\n        //and the rate mode is stable, we reset the interest rate mode of the user\n        if (_repaidWholeLoan) {\n            user.stableBorrowRate = 0;\n            user.lastVariableBorrowCumulativeIndex = 0;\n        }\n        user.originationFee = user.originationFee.sub(_originationFeeRepaid);\n\n        //solium-disable-next-line\n        user.lastUpdateTimestamp = uint40(block.timestamp);\n\n    }\n\n    /\n    * @dev updates the state of the user as a consequence of a swap rate action.\n    * @param _reserve the address of the reserve on which the user is performing the rate swap\n    * @param _user the address of the borrower\n    * @param _principalBorrowBalance the the principal amount borrowed by the user\n    * @param _compoundedBorrowBalance the principal amount plus the accrued interest\n    * @param _currentRateMode the rate mode at which the user borrowed\n    /\n    function updateReserveStateOnSwapRateInternal(\n        address _reserve,\n        address _user,\n        uint256 _principalBorrowBalance,\n        uint256 _compoundedBorrowBalance,\n        CoreLibrary.InterestRateMode _currentRateMode\n    ) internal {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n\n        //compounding reserve indexes\n        reserve.updateCumulativeIndexes();\n\n        if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {\n            uint256 userCurrentStableRate = user.stableBorrowRate;\n\n            //swap to variable\n            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(\n                _principalBorrowBalance,\n                userCurrentStableRate\n            ); //decreasing stable from old principal balance\n            reserve.increaseTotalBorrowsVariable(_compoundedBorrowBalance); //increase variable borrows\n        } else if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {\n            //swap to stable\n            uint256 currentStableRate = reserve.currentStableBorrowRate;\n            reserve.decreaseTotalBorrowsVariable(_principalBorrowBalance);\n            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(\n                _compoundedBorrowBalance,\n                currentStableRate\n            );\n\n        } else {\n            revert("Invalid rate mode received");\n        }\n    }\n\n    /\n    * @dev updates the state of the user as a consequence of a swap rate action.\n    * @param _reserve the address of the reserve on which the user is performing the swap\n    * @param _user the address of the borrower\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    * @param _currentRateMode the current rate mode of the user\n    /\n\n    function updateUserStateOnSwapRateInternal(\n        address _reserve,\n        address _user,\n        uint256 _balanceIncrease,\n        CoreLibrary.InterestRateMode _currentRateMode\n    ) internal returns (CoreLibrary.InterestRateMode) {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n\n        CoreLibrary.InterestRateMode newMode = CoreLibrary.InterestRateMode.NONE;\n\n        if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {\n            //switch to stable\n            newMode = CoreLibrary.InterestRateMode.STABLE;\n            user.stableBorrowRate = reserve.currentStableBorrowRate;\n            user.lastVariableBorrowCumulativeIndex = 0;\n        } else if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {\n            newMode = CoreLibrary.InterestRateMode.VARIABLE;\n            user.stableBorrowRate = 0;\n            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;\n        } else {\n            revert("Invalid interest rate mode received");\n        }\n        //compounding cumulated interest\n        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);\n        //solium-disable-next-line\n        user.lastUpdateTimestamp = uint40(block.timestamp);\n\n        return newMode;\n    }\n\n    /\n    * @dev updates the state of the principal reserve as a consequence of a liquidation action.\n    * @param _principalReserve the address of the principal reserve that is being repaid\n    * @param _user the address of the borrower\n    * @param _amountToLiquidate the amount being repaid by the liquidator\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    /\n\n    function updatePrincipalReserveStateOnLiquidationInternal(\n        address _principalReserve,\n        address _user,\n        uint256 _amountToLiquidate,\n        uint256 _balanceIncrease\n    ) internal {\n        CoreLibrary.ReserveData storage reserve = reserves[_principalReserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_principalReserve];\n\n        //update principal reserve data\n        reserve.updateCumulativeIndexes();\n\n        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(\n            _principalReserve,\n            _user\n        );\n\n        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {\n            //increase the total borrows by the compounded interest\n            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(\n                _balanceIncrease,\n                user.stableBorrowRate\n            );\n\n            //decrease by the actual amount to liquidate\n            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(\n                _amountToLiquidate,\n                user.stableBorrowRate\n            );\n\n        } else {\n            //increase the total borrows by the compounded interest\n            reserve.increaseTotalBorrowsVariable(_balanceIncrease);\n\n            //decrease by the actual amount to liquidate\n            reserve.decreaseTotalBorrowsVariable(_amountToLiquidate);\n        }\n\n    }\n\n    /\n    * @dev updates the state of the collateral reserve as a consequence of a liquidation action.\n    * @param _collateralReserve the address of the collateral reserve that is being liquidated\n    /\n    function updateCollateralReserveStateOnLiquidationInternal(\n        address _collateralReserve\n    ) internal {\n        //update collateral reserve\n        reserves[_collateralReserve].updateCumulativeIndexes();\n\n    }\n\n    /\n    * @dev updates the state of the user being liquidated as a consequence of a liquidation action.\n    * @param _reserve the address of the principal reserve that is being repaid\n    * @param _user the address of the borrower\n    * @param _amountToLiquidate the amount being repaid by the liquidator\n    * @param _feeLiquidated the amount of origination fee being liquidated\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    /\n    function updateUserStateOnLiquidationInternal(\n        address _reserve,\n        address _user,\n        uint256 _amountToLiquidate,\n        uint256 _feeLiquidated,\n        uint256 _balanceIncrease\n    ) internal {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        //first increase by the compounded interest, then decrease by the liquidated amount\n        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(\n            _amountToLiquidate\n        );\n\n        if (\n            getUserCurrentBorrowRateMode(_reserve, _user) == CoreLibrary.InterestRateMode.VARIABLE\n        ) {\n            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;\n        }\n\n        if(_feeLiquidated &gt; 0){\n            user.originationFee = user.originationFee.sub(_feeLiquidated);\n        }\n\n        //solium-disable-next-line\n        user.lastUpdateTimestamp = uint40(block.timestamp);\n    }\n\n    /\n    * @dev updates the state of the reserve as a consequence of a stable rate rebalance\n    * @param _reserve the address of the principal reserve where the user borrowed\n    * @param _user the address of the borrower\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    /\n\n    function updateReserveStateOnRebalanceInternal(\n        address _reserve,\n        address _user,\n        uint256 _balanceIncrease\n    ) internal {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n\n        reserve.updateCumulativeIndexes();\n\n        reserve.increaseTotalBorrowsStableAndUpdateAverageRate(\n            _balanceIncrease,\n            user.stableBorrowRate\n        );\n\n    }\n\n    /\n    * @dev updates the state of the user as a consequence of a stable rate rebalance\n    * @param _reserve the address of the principal reserve where the user borrowed\n    * @param _user the address of the borrower\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    /\n\n    function updateUserStateOnRebalanceInternal(\n        address _reserve,\n        address _user,\n        uint256 _balanceIncrease\n    ) internal {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n\n        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);\n        user.stableBorrowRate = reserve.currentStableBorrowRate;\n\n        //solium-disable-next-line\n        user.lastUpdateTimestamp = uint40(block.timestamp);\n    }\n\n    /\n    * @dev updates the state of the user as a consequence of a stable rate rebalance\n    * @param _reserve the address of the principal reserve where the user borrowed\n    * @param _user the address of the borrower\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    * @param _amountBorrowed the accrued interest on the borrowed amount\n    /\n    function updateReserveTotalBorrowsByRateModeInternal(\n        address _reserve,\n        address _user,\n        uint256 _principalBalance,\n        uint256 _balanceIncrease,\n        uint256 _amountBorrowed,\n        CoreLibrary.InterestRateMode _newBorrowRateMode\n    ) internal {\n        CoreLibrary.InterestRateMode previousRateMode = getUserCurrentBorrowRateMode(\n            _reserve,\n            _user\n        );\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n\n        if (previousRateMode == CoreLibrary.InterestRateMode.STABLE) {\n            CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(\n                _principalBalance,\n                user.stableBorrowRate\n            );\n        } else if (previousRateMode == CoreLibrary.InterestRateMode.VARIABLE) {\n            reserve.decreaseTotalBorrowsVariable(_principalBalance);\n        }\n\n        uint256 newPrincipalAmount = _principalBalance.add(_balanceIncrease).add(_amountBorrowed);\n        if (_newBorrowRateMode == CoreLibrary.InterestRateMode.STABLE) {\n            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(\n                newPrincipalAmount,\n                reserve.currentStableBorrowRate\n            );\n        } else if (_newBorrowRateMode == CoreLibrary.InterestRateMode.VARIABLE) {\n            reserve.increaseTotalBorrowsVariable(newPrincipalAmount);\n        } else {\n            revert("Invalid new borrow rate mode");\n        }\n    }\n\n    /\n    * @dev Updates the reserve current stable borrow rate Rf, the current variable borrow rate Rv and the current liquidity rate Rl.\n    * Also updates the lastUpdateTimestamp value. Please refer to the whitepaper for further information.\n    * @param _reserve the address of the reserve to be updated\n    * @param _liquidityAdded the amount of liquidity added to the protocol (deposit or repay) in the previous action\n    * @param _liquidityTaken the amount of liquidity taken from the protocol (redeem or borrow)\n    /\n\n    function updateReserveInterestRatesAndTimestampInternal(\n        address _reserve,\n        uint256 _liquidityAdded,\n        uint256 _liquidityTaken\n    ) internal {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        (uint256 newLiquidityRate, uint256 newStableRate, uint256 newVariableRate) = IReserveInterestRateStrategy(\n            reserve\n            .interestRateStrategyAddress\n        )\n        .calculateInterestRates(\n            _reserve,\n            getReserveAvailableLiquidity(_reserve).add(_liquidityAdded).sub(_liquidityTaken),\n            reserve.totalBorrowsStable,\n            reserve.totalBorrowsVariable,\n            reserve.currentAverageStableBorrowRate\n        );\n\n        reserve.currentLiquidityRate = newLiquidityRate;\n        reserve.currentStableBorrowRate = newStableRate;\n        reserve.currentVariableBorrowRate = newVariableRate;\n\n        //solium-disable-next-line\n        reserve.lastUpdateTimestamp = uint40(block.timestamp);\n\n        emit ReserveUpdated(\n            _reserve,\n            newLiquidityRate,\n            newStableRate,\n            newVariableRate,\n            reserve.lastLiquidityCumulativeIndex,\n            reserve.lastVariableBorrowCumulativeIndex\n        );\n    }\n\n    /\n    * @dev transfers to the protocol fees of a flashloan to the fees collection address\n    * @param _token the address of the token being transferred\n    * @param _amount the amount being transferred\n    /\n\n    function transferFlashLoanProtocolFeeInternal(address _token, uint256 _amount) internal {\n        address payable receiver = address(uint160(addressesProvider.getTokenDistributor()));\n\n        if (_token != EthAddressLib.ethAddress()) {\n            ERC20(_token).safeTransfer(receiver, _amount);\n        } else {\n            receiver.transfer(_amount);\n        }\n    }\n\n    /\n    * @dev updates the internal configuration of the core\n    /\n    function refreshConfigInternal() internal {\n        lendingPoolAddress = addressesProvider.getLendingPool();\n    }\n\n    /\n    * @dev adds a reserve to the array of the reserves address\n    /\n    function addReserveToListInternal(address _reserve) internal {\n        bool reserveAlreadyAdded = false;\n        for (uint256 i = 0; i &lt; reservesList.length; i++)\n            if (reservesList[i] == _reserve) {\n                reserveAlreadyAdded = true;\n            }\n        if (!reserveAlreadyAdded) reservesList.push(_reserve);\n    }\n\n}\n', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 04:31:26 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | pragma solidity ^0.5.0; import "openzeppelin-solidity/contracts/math/SafeMath.sol"; import "openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol"; import "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol"; import "openzeppelin-solidity/contracts/utils/Address.sol"; import "../libraries/openzeppelin-upgradeability/VersionedInitializable.sol"; import "../libraries/CoreLibrary.sol"; import "../configuration/LendingPoolAddressesProvider.sol"; import "../interfaces/ILendingRateOracle.sol"; import "../interfaces/IReserveInterestRateStrategy.sol"; import "../libraries/WadRayMath.sol"; import "../tokenization/AToken.sol"; import "../libraries/EthAddressLib.sol"; / * @title LendingPoolCore contract * @author Aave * @notice Holds the state of the lending pool and all the funds deposited * @dev NOTE: The core does not enforce security checks on the update of the state * (eg, updateStateOnBorrow() does not enforce that borrowed is enabled on the reserve). * The check that an action can be performed is a duty of the overlying LendingPool contract. / contract LendingPoolCore is VersionedInitializable {     using SafeMath for uint256;     using WadRayMath for uint256;     using CoreLibrary for CoreLibrary.ReserveData;     using CoreLibrary for CoreLibrary.UserReserveData;     using SafeERC20 for ERC20;     using Address for address payable; /** * @dev Emitted when the state of a reserve is updated * @param reserve the address of the reserve * @param liquidityRate the new liquidity rate * @param stableBorrowRate the new stable borrow rate * @param variableBorrowRate the new variable borrow rate * @param liquidityIndex the new liquidity index * @param variableBorrowIndex the new variable borrow index **/ event ReserveUpdated(     address indexed reserve,     uint256 liquidityRate,     uint256 stableBorrowRate,     uint256 variableBorrowRate,     uint256 liquidityIndex,     uint256 variableBorrowIndex );  address public lendingPoolAddress;  LendingPoolAddressesProvider public addressesProvider;  /** * @dev only lending pools can use functions affected by this modifier **/ modifier onlyLendingPool {     require(lendingPoolAddress == msg.sender, "The caller must be a lending pool contract");     _; }  /** * @dev only lending pools configurator can use functions affected by this modifier **/ modifier onlyLendingPoolConfigurator {     require(         addressesProvider.getLendingPoolConfigurator() == msg.sender,         "The caller must be a lending pool configurator contract"     );     _; }  mapping(address =&gt; CoreLibrary.ReserveData) internal reserves; mapping(address =&gt; mapping(address =&gt; CoreLibrary.UserReserveData)) internal usersReserveData;  address[] public reservesList;  uint256 public constant CORE_REVISION = 0x4;  /** * @dev returns the revision number of the contract **/ function getRevision() internal pure returns (uint256) {     return CORE_REVISION; }  /** * @dev initializes the Core contract, invoked upon registration on the AddressesProvider * @param _addressesProvider the addressesProvider contract **/  function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {     addressesProvider = _addressesProvider;     refreshConfigInternal(); }  /** * @dev updates the state of the core as a result of a deposit action * @param _reserve the address of the reserve in which the deposit is happening * @param _user the address of the the user depositing * @param _amount the amount being deposited * @param _isFirstDeposit true if the user is depositing for the first time **/  function updateStateOnDeposit(     address _reserve,     address _user,     uint256 _amount,     bool _isFirstDeposit ) external onlyLendingPool {     reserves[_reserve].updateCumulativeIndexes();     updateReserveInterestRatesAndTimestampInternal(_reserve, _amount, 0);      if (_isFirstDeposit) {         //if this is the first deposit of the user, we configure the deposit as enabled to be used as collateral         setUserUseReserveAsCollateral(_reserve, _user, true);     } }  /** * @dev updates the state of the core as a result of a redeem action * @param _reserve the address of the reserve in which the redeem is happening * @param _user the address of the the user redeeming * @param _amountRedeemed the amount being redeemed * @param _userRedeemedEverything true if the user is redeeming everything **/ function updateStateOnRedeem(     address _reserve,     address _user,     uint256 _amountRedeemed,     bool _userRedeemedEverything ) external onlyLendingPool {     //compound liquidity and variable borrow interests     reserves[_reserve].updateCumulativeIndexes();     updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountRedeemed);      //if user redeemed everything the useReserveAsCollateral flag is reset     if (_userRedeemedEverything) {         setUserUseReserveAsCollateral(_reserve, _user, false);     } }  /** * @dev updates the state of the core as a result of a flashloan action * @param _reserve the address of the reserve in which the flashloan is happening * @param _income the income of the protocol as a result of the action **/ function updateStateOnFlashLoan(     address _reserve,     uint256 _availableLiquidityBefore,     uint256 _income,     uint256 _protocolFee ) external onlyLendingPool {     transferFlashLoanProtocolFeeInternal(_reserve, _protocolFee);      //compounding the cumulated interest     reserves[_reserve].updateCumulativeIndexes();      uint256 totalLiquidityBefore = _availableLiquidityBefore.add(         getReserveTotalBorrows(_reserve)     );      //compounding the received fee into the reserve     reserves[_reserve].cumulateToLiquidityIndex(totalLiquidityBefore, _income);      //refresh interest rates     updateReserveInterestRatesAndTimestampInternal(_reserve, _income, 0); }  /** * @dev updates the state of the core as a consequence of a borrow action. * @param _reserve the address of the reserve on which the user is borrowing * @param _user the address of the borrower * @param _amountBorrowed the new amount borrowed * @param _borrowFee the fee on the amount borrowed * @param _rateMode the borrow rate mode (stable, variable) * @return the new borrow rate for the user **/ function updateStateOnBorrow(     address _reserve,     address _user,     uint256 _amountBorrowed,     uint256 _borrowFee,     CoreLibrary.InterestRateMode _rateMode ) external onlyLendingPool returns (uint256, uint256) {     // getting the previous borrow data of the user     (uint256 principalBorrowBalance, , uint256 balanceIncrease) = getUserBorrowBalances(         _reserve,         _user     );      updateReserveStateOnBorrowInternal(         _reserve,         _user,         principalBorrowBalance,         balanceIncrease,         _amountBorrowed,         _rateMode     );      updateUserStateOnBorrowInternal(         _reserve,         _user,         _amountBorrowed,         balanceIncrease,         _borrowFee,         _rateMode     );      updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountBorrowed);      return (getUserCurrentBorrowRate(_reserve, _user), balanceIncrease); }  /** * @dev updates the state of the core as a consequence of a repay action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _paybackAmountMinusFees the amount being paid back minus fees * @param _originationFeeRepaid the fee on the amount that is being repaid * @param _balanceIncrease the accrued interest on the borrowed amount * @param _repaidWholeLoan true if the user is repaying the whole loan **/  function updateStateOnRepay(     address _reserve,     address _user,     uint256 _paybackAmountMinusFees,     uint256 _originationFeeRepaid,     uint256 _balanceIncrease,     bool _repaidWholeLoan ) external onlyLendingPool {     updateReserveStateOnRepayInternal(         _reserve,         _user,         _paybackAmountMinusFees,         _balanceIncrease     );     updateUserStateOnRepayInternal(         _reserve,         _user,         _paybackAmountMinusFees,         _originationFeeRepaid,         _balanceIncrease,         _repaidWholeLoan     );      updateReserveInterestRatesAndTimestampInternal(_reserve, _paybackAmountMinusFees, 0); }  /** * @dev updates the state of the core as a consequence of a swap rate action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _principalBorrowBalance the amount borrowed by the user * @param _compoundedBorrowBalance the amount borrowed plus accrued interest * @param _balanceIncrease the accrued interest on the borrowed amount * @param _currentRateMode the current interest rate mode for the user **/ function updateStateOnSwapRate(     address _reserve,     address _user,     uint256 _principalBorrowBalance,     uint256 _compoundedBorrowBalance,     uint256 _balanceIncrease,     CoreLibrary.InterestRateMode _currentRateMode ) external onlyLendingPool returns (CoreLibrary.InterestRateMode, uint256) {     updateReserveStateOnSwapRateInternal(         _reserve,         _user,         _principalBorrowBalance,         _compoundedBorrowBalance,         _currentRateMode     );      CoreLibrary.InterestRateMode newRateMode = updateUserStateOnSwapRateInternal(         _reserve,         _user,         _balanceIncrease,         _currentRateMode     );      updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);      return (newRateMode, getUserCurrentBorrowRate(_reserve, _user)); }  /** * @dev updates the state of the core as a consequence of a liquidation action. * @param _principalReserve the address of the principal reserve that is being repaid * @param _collateralReserve the address of the collateral reserve that is being liquidated * @param _user the address of the borrower * @param _amountToLiquidate the amount being repaid by the liquidator * @param _collateralToLiquidate the amount of collateral being liquidated * @param _feeLiquidated the amount of origination fee being liquidated * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus * @param _balanceIncrease the accrued interest on the borrowed amount * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise **/ function updateStateOnLiquidation(     address _principalReserve,     address _collateralReserve,     address _user,     uint256 _amountToLiquidate,     uint256 _collateralToLiquidate,     uint256 _feeLiquidated,     uint256 _liquidatedCollateralForFee,     uint256 _balanceIncrease,     bool _liquidatorReceivesAToken ) external onlyLendingPool {     updatePrincipalReserveStateOnLiquidationInternal(         _principalReserve,         _user,         _amountToLiquidate,         _balanceIncrease     );      updateCollateralReserveStateOnLiquidationInternal(         _collateralReserve     );      updateUserStateOnLiquidationInternal(         _principalReserve,         _user,         _amountToLiquidate,         _feeLiquidated,         _balanceIncrease     );      updateReserveInterestRatesAndTimestampInternal(_principalReserve, _amountToLiquidate, 0);      if (!_liquidatorReceivesAToken) {         updateReserveInterestRatesAndTimestampInternal(             _collateralReserve,             0,             _collateralToLiquidate.add(_liquidatedCollateralForFee)         );     }  }  /** * @dev updates the state of the core as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount * @return the new stable rate for the user **/ function updateStateOnRebalance(address _reserve, address _user, uint256 _balanceIncrease) external onlyLendingPool returns (uint256) {     updateReserveStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);      //update user data and rebalance the rate     updateUserStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);     updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);     return usersReserveData[_user][_reserve].stableBorrowRate; }  /** * @dev enables or disables a reserve as collateral * @param _reserve the address of the principal reserve where the user deposited * @param _user the address of the depositor * @param _useAsCollateral true if the depositor wants to use the reserve as collateral **/ function setUserUseReserveAsCollateral(address _reserve, address _user, bool _useAsCollateral) public onlyLendingPool {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     user.useAsCollateral = _useAsCollateral; }  /** * @notice ETH/token transfer functions **/  /** * @dev fallback function enforces that the caller is a contract, to support flashloan transfers **/ function() external payable {     //only contracts can send ETH to the core     require(msg.sender.isContract(), "Only contracts can send ether to the Lending pool core");  }  /** * @dev transfers to the user a specific amount from the reserve. * @param _reserve the address of the reserve where the transfer is happening * @param _user the address of the user receiving the transfer * @param _amount the amount being transferred **/ function transferToUser(address _reserve, address payable _user, uint256 _amount) external onlyLendingPool {     if (_reserve != EthAddressLib.ethAddress()) {         ERC20(_reserve).safeTransfer(_user, _amount);     } else {         //solium-disable-next-line         (bool result, ) = _user.call.value(_amount).gas(50000)("");         require(result, "Transfer of ETH failed");     } }  /** * @dev transfers the protocol fees to the fees collection address * @param _token the address of the token being transferred * @param _user the address of the user from where the transfer is happening * @param _amount the amount being transferred * @param _destination the fee receiver address **/  function transferToFeeCollectionAddress(     address _token,     address _user,     uint256 _amount,     address _destination ) external payable onlyLendingPool {     address payable feeAddress = address(uint160(_destination)); //cast the address to payable      if (_token != EthAddressLib.ethAddress()) {         require(             msg.value == 0,             "User is sending ETH along with the ERC20 transfer. Check the value attribute of the transaction"         );         ERC20(_token).safeTransferFrom(_user, feeAddress, _amount);     } else {         require(msg.value &gt;= _amount, "The amount and the value sent to deposit do not match");         //solium-disable-next-line         (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");         require(result, "Transfer of ETH failed");     } }  /** * @dev transfers the fees to the fees collection address in the case of liquidation * @param _token the address of the token being transferred * @param _amount the amount being transferred * @param _destination the fee receiver address **/ function liquidateFee(     address _token,     uint256 _amount,     address _destination ) external payable onlyLendingPool {     address payable feeAddress = address(uint160(_destination)); //cast the address to payable     require(         msg.value == 0,         "Fee liquidation does not require any transfer of value"     );      if (_token != EthAddressLib.ethAddress()) {         ERC20(_token).safeTransfer(feeAddress, _amount);     } else {         //solium-disable-next-line         (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");         require(result, "Transfer of ETH failed");     } }  /** * @dev transfers an amount from a user to the destination reserve * @param _reserve the address of the reserve where the amount is being transferred * @param _user the address of the user from where the transfer is happening * @param _amount the amount being transferred **/ function transferToReserve(address _reserve, address payable _user, uint256 _amount) external payable onlyLendingPool {     if (_reserve != EthAddressLib.ethAddress()) {         require(msg.value == 0, "User is sending ETH along with the ERC20 transfer.");         ERC20(_reserve).safeTransferFrom(_user, address(this), _amount);      } else {         require(msg.value &gt;= _amount, "The amount and the value sent to deposit do not match");          if (msg.value &gt; _amount) {             //send back excess ETH             uint256 excessAmount = msg.value.sub(_amount);             //solium-disable-next-line             (bool result, ) = _user.call.value(excessAmount).gas(50000)("");             require(result, "Transfer of ETH failed");         }     } }  /** * @notice data access functions **/  /** * @dev returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral) * needed to calculate the global account data in the LendingPoolDataProvider * @param _reserve the address of the reserve * @param _user the address of the user * @return the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not **/ function getUserBasicReserveData(address _reserve, address _user) external view returns (uint256, uint256, uint256, bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      uint256 underlyingBalance = getUserUnderlyingAssetBalance(_reserve, _user);      if (user.principalBorrowBalance == 0) {         return (underlyingBalance, 0, 0, user.useAsCollateral);     }      return (     underlyingBalance,     user.getCompoundedBorrowBalance(reserve),     user.originationFee,     user.useAsCollateral     ); }  /** * @dev checks if a user is allowed to borrow at a stable rate * @param _reserve the reserve address * @param _user the user * @param _amount the amount the the user wants to borrow * @return true if the user is allowed to borrow at a stable rate, false otherwise **/  function isUserAllowedToBorrowAtStable(address _reserve, address _user, uint256 _amount) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      if (!reserve.isStableBorrowRateEnabled) return false;      return     !user.useAsCollateral ||     !reserve.usageAsCollateralEnabled ||     _amount &gt; getUserUnderlyingAssetBalance(_reserve, _user); }  /** * @dev gets the underlying asset balance of a user based on the corresponding aToken balance. * @param _reserve the reserve address * @param _user the user address * @return the underlying deposit balance of the user **/  function getUserUnderlyingAssetBalance(address _reserve, address _user) public view returns (uint256) {     AToken aToken = AToken(reserves[_reserve].aTokenAddress);     return aToken.balanceOf(_user);  }  /** * @dev gets the interest rate strategy contract address for the reserve * @param _reserve the reserve address * @return the address of the interest rate strategy contract **/ function getReserveInterestRateStrategyAddress(address _reserve) public view returns (address) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.interestRateStrategyAddress; }  /** * @dev gets the aToken contract address for the reserve * @param _reserve the reserve address * @return the address of the aToken contract **/  function getReserveATokenAddress(address _reserve) public view returns (address) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.aTokenAddress; }  /** * @dev gets the available liquidity in the reserve. The available liquidity is the balance of the core contract * @param _reserve the reserve address * @return the available liquidity **/ function getReserveAvailableLiquidity(address _reserve) public view returns (uint256) {     uint256 balance = 0;      if (_reserve == EthAddressLib.ethAddress()) {         balance = address(this).balance;     } else {         balance = IERC20(_reserve).balanceOf(address(this));     }     return balance; }  /** * @dev gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows * @param _reserve the reserve address * @return the total liquidity **/ function getReserveTotalLiquidity(address _reserve) public view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return getReserveAvailableLiquidity(_reserve).add(reserve.getTotalBorrows()); }  /** * @dev gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there * there has been 100% income. * @param _reserve the reserve address * @return the reserve normalized income **/ function getReserveNormalizedIncome(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.getNormalizedIncome(); }  /** * @dev gets the reserve total borrows * @param _reserve the reserve address * @return the total borrows (stable + variable) **/ function getReserveTotalBorrows(address _reserve) public view returns (uint256) {     return reserves[_reserve].getTotalBorrows(); }  /** * @dev gets the reserve total borrows stable * @param _reserve the reserve address * @return the total borrows stable **/ function getReserveTotalBorrowsStable(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.totalBorrowsStable; }  /** * @dev gets the reserve total borrows variable * @param _reserve the reserve address * @return the total borrows variable **/  function getReserveTotalBorrowsVariable(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.totalBorrowsVariable; }  /** * @dev gets the reserve liquidation threshold * @param _reserve the reserve address * @return the reserve liquidation threshold **/  function getReserveLiquidationThreshold(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.liquidationThreshold; }  /** * @dev gets the reserve liquidation bonus * @param _reserve the reserve address * @return the reserve liquidation bonus **/  function getReserveLiquidationBonus(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.liquidationBonus; }  /** * @dev gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty * @param _reserve the reserve address * @return the reserve current variable borrow rate **/  function getReserveCurrentVariableBorrowRate(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      if (reserve.currentVariableBorrowRate == 0) {         return         IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)         .getBaseVariableBorrowRate();     }     return reserve.currentVariableBorrowRate; }  /** * @dev gets the reserve current stable borrow rate. Is the market rate if the reserve is empty * @param _reserve the reserve address * @return the reserve current stable borrow rate **/  function getReserveCurrentStableBorrowRate(address _reserve) public view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     ILendingRateOracle oracle = ILendingRateOracle(addressesProvider.getLendingRateOracle());      if (reserve.currentStableBorrowRate == 0) {         //no stable rate borrows yet         return oracle.getMarketBorrowRate(_reserve);     }      return reserve.currentStableBorrowRate; }  /** * @dev gets the reserve average stable borrow rate. The average stable rate is the weighted average * of all the loans taken at stable rate. * @param _reserve the reserve address * @return the reserve current average borrow rate **/ function getReserveCurrentAverageStableBorrowRate(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.currentAverageStableBorrowRate; }  /** * @dev gets the reserve liquidity rate * @param _reserve the reserve address * @return the reserve liquidity rate **/ function getReserveCurrentLiquidityRate(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.currentLiquidityRate; }  /** * @dev gets the reserve liquidity cumulative index * @param _reserve the reserve address * @return the reserve liquidity cumulative index **/ function getReserveLiquidityCumulativeIndex(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.lastLiquidityCumulativeIndex; }  /** * @dev gets the reserve variable borrow index * @param _reserve the reserve address * @return the reserve variable borrow index **/ function getReserveVariableBorrowsCumulativeIndex(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.lastVariableBorrowCumulativeIndex; }  /** * @dev this function aggregates the configuration parameters of the reserve. * It's used in the LendingPoolDataProvider specifically to save gas, and avoid * multiple external contract calls to fetch the same data. * @param _reserve the reserve address * @return the reserve decimals * @return the base ltv as collateral * @return the liquidation threshold * @return if the reserve is used as collateral or not **/ function getReserveConfiguration(address _reserve) external view returns (uint256, uint256, uint256, bool) {     uint256 decimals;     uint256 baseLTVasCollateral;     uint256 liquidationThreshold;     bool usageAsCollateralEnabled;      CoreLibrary.ReserveData storage reserve = reserves[_reserve];     decimals = reserve.decimals;     baseLTVasCollateral = reserve.baseLTVasCollateral;     liquidationThreshold = reserve.liquidationThreshold;     usageAsCollateralEnabled = reserve.usageAsCollateralEnabled;      return (decimals, baseLTVasCollateral, liquidationThreshold, usageAsCollateralEnabled); }  /** * @dev returns the decimals of the reserve * @param _reserve the reserve address * @return the reserve decimals **/ function getReserveDecimals(address _reserve) external view returns (uint256) {     return reserves[_reserve].decimals; }  /** * @dev returns true if the reserve is enabled for borrowing * @param _reserve the reserve address * @return true if the reserve is enabled for borrowing, false otherwise **/  function isReserveBorrowingEnabled(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.borrowingEnabled; }  /** * @dev returns true if the reserve is enabled as collateral * @param _reserve the reserve address * @return true if the reserve is enabled as collateral, false otherwise **/  function isReserveUsageAsCollateralEnabled(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.usageAsCollateralEnabled; }  /** * @dev returns true if the stable rate is enabled on reserve * @param _reserve the reserve address * @return true if the stable rate is enabled on reserve, false otherwise **/ function getReserveIsStableBorrowRateEnabled(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.isStableBorrowRateEnabled; }  /** * @dev returns true if the reserve is active * @param _reserve the reserve address * @return true if the reserve is active, false otherwise **/ function getReserveIsActive(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.isActive; }  /** * @notice returns if a reserve is freezed * @param _reserve the reserve for which the information is needed * @return true if the reserve is freezed, false otherwise **/  function getReserveIsFreezed(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.isFreezed; }  /** * @notice returns the timestamp of the last action on the reserve * @param _reserve the reserve for which the information is needed * @return the last updated timestamp of the reserve **/  function getReserveLastUpdate(address _reserve) external view returns (uint40 timestamp) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     timestamp = reserve.lastUpdateTimestamp; }  /** * @dev returns the utilization rate U of a specific reserve * @param _reserve the reserve for which the information is needed * @return the utilization rate in ray **/  function getReserveUtilizationRate(address _reserve) public view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      uint256 totalBorrows = reserve.getTotalBorrows();      if (totalBorrows == 0) {         return 0;     }      uint256 availableLiquidity = getReserveAvailableLiquidity(_reserve);      return totalBorrows.rayDiv(availableLiquidity.add(totalBorrows)); }  /** * @return the array of reserves configured on the core **/ function getReserves() external view returns (address[] memory) {     return reservesList; }  /** * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return true if the user has chosen to use the reserve as collateral, false otherwise **/ function isUserUseReserveAsCollateralEnabled(address _reserve, address _user) external view returns (bool) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.useAsCollateral; }  /** * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the origination fee for the user **/ function getUserOriginationFee(address _reserve, address _user) external view returns (uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.originationFee; }  /** * @dev users with no loans in progress have NONE as borrow rate mode * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the borrow rate mode for the user, **/  function getUserCurrentBorrowRateMode(address _reserve, address _user) public view returns (CoreLibrary.InterestRateMode) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      if (user.principalBorrowBalance == 0) {         return CoreLibrary.InterestRateMode.NONE;     }      return     user.stableBorrowRate &gt; 0     ? CoreLibrary.InterestRateMode.STABLE     : CoreLibrary.InterestRateMode.VARIABLE; }  /** * @dev gets the current borrow rate of the user * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the borrow rate for the user, **/ function getUserCurrentBorrowRate(address _reserve, address _user) internal view returns (uint256) {     CoreLibrary.InterestRateMode rateMode = getUserCurrentBorrowRateMode(_reserve, _user);      if (rateMode == CoreLibrary.InterestRateMode.NONE) {         return 0;     }      return     rateMode == CoreLibrary.InterestRateMode.STABLE     ? usersReserveData[_user][_reserve].stableBorrowRate     : reserves[_reserve].currentVariableBorrowRate; }  /** * @dev the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the user stable rate **/ function getUserCurrentStableBorrowRate(address _reserve, address _user) external view returns (uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.stableBorrowRate; }  /** * @dev calculates and returns the borrow balances of the user * @param _reserve the address of the reserve * @param _user the address of the user * @return the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance **/  function getUserBorrowBalances(address _reserve, address _user) public view returns (uint256, uint256, uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     if (user.principalBorrowBalance == 0) {         return (0, 0, 0);     }      uint256 principal = user.principalBorrowBalance;     uint256 compoundedBalance = CoreLibrary.getCompoundedBorrowBalance(         user,         reserves[_reserve]     );     return (principal, compoundedBalance, compoundedBalance.sub(principal)); }  /** * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the variable borrow index for the user **/  function getUserVariableBorrowCumulativeIndex(address _reserve, address _user) external view returns (uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.lastVariableBorrowCumulativeIndex; }  /** * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the variable borrow index for the user **/  function getUserLastUpdate(address _reserve, address _user) external view returns (uint256 timestamp) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     timestamp = user.lastUpdateTimestamp; }  /** * @dev updates the lending pool core configuration **/ function refreshConfiguration() external onlyLendingPoolConfigurator {     refreshConfigInternal(); }  /** * @dev initializes a reserve * @param _reserve the address of the reserve * @param _aTokenAddress the address of the overlying aToken contract * @param _decimals the decimals of the reserve currency * @param _interestRateStrategyAddress the address of the interest rate strategy contract **/ function initReserve(     address _reserve,     address _aTokenAddress,     uint256 _decimals,     address _interestRateStrategyAddress ) external onlyLendingPoolConfigurator {     reserves[_reserve].init(_aTokenAddress, _decimals, _interestRateStrategyAddress);     addReserveToListInternal(_reserve);  }    /** * @dev removes the last added reserve in the reservesList array * @param _reserveToRemove the address of the reserve **/ function removeLastAddedReserve(address _reserveToRemove) external onlyLendingPoolConfigurator {      address lastReserve = reservesList[reservesList.length-1];      require(lastReserve == _reserveToRemove, "Reserve being removed is different than the reserve requested");      //as we can't check if totalLiquidity is 0 (since the reserve added might not be an ERC20) we at least check that there is nothing borrowed     require(getReserveTotalBorrows(lastReserve) == 0, "Cannot remove a reserve with liquidity deposited");      reserves[lastReserve].isActive = false;     reserves[lastReserve].aTokenAddress = address(0);     reserves[lastReserve].decimals = 0;     reserves[lastReserve].lastLiquidityCumulativeIndex = 0;     reserves[lastReserve].lastVariableBorrowCumulativeIndex = 0;     reserves[lastReserve].borrowingEnabled = false;     reserves[lastReserve].usageAsCollateralEnabled = false;     reserves[lastReserve].baseLTVasCollateral = 0;     reserves[lastReserve].liquidationThreshold = 0;     reserves[lastReserve].liquidationBonus = 0;     reserves[lastReserve].interestRateStrategyAddress = address(0);      reservesList.pop(); }  /** * @dev updates the address of the interest rate strategy contract * @param _reserve the address of the reserve * @param _rateStrategyAddress the address of the interest rate strategy contract **/  function setReserveInterestRateStrategyAddress(address _reserve, address _rateStrategyAddress) external onlyLendingPoolConfigurator {     reserves[_reserve].interestRateStrategyAddress = _rateStrategyAddress; }  /** * @dev enables borrowing on a reserve. Also sets the stable rate borrowing * @param _reserve the address of the reserve * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise **/  function enableBorrowingOnReserve(address _reserve, bool _stableBorrowRateEnabled) external onlyLendingPoolConfigurator {     reserves[_reserve].enableBorrowing(_stableBorrowRateEnabled); }  /** * @dev disables borrowing on a reserve * @param _reserve the address of the reserve **/  function disableBorrowingOnReserve(address _reserve) external onlyLendingPoolConfigurator {     reserves[_reserve].disableBorrowing(); }  /** * @dev enables a reserve to be used as collateral * @param _reserve the address of the reserve **/ function enableReserveAsCollateral(     address _reserve,     uint256 _baseLTVasCollateral,     uint256 _liquidationThreshold,     uint256 _liquidationBonus ) external onlyLendingPoolConfigurator {     reserves[_reserve].enableAsCollateral(         _baseLTVasCollateral,         _liquidationThreshold,         _liquidationBonus     ); }  /** * @dev disables a reserve to be used as collateral * @param _reserve the address of the reserve **/ function disableReserveAsCollateral(address _reserve) external onlyLendingPoolConfigurator {     reserves[_reserve].disableAsCollateral(); }  /** * @dev enable the stable borrow rate mode on a reserve * @param _reserve the address of the reserve **/ function enableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isStableBorrowRateEnabled = true; }  /** * @dev disable the stable borrow rate mode on a reserve * @param _reserve the address of the reserve **/ function disableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isStableBorrowRateEnabled = false; }  /** * @dev activates a reserve * @param _reserve the address of the reserve **/ function activateReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      require(         reserve.lastLiquidityCumulativeIndex &gt; 0 &amp;&amp;         reserve.lastVariableBorrowCumulativeIndex &gt; 0,         "Reserve has not been initialized yet"     );     reserve.isActive = true; }  /** * @dev deactivates a reserve * @param _reserve the address of the reserve **/ function deactivateReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isActive = false; }  /** * @notice allows the configurator to freeze the reserve. * A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance. * @param _reserve the address of the reserve **/ function freezeReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isFreezed = true; }  /** * @notice allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed. * @param _reserve the address of the reserve **/ function unfreezeReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isFreezed = false; }  /** * @notice allows the configurator to update the loan to value of a reserve * @param _reserve the address of the reserve * @param _ltv the new loan to value **/ function setReserveBaseLTVasCollateral(address _reserve, uint256 _ltv) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.baseLTVasCollateral = _ltv; }  /** * @notice allows the configurator to update the liquidation threshold of a reserve * @param _reserve the address of the reserve * @param _threshold the new liquidation threshold **/ function setReserveLiquidationThreshold(address _reserve, uint256 _threshold) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.liquidationThreshold = _threshold; }  /** * @notice allows the configurator to update the liquidation bonus of a reserve * @param _reserve the address of the reserve * @param _bonus the new liquidation bonus **/ function setReserveLiquidationBonus(address _reserve, uint256 _bonus) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.liquidationBonus = _bonus; }  /** * @notice allows the configurator to update the reserve decimals * @param _reserve the address of the reserve * @param _decimals the decimals of the reserve **/ function setReserveDecimals(address _reserve, uint256 _decimals) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.decimals = _decimals; }  /** * @notice internal functions **/  /** * @dev updates the state of a reserve as a consequence of a borrow action. * @param _reserve the address of the reserve on which the user is borrowing * @param _user the address of the borrower * @param _principalBorrowBalance the previous borrow balance of the borrower before the action * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount * @param _amountBorrowed the new amount borrowed * @param _rateMode the borrow rate mode (stable, variable) **/  function updateReserveStateOnBorrowInternal(     address _reserve,     address _user,     uint256 _principalBorrowBalance,     uint256 _balanceIncrease,     uint256 _amountBorrowed,     CoreLibrary.InterestRateMode _rateMode ) internal {     reserves[_reserve].updateCumulativeIndexes();      //increasing reserve total borrows to account for the new borrow balance of the user     //NOTE: Depending on the previous borrow mode, the borrows might need to be switched from variable to stable or vice versa      updateReserveTotalBorrowsByRateModeInternal(         _reserve,         _user,         _principalBorrowBalance,         _balanceIncrease,         _amountBorrowed,         _rateMode     ); }  /** * @dev updates the state of a user as a consequence of a borrow action. * @param _reserve the address of the reserve on which the user is borrowing * @param _user the address of the borrower * @param _amountBorrowed the amount borrowed * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount * @param _rateMode the borrow rate mode (stable, variable) * @return the final borrow rate for the user. Emitted by the borrow() event **/  function updateUserStateOnBorrowInternal(     address _reserve,     address _user,     uint256 _amountBorrowed,     uint256 _balanceIncrease,     uint256 _fee,     CoreLibrary.InterestRateMode _rateMode ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      if (_rateMode == CoreLibrary.InterestRateMode.STABLE) {         //stable         //reset the user variable index, and update the stable rate         user.stableBorrowRate = reserve.currentStableBorrowRate;         user.lastVariableBorrowCumulativeIndex = 0;     } else if (_rateMode == CoreLibrary.InterestRateMode.VARIABLE) {         //variable         //reset the user stable rate, and store the new borrow index         user.stableBorrowRate = 0;         user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;     } else {         revert("Invalid borrow rate mode");     }     //increase the principal borrows and the origination fee     user.principalBorrowBalance = user.principalBorrowBalance.add(_amountBorrowed).add(         _balanceIncrease     );     user.originationFee = user.originationFee.add(_fee);      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp);  }  /** * @dev updates the state of the reserve as a consequence of a repay action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _paybackAmountMinusFees the amount being paid back minus fees * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updateReserveStateOnRepayInternal(     address _reserve,     address _user,     uint256 _paybackAmountMinusFees,     uint256 _balanceIncrease ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_reserve][_user];      CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(_reserve, _user);      //update the indexes     reserves[_reserve].updateCumulativeIndexes();      //compound the cumulated interest to the borrow balance and then subtracting the payback amount     if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             _balanceIncrease,             user.stableBorrowRate         );         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _paybackAmountMinusFees,             user.stableBorrowRate         );     } else {         reserve.increaseTotalBorrowsVariable(_balanceIncrease);         reserve.decreaseTotalBorrowsVariable(_paybackAmountMinusFees);     } }  /** * @dev updates the state of the user as a consequence of a repay action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _paybackAmountMinusFees the amount being paid back minus fees * @param _originationFeeRepaid the fee on the amount that is being repaid * @param _balanceIncrease the accrued interest on the borrowed amount * @param _repaidWholeLoan true if the user is repaying the whole loan **/ function updateUserStateOnRepayInternal(     address _reserve,     address _user,     uint256 _paybackAmountMinusFees,     uint256 _originationFeeRepaid,     uint256 _balanceIncrease,     bool _repaidWholeLoan ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      //update the user principal borrow balance, adding the cumulated interest and then subtracting the payback amount     user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(         _paybackAmountMinusFees     );     user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;      //if the balance decrease is equal to the previous principal (user is repaying the whole loan)     //and the rate mode is stable, we reset the interest rate mode of the user     if (_repaidWholeLoan) {         user.stableBorrowRate = 0;         user.lastVariableBorrowCumulativeIndex = 0;     }     user.originationFee = user.originationFee.sub(_originationFeeRepaid);      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp);  }  /** * @dev updates the state of the user as a consequence of a swap rate action. * @param _reserve the address of the reserve on which the user is performing the rate swap * @param _user the address of the borrower * @param _principalBorrowBalance the the principal amount borrowed by the user * @param _compoundedBorrowBalance the principal amount plus the accrued interest * @param _currentRateMode the rate mode at which the user borrowed **/ function updateReserveStateOnSwapRateInternal(     address _reserve,     address _user,     uint256 _principalBorrowBalance,     uint256 _compoundedBorrowBalance,     CoreLibrary.InterestRateMode _currentRateMode ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      //compounding reserve indexes     reserve.updateCumulativeIndexes();      if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {         uint256 userCurrentStableRate = user.stableBorrowRate;          //swap to variable         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _principalBorrowBalance,             userCurrentStableRate         ); //decreasing stable from old principal balance         reserve.increaseTotalBorrowsVariable(_compoundedBorrowBalance); //increase variable borrows     } else if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         //swap to stable         uint256 currentStableRate = reserve.currentStableBorrowRate;         reserve.decreaseTotalBorrowsVariable(_principalBorrowBalance);         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             _compoundedBorrowBalance,             currentStableRate         );      } else {         revert("Invalid rate mode received");     } }  /** * @dev updates the state of the user as a consequence of a swap rate action. * @param _reserve the address of the reserve on which the user is performing the swap * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount * @param _currentRateMode the current rate mode of the user **/  function updateUserStateOnSwapRateInternal(     address _reserve,     address _user,     uint256 _balanceIncrease,     CoreLibrary.InterestRateMode _currentRateMode ) internal returns (CoreLibrary.InterestRateMode) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      CoreLibrary.InterestRateMode newMode = CoreLibrary.InterestRateMode.NONE;      if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         //switch to stable         newMode = CoreLibrary.InterestRateMode.STABLE;         user.stableBorrowRate = reserve.currentStableBorrowRate;         user.lastVariableBorrowCumulativeIndex = 0;     } else if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {         newMode = CoreLibrary.InterestRateMode.VARIABLE;         user.stableBorrowRate = 0;         user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;     } else {         revert("Invalid interest rate mode received");     }     //compounding cumulated interest     user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);     //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp);      return newMode; }  /** * @dev updates the state of the principal reserve as a consequence of a liquidation action. * @param _principalReserve the address of the principal reserve that is being repaid * @param _user the address of the borrower * @param _amountToLiquidate the amount being repaid by the liquidator * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updatePrincipalReserveStateOnLiquidationInternal(     address _principalReserve,     address _user,     uint256 _amountToLiquidate,     uint256 _balanceIncrease ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_principalReserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_principalReserve];      //update principal reserve data     reserve.updateCumulativeIndexes();      CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(         _principalReserve,         _user     );      if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {         //increase the total borrows by the compounded interest         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             _balanceIncrease,             user.stableBorrowRate         );          //decrease by the actual amount to liquidate         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _amountToLiquidate,             user.stableBorrowRate         );      } else {         //increase the total borrows by the compounded interest         reserve.increaseTotalBorrowsVariable(_balanceIncrease);          //decrease by the actual amount to liquidate         reserve.decreaseTotalBorrowsVariable(_amountToLiquidate);     }  }  /** * @dev updates the state of the collateral reserve as a consequence of a liquidation action. * @param _collateralReserve the address of the collateral reserve that is being liquidated **/ function updateCollateralReserveStateOnLiquidationInternal(     address _collateralReserve ) internal {     //update collateral reserve     reserves[_collateralReserve].updateCumulativeIndexes();  }  /** * @dev updates the state of the user being liquidated as a consequence of a liquidation action. * @param _reserve the address of the principal reserve that is being repaid * @param _user the address of the borrower * @param _amountToLiquidate the amount being repaid by the liquidator * @param _feeLiquidated the amount of origination fee being liquidated * @param _balanceIncrease the accrued interest on the borrowed amount **/ function updateUserStateOnLiquidationInternal(     address _reserve,     address _user,     uint256 _amountToLiquidate,     uint256 _feeLiquidated,     uint256 _balanceIncrease ) internal {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     //first increase by the compounded interest, then decrease by the liquidated amount     user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(         _amountToLiquidate     );      if (         getUserCurrentBorrowRateMode(_reserve, _user) == CoreLibrary.InterestRateMode.VARIABLE     ) {         user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;     }      if(_feeLiquidated &gt; 0){         user.originationFee = user.originationFee.sub(_feeLiquidated);     }      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp); }  /** * @dev updates the state of the reserve as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updateReserveStateOnRebalanceInternal(     address _reserve,     address _user,     uint256 _balanceIncrease ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      reserve.updateCumulativeIndexes();      reserve.increaseTotalBorrowsStableAndUpdateAverageRate(         _balanceIncrease,         user.stableBorrowRate     );  }  /** * @dev updates the state of the user as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updateUserStateOnRebalanceInternal(     address _reserve,     address _user,     uint256 _balanceIncrease ) internal {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);     user.stableBorrowRate = reserve.currentStableBorrowRate;      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp); }  /** * @dev updates the state of the user as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount * @param _amountBorrowed the accrued interest on the borrowed amount **/ function updateReserveTotalBorrowsByRateModeInternal(     address _reserve,     address _user,     uint256 _principalBalance,     uint256 _balanceIncrease,     uint256 _amountBorrowed,     CoreLibrary.InterestRateMode _newBorrowRateMode ) internal {     CoreLibrary.InterestRateMode previousRateMode = getUserCurrentBorrowRateMode(         _reserve,         _user     );     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      if (previousRateMode == CoreLibrary.InterestRateMode.STABLE) {         CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _principalBalance,             user.stableBorrowRate         );     } else if (previousRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         reserve.decreaseTotalBorrowsVariable(_principalBalance);     }      uint256 newPrincipalAmount = _principalBalance.add(_balanceIncrease).add(_amountBorrowed);     if (_newBorrowRateMode == CoreLibrary.InterestRateMode.STABLE) {         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             newPrincipalAmount,             reserve.currentStableBorrowRate         );     } else if (_newBorrowRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         reserve.increaseTotalBorrowsVariable(newPrincipalAmount);     } else {         revert("Invalid new borrow rate mode");     } }  /** * @dev Updates the reserve current stable borrow rate Rf, the current variable borrow rate Rv and the current liquidity rate Rl. * Also updates the lastUpdateTimestamp value. Please refer to the whitepaper for further information. * @param _reserve the address of the reserve to be updated * @param _liquidityAdded the amount of liquidity added to the protocol (deposit or repay) in the previous action * @param _liquidityTaken the amount of liquidity taken from the protocol (redeem or borrow) **/  function updateReserveInterestRatesAndTimestampInternal(     address _reserve,     uint256 _liquidityAdded,     uint256 _liquidityTaken ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     (uint256 newLiquidityRate, uint256 newStableRate, uint256 newVariableRate) = IReserveInterestRateStrategy(         reserve         .interestRateStrategyAddress     )     .calculateInterestRates(         _reserve,         getReserveAvailableLiquidity(_reserve).add(_liquidityAdded).sub(_liquidityTaken),         reserve.totalBorrowsStable,         reserve.totalBorrowsVariable,         reserve.currentAverageStableBorrowRate     );      reserve.currentLiquidityRate = newLiquidityRate;     reserve.currentStableBorrowRate = newStableRate;     reserve.currentVariableBorrowRate = newVariableRate;      //solium-disable-next-line     reserve.lastUpdateTimestamp = uint40(block.timestamp);      emit ReserveUpdated(         _reserve,         newLiquidityRate,         newStableRate,         newVariableRate,         reserve.lastLiquidityCumulativeIndex,         reserve.lastVariableBorrowCumulativeIndex     ); }  /** * @dev transfers to the protocol fees of a flashloan to the fees collection address * @param _token the address of the token being transferred * @param _amount the amount being transferred **/  function transferFlashLoanProtocolFeeInternal(address _token, uint256 _amount) internal {     address payable receiver = address(uint160(addressesProvider.getTokenDistributor()));      if (_token != EthAddressLib.ethAddress()) {         ERC20(_token).safeTransfer(receiver, _amount);     } else {         receiver.transfer(_amount);     } }  /** * @dev updates the internal configuration of the core **/ function refreshConfigInternal() internal {     lendingPoolAddress = addressesProvider.getLendingPool(); }  /** * @dev adds a reserve to the array of the reserves address **/ function addReserveToListInternal(address _reserve) internal {     bool reserveAlreadyAdded = false;     for (uint256 i = 0; i &lt; reservesList.length; i++)         if (reservesList[i] == _reserve) {             reserveAlreadyAdded = true;         }     if (!reserveAlreadyAdded) reservesList.push(_reserve); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 04:31:26 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: pragma solidity ^0.5.0;

import "openzeppelin-solidity/contracts/math/SafeMath.sol";
import "openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol";
import "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol";
import "openzeppelin-solidity/contracts/utils/Address.sol";
import "../libraries/openzeppelin-upgradeability/VersionedInitializable.sol";

import "../libraries/CoreLibrary.sol";
import "../configuration/LendingPoolAddressesProvider.sol";
import "../interfaces/ILendingRateOracle.sol";
import "../interfaces/IReserveInterestRateStrategy.sol";
import "../libraries/WadRayMath.sol";
import "../tokenization/AToken.sol";
import "../libraries/EthAddressLib.sol";

/**
* @title LendingPoolCore contract
* @author Aave
* @notice Holds the state of the lending pool and all the funds deposited
* @dev NOTE: The core does not enforce security checks on the update of the state
* (eg, updateStateOnBorrow() does not enforce that borrowed is enabled on the reserve).
* The check that an action can be performed is a duty of the overlying LendingPool contract.
**/

contract LendingPoolCore is VersionedInitializable {
    using SafeMath for uint256;
    using WadRayMath for uint256;
    using CoreLibrary for CoreLibrary.ReserveData;
    using CoreLibrary for CoreLibrary.UserReserveData;
    using SafeERC20 for ERC20;
    using Address for address payable;

    /**
    * @dev Emitted when the state of a reserve is updated
    * @param reserve the address of the reserve
    * @param liquidityRate the new liquidity rate
    * @param stableBorrowRate the new stable borrow rate
    * @param variableBorrowRate the new variable borrow rate
    * @param liquidityIndex the new liquidity index
    * @param variableBorrowIndex the new variable borrow index
    **/
    event ReserveUpdated(
        address indexed reserve,
        uint256 liquidityRate,
        uint256 stableBorrowRate,
        uint256 variableBorrowRate,
        uint256 liquidityIndex,
        uint256 variableBorrowIndex
    );

    address public lendingPoolAddress;

    LendingPoolAddressesProvider public addressesProvider;

    /**
    * @dev only lending pools can use functions affected by this modifier
    **/
    modifier onlyLendingPool {
        require(lendingPoolAddress == msg.sender, "The caller must be a lending pool contract");
        _;
    }

    /**
    * @dev only lending pools configurator can use functions affected by this modifier
    **/
    modifier onlyLendingPoolConfigurator {
        require(
            addressesProvider.getLendingPoolConfigurator() == msg.sender,
            "The caller must be a lending pool configurator contract"
        );
        _;
    }

    mapping(address => CoreLibrary.ReserveData) internal reserves;
    mapping(address => mapping(address => CoreLibrary.UserReserveData)) internal usersReserveData;

    address[] public reservesList;

    uint256 public constant CORE_REVISION = 0x4;

    /**
    * @dev returns the revision number of the contract
    **/
    function getRevision() internal pure returns (uint256) {
        return CORE_REVISION;
    }

    /**
    * @dev initializes the Core contract, invoked upon registration on the AddressesProvider
    * @param _addressesProvider the addressesProvider contract
    **/

    function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {
        addressesProvider = _addressesProvider;
        refreshConfigInternal();
    }

    /**
    * @dev updates the state of the core as a result of a deposit action
    * @param _reserve the address of the reserve in which the deposit is happening
    * @param _user the address of the the user depositing
    * @param _amount the amount being deposited
    * @param _isFirstDeposit true if the user is depositing for the first time
    **/

    function updateStateOnDeposit(
        address _reserve,
        address _user,
        uint256 _amount,
        bool _isFirstDeposit
    ) external onlyLendingPool {
        reserves[_reserve].updateCumulativeIndexes();
        updateReserveInterestRatesAndTimestampInternal(_reserve, _amount, 0);

        if (_isFirstDeposit) {
            //if this is the first deposit of the user, we configure the deposit as enabled to be used as collateral
            setUserUseReserveAsCollateral(_reserve, _user, true);
        }
    }

    /**
    * @dev updates the state of the core as a result of a redeem action
    * @param _reserve the address of the reserve in which the redeem is happening
    * @param _user the address of the the user redeeming
    * @param _amountRedeemed the amount being redeemed
    * @param _userRedeemedEverything true if the user is redeeming everything
    **/
    function updateStateOnRedeem(
        address _reserve,
        address _user,
        uint256 _amountRedeemed,
        bool _userRedeemedEverything
    ) external onlyLendingPool {
        //compound liquidity and variable borrow interests
        reserves[_reserve].updateCumulativeIndexes();
        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountRedeemed);

        //if user redeemed everything the useReserveAsCollateral flag is reset
        if (_userRedeemedEverything) {
            setUserUseReserveAsCollateral(_reserve, _user, false);
        }
    }

    /**
    * @dev updates the state of the core as a result of a flashloan action
    * @param _reserve the address of the reserve in which the flashloan is happening
    * @param _income the income of the protocol as a result of the action
    **/
    function updateStateOnFlashLoan(
        address _reserve,
        uint256 _availableLiquidityBefore,
        uint256 _income,
        uint256 _protocolFee
    ) external onlyLendingPool {
        transferFlashLoanProtocolFeeInternal(_reserve, _protocolFee);

        //compounding the cumulated interest
        reserves[_reserve].updateCumulativeIndexes();

        uint256 totalLiquidityBefore = _availableLiquidityBefore.add(
            getReserveTotalBorrows(_reserve)
        );

        //compounding the received fee into the reserve
        reserves[_reserve].cumulateToLiquidityIndex(totalLiquidityBefore, _income);

        //refresh interest rates
        updateReserveInterestRatesAndTimestampInternal(_reserve, _income, 0);
    }

    /**
    * @dev updates the state of the core as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _amountBorrowed the new amount borrowed
    * @param _borrowFee the fee on the amount borrowed
    * @param _rateMode the borrow rate mode (stable, variable)
    * @return the new borrow rate for the user
    **/
    function updateStateOnBorrow(
        address _reserve,
        address _user,
        uint256 _amountBorrowed,
        uint256 _borrowFee,
        CoreLibrary.InterestRateMode _rateMode
    ) external onlyLendingPool returns (uint256, uint256) {
        // getting the previous borrow data of the user
        (uint256 principalBorrowBalance, , uint256 balanceIncrease) = getUserBorrowBalances(
            _reserve,
            _user
        );

        updateReserveStateOnBorrowInternal(
            _reserve,
            _user,
            principalBorrowBalance,
            balanceIncrease,
            _amountBorrowed,
            _rateMode
        );

        updateUserStateOnBorrowInternal(
            _reserve,
            _user,
            _amountBorrowed,
            balanceIncrease,
            _borrowFee,
            _rateMode
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountBorrowed);

        return (getUserCurrentBorrowRate(_reserve, _user), balanceIncrease);
    }

    /**
    * @dev updates the state of the core as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _originationFeeRepaid the fee on the amount that is being repaid
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _repaidWholeLoan true if the user is repaying the whole loan
    **/

    function updateStateOnRepay(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _originationFeeRepaid,
        uint256 _balanceIncrease,
        bool _repaidWholeLoan
    ) external onlyLendingPool {
        updateReserveStateOnRepayInternal(
            _reserve,
            _user,
            _paybackAmountMinusFees,
            _balanceIncrease
        );
        updateUserStateOnRepayInternal(
            _reserve,
            _user,
            _paybackAmountMinusFees,
            _originationFeeRepaid,
            _balanceIncrease,
            _repaidWholeLoan
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, _paybackAmountMinusFees, 0);
    }

    /**
    * @dev updates the state of the core as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the amount borrowed by the user
    * @param _compoundedBorrowBalance the amount borrowed plus accrued interest
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _currentRateMode the current interest rate mode for the user
    **/
    function updateStateOnSwapRate(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _compoundedBorrowBalance,
        uint256 _balanceIncrease,
        CoreLibrary.InterestRateMode _currentRateMode
    ) external onlyLendingPool returns (CoreLibrary.InterestRateMode, uint256) {
        updateReserveStateOnSwapRateInternal(
            _reserve,
            _user,
            _principalBorrowBalance,
            _compoundedBorrowBalance,
            _currentRateMode
        );

        CoreLibrary.InterestRateMode newRateMode = updateUserStateOnSwapRateInternal(
            _reserve,
            _user,
            _balanceIncrease,
            _currentRateMode
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);

        return (newRateMode, getUserCurrentBorrowRate(_reserve, _user));
    }

    /**
    * @dev updates the state of the core as a consequence of a liquidation action.
    * @param _principalReserve the address of the principal reserve that is being repaid
    * @param _collateralReserve the address of the collateral reserve that is being liquidated
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _collateralToLiquidate the amount of collateral being liquidated
    * @param _feeLiquidated the amount of origination fee being liquidated
    * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise
    **/
    function updateStateOnLiquidation(
        address _principalReserve,
        address _collateralReserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _collateralToLiquidate,
        uint256 _feeLiquidated,
        uint256 _liquidatedCollateralForFee,
        uint256 _balanceIncrease,
        bool _liquidatorReceivesAToken
    ) external onlyLendingPool {
        updatePrincipalReserveStateOnLiquidationInternal(
            _principalReserve,
            _user,
            _amountToLiquidate,
            _balanceIncrease
        );

        updateCollateralReserveStateOnLiquidationInternal(
            _collateralReserve
        );

        updateUserStateOnLiquidationInternal(
            _principalReserve,
            _user,
            _amountToLiquidate,
            _feeLiquidated,
            _balanceIncrease
        );

        updateReserveInterestRatesAndTimestampInternal(_principalReserve, _amountToLiquidate, 0);

        if (!_liquidatorReceivesAToken) {
            updateReserveInterestRatesAndTimestampInternal(
                _collateralReserve,
                0,
                _collateralToLiquidate.add(_liquidatedCollateralForFee)
            );
        }

    }

    /**
    * @dev updates the state of the core as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @return the new stable rate for the user
    **/
    function updateStateOnRebalance(address _reserve, address _user, uint256 _balanceIncrease)
    external
    onlyLendingPool
    returns (uint256)
    {
        updateReserveStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);

        //update user data and rebalance the rate
        updateUserStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);
        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);
        return usersReserveData[_user][_reserve].stableBorrowRate;
    }

    /**
    * @dev enables or disables a reserve as collateral
    * @param _reserve the address of the principal reserve where the user deposited
    * @param _user the address of the depositor
    * @param _useAsCollateral true if the depositor wants to use the reserve as collateral
    **/
    function setUserUseReserveAsCollateral(address _reserve, address _user, bool _useAsCollateral)
    public
    onlyLendingPool
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        user.useAsCollateral = _useAsCollateral;
    }

    /**
    * @notice ETH/token transfer functions
    **/

    /**
    * @dev fallback function enforces that the caller is a contract, to support flashloan transfers
    **/
    function() external payable {
        //only contracts can send ETH to the core
        require(msg.sender.isContract(), "Only contracts can send ether to the Lending pool core");

    }

    /**
    * @dev transfers to the user a specific amount from the reserve.
    * @param _reserve the address of the reserve where the transfer is happening
    * @param _user the address of the user receiving the transfer
    * @param _amount the amount being transferred
    **/
    function transferToUser(address _reserve, address payable _user, uint256 _amount)
    external
    onlyLendingPool
    {
        if (_reserve != EthAddressLib.ethAddress()) {
            ERC20(_reserve).safeTransfer(_user, _amount);
        } else {
            //solium-disable-next-line
            (bool result, ) = _user.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers the protocol fees to the fees collection address
    * @param _token the address of the token being transferred
    * @param _user the address of the user from where the transfer is happening
    * @param _amount the amount being transferred
    * @param _destination the fee receiver address
    **/

    function transferToFeeCollectionAddress(
        address _token,
        address _user,
        uint256 _amount,
        address _destination
    ) external payable onlyLendingPool {
        address payable feeAddress = address(uint160(_destination)); //cast the address to payable

        if (_token != EthAddressLib.ethAddress()) {
            require(
                msg.value == 0,
                "User is sending ETH along with the ERC20 transfer. Check the value attribute of the transaction"
            );
            ERC20(_token).safeTransferFrom(_user, feeAddress, _amount);
        } else {
            require(msg.value >= _amount, "The amount and the value sent to deposit do not match");
            //solium-disable-next-line
            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers the fees to the fees collection address in the case of liquidation
    * @param _token the address of the token being transferred
    * @param _amount the amount being transferred
    * @param _destination the fee receiver address
    **/
    function liquidateFee(
        address _token,
        uint256 _amount,
        address _destination
    ) external payable onlyLendingPool {
        address payable feeAddress = address(uint160(_destination)); //cast the address to payable
        require(
            msg.value == 0,
            "Fee liquidation does not require any transfer of value"
        );

        if (_token != EthAddressLib.ethAddress()) {
            ERC20(_token).safeTransfer(feeAddress, _amount);
        } else {
            //solium-disable-next-line
            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers an amount from a user to the destination reserve
    * @param _reserve the address of the reserve where the amount is being transferred
    * @param _user the address of the user from where the transfer is happening
    * @param _amount the amount being transferred
    **/
    function transferToReserve(address _reserve, address payable _user, uint256 _amount)
    external
    payable
    onlyLendingPool
    {
        if (_reserve != EthAddressLib.ethAddress()) {
            require(msg.value == 0, "User is sending ETH along with the ERC20 transfer.");
            ERC20(_reserve).safeTransferFrom(_user, address(this), _amount);

        } else {
            require(msg.value >= _amount, "The amount and the value sent to deposit do not match");

            if (msg.value > _amount) {
                //send back excess ETH
                uint256 excessAmount = msg.value.sub(_amount);
                //solium-disable-next-line
                (bool result, ) = _user.call.value(excessAmount).gas(50000)("");
                require(result, "Transfer of ETH failed");
            }
        }
    }

    /**
    * @notice data access functions
    **/

    /**
    * @dev returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral)
    * needed to calculate the global account data in the LendingPoolDataProvider
    * @param _reserve the address of the reserve
    * @param _user the address of the user
    * @return the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not
    **/
    function getUserBasicReserveData(address _reserve, address _user)
    external
    view
    returns (uint256, uint256, uint256, bool)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        uint256 underlyingBalance = getUserUnderlyingAssetBalance(_reserve, _user);

        if (user.principalBorrowBalance == 0) {
            return (underlyingBalance, 0, 0, user.useAsCollateral);
        }

        return (
        underlyingBalance,
        user.getCompoundedBorrowBalance(reserve),
        user.originationFee,
        user.useAsCollateral
        );
    }

    /**
    * @dev checks if a user is allowed to borrow at a stable rate
    * @param _reserve the reserve address
    * @param _user the user
    * @param _amount the amount the the user wants to borrow
    * @return true if the user is allowed to borrow at a stable rate, false otherwise
    **/

    function isUserAllowedToBorrowAtStable(address _reserve, address _user, uint256 _amount)
    external
    view
    returns (bool)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (!reserve.isStableBorrowRateEnabled) return false;

        return
        !user.useAsCollateral ||
        !reserve.usageAsCollateralEnabled ||
        _amount > getUserUnderlyingAssetBalance(_reserve, _user);
    }

    /**
    * @dev gets the underlying asset balance of a user based on the corresponding aToken balance.
    * @param _reserve the reserve address
    * @param _user the user address
    * @return the underlying deposit balance of the user
    **/

    function getUserUnderlyingAssetBalance(address _reserve, address _user)
    public
    view
    returns (uint256)
    {
        AToken aToken = AToken(reserves[_reserve].aTokenAddress);
        return aToken.balanceOf(_user);

    }

    /**
    * @dev gets the interest rate strategy contract address for the reserve
    * @param _reserve the reserve address
    * @return the address of the interest rate strategy contract
    **/
    function getReserveInterestRateStrategyAddress(address _reserve) public view returns (address) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.interestRateStrategyAddress;
    }

    /**
    * @dev gets the aToken contract address for the reserve
    * @param _reserve the reserve address
    * @return the address of the aToken contract
    **/

    function getReserveATokenAddress(address _reserve) public view returns (address) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.aTokenAddress;
    }

    /**
    * @dev gets the available liquidity in the reserve. The available liquidity is the balance of the core contract
    * @param _reserve the reserve address
    * @return the available liquidity
    **/
    function getReserveAvailableLiquidity(address _reserve) public view returns (uint256) {
        uint256 balance = 0;

        if (_reserve == EthAddressLib.ethAddress()) {
            balance = address(this).balance;
        } else {
            balance = IERC20(_reserve).balanceOf(address(this));
        }
        return balance;
    }

    /**
    * @dev gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows
    * @param _reserve the reserve address
    * @return the total liquidity
    **/
    function getReserveTotalLiquidity(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return getReserveAvailableLiquidity(_reserve).add(reserve.getTotalBorrows());
    }

    /**
    * @dev gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there
    * there has been 100% income.
    * @param _reserve the reserve address
    * @return the reserve normalized income
    **/
    function getReserveNormalizedIncome(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.getNormalizedIncome();
    }

    /**
    * @dev gets the reserve total borrows
    * @param _reserve the reserve address
    * @return the total borrows (stable + variable)
    **/
    function getReserveTotalBorrows(address _reserve) public view returns (uint256) {
        return reserves[_reserve].getTotalBorrows();
    }

    /**
    * @dev gets the reserve total borrows stable
    * @param _reserve the reserve address
    * @return the total borrows stable
    **/
    function getReserveTotalBorrowsStable(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.totalBorrowsStable;
    }

    /**
    * @dev gets the reserve total borrows variable
    * @param _reserve the reserve address
    * @return the total borrows variable
    **/

    function getReserveTotalBorrowsVariable(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.totalBorrowsVariable;
    }

    /**
    * @dev gets the reserve liquidation threshold
    * @param _reserve the reserve address
    * @return the reserve liquidation threshold
    **/

    function getReserveLiquidationThreshold(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.liquidationThreshold;
    }

    /**
    * @dev gets the reserve liquidation bonus
    * @param _reserve the reserve address
    * @return the reserve liquidation bonus
    **/

    function getReserveLiquidationBonus(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.liquidationBonus;
    }

    /**
    * @dev gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty
    * @param _reserve the reserve address
    * @return the reserve current variable borrow rate
    **/

    function getReserveCurrentVariableBorrowRate(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        if (reserve.currentVariableBorrowRate == 0) {
            return
            IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)
            .getBaseVariableBorrowRate();
        }
        return reserve.currentVariableBorrowRate;
    }

    /**
    * @dev gets the reserve current stable borrow rate. Is the market rate if the reserve is empty
    * @param _reserve the reserve address
    * @return the reserve current stable borrow rate
    **/

    function getReserveCurrentStableBorrowRate(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        ILendingRateOracle oracle = ILendingRateOracle(addressesProvider.getLendingRateOracle());

        if (reserve.currentStableBorrowRate == 0) {
            //no stable rate borrows yet
            return oracle.getMarketBorrowRate(_reserve);
        }

        return reserve.currentStableBorrowRate;
    }

    /**
    * @dev gets the reserve average stable borrow rate. The average stable rate is the weighted average
    * of all the loans taken at stable rate.
    * @param _reserve the reserve address
    * @return the reserve current average borrow rate
    **/
    function getReserveCurrentAverageStableBorrowRate(address _reserve)
    external
    view
    returns (uint256)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.currentAverageStableBorrowRate;
    }

    /**
    * @dev gets the reserve liquidity rate
    * @param _reserve the reserve address
    * @return the reserve liquidity rate
    **/
    function getReserveCurrentLiquidityRate(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.currentLiquidityRate;
    }

    /**
    * @dev gets the reserve liquidity cumulative index
    * @param _reserve the reserve address
    * @return the reserve liquidity cumulative index
    **/
    function getReserveLiquidityCumulativeIndex(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.lastLiquidityCumulativeIndex;
    }

    /**
    * @dev gets the reserve variable borrow index
    * @param _reserve the reserve address
    * @return the reserve variable borrow index
    **/
    function getReserveVariableBorrowsCumulativeIndex(address _reserve)
    external
    view
    returns (uint256)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.lastVariableBorrowCumulativeIndex;
    }

    /**
    * @dev this function aggregates the configuration parameters of the reserve.
    * It's used in the LendingPoolDataProvider specifically to save gas, and avoid
    * multiple external contract calls to fetch the same data.
    * @param _reserve the reserve address
    * @return the reserve decimals
    * @return the base ltv as collateral
    * @return the liquidation threshold
    * @return if the reserve is used as collateral or not
    **/
    function getReserveConfiguration(address _reserve)
    external
    view
    returns (uint256, uint256, uint256, bool)
    {
        uint256 decimals;
        uint256 baseLTVasCollateral;
        uint256 liquidationThreshold;
        bool usageAsCollateralEnabled;

        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        decimals = reserve.decimals;
        baseLTVasCollateral = reserve.baseLTVasCollateral;
        liquidationThreshold = reserve.liquidationThreshold;
        usageAsCollateralEnabled = reserve.usageAsCollateralEnabled;

        return (decimals, baseLTVasCollateral, liquidationThreshold, usageAsCollateralEnabled);
    }

    /**
    * @dev returns the decimals of the reserve
    * @param _reserve the reserve address
    * @return the reserve decimals
    **/
    function getReserveDecimals(address _reserve) external view returns (uint256) {
        return reserves[_reserve].decimals;
    }

    /**
    * @dev returns true if the reserve is enabled for borrowing
    * @param _reserve the reserve address
    * @return true if the reserve is enabled for borrowing, false otherwise
    **/

    function isReserveBorrowingEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.borrowingEnabled;
    }

    /**
    * @dev returns true if the reserve is enabled as collateral
    * @param _reserve the reserve address
    * @return true if the reserve is enabled as collateral, false otherwise
    **/

    function isReserveUsageAsCollateralEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.usageAsCollateralEnabled;
    }

    /**
    * @dev returns true if the stable rate is enabled on reserve
    * @param _reserve the reserve address
    * @return true if the stable rate is enabled on reserve, false otherwise
    **/
    function getReserveIsStableBorrowRateEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isStableBorrowRateEnabled;
    }

    /**
    * @dev returns true if the reserve is active
    * @param _reserve the reserve address
    * @return true if the reserve is active, false otherwise
    **/
    function getReserveIsActive(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isActive;
    }

    /**
    * @notice returns if a reserve is freezed
    * @param _reserve the reserve for which the information is needed
    * @return true if the reserve is freezed, false otherwise
    **/

    function getReserveIsFreezed(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isFreezed;
    }

    /**
    * @notice returns the timestamp of the last action on the reserve
    * @param _reserve the reserve for which the information is needed
    * @return the last updated timestamp of the reserve
    **/

    function getReserveLastUpdate(address _reserve) external view returns (uint40 timestamp) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        timestamp = reserve.lastUpdateTimestamp;
    }

    /**
    * @dev returns the utilization rate U of a specific reserve
    * @param _reserve the reserve for which the information is needed
    * @return the utilization rate in ray
    **/

    function getReserveUtilizationRate(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        uint256 totalBorrows = reserve.getTotalBorrows();

        if (totalBorrows == 0) {
            return 0;
        }

        uint256 availableLiquidity = getReserveAvailableLiquidity(_reserve);

        return totalBorrows.rayDiv(availableLiquidity.add(totalBorrows));
    }

    /**
    * @return the array of reserves configured on the core
    **/
    function getReserves() external view returns (address[] memory) {
        return reservesList;
    }

    /**
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return true if the user has chosen to use the reserve as collateral, false otherwise
    **/
    function isUserUseReserveAsCollateralEnabled(address _reserve, address _user)
    external
    view
    returns (bool)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.useAsCollateral;
    }

    /**
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the origination fee for the user
    **/
    function getUserOriginationFee(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.originationFee;
    }

    /**
    * @dev users with no loans in progress have NONE as borrow rate mode
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the borrow rate mode for the user,
    **/

    function getUserCurrentBorrowRateMode(address _reserve, address _user)
    public
    view
    returns (CoreLibrary.InterestRateMode)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (user.principalBorrowBalance == 0) {
            return CoreLibrary.InterestRateMode.NONE;
        }

        return
        user.stableBorrowRate > 0
        ? CoreLibrary.InterestRateMode.STABLE
        : CoreLibrary.InterestRateMode.VARIABLE;
    }

    /**
    * @dev gets the current borrow rate of the user
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the borrow rate for the user,
    **/
    function getUserCurrentBorrowRate(address _reserve, address _user)
    internal
    view
    returns (uint256)
    {
        CoreLibrary.InterestRateMode rateMode = getUserCurrentBorrowRateMode(_reserve, _user);

        if (rateMode == CoreLibrary.InterestRateMode.NONE) {
            return 0;
        }

        return
        rateMode == CoreLibrary.InterestRateMode.STABLE
        ? usersReserveData[_user][_reserve].stableBorrowRate
        : reserves[_reserve].currentVariableBorrowRate;
    }

    /**
    * @dev the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the user stable rate
    **/
    function getUserCurrentStableBorrowRate(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.stableBorrowRate;
    }

    /**
    * @dev calculates and returns the borrow balances of the user
    * @param _reserve the address of the reserve
    * @param _user the address of the user
    * @return the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance
    **/

    function getUserBorrowBalances(address _reserve, address _user)
    public
    view
    returns (uint256, uint256, uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        if (user.principalBorrowBalance == 0) {
            return (0, 0, 0);
        }

        uint256 principal = user.principalBorrowBalance;
        uint256 compoundedBalance = CoreLibrary.getCompoundedBorrowBalance(
            user,
            reserves[_reserve]
        );
        return (principal, compoundedBalance, compoundedBalance.sub(principal));
    }

    /**
    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the variable borrow index for the user
    **/

    function getUserVariableBorrowCumulativeIndex(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.lastVariableBorrowCumulativeIndex;
    }

    /**
    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the variable borrow index for the user
    **/

    function getUserLastUpdate(address _reserve, address _user)
    external
    view
    returns (uint256 timestamp)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        timestamp = user.lastUpdateTimestamp;
    }

    /**
    * @dev updates the lending pool core configuration
    **/
    function refreshConfiguration() external onlyLendingPoolConfigurator {
        refreshConfigInternal();
    }

    /**
    * @dev initializes a reserve
    * @param _reserve the address of the reserve
    * @param _aTokenAddress the address of the overlying aToken contract
    * @param _decimals the decimals of the reserve currency
    * @param _interestRateStrategyAddress the address of the interest rate strategy contract
    **/
    function initReserve(
        address _reserve,
        address _aTokenAddress,
        uint256 _decimals,
        address _interestRateStrategyAddress
    ) external onlyLendingPoolConfigurator {
        reserves[_reserve].init(_aTokenAddress, _decimals, _interestRateStrategyAddress);
        addReserveToListInternal(_reserve);

    }



    /**
    * @dev removes the last added reserve in the reservesList array
    * @param _reserveToRemove the address of the reserve
    **/
    function removeLastAddedReserve(address _reserveToRemove)
    external onlyLendingPoolConfigurator {

        address lastReserve = reservesList[reservesList.length-1];

        require(lastReserve == _reserveToRemove, "Reserve being removed is different than the reserve requested");

        //as we can't check if totalLiquidity is 0 (since the reserve added might not be an ERC20) we at least check that there is nothing borrowed
        require(getReserveTotalBorrows(lastReserve) == 0, "Cannot remove a reserve with liquidity deposited");

        reserves[lastReserve].isActive = false;
        reserves[lastReserve].aTokenAddress = address(0);
        reserves[lastReserve].decimals = 0;
        reserves[lastReserve].lastLiquidityCumulativeIndex = 0;
        reserves[lastReserve].lastVariableBorrowCumulativeIndex = 0;
        reserves[lastReserve].borrowingEnabled = false;
        reserves[lastReserve].usageAsCollateralEnabled = false;
        reserves[lastReserve].baseLTVasCollateral = 0;
        reserves[lastReserve].liquidationThreshold = 0;
        reserves[lastReserve].liquidationBonus = 0;
        reserves[lastReserve].interestRateStrategyAddress = address(0);

        reservesList.pop();
    }

    /**
    * @dev updates the address of the interest rate strategy contract
    * @param _reserve the address of the reserve
    * @param _rateStrategyAddress the address of the interest rate strategy contract
    **/

    function setReserveInterestRateStrategyAddress(address _reserve, address _rateStrategyAddress)
    external
    onlyLendingPoolConfigurator
    {
        reserves[_reserve].interestRateStrategyAddress = _rateStrategyAddress;
    }

    /**
    * @dev enables borrowing on a reserve. Also sets the stable rate borrowing
    * @param _reserve the address of the reserve
    * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise
    **/

    function enableBorrowingOnReserve(address _reserve, bool _stableBorrowRateEnabled)
    external
    onlyLendingPoolConfigurator
    {
        reserves[_reserve].enableBorrowing(_stableBorrowRateEnabled);
    }

    /**
    * @dev disables borrowing on a reserve
    * @param _reserve the address of the reserve
    **/

    function disableBorrowingOnReserve(address _reserve) external onlyLendingPoolConfigurator {
        reserves[_reserve].disableBorrowing();
    }

    /**
    * @dev enables a reserve to be used as collateral
    * @param _reserve the address of the reserve
    **/
    function enableReserveAsCollateral(
        address _reserve,
        uint256 _baseLTVasCollateral,
        uint256 _liquidationThreshold,
        uint256 _liquidationBonus
    ) external onlyLendingPoolConfigurator {
        reserves[_reserve].enableAsCollateral(
            _baseLTVasCollateral,
            _liquidationThreshold,
            _liquidationBonus
        );
    }

    /**
    * @dev disables a reserve to be used as collateral
    * @param _reserve the address of the reserve
    **/
    function disableReserveAsCollateral(address _reserve) external onlyLendingPoolConfigurator {
        reserves[_reserve].disableAsCollateral();
    }

    /**
    * @dev enable the stable borrow rate mode on a reserve
    * @param _reserve the address of the reserve
    **/
    function enableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isStableBorrowRateEnabled = true;
    }

    /**
    * @dev disable the stable borrow rate mode on a reserve
    * @param _reserve the address of the reserve
    **/
    function disableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isStableBorrowRateEnabled = false;
    }

    /**
    * @dev activates a reserve
    * @param _reserve the address of the reserve
    **/
    function activateReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        require(
            reserve.lastLiquidityCumulativeIndex > 0 &&
            reserve.lastVariableBorrowCumulativeIndex > 0,
            "Reserve has not been initialized yet"
        );
        reserve.isActive = true;
    }

    /**
    * @dev deactivates a reserve
    * @param _reserve the address of the reserve
    **/
    function deactivateReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isActive = false;
    }

    /**
    * @notice allows the configurator to freeze the reserve.
    * A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance.
    * @param _reserve the address of the reserve
    **/
    function freezeReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isFreezed = true;
    }

    /**
    * @notice allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed.
    * @param _reserve the address of the reserve
    **/
    function unfreezeReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isFreezed = false;
    }

    /**
    * @notice allows the configurator to update the loan to value of a reserve
    * @param _reserve the address of the reserve
    * @param _ltv the new loan to value
    **/
    function setReserveBaseLTVasCollateral(address _reserve, uint256 _ltv)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.baseLTVasCollateral = _ltv;
    }

    /**
    * @notice allows the configurator to update the liquidation threshold of a reserve
    * @param _reserve the address of the reserve
    * @param _threshold the new liquidation threshold
    **/
    function setReserveLiquidationThreshold(address _reserve, uint256 _threshold)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.liquidationThreshold = _threshold;
    }

    /**
    * @notice allows the configurator to update the liquidation bonus of a reserve
    * @param _reserve the address of the reserve
    * @param _bonus the new liquidation bonus
    **/
    function setReserveLiquidationBonus(address _reserve, uint256 _bonus)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.liquidationBonus = _bonus;
    }

    /**
    * @notice allows the configurator to update the reserve decimals
    * @param _reserve the address of the reserve
    * @param _decimals the decimals of the reserve
    **/
    function setReserveDecimals(address _reserve, uint256 _decimals)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.decimals = _decimals;
    }

    /**
    * @notice internal functions
    **/

    /**
    * @dev updates the state of a reserve as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the previous borrow balance of the borrower before the action
    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount
    * @param _amountBorrowed the new amount borrowed
    * @param _rateMode the borrow rate mode (stable, variable)
    **/

    function updateReserveStateOnBorrowInternal(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _balanceIncrease,
        uint256 _amountBorrowed,
        CoreLibrary.InterestRateMode _rateMode
    ) internal {
        reserves[_reserve].updateCumulativeIndexes();

        //increasing reserve total borrows to account for the new borrow balance of the user
        //NOTE: Depending on the previous borrow mode, the borrows might need to be switched from variable to stable or vice versa

        updateReserveTotalBorrowsByRateModeInternal(
            _reserve,
            _user,
            _principalBorrowBalance,
            _balanceIncrease,
            _amountBorrowed,
            _rateMode
        );
    }

    /**
    * @dev updates the state of a user as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _amountBorrowed the amount borrowed
    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount
    * @param _rateMode the borrow rate mode (stable, variable)
    * @return the final borrow rate for the user. Emitted by the borrow() event
    **/

    function updateUserStateOnBorrowInternal(
        address _reserve,
        address _user,
        uint256 _amountBorrowed,
        uint256 _balanceIncrease,
        uint256 _fee,
        CoreLibrary.InterestRateMode _rateMode
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (_rateMode == CoreLibrary.InterestRateMode.STABLE) {
            //stable
            //reset the user variable index, and update the stable rate
            user.stableBorrowRate = reserve.currentStableBorrowRate;
            user.lastVariableBorrowCumulativeIndex = 0;
        } else if (_rateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //variable
            //reset the user stable rate, and store the new borrow index
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        } else {
            revert("Invalid borrow rate mode");
        }
        //increase the principal borrows and the origination fee
        user.principalBorrowBalance = user.principalBorrowBalance.add(_amountBorrowed).add(
            _balanceIncrease
        );
        user.originationFee = user.originationFee.add(_fee);

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

    }

    /**
    * @dev updates the state of the reserve as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateReserveStateOnRepayInternal(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_reserve][_user];

        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(_reserve, _user);

        //update the indexes
        reserves[_reserve].updateCumulativeIndexes();

        //compound the cumulated interest to the borrow balance and then subtracting the payback amount
        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _balanceIncrease,
                user.stableBorrowRate
            );
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _paybackAmountMinusFees,
                user.stableBorrowRate
            );
        } else {
            reserve.increaseTotalBorrowsVariable(_balanceIncrease);
            reserve.decreaseTotalBorrowsVariable(_paybackAmountMinusFees);
        }
    }

    /**
    * @dev updates the state of the user as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _originationFeeRepaid the fee on the amount that is being repaid
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _repaidWholeLoan true if the user is repaying the whole loan
    **/
    function updateUserStateOnRepayInternal(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _originationFeeRepaid,
        uint256 _balanceIncrease,
        bool _repaidWholeLoan
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        //update the user principal borrow balance, adding the cumulated interest and then subtracting the payback amount
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(
            _paybackAmountMinusFees
        );
        user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;

        //if the balance decrease is equal to the previous principal (user is repaying the whole loan)
        //and the rate mode is stable, we reset the interest rate mode of the user
        if (_repaidWholeLoan) {
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = 0;
        }
        user.originationFee = user.originationFee.sub(_originationFeeRepaid);

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

    }

    /**
    * @dev updates the state of the user as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is performing the rate swap
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the the principal amount borrowed by the user
    * @param _compoundedBorrowBalance the principal amount plus the accrued interest
    * @param _currentRateMode the rate mode at which the user borrowed
    **/
    function updateReserveStateOnSwapRateInternal(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _compoundedBorrowBalance,
        CoreLibrary.InterestRateMode _currentRateMode
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        //compounding reserve indexes
        reserve.updateCumulativeIndexes();

        if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {
            uint256 userCurrentStableRate = user.stableBorrowRate;

            //swap to variable
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _principalBorrowBalance,
                userCurrentStableRate
            ); //decreasing stable from old principal balance
            reserve.increaseTotalBorrowsVariable(_compoundedBorrowBalance); //increase variable borrows
        } else if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //swap to stable
            uint256 currentStableRate = reserve.currentStableBorrowRate;
            reserve.decreaseTotalBorrowsVariable(_principalBorrowBalance);
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _compoundedBorrowBalance,
                currentStableRate
            );

        } else {
            revert("Invalid rate mode received");
        }
    }

    /**
    * @dev updates the state of the user as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is performing the swap
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _currentRateMode the current rate mode of the user
    **/

    function updateUserStateOnSwapRateInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease,
        CoreLibrary.InterestRateMode _currentRateMode
    ) internal returns (CoreLibrary.InterestRateMode) {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        CoreLibrary.InterestRateMode newMode = CoreLibrary.InterestRateMode.NONE;

        if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //switch to stable
            newMode = CoreLibrary.InterestRateMode.STABLE;
            user.stableBorrowRate = reserve.currentStableBorrowRate;
            user.lastVariableBorrowCumulativeIndex = 0;
        } else if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {
            newMode = CoreLibrary.InterestRateMode.VARIABLE;
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        } else {
            revert("Invalid interest rate mode received");
        }
        //compounding cumulated interest
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);
        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

        return newMode;
    }

    /**
    * @dev updates the state of the principal reserve as a consequence of a liquidation action.
    * @param _principalReserve the address of the principal reserve that is being repaid
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updatePrincipalReserveStateOnLiquidationInternal(
        address _principalReserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_principalReserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_principalReserve];

        //update principal reserve data
        reserve.updateCumulativeIndexes();

        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(
            _principalReserve,
            _user
        );

        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            //increase the total borrows by the compounded interest
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _balanceIncrease,
                user.stableBorrowRate
            );

            //decrease by the actual amount to liquidate
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _amountToLiquidate,
                user.stableBorrowRate
            );

        } else {
            //increase the total borrows by the compounded interest
            reserve.increaseTotalBorrowsVariable(_balanceIncrease);

            //decrease by the actual amount to liquidate
            reserve.decreaseTotalBorrowsVariable(_amountToLiquidate);
        }

    }

    /**
    * @dev updates the state of the collateral reserve as a consequence of a liquidation action.
    * @param _collateralReserve the address of the collateral reserve that is being liquidated
    **/
    function updateCollateralReserveStateOnLiquidationInternal(
        address _collateralReserve
    ) internal {
        //update collateral reserve
        reserves[_collateralReserve].updateCumulativeIndexes();

    }

    /**
    * @dev updates the state of the user being liquidated as a consequence of a liquidation action.
    * @param _reserve the address of the principal reserve that is being repaid
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _feeLiquidated the amount of origination fee being liquidated
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/
    function updateUserStateOnLiquidationInternal(
        address _reserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _feeLiquidated,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        //first increase by the compounded interest, then decrease by the liquidated amount
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(
            _amountToLiquidate
        );

        if (
            getUserCurrentBorrowRateMode(_reserve, _user) == CoreLibrary.InterestRateMode.VARIABLE
        ) {
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        }

        if(_feeLiquidated > 0){
            user.originationFee = user.originationFee.sub(_feeLiquidated);
        }

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);
    }

    /**
    * @dev updates the state of the reserve as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateReserveStateOnRebalanceInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        reserve.updateCumulativeIndexes();

        reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
            _balanceIncrease,
            user.stableBorrowRate
        );

    }

    /**
    * @dev updates the state of the user as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateUserStateOnRebalanceInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);
        user.stableBorrowRate = reserve.currentStableBorrowRate;

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);
    }

    /**
    * @dev updates the state of the user as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _amountBorrowed the accrued interest on the borrowed amount
    **/
    function updateReserveTotalBorrowsByRateModeInternal(
        address _reserve,
        address _user,
        uint256 _principalBalance,
        uint256 _balanceIncrease,
        uint256 _amountBorrowed,
        CoreLibrary.InterestRateMode _newBorrowRateMode
    ) internal {
        CoreLibrary.InterestRateMode previousRateMode = getUserCurrentBorrowRateMode(
            _reserve,
            _user
        );
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        if (previousRateMode == CoreLibrary.InterestRateMode.STABLE) {
            CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _principalBalance,
                user.stableBorrowRate
            );
        } else if (previousRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            reserve.decreaseTotalBorrowsVariable(_principalBalance);
        }

        uint256 newPrincipalAmount = _principalBalance.add(_balanceIncrease).add(_amountBorrowed);
        if (_newBorrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                newPrincipalAmount,
                reserve.currentStableBorrowRate
            );
        } else if (_newBorrowRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            reserve.increaseTotalBorrowsVariable(newPrincipalAmount);
        } else {
            revert("Invalid new borrow rate mode");
        }
    }

    /**
    * @dev Updates the reserve current stable borrow rate Rf, the current variable borrow rate Rv and the current liquidity rate Rl.
    * Also updates the lastUpdateTimestamp value. Please refer to the whitepaper for further information.
    * @param _reserve the address of the reserve to be updated
    * @param _liquidityAdded the amount of liquidity added to the protocol (deposit or repay) in the previous action
    * @param _liquidityTaken the amount of liquidity taken from the protocol (redeem or borrow)
    **/

    function updateReserveInterestRatesAndTimestampInternal(
        address _reserve,
        uint256 _liquidityAdded,
        uint256 _liquidityTaken
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        (uint256 newLiquidityRate, uint256 newStableRate, uint256 newVariableRate) = IReserveInterestRateStrategy(
            reserve
            .interestRateStrategyAddress
        )
        .calculateInterestRates(
            _reserve,
            getReserveAvailableLiquidity(_reserve).add(_liquidityAdded).sub(_liquidityTaken),
            reserve.totalBorrowsStable,
            reserve.totalBorrowsVariable,
            reserve.currentAverageStableBorrowRate
        );

        reserve.currentLiquidityRate = newLiquidityRate;
        reserve.currentStableBorrowRate = newStableRate;
        reserve.currentVariableBorrowRate = newVariableRate;

        //solium-disable-next-line
        reserve.lastUpdateTimestamp = uint40(block.timestamp);

        emit ReserveUpdated(
            _reserve,
            newLiquidityRate,
            newStableRate,
            newVariableRate,
            reserve.lastLiquidityCumulativeIndex,
            reserve.lastVariableBorrowCumulativeIndex
        );
    }

    /**
    * @dev transfers to the protocol fees of a flashloan to the fees collection address
    * @param _token the address of the token being transferred
    * @param _amount the amount being transferred
    **/

    function transferFlashLoanProtocolFeeInternal(address _token, uint256 _amount) internal {
        address payable receiver = address(uint160(addressesProvider.getTokenDistributor()));

        if (_token != EthAddressLib.ethAddress()) {
            ERC20(_token).safeTransfer(receiver, _amount);
        } else {
            receiver.transfer(_amount);
        }
    }

    /**
    * @dev updates the internal configuration of the core
    **/
    function refreshConfigInternal() internal {
        lendingPoolAddress = addressesProvider.getLendingPool();
    }

    /**
    * @dev adds a reserve to the array of the reserves address
    **/
    function addReserveToListInternal(address _reserve) internal {
        bool reserveAlreadyAdded = false;
        for (uint256 i = 0; i < reservesList.length; i++)
            if (reservesList[i] == _reserve) {
                reserveAlreadyAdded = true;
            }
        if (!reserveAlreadyAdded) reservesList.push(_reserve);
    }

}
.]

Given the user's task and the brainstorming ideas provided:
Task: "pragma solidity ^0.5.0;

import "openzeppelin-solidity/contracts/math/SafeMath.sol";
import "openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol";
import "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol";
import "openzeppelin-solidity/contracts/utils/Address.sol";
import "../libraries/openzeppelin-upgradeability/VersionedInitializable.sol";

import "../libraries/CoreLibrary.sol";
import "../configuration/LendingPoolAddressesProvider.sol";
import "../interfaces/ILendingRateOracle.sol";
import "../interfaces/IReserveInterestRateStrategy.sol";
import "../libraries/WadRayMath.sol";
import "../tokenization/AToken.sol";
import "../libraries/EthAddressLib.sol";

/**
* @title LendingPoolCore contract
* @author Aave
* @notice Holds the state of the lending pool and all the funds deposited
* @dev NOTE: The core does not enforce security checks on the update of the state
* (eg, updateStateOnBorrow() does not enforce that borrowed is enabled on the reserve).
* The check that an action can be performed is a duty of the overlying LendingPool contract.
**/

contract LendingPoolCore is VersionedInitializable {
    using SafeMath for uint256;
    using WadRayMath for uint256;
    using CoreLibrary for CoreLibrary.ReserveData;
    using CoreLibrary for CoreLibrary.UserReserveData;
    using SafeERC20 for ERC20;
    using Address for address payable;

    /**
    * @dev Emitted when the state of a reserve is updated
    * @param reserve the address of the reserve
    * @param liquidityRate the new liquidity rate
    * @param stableBorrowRate the new stable borrow rate
    * @param variableBorrowRate the new variable borrow rate
    * @param liquidityIndex the new liquidity index
    * @param variableBorrowIndex the new variable borrow index
    **/
    event ReserveUpdated(
        address indexed reserve,
        uint256 liquidityRate,
        uint256 stableBorrowRate,
        uint256 variableBorrowRate,
        uint256 liquidityIndex,
        uint256 variableBorrowIndex
    );

    address public lendingPoolAddress;

    LendingPoolAddressesProvider public addressesProvider;

    /**
    * @dev only lending pools can use functions affected by this modifier
    **/
    modifier onlyLendingPool {
        require(lendingPoolAddress == msg.sender, "The caller must be a lending pool contract");
        _;
    }

    /**
    * @dev only lending pools configurator can use functions affected by this modifier
    **/
    modifier onlyLendingPoolConfigurator {
        require(
            addressesProvider.getLendingPoolConfigurator() == msg.sender,
            "The caller must be a lending pool configurator contract"
        );
        _;
    }

    mapping(address => CoreLibrary.ReserveData) internal reserves;
    mapping(address => mapping(address => CoreLibrary.UserReserveData)) internal usersReserveData;

    address[] public reservesList;

    uint256 public constant CORE_REVISION = 0x4;

    /**
    * @dev returns the revision number of the contract
    **/
    function getRevision() internal pure returns (uint256) {
        return CORE_REVISION;
    }

    /**
    * @dev initializes the Core contract, invoked upon registration on the AddressesProvider
    * @param _addressesProvider the addressesProvider contract
    **/

    function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {
        addressesProvider = _addressesProvider;
        refreshConfigInternal();
    }

    /**
    * @dev updates the state of the core as a result of a deposit action
    * @param _reserve the address of the reserve in which the deposit is happening
    * @param _user the address of the the user depositing
    * @param _amount the amount being deposited
    * @param _isFirstDeposit true if the user is depositing for the first time
    **/

    function updateStateOnDeposit(
        address _reserve,
        address _user,
        uint256 _amount,
        bool _isFirstDeposit
    ) external onlyLendingPool {
        reserves[_reserve].updateCumulativeIndexes();
        updateReserveInterestRatesAndTimestampInternal(_reserve, _amount, 0);

        if (_isFirstDeposit) {
            //if this is the first deposit of the user, we configure the deposit as enabled to be used as collateral
            setUserUseReserveAsCollateral(_reserve, _user, true);
        }
    }

    /**
    * @dev updates the state of the core as a result of a redeem action
    * @param _reserve the address of the reserve in which the redeem is happening
    * @param _user the address of the the user redeeming
    * @param _amountRedeemed the amount being redeemed
    * @param _userRedeemedEverything true if the user is redeeming everything
    **/
    function updateStateOnRedeem(
        address _reserve,
        address _user,
        uint256 _amountRedeemed,
        bool _userRedeemedEverything
    ) external onlyLendingPool {
        //compound liquidity and variable borrow interests
        reserves[_reserve].updateCumulativeIndexes();
        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountRedeemed);

        //if user redeemed everything the useReserveAsCollateral flag is reset
        if (_userRedeemedEverything) {
            setUserUseReserveAsCollateral(_reserve, _user, false);
        }
    }

    /**
    * @dev updates the state of the core as a result of a flashloan action
    * @param _reserve the address of the reserve in which the flashloan is happening
    * @param _income the income of the protocol as a result of the action
    **/
    function updateStateOnFlashLoan(
        address _reserve,
        uint256 _availableLiquidityBefore,
        uint256 _income,
        uint256 _protocolFee
    ) external onlyLendingPool {
        transferFlashLoanProtocolFeeInternal(_reserve, _protocolFee);

        //compounding the cumulated interest
        reserves[_reserve].updateCumulativeIndexes();

        uint256 totalLiquidityBefore = _availableLiquidityBefore.add(
            getReserveTotalBorrows(_reserve)
        );

        //compounding the received fee into the reserve
        reserves[_reserve].cumulateToLiquidityIndex(totalLiquidityBefore, _income);

        //refresh interest rates
        updateReserveInterestRatesAndTimestampInternal(_reserve, _income, 0);
    }

    /**
    * @dev updates the state of the core as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _amountBorrowed the new amount borrowed
    * @param _borrowFee the fee on the amount borrowed
    * @param _rateMode the borrow rate mode (stable, variable)
    * @return the new borrow rate for the user
    **/
    function updateStateOnBorrow(
        address _reserve,
        address _user,
        uint256 _amountBorrowed,
        uint256 _borrowFee,
        CoreLibrary.InterestRateMode _rateMode
    ) external onlyLendingPool returns (uint256, uint256) {
        // getting the previous borrow data of the user
        (uint256 principalBorrowBalance, , uint256 balanceIncrease) = getUserBorrowBalances(
            _reserve,
            _user
        );

        updateReserveStateOnBorrowInternal(
            _reserve,
            _user,
            principalBorrowBalance,
            balanceIncrease,
            _amountBorrowed,
            _rateMode
        );

        updateUserStateOnBorrowInternal(
            _reserve,
            _user,
            _amountBorrowed,
            balanceIncrease,
            _borrowFee,
            _rateMode
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountBorrowed);

        return (getUserCurrentBorrowRate(_reserve, _user), balanceIncrease);
    }

    /**
    * @dev updates the state of the core as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _originationFeeRepaid the fee on the amount that is being repaid
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _repaidWholeLoan true if the user is repaying the whole loan
    **/

    function updateStateOnRepay(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _originationFeeRepaid,
        uint256 _balanceIncrease,
        bool _repaidWholeLoan
    ) external onlyLendingPool {
        updateReserveStateOnRepayInternal(
            _reserve,
            _user,
            _paybackAmountMinusFees,
            _balanceIncrease
        );
        updateUserStateOnRepayInternal(
            _reserve,
            _user,
            _paybackAmountMinusFees,
            _originationFeeRepaid,
            _balanceIncrease,
            _repaidWholeLoan
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, _paybackAmountMinusFees, 0);
    }

    /**
    * @dev updates the state of the core as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the amount borrowed by the user
    * @param _compoundedBorrowBalance the amount borrowed plus accrued interest
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _currentRateMode the current interest rate mode for the user
    **/
    function updateStateOnSwapRate(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _compoundedBorrowBalance,
        uint256 _balanceIncrease,
        CoreLibrary.InterestRateMode _currentRateMode
    ) external onlyLendingPool returns (CoreLibrary.InterestRateMode, uint256) {
        updateReserveStateOnSwapRateInternal(
            _reserve,
            _user,
            _principalBorrowBalance,
            _compoundedBorrowBalance,
            _currentRateMode
        );

        CoreLibrary.InterestRateMode newRateMode = updateUserStateOnSwapRateInternal(
            _reserve,
            _user,
            _balanceIncrease,
            _currentRateMode
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);

        return (newRateMode, getUserCurrentBorrowRate(_reserve, _user));
    }

    /**
    * @dev updates the state of the core as a consequence of a liquidation action.
    * @param _principalReserve the address of the principal reserve that is being repaid
    * @param _collateralReserve the address of the collateral reserve that is being liquidated
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _collateralToLiquidate the amount of collateral being liquidated
    * @param _feeLiquidated the amount of origination fee being liquidated
    * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise
    **/
    function updateStateOnLiquidation(
        address _principalReserve,
        address _collateralReserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _collateralToLiquidate,
        uint256 _feeLiquidated,
        uint256 _liquidatedCollateralForFee,
        uint256 _balanceIncrease,
        bool _liquidatorReceivesAToken
    ) external onlyLendingPool {
        updatePrincipalReserveStateOnLiquidationInternal(
            _principalReserve,
            _user,
            _amountToLiquidate,
            _balanceIncrease
        );

        updateCollateralReserveStateOnLiquidationInternal(
            _collateralReserve
        );

        updateUserStateOnLiquidationInternal(
            _principalReserve,
            _user,
            _amountToLiquidate,
            _feeLiquidated,
            _balanceIncrease
        );

        updateReserveInterestRatesAndTimestampInternal(_principalReserve, _amountToLiquidate, 0);

        if (!_liquidatorReceivesAToken) {
            updateReserveInterestRatesAndTimestampInternal(
                _collateralReserve,
                0,
                _collateralToLiquidate.add(_liquidatedCollateralForFee)
            );
        }

    }

    /**
    * @dev updates the state of the core as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @return the new stable rate for the user
    **/
    function updateStateOnRebalance(address _reserve, address _user, uint256 _balanceIncrease)
    external
    onlyLendingPool
    returns (uint256)
    {
        updateReserveStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);

        //update user data and rebalance the rate
        updateUserStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);
        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);
        return usersReserveData[_user][_reserve].stableBorrowRate;
    }

    /**
    * @dev enables or disables a reserve as collateral
    * @param _reserve the address of the principal reserve where the user deposited
    * @param _user the address of the depositor
    * @param _useAsCollateral true if the depositor wants to use the reserve as collateral
    **/
    function setUserUseReserveAsCollateral(address _reserve, address _user, bool _useAsCollateral)
    public
    onlyLendingPool
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        user.useAsCollateral = _useAsCollateral;
    }

    /**
    * @notice ETH/token transfer functions
    **/

    /**
    * @dev fallback function enforces that the caller is a contract, to support flashloan transfers
    **/
    function() external payable {
        //only contracts can send ETH to the core
        require(msg.sender.isContract(), "Only contracts can send ether to the Lending pool core");

    }

    /**
    * @dev transfers to the user a specific amount from the reserve.
    * @param _reserve the address of the reserve where the transfer is happening
    * @param _user the address of the user receiving the transfer
    * @param _amount the amount being transferred
    **/
    function transferToUser(address _reserve, address payable _user, uint256 _amount)
    external
    onlyLendingPool
    {
        if (_reserve != EthAddressLib.ethAddress()) {
            ERC20(_reserve).safeTransfer(_user, _amount);
        } else {
            //solium-disable-next-line
            (bool result, ) = _user.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers the protocol fees to the fees collection address
    * @param _token the address of the token being transferred
    * @param _user the address of the user from where the transfer is happening
    * @param _amount the amount being transferred
    * @param _destination the fee receiver address
    **/

    function transferToFeeCollectionAddress(
        address _token,
        address _user,
        uint256 _amount,
        address _destination
    ) external payable onlyLendingPool {
        address payable feeAddress = address(uint160(_destination)); //cast the address to payable

        if (_token != EthAddressLib.ethAddress()) {
            require(
                msg.value == 0,
                "User is sending ETH along with the ERC20 transfer. Check the value attribute of the transaction"
            );
            ERC20(_token).safeTransferFrom(_user, feeAddress, _amount);
        } else {
            require(msg.value >= _amount, "The amount and the value sent to deposit do not match");
            //solium-disable-next-line
            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers the fees to the fees collection address in the case of liquidation
    * @param _token the address of the token being transferred
    * @param _amount the amount being transferred
    * @param _destination the fee receiver address
    **/
    function liquidateFee(
        address _token,
        uint256 _amount,
        address _destination
    ) external payable onlyLendingPool {
        address payable feeAddress = address(uint160(_destination)); //cast the address to payable
        require(
            msg.value == 0,
            "Fee liquidation does not require any transfer of value"
        );

        if (_token != EthAddressLib.ethAddress()) {
            ERC20(_token).safeTransfer(feeAddress, _amount);
        } else {
            //solium-disable-next-line
            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers an amount from a user to the destination reserve
    * @param _reserve the address of the reserve where the amount is being transferred
    * @param _user the address of the user from where the transfer is happening
    * @param _amount the amount being transferred
    **/
    function transferToReserve(address _reserve, address payable _user, uint256 _amount)
    external
    payable
    onlyLendingPool
    {
        if (_reserve != EthAddressLib.ethAddress()) {
            require(msg.value == 0, "User is sending ETH along with the ERC20 transfer.");
            ERC20(_reserve).safeTransferFrom(_user, address(this), _amount);

        } else {
            require(msg.value >= _amount, "The amount and the value sent to deposit do not match");

            if (msg.value > _amount) {
                //send back excess ETH
                uint256 excessAmount = msg.value.sub(_amount);
                //solium-disable-next-line
                (bool result, ) = _user.call.value(excessAmount).gas(50000)("");
                require(result, "Transfer of ETH failed");
            }
        }
    }

    /**
    * @notice data access functions
    **/

    /**
    * @dev returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral)
    * needed to calculate the global account data in the LendingPoolDataProvider
    * @param _reserve the address of the reserve
    * @param _user the address of the user
    * @return the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not
    **/
    function getUserBasicReserveData(address _reserve, address _user)
    external
    view
    returns (uint256, uint256, uint256, bool)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        uint256 underlyingBalance = getUserUnderlyingAssetBalance(_reserve, _user);

        if (user.principalBorrowBalance == 0) {
            return (underlyingBalance, 0, 0, user.useAsCollateral);
        }

        return (
        underlyingBalance,
        user.getCompoundedBorrowBalance(reserve),
        user.originationFee,
        user.useAsCollateral
        );
    }

    /**
    * @dev checks if a user is allowed to borrow at a stable rate
    * @param _reserve the reserve address
    * @param _user the user
    * @param _amount the amount the the user wants to borrow
    * @return true if the user is allowed to borrow at a stable rate, false otherwise
    **/

    function isUserAllowedToBorrowAtStable(address _reserve, address _user, uint256 _amount)
    external
    view
    returns (bool)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (!reserve.isStableBorrowRateEnabled) return false;

        return
        !user.useAsCollateral ||
        !reserve.usageAsCollateralEnabled ||
        _amount > getUserUnderlyingAssetBalance(_reserve, _user);
    }

    /**
    * @dev gets the underlying asset balance of a user based on the corresponding aToken balance.
    * @param _reserve the reserve address
    * @param _user the user address
    * @return the underlying deposit balance of the user
    **/

    function getUserUnderlyingAssetBalance(address _reserve, address _user)
    public
    view
    returns (uint256)
    {
        AToken aToken = AToken(reserves[_reserve].aTokenAddress);
        return aToken.balanceOf(_user);

    }

    /**
    * @dev gets the interest rate strategy contract address for the reserve
    * @param _reserve the reserve address
    * @return the address of the interest rate strategy contract
    **/
    function getReserveInterestRateStrategyAddress(address _reserve) public view returns (address) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.interestRateStrategyAddress;
    }

    /**
    * @dev gets the aToken contract address for the reserve
    * @param _reserve the reserve address
    * @return the address of the aToken contract
    **/

    function getReserveATokenAddress(address _reserve) public view returns (address) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.aTokenAddress;
    }

    /**
    * @dev gets the available liquidity in the reserve. The available liquidity is the balance of the core contract
    * @param _reserve the reserve address
    * @return the available liquidity
    **/
    function getReserveAvailableLiquidity(address _reserve) public view returns (uint256) {
        uint256 balance = 0;

        if (_reserve == EthAddressLib.ethAddress()) {
            balance = address(this).balance;
        } else {
            balance = IERC20(_reserve).balanceOf(address(this));
        }
        return balance;
    }

    /**
    * @dev gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows
    * @param _reserve the reserve address
    * @return the total liquidity
    **/
    function getReserveTotalLiquidity(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return getReserveAvailableLiquidity(_reserve).add(reserve.getTotalBorrows());
    }

    /**
    * @dev gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there
    * there has been 100% income.
    * @param _reserve the reserve address
    * @return the reserve normalized income
    **/
    function getReserveNormalizedIncome(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.getNormalizedIncome();
    }

    /**
    * @dev gets the reserve total borrows
    * @param _reserve the reserve address
    * @return the total borrows (stable + variable)
    **/
    function getReserveTotalBorrows(address _reserve) public view returns (uint256) {
        return reserves[_reserve].getTotalBorrows();
    }

    /**
    * @dev gets the reserve total borrows stable
    * @param _reserve the reserve address
    * @return the total borrows stable
    **/
    function getReserveTotalBorrowsStable(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.totalBorrowsStable;
    }

    /**
    * @dev gets the reserve total borrows variable
    * @param _reserve the reserve address
    * @return the total borrows variable
    **/

    function getReserveTotalBorrowsVariable(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.totalBorrowsVariable;
    }

    /**
    * @dev gets the reserve liquidation threshold
    * @param _reserve the reserve address
    * @return the reserve liquidation threshold
    **/

    function getReserveLiquidationThreshold(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.liquidationThreshold;
    }

    /**
    * @dev gets the reserve liquidation bonus
    * @param _reserve the reserve address
    * @return the reserve liquidation bonus
    **/

    function getReserveLiquidationBonus(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.liquidationBonus;
    }

    /**
    * @dev gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty
    * @param _reserve the reserve address
    * @return the reserve current variable borrow rate
    **/

    function getReserveCurrentVariableBorrowRate(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        if (reserve.currentVariableBorrowRate == 0) {
            return
            IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)
            .getBaseVariableBorrowRate();
        }
        return reserve.currentVariableBorrowRate;
    }

    /**
    * @dev gets the reserve current stable borrow rate. Is the market rate if the reserve is empty
    * @param _reserve the reserve address
    * @return the reserve current stable borrow rate
    **/

    function getReserveCurrentStableBorrowRate(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        ILendingRateOracle oracle = ILendingRateOracle(addressesProvider.getLendingRateOracle());

        if (reserve.currentStableBorrowRate == 0) {
            //no stable rate borrows yet
            return oracle.getMarketBorrowRate(_reserve);
        }

        return reserve.currentStableBorrowRate;
    }

    /**
    * @dev gets the reserve average stable borrow rate. The average stable rate is the weighted average
    * of all the loans taken at stable rate.
    * @param _reserve the reserve address
    * @return the reserve current average borrow rate
    **/
    function getReserveCurrentAverageStableBorrowRate(address _reserve)
    external
    view
    returns (uint256)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.currentAverageStableBorrowRate;
    }

    /**
    * @dev gets the reserve liquidity rate
    * @param _reserve the reserve address
    * @return the reserve liquidity rate
    **/
    function getReserveCurrentLiquidityRate(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.currentLiquidityRate;
    }

    /**
    * @dev gets the reserve liquidity cumulative index
    * @param _reserve the reserve address
    * @return the reserve liquidity cumulative index
    **/
    function getReserveLiquidityCumulativeIndex(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.lastLiquidityCumulativeIndex;
    }

    /**
    * @dev gets the reserve variable borrow index
    * @param _reserve the reserve address
    * @return the reserve variable borrow index
    **/
    function getReserveVariableBorrowsCumulativeIndex(address _reserve)
    external
    view
    returns (uint256)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.lastVariableBorrowCumulativeIndex;
    }

    /**
    * @dev this function aggregates the configuration parameters of the reserve.
    * It's used in the LendingPoolDataProvider specifically to save gas, and avoid
    * multiple external contract calls to fetch the same data.
    * @param _reserve the reserve address
    * @return the reserve decimals
    * @return the base ltv as collateral
    * @return the liquidation threshold
    * @return if the reserve is used as collateral or not
    **/
    function getReserveConfiguration(address _reserve)
    external
    view
    returns (uint256, uint256, uint256, bool)
    {
        uint256 decimals;
        uint256 baseLTVasCollateral;
        uint256 liquidationThreshold;
        bool usageAsCollateralEnabled;

        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        decimals = reserve.decimals;
        baseLTVasCollateral = reserve.baseLTVasCollateral;
        liquidationThreshold = reserve.liquidationThreshold;
        usageAsCollateralEnabled = reserve.usageAsCollateralEnabled;

        return (decimals, baseLTVasCollateral, liquidationThreshold, usageAsCollateralEnabled);
    }

    /**
    * @dev returns the decimals of the reserve
    * @param _reserve the reserve address
    * @return the reserve decimals
    **/
    function getReserveDecimals(address _reserve) external view returns (uint256) {
        return reserves[_reserve].decimals;
    }

    /**
    * @dev returns true if the reserve is enabled for borrowing
    * @param _reserve the reserve address
    * @return true if the reserve is enabled for borrowing, false otherwise
    **/

    function isReserveBorrowingEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.borrowingEnabled;
    }

    /**
    * @dev returns true if the reserve is enabled as collateral
    * @param _reserve the reserve address
    * @return true if the reserve is enabled as collateral, false otherwise
    **/

    function isReserveUsageAsCollateralEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.usageAsCollateralEnabled;
    }

    /**
    * @dev returns true if the stable rate is enabled on reserve
    * @param _reserve the reserve address
    * @return true if the stable rate is enabled on reserve, false otherwise
    **/
    function getReserveIsStableBorrowRateEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isStableBorrowRateEnabled;
    }

    /**
    * @dev returns true if the reserve is active
    * @param _reserve the reserve address
    * @return true if the reserve is active, false otherwise
    **/
    function getReserveIsActive(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isActive;
    }

    /**
    * @notice returns if a reserve is freezed
    * @param _reserve the reserve for which the information is needed
    * @return true if the reserve is freezed, false otherwise
    **/

    function getReserveIsFreezed(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isFreezed;
    }

    /**
    * @notice returns the timestamp of the last action on the reserve
    * @param _reserve the reserve for which the information is needed
    * @return the last updated timestamp of the reserve
    **/

    function getReserveLastUpdate(address _reserve) external view returns (uint40 timestamp) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        timestamp = reserve.lastUpdateTimestamp;
    }

    /**
    * @dev returns the utilization rate U of a specific reserve
    * @param _reserve the reserve for which the information is needed
    * @return the utilization rate in ray
    **/

    function getReserveUtilizationRate(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        uint256 totalBorrows = reserve.getTotalBorrows();

        if (totalBorrows == 0) {
            return 0;
        }

        uint256 availableLiquidity = getReserveAvailableLiquidity(_reserve);

        return totalBorrows.rayDiv(availableLiquidity.add(totalBorrows));
    }

    /**
    * @return the array of reserves configured on the core
    **/
    function getReserves() external view returns (address[] memory) {
        return reservesList;
    }

    /**
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return true if the user has chosen to use the reserve as collateral, false otherwise
    **/
    function isUserUseReserveAsCollateralEnabled(address _reserve, address _user)
    external
    view
    returns (bool)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.useAsCollateral;
    }

    /**
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the origination fee for the user
    **/
    function getUserOriginationFee(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.originationFee;
    }

    /**
    * @dev users with no loans in progress have NONE as borrow rate mode
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the borrow rate mode for the user,
    **/

    function getUserCurrentBorrowRateMode(address _reserve, address _user)
    public
    view
    returns (CoreLibrary.InterestRateMode)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (user.principalBorrowBalance == 0) {
            return CoreLibrary.InterestRateMode.NONE;
        }

        return
        user.stableBorrowRate > 0
        ? CoreLibrary.InterestRateMode.STABLE
        : CoreLibrary.InterestRateMode.VARIABLE;
    }

    /**
    * @dev gets the current borrow rate of the user
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the borrow rate for the user,
    **/
    function getUserCurrentBorrowRate(address _reserve, address _user)
    internal
    view
    returns (uint256)
    {
        CoreLibrary.InterestRateMode rateMode = getUserCurrentBorrowRateMode(_reserve, _user);

        if (rateMode == CoreLibrary.InterestRateMode.NONE) {
            return 0;
        }

        return
        rateMode == CoreLibrary.InterestRateMode.STABLE
        ? usersReserveData[_user][_reserve].stableBorrowRate
        : reserves[_reserve].currentVariableBorrowRate;
    }

    /**
    * @dev the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the user stable rate
    **/
    function getUserCurrentStableBorrowRate(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.stableBorrowRate;
    }

    /**
    * @dev calculates and returns the borrow balances of the user
    * @param _reserve the address of the reserve
    * @param _user the address of the user
    * @return the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance
    **/

    function getUserBorrowBalances(address _reserve, address _user)
    public
    view
    returns (uint256, uint256, uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        if (user.principalBorrowBalance == 0) {
            return (0, 0, 0);
        }

        uint256 principal = user.principalBorrowBalance;
        uint256 compoundedBalance = CoreLibrary.getCompoundedBorrowBalance(
            user,
            reserves[_reserve]
        );
        return (principal, compoundedBalance, compoundedBalance.sub(principal));
    }

    /**
    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the variable borrow index for the user
    **/

    function getUserVariableBorrowCumulativeIndex(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.lastVariableBorrowCumulativeIndex;
    }

    /**
    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the variable borrow index for the user
    **/

    function getUserLastUpdate(address _reserve, address _user)
    external
    view
    returns (uint256 timestamp)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        timestamp = user.lastUpdateTimestamp;
    }

    /**
    * @dev updates the lending pool core configuration
    **/
    function refreshConfiguration() external onlyLendingPoolConfigurator {
        refreshConfigInternal();
    }

    /**
    * @dev initializes a reserve
    * @param _reserve the address of the reserve
    * @param _aTokenAddress the address of the overlying aToken contract
    * @param _decimals the decimals of the reserve currency
    * @param _interestRateStrategyAddress the address of the interest rate strategy contract
    **/
    function initReserve(
        address _reserve,
        address _aTokenAddress,
        uint256 _decimals,
        address _interestRateStrategyAddress
    ) external onlyLendingPoolConfigurator {
        reserves[_reserve].init(_aTokenAddress, _decimals, _interestRateStrategyAddress);
        addReserveToListInternal(_reserve);

    }



    /**
    * @dev removes the last added reserve in the reservesList array
    * @param _reserveToRemove the address of the reserve
    **/
    function removeLastAddedReserve(address _reserveToRemove)
    external onlyLendingPoolConfigurator {

        address lastReserve = reservesList[reservesList.length-1];

        require(lastReserve == _reserveToRemove, "Reserve being removed is different than the reserve requested");

        //as we can't check if totalLiquidity is 0 (since the reserve added might not be an ERC20) we at least check that there is nothing borrowed
        require(getReserveTotalBorrows(lastReserve) == 0, "Cannot remove a reserve with liquidity deposited");

        reserves[lastReserve].isActive = false;
        reserves[lastReserve].aTokenAddress = address(0);
        reserves[lastReserve].decimals = 0;
        reserves[lastReserve].lastLiquidityCumulativeIndex = 0;
        reserves[lastReserve].lastVariableBorrowCumulativeIndex = 0;
        reserves[lastReserve].borrowingEnabled = false;
        reserves[lastReserve].usageAsCollateralEnabled = false;
        reserves[lastReserve].baseLTVasCollateral = 0;
        reserves[lastReserve].liquidationThreshold = 0;
        reserves[lastReserve].liquidationBonus = 0;
        reserves[lastReserve].interestRateStrategyAddress = address(0);

        reservesList.pop();
    }

    /**
    * @dev updates the address of the interest rate strategy contract
    * @param _reserve the address of the reserve
    * @param _rateStrategyAddress the address of the interest rate strategy contract
    **/

    function setReserveInterestRateStrategyAddress(address _reserve, address _rateStrategyAddress)
    external
    onlyLendingPoolConfigurator
    {
        reserves[_reserve].interestRateStrategyAddress = _rateStrategyAddress;
    }

    /**
    * @dev enables borrowing on a reserve. Also sets the stable rate borrowing
    * @param _reserve the address of the reserve
    * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise
    **/

    function enableBorrowingOnReserve(address _reserve, bool _stableBorrowRateEnabled)
    external
    onlyLendingPoolConfigurator
    {
        reserves[_reserve].enableBorrowing(_stableBorrowRateEnabled);
    }

    /**
    * @dev disables borrowing on a reserve
    * @param _reserve the address of the reserve
    **/

    function disableBorrowingOnReserve(address _reserve) external onlyLendingPoolConfigurator {
        reserves[_reserve].disableBorrowing();
    }

    /**
    * @dev enables a reserve to be used as collateral
    * @param _reserve the address of the reserve
    **/
    function enableReserveAsCollateral(
        address _reserve,
        uint256 _baseLTVasCollateral,
        uint256 _liquidationThreshold,
        uint256 _liquidationBonus
    ) external onlyLendingPoolConfigurator {
        reserves[_reserve].enableAsCollateral(
            _baseLTVasCollateral,
            _liquidationThreshold,
            _liquidationBonus
        );
    }

    /**
    * @dev disables a reserve to be used as collateral
    * @param _reserve the address of the reserve
    **/
    function disableReserveAsCollateral(address _reserve) external onlyLendingPoolConfigurator {
        reserves[_reserve].disableAsCollateral();
    }

    /**
    * @dev enable the stable borrow rate mode on a reserve
    * @param _reserve the address of the reserve
    **/
    function enableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isStableBorrowRateEnabled = true;
    }

    /**
    * @dev disable the stable borrow rate mode on a reserve
    * @param _reserve the address of the reserve
    **/
    function disableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isStableBorrowRateEnabled = false;
    }

    /**
    * @dev activates a reserve
    * @param _reserve the address of the reserve
    **/
    function activateReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        require(
            reserve.lastLiquidityCumulativeIndex > 0 &&
            reserve.lastVariableBorrowCumulativeIndex > 0,
            "Reserve has not been initialized yet"
        );
        reserve.isActive = true;
    }

    /**
    * @dev deactivates a reserve
    * @param _reserve the address of the reserve
    **/
    function deactivateReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isActive = false;
    }

    /**
    * @notice allows the configurator to freeze the reserve.
    * A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance.
    * @param _reserve the address of the reserve
    **/
    function freezeReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isFreezed = true;
    }

    /**
    * @notice allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed.
    * @param _reserve the address of the reserve
    **/
    function unfreezeReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isFreezed = false;
    }

    /**
    * @notice allows the configurator to update the loan to value of a reserve
    * @param _reserve the address of the reserve
    * @param _ltv the new loan to value
    **/
    function setReserveBaseLTVasCollateral(address _reserve, uint256 _ltv)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.baseLTVasCollateral = _ltv;
    }

    /**
    * @notice allows the configurator to update the liquidation threshold of a reserve
    * @param _reserve the address of the reserve
    * @param _threshold the new liquidation threshold
    **/
    function setReserveLiquidationThreshold(address _reserve, uint256 _threshold)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.liquidationThreshold = _threshold;
    }

    /**
    * @notice allows the configurator to update the liquidation bonus of a reserve
    * @param _reserve the address of the reserve
    * @param _bonus the new liquidation bonus
    **/
    function setReserveLiquidationBonus(address _reserve, uint256 _bonus)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.liquidationBonus = _bonus;
    }

    /**
    * @notice allows the configurator to update the reserve decimals
    * @param _reserve the address of the reserve
    * @param _decimals the decimals of the reserve
    **/
    function setReserveDecimals(address _reserve, uint256 _decimals)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.decimals = _decimals;
    }

    /**
    * @notice internal functions
    **/

    /**
    * @dev updates the state of a reserve as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the previous borrow balance of the borrower before the action
    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount
    * @param _amountBorrowed the new amount borrowed
    * @param _rateMode the borrow rate mode (stable, variable)
    **/

    function updateReserveStateOnBorrowInternal(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _balanceIncrease,
        uint256 _amountBorrowed,
        CoreLibrary.InterestRateMode _rateMode
    ) internal {
        reserves[_reserve].updateCumulativeIndexes();

        //increasing reserve total borrows to account for the new borrow balance of the user
        //NOTE: Depending on the previous borrow mode, the borrows might need to be switched from variable to stable or vice versa

        updateReserveTotalBorrowsByRateModeInternal(
            _reserve,
            _user,
            _principalBorrowBalance,
            _balanceIncrease,
            _amountBorrowed,
            _rateMode
        );
    }

    /**
    * @dev updates the state of a user as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _amountBorrowed the amount borrowed
    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount
    * @param _rateMode the borrow rate mode (stable, variable)
    * @return the final borrow rate for the user. Emitted by the borrow() event
    **/

    function updateUserStateOnBorrowInternal(
        address _reserve,
        address _user,
        uint256 _amountBorrowed,
        uint256 _balanceIncrease,
        uint256 _fee,
        CoreLibrary.InterestRateMode _rateMode
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (_rateMode == CoreLibrary.InterestRateMode.STABLE) {
            //stable
            //reset the user variable index, and update the stable rate
            user.stableBorrowRate = reserve.currentStableBorrowRate;
            user.lastVariableBorrowCumulativeIndex = 0;
        } else if (_rateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //variable
            //reset the user stable rate, and store the new borrow index
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        } else {
            revert("Invalid borrow rate mode");
        }
        //increase the principal borrows and the origination fee
        user.principalBorrowBalance = user.principalBorrowBalance.add(_amountBorrowed).add(
            _balanceIncrease
        );
        user.originationFee = user.originationFee.add(_fee);

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

    }

    /**
    * @dev updates the state of the reserve as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateReserveStateOnRepayInternal(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_reserve][_user];

        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(_reserve, _user);

        //update the indexes
        reserves[_reserve].updateCumulativeIndexes();

        //compound the cumulated interest to the borrow balance and then subtracting the payback amount
        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _balanceIncrease,
                user.stableBorrowRate
            );
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _paybackAmountMinusFees,
                user.stableBorrowRate
            );
        } else {
            reserve.increaseTotalBorrowsVariable(_balanceIncrease);
            reserve.decreaseTotalBorrowsVariable(_paybackAmountMinusFees);
        }
    }

    /**
    * @dev updates the state of the user as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _originationFeeRepaid the fee on the amount that is being repaid
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _repaidWholeLoan true if the user is repaying the whole loan
    **/
    function updateUserStateOnRepayInternal(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _originationFeeRepaid,
        uint256 _balanceIncrease,
        bool _repaidWholeLoan
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        //update the user principal borrow balance, adding the cumulated interest and then subtracting the payback amount
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(
            _paybackAmountMinusFees
        );
        user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;

        //if the balance decrease is equal to the previous principal (user is repaying the whole loan)
        //and the rate mode is stable, we reset the interest rate mode of the user
        if (_repaidWholeLoan) {
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = 0;
        }
        user.originationFee = user.originationFee.sub(_originationFeeRepaid);

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

    }

    /**
    * @dev updates the state of the user as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is performing the rate swap
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the the principal amount borrowed by the user
    * @param _compoundedBorrowBalance the principal amount plus the accrued interest
    * @param _currentRateMode the rate mode at which the user borrowed
    **/
    function updateReserveStateOnSwapRateInternal(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _compoundedBorrowBalance,
        CoreLibrary.InterestRateMode _currentRateMode
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        //compounding reserve indexes
        reserve.updateCumulativeIndexes();

        if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {
            uint256 userCurrentStableRate = user.stableBorrowRate;

            //swap to variable
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _principalBorrowBalance,
                userCurrentStableRate
            ); //decreasing stable from old principal balance
            reserve.increaseTotalBorrowsVariable(_compoundedBorrowBalance); //increase variable borrows
        } else if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //swap to stable
            uint256 currentStableRate = reserve.currentStableBorrowRate;
            reserve.decreaseTotalBorrowsVariable(_principalBorrowBalance);
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _compoundedBorrowBalance,
                currentStableRate
            );

        } else {
            revert("Invalid rate mode received");
        }
    }

    /**
    * @dev updates the state of the user as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is performing the swap
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _currentRateMode the current rate mode of the user
    **/

    function updateUserStateOnSwapRateInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease,
        CoreLibrary.InterestRateMode _currentRateMode
    ) internal returns (CoreLibrary.InterestRateMode) {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        CoreLibrary.InterestRateMode newMode = CoreLibrary.InterestRateMode.NONE;

        if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //switch to stable
            newMode = CoreLibrary.InterestRateMode.STABLE;
            user.stableBorrowRate = reserve.currentStableBorrowRate;
            user.lastVariableBorrowCumulativeIndex = 0;
        } else if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {
            newMode = CoreLibrary.InterestRateMode.VARIABLE;
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        } else {
            revert("Invalid interest rate mode received");
        }
        //compounding cumulated interest
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);
        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

        return newMode;
    }

    /**
    * @dev updates the state of the principal reserve as a consequence of a liquidation action.
    * @param _principalReserve the address of the principal reserve that is being repaid
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updatePrincipalReserveStateOnLiquidationInternal(
        address _principalReserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_principalReserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_principalReserve];

        //update principal reserve data
        reserve.updateCumulativeIndexes();

        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(
            _principalReserve,
            _user
        );

        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            //increase the total borrows by the compounded interest
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _balanceIncrease,
                user.stableBorrowRate
            );

            //decrease by the actual amount to liquidate
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _amountToLiquidate,
                user.stableBorrowRate
            );

        } else {
            //increase the total borrows by the compounded interest
            reserve.increaseTotalBorrowsVariable(_balanceIncrease);

            //decrease by the actual amount to liquidate
            reserve.decreaseTotalBorrowsVariable(_amountToLiquidate);
        }

    }

    /**
    * @dev updates the state of the collateral reserve as a consequence of a liquidation action.
    * @param _collateralReserve the address of the collateral reserve that is being liquidated
    **/
    function updateCollateralReserveStateOnLiquidationInternal(
        address _collateralReserve
    ) internal {
        //update collateral reserve
        reserves[_collateralReserve].updateCumulativeIndexes();

    }

    /**
    * @dev updates the state of the user being liquidated as a consequence of a liquidation action.
    * @param _reserve the address of the principal reserve that is being repaid
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _feeLiquidated the amount of origination fee being liquidated
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/
    function updateUserStateOnLiquidationInternal(
        address _reserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _feeLiquidated,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        //first increase by the compounded interest, then decrease by the liquidated amount
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(
            _amountToLiquidate
        );

        if (
            getUserCurrentBorrowRateMode(_reserve, _user) == CoreLibrary.InterestRateMode.VARIABLE
        ) {
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        }

        if(_feeLiquidated > 0){
            user.originationFee = user.originationFee.sub(_feeLiquidated);
        }

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);
    }

    /**
    * @dev updates the state of the reserve as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateReserveStateOnRebalanceInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        reserve.updateCumulativeIndexes();

        reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
            _balanceIncrease,
            user.stableBorrowRate
        );

    }

    /**
    * @dev updates the state of the user as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateUserStateOnRebalanceInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);
        user.stableBorrowRate = reserve.currentStableBorrowRate;

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);
    }

    /**
    * @dev updates the state of the user as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _amountBorrowed the accrued interest on the borrowed amount
    **/
    function updateReserveTotalBorrowsByRateModeInternal(
        address _reserve,
        address _user,
        uint256 _principalBalance,
        uint256 _balanceIncrease,
        uint256 _amountBorrowed,
        CoreLibrary.InterestRateMode _newBorrowRateMode
    ) internal {
        CoreLibrary.InterestRateMode previousRateMode = getUserCurrentBorrowRateMode(
            _reserve,
            _user
        );
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        if (previousRateMode == CoreLibrary.InterestRateMode.STABLE) {
            CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _principalBalance,
                user.stableBorrowRate
            );
        } else if (previousRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            reserve.decreaseTotalBorrowsVariable(_principalBalance);
        }

        uint256 newPrincipalAmount = _principalBalance.add(_balanceIncrease).add(_amountBorrowed);
        if (_newBorrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                newPrincipalAmount,
                reserve.currentStableBorrowRate
            );
        } else if (_newBorrowRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            reserve.increaseTotalBorrowsVariable(newPrincipalAmount);
        } else {
            revert("Invalid new borrow rate mode");
        }
    }

    /**
    * @dev Updates the reserve current stable borrow rate Rf, the current variable borrow rate Rv and the current liquidity rate Rl.
    * Also updates the lastUpdateTimestamp value. Please refer to the whitepaper for further information.
    * @param _reserve the address of the reserve to be updated
    * @param _liquidityAdded the amount of liquidity added to the protocol (deposit or repay) in the previous action
    * @param _liquidityTaken the amount of liquidity taken from the protocol (redeem or borrow)
    **/

    function updateReserveInterestRatesAndTimestampInternal(
        address _reserve,
        uint256 _liquidityAdded,
        uint256 _liquidityTaken
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        (uint256 newLiquidityRate, uint256 newStableRate, uint256 newVariableRate) = IReserveInterestRateStrategy(
            reserve
            .interestRateStrategyAddress
        )
        .calculateInterestRates(
            _reserve,
            getReserveAvailableLiquidity(_reserve).add(_liquidityAdded).sub(_liquidityTaken),
            reserve.totalBorrowsStable,
            reserve.totalBorrowsVariable,
            reserve.currentAverageStableBorrowRate
        );

        reserve.currentLiquidityRate = newLiquidityRate;
        reserve.currentStableBorrowRate = newStableRate;
        reserve.currentVariableBorrowRate = newVariableRate;

        //solium-disable-next-line
        reserve.lastUpdateTimestamp = uint40(block.timestamp);

        emit ReserveUpdated(
            _reserve,
            newLiquidityRate,
            newStableRate,
            newVariableRate,
            reserve.lastLiquidityCumulativeIndex,
            reserve.lastVariableBorrowCumulativeIndex
        );
    }

    /**
    * @dev transfers to the protocol fees of a flashloan to the fees collection address
    * @param _token the address of the token being transferred
    * @param _amount the amount being transferred
    **/

    function transferFlashLoanProtocolFeeInternal(address _token, uint256 _amount) internal {
        address payable receiver = address(uint160(addressesProvider.getTokenDistributor()));

        if (_token != EthAddressLib.ethAddress()) {
            ERC20(_token).safeTransfer(receiver, _amount);
        } else {
            receiver.transfer(_amount);
        }
    }

    /**
    * @dev updates the internal configuration of the core
    **/
    function refreshConfigInternal() internal {
        lendingPoolAddress = addressesProvider.getLendingPool();
    }

    /**
    * @dev adds a reserve to the array of the reserves address
    **/
    function addReserveToListInternal(address _reserve) internal {
        bool reserveAlreadyAdded = false;
        for (uint256 i = 0; i < reservesList.length; i++)
            if (reservesList[i] == _reserve) {
                reserveAlreadyAdded = true;
            }
        if (!reserveAlreadyAdded) reservesList.push(_reserve);
    }

}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-01-09 04:31:30 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 04:31:30 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 28820
completion_tokens: 1
total_tokens: 28821
cost: $-1.000000


[2024-01-09 04:31:30 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: pragma solidity ^0.5.0;

import "openzeppelin-solidity/contracts/math/SafeMath.sol";
import "openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol";
import "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol";
import "openzeppelin-solidity/contracts/utils/Address.sol";
import "../libraries/openzeppelin-upgradeability/VersionedInitializable.sol";

import "../libraries/CoreLibrary.sol";
import "../configuration/LendingPoolAddressesProvider.sol";
import "../interfaces/ILendingRateOracle.sol";
import "../interfaces/IReserveInterestRateStrategy.sol";
import "../libraries/WadRayMath.sol";
import "../tokenization/AToken.sol";
import "../libraries/EthAddressLib.sol";

/**
* @title LendingPoolCore contract
* @author Aave
* @notice Holds the state of the lending pool and all the funds deposited
* @dev NOTE: The core does not enforce security checks on the update of the state
* (eg, updateStateOnBorrow() does not enforce that borrowed is enabled on the reserve).
* The check that an action can be performed is a duty of the overlying LendingPool contract.
**/

contract LendingPoolCore is VersionedInitializable {
    using SafeMath for uint256;
    using WadRayMath for uint256;
    using CoreLibrary for CoreLibrary.ReserveData;
    using CoreLibrary for CoreLibrary.UserReserveData;
    using SafeERC20 for ERC20;
    using Address for address payable;

    /**
    * @dev Emitted when the state of a reserve is updated
    * @param reserve the address of the reserve
    * @param liquidityRate the new liquidity rate
    * @param stableBorrowRate the new stable borrow rate
    * @param variableBorrowRate the new variable borrow rate
    * @param liquidityIndex the new liquidity index
    * @param variableBorrowIndex the new variable borrow index
    **/
    event ReserveUpdated(
        address indexed reserve,
        uint256 liquidityRate,
        uint256 stableBorrowRate,
        uint256 variableBorrowRate,
        uint256 liquidityIndex,
        uint256 variableBorrowIndex
    );

    address public lendingPoolAddress;

    LendingPoolAddressesProvider public addressesProvider;

    /**
    * @dev only lending pools can use functions affected by this modifier
    **/
    modifier onlyLendingPool {
        require(lendingPoolAddress == msg.sender, "The caller must be a lending pool contract");
        _;
    }

    /**
    * @dev only lending pools configurator can use functions affected by this modifier
    **/
    modifier onlyLendingPoolConfigurator {
        require(
            addressesProvider.getLendingPoolConfigurator() == msg.sender,
            "The caller must be a lending pool configurator contract"
        );
        _;
    }

    mapping(address => CoreLibrary.ReserveData) internal reserves;
    mapping(address => mapping(address => CoreLibrary.UserReserveData)) internal usersReserveData;

    address[] public reservesList;

    uint256 public constant CORE_REVISION = 0x4;

    /**
    * @dev returns the revision number of the contract
    **/
    function getRevision() internal pure returns (uint256) {
        return CORE_REVISION;
    }

    /**
    * @dev initializes the Core contract, invoked upon registration on the AddressesProvider
    * @param _addressesProvider the addressesProvider contract
    **/

    function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {
        addressesProvider = _addressesProvider;
        refreshConfigInternal();
    }

    /**
    * @dev updates the state of the core as a result of a deposit action
    * @param _reserve the address of the reserve in which the deposit is happening
    * @param _user the address of the the user depositing
    * @param _amount the amount being deposited
    * @param _isFirstDeposit true if the user is depositing for the first time
    **/

    function updateStateOnDeposit(
        address _reserve,
        address _user,
        uint256 _amount,
        bool _isFirstDeposit
    ) external onlyLendingPool {
        reserves[_reserve].updateCumulativeIndexes();
        updateReserveInterestRatesAndTimestampInternal(_reserve, _amount, 0);

        if (_isFirstDeposit) {
            //if this is the first deposit of the user, we configure the deposit as enabled to be used as collateral
            setUserUseReserveAsCollateral(_reserve, _user, true);
        }
    }

    /**
    * @dev updates the state of the core as a result of a redeem action
    * @param _reserve the address of the reserve in which the redeem is happening
    * @param _user the address of the the user redeeming
    * @param _amountRedeemed the amount being redeemed
    * @param _userRedeemedEverything true if the user is redeeming everything
    **/
    function updateStateOnRedeem(
        address _reserve,
        address _user,
        uint256 _amountRedeemed,
        bool _userRedeemedEverything
    ) external onlyLendingPool {
        //compound liquidity and variable borrow interests
        reserves[_reserve].updateCumulativeIndexes();
        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountRedeemed);

        //if user redeemed everything the useReserveAsCollateral flag is reset
        if (_userRedeemedEverything) {
            setUserUseReserveAsCollateral(_reserve, _user, false);
        }
    }

    /**
    * @dev updates the state of the core as a result of a flashloan action
    * @param _reserve the address of the reserve in which the flashloan is happening
    * @param _income the income of the protocol as a result of the action
    **/
    function updateStateOnFlashLoan(
        address _reserve,
        uint256 _availableLiquidityBefore,
        uint256 _income,
        uint256 _protocolFee
    ) external onlyLendingPool {
        transferFlashLoanProtocolFeeInternal(_reserve, _protocolFee);

        //compounding the cumulated interest
        reserves[_reserve].updateCumulativeIndexes();

        uint256 totalLiquidityBefore = _availableLiquidityBefore.add(
            getReserveTotalBorrows(_reserve)
        );

        //compounding the received fee into the reserve
        reserves[_reserve].cumulateToLiquidityIndex(totalLiquidityBefore, _income);

        //refresh interest rates
        updateReserveInterestRatesAndTimestampInternal(_reserve, _income, 0);
    }

    /**
    * @dev updates the state of the core as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _amountBorrowed the new amount borrowed
    * @param _borrowFee the fee on the amount borrowed
    * @param _rateMode the borrow rate mode (stable, variable)
    * @return the new borrow rate for the user
    **/
    function updateStateOnBorrow(
        address _reserve,
        address _user,
        uint256 _amountBorrowed,
        uint256 _borrowFee,
        CoreLibrary.InterestRateMode _rateMode
    ) external onlyLendingPool returns (uint256, uint256) {
        // getting the previous borrow data of the user
        (uint256 principalBorrowBalance, , uint256 balanceIncrease) = getUserBorrowBalances(
            _reserve,
            _user
        );

        updateReserveStateOnBorrowInternal(
            _reserve,
            _user,
            principalBorrowBalance,
            balanceIncrease,
            _amountBorrowed,
            _rateMode
        );

        updateUserStateOnBorrowInternal(
            _reserve,
            _user,
            _amountBorrowed,
            balanceIncrease,
            _borrowFee,
            _rateMode
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountBorrowed);

        return (getUserCurrentBorrowRate(_reserve, _user), balanceIncrease);
    }

    /**
    * @dev updates the state of the core as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _originationFeeRepaid the fee on the amount that is being repaid
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _repaidWholeLoan true if the user is repaying the whole loan
    **/

    function updateStateOnRepay(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _originationFeeRepaid,
        uint256 _balanceIncrease,
        bool _repaidWholeLoan
    ) external onlyLendingPool {
        updateReserveStateOnRepayInternal(
            _reserve,
            _user,
            _paybackAmountMinusFees,
            _balanceIncrease
        );
        updateUserStateOnRepayInternal(
            _reserve,
            _user,
            _paybackAmountMinusFees,
            _originationFeeRepaid,
            _balanceIncrease,
            _repaidWholeLoan
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, _paybackAmountMinusFees, 0);
    }

    /**
    * @dev updates the state of the core as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the amount borrowed by the user
    * @param _compoundedBorrowBalance the amount borrowed plus accrued interest
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _currentRateMode the current interest rate mode for the user
    **/
    function updateStateOnSwapRate(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _compoundedBorrowBalance,
        uint256 _balanceIncrease,
        CoreLibrary.InterestRateMode _currentRateMode
    ) external onlyLendingPool returns (CoreLibrary.InterestRateMode, uint256) {
        updateReserveStateOnSwapRateInternal(
            _reserve,
            _user,
            _principalBorrowBalance,
            _compoundedBorrowBalance,
            _currentRateMode
        );

        CoreLibrary.InterestRateMode newRateMode = updateUserStateOnSwapRateInternal(
            _reserve,
            _user,
            _balanceIncrease,
            _currentRateMode
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);

        return (newRateMode, getUserCurrentBorrowRate(_reserve, _user));
    }

    /**
    * @dev updates the state of the core as a consequence of a liquidation action.
    * @param _principalReserve the address of the principal reserve that is being repaid
    * @param _collateralReserve the address of the collateral reserve that is being liquidated
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _collateralToLiquidate the amount of collateral being liquidated
    * @param _feeLiquidated the amount of origination fee being liquidated
    * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise
    **/
    function updateStateOnLiquidation(
        address _principalReserve,
        address _collateralReserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _collateralToLiquidate,
        uint256 _feeLiquidated,
        uint256 _liquidatedCollateralForFee,
        uint256 _balanceIncrease,
        bool _liquidatorReceivesAToken
    ) external onlyLendingPool {
        updatePrincipalReserveStateOnLiquidationInternal(
            _principalReserve,
            _user,
            _amountToLiquidate,
            _balanceIncrease
        );

        updateCollateralReserveStateOnLiquidationInternal(
            _collateralReserve
        );

        updateUserStateOnLiquidationInternal(
            _principalReserve,
            _user,
            _amountToLiquidate,
            _feeLiquidated,
            _balanceIncrease
        );

        updateReserveInterestRatesAndTimestampInternal(_principalReserve, _amountToLiquidate, 0);

        if (!_liquidatorReceivesAToken) {
            updateReserveInterestRatesAndTimestampInternal(
                _collateralReserve,
                0,
                _collateralToLiquidate.add(_liquidatedCollateralForFee)
            );
        }

    }

    /**
    * @dev updates the state of the core as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @return the new stable rate for the user
    **/
    function updateStateOnRebalance(address _reserve, address _user, uint256 _balanceIncrease)
    external
    onlyLendingPool
    returns (uint256)
    {
        updateReserveStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);

        //update user data and rebalance the rate
        updateUserStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);
        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);
        return usersReserveData[_user][_reserve].stableBorrowRate;
    }

    /**
    * @dev enables or disables a reserve as collateral
    * @param _reserve the address of the principal reserve where the user deposited
    * @param _user the address of the depositor
    * @param _useAsCollateral true if the depositor wants to use the reserve as collateral
    **/
    function setUserUseReserveAsCollateral(address _reserve, address _user, bool _useAsCollateral)
    public
    onlyLendingPool
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        user.useAsCollateral = _useAsCollateral;
    }

    /**
    * @notice ETH/token transfer functions
    **/

    /**
    * @dev fallback function enforces that the caller is a contract, to support flashloan transfers
    **/
    function() external payable {
        //only contracts can send ETH to the core
        require(msg.sender.isContract(), "Only contracts can send ether to the Lending pool core");

    }

    /**
    * @dev transfers to the user a specific amount from the reserve.
    * @param _reserve the address of the reserve where the transfer is happening
    * @param _user the address of the user receiving the transfer
    * @param _amount the amount being transferred
    **/
    function transferToUser(address _reserve, address payable _user, uint256 _amount)
    external
    onlyLendingPool
    {
        if (_reserve != EthAddressLib.ethAddress()) {
            ERC20(_reserve).safeTransfer(_user, _amount);
        } else {
            //solium-disable-next-line
            (bool result, ) = _user.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers the protocol fees to the fees collection address
    * @param _token the address of the token being transferred
    * @param _user the address of the user from where the transfer is happening
    * @param _amount the amount being transferred
    * @param _destination the fee receiver address
    **/

    function transferToFeeCollectionAddress(
        address _token,
        address _user,
        uint256 _amount,
        address _destination
    ) external payable onlyLendingPool {
        address payable feeAddress = address(uint160(_destination)); //cast the address to payable

        if (_token != EthAddressLib.ethAddress()) {
            require(
                msg.value == 0,
                "User is sending ETH along with the ERC20 transfer. Check the value attribute of the transaction"
            );
            ERC20(_token).safeTransferFrom(_user, feeAddress, _amount);
        } else {
            require(msg.value >= _amount, "The amount and the value sent to deposit do not match");
            //solium-disable-next-line
            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers the fees to the fees collection address in the case of liquidation
    * @param _token the address of the token being transferred
    * @param _amount the amount being transferred
    * @param _destination the fee receiver address
    **/
    function liquidateFee(
        address _token,
        uint256 _amount,
        address _destination
    ) external payable onlyLendingPool {
        address payable feeAddress = address(uint160(_destination)); //cast the address to payable
        require(
            msg.value == 0,
            "Fee liquidation does not require any transfer of value"
        );

        if (_token != EthAddressLib.ethAddress()) {
            ERC20(_token).safeTransfer(feeAddress, _amount);
        } else {
            //solium-disable-next-line
            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers an amount from a user to the destination reserve
    * @param _reserve the address of the reserve where the amount is being transferred
    * @param _user the address of the user from where the transfer is happening
    * @param _amount the amount being transferred
    **/
    function transferToReserve(address _reserve, address payable _user, uint256 _amount)
    external
    payable
    onlyLendingPool
    {
        if (_reserve != EthAddressLib.ethAddress()) {
            require(msg.value == 0, "User is sending ETH along with the ERC20 transfer.");
            ERC20(_reserve).safeTransferFrom(_user, address(this), _amount);

        } else {
            require(msg.value >= _amount, "The amount and the value sent to deposit do not match");

            if (msg.value > _amount) {
                //send back excess ETH
                uint256 excessAmount = msg.value.sub(_amount);
                //solium-disable-next-line
                (bool result, ) = _user.call.value(excessAmount).gas(50000)("");
                require(result, "Transfer of ETH failed");
            }
        }
    }

    /**
    * @notice data access functions
    **/

    /**
    * @dev returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral)
    * needed to calculate the global account data in the LendingPoolDataProvider
    * @param _reserve the address of the reserve
    * @param _user the address of the user
    * @return the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not
    **/
    function getUserBasicReserveData(address _reserve, address _user)
    external
    view
    returns (uint256, uint256, uint256, bool)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        uint256 underlyingBalance = getUserUnderlyingAssetBalance(_reserve, _user);

        if (user.principalBorrowBalance == 0) {
            return (underlyingBalance, 0, 0, user.useAsCollateral);
        }

        return (
        underlyingBalance,
        user.getCompoundedBorrowBalance(reserve),
        user.originationFee,
        user.useAsCollateral
        );
    }

    /**
    * @dev checks if a user is allowed to borrow at a stable rate
    * @param _reserve the reserve address
    * @param _user the user
    * @param _amount the amount the the user wants to borrow
    * @return true if the user is allowed to borrow at a stable rate, false otherwise
    **/

    function isUserAllowedToBorrowAtStable(address _reserve, address _user, uint256 _amount)
    external
    view
    returns (bool)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (!reserve.isStableBorrowRateEnabled) return false;

        return
        !user.useAsCollateral ||
        !reserve.usageAsCollateralEnabled ||
        _amount > getUserUnderlyingAssetBalance(_reserve, _user);
    }

    /**
    * @dev gets the underlying asset balance of a user based on the corresponding aToken balance.
    * @param _reserve the reserve address
    * @param _user the user address
    * @return the underlying deposit balance of the user
    **/

    function getUserUnderlyingAssetBalance(address _reserve, address _user)
    public
    view
    returns (uint256)
    {
        AToken aToken = AToken(reserves[_reserve].aTokenAddress);
        return aToken.balanceOf(_user);

    }

    /**
    * @dev gets the interest rate strategy contract address for the reserve
    * @param _reserve the reserve address
    * @return the address of the interest rate strategy contract
    **/
    function getReserveInterestRateStrategyAddress(address _reserve) public view returns (address) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.interestRateStrategyAddress;
    }

    /**
    * @dev gets the aToken contract address for the reserve
    * @param _reserve the reserve address
    * @return the address of the aToken contract
    **/

    function getReserveATokenAddress(address _reserve) public view returns (address) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.aTokenAddress;
    }

    /**
    * @dev gets the available liquidity in the reserve. The available liquidity is the balance of the core contract
    * @param _reserve the reserve address
    * @return the available liquidity
    **/
    function getReserveAvailableLiquidity(address _reserve) public view returns (uint256) {
        uint256 balance = 0;

        if (_reserve == EthAddressLib.ethAddress()) {
            balance = address(this).balance;
        } else {
            balance = IERC20(_reserve).balanceOf(address(this));
        }
        return balance;
    }

    /**
    * @dev gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows
    * @param _reserve the reserve address
    * @return the total liquidity
    **/
    function getReserveTotalLiquidity(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return getReserveAvailableLiquidity(_reserve).add(reserve.getTotalBorrows());
    }

    /**
    * @dev gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there
    * there has been 100% income.
    * @param _reserve the reserve address
    * @return the reserve normalized income
    **/
    function getReserveNormalizedIncome(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.getNormalizedIncome();
    }

    /**
    * @dev gets the reserve total borrows
    * @param _reserve the reserve address
    * @return the total borrows (stable + variable)
    **/
    function getReserveTotalBorrows(address _reserve) public view returns (uint256) {
        return reserves[_reserve].getTotalBorrows();
    }

    /**
    * @dev gets the reserve total borrows stable
    * @param _reserve the reserve address
    * @return the total borrows stable
    **/
    function getReserveTotalBorrowsStable(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.totalBorrowsStable;
    }

    /**
    * @dev gets the reserve total borrows variable
    * @param _reserve the reserve address
    * @return the total borrows variable
    **/

    function getReserveTotalBorrowsVariable(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.totalBorrowsVariable;
    }

    /**
    * @dev gets the reserve liquidation threshold
    * @param _reserve the reserve address
    * @return the reserve liquidation threshold
    **/

    function getReserveLiquidationThreshold(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.liquidationThreshold;
    }

    /**
    * @dev gets the reserve liquidation bonus
    * @param _reserve the reserve address
    * @return the reserve liquidation bonus
    **/

    function getReserveLiquidationBonus(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.liquidationBonus;
    }

    /**
    * @dev gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty
    * @param _reserve the reserve address
    * @return the reserve current variable borrow rate
    **/

    function getReserveCurrentVariableBorrowRate(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        if (reserve.currentVariableBorrowRate == 0) {
            return
            IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)
            .getBaseVariableBorrowRate();
        }
        return reserve.currentVariableBorrowRate;
    }

    /**
    * @dev gets the reserve current stable borrow rate. Is the market rate if the reserve is empty
    * @param _reserve the reserve address
    * @return the reserve current stable borrow rate
    **/

    function getReserveCurrentStableBorrowRate(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        ILendingRateOracle oracle = ILendingRateOracle(addressesProvider.getLendingRateOracle());

        if (reserve.currentStableBorrowRate == 0) {
            //no stable rate borrows yet
            return oracle.getMarketBorrowRate(_reserve);
        }

        return reserve.currentStableBorrowRate;
    }

    /**
    * @dev gets the reserve average stable borrow rate. The average stable rate is the weighted average
    * of all the loans taken at stable rate.
    * @param _reserve the reserve address
    * @return the reserve current average borrow rate
    **/
    function getReserveCurrentAverageStableBorrowRate(address _reserve)
    external
    view
    returns (uint256)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.currentAverageStableBorrowRate;
    }

    /**
    * @dev gets the reserve liquidity rate
    * @param _reserve the reserve address
    * @return the reserve liquidity rate
    **/
    function getReserveCurrentLiquidityRate(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.currentLiquidityRate;
    }

    /**
    * @dev gets the reserve liquidity cumulative index
    * @param _reserve the reserve address
    * @return the reserve liquidity cumulative index
    **/
    function getReserveLiquidityCumulativeIndex(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.lastLiquidityCumulativeIndex;
    }

    /**
    * @dev gets the reserve variable borrow index
    * @param _reserve the reserve address
    * @return the reserve variable borrow index
    **/
    function getReserveVariableBorrowsCumulativeIndex(address _reserve)
    external
    view
    returns (uint256)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.lastVariableBorrowCumulativeIndex;
    }

    /**
    * @dev this function aggregates the configuration parameters of the reserve.
    * It's used in the LendingPoolDataProvider specifically to save gas, and avoid
    * multiple external contract calls to fetch the same data.
    * @param _reserve the reserve address
    * @return the reserve decimals
    * @return the base ltv as collateral
    * @return the liquidation threshold
    * @return if the reserve is used as collateral or not
    **/
    function getReserveConfiguration(address _reserve)
    external
    view
    returns (uint256, uint256, uint256, bool)
    {
        uint256 decimals;
        uint256 baseLTVasCollateral;
        uint256 liquidationThreshold;
        bool usageAsCollateralEnabled;

        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        decimals = reserve.decimals;
        baseLTVasCollateral = reserve.baseLTVasCollateral;
        liquidationThreshold = reserve.liquidationThreshold;
        usageAsCollateralEnabled = reserve.usageAsCollateralEnabled;

        return (decimals, baseLTVasCollateral, liquidationThreshold, usageAsCollateralEnabled);
    }

    /**
    * @dev returns the decimals of the reserve
    * @param _reserve the reserve address
    * @return the reserve decimals
    **/
    function getReserveDecimals(address _reserve) external view returns (uint256) {
        return reserves[_reserve].decimals;
    }

    /**
    * @dev returns true if the reserve is enabled for borrowing
    * @param _reserve the reserve address
    * @return true if the reserve is enabled for borrowing, false otherwise
    **/

    function isReserveBorrowingEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.borrowingEnabled;
    }

    /**
    * @dev returns true if the reserve is enabled as collateral
    * @param _reserve the reserve address
    * @return true if the reserve is enabled as collateral, false otherwise
    **/

    function isReserveUsageAsCollateralEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.usageAsCollateralEnabled;
    }

    /**
    * @dev returns true if the stable rate is enabled on reserve
    * @param _reserve the reserve address
    * @return true if the stable rate is enabled on reserve, false otherwise
    **/
    function getReserveIsStableBorrowRateEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isStableBorrowRateEnabled;
    }

    /**
    * @dev returns true if the reserve is active
    * @param _reserve the reserve address
    * @return true if the reserve is active, false otherwise
    **/
    function getReserveIsActive(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isActive;
    }

    /**
    * @notice returns if a reserve is freezed
    * @param _reserve the reserve for which the information is needed
    * @return true if the reserve is freezed, false otherwise
    **/

    function getReserveIsFreezed(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isFreezed;
    }

    /**
    * @notice returns the timestamp of the last action on the reserve
    * @param _reserve the reserve for which the information is needed
    * @return the last updated timestamp of the reserve
    **/

    function getReserveLastUpdate(address _reserve) external view returns (uint40 timestamp) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        timestamp = reserve.lastUpdateTimestamp;
    }

    /**
    * @dev returns the utilization rate U of a specific reserve
    * @param _reserve the reserve for which the information is needed
    * @return the utilization rate in ray
    **/

    function getReserveUtilizationRate(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        uint256 totalBorrows = reserve.getTotalBorrows();

        if (totalBorrows == 0) {
            return 0;
        }

        uint256 availableLiquidity = getReserveAvailableLiquidity(_reserve);

        return totalBorrows.rayDiv(availableLiquidity.add(totalBorrows));
    }

    /**
    * @return the array of reserves configured on the core
    **/
    function getReserves() external view returns (address[] memory) {
        return reservesList;
    }

    /**
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return true if the user has chosen to use the reserve as collateral, false otherwise
    **/
    function isUserUseReserveAsCollateralEnabled(address _reserve, address _user)
    external
    view
    returns (bool)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.useAsCollateral;
    }

    /**
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the origination fee for the user
    **/
    function getUserOriginationFee(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.originationFee;
    }

    /**
    * @dev users with no loans in progress have NONE as borrow rate mode
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the borrow rate mode for the user,
    **/

    function getUserCurrentBorrowRateMode(address _reserve, address _user)
    public
    view
    returns (CoreLibrary.InterestRateMode)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (user.principalBorrowBalance == 0) {
            return CoreLibrary.InterestRateMode.NONE;
        }

        return
        user.stableBorrowRate > 0
        ? CoreLibrary.InterestRateMode.STABLE
        : CoreLibrary.InterestRateMode.VARIABLE;
    }

    /**
    * @dev gets the current borrow rate of the user
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the borrow rate for the user,
    **/
    function getUserCurrentBorrowRate(address _reserve, address _user)
    internal
    view
    returns (uint256)
    {
        CoreLibrary.InterestRateMode rateMode = getUserCurrentBorrowRateMode(_reserve, _user);

        if (rateMode == CoreLibrary.InterestRateMode.NONE) {
            return 0;
        }

        return
        rateMode == CoreLibrary.InterestRateMode.STABLE
        ? usersReserveData[_user][_reserve].stableBorrowRate
        : reserves[_reserve].currentVariableBorrowRate;
    }

    /**
    * @dev the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the user stable rate
    **/
    function getUserCurrentStableBorrowRate(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.stableBorrowRate;
    }

    /**
    * @dev calculates and returns the borrow balances of the user
    * @param _reserve the address of the reserve
    * @param _user the address of the user
    * @return the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance
    **/

    function getUserBorrowBalances(address _reserve, address _user)
    public
    view
    returns (uint256, uint256, uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        if (user.principalBorrowBalance == 0) {
            return (0, 0, 0);
        }

        uint256 principal = user.principalBorrowBalance;
        uint256 compoundedBalance = CoreLibrary.getCompoundedBorrowBalance(
            user,
            reserves[_reserve]
        );
        return (principal, compoundedBalance, compoundedBalance.sub(principal));
    }

    /**
    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the variable borrow index for the user
    **/

    function getUserVariableBorrowCumulativeIndex(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.lastVariableBorrowCumulativeIndex;
    }

    /**
    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the variable borrow index for the user
    **/

    function getUserLastUpdate(address _reserve, address _user)
    external
    view
    returns (uint256 timestamp)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        timestamp = user.lastUpdateTimestamp;
    }

    /**
    * @dev updates the lending pool core configuration
    **/
    function refreshConfiguration() external onlyLendingPoolConfigurator {
        refreshConfigInternal();
    }

    /**
    * @dev initializes a reserve
    * @param _reserve the address of the reserve
    * @param _aTokenAddress the address of the overlying aToken contract
    * @param _decimals the decimals of the reserve currency
    * @param _interestRateStrategyAddress the address of the interest rate strategy contract
    **/
    function initReserve(
        address _reserve,
        address _aTokenAddress,
        uint256 _decimals,
        address _interestRateStrategyAddress
    ) external onlyLendingPoolConfigurator {
        reserves[_reserve].init(_aTokenAddress, _decimals, _interestRateStrategyAddress);
        addReserveToListInternal(_reserve);

    }



    /**
    * @dev removes the last added reserve in the reservesList array
    * @param _reserveToRemove the address of the reserve
    **/
    function removeLastAddedReserve(address _reserveToRemove)
    external onlyLendingPoolConfigurator {

        address lastReserve = reservesList[reservesList.length-1];

        require(lastReserve == _reserveToRemove, "Reserve being removed is different than the reserve requested");

        //as we can't check if totalLiquidity is 0 (since the reserve added might not be an ERC20) we at least check that there is nothing borrowed
        require(getReserveTotalBorrows(lastReserve) == 0, "Cannot remove a reserve with liquidity deposited");

        reserves[lastReserve].isActive = false;
        reserves[lastReserve].aTokenAddress = address(0);
        reserves[lastReserve].decimals = 0;
        reserves[lastReserve].lastLiquidityCumulativeIndex = 0;
        reserves[lastReserve].lastVariableBorrowCumulativeIndex = 0;
        reserves[lastReserve].borrowingEnabled = false;
        reserves[lastReserve].usageAsCollateralEnabled = false;
        reserves[lastReserve].baseLTVasCollateral = 0;
        reserves[lastReserve].liquidationThreshold = 0;
        reserves[lastReserve].liquidationBonus = 0;
        reserves[lastReserve].interestRateStrategyAddress = address(0);

        reservesList.pop();
    }

    /**
    * @dev updates the address of the interest rate strategy contract
    * @param _reserve the address of the reserve
    * @param _rateStrategyAddress the address of the interest rate strategy contract
    **/

    function setReserveInterestRateStrategyAddress(address _reserve, address _rateStrategyAddress)
    external
    onlyLendingPoolConfigurator
    {
        reserves[_reserve].interestRateStrategyAddress = _rateStrategyAddress;
    }

    /**
    * @dev enables borrowing on a reserve. Also sets the stable rate borrowing
    * @param _reserve the address of the reserve
    * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise
    **/

    function enableBorrowingOnReserve(address _reserve, bool _stableBorrowRateEnabled)
    external
    onlyLendingPoolConfigurator
    {
        reserves[_reserve].enableBorrowing(_stableBorrowRateEnabled);
    }

    /**
    * @dev disables borrowing on a reserve
    * @param _reserve the address of the reserve
    **/

    function disableBorrowingOnReserve(address _reserve) external onlyLendingPoolConfigurator {
        reserves[_reserve].disableBorrowing();
    }

    /**
    * @dev enables a reserve to be used as collateral
    * @param _reserve the address of the reserve
    **/
    function enableReserveAsCollateral(
        address _reserve,
        uint256 _baseLTVasCollateral,
        uint256 _liquidationThreshold,
        uint256 _liquidationBonus
    ) external onlyLendingPoolConfigurator {
        reserves[_reserve].enableAsCollateral(
            _baseLTVasCollateral,
            _liquidationThreshold,
            _liquidationBonus
        );
    }

    /**
    * @dev disables a reserve to be used as collateral
    * @param _reserve the address of the reserve
    **/
    function disableReserveAsCollateral(address _reserve) external onlyLendingPoolConfigurator {
        reserves[_reserve].disableAsCollateral();
    }

    /**
    * @dev enable the stable borrow rate mode on a reserve
    * @param _reserve the address of the reserve
    **/
    function enableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isStableBorrowRateEnabled = true;
    }

    /**
    * @dev disable the stable borrow rate mode on a reserve
    * @param _reserve the address of the reserve
    **/
    function disableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isStableBorrowRateEnabled = false;
    }

    /**
    * @dev activates a reserve
    * @param _reserve the address of the reserve
    **/
    function activateReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        require(
            reserve.lastLiquidityCumulativeIndex > 0 &&
            reserve.lastVariableBorrowCumulativeIndex > 0,
            "Reserve has not been initialized yet"
        );
        reserve.isActive = true;
    }

    /**
    * @dev deactivates a reserve
    * @param _reserve the address of the reserve
    **/
    function deactivateReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isActive = false;
    }

    /**
    * @notice allows the configurator to freeze the reserve.
    * A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance.
    * @param _reserve the address of the reserve
    **/
    function freezeReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isFreezed = true;
    }

    /**
    * @notice allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed.
    * @param _reserve the address of the reserve
    **/
    function unfreezeReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isFreezed = false;
    }

    /**
    * @notice allows the configurator to update the loan to value of a reserve
    * @param _reserve the address of the reserve
    * @param _ltv the new loan to value
    **/
    function setReserveBaseLTVasCollateral(address _reserve, uint256 _ltv)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.baseLTVasCollateral = _ltv;
    }

    /**
    * @notice allows the configurator to update the liquidation threshold of a reserve
    * @param _reserve the address of the reserve
    * @param _threshold the new liquidation threshold
    **/
    function setReserveLiquidationThreshold(address _reserve, uint256 _threshold)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.liquidationThreshold = _threshold;
    }

    /**
    * @notice allows the configurator to update the liquidation bonus of a reserve
    * @param _reserve the address of the reserve
    * @param _bonus the new liquidation bonus
    **/
    function setReserveLiquidationBonus(address _reserve, uint256 _bonus)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.liquidationBonus = _bonus;
    }

    /**
    * @notice allows the configurator to update the reserve decimals
    * @param _reserve the address of the reserve
    * @param _decimals the decimals of the reserve
    **/
    function setReserveDecimals(address _reserve, uint256 _decimals)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.decimals = _decimals;
    }

    /**
    * @notice internal functions
    **/

    /**
    * @dev updates the state of a reserve as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the previous borrow balance of the borrower before the action
    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount
    * @param _amountBorrowed the new amount borrowed
    * @param _rateMode the borrow rate mode (stable, variable)
    **/

    function updateReserveStateOnBorrowInternal(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _balanceIncrease,
        uint256 _amountBorrowed,
        CoreLibrary.InterestRateMode _rateMode
    ) internal {
        reserves[_reserve].updateCumulativeIndexes();

        //increasing reserve total borrows to account for the new borrow balance of the user
        //NOTE: Depending on the previous borrow mode, the borrows might need to be switched from variable to stable or vice versa

        updateReserveTotalBorrowsByRateModeInternal(
            _reserve,
            _user,
            _principalBorrowBalance,
            _balanceIncrease,
            _amountBorrowed,
            _rateMode
        );
    }

    /**
    * @dev updates the state of a user as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _amountBorrowed the amount borrowed
    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount
    * @param _rateMode the borrow rate mode (stable, variable)
    * @return the final borrow rate for the user. Emitted by the borrow() event
    **/

    function updateUserStateOnBorrowInternal(
        address _reserve,
        address _user,
        uint256 _amountBorrowed,
        uint256 _balanceIncrease,
        uint256 _fee,
        CoreLibrary.InterestRateMode _rateMode
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (_rateMode == CoreLibrary.InterestRateMode.STABLE) {
            //stable
            //reset the user variable index, and update the stable rate
            user.stableBorrowRate = reserve.currentStableBorrowRate;
            user.lastVariableBorrowCumulativeIndex = 0;
        } else if (_rateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //variable
            //reset the user stable rate, and store the new borrow index
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        } else {
            revert("Invalid borrow rate mode");
        }
        //increase the principal borrows and the origination fee
        user.principalBorrowBalance = user.principalBorrowBalance.add(_amountBorrowed).add(
            _balanceIncrease
        );
        user.originationFee = user.originationFee.add(_fee);

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

    }

    /**
    * @dev updates the state of the reserve as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateReserveStateOnRepayInternal(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_reserve][_user];

        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(_reserve, _user);

        //update the indexes
        reserves[_reserve].updateCumulativeIndexes();

        //compound the cumulated interest to the borrow balance and then subtracting the payback amount
        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _balanceIncrease,
                user.stableBorrowRate
            );
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _paybackAmountMinusFees,
                user.stableBorrowRate
            );
        } else {
            reserve.increaseTotalBorrowsVariable(_balanceIncrease);
            reserve.decreaseTotalBorrowsVariable(_paybackAmountMinusFees);
        }
    }

    /**
    * @dev updates the state of the user as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _originationFeeRepaid the fee on the amount that is being repaid
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _repaidWholeLoan true if the user is repaying the whole loan
    **/
    function updateUserStateOnRepayInternal(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _originationFeeRepaid,
        uint256 _balanceIncrease,
        bool _repaidWholeLoan
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        //update the user principal borrow balance, adding the cumulated interest and then subtracting the payback amount
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(
            _paybackAmountMinusFees
        );
        user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;

        //if the balance decrease is equal to the previous principal (user is repaying the whole loan)
        //and the rate mode is stable, we reset the interest rate mode of the user
        if (_repaidWholeLoan) {
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = 0;
        }
        user.originationFee = user.originationFee.sub(_originationFeeRepaid);

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

    }

    /**
    * @dev updates the state of the user as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is performing the rate swap
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the the principal amount borrowed by the user
    * @param _compoundedBorrowBalance the principal amount plus the accrued interest
    * @param _currentRateMode the rate mode at which the user borrowed
    **/
    function updateReserveStateOnSwapRateInternal(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _compoundedBorrowBalance,
        CoreLibrary.InterestRateMode _currentRateMode
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        //compounding reserve indexes
        reserve.updateCumulativeIndexes();

        if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {
            uint256 userCurrentStableRate = user.stableBorrowRate;

            //swap to variable
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _principalBorrowBalance,
                userCurrentStableRate
            ); //decreasing stable from old principal balance
            reserve.increaseTotalBorrowsVariable(_compoundedBorrowBalance); //increase variable borrows
        } else if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //swap to stable
            uint256 currentStableRate = reserve.currentStableBorrowRate;
            reserve.decreaseTotalBorrowsVariable(_principalBorrowBalance);
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _compoundedBorrowBalance,
                currentStableRate
            );

        } else {
            revert("Invalid rate mode received");
        }
    }

    /**
    * @dev updates the state of the user as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is performing the swap
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _currentRateMode the current rate mode of the user
    **/

    function updateUserStateOnSwapRateInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease,
        CoreLibrary.InterestRateMode _currentRateMode
    ) internal returns (CoreLibrary.InterestRateMode) {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        CoreLibrary.InterestRateMode newMode = CoreLibrary.InterestRateMode.NONE;

        if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //switch to stable
            newMode = CoreLibrary.InterestRateMode.STABLE;
            user.stableBorrowRate = reserve.currentStableBorrowRate;
            user.lastVariableBorrowCumulativeIndex = 0;
        } else if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {
            newMode = CoreLibrary.InterestRateMode.VARIABLE;
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        } else {
            revert("Invalid interest rate mode received");
        }
        //compounding cumulated interest
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);
        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

        return newMode;
    }

    /**
    * @dev updates the state of the principal reserve as a consequence of a liquidation action.
    * @param _principalReserve the address of the principal reserve that is being repaid
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updatePrincipalReserveStateOnLiquidationInternal(
        address _principalReserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_principalReserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_principalReserve];

        //update principal reserve data
        reserve.updateCumulativeIndexes();

        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(
            _principalReserve,
            _user
        );

        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            //increase the total borrows by the compounded interest
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _balanceIncrease,
                user.stableBorrowRate
            );

            //decrease by the actual amount to liquidate
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _amountToLiquidate,
                user.stableBorrowRate
            );

        } else {
            //increase the total borrows by the compounded interest
            reserve.increaseTotalBorrowsVariable(_balanceIncrease);

            //decrease by the actual amount to liquidate
            reserve.decreaseTotalBorrowsVariable(_amountToLiquidate);
        }

    }

    /**
    * @dev updates the state of the collateral reserve as a consequence of a liquidation action.
    * @param _collateralReserve the address of the collateral reserve that is being liquidated
    **/
    function updateCollateralReserveStateOnLiquidationInternal(
        address _collateralReserve
    ) internal {
        //update collateral reserve
        reserves[_collateralReserve].updateCumulativeIndexes();

    }

    /**
    * @dev updates the state of the user being liquidated as a consequence of a liquidation action.
    * @param _reserve the address of the principal reserve that is being repaid
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _feeLiquidated the amount of origination fee being liquidated
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/
    function updateUserStateOnLiquidationInternal(
        address _reserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _feeLiquidated,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        //first increase by the compounded interest, then decrease by the liquidated amount
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(
            _amountToLiquidate
        );

        if (
            getUserCurrentBorrowRateMode(_reserve, _user) == CoreLibrary.InterestRateMode.VARIABLE
        ) {
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        }

        if(_feeLiquidated > 0){
            user.originationFee = user.originationFee.sub(_feeLiquidated);
        }

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);
    }

    /**
    * @dev updates the state of the reserve as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateReserveStateOnRebalanceInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        reserve.updateCumulativeIndexes();

        reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
            _balanceIncrease,
            user.stableBorrowRate
        );

    }

    /**
    * @dev updates the state of the user as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateUserStateOnRebalanceInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);
        user.stableBorrowRate = reserve.currentStableBorrowRate;

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);
    }

    /**
    * @dev updates the state of the user as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _amountBorrowed the accrued interest on the borrowed amount
    **/
    function updateReserveTotalBorrowsByRateModeInternal(
        address _reserve,
        address _user,
        uint256 _principalBalance,
        uint256 _balanceIncrease,
        uint256 _amountBorrowed,
        CoreLibrary.InterestRateMode _newBorrowRateMode
    ) internal {
        CoreLibrary.InterestRateMode previousRateMode = getUserCurrentBorrowRateMode(
            _reserve,
            _user
        );
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        if (previousRateMode == CoreLibrary.InterestRateMode.STABLE) {
            CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _principalBalance,
                user.stableBorrowRate
            );
        } else if (previousRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            reserve.decreaseTotalBorrowsVariable(_principalBalance);
        }

        uint256 newPrincipalAmount = _principalBalance.add(_balanceIncrease).add(_amountBorrowed);
        if (_newBorrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                newPrincipalAmount,
                reserve.currentStableBorrowRate
            );
        } else if (_newBorrowRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            reserve.increaseTotalBorrowsVariable(newPrincipalAmount);
        } else {
            revert("Invalid new borrow rate mode");
        }
    }

    /**
    * @dev Updates the reserve current stable borrow rate Rf, the current variable borrow rate Rv and the current liquidity rate Rl.
    * Also updates the lastUpdateTimestamp value. Please refer to the whitepaper for further information.
    * @param _reserve the address of the reserve to be updated
    * @param _liquidityAdded the amount of liquidity added to the protocol (deposit or repay) in the previous action
    * @param _liquidityTaken the amount of liquidity taken from the protocol (redeem or borrow)
    **/

    function updateReserveInterestRatesAndTimestampInternal(
        address _reserve,
        uint256 _liquidityAdded,
        uint256 _liquidityTaken
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        (uint256 newLiquidityRate, uint256 newStableRate, uint256 newVariableRate) = IReserveInterestRateStrategy(
            reserve
            .interestRateStrategyAddress
        )
        .calculateInterestRates(
            _reserve,
            getReserveAvailableLiquidity(_reserve).add(_liquidityAdded).sub(_liquidityTaken),
            reserve.totalBorrowsStable,
            reserve.totalBorrowsVariable,
            reserve.currentAverageStableBorrowRate
        );

        reserve.currentLiquidityRate = newLiquidityRate;
        reserve.currentStableBorrowRate = newStableRate;
        reserve.currentVariableBorrowRate = newVariableRate;

        //solium-disable-next-line
        reserve.lastUpdateTimestamp = uint40(block.timestamp);

        emit ReserveUpdated(
            _reserve,
            newLiquidityRate,
            newStableRate,
            newVariableRate,
            reserve.lastLiquidityCumulativeIndex,
            reserve.lastVariableBorrowCumulativeIndex
        );
    }

    /**
    * @dev transfers to the protocol fees of a flashloan to the fees collection address
    * @param _token the address of the token being transferred
    * @param _amount the amount being transferred
    **/

    function transferFlashLoanProtocolFeeInternal(address _token, uint256 _amount) internal {
        address payable receiver = address(uint160(addressesProvider.getTokenDistributor()));

        if (_token != EthAddressLib.ethAddress()) {
            ERC20(_token).safeTransfer(receiver, _amount);
        } else {
            receiver.transfer(_amount);
        }
    }

    /**
    * @dev updates the internal configuration of the core
    **/
    function refreshConfigInternal() internal {
        lendingPoolAddress = addressesProvider.getLendingPool();
    }

    /**
    * @dev adds a reserve to the array of the reserves address
    **/
    function addReserveToListInternal(address _reserve) internal {
        bool reserveAlreadyAdded = false;
        for (uint256 i = 0; i < reservesList.length; i++)
            if (reservesList[i] == _reserve) {
                reserveAlreadyAdded = true;
            }
        if (!reserveAlreadyAdded) reservesList.push(_reserve);
    }

}
.]

###

[2024-01-09 04:31:30 INFO] **[Seminar Conclusion]**:

 ###

[2024-01-09 04:31:30 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 1

[2024-01-09 04:31:30 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | pragma solidity ^0.5.0; import "openzeppelin-solidity/contracts/math/SafeMath.sol"; import "openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol"; import "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol"; import "openzeppelin-solidity/contracts/utils/Address.sol"; import "../libraries/openzeppelin-upgradeability/VersionedInitializable.sol"; import "../libraries/CoreLibrary.sol"; import "../configuration/LendingPoolAddressesProvider.sol"; import "../interfaces/ILendingRateOracle.sol"; import "../interfaces/IReserveInterestRateStrategy.sol"; import "../libraries/WadRayMath.sol"; import "../tokenization/AToken.sol"; import "../libraries/EthAddressLib.sol"; / * @title LendingPoolCore contract * @author Aave * @notice Holds the state of the lending pool and all the funds deposited * @dev NOTE: The core does not enforce security checks on the update of the state * (eg, updateStateOnBorrow() does not enforce that borrowed is enabled on the reserve). * The check that an action can be performed is a duty of the overlying LendingPool contract. / contract LendingPoolCore is VersionedInitializable {     using SafeMath for uint256;     using WadRayMath for uint256;     using CoreLibrary for CoreLibrary.ReserveData;     using CoreLibrary for CoreLibrary.UserReserveData;     using SafeERC20 for ERC20;     using Address for address payable; /** * @dev Emitted when the state of a reserve is updated * @param reserve the address of the reserve * @param liquidityRate the new liquidity rate * @param stableBorrowRate the new stable borrow rate * @param variableBorrowRate the new variable borrow rate * @param liquidityIndex the new liquidity index * @param variableBorrowIndex the new variable borrow index **/ event ReserveUpdated(     address indexed reserve,     uint256 liquidityRate,     uint256 stableBorrowRate,     uint256 variableBorrowRate,     uint256 liquidityIndex,     uint256 variableBorrowIndex );  address public lendingPoolAddress;  LendingPoolAddressesProvider public addressesProvider;  /** * @dev only lending pools can use functions affected by this modifier **/ modifier onlyLendingPool {     require(lendingPoolAddress == msg.sender, "The caller must be a lending pool contract");     _; }  /** * @dev only lending pools configurator can use functions affected by this modifier **/ modifier onlyLendingPoolConfigurator {     require(         addressesProvider.getLendingPoolConfigurator() == msg.sender,         "The caller must be a lending pool configurator contract"     );     _; }  mapping(address =&gt; CoreLibrary.ReserveData) internal reserves; mapping(address =&gt; mapping(address =&gt; CoreLibrary.UserReserveData)) internal usersReserveData;  address[] public reservesList;  uint256 public constant CORE_REVISION = 0x4;  /** * @dev returns the revision number of the contract **/ function getRevision() internal pure returns (uint256) {     return CORE_REVISION; }  /** * @dev initializes the Core contract, invoked upon registration on the AddressesProvider * @param _addressesProvider the addressesProvider contract **/  function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {     addressesProvider = _addressesProvider;     refreshConfigInternal(); }  /** * @dev updates the state of the core as a result of a deposit action * @param _reserve the address of the reserve in which the deposit is happening * @param _user the address of the the user depositing * @param _amount the amount being deposited * @param _isFirstDeposit true if the user is depositing for the first time **/  function updateStateOnDeposit(     address _reserve,     address _user,     uint256 _amount,     bool _isFirstDeposit ) external onlyLendingPool {     reserves[_reserve].updateCumulativeIndexes();     updateReserveInterestRatesAndTimestampInternal(_reserve, _amount, 0);      if (_isFirstDeposit) {         //if this is the first deposit of the user, we configure the deposit as enabled to be used as collateral         setUserUseReserveAsCollateral(_reserve, _user, true);     } }  /** * @dev updates the state of the core as a result of a redeem action * @param _reserve the address of the reserve in which the redeem is happening * @param _user the address of the the user redeeming * @param _amountRedeemed the amount being redeemed * @param _userRedeemedEverything true if the user is redeeming everything **/ function updateStateOnRedeem(     address _reserve,     address _user,     uint256 _amountRedeemed,     bool _userRedeemedEverything ) external onlyLendingPool {     //compound liquidity and variable borrow interests     reserves[_reserve].updateCumulativeIndexes();     updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountRedeemed);      //if user redeemed everything the useReserveAsCollateral flag is reset     if (_userRedeemedEverything) {         setUserUseReserveAsCollateral(_reserve, _user, false);     } }  /** * @dev updates the state of the core as a result of a flashloan action * @param _reserve the address of the reserve in which the flashloan is happening * @param _income the income of the protocol as a result of the action **/ function updateStateOnFlashLoan(     address _reserve,     uint256 _availableLiquidityBefore,     uint256 _income,     uint256 _protocolFee ) external onlyLendingPool {     transferFlashLoanProtocolFeeInternal(_reserve, _protocolFee);      //compounding the cumulated interest     reserves[_reserve].updateCumulativeIndexes();      uint256 totalLiquidityBefore = _availableLiquidityBefore.add(         getReserveTotalBorrows(_reserve)     );      //compounding the received fee into the reserve     reserves[_reserve].cumulateToLiquidityIndex(totalLiquidityBefore, _income);      //refresh interest rates     updateReserveInterestRatesAndTimestampInternal(_reserve, _income, 0); }  /** * @dev updates the state of the core as a consequence of a borrow action. * @param _reserve the address of the reserve on which the user is borrowing * @param _user the address of the borrower * @param _amountBorrowed the new amount borrowed * @param _borrowFee the fee on the amount borrowed * @param _rateMode the borrow rate mode (stable, variable) * @return the new borrow rate for the user **/ function updateStateOnBorrow(     address _reserve,     address _user,     uint256 _amountBorrowed,     uint256 _borrowFee,     CoreLibrary.InterestRateMode _rateMode ) external onlyLendingPool returns (uint256, uint256) {     // getting the previous borrow data of the user     (uint256 principalBorrowBalance, , uint256 balanceIncrease) = getUserBorrowBalances(         _reserve,         _user     );      updateReserveStateOnBorrowInternal(         _reserve,         _user,         principalBorrowBalance,         balanceIncrease,         _amountBorrowed,         _rateMode     );      updateUserStateOnBorrowInternal(         _reserve,         _user,         _amountBorrowed,         balanceIncrease,         _borrowFee,         _rateMode     );      updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountBorrowed);      return (getUserCurrentBorrowRate(_reserve, _user), balanceIncrease); }  /** * @dev updates the state of the core as a consequence of a repay action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _paybackAmountMinusFees the amount being paid back minus fees * @param _originationFeeRepaid the fee on the amount that is being repaid * @param _balanceIncrease the accrued interest on the borrowed amount * @param _repaidWholeLoan true if the user is repaying the whole loan **/  function updateStateOnRepay(     address _reserve,     address _user,     uint256 _paybackAmountMinusFees,     uint256 _originationFeeRepaid,     uint256 _balanceIncrease,     bool _repaidWholeLoan ) external onlyLendingPool {     updateReserveStateOnRepayInternal(         _reserve,         _user,         _paybackAmountMinusFees,         _balanceIncrease     );     updateUserStateOnRepayInternal(         _reserve,         _user,         _paybackAmountMinusFees,         _originationFeeRepaid,         _balanceIncrease,         _repaidWholeLoan     );      updateReserveInterestRatesAndTimestampInternal(_reserve, _paybackAmountMinusFees, 0); }  /** * @dev updates the state of the core as a consequence of a swap rate action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _principalBorrowBalance the amount borrowed by the user * @param _compoundedBorrowBalance the amount borrowed plus accrued interest * @param _balanceIncrease the accrued interest on the borrowed amount * @param _currentRateMode the current interest rate mode for the user **/ function updateStateOnSwapRate(     address _reserve,     address _user,     uint256 _principalBorrowBalance,     uint256 _compoundedBorrowBalance,     uint256 _balanceIncrease,     CoreLibrary.InterestRateMode _currentRateMode ) external onlyLendingPool returns (CoreLibrary.InterestRateMode, uint256) {     updateReserveStateOnSwapRateInternal(         _reserve,         _user,         _principalBorrowBalance,         _compoundedBorrowBalance,         _currentRateMode     );      CoreLibrary.InterestRateMode newRateMode = updateUserStateOnSwapRateInternal(         _reserve,         _user,         _balanceIncrease,         _currentRateMode     );      updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);      return (newRateMode, getUserCurrentBorrowRate(_reserve, _user)); }  /** * @dev updates the state of the core as a consequence of a liquidation action. * @param _principalReserve the address of the principal reserve that is being repaid * @param _collateralReserve the address of the collateral reserve that is being liquidated * @param _user the address of the borrower * @param _amountToLiquidate the amount being repaid by the liquidator * @param _collateralToLiquidate the amount of collateral being liquidated * @param _feeLiquidated the amount of origination fee being liquidated * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus * @param _balanceIncrease the accrued interest on the borrowed amount * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise **/ function updateStateOnLiquidation(     address _principalReserve,     address _collateralReserve,     address _user,     uint256 _amountToLiquidate,     uint256 _collateralToLiquidate,     uint256 _feeLiquidated,     uint256 _liquidatedCollateralForFee,     uint256 _balanceIncrease,     bool _liquidatorReceivesAToken ) external onlyLendingPool {     updatePrincipalReserveStateOnLiquidationInternal(         _principalReserve,         _user,         _amountToLiquidate,         _balanceIncrease     );      updateCollateralReserveStateOnLiquidationInternal(         _collateralReserve     );      updateUserStateOnLiquidationInternal(         _principalReserve,         _user,         _amountToLiquidate,         _feeLiquidated,         _balanceIncrease     );      updateReserveInterestRatesAndTimestampInternal(_principalReserve, _amountToLiquidate, 0);      if (!_liquidatorReceivesAToken) {         updateReserveInterestRatesAndTimestampInternal(             _collateralReserve,             0,             _collateralToLiquidate.add(_liquidatedCollateralForFee)         );     }  }  /** * @dev updates the state of the core as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount * @return the new stable rate for the user **/ function updateStateOnRebalance(address _reserve, address _user, uint256 _balanceIncrease) external onlyLendingPool returns (uint256) {     updateReserveStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);      //update user data and rebalance the rate     updateUserStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);     updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);     return usersReserveData[_user][_reserve].stableBorrowRate; }  /** * @dev enables or disables a reserve as collateral * @param _reserve the address of the principal reserve where the user deposited * @param _user the address of the depositor * @param _useAsCollateral true if the depositor wants to use the reserve as collateral **/ function setUserUseReserveAsCollateral(address _reserve, address _user, bool _useAsCollateral) public onlyLendingPool {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     user.useAsCollateral = _useAsCollateral; }  /** * @notice ETH/token transfer functions **/  /** * @dev fallback function enforces that the caller is a contract, to support flashloan transfers **/ function() external payable {     //only contracts can send ETH to the core     require(msg.sender.isContract(), "Only contracts can send ether to the Lending pool core");  }  /** * @dev transfers to the user a specific amount from the reserve. * @param _reserve the address of the reserve where the transfer is happening * @param _user the address of the user receiving the transfer * @param _amount the amount being transferred **/ function transferToUser(address _reserve, address payable _user, uint256 _amount) external onlyLendingPool {     if (_reserve != EthAddressLib.ethAddress()) {         ERC20(_reserve).safeTransfer(_user, _amount);     } else {         //solium-disable-next-line         (bool result, ) = _user.call.value(_amount).gas(50000)("");         require(result, "Transfer of ETH failed");     } }  /** * @dev transfers the protocol fees to the fees collection address * @param _token the address of the token being transferred * @param _user the address of the user from where the transfer is happening * @param _amount the amount being transferred * @param _destination the fee receiver address **/  function transferToFeeCollectionAddress(     address _token,     address _user,     uint256 _amount,     address _destination ) external payable onlyLendingPool {     address payable feeAddress = address(uint160(_destination)); //cast the address to payable      if (_token != EthAddressLib.ethAddress()) {         require(             msg.value == 0,             "User is sending ETH along with the ERC20 transfer. Check the value attribute of the transaction"         );         ERC20(_token).safeTransferFrom(_user, feeAddress, _amount);     } else {         require(msg.value &gt;= _amount, "The amount and the value sent to deposit do not match");         //solium-disable-next-line         (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");         require(result, "Transfer of ETH failed");     } }  /** * @dev transfers the fees to the fees collection address in the case of liquidation * @param _token the address of the token being transferred * @param _amount the amount being transferred * @param _destination the fee receiver address **/ function liquidateFee(     address _token,     uint256 _amount,     address _destination ) external payable onlyLendingPool {     address payable feeAddress = address(uint160(_destination)); //cast the address to payable     require(         msg.value == 0,         "Fee liquidation does not require any transfer of value"     );      if (_token != EthAddressLib.ethAddress()) {         ERC20(_token).safeTransfer(feeAddress, _amount);     } else {         //solium-disable-next-line         (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");         require(result, "Transfer of ETH failed");     } }  /** * @dev transfers an amount from a user to the destination reserve * @param _reserve the address of the reserve where the amount is being transferred * @param _user the address of the user from where the transfer is happening * @param _amount the amount being transferred **/ function transferToReserve(address _reserve, address payable _user, uint256 _amount) external payable onlyLendingPool {     if (_reserve != EthAddressLib.ethAddress()) {         require(msg.value == 0, "User is sending ETH along with the ERC20 transfer.");         ERC20(_reserve).safeTransferFrom(_user, address(this), _amount);      } else {         require(msg.value &gt;= _amount, "The amount and the value sent to deposit do not match");          if (msg.value &gt; _amount) {             //send back excess ETH             uint256 excessAmount = msg.value.sub(_amount);             //solium-disable-next-line             (bool result, ) = _user.call.value(excessAmount).gas(50000)("");             require(result, "Transfer of ETH failed");         }     } }  /** * @notice data access functions **/  /** * @dev returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral) * needed to calculate the global account data in the LendingPoolDataProvider * @param _reserve the address of the reserve * @param _user the address of the user * @return the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not **/ function getUserBasicReserveData(address _reserve, address _user) external view returns (uint256, uint256, uint256, bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      uint256 underlyingBalance = getUserUnderlyingAssetBalance(_reserve, _user);      if (user.principalBorrowBalance == 0) {         return (underlyingBalance, 0, 0, user.useAsCollateral);     }      return (     underlyingBalance,     user.getCompoundedBorrowBalance(reserve),     user.originationFee,     user.useAsCollateral     ); }  /** * @dev checks if a user is allowed to borrow at a stable rate * @param _reserve the reserve address * @param _user the user * @param _amount the amount the the user wants to borrow * @return true if the user is allowed to borrow at a stable rate, false otherwise **/  function isUserAllowedToBorrowAtStable(address _reserve, address _user, uint256 _amount) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      if (!reserve.isStableBorrowRateEnabled) return false;      return     !user.useAsCollateral ||     !reserve.usageAsCollateralEnabled ||     _amount &gt; getUserUnderlyingAssetBalance(_reserve, _user); }  /** * @dev gets the underlying asset balance of a user based on the corresponding aToken balance. * @param _reserve the reserve address * @param _user the user address * @return the underlying deposit balance of the user **/  function getUserUnderlyingAssetBalance(address _reserve, address _user) public view returns (uint256) {     AToken aToken = AToken(reserves[_reserve].aTokenAddress);     return aToken.balanceOf(_user);  }  /** * @dev gets the interest rate strategy contract address for the reserve * @param _reserve the reserve address * @return the address of the interest rate strategy contract **/ function getReserveInterestRateStrategyAddress(address _reserve) public view returns (address) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.interestRateStrategyAddress; }  /** * @dev gets the aToken contract address for the reserve * @param _reserve the reserve address * @return the address of the aToken contract **/  function getReserveATokenAddress(address _reserve) public view returns (address) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.aTokenAddress; }  /** * @dev gets the available liquidity in the reserve. The available liquidity is the balance of the core contract * @param _reserve the reserve address * @return the available liquidity **/ function getReserveAvailableLiquidity(address _reserve) public view returns (uint256) {     uint256 balance = 0;      if (_reserve == EthAddressLib.ethAddress()) {         balance = address(this).balance;     } else {         balance = IERC20(_reserve).balanceOf(address(this));     }     return balance; }  /** * @dev gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows * @param _reserve the reserve address * @return the total liquidity **/ function getReserveTotalLiquidity(address _reserve) public view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return getReserveAvailableLiquidity(_reserve).add(reserve.getTotalBorrows()); }  /** * @dev gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there * there has been 100% income. * @param _reserve the reserve address * @return the reserve normalized income **/ function getReserveNormalizedIncome(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.getNormalizedIncome(); }  /** * @dev gets the reserve total borrows * @param _reserve the reserve address * @return the total borrows (stable + variable) **/ function getReserveTotalBorrows(address _reserve) public view returns (uint256) {     return reserves[_reserve].getTotalBorrows(); }  /** * @dev gets the reserve total borrows stable * @param _reserve the reserve address * @return the total borrows stable **/ function getReserveTotalBorrowsStable(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.totalBorrowsStable; }  /** * @dev gets the reserve total borrows variable * @param _reserve the reserve address * @return the total borrows variable **/  function getReserveTotalBorrowsVariable(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.totalBorrowsVariable; }  /** * @dev gets the reserve liquidation threshold * @param _reserve the reserve address * @return the reserve liquidation threshold **/  function getReserveLiquidationThreshold(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.liquidationThreshold; }  /** * @dev gets the reserve liquidation bonus * @param _reserve the reserve address * @return the reserve liquidation bonus **/  function getReserveLiquidationBonus(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.liquidationBonus; }  /** * @dev gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty * @param _reserve the reserve address * @return the reserve current variable borrow rate **/  function getReserveCurrentVariableBorrowRate(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      if (reserve.currentVariableBorrowRate == 0) {         return         IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)         .getBaseVariableBorrowRate();     }     return reserve.currentVariableBorrowRate; }  /** * @dev gets the reserve current stable borrow rate. Is the market rate if the reserve is empty * @param _reserve the reserve address * @return the reserve current stable borrow rate **/  function getReserveCurrentStableBorrowRate(address _reserve) public view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     ILendingRateOracle oracle = ILendingRateOracle(addressesProvider.getLendingRateOracle());      if (reserve.currentStableBorrowRate == 0) {         //no stable rate borrows yet         return oracle.getMarketBorrowRate(_reserve);     }      return reserve.currentStableBorrowRate; }  /** * @dev gets the reserve average stable borrow rate. The average stable rate is the weighted average * of all the loans taken at stable rate. * @param _reserve the reserve address * @return the reserve current average borrow rate **/ function getReserveCurrentAverageStableBorrowRate(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.currentAverageStableBorrowRate; }  /** * @dev gets the reserve liquidity rate * @param _reserve the reserve address * @return the reserve liquidity rate **/ function getReserveCurrentLiquidityRate(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.currentLiquidityRate; }  /** * @dev gets the reserve liquidity cumulative index * @param _reserve the reserve address * @return the reserve liquidity cumulative index **/ function getReserveLiquidityCumulativeIndex(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.lastLiquidityCumulativeIndex; }  /** * @dev gets the reserve variable borrow index * @param _reserve the reserve address * @return the reserve variable borrow index **/ function getReserveVariableBorrowsCumulativeIndex(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.lastVariableBorrowCumulativeIndex; }  /** * @dev this function aggregates the configuration parameters of the reserve. * It's used in the LendingPoolDataProvider specifically to save gas, and avoid * multiple external contract calls to fetch the same data. * @param _reserve the reserve address * @return the reserve decimals * @return the base ltv as collateral * @return the liquidation threshold * @return if the reserve is used as collateral or not **/ function getReserveConfiguration(address _reserve) external view returns (uint256, uint256, uint256, bool) {     uint256 decimals;     uint256 baseLTVasCollateral;     uint256 liquidationThreshold;     bool usageAsCollateralEnabled;      CoreLibrary.ReserveData storage reserve = reserves[_reserve];     decimals = reserve.decimals;     baseLTVasCollateral = reserve.baseLTVasCollateral;     liquidationThreshold = reserve.liquidationThreshold;     usageAsCollateralEnabled = reserve.usageAsCollateralEnabled;      return (decimals, baseLTVasCollateral, liquidationThreshold, usageAsCollateralEnabled); }  /** * @dev returns the decimals of the reserve * @param _reserve the reserve address * @return the reserve decimals **/ function getReserveDecimals(address _reserve) external view returns (uint256) {     return reserves[_reserve].decimals; }  /** * @dev returns true if the reserve is enabled for borrowing * @param _reserve the reserve address * @return true if the reserve is enabled for borrowing, false otherwise **/  function isReserveBorrowingEnabled(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.borrowingEnabled; }  /** * @dev returns true if the reserve is enabled as collateral * @param _reserve the reserve address * @return true if the reserve is enabled as collateral, false otherwise **/  function isReserveUsageAsCollateralEnabled(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.usageAsCollateralEnabled; }  /** * @dev returns true if the stable rate is enabled on reserve * @param _reserve the reserve address * @return true if the stable rate is enabled on reserve, false otherwise **/ function getReserveIsStableBorrowRateEnabled(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.isStableBorrowRateEnabled; }  /** * @dev returns true if the reserve is active * @param _reserve the reserve address * @return true if the reserve is active, false otherwise **/ function getReserveIsActive(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.isActive; }  /** * @notice returns if a reserve is freezed * @param _reserve the reserve for which the information is needed * @return true if the reserve is freezed, false otherwise **/  function getReserveIsFreezed(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.isFreezed; }  /** * @notice returns the timestamp of the last action on the reserve * @param _reserve the reserve for which the information is needed * @return the last updated timestamp of the reserve **/  function getReserveLastUpdate(address _reserve) external view returns (uint40 timestamp) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     timestamp = reserve.lastUpdateTimestamp; }  /** * @dev returns the utilization rate U of a specific reserve * @param _reserve the reserve for which the information is needed * @return the utilization rate in ray **/  function getReserveUtilizationRate(address _reserve) public view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      uint256 totalBorrows = reserve.getTotalBorrows();      if (totalBorrows == 0) {         return 0;     }      uint256 availableLiquidity = getReserveAvailableLiquidity(_reserve);      return totalBorrows.rayDiv(availableLiquidity.add(totalBorrows)); }  /** * @return the array of reserves configured on the core **/ function getReserves() external view returns (address[] memory) {     return reservesList; }  /** * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return true if the user has chosen to use the reserve as collateral, false otherwise **/ function isUserUseReserveAsCollateralEnabled(address _reserve, address _user) external view returns (bool) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.useAsCollateral; }  /** * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the origination fee for the user **/ function getUserOriginationFee(address _reserve, address _user) external view returns (uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.originationFee; }  /** * @dev users with no loans in progress have NONE as borrow rate mode * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the borrow rate mode for the user, **/  function getUserCurrentBorrowRateMode(address _reserve, address _user) public view returns (CoreLibrary.InterestRateMode) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      if (user.principalBorrowBalance == 0) {         return CoreLibrary.InterestRateMode.NONE;     }      return     user.stableBorrowRate &gt; 0     ? CoreLibrary.InterestRateMode.STABLE     : CoreLibrary.InterestRateMode.VARIABLE; }  /** * @dev gets the current borrow rate of the user * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the borrow rate for the user, **/ function getUserCurrentBorrowRate(address _reserve, address _user) internal view returns (uint256) {     CoreLibrary.InterestRateMode rateMode = getUserCurrentBorrowRateMode(_reserve, _user);      if (rateMode == CoreLibrary.InterestRateMode.NONE) {         return 0;     }      return     rateMode == CoreLibrary.InterestRateMode.STABLE     ? usersReserveData[_user][_reserve].stableBorrowRate     : reserves[_reserve].currentVariableBorrowRate; }  /** * @dev the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the user stable rate **/ function getUserCurrentStableBorrowRate(address _reserve, address _user) external view returns (uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.stableBorrowRate; }  /** * @dev calculates and returns the borrow balances of the user * @param _reserve the address of the reserve * @param _user the address of the user * @return the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance **/  function getUserBorrowBalances(address _reserve, address _user) public view returns (uint256, uint256, uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     if (user.principalBorrowBalance == 0) {         return (0, 0, 0);     }      uint256 principal = user.principalBorrowBalance;     uint256 compoundedBalance = CoreLibrary.getCompoundedBorrowBalance(         user,         reserves[_reserve]     );     return (principal, compoundedBalance, compoundedBalance.sub(principal)); }  /** * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the variable borrow index for the user **/  function getUserVariableBorrowCumulativeIndex(address _reserve, address _user) external view returns (uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.lastVariableBorrowCumulativeIndex; }  /** * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the variable borrow index for the user **/  function getUserLastUpdate(address _reserve, address _user) external view returns (uint256 timestamp) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     timestamp = user.lastUpdateTimestamp; }  /** * @dev updates the lending pool core configuration **/ function refreshConfiguration() external onlyLendingPoolConfigurator {     refreshConfigInternal(); }  /** * @dev initializes a reserve * @param _reserve the address of the reserve * @param _aTokenAddress the address of the overlying aToken contract * @param _decimals the decimals of the reserve currency * @param _interestRateStrategyAddress the address of the interest rate strategy contract **/ function initReserve(     address _reserve,     address _aTokenAddress,     uint256 _decimals,     address _interestRateStrategyAddress ) external onlyLendingPoolConfigurator {     reserves[_reserve].init(_aTokenAddress, _decimals, _interestRateStrategyAddress);     addReserveToListInternal(_reserve);  }    /** * @dev removes the last added reserve in the reservesList array * @param _reserveToRemove the address of the reserve **/ function removeLastAddedReserve(address _reserveToRemove) external onlyLendingPoolConfigurator {      address lastReserve = reservesList[reservesList.length-1];      require(lastReserve == _reserveToRemove, "Reserve being removed is different than the reserve requested");      //as we can't check if totalLiquidity is 0 (since the reserve added might not be an ERC20) we at least check that there is nothing borrowed     require(getReserveTotalBorrows(lastReserve) == 0, "Cannot remove a reserve with liquidity deposited");      reserves[lastReserve].isActive = false;     reserves[lastReserve].aTokenAddress = address(0);     reserves[lastReserve].decimals = 0;     reserves[lastReserve].lastLiquidityCumulativeIndex = 0;     reserves[lastReserve].lastVariableBorrowCumulativeIndex = 0;     reserves[lastReserve].borrowingEnabled = false;     reserves[lastReserve].usageAsCollateralEnabled = false;     reserves[lastReserve].baseLTVasCollateral = 0;     reserves[lastReserve].liquidationThreshold = 0;     reserves[lastReserve].liquidationBonus = 0;     reserves[lastReserve].interestRateStrategyAddress = address(0);      reservesList.pop(); }  /** * @dev updates the address of the interest rate strategy contract * @param _reserve the address of the reserve * @param _rateStrategyAddress the address of the interest rate strategy contract **/  function setReserveInterestRateStrategyAddress(address _reserve, address _rateStrategyAddress) external onlyLendingPoolConfigurator {     reserves[_reserve].interestRateStrategyAddress = _rateStrategyAddress; }  /** * @dev enables borrowing on a reserve. Also sets the stable rate borrowing * @param _reserve the address of the reserve * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise **/  function enableBorrowingOnReserve(address _reserve, bool _stableBorrowRateEnabled) external onlyLendingPoolConfigurator {     reserves[_reserve].enableBorrowing(_stableBorrowRateEnabled); }  /** * @dev disables borrowing on a reserve * @param _reserve the address of the reserve **/  function disableBorrowingOnReserve(address _reserve) external onlyLendingPoolConfigurator {     reserves[_reserve].disableBorrowing(); }  /** * @dev enables a reserve to be used as collateral * @param _reserve the address of the reserve **/ function enableReserveAsCollateral(     address _reserve,     uint256 _baseLTVasCollateral,     uint256 _liquidationThreshold,     uint256 _liquidationBonus ) external onlyLendingPoolConfigurator {     reserves[_reserve].enableAsCollateral(         _baseLTVasCollateral,         _liquidationThreshold,         _liquidationBonus     ); }  /** * @dev disables a reserve to be used as collateral * @param _reserve the address of the reserve **/ function disableReserveAsCollateral(address _reserve) external onlyLendingPoolConfigurator {     reserves[_reserve].disableAsCollateral(); }  /** * @dev enable the stable borrow rate mode on a reserve * @param _reserve the address of the reserve **/ function enableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isStableBorrowRateEnabled = true; }  /** * @dev disable the stable borrow rate mode on a reserve * @param _reserve the address of the reserve **/ function disableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isStableBorrowRateEnabled = false; }  /** * @dev activates a reserve * @param _reserve the address of the reserve **/ function activateReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      require(         reserve.lastLiquidityCumulativeIndex &gt; 0 &amp;&amp;         reserve.lastVariableBorrowCumulativeIndex &gt; 0,         "Reserve has not been initialized yet"     );     reserve.isActive = true; }  /** * @dev deactivates a reserve * @param _reserve the address of the reserve **/ function deactivateReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isActive = false; }  /** * @notice allows the configurator to freeze the reserve. * A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance. * @param _reserve the address of the reserve **/ function freezeReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isFreezed = true; }  /** * @notice allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed. * @param _reserve the address of the reserve **/ function unfreezeReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isFreezed = false; }  /** * @notice allows the configurator to update the loan to value of a reserve * @param _reserve the address of the reserve * @param _ltv the new loan to value **/ function setReserveBaseLTVasCollateral(address _reserve, uint256 _ltv) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.baseLTVasCollateral = _ltv; }  /** * @notice allows the configurator to update the liquidation threshold of a reserve * @param _reserve the address of the reserve * @param _threshold the new liquidation threshold **/ function setReserveLiquidationThreshold(address _reserve, uint256 _threshold) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.liquidationThreshold = _threshold; }  /** * @notice allows the configurator to update the liquidation bonus of a reserve * @param _reserve the address of the reserve * @param _bonus the new liquidation bonus **/ function setReserveLiquidationBonus(address _reserve, uint256 _bonus) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.liquidationBonus = _bonus; }  /** * @notice allows the configurator to update the reserve decimals * @param _reserve the address of the reserve * @param _decimals the decimals of the reserve **/ function setReserveDecimals(address _reserve, uint256 _decimals) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.decimals = _decimals; }  /** * @notice internal functions **/  /** * @dev updates the state of a reserve as a consequence of a borrow action. * @param _reserve the address of the reserve on which the user is borrowing * @param _user the address of the borrower * @param _principalBorrowBalance the previous borrow balance of the borrower before the action * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount * @param _amountBorrowed the new amount borrowed * @param _rateMode the borrow rate mode (stable, variable) **/  function updateReserveStateOnBorrowInternal(     address _reserve,     address _user,     uint256 _principalBorrowBalance,     uint256 _balanceIncrease,     uint256 _amountBorrowed,     CoreLibrary.InterestRateMode _rateMode ) internal {     reserves[_reserve].updateCumulativeIndexes();      //increasing reserve total borrows to account for the new borrow balance of the user     //NOTE: Depending on the previous borrow mode, the borrows might need to be switched from variable to stable or vice versa      updateReserveTotalBorrowsByRateModeInternal(         _reserve,         _user,         _principalBorrowBalance,         _balanceIncrease,         _amountBorrowed,         _rateMode     ); }  /** * @dev updates the state of a user as a consequence of a borrow action. * @param _reserve the address of the reserve on which the user is borrowing * @param _user the address of the borrower * @param _amountBorrowed the amount borrowed * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount * @param _rateMode the borrow rate mode (stable, variable) * @return the final borrow rate for the user. Emitted by the borrow() event **/  function updateUserStateOnBorrowInternal(     address _reserve,     address _user,     uint256 _amountBorrowed,     uint256 _balanceIncrease,     uint256 _fee,     CoreLibrary.InterestRateMode _rateMode ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      if (_rateMode == CoreLibrary.InterestRateMode.STABLE) {         //stable         //reset the user variable index, and update the stable rate         user.stableBorrowRate = reserve.currentStableBorrowRate;         user.lastVariableBorrowCumulativeIndex = 0;     } else if (_rateMode == CoreLibrary.InterestRateMode.VARIABLE) {         //variable         //reset the user stable rate, and store the new borrow index         user.stableBorrowRate = 0;         user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;     } else {         revert("Invalid borrow rate mode");     }     //increase the principal borrows and the origination fee     user.principalBorrowBalance = user.principalBorrowBalance.add(_amountBorrowed).add(         _balanceIncrease     );     user.originationFee = user.originationFee.add(_fee);      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp);  }  /** * @dev updates the state of the reserve as a consequence of a repay action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _paybackAmountMinusFees the amount being paid back minus fees * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updateReserveStateOnRepayInternal(     address _reserve,     address _user,     uint256 _paybackAmountMinusFees,     uint256 _balanceIncrease ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_reserve][_user];      CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(_reserve, _user);      //update the indexes     reserves[_reserve].updateCumulativeIndexes();      //compound the cumulated interest to the borrow balance and then subtracting the payback amount     if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             _balanceIncrease,             user.stableBorrowRate         );         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _paybackAmountMinusFees,             user.stableBorrowRate         );     } else {         reserve.increaseTotalBorrowsVariable(_balanceIncrease);         reserve.decreaseTotalBorrowsVariable(_paybackAmountMinusFees);     } }  /** * @dev updates the state of the user as a consequence of a repay action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _paybackAmountMinusFees the amount being paid back minus fees * @param _originationFeeRepaid the fee on the amount that is being repaid * @param _balanceIncrease the accrued interest on the borrowed amount * @param _repaidWholeLoan true if the user is repaying the whole loan **/ function updateUserStateOnRepayInternal(     address _reserve,     address _user,     uint256 _paybackAmountMinusFees,     uint256 _originationFeeRepaid,     uint256 _balanceIncrease,     bool _repaidWholeLoan ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      //update the user principal borrow balance, adding the cumulated interest and then subtracting the payback amount     user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(         _paybackAmountMinusFees     );     user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;      //if the balance decrease is equal to the previous principal (user is repaying the whole loan)     //and the rate mode is stable, we reset the interest rate mode of the user     if (_repaidWholeLoan) {         user.stableBorrowRate = 0;         user.lastVariableBorrowCumulativeIndex = 0;     }     user.originationFee = user.originationFee.sub(_originationFeeRepaid);      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp);  }  /** * @dev updates the state of the user as a consequence of a swap rate action. * @param _reserve the address of the reserve on which the user is performing the rate swap * @param _user the address of the borrower * @param _principalBorrowBalance the the principal amount borrowed by the user * @param _compoundedBorrowBalance the principal amount plus the accrued interest * @param _currentRateMode the rate mode at which the user borrowed **/ function updateReserveStateOnSwapRateInternal(     address _reserve,     address _user,     uint256 _principalBorrowBalance,     uint256 _compoundedBorrowBalance,     CoreLibrary.InterestRateMode _currentRateMode ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      //compounding reserve indexes     reserve.updateCumulativeIndexes();      if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {         uint256 userCurrentStableRate = user.stableBorrowRate;          //swap to variable         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _principalBorrowBalance,             userCurrentStableRate         ); //decreasing stable from old principal balance         reserve.increaseTotalBorrowsVariable(_compoundedBorrowBalance); //increase variable borrows     } else if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         //swap to stable         uint256 currentStableRate = reserve.currentStableBorrowRate;         reserve.decreaseTotalBorrowsVariable(_principalBorrowBalance);         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             _compoundedBorrowBalance,             currentStableRate         );      } else {         revert("Invalid rate mode received");     } }  /** * @dev updates the state of the user as a consequence of a swap rate action. * @param _reserve the address of the reserve on which the user is performing the swap * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount * @param _currentRateMode the current rate mode of the user **/  function updateUserStateOnSwapRateInternal(     address _reserve,     address _user,     uint256 _balanceIncrease,     CoreLibrary.InterestRateMode _currentRateMode ) internal returns (CoreLibrary.InterestRateMode) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      CoreLibrary.InterestRateMode newMode = CoreLibrary.InterestRateMode.NONE;      if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         //switch to stable         newMode = CoreLibrary.InterestRateMode.STABLE;         user.stableBorrowRate = reserve.currentStableBorrowRate;         user.lastVariableBorrowCumulativeIndex = 0;     } else if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {         newMode = CoreLibrary.InterestRateMode.VARIABLE;         user.stableBorrowRate = 0;         user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;     } else {         revert("Invalid interest rate mode received");     }     //compounding cumulated interest     user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);     //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp);      return newMode; }  /** * @dev updates the state of the principal reserve as a consequence of a liquidation action. * @param _principalReserve the address of the principal reserve that is being repaid * @param _user the address of the borrower * @param _amountToLiquidate the amount being repaid by the liquidator * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updatePrincipalReserveStateOnLiquidationInternal(     address _principalReserve,     address _user,     uint256 _amountToLiquidate,     uint256 _balanceIncrease ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_principalReserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_principalReserve];      //update principal reserve data     reserve.updateCumulativeIndexes();      CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(         _principalReserve,         _user     );      if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {         //increase the total borrows by the compounded interest         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             _balanceIncrease,             user.stableBorrowRate         );          //decrease by the actual amount to liquidate         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _amountToLiquidate,             user.stableBorrowRate         );      } else {         //increase the total borrows by the compounded interest         reserve.increaseTotalBorrowsVariable(_balanceIncrease);          //decrease by the actual amount to liquidate         reserve.decreaseTotalBorrowsVariable(_amountToLiquidate);     }  }  /** * @dev updates the state of the collateral reserve as a consequence of a liquidation action. * @param _collateralReserve the address of the collateral reserve that is being liquidated **/ function updateCollateralReserveStateOnLiquidationInternal(     address _collateralReserve ) internal {     //update collateral reserve     reserves[_collateralReserve].updateCumulativeIndexes();  }  /** * @dev updates the state of the user being liquidated as a consequence of a liquidation action. * @param _reserve the address of the principal reserve that is being repaid * @param _user the address of the borrower * @param _amountToLiquidate the amount being repaid by the liquidator * @param _feeLiquidated the amount of origination fee being liquidated * @param _balanceIncrease the accrued interest on the borrowed amount **/ function updateUserStateOnLiquidationInternal(     address _reserve,     address _user,     uint256 _amountToLiquidate,     uint256 _feeLiquidated,     uint256 _balanceIncrease ) internal {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     //first increase by the compounded interest, then decrease by the liquidated amount     user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(         _amountToLiquidate     );      if (         getUserCurrentBorrowRateMode(_reserve, _user) == CoreLibrary.InterestRateMode.VARIABLE     ) {         user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;     }      if(_feeLiquidated &gt; 0){         user.originationFee = user.originationFee.sub(_feeLiquidated);     }      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp); }  /** * @dev updates the state of the reserve as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updateReserveStateOnRebalanceInternal(     address _reserve,     address _user,     uint256 _balanceIncrease ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      reserve.updateCumulativeIndexes();      reserve.increaseTotalBorrowsStableAndUpdateAverageRate(         _balanceIncrease,         user.stableBorrowRate     );  }  /** * @dev updates the state of the user as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updateUserStateOnRebalanceInternal(     address _reserve,     address _user,     uint256 _balanceIncrease ) internal {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);     user.stableBorrowRate = reserve.currentStableBorrowRate;      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp); }  /** * @dev updates the state of the user as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount * @param _amountBorrowed the accrued interest on the borrowed amount **/ function updateReserveTotalBorrowsByRateModeInternal(     address _reserve,     address _user,     uint256 _principalBalance,     uint256 _balanceIncrease,     uint256 _amountBorrowed,     CoreLibrary.InterestRateMode _newBorrowRateMode ) internal {     CoreLibrary.InterestRateMode previousRateMode = getUserCurrentBorrowRateMode(         _reserve,         _user     );     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      if (previousRateMode == CoreLibrary.InterestRateMode.STABLE) {         CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _principalBalance,             user.stableBorrowRate         );     } else if (previousRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         reserve.decreaseTotalBorrowsVariable(_principalBalance);     }      uint256 newPrincipalAmount = _principalBalance.add(_balanceIncrease).add(_amountBorrowed);     if (_newBorrowRateMode == CoreLibrary.InterestRateMode.STABLE) {         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             newPrincipalAmount,             reserve.currentStableBorrowRate         );     } else if (_newBorrowRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         reserve.increaseTotalBorrowsVariable(newPrincipalAmount);     } else {         revert("Invalid new borrow rate mode");     } }  /** * @dev Updates the reserve current stable borrow rate Rf, the current variable borrow rate Rv and the current liquidity rate Rl. * Also updates the lastUpdateTimestamp value. Please refer to the whitepaper for further information. * @param _reserve the address of the reserve to be updated * @param _liquidityAdded the amount of liquidity added to the protocol (deposit or repay) in the previous action * @param _liquidityTaken the amount of liquidity taken from the protocol (redeem or borrow) **/  function updateReserveInterestRatesAndTimestampInternal(     address _reserve,     uint256 _liquidityAdded,     uint256 _liquidityTaken ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     (uint256 newLiquidityRate, uint256 newStableRate, uint256 newVariableRate) = IReserveInterestRateStrategy(         reserve         .interestRateStrategyAddress     )     .calculateInterestRates(         _reserve,         getReserveAvailableLiquidity(_reserve).add(_liquidityAdded).sub(_liquidityTaken),         reserve.totalBorrowsStable,         reserve.totalBorrowsVariable,         reserve.currentAverageStableBorrowRate     );      reserve.currentLiquidityRate = newLiquidityRate;     reserve.currentStableBorrowRate = newStableRate;     reserve.currentVariableBorrowRate = newVariableRate;      //solium-disable-next-line     reserve.lastUpdateTimestamp = uint40(block.timestamp);      emit ReserveUpdated(         _reserve,         newLiquidityRate,         newStableRate,         newVariableRate,         reserve.lastLiquidityCumulativeIndex,         reserve.lastVariableBorrowCumulativeIndex     ); }  /** * @dev transfers to the protocol fees of a flashloan to the fees collection address * @param _token the address of the token being transferred * @param _amount the amount being transferred **/  function transferFlashLoanProtocolFeeInternal(address _token, uint256 _amount) internal {     address payable receiver = address(uint160(addressesProvider.getTokenDistributor()));      if (_token != EthAddressLib.ethAddress()) {         ERC20(_token).safeTransfer(receiver, _amount);     } else {         receiver.transfer(_amount);     } }  /** * @dev updates the internal configuration of the core **/ function refreshConfigInternal() internal {     lendingPoolAddress = addressesProvider.getLendingPool(); }  /** * @dev adds a reserve to the array of the reserves address **/ function addReserveToListInternal(address _reserve) internal {     bool reserveAlreadyAdded = false;     for (uint256 i = 0; i &lt; reservesList.length; i++)         if (reservesList[i] == _reserve) {             reserveAlreadyAdded = true;         }     if (!reserveAlreadyAdded) reservesList.push(_reserve); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 04:31:30 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | pragma solidity ^0.5.0; import "openzeppelin-solidity/contracts/math/SafeMath.sol"; import "openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol"; import "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol"; import "openzeppelin-solidity/contracts/utils/Address.sol"; import "../libraries/openzeppelin-upgradeability/VersionedInitializable.sol"; import "../libraries/CoreLibrary.sol"; import "../configuration/LendingPoolAddressesProvider.sol"; import "../interfaces/ILendingRateOracle.sol"; import "../interfaces/IReserveInterestRateStrategy.sol"; import "../libraries/WadRayMath.sol"; import "../tokenization/AToken.sol"; import "../libraries/EthAddressLib.sol"; / * @title LendingPoolCore contract * @author Aave * @notice Holds the state of the lending pool and all the funds deposited * @dev NOTE: The core does not enforce security checks on the update of the state * (eg, updateStateOnBorrow() does not enforce that borrowed is enabled on the reserve). * The check that an action can be performed is a duty of the overlying LendingPool contract. / contract LendingPoolCore is VersionedInitializable {     using SafeMath for uint256;     using WadRayMath for uint256;     using CoreLibrary for CoreLibrary.ReserveData;     using CoreLibrary for CoreLibrary.UserReserveData;     using SafeERC20 for ERC20;     using Address for address payable; /** * @dev Emitted when the state of a reserve is updated * @param reserve the address of the reserve * @param liquidityRate the new liquidity rate * @param stableBorrowRate the new stable borrow rate * @param variableBorrowRate the new variable borrow rate * @param liquidityIndex the new liquidity index * @param variableBorrowIndex the new variable borrow index **/ event ReserveUpdated(     address indexed reserve,     uint256 liquidityRate,     uint256 stableBorrowRate,     uint256 variableBorrowRate,     uint256 liquidityIndex,     uint256 variableBorrowIndex );  address public lendingPoolAddress;  LendingPoolAddressesProvider public addressesProvider;  /** * @dev only lending pools can use functions affected by this modifier **/ modifier onlyLendingPool {     require(lendingPoolAddress == msg.sender, "The caller must be a lending pool contract");     _; }  /** * @dev only lending pools configurator can use functions affected by this modifier **/ modifier onlyLendingPoolConfigurator {     require(         addressesProvider.getLendingPoolConfigurator() == msg.sender,         "The caller must be a lending pool configurator contract"     );     _; }  mapping(address =&gt; CoreLibrary.ReserveData) internal reserves; mapping(address =&gt; mapping(address =&gt; CoreLibrary.UserReserveData)) internal usersReserveData;  address[] public reservesList;  uint256 public constant CORE_REVISION = 0x4;  /** * @dev returns the revision number of the contract **/ function getRevision() internal pure returns (uint256) {     return CORE_REVISION; }  /** * @dev initializes the Core contract, invoked upon registration on the AddressesProvider * @param _addressesProvider the addressesProvider contract **/  function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {     addressesProvider = _addressesProvider;     refreshConfigInternal(); }  /** * @dev updates the state of the core as a result of a deposit action * @param _reserve the address of the reserve in which the deposit is happening * @param _user the address of the the user depositing * @param _amount the amount being deposited * @param _isFirstDeposit true if the user is depositing for the first time **/  function updateStateOnDeposit(     address _reserve,     address _user,     uint256 _amount,     bool _isFirstDeposit ) external onlyLendingPool {     reserves[_reserve].updateCumulativeIndexes();     updateReserveInterestRatesAndTimestampInternal(_reserve, _amount, 0);      if (_isFirstDeposit) {         //if this is the first deposit of the user, we configure the deposit as enabled to be used as collateral         setUserUseReserveAsCollateral(_reserve, _user, true);     } }  /** * @dev updates the state of the core as a result of a redeem action * @param _reserve the address of the reserve in which the redeem is happening * @param _user the address of the the user redeeming * @param _amountRedeemed the amount being redeemed * @param _userRedeemedEverything true if the user is redeeming everything **/ function updateStateOnRedeem(     address _reserve,     address _user,     uint256 _amountRedeemed,     bool _userRedeemedEverything ) external onlyLendingPool {     //compound liquidity and variable borrow interests     reserves[_reserve].updateCumulativeIndexes();     updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountRedeemed);      //if user redeemed everything the useReserveAsCollateral flag is reset     if (_userRedeemedEverything) {         setUserUseReserveAsCollateral(_reserve, _user, false);     } }  /** * @dev updates the state of the core as a result of a flashloan action * @param _reserve the address of the reserve in which the flashloan is happening * @param _income the income of the protocol as a result of the action **/ function updateStateOnFlashLoan(     address _reserve,     uint256 _availableLiquidityBefore,     uint256 _income,     uint256 _protocolFee ) external onlyLendingPool {     transferFlashLoanProtocolFeeInternal(_reserve, _protocolFee);      //compounding the cumulated interest     reserves[_reserve].updateCumulativeIndexes();      uint256 totalLiquidityBefore = _availableLiquidityBefore.add(         getReserveTotalBorrows(_reserve)     );      //compounding the received fee into the reserve     reserves[_reserve].cumulateToLiquidityIndex(totalLiquidityBefore, _income);      //refresh interest rates     updateReserveInterestRatesAndTimestampInternal(_reserve, _income, 0); }  /** * @dev updates the state of the core as a consequence of a borrow action. * @param _reserve the address of the reserve on which the user is borrowing * @param _user the address of the borrower * @param _amountBorrowed the new amount borrowed * @param _borrowFee the fee on the amount borrowed * @param _rateMode the borrow rate mode (stable, variable) * @return the new borrow rate for the user **/ function updateStateOnBorrow(     address _reserve,     address _user,     uint256 _amountBorrowed,     uint256 _borrowFee,     CoreLibrary.InterestRateMode _rateMode ) external onlyLendingPool returns (uint256, uint256) {     // getting the previous borrow data of the user     (uint256 principalBorrowBalance, , uint256 balanceIncrease) = getUserBorrowBalances(         _reserve,         _user     );      updateReserveStateOnBorrowInternal(         _reserve,         _user,         principalBorrowBalance,         balanceIncrease,         _amountBorrowed,         _rateMode     );      updateUserStateOnBorrowInternal(         _reserve,         _user,         _amountBorrowed,         balanceIncrease,         _borrowFee,         _rateMode     );      updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountBorrowed);      return (getUserCurrentBorrowRate(_reserve, _user), balanceIncrease); }  /** * @dev updates the state of the core as a consequence of a repay action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _paybackAmountMinusFees the amount being paid back minus fees * @param _originationFeeRepaid the fee on the amount that is being repaid * @param _balanceIncrease the accrued interest on the borrowed amount * @param _repaidWholeLoan true if the user is repaying the whole loan **/  function updateStateOnRepay(     address _reserve,     address _user,     uint256 _paybackAmountMinusFees,     uint256 _originationFeeRepaid,     uint256 _balanceIncrease,     bool _repaidWholeLoan ) external onlyLendingPool {     updateReserveStateOnRepayInternal(         _reserve,         _user,         _paybackAmountMinusFees,         _balanceIncrease     );     updateUserStateOnRepayInternal(         _reserve,         _user,         _paybackAmountMinusFees,         _originationFeeRepaid,         _balanceIncrease,         _repaidWholeLoan     );      updateReserveInterestRatesAndTimestampInternal(_reserve, _paybackAmountMinusFees, 0); }  /** * @dev updates the state of the core as a consequence of a swap rate action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _principalBorrowBalance the amount borrowed by the user * @param _compoundedBorrowBalance the amount borrowed plus accrued interest * @param _balanceIncrease the accrued interest on the borrowed amount * @param _currentRateMode the current interest rate mode for the user **/ function updateStateOnSwapRate(     address _reserve,     address _user,     uint256 _principalBorrowBalance,     uint256 _compoundedBorrowBalance,     uint256 _balanceIncrease,     CoreLibrary.InterestRateMode _currentRateMode ) external onlyLendingPool returns (CoreLibrary.InterestRateMode, uint256) {     updateReserveStateOnSwapRateInternal(         _reserve,         _user,         _principalBorrowBalance,         _compoundedBorrowBalance,         _currentRateMode     );      CoreLibrary.InterestRateMode newRateMode = updateUserStateOnSwapRateInternal(         _reserve,         _user,         _balanceIncrease,         _currentRateMode     );      updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);      return (newRateMode, getUserCurrentBorrowRate(_reserve, _user)); }  /** * @dev updates the state of the core as a consequence of a liquidation action. * @param _principalReserve the address of the principal reserve that is being repaid * @param _collateralReserve the address of the collateral reserve that is being liquidated * @param _user the address of the borrower * @param _amountToLiquidate the amount being repaid by the liquidator * @param _collateralToLiquidate the amount of collateral being liquidated * @param _feeLiquidated the amount of origination fee being liquidated * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus * @param _balanceIncrease the accrued interest on the borrowed amount * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise **/ function updateStateOnLiquidation(     address _principalReserve,     address _collateralReserve,     address _user,     uint256 _amountToLiquidate,     uint256 _collateralToLiquidate,     uint256 _feeLiquidated,     uint256 _liquidatedCollateralForFee,     uint256 _balanceIncrease,     bool _liquidatorReceivesAToken ) external onlyLendingPool {     updatePrincipalReserveStateOnLiquidationInternal(         _principalReserve,         _user,         _amountToLiquidate,         _balanceIncrease     );      updateCollateralReserveStateOnLiquidationInternal(         _collateralReserve     );      updateUserStateOnLiquidationInternal(         _principalReserve,         _user,         _amountToLiquidate,         _feeLiquidated,         _balanceIncrease     );      updateReserveInterestRatesAndTimestampInternal(_principalReserve, _amountToLiquidate, 0);      if (!_liquidatorReceivesAToken) {         updateReserveInterestRatesAndTimestampInternal(             _collateralReserve,             0,             _collateralToLiquidate.add(_liquidatedCollateralForFee)         );     }  }  /** * @dev updates the state of the core as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount * @return the new stable rate for the user **/ function updateStateOnRebalance(address _reserve, address _user, uint256 _balanceIncrease) external onlyLendingPool returns (uint256) {     updateReserveStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);      //update user data and rebalance the rate     updateUserStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);     updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);     return usersReserveData[_user][_reserve].stableBorrowRate; }  /** * @dev enables or disables a reserve as collateral * @param _reserve the address of the principal reserve where the user deposited * @param _user the address of the depositor * @param _useAsCollateral true if the depositor wants to use the reserve as collateral **/ function setUserUseReserveAsCollateral(address _reserve, address _user, bool _useAsCollateral) public onlyLendingPool {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     user.useAsCollateral = _useAsCollateral; }  /** * @notice ETH/token transfer functions **/  /** * @dev fallback function enforces that the caller is a contract, to support flashloan transfers **/ function() external payable {     //only contracts can send ETH to the core     require(msg.sender.isContract(), "Only contracts can send ether to the Lending pool core");  }  /** * @dev transfers to the user a specific amount from the reserve. * @param _reserve the address of the reserve where the transfer is happening * @param _user the address of the user receiving the transfer * @param _amount the amount being transferred **/ function transferToUser(address _reserve, address payable _user, uint256 _amount) external onlyLendingPool {     if (_reserve != EthAddressLib.ethAddress()) {         ERC20(_reserve).safeTransfer(_user, _amount);     } else {         //solium-disable-next-line         (bool result, ) = _user.call.value(_amount).gas(50000)("");         require(result, "Transfer of ETH failed");     } }  /** * @dev transfers the protocol fees to the fees collection address * @param _token the address of the token being transferred * @param _user the address of the user from where the transfer is happening * @param _amount the amount being transferred * @param _destination the fee receiver address **/  function transferToFeeCollectionAddress(     address _token,     address _user,     uint256 _amount,     address _destination ) external payable onlyLendingPool {     address payable feeAddress = address(uint160(_destination)); //cast the address to payable      if (_token != EthAddressLib.ethAddress()) {         require(             msg.value == 0,             "User is sending ETH along with the ERC20 transfer. Check the value attribute of the transaction"         );         ERC20(_token).safeTransferFrom(_user, feeAddress, _amount);     } else {         require(msg.value &gt;= _amount, "The amount and the value sent to deposit do not match");         //solium-disable-next-line         (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");         require(result, "Transfer of ETH failed");     } }  /** * @dev transfers the fees to the fees collection address in the case of liquidation * @param _token the address of the token being transferred * @param _amount the amount being transferred * @param _destination the fee receiver address **/ function liquidateFee(     address _token,     uint256 _amount,     address _destination ) external payable onlyLendingPool {     address payable feeAddress = address(uint160(_destination)); //cast the address to payable     require(         msg.value == 0,         "Fee liquidation does not require any transfer of value"     );      if (_token != EthAddressLib.ethAddress()) {         ERC20(_token).safeTransfer(feeAddress, _amount);     } else {         //solium-disable-next-line         (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");         require(result, "Transfer of ETH failed");     } }  /** * @dev transfers an amount from a user to the destination reserve * @param _reserve the address of the reserve where the amount is being transferred * @param _user the address of the user from where the transfer is happening * @param _amount the amount being transferred **/ function transferToReserve(address _reserve, address payable _user, uint256 _amount) external payable onlyLendingPool {     if (_reserve != EthAddressLib.ethAddress()) {         require(msg.value == 0, "User is sending ETH along with the ERC20 transfer.");         ERC20(_reserve).safeTransferFrom(_user, address(this), _amount);      } else {         require(msg.value &gt;= _amount, "The amount and the value sent to deposit do not match");          if (msg.value &gt; _amount) {             //send back excess ETH             uint256 excessAmount = msg.value.sub(_amount);             //solium-disable-next-line             (bool result, ) = _user.call.value(excessAmount).gas(50000)("");             require(result, "Transfer of ETH failed");         }     } }  /** * @notice data access functions **/  /** * @dev returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral) * needed to calculate the global account data in the LendingPoolDataProvider * @param _reserve the address of the reserve * @param _user the address of the user * @return the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not **/ function getUserBasicReserveData(address _reserve, address _user) external view returns (uint256, uint256, uint256, bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      uint256 underlyingBalance = getUserUnderlyingAssetBalance(_reserve, _user);      if (user.principalBorrowBalance == 0) {         return (underlyingBalance, 0, 0, user.useAsCollateral);     }      return (     underlyingBalance,     user.getCompoundedBorrowBalance(reserve),     user.originationFee,     user.useAsCollateral     ); }  /** * @dev checks if a user is allowed to borrow at a stable rate * @param _reserve the reserve address * @param _user the user * @param _amount the amount the the user wants to borrow * @return true if the user is allowed to borrow at a stable rate, false otherwise **/  function isUserAllowedToBorrowAtStable(address _reserve, address _user, uint256 _amount) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      if (!reserve.isStableBorrowRateEnabled) return false;      return     !user.useAsCollateral ||     !reserve.usageAsCollateralEnabled ||     _amount &gt; getUserUnderlyingAssetBalance(_reserve, _user); }  /** * @dev gets the underlying asset balance of a user based on the corresponding aToken balance. * @param _reserve the reserve address * @param _user the user address * @return the underlying deposit balance of the user **/  function getUserUnderlyingAssetBalance(address _reserve, address _user) public view returns (uint256) {     AToken aToken = AToken(reserves[_reserve].aTokenAddress);     return aToken.balanceOf(_user);  }  /** * @dev gets the interest rate strategy contract address for the reserve * @param _reserve the reserve address * @return the address of the interest rate strategy contract **/ function getReserveInterestRateStrategyAddress(address _reserve) public view returns (address) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.interestRateStrategyAddress; }  /** * @dev gets the aToken contract address for the reserve * @param _reserve the reserve address * @return the address of the aToken contract **/  function getReserveATokenAddress(address _reserve) public view returns (address) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.aTokenAddress; }  /** * @dev gets the available liquidity in the reserve. The available liquidity is the balance of the core contract * @param _reserve the reserve address * @return the available liquidity **/ function getReserveAvailableLiquidity(address _reserve) public view returns (uint256) {     uint256 balance = 0;      if (_reserve == EthAddressLib.ethAddress()) {         balance = address(this).balance;     } else {         balance = IERC20(_reserve).balanceOf(address(this));     }     return balance; }  /** * @dev gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows * @param _reserve the reserve address * @return the total liquidity **/ function getReserveTotalLiquidity(address _reserve) public view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return getReserveAvailableLiquidity(_reserve).add(reserve.getTotalBorrows()); }  /** * @dev gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there * there has been 100% income. * @param _reserve the reserve address * @return the reserve normalized income **/ function getReserveNormalizedIncome(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.getNormalizedIncome(); }  /** * @dev gets the reserve total borrows * @param _reserve the reserve address * @return the total borrows (stable + variable) **/ function getReserveTotalBorrows(address _reserve) public view returns (uint256) {     return reserves[_reserve].getTotalBorrows(); }  /** * @dev gets the reserve total borrows stable * @param _reserve the reserve address * @return the total borrows stable **/ function getReserveTotalBorrowsStable(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.totalBorrowsStable; }  /** * @dev gets the reserve total borrows variable * @param _reserve the reserve address * @return the total borrows variable **/  function getReserveTotalBorrowsVariable(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.totalBorrowsVariable; }  /** * @dev gets the reserve liquidation threshold * @param _reserve the reserve address * @return the reserve liquidation threshold **/  function getReserveLiquidationThreshold(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.liquidationThreshold; }  /** * @dev gets the reserve liquidation bonus * @param _reserve the reserve address * @return the reserve liquidation bonus **/  function getReserveLiquidationBonus(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.liquidationBonus; }  /** * @dev gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty * @param _reserve the reserve address * @return the reserve current variable borrow rate **/  function getReserveCurrentVariableBorrowRate(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      if (reserve.currentVariableBorrowRate == 0) {         return         IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)         .getBaseVariableBorrowRate();     }     return reserve.currentVariableBorrowRate; }  /** * @dev gets the reserve current stable borrow rate. Is the market rate if the reserve is empty * @param _reserve the reserve address * @return the reserve current stable borrow rate **/  function getReserveCurrentStableBorrowRate(address _reserve) public view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     ILendingRateOracle oracle = ILendingRateOracle(addressesProvider.getLendingRateOracle());      if (reserve.currentStableBorrowRate == 0) {         //no stable rate borrows yet         return oracle.getMarketBorrowRate(_reserve);     }      return reserve.currentStableBorrowRate; }  /** * @dev gets the reserve average stable borrow rate. The average stable rate is the weighted average * of all the loans taken at stable rate. * @param _reserve the reserve address * @return the reserve current average borrow rate **/ function getReserveCurrentAverageStableBorrowRate(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.currentAverageStableBorrowRate; }  /** * @dev gets the reserve liquidity rate * @param _reserve the reserve address * @return the reserve liquidity rate **/ function getReserveCurrentLiquidityRate(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.currentLiquidityRate; }  /** * @dev gets the reserve liquidity cumulative index * @param _reserve the reserve address * @return the reserve liquidity cumulative index **/ function getReserveLiquidityCumulativeIndex(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.lastLiquidityCumulativeIndex; }  /** * @dev gets the reserve variable borrow index * @param _reserve the reserve address * @return the reserve variable borrow index **/ function getReserveVariableBorrowsCumulativeIndex(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.lastVariableBorrowCumulativeIndex; }  /** * @dev this function aggregates the configuration parameters of the reserve. * It's used in the LendingPoolDataProvider specifically to save gas, and avoid * multiple external contract calls to fetch the same data. * @param _reserve the reserve address * @return the reserve decimals * @return the base ltv as collateral * @return the liquidation threshold * @return if the reserve is used as collateral or not **/ function getReserveConfiguration(address _reserve) external view returns (uint256, uint256, uint256, bool) {     uint256 decimals;     uint256 baseLTVasCollateral;     uint256 liquidationThreshold;     bool usageAsCollateralEnabled;      CoreLibrary.ReserveData storage reserve = reserves[_reserve];     decimals = reserve.decimals;     baseLTVasCollateral = reserve.baseLTVasCollateral;     liquidationThreshold = reserve.liquidationThreshold;     usageAsCollateralEnabled = reserve.usageAsCollateralEnabled;      return (decimals, baseLTVasCollateral, liquidationThreshold, usageAsCollateralEnabled); }  /** * @dev returns the decimals of the reserve * @param _reserve the reserve address * @return the reserve decimals **/ function getReserveDecimals(address _reserve) external view returns (uint256) {     return reserves[_reserve].decimals; }  /** * @dev returns true if the reserve is enabled for borrowing * @param _reserve the reserve address * @return true if the reserve is enabled for borrowing, false otherwise **/  function isReserveBorrowingEnabled(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.borrowingEnabled; }  /** * @dev returns true if the reserve is enabled as collateral * @param _reserve the reserve address * @return true if the reserve is enabled as collateral, false otherwise **/  function isReserveUsageAsCollateralEnabled(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.usageAsCollateralEnabled; }  /** * @dev returns true if the stable rate is enabled on reserve * @param _reserve the reserve address * @return true if the stable rate is enabled on reserve, false otherwise **/ function getReserveIsStableBorrowRateEnabled(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.isStableBorrowRateEnabled; }  /** * @dev returns true if the reserve is active * @param _reserve the reserve address * @return true if the reserve is active, false otherwise **/ function getReserveIsActive(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.isActive; }  /** * @notice returns if a reserve is freezed * @param _reserve the reserve for which the information is needed * @return true if the reserve is freezed, false otherwise **/  function getReserveIsFreezed(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.isFreezed; }  /** * @notice returns the timestamp of the last action on the reserve * @param _reserve the reserve for which the information is needed * @return the last updated timestamp of the reserve **/  function getReserveLastUpdate(address _reserve) external view returns (uint40 timestamp) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     timestamp = reserve.lastUpdateTimestamp; }  /** * @dev returns the utilization rate U of a specific reserve * @param _reserve the reserve for which the information is needed * @return the utilization rate in ray **/  function getReserveUtilizationRate(address _reserve) public view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      uint256 totalBorrows = reserve.getTotalBorrows();      if (totalBorrows == 0) {         return 0;     }      uint256 availableLiquidity = getReserveAvailableLiquidity(_reserve);      return totalBorrows.rayDiv(availableLiquidity.add(totalBorrows)); }  /** * @return the array of reserves configured on the core **/ function getReserves() external view returns (address[] memory) {     return reservesList; }  /** * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return true if the user has chosen to use the reserve as collateral, false otherwise **/ function isUserUseReserveAsCollateralEnabled(address _reserve, address _user) external view returns (bool) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.useAsCollateral; }  /** * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the origination fee for the user **/ function getUserOriginationFee(address _reserve, address _user) external view returns (uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.originationFee; }  /** * @dev users with no loans in progress have NONE as borrow rate mode * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the borrow rate mode for the user, **/  function getUserCurrentBorrowRateMode(address _reserve, address _user) public view returns (CoreLibrary.InterestRateMode) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      if (user.principalBorrowBalance == 0) {         return CoreLibrary.InterestRateMode.NONE;     }      return     user.stableBorrowRate &gt; 0     ? CoreLibrary.InterestRateMode.STABLE     : CoreLibrary.InterestRateMode.VARIABLE; }  /** * @dev gets the current borrow rate of the user * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the borrow rate for the user, **/ function getUserCurrentBorrowRate(address _reserve, address _user) internal view returns (uint256) {     CoreLibrary.InterestRateMode rateMode = getUserCurrentBorrowRateMode(_reserve, _user);      if (rateMode == CoreLibrary.InterestRateMode.NONE) {         return 0;     }      return     rateMode == CoreLibrary.InterestRateMode.STABLE     ? usersReserveData[_user][_reserve].stableBorrowRate     : reserves[_reserve].currentVariableBorrowRate; }  /** * @dev the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the user stable rate **/ function getUserCurrentStableBorrowRate(address _reserve, address _user) external view returns (uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.stableBorrowRate; }  /** * @dev calculates and returns the borrow balances of the user * @param _reserve the address of the reserve * @param _user the address of the user * @return the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance **/  function getUserBorrowBalances(address _reserve, address _user) public view returns (uint256, uint256, uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     if (user.principalBorrowBalance == 0) {         return (0, 0, 0);     }      uint256 principal = user.principalBorrowBalance;     uint256 compoundedBalance = CoreLibrary.getCompoundedBorrowBalance(         user,         reserves[_reserve]     );     return (principal, compoundedBalance, compoundedBalance.sub(principal)); }  /** * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the variable borrow index for the user **/  function getUserVariableBorrowCumulativeIndex(address _reserve, address _user) external view returns (uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.lastVariableBorrowCumulativeIndex; }  /** * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the variable borrow index for the user **/  function getUserLastUpdate(address _reserve, address _user) external view returns (uint256 timestamp) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     timestamp = user.lastUpdateTimestamp; }  /** * @dev updates the lending pool core configuration **/ function refreshConfiguration() external onlyLendingPoolConfigurator {     refreshConfigInternal(); }  /** * @dev initializes a reserve * @param _reserve the address of the reserve * @param _aTokenAddress the address of the overlying aToken contract * @param _decimals the decimals of the reserve currency * @param _interestRateStrategyAddress the address of the interest rate strategy contract **/ function initReserve(     address _reserve,     address _aTokenAddress,     uint256 _decimals,     address _interestRateStrategyAddress ) external onlyLendingPoolConfigurator {     reserves[_reserve].init(_aTokenAddress, _decimals, _interestRateStrategyAddress);     addReserveToListInternal(_reserve);  }    /** * @dev removes the last added reserve in the reservesList array * @param _reserveToRemove the address of the reserve **/ function removeLastAddedReserve(address _reserveToRemove) external onlyLendingPoolConfigurator {      address lastReserve = reservesList[reservesList.length-1];      require(lastReserve == _reserveToRemove, "Reserve being removed is different than the reserve requested");      //as we can't check if totalLiquidity is 0 (since the reserve added might not be an ERC20) we at least check that there is nothing borrowed     require(getReserveTotalBorrows(lastReserve) == 0, "Cannot remove a reserve with liquidity deposited");      reserves[lastReserve].isActive = false;     reserves[lastReserve].aTokenAddress = address(0);     reserves[lastReserve].decimals = 0;     reserves[lastReserve].lastLiquidityCumulativeIndex = 0;     reserves[lastReserve].lastVariableBorrowCumulativeIndex = 0;     reserves[lastReserve].borrowingEnabled = false;     reserves[lastReserve].usageAsCollateralEnabled = false;     reserves[lastReserve].baseLTVasCollateral = 0;     reserves[lastReserve].liquidationThreshold = 0;     reserves[lastReserve].liquidationBonus = 0;     reserves[lastReserve].interestRateStrategyAddress = address(0);      reservesList.pop(); }  /** * @dev updates the address of the interest rate strategy contract * @param _reserve the address of the reserve * @param _rateStrategyAddress the address of the interest rate strategy contract **/  function setReserveInterestRateStrategyAddress(address _reserve, address _rateStrategyAddress) external onlyLendingPoolConfigurator {     reserves[_reserve].interestRateStrategyAddress = _rateStrategyAddress; }  /** * @dev enables borrowing on a reserve. Also sets the stable rate borrowing * @param _reserve the address of the reserve * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise **/  function enableBorrowingOnReserve(address _reserve, bool _stableBorrowRateEnabled) external onlyLendingPoolConfigurator {     reserves[_reserve].enableBorrowing(_stableBorrowRateEnabled); }  /** * @dev disables borrowing on a reserve * @param _reserve the address of the reserve **/  function disableBorrowingOnReserve(address _reserve) external onlyLendingPoolConfigurator {     reserves[_reserve].disableBorrowing(); }  /** * @dev enables a reserve to be used as collateral * @param _reserve the address of the reserve **/ function enableReserveAsCollateral(     address _reserve,     uint256 _baseLTVasCollateral,     uint256 _liquidationThreshold,     uint256 _liquidationBonus ) external onlyLendingPoolConfigurator {     reserves[_reserve].enableAsCollateral(         _baseLTVasCollateral,         _liquidationThreshold,         _liquidationBonus     ); }  /** * @dev disables a reserve to be used as collateral * @param _reserve the address of the reserve **/ function disableReserveAsCollateral(address _reserve) external onlyLendingPoolConfigurator {     reserves[_reserve].disableAsCollateral(); }  /** * @dev enable the stable borrow rate mode on a reserve * @param _reserve the address of the reserve **/ function enableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isStableBorrowRateEnabled = true; }  /** * @dev disable the stable borrow rate mode on a reserve * @param _reserve the address of the reserve **/ function disableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isStableBorrowRateEnabled = false; }  /** * @dev activates a reserve * @param _reserve the address of the reserve **/ function activateReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      require(         reserve.lastLiquidityCumulativeIndex &gt; 0 &amp;&amp;         reserve.lastVariableBorrowCumulativeIndex &gt; 0,         "Reserve has not been initialized yet"     );     reserve.isActive = true; }  /** * @dev deactivates a reserve * @param _reserve the address of the reserve **/ function deactivateReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isActive = false; }  /** * @notice allows the configurator to freeze the reserve. * A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance. * @param _reserve the address of the reserve **/ function freezeReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isFreezed = true; }  /** * @notice allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed. * @param _reserve the address of the reserve **/ function unfreezeReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isFreezed = false; }  /** * @notice allows the configurator to update the loan to value of a reserve * @param _reserve the address of the reserve * @param _ltv the new loan to value **/ function setReserveBaseLTVasCollateral(address _reserve, uint256 _ltv) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.baseLTVasCollateral = _ltv; }  /** * @notice allows the configurator to update the liquidation threshold of a reserve * @param _reserve the address of the reserve * @param _threshold the new liquidation threshold **/ function setReserveLiquidationThreshold(address _reserve, uint256 _threshold) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.liquidationThreshold = _threshold; }  /** * @notice allows the configurator to update the liquidation bonus of a reserve * @param _reserve the address of the reserve * @param _bonus the new liquidation bonus **/ function setReserveLiquidationBonus(address _reserve, uint256 _bonus) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.liquidationBonus = _bonus; }  /** * @notice allows the configurator to update the reserve decimals * @param _reserve the address of the reserve * @param _decimals the decimals of the reserve **/ function setReserveDecimals(address _reserve, uint256 _decimals) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.decimals = _decimals; }  /** * @notice internal functions **/  /** * @dev updates the state of a reserve as a consequence of a borrow action. * @param _reserve the address of the reserve on which the user is borrowing * @param _user the address of the borrower * @param _principalBorrowBalance the previous borrow balance of the borrower before the action * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount * @param _amountBorrowed the new amount borrowed * @param _rateMode the borrow rate mode (stable, variable) **/  function updateReserveStateOnBorrowInternal(     address _reserve,     address _user,     uint256 _principalBorrowBalance,     uint256 _balanceIncrease,     uint256 _amountBorrowed,     CoreLibrary.InterestRateMode _rateMode ) internal {     reserves[_reserve].updateCumulativeIndexes();      //increasing reserve total borrows to account for the new borrow balance of the user     //NOTE: Depending on the previous borrow mode, the borrows might need to be switched from variable to stable or vice versa      updateReserveTotalBorrowsByRateModeInternal(         _reserve,         _user,         _principalBorrowBalance,         _balanceIncrease,         _amountBorrowed,         _rateMode     ); }  /** * @dev updates the state of a user as a consequence of a borrow action. * @param _reserve the address of the reserve on which the user is borrowing * @param _user the address of the borrower * @param _amountBorrowed the amount borrowed * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount * @param _rateMode the borrow rate mode (stable, variable) * @return the final borrow rate for the user. Emitted by the borrow() event **/  function updateUserStateOnBorrowInternal(     address _reserve,     address _user,     uint256 _amountBorrowed,     uint256 _balanceIncrease,     uint256 _fee,     CoreLibrary.InterestRateMode _rateMode ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      if (_rateMode == CoreLibrary.InterestRateMode.STABLE) {         //stable         //reset the user variable index, and update the stable rate         user.stableBorrowRate = reserve.currentStableBorrowRate;         user.lastVariableBorrowCumulativeIndex = 0;     } else if (_rateMode == CoreLibrary.InterestRateMode.VARIABLE) {         //variable         //reset the user stable rate, and store the new borrow index         user.stableBorrowRate = 0;         user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;     } else {         revert("Invalid borrow rate mode");     }     //increase the principal borrows and the origination fee     user.principalBorrowBalance = user.principalBorrowBalance.add(_amountBorrowed).add(         _balanceIncrease     );     user.originationFee = user.originationFee.add(_fee);      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp);  }  /** * @dev updates the state of the reserve as a consequence of a repay action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _paybackAmountMinusFees the amount being paid back minus fees * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updateReserveStateOnRepayInternal(     address _reserve,     address _user,     uint256 _paybackAmountMinusFees,     uint256 _balanceIncrease ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_reserve][_user];      CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(_reserve, _user);      //update the indexes     reserves[_reserve].updateCumulativeIndexes();      //compound the cumulated interest to the borrow balance and then subtracting the payback amount     if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             _balanceIncrease,             user.stableBorrowRate         );         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _paybackAmountMinusFees,             user.stableBorrowRate         );     } else {         reserve.increaseTotalBorrowsVariable(_balanceIncrease);         reserve.decreaseTotalBorrowsVariable(_paybackAmountMinusFees);     } }  /** * @dev updates the state of the user as a consequence of a repay action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _paybackAmountMinusFees the amount being paid back minus fees * @param _originationFeeRepaid the fee on the amount that is being repaid * @param _balanceIncrease the accrued interest on the borrowed amount * @param _repaidWholeLoan true if the user is repaying the whole loan **/ function updateUserStateOnRepayInternal(     address _reserve,     address _user,     uint256 _paybackAmountMinusFees,     uint256 _originationFeeRepaid,     uint256 _balanceIncrease,     bool _repaidWholeLoan ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      //update the user principal borrow balance, adding the cumulated interest and then subtracting the payback amount     user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(         _paybackAmountMinusFees     );     user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;      //if the balance decrease is equal to the previous principal (user is repaying the whole loan)     //and the rate mode is stable, we reset the interest rate mode of the user     if (_repaidWholeLoan) {         user.stableBorrowRate = 0;         user.lastVariableBorrowCumulativeIndex = 0;     }     user.originationFee = user.originationFee.sub(_originationFeeRepaid);      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp);  }  /** * @dev updates the state of the user as a consequence of a swap rate action. * @param _reserve the address of the reserve on which the user is performing the rate swap * @param _user the address of the borrower * @param _principalBorrowBalance the the principal amount borrowed by the user * @param _compoundedBorrowBalance the principal amount plus the accrued interest * @param _currentRateMode the rate mode at which the user borrowed **/ function updateReserveStateOnSwapRateInternal(     address _reserve,     address _user,     uint256 _principalBorrowBalance,     uint256 _compoundedBorrowBalance,     CoreLibrary.InterestRateMode _currentRateMode ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      //compounding reserve indexes     reserve.updateCumulativeIndexes();      if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {         uint256 userCurrentStableRate = user.stableBorrowRate;          //swap to variable         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _principalBorrowBalance,             userCurrentStableRate         ); //decreasing stable from old principal balance         reserve.increaseTotalBorrowsVariable(_compoundedBorrowBalance); //increase variable borrows     } else if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         //swap to stable         uint256 currentStableRate = reserve.currentStableBorrowRate;         reserve.decreaseTotalBorrowsVariable(_principalBorrowBalance);         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             _compoundedBorrowBalance,             currentStableRate         );      } else {         revert("Invalid rate mode received");     } }  /** * @dev updates the state of the user as a consequence of a swap rate action. * @param _reserve the address of the reserve on which the user is performing the swap * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount * @param _currentRateMode the current rate mode of the user **/  function updateUserStateOnSwapRateInternal(     address _reserve,     address _user,     uint256 _balanceIncrease,     CoreLibrary.InterestRateMode _currentRateMode ) internal returns (CoreLibrary.InterestRateMode) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      CoreLibrary.InterestRateMode newMode = CoreLibrary.InterestRateMode.NONE;      if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         //switch to stable         newMode = CoreLibrary.InterestRateMode.STABLE;         user.stableBorrowRate = reserve.currentStableBorrowRate;         user.lastVariableBorrowCumulativeIndex = 0;     } else if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {         newMode = CoreLibrary.InterestRateMode.VARIABLE;         user.stableBorrowRate = 0;         user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;     } else {         revert("Invalid interest rate mode received");     }     //compounding cumulated interest     user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);     //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp);      return newMode; }  /** * @dev updates the state of the principal reserve as a consequence of a liquidation action. * @param _principalReserve the address of the principal reserve that is being repaid * @param _user the address of the borrower * @param _amountToLiquidate the amount being repaid by the liquidator * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updatePrincipalReserveStateOnLiquidationInternal(     address _principalReserve,     address _user,     uint256 _amountToLiquidate,     uint256 _balanceIncrease ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_principalReserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_principalReserve];      //update principal reserve data     reserve.updateCumulativeIndexes();      CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(         _principalReserve,         _user     );      if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {         //increase the total borrows by the compounded interest         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             _balanceIncrease,             user.stableBorrowRate         );          //decrease by the actual amount to liquidate         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _amountToLiquidate,             user.stableBorrowRate         );      } else {         //increase the total borrows by the compounded interest         reserve.increaseTotalBorrowsVariable(_balanceIncrease);          //decrease by the actual amount to liquidate         reserve.decreaseTotalBorrowsVariable(_amountToLiquidate);     }  }  /** * @dev updates the state of the collateral reserve as a consequence of a liquidation action. * @param _collateralReserve the address of the collateral reserve that is being liquidated **/ function updateCollateralReserveStateOnLiquidationInternal(     address _collateralReserve ) internal {     //update collateral reserve     reserves[_collateralReserve].updateCumulativeIndexes();  }  /** * @dev updates the state of the user being liquidated as a consequence of a liquidation action. * @param _reserve the address of the principal reserve that is being repaid * @param _user the address of the borrower * @param _amountToLiquidate the amount being repaid by the liquidator * @param _feeLiquidated the amount of origination fee being liquidated * @param _balanceIncrease the accrued interest on the borrowed amount **/ function updateUserStateOnLiquidationInternal(     address _reserve,     address _user,     uint256 _amountToLiquidate,     uint256 _feeLiquidated,     uint256 _balanceIncrease ) internal {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     //first increase by the compounded interest, then decrease by the liquidated amount     user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(         _amountToLiquidate     );      if (         getUserCurrentBorrowRateMode(_reserve, _user) == CoreLibrary.InterestRateMode.VARIABLE     ) {         user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;     }      if(_feeLiquidated &gt; 0){         user.originationFee = user.originationFee.sub(_feeLiquidated);     }      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp); }  /** * @dev updates the state of the reserve as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updateReserveStateOnRebalanceInternal(     address _reserve,     address _user,     uint256 _balanceIncrease ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      reserve.updateCumulativeIndexes();      reserve.increaseTotalBorrowsStableAndUpdateAverageRate(         _balanceIncrease,         user.stableBorrowRate     );  }  /** * @dev updates the state of the user as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updateUserStateOnRebalanceInternal(     address _reserve,     address _user,     uint256 _balanceIncrease ) internal {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);     user.stableBorrowRate = reserve.currentStableBorrowRate;      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp); }  /** * @dev updates the state of the user as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount * @param _amountBorrowed the accrued interest on the borrowed amount **/ function updateReserveTotalBorrowsByRateModeInternal(     address _reserve,     address _user,     uint256 _principalBalance,     uint256 _balanceIncrease,     uint256 _amountBorrowed,     CoreLibrary.InterestRateMode _newBorrowRateMode ) internal {     CoreLibrary.InterestRateMode previousRateMode = getUserCurrentBorrowRateMode(         _reserve,         _user     );     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      if (previousRateMode == CoreLibrary.InterestRateMode.STABLE) {         CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _principalBalance,             user.stableBorrowRate         );     } else if (previousRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         reserve.decreaseTotalBorrowsVariable(_principalBalance);     }      uint256 newPrincipalAmount = _principalBalance.add(_balanceIncrease).add(_amountBorrowed);     if (_newBorrowRateMode == CoreLibrary.InterestRateMode.STABLE) {         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             newPrincipalAmount,             reserve.currentStableBorrowRate         );     } else if (_newBorrowRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         reserve.increaseTotalBorrowsVariable(newPrincipalAmount);     } else {         revert("Invalid new borrow rate mode");     } }  /** * @dev Updates the reserve current stable borrow rate Rf, the current variable borrow rate Rv and the current liquidity rate Rl. * Also updates the lastUpdateTimestamp value. Please refer to the whitepaper for further information. * @param _reserve the address of the reserve to be updated * @param _liquidityAdded the amount of liquidity added to the protocol (deposit or repay) in the previous action * @param _liquidityTaken the amount of liquidity taken from the protocol (redeem or borrow) **/  function updateReserveInterestRatesAndTimestampInternal(     address _reserve,     uint256 _liquidityAdded,     uint256 _liquidityTaken ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     (uint256 newLiquidityRate, uint256 newStableRate, uint256 newVariableRate) = IReserveInterestRateStrategy(         reserve         .interestRateStrategyAddress     )     .calculateInterestRates(         _reserve,         getReserveAvailableLiquidity(_reserve).add(_liquidityAdded).sub(_liquidityTaken),         reserve.totalBorrowsStable,         reserve.totalBorrowsVariable,         reserve.currentAverageStableBorrowRate     );      reserve.currentLiquidityRate = newLiquidityRate;     reserve.currentStableBorrowRate = newStableRate;     reserve.currentVariableBorrowRate = newVariableRate;      //solium-disable-next-line     reserve.lastUpdateTimestamp = uint40(block.timestamp);      emit ReserveUpdated(         _reserve,         newLiquidityRate,         newStableRate,         newVariableRate,         reserve.lastLiquidityCumulativeIndex,         reserve.lastVariableBorrowCumulativeIndex     ); }  /** * @dev transfers to the protocol fees of a flashloan to the fees collection address * @param _token the address of the token being transferred * @param _amount the amount being transferred **/  function transferFlashLoanProtocolFeeInternal(address _token, uint256 _amount) internal {     address payable receiver = address(uint160(addressesProvider.getTokenDistributor()));      if (_token != EthAddressLib.ethAddress()) {         ERC20(_token).safeTransfer(receiver, _amount);     } else {         receiver.transfer(_amount);     } }  /** * @dev updates the internal configuration of the core **/ function refreshConfigInternal() internal {     lendingPoolAddress = addressesProvider.getLendingPool(); }  /** * @dev adds a reserve to the array of the reserves address **/ function addReserveToListInternal(address _reserve) internal {     bool reserveAlreadyAdded = false;     for (uint256 i = 0; i &lt; reservesList.length; i++)         if (reservesList[i] == _reserve) {             reserveAlreadyAdded = true;         }     if (!reserveAlreadyAdded) reservesList.push(_reserve); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 04:31:30 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: pragma solidity ^0.5.0;

import "openzeppelin-solidity/contracts/math/SafeMath.sol";
import "openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol";
import "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol";
import "openzeppelin-solidity/contracts/utils/Address.sol";
import "../libraries/openzeppelin-upgradeability/VersionedInitializable.sol";

import "../libraries/CoreLibrary.sol";
import "../configuration/LendingPoolAddressesProvider.sol";
import "../interfaces/ILendingRateOracle.sol";
import "../interfaces/IReserveInterestRateStrategy.sol";
import "../libraries/WadRayMath.sol";
import "../tokenization/AToken.sol";
import "../libraries/EthAddressLib.sol";

/**
* @title LendingPoolCore contract
* @author Aave
* @notice Holds the state of the lending pool and all the funds deposited
* @dev NOTE: The core does not enforce security checks on the update of the state
* (eg, updateStateOnBorrow() does not enforce that borrowed is enabled on the reserve).
* The check that an action can be performed is a duty of the overlying LendingPool contract.
**/

contract LendingPoolCore is VersionedInitializable {
    using SafeMath for uint256;
    using WadRayMath for uint256;
    using CoreLibrary for CoreLibrary.ReserveData;
    using CoreLibrary for CoreLibrary.UserReserveData;
    using SafeERC20 for ERC20;
    using Address for address payable;

    /**
    * @dev Emitted when the state of a reserve is updated
    * @param reserve the address of the reserve
    * @param liquidityRate the new liquidity rate
    * @param stableBorrowRate the new stable borrow rate
    * @param variableBorrowRate the new variable borrow rate
    * @param liquidityIndex the new liquidity index
    * @param variableBorrowIndex the new variable borrow index
    **/
    event ReserveUpdated(
        address indexed reserve,
        uint256 liquidityRate,
        uint256 stableBorrowRate,
        uint256 variableBorrowRate,
        uint256 liquidityIndex,
        uint256 variableBorrowIndex
    );

    address public lendingPoolAddress;

    LendingPoolAddressesProvider public addressesProvider;

    /**
    * @dev only lending pools can use functions affected by this modifier
    **/
    modifier onlyLendingPool {
        require(lendingPoolAddress == msg.sender, "The caller must be a lending pool contract");
        _;
    }

    /**
    * @dev only lending pools configurator can use functions affected by this modifier
    **/
    modifier onlyLendingPoolConfigurator {
        require(
            addressesProvider.getLendingPoolConfigurator() == msg.sender,
            "The caller must be a lending pool configurator contract"
        );
        _;
    }

    mapping(address => CoreLibrary.ReserveData) internal reserves;
    mapping(address => mapping(address => CoreLibrary.UserReserveData)) internal usersReserveData;

    address[] public reservesList;

    uint256 public constant CORE_REVISION = 0x4;

    /**
    * @dev returns the revision number of the contract
    **/
    function getRevision() internal pure returns (uint256) {
        return CORE_REVISION;
    }

    /**
    * @dev initializes the Core contract, invoked upon registration on the AddressesProvider
    * @param _addressesProvider the addressesProvider contract
    **/

    function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {
        addressesProvider = _addressesProvider;
        refreshConfigInternal();
    }

    /**
    * @dev updates the state of the core as a result of a deposit action
    * @param _reserve the address of the reserve in which the deposit is happening
    * @param _user the address of the the user depositing
    * @param _amount the amount being deposited
    * @param _isFirstDeposit true if the user is depositing for the first time
    **/

    function updateStateOnDeposit(
        address _reserve,
        address _user,
        uint256 _amount,
        bool _isFirstDeposit
    ) external onlyLendingPool {
        reserves[_reserve].updateCumulativeIndexes();
        updateReserveInterestRatesAndTimestampInternal(_reserve, _amount, 0);

        if (_isFirstDeposit) {
            //if this is the first deposit of the user, we configure the deposit as enabled to be used as collateral
            setUserUseReserveAsCollateral(_reserve, _user, true);
        }
    }

    /**
    * @dev updates the state of the core as a result of a redeem action
    * @param _reserve the address of the reserve in which the redeem is happening
    * @param _user the address of the the user redeeming
    * @param _amountRedeemed the amount being redeemed
    * @param _userRedeemedEverything true if the user is redeeming everything
    **/
    function updateStateOnRedeem(
        address _reserve,
        address _user,
        uint256 _amountRedeemed,
        bool _userRedeemedEverything
    ) external onlyLendingPool {
        //compound liquidity and variable borrow interests
        reserves[_reserve].updateCumulativeIndexes();
        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountRedeemed);

        //if user redeemed everything the useReserveAsCollateral flag is reset
        if (_userRedeemedEverything) {
            setUserUseReserveAsCollateral(_reserve, _user, false);
        }
    }

    /**
    * @dev updates the state of the core as a result of a flashloan action
    * @param _reserve the address of the reserve in which the flashloan is happening
    * @param _income the income of the protocol as a result of the action
    **/
    function updateStateOnFlashLoan(
        address _reserve,
        uint256 _availableLiquidityBefore,
        uint256 _income,
        uint256 _protocolFee
    ) external onlyLendingPool {
        transferFlashLoanProtocolFeeInternal(_reserve, _protocolFee);

        //compounding the cumulated interest
        reserves[_reserve].updateCumulativeIndexes();

        uint256 totalLiquidityBefore = _availableLiquidityBefore.add(
            getReserveTotalBorrows(_reserve)
        );

        //compounding the received fee into the reserve
        reserves[_reserve].cumulateToLiquidityIndex(totalLiquidityBefore, _income);

        //refresh interest rates
        updateReserveInterestRatesAndTimestampInternal(_reserve, _income, 0);
    }

    /**
    * @dev updates the state of the core as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _amountBorrowed the new amount borrowed
    * @param _borrowFee the fee on the amount borrowed
    * @param _rateMode the borrow rate mode (stable, variable)
    * @return the new borrow rate for the user
    **/
    function updateStateOnBorrow(
        address _reserve,
        address _user,
        uint256 _amountBorrowed,
        uint256 _borrowFee,
        CoreLibrary.InterestRateMode _rateMode
    ) external onlyLendingPool returns (uint256, uint256) {
        // getting the previous borrow data of the user
        (uint256 principalBorrowBalance, , uint256 balanceIncrease) = getUserBorrowBalances(
            _reserve,
            _user
        );

        updateReserveStateOnBorrowInternal(
            _reserve,
            _user,
            principalBorrowBalance,
            balanceIncrease,
            _amountBorrowed,
            _rateMode
        );

        updateUserStateOnBorrowInternal(
            _reserve,
            _user,
            _amountBorrowed,
            balanceIncrease,
            _borrowFee,
            _rateMode
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountBorrowed);

        return (getUserCurrentBorrowRate(_reserve, _user), balanceIncrease);
    }

    /**
    * @dev updates the state of the core as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _originationFeeRepaid the fee on the amount that is being repaid
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _repaidWholeLoan true if the user is repaying the whole loan
    **/

    function updateStateOnRepay(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _originationFeeRepaid,
        uint256 _balanceIncrease,
        bool _repaidWholeLoan
    ) external onlyLendingPool {
        updateReserveStateOnRepayInternal(
            _reserve,
            _user,
            _paybackAmountMinusFees,
            _balanceIncrease
        );
        updateUserStateOnRepayInternal(
            _reserve,
            _user,
            _paybackAmountMinusFees,
            _originationFeeRepaid,
            _balanceIncrease,
            _repaidWholeLoan
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, _paybackAmountMinusFees, 0);
    }

    /**
    * @dev updates the state of the core as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the amount borrowed by the user
    * @param _compoundedBorrowBalance the amount borrowed plus accrued interest
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _currentRateMode the current interest rate mode for the user
    **/
    function updateStateOnSwapRate(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _compoundedBorrowBalance,
        uint256 _balanceIncrease,
        CoreLibrary.InterestRateMode _currentRateMode
    ) external onlyLendingPool returns (CoreLibrary.InterestRateMode, uint256) {
        updateReserveStateOnSwapRateInternal(
            _reserve,
            _user,
            _principalBorrowBalance,
            _compoundedBorrowBalance,
            _currentRateMode
        );

        CoreLibrary.InterestRateMode newRateMode = updateUserStateOnSwapRateInternal(
            _reserve,
            _user,
            _balanceIncrease,
            _currentRateMode
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);

        return (newRateMode, getUserCurrentBorrowRate(_reserve, _user));
    }

    /**
    * @dev updates the state of the core as a consequence of a liquidation action.
    * @param _principalReserve the address of the principal reserve that is being repaid
    * @param _collateralReserve the address of the collateral reserve that is being liquidated
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _collateralToLiquidate the amount of collateral being liquidated
    * @param _feeLiquidated the amount of origination fee being liquidated
    * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise
    **/
    function updateStateOnLiquidation(
        address _principalReserve,
        address _collateralReserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _collateralToLiquidate,
        uint256 _feeLiquidated,
        uint256 _liquidatedCollateralForFee,
        uint256 _balanceIncrease,
        bool _liquidatorReceivesAToken
    ) external onlyLendingPool {
        updatePrincipalReserveStateOnLiquidationInternal(
            _principalReserve,
            _user,
            _amountToLiquidate,
            _balanceIncrease
        );

        updateCollateralReserveStateOnLiquidationInternal(
            _collateralReserve
        );

        updateUserStateOnLiquidationInternal(
            _principalReserve,
            _user,
            _amountToLiquidate,
            _feeLiquidated,
            _balanceIncrease
        );

        updateReserveInterestRatesAndTimestampInternal(_principalReserve, _amountToLiquidate, 0);

        if (!_liquidatorReceivesAToken) {
            updateReserveInterestRatesAndTimestampInternal(
                _collateralReserve,
                0,
                _collateralToLiquidate.add(_liquidatedCollateralForFee)
            );
        }

    }

    /**
    * @dev updates the state of the core as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @return the new stable rate for the user
    **/
    function updateStateOnRebalance(address _reserve, address _user, uint256 _balanceIncrease)
    external
    onlyLendingPool
    returns (uint256)
    {
        updateReserveStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);

        //update user data and rebalance the rate
        updateUserStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);
        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);
        return usersReserveData[_user][_reserve].stableBorrowRate;
    }

    /**
    * @dev enables or disables a reserve as collateral
    * @param _reserve the address of the principal reserve where the user deposited
    * @param _user the address of the depositor
    * @param _useAsCollateral true if the depositor wants to use the reserve as collateral
    **/
    function setUserUseReserveAsCollateral(address _reserve, address _user, bool _useAsCollateral)
    public
    onlyLendingPool
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        user.useAsCollateral = _useAsCollateral;
    }

    /**
    * @notice ETH/token transfer functions
    **/

    /**
    * @dev fallback function enforces that the caller is a contract, to support flashloan transfers
    **/
    function() external payable {
        //only contracts can send ETH to the core
        require(msg.sender.isContract(), "Only contracts can send ether to the Lending pool core");

    }

    /**
    * @dev transfers to the user a specific amount from the reserve.
    * @param _reserve the address of the reserve where the transfer is happening
    * @param _user the address of the user receiving the transfer
    * @param _amount the amount being transferred
    **/
    function transferToUser(address _reserve, address payable _user, uint256 _amount)
    external
    onlyLendingPool
    {
        if (_reserve != EthAddressLib.ethAddress()) {
            ERC20(_reserve).safeTransfer(_user, _amount);
        } else {
            //solium-disable-next-line
            (bool result, ) = _user.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers the protocol fees to the fees collection address
    * @param _token the address of the token being transferred
    * @param _user the address of the user from where the transfer is happening
    * @param _amount the amount being transferred
    * @param _destination the fee receiver address
    **/

    function transferToFeeCollectionAddress(
        address _token,
        address _user,
        uint256 _amount,
        address _destination
    ) external payable onlyLendingPool {
        address payable feeAddress = address(uint160(_destination)); //cast the address to payable

        if (_token != EthAddressLib.ethAddress()) {
            require(
                msg.value == 0,
                "User is sending ETH along with the ERC20 transfer. Check the value attribute of the transaction"
            );
            ERC20(_token).safeTransferFrom(_user, feeAddress, _amount);
        } else {
            require(msg.value >= _amount, "The amount and the value sent to deposit do not match");
            //solium-disable-next-line
            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers the fees to the fees collection address in the case of liquidation
    * @param _token the address of the token being transferred
    * @param _amount the amount being transferred
    * @param _destination the fee receiver address
    **/
    function liquidateFee(
        address _token,
        uint256 _amount,
        address _destination
    ) external payable onlyLendingPool {
        address payable feeAddress = address(uint160(_destination)); //cast the address to payable
        require(
            msg.value == 0,
            "Fee liquidation does not require any transfer of value"
        );

        if (_token != EthAddressLib.ethAddress()) {
            ERC20(_token).safeTransfer(feeAddress, _amount);
        } else {
            //solium-disable-next-line
            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers an amount from a user to the destination reserve
    * @param _reserve the address of the reserve where the amount is being transferred
    * @param _user the address of the user from where the transfer is happening
    * @param _amount the amount being transferred
    **/
    function transferToReserve(address _reserve, address payable _user, uint256 _amount)
    external
    payable
    onlyLendingPool
    {
        if (_reserve != EthAddressLib.ethAddress()) {
            require(msg.value == 0, "User is sending ETH along with the ERC20 transfer.");
            ERC20(_reserve).safeTransferFrom(_user, address(this), _amount);

        } else {
            require(msg.value >= _amount, "The amount and the value sent to deposit do not match");

            if (msg.value > _amount) {
                //send back excess ETH
                uint256 excessAmount = msg.value.sub(_amount);
                //solium-disable-next-line
                (bool result, ) = _user.call.value(excessAmount).gas(50000)("");
                require(result, "Transfer of ETH failed");
            }
        }
    }

    /**
    * @notice data access functions
    **/

    /**
    * @dev returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral)
    * needed to calculate the global account data in the LendingPoolDataProvider
    * @param _reserve the address of the reserve
    * @param _user the address of the user
    * @return the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not
    **/
    function getUserBasicReserveData(address _reserve, address _user)
    external
    view
    returns (uint256, uint256, uint256, bool)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        uint256 underlyingBalance = getUserUnderlyingAssetBalance(_reserve, _user);

        if (user.principalBorrowBalance == 0) {
            return (underlyingBalance, 0, 0, user.useAsCollateral);
        }

        return (
        underlyingBalance,
        user.getCompoundedBorrowBalance(reserve),
        user.originationFee,
        user.useAsCollateral
        );
    }

    /**
    * @dev checks if a user is allowed to borrow at a stable rate
    * @param _reserve the reserve address
    * @param _user the user
    * @param _amount the amount the the user wants to borrow
    * @return true if the user is allowed to borrow at a stable rate, false otherwise
    **/

    function isUserAllowedToBorrowAtStable(address _reserve, address _user, uint256 _amount)
    external
    view
    returns (bool)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (!reserve.isStableBorrowRateEnabled) return false;

        return
        !user.useAsCollateral ||
        !reserve.usageAsCollateralEnabled ||
        _amount > getUserUnderlyingAssetBalance(_reserve, _user);
    }

    /**
    * @dev gets the underlying asset balance of a user based on the corresponding aToken balance.
    * @param _reserve the reserve address
    * @param _user the user address
    * @return the underlying deposit balance of the user
    **/

    function getUserUnderlyingAssetBalance(address _reserve, address _user)
    public
    view
    returns (uint256)
    {
        AToken aToken = AToken(reserves[_reserve].aTokenAddress);
        return aToken.balanceOf(_user);

    }

    /**
    * @dev gets the interest rate strategy contract address for the reserve
    * @param _reserve the reserve address
    * @return the address of the interest rate strategy contract
    **/
    function getReserveInterestRateStrategyAddress(address _reserve) public view returns (address) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.interestRateStrategyAddress;
    }

    /**
    * @dev gets the aToken contract address for the reserve
    * @param _reserve the reserve address
    * @return the address of the aToken contract
    **/

    function getReserveATokenAddress(address _reserve) public view returns (address) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.aTokenAddress;
    }

    /**
    * @dev gets the available liquidity in the reserve. The available liquidity is the balance of the core contract
    * @param _reserve the reserve address
    * @return the available liquidity
    **/
    function getReserveAvailableLiquidity(address _reserve) public view returns (uint256) {
        uint256 balance = 0;

        if (_reserve == EthAddressLib.ethAddress()) {
            balance = address(this).balance;
        } else {
            balance = IERC20(_reserve).balanceOf(address(this));
        }
        return balance;
    }

    /**
    * @dev gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows
    * @param _reserve the reserve address
    * @return the total liquidity
    **/
    function getReserveTotalLiquidity(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return getReserveAvailableLiquidity(_reserve).add(reserve.getTotalBorrows());
    }

    /**
    * @dev gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there
    * there has been 100% income.
    * @param _reserve the reserve address
    * @return the reserve normalized income
    **/
    function getReserveNormalizedIncome(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.getNormalizedIncome();
    }

    /**
    * @dev gets the reserve total borrows
    * @param _reserve the reserve address
    * @return the total borrows (stable + variable)
    **/
    function getReserveTotalBorrows(address _reserve) public view returns (uint256) {
        return reserves[_reserve].getTotalBorrows();
    }

    /**
    * @dev gets the reserve total borrows stable
    * @param _reserve the reserve address
    * @return the total borrows stable
    **/
    function getReserveTotalBorrowsStable(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.totalBorrowsStable;
    }

    /**
    * @dev gets the reserve total borrows variable
    * @param _reserve the reserve address
    * @return the total borrows variable
    **/

    function getReserveTotalBorrowsVariable(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.totalBorrowsVariable;
    }

    /**
    * @dev gets the reserve liquidation threshold
    * @param _reserve the reserve address
    * @return the reserve liquidation threshold
    **/

    function getReserveLiquidationThreshold(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.liquidationThreshold;
    }

    /**
    * @dev gets the reserve liquidation bonus
    * @param _reserve the reserve address
    * @return the reserve liquidation bonus
    **/

    function getReserveLiquidationBonus(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.liquidationBonus;
    }

    /**
    * @dev gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty
    * @param _reserve the reserve address
    * @return the reserve current variable borrow rate
    **/

    function getReserveCurrentVariableBorrowRate(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        if (reserve.currentVariableBorrowRate == 0) {
            return
            IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)
            .getBaseVariableBorrowRate();
        }
        return reserve.currentVariableBorrowRate;
    }

    /**
    * @dev gets the reserve current stable borrow rate. Is the market rate if the reserve is empty
    * @param _reserve the reserve address
    * @return the reserve current stable borrow rate
    **/

    function getReserveCurrentStableBorrowRate(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        ILendingRateOracle oracle = ILendingRateOracle(addressesProvider.getLendingRateOracle());

        if (reserve.currentStableBorrowRate == 0) {
            //no stable rate borrows yet
            return oracle.getMarketBorrowRate(_reserve);
        }

        return reserve.currentStableBorrowRate;
    }

    /**
    * @dev gets the reserve average stable borrow rate. The average stable rate is the weighted average
    * of all the loans taken at stable rate.
    * @param _reserve the reserve address
    * @return the reserve current average borrow rate
    **/
    function getReserveCurrentAverageStableBorrowRate(address _reserve)
    external
    view
    returns (uint256)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.currentAverageStableBorrowRate;
    }

    /**
    * @dev gets the reserve liquidity rate
    * @param _reserve the reserve address
    * @return the reserve liquidity rate
    **/
    function getReserveCurrentLiquidityRate(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.currentLiquidityRate;
    }

    /**
    * @dev gets the reserve liquidity cumulative index
    * @param _reserve the reserve address
    * @return the reserve liquidity cumulative index
    **/
    function getReserveLiquidityCumulativeIndex(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.lastLiquidityCumulativeIndex;
    }

    /**
    * @dev gets the reserve variable borrow index
    * @param _reserve the reserve address
    * @return the reserve variable borrow index
    **/
    function getReserveVariableBorrowsCumulativeIndex(address _reserve)
    external
    view
    returns (uint256)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.lastVariableBorrowCumulativeIndex;
    }

    /**
    * @dev this function aggregates the configuration parameters of the reserve.
    * It's used in the LendingPoolDataProvider specifically to save gas, and avoid
    * multiple external contract calls to fetch the same data.
    * @param _reserve the reserve address
    * @return the reserve decimals
    * @return the base ltv as collateral
    * @return the liquidation threshold
    * @return if the reserve is used as collateral or not
    **/
    function getReserveConfiguration(address _reserve)
    external
    view
    returns (uint256, uint256, uint256, bool)
    {
        uint256 decimals;
        uint256 baseLTVasCollateral;
        uint256 liquidationThreshold;
        bool usageAsCollateralEnabled;

        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        decimals = reserve.decimals;
        baseLTVasCollateral = reserve.baseLTVasCollateral;
        liquidationThreshold = reserve.liquidationThreshold;
        usageAsCollateralEnabled = reserve.usageAsCollateralEnabled;

        return (decimals, baseLTVasCollateral, liquidationThreshold, usageAsCollateralEnabled);
    }

    /**
    * @dev returns the decimals of the reserve
    * @param _reserve the reserve address
    * @return the reserve decimals
    **/
    function getReserveDecimals(address _reserve) external view returns (uint256) {
        return reserves[_reserve].decimals;
    }

    /**
    * @dev returns true if the reserve is enabled for borrowing
    * @param _reserve the reserve address
    * @return true if the reserve is enabled for borrowing, false otherwise
    **/

    function isReserveBorrowingEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.borrowingEnabled;
    }

    /**
    * @dev returns true if the reserve is enabled as collateral
    * @param _reserve the reserve address
    * @return true if the reserve is enabled as collateral, false otherwise
    **/

    function isReserveUsageAsCollateralEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.usageAsCollateralEnabled;
    }

    /**
    * @dev returns true if the stable rate is enabled on reserve
    * @param _reserve the reserve address
    * @return true if the stable rate is enabled on reserve, false otherwise
    **/
    function getReserveIsStableBorrowRateEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isStableBorrowRateEnabled;
    }

    /**
    * @dev returns true if the reserve is active
    * @param _reserve the reserve address
    * @return true if the reserve is active, false otherwise
    **/
    function getReserveIsActive(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isActive;
    }

    /**
    * @notice returns if a reserve is freezed
    * @param _reserve the reserve for which the information is needed
    * @return true if the reserve is freezed, false otherwise
    **/

    function getReserveIsFreezed(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isFreezed;
    }

    /**
    * @notice returns the timestamp of the last action on the reserve
    * @param _reserve the reserve for which the information is needed
    * @return the last updated timestamp of the reserve
    **/

    function getReserveLastUpdate(address _reserve) external view returns (uint40 timestamp) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        timestamp = reserve.lastUpdateTimestamp;
    }

    /**
    * @dev returns the utilization rate U of a specific reserve
    * @param _reserve the reserve for which the information is needed
    * @return the utilization rate in ray
    **/

    function getReserveUtilizationRate(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        uint256 totalBorrows = reserve.getTotalBorrows();

        if (totalBorrows == 0) {
            return 0;
        }

        uint256 availableLiquidity = getReserveAvailableLiquidity(_reserve);

        return totalBorrows.rayDiv(availableLiquidity.add(totalBorrows));
    }

    /**
    * @return the array of reserves configured on the core
    **/
    function getReserves() external view returns (address[] memory) {
        return reservesList;
    }

    /**
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return true if the user has chosen to use the reserve as collateral, false otherwise
    **/
    function isUserUseReserveAsCollateralEnabled(address _reserve, address _user)
    external
    view
    returns (bool)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.useAsCollateral;
    }

    /**
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the origination fee for the user
    **/
    function getUserOriginationFee(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.originationFee;
    }

    /**
    * @dev users with no loans in progress have NONE as borrow rate mode
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the borrow rate mode for the user,
    **/

    function getUserCurrentBorrowRateMode(address _reserve, address _user)
    public
    view
    returns (CoreLibrary.InterestRateMode)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (user.principalBorrowBalance == 0) {
            return CoreLibrary.InterestRateMode.NONE;
        }

        return
        user.stableBorrowRate > 0
        ? CoreLibrary.InterestRateMode.STABLE
        : CoreLibrary.InterestRateMode.VARIABLE;
    }

    /**
    * @dev gets the current borrow rate of the user
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the borrow rate for the user,
    **/
    function getUserCurrentBorrowRate(address _reserve, address _user)
    internal
    view
    returns (uint256)
    {
        CoreLibrary.InterestRateMode rateMode = getUserCurrentBorrowRateMode(_reserve, _user);

        if (rateMode == CoreLibrary.InterestRateMode.NONE) {
            return 0;
        }

        return
        rateMode == CoreLibrary.InterestRateMode.STABLE
        ? usersReserveData[_user][_reserve].stableBorrowRate
        : reserves[_reserve].currentVariableBorrowRate;
    }

    /**
    * @dev the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the user stable rate
    **/
    function getUserCurrentStableBorrowRate(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.stableBorrowRate;
    }

    /**
    * @dev calculates and returns the borrow balances of the user
    * @param _reserve the address of the reserve
    * @param _user the address of the user
    * @return the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance
    **/

    function getUserBorrowBalances(address _reserve, address _user)
    public
    view
    returns (uint256, uint256, uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        if (user.principalBorrowBalance == 0) {
            return (0, 0, 0);
        }

        uint256 principal = user.principalBorrowBalance;
        uint256 compoundedBalance = CoreLibrary.getCompoundedBorrowBalance(
            user,
            reserves[_reserve]
        );
        return (principal, compoundedBalance, compoundedBalance.sub(principal));
    }

    /**
    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the variable borrow index for the user
    **/

    function getUserVariableBorrowCumulativeIndex(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.lastVariableBorrowCumulativeIndex;
    }

    /**
    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the variable borrow index for the user
    **/

    function getUserLastUpdate(address _reserve, address _user)
    external
    view
    returns (uint256 timestamp)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        timestamp = user.lastUpdateTimestamp;
    }

    /**
    * @dev updates the lending pool core configuration
    **/
    function refreshConfiguration() external onlyLendingPoolConfigurator {
        refreshConfigInternal();
    }

    /**
    * @dev initializes a reserve
    * @param _reserve the address of the reserve
    * @param _aTokenAddress the address of the overlying aToken contract
    * @param _decimals the decimals of the reserve currency
    * @param _interestRateStrategyAddress the address of the interest rate strategy contract
    **/
    function initReserve(
        address _reserve,
        address _aTokenAddress,
        uint256 _decimals,
        address _interestRateStrategyAddress
    ) external onlyLendingPoolConfigurator {
        reserves[_reserve].init(_aTokenAddress, _decimals, _interestRateStrategyAddress);
        addReserveToListInternal(_reserve);

    }



    /**
    * @dev removes the last added reserve in the reservesList array
    * @param _reserveToRemove the address of the reserve
    **/
    function removeLastAddedReserve(address _reserveToRemove)
    external onlyLendingPoolConfigurator {

        address lastReserve = reservesList[reservesList.length-1];

        require(lastReserve == _reserveToRemove, "Reserve being removed is different than the reserve requested");

        //as we can't check if totalLiquidity is 0 (since the reserve added might not be an ERC20) we at least check that there is nothing borrowed
        require(getReserveTotalBorrows(lastReserve) == 0, "Cannot remove a reserve with liquidity deposited");

        reserves[lastReserve].isActive = false;
        reserves[lastReserve].aTokenAddress = address(0);
        reserves[lastReserve].decimals = 0;
        reserves[lastReserve].lastLiquidityCumulativeIndex = 0;
        reserves[lastReserve].lastVariableBorrowCumulativeIndex = 0;
        reserves[lastReserve].borrowingEnabled = false;
        reserves[lastReserve].usageAsCollateralEnabled = false;
        reserves[lastReserve].baseLTVasCollateral = 0;
        reserves[lastReserve].liquidationThreshold = 0;
        reserves[lastReserve].liquidationBonus = 0;
        reserves[lastReserve].interestRateStrategyAddress = address(0);

        reservesList.pop();
    }

    /**
    * @dev updates the address of the interest rate strategy contract
    * @param _reserve the address of the reserve
    * @param _rateStrategyAddress the address of the interest rate strategy contract
    **/

    function setReserveInterestRateStrategyAddress(address _reserve, address _rateStrategyAddress)
    external
    onlyLendingPoolConfigurator
    {
        reserves[_reserve].interestRateStrategyAddress = _rateStrategyAddress;
    }

    /**
    * @dev enables borrowing on a reserve. Also sets the stable rate borrowing
    * @param _reserve the address of the reserve
    * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise
    **/

    function enableBorrowingOnReserve(address _reserve, bool _stableBorrowRateEnabled)
    external
    onlyLendingPoolConfigurator
    {
        reserves[_reserve].enableBorrowing(_stableBorrowRateEnabled);
    }

    /**
    * @dev disables borrowing on a reserve
    * @param _reserve the address of the reserve
    **/

    function disableBorrowingOnReserve(address _reserve) external onlyLendingPoolConfigurator {
        reserves[_reserve].disableBorrowing();
    }

    /**
    * @dev enables a reserve to be used as collateral
    * @param _reserve the address of the reserve
    **/
    function enableReserveAsCollateral(
        address _reserve,
        uint256 _baseLTVasCollateral,
        uint256 _liquidationThreshold,
        uint256 _liquidationBonus
    ) external onlyLendingPoolConfigurator {
        reserves[_reserve].enableAsCollateral(
            _baseLTVasCollateral,
            _liquidationThreshold,
            _liquidationBonus
        );
    }

    /**
    * @dev disables a reserve to be used as collateral
    * @param _reserve the address of the reserve
    **/
    function disableReserveAsCollateral(address _reserve) external onlyLendingPoolConfigurator {
        reserves[_reserve].disableAsCollateral();
    }

    /**
    * @dev enable the stable borrow rate mode on a reserve
    * @param _reserve the address of the reserve
    **/
    function enableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isStableBorrowRateEnabled = true;
    }

    /**
    * @dev disable the stable borrow rate mode on a reserve
    * @param _reserve the address of the reserve
    **/
    function disableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isStableBorrowRateEnabled = false;
    }

    /**
    * @dev activates a reserve
    * @param _reserve the address of the reserve
    **/
    function activateReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        require(
            reserve.lastLiquidityCumulativeIndex > 0 &&
            reserve.lastVariableBorrowCumulativeIndex > 0,
            "Reserve has not been initialized yet"
        );
        reserve.isActive = true;
    }

    /**
    * @dev deactivates a reserve
    * @param _reserve the address of the reserve
    **/
    function deactivateReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isActive = false;
    }

    /**
    * @notice allows the configurator to freeze the reserve.
    * A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance.
    * @param _reserve the address of the reserve
    **/
    function freezeReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isFreezed = true;
    }

    /**
    * @notice allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed.
    * @param _reserve the address of the reserve
    **/
    function unfreezeReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isFreezed = false;
    }

    /**
    * @notice allows the configurator to update the loan to value of a reserve
    * @param _reserve the address of the reserve
    * @param _ltv the new loan to value
    **/
    function setReserveBaseLTVasCollateral(address _reserve, uint256 _ltv)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.baseLTVasCollateral = _ltv;
    }

    /**
    * @notice allows the configurator to update the liquidation threshold of a reserve
    * @param _reserve the address of the reserve
    * @param _threshold the new liquidation threshold
    **/
    function setReserveLiquidationThreshold(address _reserve, uint256 _threshold)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.liquidationThreshold = _threshold;
    }

    /**
    * @notice allows the configurator to update the liquidation bonus of a reserve
    * @param _reserve the address of the reserve
    * @param _bonus the new liquidation bonus
    **/
    function setReserveLiquidationBonus(address _reserve, uint256 _bonus)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.liquidationBonus = _bonus;
    }

    /**
    * @notice allows the configurator to update the reserve decimals
    * @param _reserve the address of the reserve
    * @param _decimals the decimals of the reserve
    **/
    function setReserveDecimals(address _reserve, uint256 _decimals)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.decimals = _decimals;
    }

    /**
    * @notice internal functions
    **/

    /**
    * @dev updates the state of a reserve as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the previous borrow balance of the borrower before the action
    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount
    * @param _amountBorrowed the new amount borrowed
    * @param _rateMode the borrow rate mode (stable, variable)
    **/

    function updateReserveStateOnBorrowInternal(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _balanceIncrease,
        uint256 _amountBorrowed,
        CoreLibrary.InterestRateMode _rateMode
    ) internal {
        reserves[_reserve].updateCumulativeIndexes();

        //increasing reserve total borrows to account for the new borrow balance of the user
        //NOTE: Depending on the previous borrow mode, the borrows might need to be switched from variable to stable or vice versa

        updateReserveTotalBorrowsByRateModeInternal(
            _reserve,
            _user,
            _principalBorrowBalance,
            _balanceIncrease,
            _amountBorrowed,
            _rateMode
        );
    }

    /**
    * @dev updates the state of a user as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _amountBorrowed the amount borrowed
    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount
    * @param _rateMode the borrow rate mode (stable, variable)
    * @return the final borrow rate for the user. Emitted by the borrow() event
    **/

    function updateUserStateOnBorrowInternal(
        address _reserve,
        address _user,
        uint256 _amountBorrowed,
        uint256 _balanceIncrease,
        uint256 _fee,
        CoreLibrary.InterestRateMode _rateMode
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (_rateMode == CoreLibrary.InterestRateMode.STABLE) {
            //stable
            //reset the user variable index, and update the stable rate
            user.stableBorrowRate = reserve.currentStableBorrowRate;
            user.lastVariableBorrowCumulativeIndex = 0;
        } else if (_rateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //variable
            //reset the user stable rate, and store the new borrow index
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        } else {
            revert("Invalid borrow rate mode");
        }
        //increase the principal borrows and the origination fee
        user.principalBorrowBalance = user.principalBorrowBalance.add(_amountBorrowed).add(
            _balanceIncrease
        );
        user.originationFee = user.originationFee.add(_fee);

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

    }

    /**
    * @dev updates the state of the reserve as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateReserveStateOnRepayInternal(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_reserve][_user];

        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(_reserve, _user);

        //update the indexes
        reserves[_reserve].updateCumulativeIndexes();

        //compound the cumulated interest to the borrow balance and then subtracting the payback amount
        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _balanceIncrease,
                user.stableBorrowRate
            );
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _paybackAmountMinusFees,
                user.stableBorrowRate
            );
        } else {
            reserve.increaseTotalBorrowsVariable(_balanceIncrease);
            reserve.decreaseTotalBorrowsVariable(_paybackAmountMinusFees);
        }
    }

    /**
    * @dev updates the state of the user as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _originationFeeRepaid the fee on the amount that is being repaid
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _repaidWholeLoan true if the user is repaying the whole loan
    **/
    function updateUserStateOnRepayInternal(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _originationFeeRepaid,
        uint256 _balanceIncrease,
        bool _repaidWholeLoan
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        //update the user principal borrow balance, adding the cumulated interest and then subtracting the payback amount
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(
            _paybackAmountMinusFees
        );
        user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;

        //if the balance decrease is equal to the previous principal (user is repaying the whole loan)
        //and the rate mode is stable, we reset the interest rate mode of the user
        if (_repaidWholeLoan) {
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = 0;
        }
        user.originationFee = user.originationFee.sub(_originationFeeRepaid);

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

    }

    /**
    * @dev updates the state of the user as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is performing the rate swap
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the the principal amount borrowed by the user
    * @param _compoundedBorrowBalance the principal amount plus the accrued interest
    * @param _currentRateMode the rate mode at which the user borrowed
    **/
    function updateReserveStateOnSwapRateInternal(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _compoundedBorrowBalance,
        CoreLibrary.InterestRateMode _currentRateMode
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        //compounding reserve indexes
        reserve.updateCumulativeIndexes();

        if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {
            uint256 userCurrentStableRate = user.stableBorrowRate;

            //swap to variable
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _principalBorrowBalance,
                userCurrentStableRate
            ); //decreasing stable from old principal balance
            reserve.increaseTotalBorrowsVariable(_compoundedBorrowBalance); //increase variable borrows
        } else if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //swap to stable
            uint256 currentStableRate = reserve.currentStableBorrowRate;
            reserve.decreaseTotalBorrowsVariable(_principalBorrowBalance);
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _compoundedBorrowBalance,
                currentStableRate
            );

        } else {
            revert("Invalid rate mode received");
        }
    }

    /**
    * @dev updates the state of the user as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is performing the swap
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _currentRateMode the current rate mode of the user
    **/

    function updateUserStateOnSwapRateInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease,
        CoreLibrary.InterestRateMode _currentRateMode
    ) internal returns (CoreLibrary.InterestRateMode) {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        CoreLibrary.InterestRateMode newMode = CoreLibrary.InterestRateMode.NONE;

        if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //switch to stable
            newMode = CoreLibrary.InterestRateMode.STABLE;
            user.stableBorrowRate = reserve.currentStableBorrowRate;
            user.lastVariableBorrowCumulativeIndex = 0;
        } else if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {
            newMode = CoreLibrary.InterestRateMode.VARIABLE;
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        } else {
            revert("Invalid interest rate mode received");
        }
        //compounding cumulated interest
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);
        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

        return newMode;
    }

    /**
    * @dev updates the state of the principal reserve as a consequence of a liquidation action.
    * @param _principalReserve the address of the principal reserve that is being repaid
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updatePrincipalReserveStateOnLiquidationInternal(
        address _principalReserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_principalReserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_principalReserve];

        //update principal reserve data
        reserve.updateCumulativeIndexes();

        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(
            _principalReserve,
            _user
        );

        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            //increase the total borrows by the compounded interest
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _balanceIncrease,
                user.stableBorrowRate
            );

            //decrease by the actual amount to liquidate
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _amountToLiquidate,
                user.stableBorrowRate
            );

        } else {
            //increase the total borrows by the compounded interest
            reserve.increaseTotalBorrowsVariable(_balanceIncrease);

            //decrease by the actual amount to liquidate
            reserve.decreaseTotalBorrowsVariable(_amountToLiquidate);
        }

    }

    /**
    * @dev updates the state of the collateral reserve as a consequence of a liquidation action.
    * @param _collateralReserve the address of the collateral reserve that is being liquidated
    **/
    function updateCollateralReserveStateOnLiquidationInternal(
        address _collateralReserve
    ) internal {
        //update collateral reserve
        reserves[_collateralReserve].updateCumulativeIndexes();

    }

    /**
    * @dev updates the state of the user being liquidated as a consequence of a liquidation action.
    * @param _reserve the address of the principal reserve that is being repaid
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _feeLiquidated the amount of origination fee being liquidated
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/
    function updateUserStateOnLiquidationInternal(
        address _reserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _feeLiquidated,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        //first increase by the compounded interest, then decrease by the liquidated amount
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(
            _amountToLiquidate
        );

        if (
            getUserCurrentBorrowRateMode(_reserve, _user) == CoreLibrary.InterestRateMode.VARIABLE
        ) {
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        }

        if(_feeLiquidated > 0){
            user.originationFee = user.originationFee.sub(_feeLiquidated);
        }

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);
    }

    /**
    * @dev updates the state of the reserve as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateReserveStateOnRebalanceInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        reserve.updateCumulativeIndexes();

        reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
            _balanceIncrease,
            user.stableBorrowRate
        );

    }

    /**
    * @dev updates the state of the user as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateUserStateOnRebalanceInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);
        user.stableBorrowRate = reserve.currentStableBorrowRate;

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);
    }

    /**
    * @dev updates the state of the user as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _amountBorrowed the accrued interest on the borrowed amount
    **/
    function updateReserveTotalBorrowsByRateModeInternal(
        address _reserve,
        address _user,
        uint256 _principalBalance,
        uint256 _balanceIncrease,
        uint256 _amountBorrowed,
        CoreLibrary.InterestRateMode _newBorrowRateMode
    ) internal {
        CoreLibrary.InterestRateMode previousRateMode = getUserCurrentBorrowRateMode(
            _reserve,
            _user
        );
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        if (previousRateMode == CoreLibrary.InterestRateMode.STABLE) {
            CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _principalBalance,
                user.stableBorrowRate
            );
        } else if (previousRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            reserve.decreaseTotalBorrowsVariable(_principalBalance);
        }

        uint256 newPrincipalAmount = _principalBalance.add(_balanceIncrease).add(_amountBorrowed);
        if (_newBorrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                newPrincipalAmount,
                reserve.currentStableBorrowRate
            );
        } else if (_newBorrowRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            reserve.increaseTotalBorrowsVariable(newPrincipalAmount);
        } else {
            revert("Invalid new borrow rate mode");
        }
    }

    /**
    * @dev Updates the reserve current stable borrow rate Rf, the current variable borrow rate Rv and the current liquidity rate Rl.
    * Also updates the lastUpdateTimestamp value. Please refer to the whitepaper for further information.
    * @param _reserve the address of the reserve to be updated
    * @param _liquidityAdded the amount of liquidity added to the protocol (deposit or repay) in the previous action
    * @param _liquidityTaken the amount of liquidity taken from the protocol (redeem or borrow)
    **/

    function updateReserveInterestRatesAndTimestampInternal(
        address _reserve,
        uint256 _liquidityAdded,
        uint256 _liquidityTaken
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        (uint256 newLiquidityRate, uint256 newStableRate, uint256 newVariableRate) = IReserveInterestRateStrategy(
            reserve
            .interestRateStrategyAddress
        )
        .calculateInterestRates(
            _reserve,
            getReserveAvailableLiquidity(_reserve).add(_liquidityAdded).sub(_liquidityTaken),
            reserve.totalBorrowsStable,
            reserve.totalBorrowsVariable,
            reserve.currentAverageStableBorrowRate
        );

        reserve.currentLiquidityRate = newLiquidityRate;
        reserve.currentStableBorrowRate = newStableRate;
        reserve.currentVariableBorrowRate = newVariableRate;

        //solium-disable-next-line
        reserve.lastUpdateTimestamp = uint40(block.timestamp);

        emit ReserveUpdated(
            _reserve,
            newLiquidityRate,
            newStableRate,
            newVariableRate,
            reserve.lastLiquidityCumulativeIndex,
            reserve.lastVariableBorrowCumulativeIndex
        );
    }

    /**
    * @dev transfers to the protocol fees of a flashloan to the fees collection address
    * @param _token the address of the token being transferred
    * @param _amount the amount being transferred
    **/

    function transferFlashLoanProtocolFeeInternal(address _token, uint256 _amount) internal {
        address payable receiver = address(uint160(addressesProvider.getTokenDistributor()));

        if (_token != EthAddressLib.ethAddress()) {
            ERC20(_token).safeTransfer(receiver, _amount);
        } else {
            receiver.transfer(_amount);
        }
    }

    /**
    * @dev updates the internal configuration of the core
    **/
    function refreshConfigInternal() internal {
        lendingPoolAddress = addressesProvider.getLendingPool();
    }

    /**
    * @dev adds a reserve to the array of the reserves address
    **/
    function addReserveToListInternal(address _reserve) internal {
        bool reserveAlreadyAdded = false;
        for (uint256 i = 0; i < reservesList.length; i++)
            if (reservesList[i] == _reserve) {
                reserveAlreadyAdded = true;
            }
        if (!reserveAlreadyAdded) reservesList.push(_reserve);
    }

}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-01-09 04:31:41 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 04:31:41 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 14469
completion_tokens: 716
total_tokens: 15185
cost: $-1.000000


[2024-01-09 04:31:41 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: pragma solidity ^0.5.0;

import "openzeppelin-solidity/contracts/math/SafeMath.sol";
import "openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol";
import "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol";
import "openzeppelin-solidity/contracts/utils/Address.sol";
import "../libraries/openzeppelin-upgradeability/VersionedInitializable.sol";

import "../libraries/CoreLibrary.sol";
import "../configuration/LendingPoolAddressesProvider.sol";
import "../interfaces/ILendingRateOracle.sol";
import "../interfaces/IReserveInterestRateStrategy.sol";
import "../libraries/WadRayMath.sol";
import "../tokenization/AToken.sol";
import "../libraries/EthAddressLib.sol";

/**
* @title LendingPoolCore contract
* @author Aave
* @notice Holds the state of the lending pool and all the funds deposited
* @dev NOTE: The core does not enforce security checks on the update of the state
* (eg, updateStateOnBorrow() does not enforce that borrowed is enabled on the reserve).
* The check that an action can be performed is a duty of the overlying LendingPool contract.
**/

contract LendingPoolCore is VersionedInitializable {
    using SafeMath for uint256;
    using WadRayMath for uint256;
    using CoreLibrary for CoreLibrary.ReserveData;
    using CoreLibrary for CoreLibrary.UserReserveData;
    using SafeERC20 for ERC20;
    using Address for address payable;

    /**
    * @dev Emitted when the state of a reserve is updated
    * @param reserve the address of the reserve
    * @param liquidityRate the new liquidity rate
    * @param stableBorrowRate the new stable borrow rate
    * @param variableBorrowRate the new variable borrow rate
    * @param liquidityIndex the new liquidity index
    * @param variableBorrowIndex the new variable borrow index
    **/
    event ReserveUpdated(
        address indexed reserve,
        uint256 liquidityRate,
        uint256 stableBorrowRate,
        uint256 variableBorrowRate,
        uint256 liquidityIndex,
        uint256 variableBorrowIndex
    );

    address public lendingPoolAddress;

    LendingPoolAddressesProvider public addressesProvider;

    /**
    * @dev only lending pools can use functions affected by this modifier
    **/
    modifier onlyLendingPool {
        require(lendingPoolAddress == msg.sender, "The caller must be a lending pool contract");
        _;
    }

    /**
    * @dev only lending pools configurator can use functions affected by this modifier
    **/
    modifier onlyLendingPoolConfigurator {
        require(
            addressesProvider.getLendingPoolConfigurator() == msg.sender,
            "The caller must be a lending pool configurator contract"
        );
        _;
    }

    mapping(address => CoreLibrary.ReserveData) internal reserves;
    mapping(address => mapping(address => CoreLibrary.UserReserveData)) internal usersReserveData;

    address[] public reservesList;

    uint256 public constant CORE_REVISION = 0x4;

    /**
    * @dev returns the revision number of the contract
    **/
    function getRevision() internal pure returns (uint256) {
        return CORE_REVISION;
    }

    /**
    * @dev initializes the Core contract, invoked upon registration on the AddressesProvider
    * @param _addressesProvider the addressesProvider contract
    **/

    function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {
        addressesProvider = _addressesProvider;
        refreshConfigInternal();
    }

    /**
    * @dev updates the state of the core as a result of a deposit action
    * @param _reserve the address of the reserve in which the deposit is happening
    * @param _user the address of the the user depositing
    * @param _amount the amount being deposited
    * @param _isFirstDeposit true if the user is depositing for the first time
    **/

    function updateStateOnDeposit(
        address _reserve,
        address _user,
        uint256 _amount,
        bool _isFirstDeposit
    ) external onlyLendingPool {
        reserves[_reserve].updateCumulativeIndexes();
        updateReserveInterestRatesAndTimestampInternal(_reserve, _amount, 0);

        if (_isFirstDeposit) {
            //if this is the first deposit of the user, we configure the deposit as enabled to be used as collateral
            setUserUseReserveAsCollateral(_reserve, _user, true);
        }
    }

    /**
    * @dev updates the state of the core as a result of a redeem action
    * @param _reserve the address of the reserve in which the redeem is happening
    * @param _user the address of the the user redeeming
    * @param _amountRedeemed the amount being redeemed
    * @param _userRedeemedEverything true if the user is redeeming everything
    **/
    function updateStateOnRedeem(
        address _reserve,
        address _user,
        uint256 _amountRedeemed,
        bool _userRedeemedEverything
    ) external onlyLendingPool {
        //compound liquidity and variable borrow interests
        reserves[_reserve].updateCumulativeIndexes();
        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountRedeemed);

        //if user redeemed everything the useReserveAsCollateral flag is reset
        if (_userRedeemedEverything) {
            setUserUseReserveAsCollateral(_reserve, _user, false);
        }
    }

    /**
    * @dev updates the state of the core as a result of a flashloan action
    * @param _reserve the address of the reserve in which the flashloan is happening
    * @param _income the income of the protocol as a result of the action
    **/
    function updateStateOnFlashLoan(
        address _reserve,
        uint256 _availableLiquidityBefore,
        uint256 _income,
        uint256 _protocolFee
    ) external onlyLendingPool {
        transferFlashLoanProtocolFeeInternal(_reserve, _protocolFee);

        //compounding the cumulated interest
        reserves[_reserve].updateCumulativeIndexes();

        uint256 totalLiquidityBefore = _availableLiquidityBefore.add(
            getReserveTotalBorrows(_reserve)
        );

        //compounding the received fee into the reserve
        reserves[_reserve].cumulateToLiquidityIndex(totalLiquidityBefore, _income);

        //refresh interest rates
        updateReserveInterestRatesAndTimestampInternal(_reserve, _income, 0);
    }

    /**
    * @dev updates the state of the core as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _amountBorrowed the new amount borrowed
    * @param _borrowFee the fee on the amount borrowed
    * @param _rateMode the borrow rate mode (stable, variable)
    * @return the new borrow rate for the user
    **/
    function updateStateOnBorrow(
        address _reserve,
        address _user,
        uint256 _amountBorrowed,
        uint256 _borrowFee,
        CoreLibrary.InterestRateMode _rateMode
    ) external onlyLendingPool returns (uint256, uint256) {
        // getting the previous borrow data of the user
        (uint256 principalBorrowBalance, , uint256 balanceIncrease) = getUserBorrowBalances(
            _reserve,
            _user
        );

        updateReserveStateOnBorrowInternal(
            _reserve,
            _user,
            principalBorrowBalance,
            balanceIncrease,
            _amountBorrowed,
            _rateMode
        );

        updateUserStateOnBorrowInternal(
            _reserve,
            _user,
            _amountBorrowed,
            balanceIncrease,
            _borrowFee,
            _rateMode
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountBorrowed);

        return (getUserCurrentBorrowRate(_reserve, _user), balanceIncrease);
    }

    /**
    * @dev updates the state of the core as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _originationFeeRepaid the fee on the amount that is being repaid
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _repaidWholeLoan true if the user is repaying the whole loan
    **/

    function updateStateOnRepay(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _originationFeeRepaid,
        uint256 _balanceIncrease,
        bool _repaidWholeLoan
    ) external onlyLendingPool {
        updateReserveStateOnRepayInternal(
            _reserve,
            _user,
            _paybackAmountMinusFees,
            _balanceIncrease
        );
        updateUserStateOnRepayInternal(
            _reserve,
            _user,
            _paybackAmountMinusFees,
            _originationFeeRepaid,
            _balanceIncrease,
            _repaidWholeLoan
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, _paybackAmountMinusFees, 0);
    }

    /**
    * @dev updates the state of the core as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the amount borrowed by the user
    * @param _compoundedBorrowBalance the amount borrowed plus accrued interest
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _currentRateMode the current interest rate mode for the user
    **/
    function updateStateOnSwapRate(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _compoundedBorrowBalance,
        uint256 _balanceIncrease,
        CoreLibrary.InterestRateMode _currentRateMode
    ) external onlyLendingPool returns (CoreLibrary.InterestRateMode, uint256) {
        updateReserveStateOnSwapRateInternal(
            _reserve,
            _user,
            _principalBorrowBalance,
            _compoundedBorrowBalance,
            _currentRateMode
        );

        CoreLibrary.InterestRateMode newRateMode = updateUserStateOnSwapRateInternal(
            _reserve,
            _user,
            _balanceIncrease,
            _currentRateMode
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);

        return (newRateMode, getUserCurrentBorrowRate(_reserve, _user));
    }

    /**
    * @dev updates the state of the core as a consequence of a liquidation action.
    * @param _principalReserve the address of the principal reserve that is being repaid
    * @param _collateralReserve the address of the collateral reserve that is being liquidated
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _collateralToLiquidate the amount of collateral being liquidated
    * @param _feeLiquidated the amount of origination fee being liquidated
    * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise
    **/
    function updateStateOnLiquidation(
        address _principalReserve,
        address _collateralReserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _collateralToLiquidate,
        uint256 _feeLiquidated,
        uint256 _liquidatedCollateralForFee,
        uint256 _balanceIncrease,
        bool _liquidatorReceivesAToken
    ) external onlyLendingPool {
        updatePrincipalReserveStateOnLiquidationInternal(
            _principalReserve,
            _user,
            _amountToLiquidate,
            _balanceIncrease
        );

        updateCollateralReserveStateOnLiquidationInternal(
            _collateralReserve
        );

        updateUserStateOnLiquidationInternal(
            _principalReserve,
            _user,
            _amountToLiquidate,
            _feeLiquidated,
            _balanceIncrease
        );

        updateReserveInterestRatesAndTimestampInternal(_principalReserve, _amountToLiquidate, 0);

        if (!_liquidatorReceivesAToken) {
            updateReserveInterestRatesAndTimestampInternal(
                _collateralReserve,
                0,
                _collateralToLiquidate.add(_liquidatedCollateralForFee)
            );
        }

    }

    /**
    * @dev updates the state of the core as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @return the new stable rate for the user
    **/
    function updateStateOnRebalance(address _reserve, address _user, uint256 _balanceIncrease)
    external
    onlyLendingPool
    returns (uint256)
    {
        updateReserveStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);

        //update user data and rebalance the rate
        updateUserStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);
        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);
        return usersReserveData[_user][_reserve].stableBorrowRate;
    }

    /**
    * @dev enables or disables a reserve as collateral
    * @param _reserve the address of the principal reserve where the user deposited
    * @param _user the address of the depositor
    * @param _useAsCollateral true if the depositor wants to use the reserve as collateral
    **/
    function setUserUseReserveAsCollateral(address _reserve, address _user, bool _useAsCollateral)
    public
    onlyLendingPool
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        user.useAsCollateral = _useAsCollateral;
    }

    /**
    * @notice ETH/token transfer functions
    **/

    /**
    * @dev fallback function enforces that the caller is a contract, to support flashloan transfers
    **/
    function() external payable {
        //only contracts can send ETH to the core
        require(msg.sender.isContract(), "Only contracts can send ether to the Lending pool core");

    }

    /**
    * @dev transfers to the user a specific amount from the reserve.
    * @param _reserve the address of the reserve where the transfer is happening
    * @param _user the address of the user receiving the transfer
    * @param _amount the amount being transferred
    **/
    function transferToUser(address _reserve, address payable _user, uint256 _amount)
    external
    onlyLendingPool
    {
        if (_reserve != EthAddressLib.ethAddress()) {
            ERC20(_reserve).safeTransfer(_user, _amount);
        } else {
            //solium-disable-next-line
            (bool result, ) = _user.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers the protocol fees to the fees collection address
    * @param _token the address of the token being transferred
    * @param _user the address of the user from where the transfer is happening
    * @param _amount the amount being transferred
    * @param _destination the fee receiver address
    **/

    function transferToFeeCollectionAddress(
        address _token,
        address _user,
        uint256 _amount,
        address _destination
    ) external payable onlyLendingPool {
        address payable feeAddress = address(uint160(_destination)); //cast the address to payable

        if (_token != EthAddressLib.ethAddress()) {
            require(
                msg.value == 0,
                "User is sending ETH along with the ERC20 transfer. Check the value attribute of the transaction"
            );
            ERC20(_token).safeTransferFrom(_user, feeAddress, _amount);
        } else {
            require(msg.value >= _amount, "The amount and the value sent to deposit do not match");
            //solium-disable-next-line
            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers the fees to the fees collection address in the case of liquidation
    * @param _token the address of the token being transferred
    * @param _amount the amount being transferred
    * @param _destination the fee receiver address
    **/
    function liquidateFee(
        address _token,
        uint256 _amount,
        address _destination
    ) external payable onlyLendingPool {
        address payable feeAddress = address(uint160(_destination)); //cast the address to payable
        require(
            msg.value == 0,
            "Fee liquidation does not require any transfer of value"
        );

        if (_token != EthAddressLib.ethAddress()) {
            ERC20(_token).safeTransfer(feeAddress, _amount);
        } else {
            //solium-disable-next-line
            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers an amount from a user to the destination reserve
    * @param _reserve the address of the reserve where the amount is being transferred
    * @param _user the address of the user from where the transfer is happening
    * @param _amount the amount being transferred
    **/
    function transferToReserve(address _reserve, address payable _user, uint256 _amount)
    external
    payable
    onlyLendingPool
    {
        if (_reserve != EthAddressLib.ethAddress()) {
            require(msg.value == 0, "User is sending ETH along with the ERC20 transfer.");
            ERC20(_reserve).safeTransferFrom(_user, address(this), _amount);

        } else {
            require(msg.value >= _amount, "The amount and the value sent to deposit do not match");

            if (msg.value > _amount) {
                //send back excess ETH
                uint256 excessAmount = msg.value.sub(_amount);
                //solium-disable-next-line
                (bool result, ) = _user.call.value(excessAmount).gas(50000)("");
                require(result, "Transfer of ETH failed");
            }
        }
    }

    /**
    * @notice data access functions
    **/

    /**
    * @dev returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral)
    * needed to calculate the global account data in the LendingPoolDataProvider
    * @param _reserve the address of the reserve
    * @param _user the address of the user
    * @return the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not
    **/
    function getUserBasicReserveData(address _reserve, address _user)
    external
    view
    returns (uint256, uint256, uint256, bool)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        uint256 underlyingBalance = getUserUnderlyingAssetBalance(_reserve, _user);

        if (user.principalBorrowBalance == 0) {
            return (underlyingBalance, 0, 0, user.useAsCollateral);
        }

        return (
        underlyingBalance,
        user.getCompoundedBorrowBalance(reserve),
        user.originationFee,
        user.useAsCollateral
        );
    }

    /**
    * @dev checks if a user is allowed to borrow at a stable rate
    * @param _reserve the reserve address
    * @param _user the user
    * @param _amount the amount the the user wants to borrow
    * @return true if the user is allowed to borrow at a stable rate, false otherwise
    **/

    function isUserAllowedToBorrowAtStable(address _reserve, address _user, uint256 _amount)
    external
    view
    returns (bool)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (!reserve.isStableBorrowRateEnabled) return false;

        return
        !user.useAsCollateral ||
        !reserve.usageAsCollateralEnabled ||
        _amount > getUserUnderlyingAssetBalance(_reserve, _user);
    }

    /**
    * @dev gets the underlying asset balance of a user based on the corresponding aToken balance.
    * @param _reserve the reserve address
    * @param _user the user address
    * @return the underlying deposit balance of the user
    **/

    function getUserUnderlyingAssetBalance(address _reserve, address _user)
    public
    view
    returns (uint256)
    {
        AToken aToken = AToken(reserves[_reserve].aTokenAddress);
        return aToken.balanceOf(_user);

    }

    /**
    * @dev gets the interest rate strategy contract address for the reserve
    * @param _reserve the reserve address
    * @return the address of the interest rate strategy contract
    **/
    function getReserveInterestRateStrategyAddress(address _reserve) public view returns (address) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.interestRateStrategyAddress;
    }

    /**
    * @dev gets the aToken contract address for the reserve
    * @param _reserve the reserve address
    * @return the address of the aToken contract
    **/

    function getReserveATokenAddress(address _reserve) public view returns (address) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.aTokenAddress;
    }

    /**
    * @dev gets the available liquidity in the reserve. The available liquidity is the balance of the core contract
    * @param _reserve the reserve address
    * @return the available liquidity
    **/
    function getReserveAvailableLiquidity(address _reserve) public view returns (uint256) {
        uint256 balance = 0;

        if (_reserve == EthAddressLib.ethAddress()) {
            balance = address(this).balance;
        } else {
            balance = IERC20(_reserve).balanceOf(address(this));
        }
        return balance;
    }

    /**
    * @dev gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows
    * @param _reserve the reserve address
    * @return the total liquidity
    **/
    function getReserveTotalLiquidity(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return getReserveAvailableLiquidity(_reserve).add(reserve.getTotalBorrows());
    }

    /**
    * @dev gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there
    * there has been 100% income.
    * @param _reserve the reserve address
    * @return the reserve normalized income
    **/
    function getReserveNormalizedIncome(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.getNormalizedIncome();
    }

    /**
    * @dev gets the reserve total borrows
    * @param _reserve the reserve address
    * @return the total borrows (stable + variable)
    **/
    function getReserveTotalBorrows(address _reserve) public view returns (uint256) {
        return reserves[_reserve].getTotalBorrows();
    }

    /**
    * @dev gets the reserve total borrows stable
    * @param _reserve the reserve address
    * @return the total borrows stable
    **/
    function getReserveTotalBorrowsStable(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.totalBorrowsStable;
    }

    /**
    * @dev gets the reserve total borrows variable
    * @param _reserve the reserve address
    * @return the total borrows variable
    **/

    function getReserveTotalBorrowsVariable(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.totalBorrowsVariable;
    }

    /**
    * @dev gets the reserve liquidation threshold
    * @param _reserve the reserve address
    * @return the reserve liquidation threshold
    **/

    function getReserveLiquidationThreshold(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.liquidationThreshold;
    }

    /**
    * @dev gets the reserve liquidation bonus
    * @param _reserve the reserve address
    * @return the reserve liquidation bonus
    **/

    function getReserveLiquidationBonus(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.liquidationBonus;
    }

    /**
    * @dev gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty
    * @param _reserve the reserve address
    * @return the reserve current variable borrow rate
    **/

    function getReserveCurrentVariableBorrowRate(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        if (reserve.currentVariableBorrowRate == 0) {
            return
            IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)
            .getBaseVariableBorrowRate();
        }
        return reserve.currentVariableBorrowRate;
    }

    /**
    * @dev gets the reserve current stable borrow rate. Is the market rate if the reserve is empty
    * @param _reserve the reserve address
    * @return the reserve current stable borrow rate
    **/

    function getReserveCurrentStableBorrowRate(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        ILendingRateOracle oracle = ILendingRateOracle(addressesProvider.getLendingRateOracle());

        if (reserve.currentStableBorrowRate == 0) {
            //no stable rate borrows yet
            return oracle.getMarketBorrowRate(_reserve);
        }

        return reserve.currentStableBorrowRate;
    }

    /**
    * @dev gets the reserve average stable borrow rate. The average stable rate is the weighted average
    * of all the loans taken at stable rate.
    * @param _reserve the reserve address
    * @return the reserve current average borrow rate
    **/
    function getReserveCurrentAverageStableBorrowRate(address _reserve)
    external
    view
    returns (uint256)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.currentAverageStableBorrowRate;
    }

    /**
    * @dev gets the reserve liquidity rate
    * @param _reserve the reserve address
    * @return the reserve liquidity rate
    **/
    function getReserveCurrentLiquidityRate(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.currentLiquidityRate;
    }

    /**
    * @dev gets the reserve liquidity cumulative index
    * @param _reserve the reserve address
    * @return the reserve liquidity cumulative index
    **/
    function getReserveLiquidityCumulativeIndex(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.lastLiquidityCumulativeIndex;
    }

    /**
    * @dev gets the reserve variable borrow index
    * @param _reserve the reserve address
    * @return the reserve variable borrow index
    **/
    function getReserveVariableBorrowsCumulativeIndex(address _reserve)
    external
    view
    returns (uint256)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.lastVariableBorrowCumulativeIndex;
    }

    /**
    * @dev this function aggregates the configuration parameters of the reserve.
    * It's used in the LendingPoolDataProvider specifically to save gas, and avoid
    * multiple external contract calls to fetch the same data.
    * @param _reserve the reserve address
    * @return the reserve decimals
    * @return the base ltv as collateral
    * @return the liquidation threshold
    * @return if the reserve is used as collateral or not
    **/
    function getReserveConfiguration(address _reserve)
    external
    view
    returns (uint256, uint256, uint256, bool)
    {
        uint256 decimals;
        uint256 baseLTVasCollateral;
        uint256 liquidationThreshold;
        bool usageAsCollateralEnabled;

        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        decimals = reserve.decimals;
        baseLTVasCollateral = reserve.baseLTVasCollateral;
        liquidationThreshold = reserve.liquidationThreshold;
        usageAsCollateralEnabled = reserve.usageAsCollateralEnabled;

        return (decimals, baseLTVasCollateral, liquidationThreshold, usageAsCollateralEnabled);
    }

    /**
    * @dev returns the decimals of the reserve
    * @param _reserve the reserve address
    * @return the reserve decimals
    **/
    function getReserveDecimals(address _reserve) external view returns (uint256) {
        return reserves[_reserve].decimals;
    }

    /**
    * @dev returns true if the reserve is enabled for borrowing
    * @param _reserve the reserve address
    * @return true if the reserve is enabled for borrowing, false otherwise
    **/

    function isReserveBorrowingEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.borrowingEnabled;
    }

    /**
    * @dev returns true if the reserve is enabled as collateral
    * @param _reserve the reserve address
    * @return true if the reserve is enabled as collateral, false otherwise
    **/

    function isReserveUsageAsCollateralEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.usageAsCollateralEnabled;
    }

    /**
    * @dev returns true if the stable rate is enabled on reserve
    * @param _reserve the reserve address
    * @return true if the stable rate is enabled on reserve, false otherwise
    **/
    function getReserveIsStableBorrowRateEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isStableBorrowRateEnabled;
    }

    /**
    * @dev returns true if the reserve is active
    * @param _reserve the reserve address
    * @return true if the reserve is active, false otherwise
    **/
    function getReserveIsActive(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isActive;
    }

    /**
    * @notice returns if a reserve is freezed
    * @param _reserve the reserve for which the information is needed
    * @return true if the reserve is freezed, false otherwise
    **/

    function getReserveIsFreezed(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isFreezed;
    }

    /**
    * @notice returns the timestamp of the last action on the reserve
    * @param _reserve the reserve for which the information is needed
    * @return the last updated timestamp of the reserve
    **/

    function getReserveLastUpdate(address _reserve) external view returns (uint40 timestamp) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        timestamp = reserve.lastUpdateTimestamp;
    }

    /**
    * @dev returns the utilization rate U of a specific reserve
    * @param _reserve the reserve for which the information is needed
    * @return the utilization rate in ray
    **/

    function getReserveUtilizationRate(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        uint256 totalBorrows = reserve.getTotalBorrows();

        if (totalBorrows == 0) {
            return 0;
        }

        uint256 availableLiquidity = getReserveAvailableLiquidity(_reserve);

        return totalBorrows.rayDiv(availableLiquidity.add(totalBorrows));
    }

    /**
    * @return the array of reserves configured on the core
    **/
    function getReserves() external view returns (address[] memory) {
        return reservesList;
    }

    /**
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return true if the user has chosen to use the reserve as collateral, false otherwise
    **/
    function isUserUseReserveAsCollateralEnabled(address _reserve, address _user)
    external
    view
    returns (bool)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.useAsCollateral;
    }

    /**
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the origination fee for the user
    **/
    function getUserOriginationFee(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.originationFee;
    }

    /**
    * @dev users with no loans in progress have NONE as borrow rate mode
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the borrow rate mode for the user,
    **/

    function getUserCurrentBorrowRateMode(address _reserve, address _user)
    public
    view
    returns (CoreLibrary.InterestRateMode)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (user.principalBorrowBalance == 0) {
            return CoreLibrary.InterestRateMode.NONE;
        }

        return
        user.stableBorrowRate > 0
        ? CoreLibrary.InterestRateMode.STABLE
        : CoreLibrary.InterestRateMode.VARIABLE;
    }

    /**
    * @dev gets the current borrow rate of the user
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the borrow rate for the user,
    **/
    function getUserCurrentBorrowRate(address _reserve, address _user)
    internal
    view
    returns (uint256)
    {
        CoreLibrary.InterestRateMode rateMode = getUserCurrentBorrowRateMode(_reserve, _user);

        if (rateMode == CoreLibrary.InterestRateMode.NONE) {
            return 0;
        }

        return
        rateMode == CoreLibrary.InterestRateMode.STABLE
        ? usersReserveData[_user][_reserve].stableBorrowRate
        : reserves[_reserve].currentVariableBorrowRate;
    }

    /**
    * @dev the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the user stable rate
    **/
    function getUserCurrentStableBorrowRate(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.stableBorrowRate;
    }

    /**
    * @dev calculates and returns the borrow balances of the user
    * @param _reserve the address of the reserve
    * @param _user the address of the user
    * @return the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance
    **/

    function getUserBorrowBalances(address _reserve, address _user)
    public
    view
    returns (uint256, uint256, uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        if (user.principalBorrowBalance == 0) {
            return (0, 0, 0);
        }

        uint256 principal = user.principalBorrowBalance;
        uint256 compoundedBalance = CoreLibrary.getCompoundedBorrowBalance(
            user,
            reserves[_reserve]
        );
        return (principal, compoundedBalance, compoundedBalance.sub(principal));
    }

    /**
    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the variable borrow index for the user
    **/

    function getUserVariableBorrowCumulativeIndex(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.lastVariableBorrowCumulativeIndex;
    }

    /**
    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the variable borrow index for the user
    **/

    function getUserLastUpdate(address _reserve, address _user)
    external
    view
    returns (uint256 timestamp)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        timestamp = user.lastUpdateTimestamp;
    }

    /**
    * @dev updates the lending pool core configuration
    **/
    function refreshConfiguration() external onlyLendingPoolConfigurator {
        refreshConfigInternal();
    }

    /**
    * @dev initializes a reserve
    * @param _reserve the address of the reserve
    * @param _aTokenAddress the address of the overlying aToken contract
    * @param _decimals the decimals of the reserve currency
    * @param _interestRateStrategyAddress the address of the interest rate strategy contract
    **/
    function initReserve(
        address _reserve,
        address _aTokenAddress,
        uint256 _decimals,
        address _interestRateStrategyAddress
    ) external onlyLendingPoolConfigurator {
        reserves[_reserve].init(_aTokenAddress, _decimals, _interestRateStrategyAddress);
        addReserveToListInternal(_reserve);

    }



    /**
    * @dev removes the last added reserve in the reservesList array
    * @param _reserveToRemove the address of the reserve
    **/
    function removeLastAddedReserve(address _reserveToRemove)
    external onlyLendingPoolConfigurator {

        address lastReserve = reservesList[reservesList.length-1];

        require(lastReserve == _reserveToRemove, "Reserve being removed is different than the reserve requested");

        //as we can't check if totalLiquidity is 0 (since the reserve added might not be an ERC20) we at least check that there is nothing borrowed
        require(getReserveTotalBorrows(lastReserve) == 0, "Cannot remove a reserve with liquidity deposited");

        reserves[lastReserve].isActive = false;
        reserves[lastReserve].aTokenAddress = address(0);
        reserves[lastReserve].decimals = 0;
        reserves[lastReserve].lastLiquidityCumulativeIndex = 0;
        reserves[lastReserve].lastVariableBorrowCumulativeIndex = 0;
        reserves[lastReserve].borrowingEnabled = false;
        reserves[lastReserve].usageAsCollateralEnabled = false;
        reserves[lastReserve].baseLTVasCollateral = 0;
        reserves[lastReserve].liquidationThreshold = 0;
        reserves[lastReserve].liquidationBonus = 0;
        reserves[lastReserve].interestRateStrategyAddress = address(0);

        reservesList.pop();
    }

    /**
    * @dev updates the address of the interest rate strategy contract
    * @param _reserve the address of the reserve
    * @param _rateStrategyAddress the address of the interest rate strategy contract
    **/

    function setReserveInterestRateStrategyAddress(address _reserve, address _rateStrategyAddress)
    external
    onlyLendingPoolConfigurator
    {
        reserves[_reserve].interestRateStrategyAddress = _rateStrategyAddress;
    }

    /**
    * @dev enables borrowing on a reserve. Also sets the stable rate borrowing
    * @param _reserve the address of the reserve
    * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise
    **/

    function enableBorrowingOnReserve(address _reserve, bool _stableBorrowRateEnabled)
    external
    onlyLendingPoolConfigurator
    {
        reserves[_reserve].enableBorrowing(_stableBorrowRateEnabled);
    }

    /**
    * @dev disables borrowing on a reserve
    * @param _reserve the address of the reserve
    **/

    function disableBorrowingOnReserve(address _reserve) external onlyLendingPoolConfigurator {
        reserves[_reserve].disableBorrowing();
    }

    /**
    * @dev enables a reserve to be used as collateral
    * @param _reserve the address of the reserve
    **/
    function enableReserveAsCollateral(
        address _reserve,
        uint256 _baseLTVasCollateral,
        uint256 _liquidationThreshold,
        uint256 _liquidationBonus
    ) external onlyLendingPoolConfigurator {
        reserves[_reserve].enableAsCollateral(
            _baseLTVasCollateral,
            _liquidationThreshold,
            _liquidationBonus
        );
    }

    /**
    * @dev disables a reserve to be used as collateral
    * @param _reserve the address of the reserve
    **/
    function disableReserveAsCollateral(address _reserve) external onlyLendingPoolConfigurator {
        reserves[_reserve].disableAsCollateral();
    }

    /**
    * @dev enable the stable borrow rate mode on a reserve
    * @param _reserve the address of the reserve
    **/
    function enableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isStableBorrowRateEnabled = true;
    }

    /**
    * @dev disable the stable borrow rate mode on a reserve
    * @param _reserve the address of the reserve
    **/
    function disableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isStableBorrowRateEnabled = false;
    }

    /**
    * @dev activates a reserve
    * @param _reserve the address of the reserve
    **/
    function activateReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        require(
            reserve.lastLiquidityCumulativeIndex > 0 &&
            reserve.lastVariableBorrowCumulativeIndex > 0,
            "Reserve has not been initialized yet"
        );
        reserve.isActive = true;
    }

    /**
    * @dev deactivates a reserve
    * @param _reserve the address of the reserve
    **/
    function deactivateReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isActive = false;
    }

    /**
    * @notice allows the configurator to freeze the reserve.
    * A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance.
    * @param _reserve the address of the reserve
    **/
    function freezeReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isFreezed = true;
    }

    /**
    * @notice allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed.
    * @param _reserve the address of the reserve
    **/
    function unfreezeReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isFreezed = false;
    }

    /**
    * @notice allows the configurator to update the loan to value of a reserve
    * @param _reserve the address of the reserve
    * @param _ltv the new loan to value
    **/
    function setReserveBaseLTVasCollateral(address _reserve, uint256 _ltv)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.baseLTVasCollateral = _ltv;
    }

    /**
    * @notice allows the configurator to update the liquidation threshold of a reserve
    * @param _reserve the address of the reserve
    * @param _threshold the new liquidation threshold
    **/
    function setReserveLiquidationThreshold(address _reserve, uint256 _threshold)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.liquidationThreshold = _threshold;
    }

    /**
    * @notice allows the configurator to update the liquidation bonus of a reserve
    * @param _reserve the address of the reserve
    * @param _bonus the new liquidation bonus
    **/
    function setReserveLiquidationBonus(address _reserve, uint256 _bonus)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.liquidationBonus = _bonus;
    }

    /**
    * @notice allows the configurator to update the reserve decimals
    * @param _reserve the address of the reserve
    * @param _decimals the decimals of the reserve
    **/
    function setReserveDecimals(address _reserve, uint256 _decimals)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.decimals = _decimals;
    }

    /**
    * @notice internal functions
    **/

    /**
    * @dev updates the state of a reserve as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the previous borrow balance of the borrower before the action
    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount
    * @param _amountBorrowed the new amount borrowed
    * @param _rateMode the borrow rate mode (stable, variable)
    **/

    function updateReserveStateOnBorrowInternal(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _balanceIncrease,
        uint256 _amountBorrowed,
        CoreLibrary.InterestRateMode _rateMode
    ) internal {
        reserves[_reserve].updateCumulativeIndexes();

        //increasing reserve total borrows to account for the new borrow balance of the user
        //NOTE: Depending on the previous borrow mode, the borrows might need to be switched from variable to stable or vice versa

        updateReserveTotalBorrowsByRateModeInternal(
            _reserve,
            _user,
            _principalBorrowBalance,
            _balanceIncrease,
            _amountBorrowed,
            _rateMode
        );
    }

    /**
    * @dev updates the state of a user as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _amountBorrowed the amount borrowed
    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount
    * @param _rateMode the borrow rate mode (stable, variable)
    * @return the final borrow rate for the user. Emitted by the borrow() event
    **/

    function updateUserStateOnBorrowInternal(
        address _reserve,
        address _user,
        uint256 _amountBorrowed,
        uint256 _balanceIncrease,
        uint256 _fee,
        CoreLibrary.InterestRateMode _rateMode
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (_rateMode == CoreLibrary.InterestRateMode.STABLE) {
            //stable
            //reset the user variable index, and update the stable rate
            user.stableBorrowRate = reserve.currentStableBorrowRate;
            user.lastVariableBorrowCumulativeIndex = 0;
        } else if (_rateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //variable
            //reset the user stable rate, and store the new borrow index
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        } else {
            revert("Invalid borrow rate mode");
        }
        //increase the principal borrows and the origination fee
        user.principalBorrowBalance = user.principalBorrowBalance.add(_amountBorrowed).add(
            _balanceIncrease
        );
        user.originationFee = user.originationFee.add(_fee);

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

    }

    /**
    * @dev updates the state of the reserve as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateReserveStateOnRepayInternal(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_reserve][_user];

        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(_reserve, _user);

        //update the indexes
        reserves[_reserve].updateCumulativeIndexes();

        //compound the cumulated interest to the borrow balance and then subtracting the payback amount
        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _balanceIncrease,
                user.stableBorrowRate
            );
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _paybackAmountMinusFees,
                user.stableBorrowRate
            );
        } else {
            reserve.increaseTotalBorrowsVariable(_balanceIncrease);
            reserve.decreaseTotalBorrowsVariable(_paybackAmountMinusFees);
        }
    }

    /**
    * @dev updates the state of the user as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _originationFeeRepaid the fee on the amount that is being repaid
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _repaidWholeLoan true if the user is repaying the whole loan
    **/
    function updateUserStateOnRepayInternal(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _originationFeeRepaid,
        uint256 _balanceIncrease,
        bool _repaidWholeLoan
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        //update the user principal borrow balance, adding the cumulated interest and then subtracting the payback amount
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(
            _paybackAmountMinusFees
        );
        user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;

        //if the balance decrease is equal to the previous principal (user is repaying the whole loan)
        //and the rate mode is stable, we reset the interest rate mode of the user
        if (_repaidWholeLoan) {
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = 0;
        }
        user.originationFee = user.originationFee.sub(_originationFeeRepaid);

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

    }

    /**
    * @dev updates the state of the user as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is performing the rate swap
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the the principal amount borrowed by the user
    * @param _compoundedBorrowBalance the principal amount plus the accrued interest
    * @param _currentRateMode the rate mode at which the user borrowed
    **/
    function updateReserveStateOnSwapRateInternal(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _compoundedBorrowBalance,
        CoreLibrary.InterestRateMode _currentRateMode
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        //compounding reserve indexes
        reserve.updateCumulativeIndexes();

        if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {
            uint256 userCurrentStableRate = user.stableBorrowRate;

            //swap to variable
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _principalBorrowBalance,
                userCurrentStableRate
            ); //decreasing stable from old principal balance
            reserve.increaseTotalBorrowsVariable(_compoundedBorrowBalance); //increase variable borrows
        } else if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //swap to stable
            uint256 currentStableRate = reserve.currentStableBorrowRate;
            reserve.decreaseTotalBorrowsVariable(_principalBorrowBalance);
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _compoundedBorrowBalance,
                currentStableRate
            );

        } else {
            revert("Invalid rate mode received");
        }
    }

    /**
    * @dev updates the state of the user as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is performing the swap
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _currentRateMode the current rate mode of the user
    **/

    function updateUserStateOnSwapRateInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease,
        CoreLibrary.InterestRateMode _currentRateMode
    ) internal returns (CoreLibrary.InterestRateMode) {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        CoreLibrary.InterestRateMode newMode = CoreLibrary.InterestRateMode.NONE;

        if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //switch to stable
            newMode = CoreLibrary.InterestRateMode.STABLE;
            user.stableBorrowRate = reserve.currentStableBorrowRate;
            user.lastVariableBorrowCumulativeIndex = 0;
        } else if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {
            newMode = CoreLibrary.InterestRateMode.VARIABLE;
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        } else {
            revert("Invalid interest rate mode received");
        }
        //compounding cumulated interest
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);
        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

        return newMode;
    }

    /**
    * @dev updates the state of the principal reserve as a consequence of a liquidation action.
    * @param _principalReserve the address of the principal reserve that is being repaid
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updatePrincipalReserveStateOnLiquidationInternal(
        address _principalReserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_principalReserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_principalReserve];

        //update principal reserve data
        reserve.updateCumulativeIndexes();

        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(
            _principalReserve,
            _user
        );

        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            //increase the total borrows by the compounded interest
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _balanceIncrease,
                user.stableBorrowRate
            );

            //decrease by the actual amount to liquidate
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _amountToLiquidate,
                user.stableBorrowRate
            );

        } else {
            //increase the total borrows by the compounded interest
            reserve.increaseTotalBorrowsVariable(_balanceIncrease);

            //decrease by the actual amount to liquidate
            reserve.decreaseTotalBorrowsVariable(_amountToLiquidate);
        }

    }

    /**
    * @dev updates the state of the collateral reserve as a consequence of a liquidation action.
    * @param _collateralReserve the address of the collateral reserve that is being liquidated
    **/
    function updateCollateralReserveStateOnLiquidationInternal(
        address _collateralReserve
    ) internal {
        //update collateral reserve
        reserves[_collateralReserve].updateCumulativeIndexes();

    }

    /**
    * @dev updates the state of the user being liquidated as a consequence of a liquidation action.
    * @param _reserve the address of the principal reserve that is being repaid
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _feeLiquidated the amount of origination fee being liquidated
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/
    function updateUserStateOnLiquidationInternal(
        address _reserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _feeLiquidated,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        //first increase by the compounded interest, then decrease by the liquidated amount
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(
            _amountToLiquidate
        );

        if (
            getUserCurrentBorrowRateMode(_reserve, _user) == CoreLibrary.InterestRateMode.VARIABLE
        ) {
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        }

        if(_feeLiquidated > 0){
            user.originationFee = user.originationFee.sub(_feeLiquidated);
        }

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);
    }

    /**
    * @dev updates the state of the reserve as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateReserveStateOnRebalanceInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        reserve.updateCumulativeIndexes();

        reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
            _balanceIncrease,
            user.stableBorrowRate
        );

    }

    /**
    * @dev updates the state of the user as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateUserStateOnRebalanceInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);
        user.stableBorrowRate = reserve.currentStableBorrowRate;

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);
    }

    /**
    * @dev updates the state of the user as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _amountBorrowed the accrued interest on the borrowed amount
    **/
    function updateReserveTotalBorrowsByRateModeInternal(
        address _reserve,
        address _user,
        uint256 _principalBalance,
        uint256 _balanceIncrease,
        uint256 _amountBorrowed,
        CoreLibrary.InterestRateMode _newBorrowRateMode
    ) internal {
        CoreLibrary.InterestRateMode previousRateMode = getUserCurrentBorrowRateMode(
            _reserve,
            _user
        );
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        if (previousRateMode == CoreLibrary.InterestRateMode.STABLE) {
            CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _principalBalance,
                user.stableBorrowRate
            );
        } else if (previousRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            reserve.decreaseTotalBorrowsVariable(_principalBalance);
        }

        uint256 newPrincipalAmount = _principalBalance.add(_balanceIncrease).add(_amountBorrowed);
        if (_newBorrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                newPrincipalAmount,
                reserve.currentStableBorrowRate
            );
        } else if (_newBorrowRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            reserve.increaseTotalBorrowsVariable(newPrincipalAmount);
        } else {
            revert("Invalid new borrow rate mode");
        }
    }

    /**
    * @dev Updates the reserve current stable borrow rate Rf, the current variable borrow rate Rv and the current liquidity rate Rl.
    * Also updates the lastUpdateTimestamp value. Please refer to the whitepaper for further information.
    * @param _reserve the address of the reserve to be updated
    * @param _liquidityAdded the amount of liquidity added to the protocol (deposit or repay) in the previous action
    * @param _liquidityTaken the amount of liquidity taken from the protocol (redeem or borrow)
    **/

    function updateReserveInterestRatesAndTimestampInternal(
        address _reserve,
        uint256 _liquidityAdded,
        uint256 _liquidityTaken
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        (uint256 newLiquidityRate, uint256 newStableRate, uint256 newVariableRate) = IReserveInterestRateStrategy(
            reserve
            .interestRateStrategyAddress
        )
        .calculateInterestRates(
            _reserve,
            getReserveAvailableLiquidity(_reserve).add(_liquidityAdded).sub(_liquidityTaken),
            reserve.totalBorrowsStable,
            reserve.totalBorrowsVariable,
            reserve.currentAverageStableBorrowRate
        );

        reserve.currentLiquidityRate = newLiquidityRate;
        reserve.currentStableBorrowRate = newStableRate;
        reserve.currentVariableBorrowRate = newVariableRate;

        //solium-disable-next-line
        reserve.lastUpdateTimestamp = uint40(block.timestamp);

        emit ReserveUpdated(
            _reserve,
            newLiquidityRate,
            newStableRate,
            newVariableRate,
            reserve.lastLiquidityCumulativeIndex,
            reserve.lastVariableBorrowCumulativeIndex
        );
    }

    /**
    * @dev transfers to the protocol fees of a flashloan to the fees collection address
    * @param _token the address of the token being transferred
    * @param _amount the amount being transferred
    **/

    function transferFlashLoanProtocolFeeInternal(address _token, uint256 _amount) internal {
        address payable receiver = address(uint160(addressesProvider.getTokenDistributor()));

        if (_token != EthAddressLib.ethAddress()) {
            ERC20(_token).safeTransfer(receiver, _amount);
        } else {
            receiver.transfer(_amount);
        }
    }

    /**
    * @dev updates the internal configuration of the core
    **/
    function refreshConfigInternal() internal {
        lendingPoolAddress = addressesProvider.getLendingPool();
    }

    /**
    * @dev adds a reserve to the array of the reserves address
    **/
    function addReserveToListInternal(address _reserve) internal {
        bool reserveAlreadyAdded = false;
        for (uint256 i = 0; i < reservesList.length; i++)
            if (reservesList[i] == _reserve) {
                reserveAlreadyAdded = true;
            }
        if (!reserveAlreadyAdded) reservesList.push(_reserve);
    }

}
.]

### Summary of Security Vulnerabilities in the LendingPoolCore Contract

1. **Lack of Input Validation**:
   - The contract does not perform adequate checks on input parameters in several functions, such as `updateStateOnDeposit`, `updateStateOnRedeem`, and others. This could lead to unexpected behavior if invalid addresses or amounts are passed.

2. **Reentrancy Vulnerability**:
   - Functions that transfer ETH or tokens (e.g., `transferToUser`, `transferToReserve`) do not implement the Checks-Effects-Interactions pattern, making them susceptible to reentrancy attacks.

3. **Gas Limit Issues**:
   - The use of `.call.value()` with a fixed gas limit (e.g., `gas(50000)`) can lead to failures if the recipient contract requires more gas to execute its logic. This could result in failed transactions and loss of funds.

4. **Potential Integer Overflow/Underflow**:
   - Although the contract uses SafeMath, there are still areas where arithmetic operations could lead to unexpected results if not properly handled, especially in functions that manipulate user balances and reserves.

5. **Access Control Issues**:
   - The `onlyLendingPool` and `onlyLendingPoolConfigurator` modifiers are used to restrict access, but there may be scenarios where unauthorized contracts could gain access if not properly validated.

6. **Lack of Event Emission**:
   - Certain state-changing functions do not emit events, which could hinder tracking and auditing of contract interactions. For example, functions like `setUserUseReserveAsCollateral` and `updateStateOnRepay` should emit events to log significant state changes.

7. **Fallback Function Limitations**:
   - The fallback function only allows contracts to send ETH, which may limit usability for users who want to interact with the contract directly. This could lead to user confusion and potential loss of funds.

8. **Inadequate Handling of Liquidation**:
   - The liquidation process may not adequately protect against scenarios where the collateral value drops significantly, potentially leading to under-collateralized loans.

9. **Uncontrolled Reserve Management**:
   - The ability to add or remove reserves without sufficient checks could lead to the introduction of malicious or poorly designed reserves, affecting the overall integrity of the lending pool.

### Comprehensive Analysis Report

The LendingPoolCore contract exhibits several security vulnerabilities that could potentially compromise the integrity and functionality of the lending protocol. The lack of input validation, particularly in critical functions, poses a risk of unexpected behavior, while the absence of reentrancy protections could lead to significant financial losses.

Moreover, the gas limit issues associated with ETH transfers could result in failed transactions, further complicating user interactions. Although SafeMath is employed, the potential for integer overflow/underflow remains a concern, especially in complex arithmetic operations.

Access control mechanisms, while present, may not be robust enough to prevent unauthorized access, and the lack of event emissions in key functions hampers transparency and auditability. The fallback function's limitations restrict user interactions, and the liquidation process does not adequately safeguard against market volatility.

Lastly, the uncontrolled management of reserves could introduce risks associated with malicious contracts, undermining the entire lending ecosystem. 

In conclusion, it is imperative to address these vulnerabilities through rigorous testing, enhanced input validation, implementation of the Checks-Effects-Interactions pattern, and the introduction of comprehensive event logging. Additionally, a thorough review of access controls and reserve management practices is essential to ensure the security and reliability of the LendingPoolCore contract.

[2024-01-09 04:31:41 INFO] **[Seminar Conclusion]**:

 ### Summary of Security Vulnerabilities in the LendingPoolCore Contract

1. **Lack of Input Validation**:
   - The contract does not perform adequate checks on input parameters in several functions, such as `updateStateOnDeposit`, `updateStateOnRedeem`, and others. This could lead to unexpected behavior if invalid addresses or amounts are passed.

2. **Reentrancy Vulnerability**:
   - Functions that transfer ETH or tokens (e.g., `transferToUser`, `transferToReserve`) do not implement the Checks-Effects-Interactions pattern, making them susceptible to reentrancy attacks.

3. **Gas Limit Issues**:
   - The use of `.call.value()` with a fixed gas limit (e.g., `gas(50000)`) can lead to failures if the recipient contract requires more gas to execute its logic. This could result in failed transactions and loss of funds.

4. **Potential Integer Overflow/Underflow**:
   - Although the contract uses SafeMath, there are still areas where arithmetic operations could lead to unexpected results if not properly handled, especially in functions that manipulate user balances and reserves.

5. **Access Control Issues**:
   - The `onlyLendingPool` and `onlyLendingPoolConfigurator` modifiers are used to restrict access, but there may be scenarios where unauthorized contracts could gain access if not properly validated.

6. **Lack of Event Emission**:
   - Certain state-changing functions do not emit events, which could hinder tracking and auditing of contract interactions. For example, functions like `setUserUseReserveAsCollateral` and `updateStateOnRepay` should emit events to log significant state changes.

7. **Fallback Function Limitations**:
   - The fallback function only allows contracts to send ETH, which may limit usability for users who want to interact with the contract directly. This could lead to user confusion and potential loss of funds.

8. **Inadequate Handling of Liquidation**:
   - The liquidation process may not adequately protect against scenarios where the collateral value drops significantly, potentially leading to under-collateralized loans.

9. **Uncontrolled Reserve Management**:
   - The ability to add or remove reserves without sufficient checks could lead to the introduction of malicious or poorly designed reserves, affecting the overall integrity of the lending pool.

### Comprehensive Analysis Report

The LendingPoolCore contract exhibits several security vulnerabilities that could potentially compromise the integrity and functionality of the lending protocol. The lack of input validation, particularly in critical functions, poses a risk of unexpected behavior, while the absence of reentrancy protections could lead to significant financial losses.

Moreover, the gas limit issues associated with ETH transfers could result in failed transactions, further complicating user interactions. Although SafeMath is employed, the potential for integer overflow/underflow remains a concern, especially in complex arithmetic operations.

Access control mechanisms, while present, may not be robust enough to prevent unauthorized access, and the lack of event emissions in key functions hampers transparency and auditability. The fallback function's limitations restrict user interactions, and the liquidation process does not adequately safeguard against market volatility.

Lastly, the uncontrolled management of reserves could introduce risks associated with malicious contracts, undermining the entire lending ecosystem. 

In conclusion, it is imperative to address these vulnerabilities through rigorous testing, enhanced input validation, implementation of the Checks-Effects-Interactions pattern, and the introduction of comprehensive event logging. Additionally, a thorough review of access controls and reserve management practices is essential to ensure the security and reliability of the LendingPoolCore contract.

[2024-01-09 04:31:41 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 2

[2024-01-09 04:31:42 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | pragma solidity ^0.5.0; import "openzeppelin-solidity/contracts/math/SafeMath.sol"; import "openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol"; import "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol"; import "openzeppelin-solidity/contracts/utils/Address.sol"; import "../libraries/openzeppelin-upgradeability/VersionedInitializable.sol"; import "../libraries/CoreLibrary.sol"; import "../configuration/LendingPoolAddressesProvider.sol"; import "../interfaces/ILendingRateOracle.sol"; import "../interfaces/IReserveInterestRateStrategy.sol"; import "../libraries/WadRayMath.sol"; import "../tokenization/AToken.sol"; import "../libraries/EthAddressLib.sol"; / * @title LendingPoolCore contract * @author Aave * @notice Holds the state of the lending pool and all the funds deposited * @dev NOTE: The core does not enforce security checks on the update of the state * (eg, updateStateOnBorrow() does not enforce that borrowed is enabled on the reserve). * The check that an action can be performed is a duty of the overlying LendingPool contract. / contract LendingPoolCore is VersionedInitializable {     using SafeMath for uint256;     using WadRayMath for uint256;     using CoreLibrary for CoreLibrary.ReserveData;     using CoreLibrary for CoreLibrary.UserReserveData;     using SafeERC20 for ERC20;     using Address for address payable; /** * @dev Emitted when the state of a reserve is updated * @param reserve the address of the reserve * @param liquidityRate the new liquidity rate * @param stableBorrowRate the new stable borrow rate * @param variableBorrowRate the new variable borrow rate * @param liquidityIndex the new liquidity index * @param variableBorrowIndex the new variable borrow index **/ event ReserveUpdated(     address indexed reserve,     uint256 liquidityRate,     uint256 stableBorrowRate,     uint256 variableBorrowRate,     uint256 liquidityIndex,     uint256 variableBorrowIndex );  address public lendingPoolAddress;  LendingPoolAddressesProvider public addressesProvider;  /** * @dev only lending pools can use functions affected by this modifier **/ modifier onlyLendingPool {     require(lendingPoolAddress == msg.sender, "The caller must be a lending pool contract");     _; }  /** * @dev only lending pools configurator can use functions affected by this modifier **/ modifier onlyLendingPoolConfigurator {     require(         addressesProvider.getLendingPoolConfigurator() == msg.sender,         "The caller must be a lending pool configurator contract"     );     _; }  mapping(address =&gt; CoreLibrary.ReserveData) internal reserves; mapping(address =&gt; mapping(address =&gt; CoreLibrary.UserReserveData)) internal usersReserveData;  address[] public reservesList;  uint256 public constant CORE_REVISION = 0x4;  /** * @dev returns the revision number of the contract **/ function getRevision() internal pure returns (uint256) {     return CORE_REVISION; }  /** * @dev initializes the Core contract, invoked upon registration on the AddressesProvider * @param _addressesProvider the addressesProvider contract **/  function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {     addressesProvider = _addressesProvider;     refreshConfigInternal(); }  /** * @dev updates the state of the core as a result of a deposit action * @param _reserve the address of the reserve in which the deposit is happening * @param _user the address of the the user depositing * @param _amount the amount being deposited * @param _isFirstDeposit true if the user is depositing for the first time **/  function updateStateOnDeposit(     address _reserve,     address _user,     uint256 _amount,     bool _isFirstDeposit ) external onlyLendingPool {     reserves[_reserve].updateCumulativeIndexes();     updateReserveInterestRatesAndTimestampInternal(_reserve, _amount, 0);      if (_isFirstDeposit) {         //if this is the first deposit of the user, we configure the deposit as enabled to be used as collateral         setUserUseReserveAsCollateral(_reserve, _user, true);     } }  /** * @dev updates the state of the core as a result of a redeem action * @param _reserve the address of the reserve in which the redeem is happening * @param _user the address of the the user redeeming * @param _amountRedeemed the amount being redeemed * @param _userRedeemedEverything true if the user is redeeming everything **/ function updateStateOnRedeem(     address _reserve,     address _user,     uint256 _amountRedeemed,     bool _userRedeemedEverything ) external onlyLendingPool {     //compound liquidity and variable borrow interests     reserves[_reserve].updateCumulativeIndexes();     updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountRedeemed);      //if user redeemed everything the useReserveAsCollateral flag is reset     if (_userRedeemedEverything) {         setUserUseReserveAsCollateral(_reserve, _user, false);     } }  /** * @dev updates the state of the core as a result of a flashloan action * @param _reserve the address of the reserve in which the flashloan is happening * @param _income the income of the protocol as a result of the action **/ function updateStateOnFlashLoan(     address _reserve,     uint256 _availableLiquidityBefore,     uint256 _income,     uint256 _protocolFee ) external onlyLendingPool {     transferFlashLoanProtocolFeeInternal(_reserve, _protocolFee);      //compounding the cumulated interest     reserves[_reserve].updateCumulativeIndexes();      uint256 totalLiquidityBefore = _availableLiquidityBefore.add(         getReserveTotalBorrows(_reserve)     );      //compounding the received fee into the reserve     reserves[_reserve].cumulateToLiquidityIndex(totalLiquidityBefore, _income);      //refresh interest rates     updateReserveInterestRatesAndTimestampInternal(_reserve, _income, 0); }  /** * @dev updates the state of the core as a consequence of a borrow action. * @param _reserve the address of the reserve on which the user is borrowing * @param _user the address of the borrower * @param _amountBorrowed the new amount borrowed * @param _borrowFee the fee on the amount borrowed * @param _rateMode the borrow rate mode (stable, variable) * @return the new borrow rate for the user **/ function updateStateOnBorrow(     address _reserve,     address _user,     uint256 _amountBorrowed,     uint256 _borrowFee,     CoreLibrary.InterestRateMode _rateMode ) external onlyLendingPool returns (uint256, uint256) {     // getting the previous borrow data of the user     (uint256 principalBorrowBalance, , uint256 balanceIncrease) = getUserBorrowBalances(         _reserve,         _user     );      updateReserveStateOnBorrowInternal(         _reserve,         _user,         principalBorrowBalance,         balanceIncrease,         _amountBorrowed,         _rateMode     );      updateUserStateOnBorrowInternal(         _reserve,         _user,         _amountBorrowed,         balanceIncrease,         _borrowFee,         _rateMode     );      updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountBorrowed);      return (getUserCurrentBorrowRate(_reserve, _user), balanceIncrease); }  /** * @dev updates the state of the core as a consequence of a repay action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _paybackAmountMinusFees the amount being paid back minus fees * @param _originationFeeRepaid the fee on the amount that is being repaid * @param _balanceIncrease the accrued interest on the borrowed amount * @param _repaidWholeLoan true if the user is repaying the whole loan **/  function updateStateOnRepay(     address _reserve,     address _user,     uint256 _paybackAmountMinusFees,     uint256 _originationFeeRepaid,     uint256 _balanceIncrease,     bool _repaidWholeLoan ) external onlyLendingPool {     updateReserveStateOnRepayInternal(         _reserve,         _user,         _paybackAmountMinusFees,         _balanceIncrease     );     updateUserStateOnRepayInternal(         _reserve,         _user,         _paybackAmountMinusFees,         _originationFeeRepaid,         _balanceIncrease,         _repaidWholeLoan     );      updateReserveInterestRatesAndTimestampInternal(_reserve, _paybackAmountMinusFees, 0); }  /** * @dev updates the state of the core as a consequence of a swap rate action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _principalBorrowBalance the amount borrowed by the user * @param _compoundedBorrowBalance the amount borrowed plus accrued interest * @param _balanceIncrease the accrued interest on the borrowed amount * @param _currentRateMode the current interest rate mode for the user **/ function updateStateOnSwapRate(     address _reserve,     address _user,     uint256 _principalBorrowBalance,     uint256 _compoundedBorrowBalance,     uint256 _balanceIncrease,     CoreLibrary.InterestRateMode _currentRateMode ) external onlyLendingPool returns (CoreLibrary.InterestRateMode, uint256) {     updateReserveStateOnSwapRateInternal(         _reserve,         _user,         _principalBorrowBalance,         _compoundedBorrowBalance,         _currentRateMode     );      CoreLibrary.InterestRateMode newRateMode = updateUserStateOnSwapRateInternal(         _reserve,         _user,         _balanceIncrease,         _currentRateMode     );      updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);      return (newRateMode, getUserCurrentBorrowRate(_reserve, _user)); }  /** * @dev updates the state of the core as a consequence of a liquidation action. * @param _principalReserve the address of the principal reserve that is being repaid * @param _collateralReserve the address of the collateral reserve that is being liquidated * @param _user the address of the borrower * @param _amountToLiquidate the amount being repaid by the liquidator * @param _collateralToLiquidate the amount of collateral being liquidated * @param _feeLiquidated the amount of origination fee being liquidated * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus * @param _balanceIncrease the accrued interest on the borrowed amount * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise **/ function updateStateOnLiquidation(     address _principalReserve,     address _collateralReserve,     address _user,     uint256 _amountToLiquidate,     uint256 _collateralToLiquidate,     uint256 _feeLiquidated,     uint256 _liquidatedCollateralForFee,     uint256 _balanceIncrease,     bool _liquidatorReceivesAToken ) external onlyLendingPool {     updatePrincipalReserveStateOnLiquidationInternal(         _principalReserve,         _user,         _amountToLiquidate,         _balanceIncrease     );      updateCollateralReserveStateOnLiquidationInternal(         _collateralReserve     );      updateUserStateOnLiquidationInternal(         _principalReserve,         _user,         _amountToLiquidate,         _feeLiquidated,         _balanceIncrease     );      updateReserveInterestRatesAndTimestampInternal(_principalReserve, _amountToLiquidate, 0);      if (!_liquidatorReceivesAToken) {         updateReserveInterestRatesAndTimestampInternal(             _collateralReserve,             0,             _collateralToLiquidate.add(_liquidatedCollateralForFee)         );     }  }  /** * @dev updates the state of the core as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount * @return the new stable rate for the user **/ function updateStateOnRebalance(address _reserve, address _user, uint256 _balanceIncrease) external onlyLendingPool returns (uint256) {     updateReserveStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);      //update user data and rebalance the rate     updateUserStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);     updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);     return usersReserveData[_user][_reserve].stableBorrowRate; }  /** * @dev enables or disables a reserve as collateral * @param _reserve the address of the principal reserve where the user deposited * @param _user the address of the depositor * @param _useAsCollateral true if the depositor wants to use the reserve as collateral **/ function setUserUseReserveAsCollateral(address _reserve, address _user, bool _useAsCollateral) public onlyLendingPool {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     user.useAsCollateral = _useAsCollateral; }  /** * @notice ETH/token transfer functions **/  /** * @dev fallback function enforces that the caller is a contract, to support flashloan transfers **/ function() external payable {     //only contracts can send ETH to the core     require(msg.sender.isContract(), "Only contracts can send ether to the Lending pool core");  }  /** * @dev transfers to the user a specific amount from the reserve. * @param _reserve the address of the reserve where the transfer is happening * @param _user the address of the user receiving the transfer * @param _amount the amount being transferred **/ function transferToUser(address _reserve, address payable _user, uint256 _amount) external onlyLendingPool {     if (_reserve != EthAddressLib.ethAddress()) {         ERC20(_reserve).safeTransfer(_user, _amount);     } else {         //solium-disable-next-line         (bool result, ) = _user.call.value(_amount).gas(50000)("");         require(result, "Transfer of ETH failed");     } }  /** * @dev transfers the protocol fees to the fees collection address * @param _token the address of the token being transferred * @param _user the address of the user from where the transfer is happening * @param _amount the amount being transferred * @param _destination the fee receiver address **/  function transferToFeeCollectionAddress(     address _token,     address _user,     uint256 _amount,     address _destination ) external payable onlyLendingPool {     address payable feeAddress = address(uint160(_destination)); //cast the address to payable      if (_token != EthAddressLib.ethAddress()) {         require(             msg.value == 0,             "User is sending ETH along with the ERC20 transfer. Check the value attribute of the transaction"         );         ERC20(_token).safeTransferFrom(_user, feeAddress, _amount);     } else {         require(msg.value &gt;= _amount, "The amount and the value sent to deposit do not match");         //solium-disable-next-line         (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");         require(result, "Transfer of ETH failed");     } }  /** * @dev transfers the fees to the fees collection address in the case of liquidation * @param _token the address of the token being transferred * @param _amount the amount being transferred * @param _destination the fee receiver address **/ function liquidateFee(     address _token,     uint256 _amount,     address _destination ) external payable onlyLendingPool {     address payable feeAddress = address(uint160(_destination)); //cast the address to payable     require(         msg.value == 0,         "Fee liquidation does not require any transfer of value"     );      if (_token != EthAddressLib.ethAddress()) {         ERC20(_token).safeTransfer(feeAddress, _amount);     } else {         //solium-disable-next-line         (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");         require(result, "Transfer of ETH failed");     } }  /** * @dev transfers an amount from a user to the destination reserve * @param _reserve the address of the reserve where the amount is being transferred * @param _user the address of the user from where the transfer is happening * @param _amount the amount being transferred **/ function transferToReserve(address _reserve, address payable _user, uint256 _amount) external payable onlyLendingPool {     if (_reserve != EthAddressLib.ethAddress()) {         require(msg.value == 0, "User is sending ETH along with the ERC20 transfer.");         ERC20(_reserve).safeTransferFrom(_user, address(this), _amount);      } else {         require(msg.value &gt;= _amount, "The amount and the value sent to deposit do not match");          if (msg.value &gt; _amount) {             //send back excess ETH             uint256 excessAmount = msg.value.sub(_amount);             //solium-disable-next-line             (bool result, ) = _user.call.value(excessAmount).gas(50000)("");             require(result, "Transfer of ETH failed");         }     } }  /** * @notice data access functions **/  /** * @dev returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral) * needed to calculate the global account data in the LendingPoolDataProvider * @param _reserve the address of the reserve * @param _user the address of the user * @return the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not **/ function getUserBasicReserveData(address _reserve, address _user) external view returns (uint256, uint256, uint256, bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      uint256 underlyingBalance = getUserUnderlyingAssetBalance(_reserve, _user);      if (user.principalBorrowBalance == 0) {         return (underlyingBalance, 0, 0, user.useAsCollateral);     }      return (     underlyingBalance,     user.getCompoundedBorrowBalance(reserve),     user.originationFee,     user.useAsCollateral     ); }  /** * @dev checks if a user is allowed to borrow at a stable rate * @param _reserve the reserve address * @param _user the user * @param _amount the amount the the user wants to borrow * @return true if the user is allowed to borrow at a stable rate, false otherwise **/  function isUserAllowedToBorrowAtStable(address _reserve, address _user, uint256 _amount) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      if (!reserve.isStableBorrowRateEnabled) return false;      return     !user.useAsCollateral ||     !reserve.usageAsCollateralEnabled ||     _amount &gt; getUserUnderlyingAssetBalance(_reserve, _user); }  /** * @dev gets the underlying asset balance of a user based on the corresponding aToken balance. * @param _reserve the reserve address * @param _user the user address * @return the underlying deposit balance of the user **/  function getUserUnderlyingAssetBalance(address _reserve, address _user) public view returns (uint256) {     AToken aToken = AToken(reserves[_reserve].aTokenAddress);     return aToken.balanceOf(_user);  }  /** * @dev gets the interest rate strategy contract address for the reserve * @param _reserve the reserve address * @return the address of the interest rate strategy contract **/ function getReserveInterestRateStrategyAddress(address _reserve) public view returns (address) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.interestRateStrategyAddress; }  /** * @dev gets the aToken contract address for the reserve * @param _reserve the reserve address * @return the address of the aToken contract **/  function getReserveATokenAddress(address _reserve) public view returns (address) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.aTokenAddress; }  /** * @dev gets the available liquidity in the reserve. The available liquidity is the balance of the core contract * @param _reserve the reserve address * @return the available liquidity **/ function getReserveAvailableLiquidity(address _reserve) public view returns (uint256) {     uint256 balance = 0;      if (_reserve == EthAddressLib.ethAddress()) {         balance = address(this).balance;     } else {         balance = IERC20(_reserve).balanceOf(address(this));     }     return balance; }  /** * @dev gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows * @param _reserve the reserve address * @return the total liquidity **/ function getReserveTotalLiquidity(address _reserve) public view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return getReserveAvailableLiquidity(_reserve).add(reserve.getTotalBorrows()); }  /** * @dev gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there * there has been 100% income. * @param _reserve the reserve address * @return the reserve normalized income **/ function getReserveNormalizedIncome(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.getNormalizedIncome(); }  /** * @dev gets the reserve total borrows * @param _reserve the reserve address * @return the total borrows (stable + variable) **/ function getReserveTotalBorrows(address _reserve) public view returns (uint256) {     return reserves[_reserve].getTotalBorrows(); }  /** * @dev gets the reserve total borrows stable * @param _reserve the reserve address * @return the total borrows stable **/ function getReserveTotalBorrowsStable(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.totalBorrowsStable; }  /** * @dev gets the reserve total borrows variable * @param _reserve the reserve address * @return the total borrows variable **/  function getReserveTotalBorrowsVariable(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.totalBorrowsVariable; }  /** * @dev gets the reserve liquidation threshold * @param _reserve the reserve address * @return the reserve liquidation threshold **/  function getReserveLiquidationThreshold(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.liquidationThreshold; }  /** * @dev gets the reserve liquidation bonus * @param _reserve the reserve address * @return the reserve liquidation bonus **/  function getReserveLiquidationBonus(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.liquidationBonus; }  /** * @dev gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty * @param _reserve the reserve address * @return the reserve current variable borrow rate **/  function getReserveCurrentVariableBorrowRate(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      if (reserve.currentVariableBorrowRate == 0) {         return         IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)         .getBaseVariableBorrowRate();     }     return reserve.currentVariableBorrowRate; }  /** * @dev gets the reserve current stable borrow rate. Is the market rate if the reserve is empty * @param _reserve the reserve address * @return the reserve current stable borrow rate **/  function getReserveCurrentStableBorrowRate(address _reserve) public view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     ILendingRateOracle oracle = ILendingRateOracle(addressesProvider.getLendingRateOracle());      if (reserve.currentStableBorrowRate == 0) {         //no stable rate borrows yet         return oracle.getMarketBorrowRate(_reserve);     }      return reserve.currentStableBorrowRate; }  /** * @dev gets the reserve average stable borrow rate. The average stable rate is the weighted average * of all the loans taken at stable rate. * @param _reserve the reserve address * @return the reserve current average borrow rate **/ function getReserveCurrentAverageStableBorrowRate(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.currentAverageStableBorrowRate; }  /** * @dev gets the reserve liquidity rate * @param _reserve the reserve address * @return the reserve liquidity rate **/ function getReserveCurrentLiquidityRate(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.currentLiquidityRate; }  /** * @dev gets the reserve liquidity cumulative index * @param _reserve the reserve address * @return the reserve liquidity cumulative index **/ function getReserveLiquidityCumulativeIndex(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.lastLiquidityCumulativeIndex; }  /** * @dev gets the reserve variable borrow index * @param _reserve the reserve address * @return the reserve variable borrow index **/ function getReserveVariableBorrowsCumulativeIndex(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.lastVariableBorrowCumulativeIndex; }  /** * @dev this function aggregates the configuration parameters of the reserve. * It's used in the LendingPoolDataProvider specifically to save gas, and avoid * multiple external contract calls to fetch the same data. * @param _reserve the reserve address * @return the reserve decimals * @return the base ltv as collateral * @return the liquidation threshold * @return if the reserve is used as collateral or not **/ function getReserveConfiguration(address _reserve) external view returns (uint256, uint256, uint256, bool) {     uint256 decimals;     uint256 baseLTVasCollateral;     uint256 liquidationThreshold;     bool usageAsCollateralEnabled;      CoreLibrary.ReserveData storage reserve = reserves[_reserve];     decimals = reserve.decimals;     baseLTVasCollateral = reserve.baseLTVasCollateral;     liquidationThreshold = reserve.liquidationThreshold;     usageAsCollateralEnabled = reserve.usageAsCollateralEnabled;      return (decimals, baseLTVasCollateral, liquidationThreshold, usageAsCollateralEnabled); }  /** * @dev returns the decimals of the reserve * @param _reserve the reserve address * @return the reserve decimals **/ function getReserveDecimals(address _reserve) external view returns (uint256) {     return reserves[_reserve].decimals; }  /** * @dev returns true if the reserve is enabled for borrowing * @param _reserve the reserve address * @return true if the reserve is enabled for borrowing, false otherwise **/  function isReserveBorrowingEnabled(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.borrowingEnabled; }  /** * @dev returns true if the reserve is enabled as collateral * @param _reserve the reserve address * @return true if the reserve is enabled as collateral, false otherwise **/  function isReserveUsageAsCollateralEnabled(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.usageAsCollateralEnabled; }  /** * @dev returns true if the stable rate is enabled on reserve * @param _reserve the reserve address * @return true if the stable rate is enabled on reserve, false otherwise **/ function getReserveIsStableBorrowRateEnabled(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.isStableBorrowRateEnabled; }  /** * @dev returns true if the reserve is active * @param _reserve the reserve address * @return true if the reserve is active, false otherwise **/ function getReserveIsActive(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.isActive; }  /** * @notice returns if a reserve is freezed * @param _reserve the reserve for which the information is needed * @return true if the reserve is freezed, false otherwise **/  function getReserveIsFreezed(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.isFreezed; }  /** * @notice returns the timestamp of the last action on the reserve * @param _reserve the reserve for which the information is needed * @return the last updated timestamp of the reserve **/  function getReserveLastUpdate(address _reserve) external view returns (uint40 timestamp) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     timestamp = reserve.lastUpdateTimestamp; }  /** * @dev returns the utilization rate U of a specific reserve * @param _reserve the reserve for which the information is needed * @return the utilization rate in ray **/  function getReserveUtilizationRate(address _reserve) public view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      uint256 totalBorrows = reserve.getTotalBorrows();      if (totalBorrows == 0) {         return 0;     }      uint256 availableLiquidity = getReserveAvailableLiquidity(_reserve);      return totalBorrows.rayDiv(availableLiquidity.add(totalBorrows)); }  /** * @return the array of reserves configured on the core **/ function getReserves() external view returns (address[] memory) {     return reservesList; }  /** * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return true if the user has chosen to use the reserve as collateral, false otherwise **/ function isUserUseReserveAsCollateralEnabled(address _reserve, address _user) external view returns (bool) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.useAsCollateral; }  /** * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the origination fee for the user **/ function getUserOriginationFee(address _reserve, address _user) external view returns (uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.originationFee; }  /** * @dev users with no loans in progress have NONE as borrow rate mode * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the borrow rate mode for the user, **/  function getUserCurrentBorrowRateMode(address _reserve, address _user) public view returns (CoreLibrary.InterestRateMode) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      if (user.principalBorrowBalance == 0) {         return CoreLibrary.InterestRateMode.NONE;     }      return     user.stableBorrowRate &gt; 0     ? CoreLibrary.InterestRateMode.STABLE     : CoreLibrary.InterestRateMode.VARIABLE; }  /** * @dev gets the current borrow rate of the user * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the borrow rate for the user, **/ function getUserCurrentBorrowRate(address _reserve, address _user) internal view returns (uint256) {     CoreLibrary.InterestRateMode rateMode = getUserCurrentBorrowRateMode(_reserve, _user);      if (rateMode == CoreLibrary.InterestRateMode.NONE) {         return 0;     }      return     rateMode == CoreLibrary.InterestRateMode.STABLE     ? usersReserveData[_user][_reserve].stableBorrowRate     : reserves[_reserve].currentVariableBorrowRate; }  /** * @dev the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the user stable rate **/ function getUserCurrentStableBorrowRate(address _reserve, address _user) external view returns (uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.stableBorrowRate; }  /** * @dev calculates and returns the borrow balances of the user * @param _reserve the address of the reserve * @param _user the address of the user * @return the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance **/  function getUserBorrowBalances(address _reserve, address _user) public view returns (uint256, uint256, uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     if (user.principalBorrowBalance == 0) {         return (0, 0, 0);     }      uint256 principal = user.principalBorrowBalance;     uint256 compoundedBalance = CoreLibrary.getCompoundedBorrowBalance(         user,         reserves[_reserve]     );     return (principal, compoundedBalance, compoundedBalance.sub(principal)); }  /** * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the variable borrow index for the user **/  function getUserVariableBorrowCumulativeIndex(address _reserve, address _user) external view returns (uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.lastVariableBorrowCumulativeIndex; }  /** * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the variable borrow index for the user **/  function getUserLastUpdate(address _reserve, address _user) external view returns (uint256 timestamp) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     timestamp = user.lastUpdateTimestamp; }  /** * @dev updates the lending pool core configuration **/ function refreshConfiguration() external onlyLendingPoolConfigurator {     refreshConfigInternal(); }  /** * @dev initializes a reserve * @param _reserve the address of the reserve * @param _aTokenAddress the address of the overlying aToken contract * @param _decimals the decimals of the reserve currency * @param _interestRateStrategyAddress the address of the interest rate strategy contract **/ function initReserve(     address _reserve,     address _aTokenAddress,     uint256 _decimals,     address _interestRateStrategyAddress ) external onlyLendingPoolConfigurator {     reserves[_reserve].init(_aTokenAddress, _decimals, _interestRateStrategyAddress);     addReserveToListInternal(_reserve);  }    /** * @dev removes the last added reserve in the reservesList array * @param _reserveToRemove the address of the reserve **/ function removeLastAddedReserve(address _reserveToRemove) external onlyLendingPoolConfigurator {      address lastReserve = reservesList[reservesList.length-1];      require(lastReserve == _reserveToRemove, "Reserve being removed is different than the reserve requested");      //as we can't check if totalLiquidity is 0 (since the reserve added might not be an ERC20) we at least check that there is nothing borrowed     require(getReserveTotalBorrows(lastReserve) == 0, "Cannot remove a reserve with liquidity deposited");      reserves[lastReserve].isActive = false;     reserves[lastReserve].aTokenAddress = address(0);     reserves[lastReserve].decimals = 0;     reserves[lastReserve].lastLiquidityCumulativeIndex = 0;     reserves[lastReserve].lastVariableBorrowCumulativeIndex = 0;     reserves[lastReserve].borrowingEnabled = false;     reserves[lastReserve].usageAsCollateralEnabled = false;     reserves[lastReserve].baseLTVasCollateral = 0;     reserves[lastReserve].liquidationThreshold = 0;     reserves[lastReserve].liquidationBonus = 0;     reserves[lastReserve].interestRateStrategyAddress = address(0);      reservesList.pop(); }  /** * @dev updates the address of the interest rate strategy contract * @param _reserve the address of the reserve * @param _rateStrategyAddress the address of the interest rate strategy contract **/  function setReserveInterestRateStrategyAddress(address _reserve, address _rateStrategyAddress) external onlyLendingPoolConfigurator {     reserves[_reserve].interestRateStrategyAddress = _rateStrategyAddress; }  /** * @dev enables borrowing on a reserve. Also sets the stable rate borrowing * @param _reserve the address of the reserve * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise **/  function enableBorrowingOnReserve(address _reserve, bool _stableBorrowRateEnabled) external onlyLendingPoolConfigurator {     reserves[_reserve].enableBorrowing(_stableBorrowRateEnabled); }  /** * @dev disables borrowing on a reserve * @param _reserve the address of the reserve **/  function disableBorrowingOnReserve(address _reserve) external onlyLendingPoolConfigurator {     reserves[_reserve].disableBorrowing(); }  /** * @dev enables a reserve to be used as collateral * @param _reserve the address of the reserve **/ function enableReserveAsCollateral(     address _reserve,     uint256 _baseLTVasCollateral,     uint256 _liquidationThreshold,     uint256 _liquidationBonus ) external onlyLendingPoolConfigurator {     reserves[_reserve].enableAsCollateral(         _baseLTVasCollateral,         _liquidationThreshold,         _liquidationBonus     ); }  /** * @dev disables a reserve to be used as collateral * @param _reserve the address of the reserve **/ function disableReserveAsCollateral(address _reserve) external onlyLendingPoolConfigurator {     reserves[_reserve].disableAsCollateral(); }  /** * @dev enable the stable borrow rate mode on a reserve * @param _reserve the address of the reserve **/ function enableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isStableBorrowRateEnabled = true; }  /** * @dev disable the stable borrow rate mode on a reserve * @param _reserve the address of the reserve **/ function disableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isStableBorrowRateEnabled = false; }  /** * @dev activates a reserve * @param _reserve the address of the reserve **/ function activateReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      require(         reserve.lastLiquidityCumulativeIndex &gt; 0 &amp;&amp;         reserve.lastVariableBorrowCumulativeIndex &gt; 0,         "Reserve has not been initialized yet"     );     reserve.isActive = true; }  /** * @dev deactivates a reserve * @param _reserve the address of the reserve **/ function deactivateReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isActive = false; }  /** * @notice allows the configurator to freeze the reserve. * A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance. * @param _reserve the address of the reserve **/ function freezeReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isFreezed = true; }  /** * @notice allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed. * @param _reserve the address of the reserve **/ function unfreezeReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isFreezed = false; }  /** * @notice allows the configurator to update the loan to value of a reserve * @param _reserve the address of the reserve * @param _ltv the new loan to value **/ function setReserveBaseLTVasCollateral(address _reserve, uint256 _ltv) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.baseLTVasCollateral = _ltv; }  /** * @notice allows the configurator to update the liquidation threshold of a reserve * @param _reserve the address of the reserve * @param _threshold the new liquidation threshold **/ function setReserveLiquidationThreshold(address _reserve, uint256 _threshold) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.liquidationThreshold = _threshold; }  /** * @notice allows the configurator to update the liquidation bonus of a reserve * @param _reserve the address of the reserve * @param _bonus the new liquidation bonus **/ function setReserveLiquidationBonus(address _reserve, uint256 _bonus) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.liquidationBonus = _bonus; }  /** * @notice allows the configurator to update the reserve decimals * @param _reserve the address of the reserve * @param _decimals the decimals of the reserve **/ function setReserveDecimals(address _reserve, uint256 _decimals) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.decimals = _decimals; }  /** * @notice internal functions **/  /** * @dev updates the state of a reserve as a consequence of a borrow action. * @param _reserve the address of the reserve on which the user is borrowing * @param _user the address of the borrower * @param _principalBorrowBalance the previous borrow balance of the borrower before the action * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount * @param _amountBorrowed the new amount borrowed * @param _rateMode the borrow rate mode (stable, variable) **/  function updateReserveStateOnBorrowInternal(     address _reserve,     address _user,     uint256 _principalBorrowBalance,     uint256 _balanceIncrease,     uint256 _amountBorrowed,     CoreLibrary.InterestRateMode _rateMode ) internal {     reserves[_reserve].updateCumulativeIndexes();      //increasing reserve total borrows to account for the new borrow balance of the user     //NOTE: Depending on the previous borrow mode, the borrows might need to be switched from variable to stable or vice versa      updateReserveTotalBorrowsByRateModeInternal(         _reserve,         _user,         _principalBorrowBalance,         _balanceIncrease,         _amountBorrowed,         _rateMode     ); }  /** * @dev updates the state of a user as a consequence of a borrow action. * @param _reserve the address of the reserve on which the user is borrowing * @param _user the address of the borrower * @param _amountBorrowed the amount borrowed * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount * @param _rateMode the borrow rate mode (stable, variable) * @return the final borrow rate for the user. Emitted by the borrow() event **/  function updateUserStateOnBorrowInternal(     address _reserve,     address _user,     uint256 _amountBorrowed,     uint256 _balanceIncrease,     uint256 _fee,     CoreLibrary.InterestRateMode _rateMode ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      if (_rateMode == CoreLibrary.InterestRateMode.STABLE) {         //stable         //reset the user variable index, and update the stable rate         user.stableBorrowRate = reserve.currentStableBorrowRate;         user.lastVariableBorrowCumulativeIndex = 0;     } else if (_rateMode == CoreLibrary.InterestRateMode.VARIABLE) {         //variable         //reset the user stable rate, and store the new borrow index         user.stableBorrowRate = 0;         user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;     } else {         revert("Invalid borrow rate mode");     }     //increase the principal borrows and the origination fee     user.principalBorrowBalance = user.principalBorrowBalance.add(_amountBorrowed).add(         _balanceIncrease     );     user.originationFee = user.originationFee.add(_fee);      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp);  }  /** * @dev updates the state of the reserve as a consequence of a repay action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _paybackAmountMinusFees the amount being paid back minus fees * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updateReserveStateOnRepayInternal(     address _reserve,     address _user,     uint256 _paybackAmountMinusFees,     uint256 _balanceIncrease ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_reserve][_user];      CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(_reserve, _user);      //update the indexes     reserves[_reserve].updateCumulativeIndexes();      //compound the cumulated interest to the borrow balance and then subtracting the payback amount     if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             _balanceIncrease,             user.stableBorrowRate         );         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _paybackAmountMinusFees,             user.stableBorrowRate         );     } else {         reserve.increaseTotalBorrowsVariable(_balanceIncrease);         reserve.decreaseTotalBorrowsVariable(_paybackAmountMinusFees);     } }  /** * @dev updates the state of the user as a consequence of a repay action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _paybackAmountMinusFees the amount being paid back minus fees * @param _originationFeeRepaid the fee on the amount that is being repaid * @param _balanceIncrease the accrued interest on the borrowed amount * @param _repaidWholeLoan true if the user is repaying the whole loan **/ function updateUserStateOnRepayInternal(     address _reserve,     address _user,     uint256 _paybackAmountMinusFees,     uint256 _originationFeeRepaid,     uint256 _balanceIncrease,     bool _repaidWholeLoan ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      //update the user principal borrow balance, adding the cumulated interest and then subtracting the payback amount     user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(         _paybackAmountMinusFees     );     user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;      //if the balance decrease is equal to the previous principal (user is repaying the whole loan)     //and the rate mode is stable, we reset the interest rate mode of the user     if (_repaidWholeLoan) {         user.stableBorrowRate = 0;         user.lastVariableBorrowCumulativeIndex = 0;     }     user.originationFee = user.originationFee.sub(_originationFeeRepaid);      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp);  }  /** * @dev updates the state of the user as a consequence of a swap rate action. * @param _reserve the address of the reserve on which the user is performing the rate swap * @param _user the address of the borrower * @param _principalBorrowBalance the the principal amount borrowed by the user * @param _compoundedBorrowBalance the principal amount plus the accrued interest * @param _currentRateMode the rate mode at which the user borrowed **/ function updateReserveStateOnSwapRateInternal(     address _reserve,     address _user,     uint256 _principalBorrowBalance,     uint256 _compoundedBorrowBalance,     CoreLibrary.InterestRateMode _currentRateMode ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      //compounding reserve indexes     reserve.updateCumulativeIndexes();      if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {         uint256 userCurrentStableRate = user.stableBorrowRate;          //swap to variable         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _principalBorrowBalance,             userCurrentStableRate         ); //decreasing stable from old principal balance         reserve.increaseTotalBorrowsVariable(_compoundedBorrowBalance); //increase variable borrows     } else if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         //swap to stable         uint256 currentStableRate = reserve.currentStableBorrowRate;         reserve.decreaseTotalBorrowsVariable(_principalBorrowBalance);         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             _compoundedBorrowBalance,             currentStableRate         );      } else {         revert("Invalid rate mode received");     } }  /** * @dev updates the state of the user as a consequence of a swap rate action. * @param _reserve the address of the reserve on which the user is performing the swap * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount * @param _currentRateMode the current rate mode of the user **/  function updateUserStateOnSwapRateInternal(     address _reserve,     address _user,     uint256 _balanceIncrease,     CoreLibrary.InterestRateMode _currentRateMode ) internal returns (CoreLibrary.InterestRateMode) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      CoreLibrary.InterestRateMode newMode = CoreLibrary.InterestRateMode.NONE;      if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         //switch to stable         newMode = CoreLibrary.InterestRateMode.STABLE;         user.stableBorrowRate = reserve.currentStableBorrowRate;         user.lastVariableBorrowCumulativeIndex = 0;     } else if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {         newMode = CoreLibrary.InterestRateMode.VARIABLE;         user.stableBorrowRate = 0;         user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;     } else {         revert("Invalid interest rate mode received");     }     //compounding cumulated interest     user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);     //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp);      return newMode; }  /** * @dev updates the state of the principal reserve as a consequence of a liquidation action. * @param _principalReserve the address of the principal reserve that is being repaid * @param _user the address of the borrower * @param _amountToLiquidate the amount being repaid by the liquidator * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updatePrincipalReserveStateOnLiquidationInternal(     address _principalReserve,     address _user,     uint256 _amountToLiquidate,     uint256 _balanceIncrease ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_principalReserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_principalReserve];      //update principal reserve data     reserve.updateCumulativeIndexes();      CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(         _principalReserve,         _user     );      if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {         //increase the total borrows by the compounded interest         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             _balanceIncrease,             user.stableBorrowRate         );          //decrease by the actual amount to liquidate         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _amountToLiquidate,             user.stableBorrowRate         );      } else {         //increase the total borrows by the compounded interest         reserve.increaseTotalBorrowsVariable(_balanceIncrease);          //decrease by the actual amount to liquidate         reserve.decreaseTotalBorrowsVariable(_amountToLiquidate);     }  }  /** * @dev updates the state of the collateral reserve as a consequence of a liquidation action. * @param _collateralReserve the address of the collateral reserve that is being liquidated **/ function updateCollateralReserveStateOnLiquidationInternal(     address _collateralReserve ) internal {     //update collateral reserve     reserves[_collateralReserve].updateCumulativeIndexes();  }  /** * @dev updates the state of the user being liquidated as a consequence of a liquidation action. * @param _reserve the address of the principal reserve that is being repaid * @param _user the address of the borrower * @param _amountToLiquidate the amount being repaid by the liquidator * @param _feeLiquidated the amount of origination fee being liquidated * @param _balanceIncrease the accrued interest on the borrowed amount **/ function updateUserStateOnLiquidationInternal(     address _reserve,     address _user,     uint256 _amountToLiquidate,     uint256 _feeLiquidated,     uint256 _balanceIncrease ) internal {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     //first increase by the compounded interest, then decrease by the liquidated amount     user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(         _amountToLiquidate     );      if (         getUserCurrentBorrowRateMode(_reserve, _user) == CoreLibrary.InterestRateMode.VARIABLE     ) {         user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;     }      if(_feeLiquidated &gt; 0){         user.originationFee = user.originationFee.sub(_feeLiquidated);     }      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp); }  /** * @dev updates the state of the reserve as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updateReserveStateOnRebalanceInternal(     address _reserve,     address _user,     uint256 _balanceIncrease ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      reserve.updateCumulativeIndexes();      reserve.increaseTotalBorrowsStableAndUpdateAverageRate(         _balanceIncrease,         user.stableBorrowRate     );  }  /** * @dev updates the state of the user as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updateUserStateOnRebalanceInternal(     address _reserve,     address _user,     uint256 _balanceIncrease ) internal {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);     user.stableBorrowRate = reserve.currentStableBorrowRate;      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp); }  /** * @dev updates the state of the user as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount * @param _amountBorrowed the accrued interest on the borrowed amount **/ function updateReserveTotalBorrowsByRateModeInternal(     address _reserve,     address _user,     uint256 _principalBalance,     uint256 _balanceIncrease,     uint256 _amountBorrowed,     CoreLibrary.InterestRateMode _newBorrowRateMode ) internal {     CoreLibrary.InterestRateMode previousRateMode = getUserCurrentBorrowRateMode(         _reserve,         _user     );     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      if (previousRateMode == CoreLibrary.InterestRateMode.STABLE) {         CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _principalBalance,             user.stableBorrowRate         );     } else if (previousRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         reserve.decreaseTotalBorrowsVariable(_principalBalance);     }      uint256 newPrincipalAmount = _principalBalance.add(_balanceIncrease).add(_amountBorrowed);     if (_newBorrowRateMode == CoreLibrary.InterestRateMode.STABLE) {         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             newPrincipalAmount,             reserve.currentStableBorrowRate         );     } else if (_newBorrowRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         reserve.increaseTotalBorrowsVariable(newPrincipalAmount);     } else {         revert("Invalid new borrow rate mode");     } }  /** * @dev Updates the reserve current stable borrow rate Rf, the current variable borrow rate Rv and the current liquidity rate Rl. * Also updates the lastUpdateTimestamp value. Please refer to the whitepaper for further information. * @param _reserve the address of the reserve to be updated * @param _liquidityAdded the amount of liquidity added to the protocol (deposit or repay) in the previous action * @param _liquidityTaken the amount of liquidity taken from the protocol (redeem or borrow) **/  function updateReserveInterestRatesAndTimestampInternal(     address _reserve,     uint256 _liquidityAdded,     uint256 _liquidityTaken ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     (uint256 newLiquidityRate, uint256 newStableRate, uint256 newVariableRate) = IReserveInterestRateStrategy(         reserve         .interestRateStrategyAddress     )     .calculateInterestRates(         _reserve,         getReserveAvailableLiquidity(_reserve).add(_liquidityAdded).sub(_liquidityTaken),         reserve.totalBorrowsStable,         reserve.totalBorrowsVariable,         reserve.currentAverageStableBorrowRate     );      reserve.currentLiquidityRate = newLiquidityRate;     reserve.currentStableBorrowRate = newStableRate;     reserve.currentVariableBorrowRate = newVariableRate;      //solium-disable-next-line     reserve.lastUpdateTimestamp = uint40(block.timestamp);      emit ReserveUpdated(         _reserve,         newLiquidityRate,         newStableRate,         newVariableRate,         reserve.lastLiquidityCumulativeIndex,         reserve.lastVariableBorrowCumulativeIndex     ); }  /** * @dev transfers to the protocol fees of a flashloan to the fees collection address * @param _token the address of the token being transferred * @param _amount the amount being transferred **/  function transferFlashLoanProtocolFeeInternal(address _token, uint256 _amount) internal {     address payable receiver = address(uint160(addressesProvider.getTokenDistributor()));      if (_token != EthAddressLib.ethAddress()) {         ERC20(_token).safeTransfer(receiver, _amount);     } else {         receiver.transfer(_amount);     } }  /** * @dev updates the internal configuration of the core **/ function refreshConfigInternal() internal {     lendingPoolAddress = addressesProvider.getLendingPool(); }  /** * @dev adds a reserve to the array of the reserves address **/ function addReserveToListInternal(address _reserve) internal {     bool reserveAlreadyAdded = false;     for (uint256 i = 0; i &lt; reservesList.length; i++)         if (reservesList[i] == _reserve) {             reserveAlreadyAdded = true;         }     if (!reserveAlreadyAdded) reservesList.push(_reserve); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': 'pragma solidity ^0.5.0;\n\nimport "openzeppelin-solidity/contracts/math/SafeMath.sol";\nimport "openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol";\nimport "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol";\nimport "openzeppelin-solidity/contracts/utils/Address.sol";\nimport "../libraries/openzeppelin-upgradeability/VersionedInitializable.sol";\n\nimport "../libraries/CoreLibrary.sol";\nimport "../configuration/LendingPoolAddressesProvider.sol";\nimport "../interfaces/ILendingRateOracle.sol";\nimport "../interfaces/IReserveInterestRateStrategy.sol";\nimport "../libraries/WadRayMath.sol";\nimport "../tokenization/AToken.sol";\nimport "../libraries/EthAddressLib.sol";\n\n/\n @title LendingPoolCore contract\n @author Aave\n @notice Holds the state of the lending pool and all the funds deposited\n @dev NOTE: The core does not enforce security checks on the update of the state\n (eg, updateStateOnBorrow() does not enforce that borrowed is enabled on the reserve).\n The check that an action can be performed is a duty of the overlying LendingPool contract.\n/\n\ncontract LendingPoolCore is VersionedInitializable {\n    using SafeMath for uint256;\n    using WadRayMath for uint256;\n    using CoreLibrary for CoreLibrary.ReserveData;\n    using CoreLibrary for CoreLibrary.UserReserveData;\n    using SafeERC20 for ERC20;\n    using Address for address payable;\n\n    /\n    * @dev Emitted when the state of a reserve is updated\n    * @param reserve the address of the reserve\n    * @param liquidityRate the new liquidity rate\n    * @param stableBorrowRate the new stable borrow rate\n    * @param variableBorrowRate the new variable borrow rate\n    * @param liquidityIndex the new liquidity index\n    * @param variableBorrowIndex the new variable borrow index\n    /\n    event ReserveUpdated(\n        address indexed reserve,\n        uint256 liquidityRate,\n        uint256 stableBorrowRate,\n        uint256 variableBorrowRate,\n        uint256 liquidityIndex,\n        uint256 variableBorrowIndex\n    );\n\n    address public lendingPoolAddress;\n\n    LendingPoolAddressesProvider public addressesProvider;\n\n    /\n    * @dev only lending pools can use functions affected by this modifier\n    /\n    modifier onlyLendingPool {\n        require(lendingPoolAddress == msg.sender, "The caller must be a lending pool contract");\n        ;\n    }\n\n    /\n    * @dev only lending pools configurator can use functions affected by this modifier\n    /\n    modifier onlyLendingPoolConfigurator {\n        require(\n            addressesProvider.getLendingPoolConfigurator() == msg.sender,\n            "The caller must be a lending pool configurator contract"\n        );\n        ;\n    }\n\n    mapping(address =&gt; CoreLibrary.ReserveData) internal reserves;\n    mapping(address =&gt; mapping(address =&gt; CoreLibrary.UserReserveData)) internal usersReserveData;\n\n    address[] public reservesList;\n\n    uint256 public constant CORE_REVISION = 0x4;\n\n    /\n    * @dev returns the revision number of the contract\n    /\n    function getRevision() internal pure returns (uint256) {\n        return CORE_REVISION;\n    }\n\n    /\n    * @dev initializes the Core contract, invoked upon registration on the AddressesProvider\n    * @param _addressesProvider the addressesProvider contract\n    /\n\n    function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {\n        addressesProvider = _addressesProvider;\n        refreshConfigInternal();\n    }\n\n    /\n    * @dev updates the state of the core as a result of a deposit action\n    * @param _reserve the address of the reserve in which the deposit is happening\n    * @param _user the address of the the user depositing\n    * @param _amount the amount being deposited\n    * @param _isFirstDeposit true if the user is depositing for the first time\n    /\n\n    function updateStateOnDeposit(\n        address _reserve,\n        address _user,\n        uint256 _amount,\n        bool _isFirstDeposit\n    ) external onlyLendingPool {\n        reserves[_reserve].updateCumulativeIndexes();\n        updateReserveInterestRatesAndTimestampInternal(_reserve, _amount, 0);\n\n        if (_isFirstDeposit) {\n            //if this is the first deposit of the user, we configure the deposit as enabled to be used as collateral\n            setUserUseReserveAsCollateral(_reserve, _user, true);\n        }\n    }\n\n    /\n    * @dev updates the state of the core as a result of a redeem action\n    * @param _reserve the address of the reserve in which the redeem is happening\n    * @param _user the address of the the user redeeming\n    * @param _amountRedeemed the amount being redeemed\n    * @param _userRedeemedEverything true if the user is redeeming everything\n    /\n    function updateStateOnRedeem(\n        address _reserve,\n        address _user,\n        uint256 _amountRedeemed,\n        bool _userRedeemedEverything\n    ) external onlyLendingPool {\n        //compound liquidity and variable borrow interests\n        reserves[_reserve].updateCumulativeIndexes();\n        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountRedeemed);\n\n        //if user redeemed everything the useReserveAsCollateral flag is reset\n        if (_userRedeemedEverything) {\n            setUserUseReserveAsCollateral(_reserve, _user, false);\n        }\n    }\n\n    /\n    * @dev updates the state of the core as a result of a flashloan action\n    * @param _reserve the address of the reserve in which the flashloan is happening\n    * @param _income the income of the protocol as a result of the action\n    /\n    function updateStateOnFlashLoan(\n        address _reserve,\n        uint256 _availableLiquidityBefore,\n        uint256 _income,\n        uint256 _protocolFee\n    ) external onlyLendingPool {\n        transferFlashLoanProtocolFeeInternal(_reserve, _protocolFee);\n\n        //compounding the cumulated interest\n        reserves[_reserve].updateCumulativeIndexes();\n\n        uint256 totalLiquidityBefore = _availableLiquidityBefore.add(\n            getReserveTotalBorrows(_reserve)\n        );\n\n        //compounding the received fee into the reserve\n        reserves[_reserve].cumulateToLiquidityIndex(totalLiquidityBefore, _income);\n\n        //refresh interest rates\n        updateReserveInterestRatesAndTimestampInternal(_reserve, _income, 0);\n    }\n\n    /\n    * @dev updates the state of the core as a consequence of a borrow action.\n    * @param _reserve the address of the reserve on which the user is borrowing\n    * @param _user the address of the borrower\n    * @param _amountBorrowed the new amount borrowed\n    * @param _borrowFee the fee on the amount borrowed\n    * @param _rateMode the borrow rate mode (stable, variable)\n    * @return the new borrow rate for the user\n    /\n    function updateStateOnBorrow(\n        address _reserve,\n        address _user,\n        uint256 _amountBorrowed,\n        uint256 _borrowFee,\n        CoreLibrary.InterestRateMode _rateMode\n    ) external onlyLendingPool returns (uint256, uint256) {\n        // getting the previous borrow data of the user\n        (uint256 principalBorrowBalance, , uint256 balanceIncrease) = getUserBorrowBalances(\n            _reserve,\n            _user\n        );\n\n        updateReserveStateOnBorrowInternal(\n            _reserve,\n            _user,\n            principalBorrowBalance,\n            balanceIncrease,\n            _amountBorrowed,\n            _rateMode\n        );\n\n        updateUserStateOnBorrowInternal(\n            _reserve,\n            _user,\n            _amountBorrowed,\n            balanceIncrease,\n            _borrowFee,\n            _rateMode\n        );\n\n        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountBorrowed);\n\n        return (getUserCurrentBorrowRate(_reserve, _user), balanceIncrease);\n    }\n\n    /\n    * @dev updates the state of the core as a consequence of a repay action.\n    * @param _reserve the address of the reserve on which the user is repaying\n    * @param _user the address of the borrower\n    * @param _paybackAmountMinusFees the amount being paid back minus fees\n    * @param _originationFeeRepaid the fee on the amount that is being repaid\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    * @param _repaidWholeLoan true if the user is repaying the whole loan\n    /\n\n    function updateStateOnRepay(\n        address _reserve,\n        address _user,\n        uint256 _paybackAmountMinusFees,\n        uint256 _originationFeeRepaid,\n        uint256 _balanceIncrease,\n        bool _repaidWholeLoan\n    ) external onlyLendingPool {\n        updateReserveStateOnRepayInternal(\n            _reserve,\n            _user,\n            _paybackAmountMinusFees,\n            _balanceIncrease\n        );\n        updateUserStateOnRepayInternal(\n            _reserve,\n            _user,\n            _paybackAmountMinusFees,\n            _originationFeeRepaid,\n            _balanceIncrease,\n            _repaidWholeLoan\n        );\n\n        updateReserveInterestRatesAndTimestampInternal(_reserve, _paybackAmountMinusFees, 0);\n    }\n\n    /\n    * @dev updates the state of the core as a consequence of a swap rate action.\n    * @param _reserve the address of the reserve on which the user is repaying\n    * @param _user the address of the borrower\n    * @param _principalBorrowBalance the amount borrowed by the user\n    * @param _compoundedBorrowBalance the amount borrowed plus accrued interest\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    * @param _currentRateMode the current interest rate mode for the user\n    /\n    function updateStateOnSwapRate(\n        address _reserve,\n        address _user,\n        uint256 _principalBorrowBalance,\n        uint256 _compoundedBorrowBalance,\n        uint256 _balanceIncrease,\n        CoreLibrary.InterestRateMode _currentRateMode\n    ) external onlyLendingPool returns (CoreLibrary.InterestRateMode, uint256) {\n        updateReserveStateOnSwapRateInternal(\n            _reserve,\n            _user,\n            _principalBorrowBalance,\n            _compoundedBorrowBalance,\n            _currentRateMode\n        );\n\n        CoreLibrary.InterestRateMode newRateMode = updateUserStateOnSwapRateInternal(\n            _reserve,\n            _user,\n            _balanceIncrease,\n            _currentRateMode\n        );\n\n        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);\n\n        return (newRateMode, getUserCurrentBorrowRate(_reserve, _user));\n    }\n\n    /\n    * @dev updates the state of the core as a consequence of a liquidation action.\n    * @param _principalReserve the address of the principal reserve that is being repaid\n    * @param _collateralReserve the address of the collateral reserve that is being liquidated\n    * @param _user the address of the borrower\n    * @param _amountToLiquidate the amount being repaid by the liquidator\n    * @param _collateralToLiquidate the amount of collateral being liquidated\n    * @param _feeLiquidated the amount of origination fee being liquidated\n    * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise\n    /\n    function updateStateOnLiquidation(\n        address _principalReserve,\n        address _collateralReserve,\n        address _user,\n        uint256 _amountToLiquidate,\n        uint256 _collateralToLiquidate,\n        uint256 _feeLiquidated,\n        uint256 _liquidatedCollateralForFee,\n        uint256 _balanceIncrease,\n        bool _liquidatorReceivesAToken\n    ) external onlyLendingPool {\n        updatePrincipalReserveStateOnLiquidationInternal(\n            _principalReserve,\n            _user,\n            _amountToLiquidate,\n            _balanceIncrease\n        );\n\n        updateCollateralReserveStateOnLiquidationInternal(\n            _collateralReserve\n        );\n\n        updateUserStateOnLiquidationInternal(\n            _principalReserve,\n            _user,\n            _amountToLiquidate,\n            _feeLiquidated,\n            _balanceIncrease\n        );\n\n        updateReserveInterestRatesAndTimestampInternal(_principalReserve, _amountToLiquidate, 0);\n\n        if (!_liquidatorReceivesAToken) {\n            updateReserveInterestRatesAndTimestampInternal(\n                _collateralReserve,\n                0,\n                _collateralToLiquidate.add(_liquidatedCollateralForFee)\n            );\n        }\n\n    }\n\n    /\n    * @dev updates the state of the core as a consequence of a stable rate rebalance\n    * @param _reserve the address of the principal reserve where the user borrowed\n    * @param _user the address of the borrower\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    * @return the new stable rate for the user\n    /\n    function updateStateOnRebalance(address _reserve, address _user, uint256 _balanceIncrease)\n    external\n    onlyLendingPool\n    returns (uint256)\n    {\n        updateReserveStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);\n\n        //update user data and rebalance the rate\n        updateUserStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);\n        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);\n        return usersReserveData[_user][_reserve].stableBorrowRate;\n    }\n\n    /\n    * @dev enables or disables a reserve as collateral\n    * @param _reserve the address of the principal reserve where the user deposited\n    * @param _user the address of the depositor\n    * @param _useAsCollateral true if the depositor wants to use the reserve as collateral\n    /\n    function setUserUseReserveAsCollateral(address _reserve, address _user, bool _useAsCollateral)\n    public\n    onlyLendingPool\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        user.useAsCollateral = _useAsCollateral;\n    }\n\n    /\n    * @notice ETH/token transfer functions\n    /\n\n    /\n    * @dev fallback function enforces that the caller is a contract, to support flashloan transfers\n    /\n    function() external payable {\n        //only contracts can send ETH to the core\n        require(msg.sender.isContract(), "Only contracts can send ether to the Lending pool core");\n\n    }\n\n    /\n    * @dev transfers to the user a specific amount from the reserve.\n    * @param _reserve the address of the reserve where the transfer is happening\n    * @param _user the address of the user receiving the transfer\n    * @param _amount the amount being transferred\n    /\n    function transferToUser(address _reserve, address payable _user, uint256 _amount)\n    external\n    onlyLendingPool\n    {\n        if (_reserve != EthAddressLib.ethAddress()) {\n            ERC20(_reserve).safeTransfer(_user, _amount);\n        } else {\n            //solium-disable-next-line\n            (bool result, ) = _user.call.value(_amount).gas(50000)("");\n            require(result, "Transfer of ETH failed");\n        }\n    }\n\n    /\n    * @dev transfers the protocol fees to the fees collection address\n    * @param _token the address of the token being transferred\n    * @param _user the address of the user from where the transfer is happening\n    * @param _amount the amount being transferred\n    * @param _destination the fee receiver address\n    /\n\n    function transferToFeeCollectionAddress(\n        address _token,\n        address _user,\n        uint256 _amount,\n        address _destination\n    ) external payable onlyLendingPool {\n        address payable feeAddress = address(uint160(_destination)); //cast the address to payable\n\n        if (_token != EthAddressLib.ethAddress()) {\n            require(\n                msg.value == 0,\n                "User is sending ETH along with the ERC20 transfer. Check the value attribute of the transaction"\n            );\n            ERC20(_token).safeTransferFrom(_user, feeAddress, _amount);\n        } else {\n            require(msg.value &gt;= _amount, "The amount and the value sent to deposit do not match");\n            //solium-disable-next-line\n            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");\n            require(result, "Transfer of ETH failed");\n        }\n    }\n\n    /\n    * @dev transfers the fees to the fees collection address in the case of liquidation\n    * @param _token the address of the token being transferred\n    * @param _amount the amount being transferred\n    * @param _destination the fee receiver address\n    /\n    function liquidateFee(\n        address _token,\n        uint256 _amount,\n        address _destination\n    ) external payable onlyLendingPool {\n        address payable feeAddress = address(uint160(_destination)); //cast the address to payable\n        require(\n            msg.value == 0,\n            "Fee liquidation does not require any transfer of value"\n        );\n\n        if (_token != EthAddressLib.ethAddress()) {\n            ERC20(_token).safeTransfer(feeAddress, _amount);\n        } else {\n            //solium-disable-next-line\n            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");\n            require(result, "Transfer of ETH failed");\n        }\n    }\n\n    /\n    * @dev transfers an amount from a user to the destination reserve\n    * @param _reserve the address of the reserve where the amount is being transferred\n    * @param _user the address of the user from where the transfer is happening\n    * @param _amount the amount being transferred\n    /\n    function transferToReserve(address _reserve, address payable _user, uint256 _amount)\n    external\n    payable\n    onlyLendingPool\n    {\n        if (_reserve != EthAddressLib.ethAddress()) {\n            require(msg.value == 0, "User is sending ETH along with the ERC20 transfer.");\n            ERC20(_reserve).safeTransferFrom(_user, address(this), _amount);\n\n        } else {\n            require(msg.value &gt;= _amount, "The amount and the value sent to deposit do not match");\n\n            if (msg.value &gt; _amount) {\n                //send back excess ETH\n                uint256 excessAmount = msg.value.sub(_amount);\n                //solium-disable-next-line\n                (bool result, ) = _user.call.value(excessAmount).gas(50000)("");\n                require(result, "Transfer of ETH failed");\n            }\n        }\n    }\n\n    /\n    * @notice data access functions\n    /\n\n    /\n    * @dev returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral)\n    * needed to calculate the global account data in the LendingPoolDataProvider\n    * @param _reserve the address of the reserve\n    * @param _user the address of the user\n    * @return the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not\n    /\n    function getUserBasicReserveData(address _reserve, address _user)\n    external\n    view\n    returns (uint256, uint256, uint256, bool)\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n\n        uint256 underlyingBalance = getUserUnderlyingAssetBalance(_reserve, _user);\n\n        if (user.principalBorrowBalance == 0) {\n            return (underlyingBalance, 0, 0, user.useAsCollateral);\n        }\n\n        return (\n        underlyingBalance,\n        user.getCompoundedBorrowBalance(reserve),\n        user.originationFee,\n        user.useAsCollateral\n        );\n    }\n\n    /\n    * @dev checks if a user is allowed to borrow at a stable rate\n    * @param _reserve the reserve address\n    * @param _user the user\n    * @param _amount the amount the the user wants to borrow\n    * @return true if the user is allowed to borrow at a stable rate, false otherwise\n    /\n\n    function isUserAllowedToBorrowAtStable(address _reserve, address _user, uint256 _amount)\n    external\n    view\n    returns (bool)\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n\n        if (!reserve.isStableBorrowRateEnabled) return false;\n\n        return\n        !user.useAsCollateral ||\n        !reserve.usageAsCollateralEnabled ||\n        _amount &gt; getUserUnderlyingAssetBalance(_reserve, _user);\n    }\n\n    /\n    * @dev gets the underlying asset balance of a user based on the corresponding aToken balance.\n    * @param _reserve the reserve address\n    * @param _user the user address\n    * @return the underlying deposit balance of the user\n    /\n\n    function getUserUnderlyingAssetBalance(address _reserve, address _user)\n    public\n    view\n    returns (uint256)\n    {\n        AToken aToken = AToken(reserves[_reserve].aTokenAddress);\n        return aToken.balanceOf(_user);\n\n    }\n\n    /\n    * @dev gets the interest rate strategy contract address for the reserve\n    * @param _reserve the reserve address\n    * @return the address of the interest rate strategy contract\n    /\n    function getReserveInterestRateStrategyAddress(address _reserve) public view returns (address) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.interestRateStrategyAddress;\n    }\n\n    /\n    * @dev gets the aToken contract address for the reserve\n    * @param _reserve the reserve address\n    * @return the address of the aToken contract\n    /\n\n    function getReserveATokenAddress(address _reserve) public view returns (address) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.aTokenAddress;\n    }\n\n    /\n    * @dev gets the available liquidity in the reserve. The available liquidity is the balance of the core contract\n    * @param _reserve the reserve address\n    * @return the available liquidity\n    /\n    function getReserveAvailableLiquidity(address _reserve) public view returns (uint256) {\n        uint256 balance = 0;\n\n        if (_reserve == EthAddressLib.ethAddress()) {\n            balance = address(this).balance;\n        } else {\n            balance = IERC20(_reserve).balanceOf(address(this));\n        }\n        return balance;\n    }\n\n    /\n    * @dev gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows\n    * @param _reserve the reserve address\n    * @return the total liquidity\n    /\n    function getReserveTotalLiquidity(address _reserve) public view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return getReserveAvailableLiquidity(_reserve).add(reserve.getTotalBorrows());\n    }\n\n    /\n    * @dev gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there\n    * there has been 100% income.\n    * @param _reserve the reserve address\n    * @return the reserve normalized income\n    /\n    function getReserveNormalizedIncome(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.getNormalizedIncome();\n    }\n\n    /\n    * @dev gets the reserve total borrows\n    * @param _reserve the reserve address\n    * @return the total borrows (stable + variable)\n    /\n    function getReserveTotalBorrows(address _reserve) public view returns (uint256) {\n        return reserves[_reserve].getTotalBorrows();\n    }\n\n    /\n    * @dev gets the reserve total borrows stable\n    * @param _reserve the reserve address\n    * @return the total borrows stable\n    /\n    function getReserveTotalBorrowsStable(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.totalBorrowsStable;\n    }\n\n    /\n    * @dev gets the reserve total borrows variable\n    * @param _reserve the reserve address\n    * @return the total borrows variable\n    /\n\n    function getReserveTotalBorrowsVariable(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.totalBorrowsVariable;\n    }\n\n    /\n    * @dev gets the reserve liquidation threshold\n    * @param _reserve the reserve address\n    * @return the reserve liquidation threshold\n    /\n\n    function getReserveLiquidationThreshold(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.liquidationThreshold;\n    }\n\n    /\n    * @dev gets the reserve liquidation bonus\n    * @param _reserve the reserve address\n    * @return the reserve liquidation bonus\n    /\n\n    function getReserveLiquidationBonus(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.liquidationBonus;\n    }\n\n    /\n    * @dev gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty\n    * @param _reserve the reserve address\n    * @return the reserve current variable borrow rate\n    /\n\n    function getReserveCurrentVariableBorrowRate(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n\n        if (reserve.currentVariableBorrowRate == 0) {\n            return\n            IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)\n            .getBaseVariableBorrowRate();\n        }\n        return reserve.currentVariableBorrowRate;\n    }\n\n    /\n    * @dev gets the reserve current stable borrow rate. Is the market rate if the reserve is empty\n    * @param _reserve the reserve address\n    * @return the reserve current stable borrow rate\n    /\n\n    function getReserveCurrentStableBorrowRate(address _reserve) public view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        ILendingRateOracle oracle = ILendingRateOracle(addressesProvider.getLendingRateOracle());\n\n        if (reserve.currentStableBorrowRate == 0) {\n            //no stable rate borrows yet\n            return oracle.getMarketBorrowRate(_reserve);\n        }\n\n        return reserve.currentStableBorrowRate;\n    }\n\n    /\n    * @dev gets the reserve average stable borrow rate. The average stable rate is the weighted average\n    * of all the loans taken at stable rate.\n    * @param _reserve the reserve address\n    * @return the reserve current average borrow rate\n    /\n    function getReserveCurrentAverageStableBorrowRate(address _reserve)\n    external\n    view\n    returns (uint256)\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.currentAverageStableBorrowRate;\n    }\n\n    /\n    * @dev gets the reserve liquidity rate\n    * @param _reserve the reserve address\n    * @return the reserve liquidity rate\n    /\n    function getReserveCurrentLiquidityRate(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.currentLiquidityRate;\n    }\n\n    /\n    * @dev gets the reserve liquidity cumulative index\n    * @param _reserve the reserve address\n    * @return the reserve liquidity cumulative index\n    /\n    function getReserveLiquidityCumulativeIndex(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.lastLiquidityCumulativeIndex;\n    }\n\n    /\n    * @dev gets the reserve variable borrow index\n    * @param _reserve the reserve address\n    * @return the reserve variable borrow index\n    /\n    function getReserveVariableBorrowsCumulativeIndex(address _reserve)\n    external\n    view\n    returns (uint256)\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.lastVariableBorrowCumulativeIndex;\n    }\n\n    /\n    * @dev this function aggregates the configuration parameters of the reserve.\n    * It\'s used in the LendingPoolDataProvider specifically to save gas, and avoid\n    * multiple external contract calls to fetch the same data.\n    * @param _reserve the reserve address\n    * @return the reserve decimals\n    * @return the base ltv as collateral\n    * @return the liquidation threshold\n    * @return if the reserve is used as collateral or not\n    /\n    function getReserveConfiguration(address _reserve)\n    external\n    view\n    returns (uint256, uint256, uint256, bool)\n    {\n        uint256 decimals;\n        uint256 baseLTVasCollateral;\n        uint256 liquidationThreshold;\n        bool usageAsCollateralEnabled;\n\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        decimals = reserve.decimals;\n        baseLTVasCollateral = reserve.baseLTVasCollateral;\n        liquidationThreshold = reserve.liquidationThreshold;\n        usageAsCollateralEnabled = reserve.usageAsCollateralEnabled;\n\n        return (decimals, baseLTVasCollateral, liquidationThreshold, usageAsCollateralEnabled);\n    }\n\n    /\n    * @dev returns the decimals of the reserve\n    * @param _reserve the reserve address\n    * @return the reserve decimals\n    /\n    function getReserveDecimals(address _reserve) external view returns (uint256) {\n        return reserves[_reserve].decimals;\n    }\n\n    /\n    * @dev returns true if the reserve is enabled for borrowing\n    * @param _reserve the reserve address\n    * @return true if the reserve is enabled for borrowing, false otherwise\n    /\n\n    function isReserveBorrowingEnabled(address _reserve) external view returns (bool) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.borrowingEnabled;\n    }\n\n    /\n    * @dev returns true if the reserve is enabled as collateral\n    * @param _reserve the reserve address\n    * @return true if the reserve is enabled as collateral, false otherwise\n    /\n\n    function isReserveUsageAsCollateralEnabled(address _reserve) external view returns (bool) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.usageAsCollateralEnabled;\n    }\n\n    /\n    * @dev returns true if the stable rate is enabled on reserve\n    * @param _reserve the reserve address\n    * @return true if the stable rate is enabled on reserve, false otherwise\n    /\n    function getReserveIsStableBorrowRateEnabled(address _reserve) external view returns (bool) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.isStableBorrowRateEnabled;\n    }\n\n    /\n    * @dev returns true if the reserve is active\n    * @param _reserve the reserve address\n    * @return true if the reserve is active, false otherwise\n    /\n    function getReserveIsActive(address _reserve) external view returns (bool) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.isActive;\n    }\n\n    /\n    * @notice returns if a reserve is freezed\n    * @param _reserve the reserve for which the information is needed\n    * @return true if the reserve is freezed, false otherwise\n    /\n\n    function getReserveIsFreezed(address _reserve) external view returns (bool) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.isFreezed;\n    }\n\n    /\n    * @notice returns the timestamp of the last action on the reserve\n    * @param _reserve the reserve for which the information is needed\n    * @return the last updated timestamp of the reserve\n    /\n\n    function getReserveLastUpdate(address _reserve) external view returns (uint40 timestamp) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        timestamp = reserve.lastUpdateTimestamp;\n    }\n\n    /\n    * @dev returns the utilization rate U of a specific reserve\n    * @param _reserve the reserve for which the information is needed\n    * @return the utilization rate in ray\n    /\n\n    function getReserveUtilizationRate(address _reserve) public view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n\n        uint256 totalBorrows = reserve.getTotalBorrows();\n\n        if (totalBorrows == 0) {\n            return 0;\n        }\n\n        uint256 availableLiquidity = getReserveAvailableLiquidity(_reserve);\n\n        return totalBorrows.rayDiv(availableLiquidity.add(totalBorrows));\n    }\n\n    /\n    * @return the array of reserves configured on the core\n    /\n    function getReserves() external view returns (address[] memory) {\n        return reservesList;\n    }\n\n    /\n    * @param _reserve the address of the reserve for which the information is needed\n    * @param _user the address of the user for which the information is needed\n    * @return true if the user has chosen to use the reserve as collateral, false otherwise\n    /\n    function isUserUseReserveAsCollateralEnabled(address _reserve, address _user)\n    external\n    view\n    returns (bool)\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        return user.useAsCollateral;\n    }\n\n    /\n    * @param _reserve the address of the reserve for which the information is needed\n    * @param _user the address of the user for which the information is needed\n    * @return the origination fee for the user\n    /\n    function getUserOriginationFee(address _reserve, address _user)\n    external\n    view\n    returns (uint256)\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        return user.originationFee;\n    }\n\n    /\n    * @dev users with no loans in progress have NONE as borrow rate mode\n    * @param _reserve the address of the reserve for which the information is needed\n    * @param _user the address of the user for which the information is needed\n    * @return the borrow rate mode for the user,\n    /\n\n    function getUserCurrentBorrowRateMode(address _reserve, address _user)\n    public\n    view\n    returns (CoreLibrary.InterestRateMode)\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n\n        if (user.principalBorrowBalance == 0) {\n            return CoreLibrary.InterestRateMode.NONE;\n        }\n\n        return\n        user.stableBorrowRate &gt; 0\n        ? CoreLibrary.InterestRateMode.STABLE\n        : CoreLibrary.InterestRateMode.VARIABLE;\n    }\n\n    /\n    * @dev gets the current borrow rate of the user\n    * @param _reserve the address of the reserve for which the information is needed\n    * @param _user the address of the user for which the information is needed\n    * @return the borrow rate for the user,\n    /\n    function getUserCurrentBorrowRate(address _reserve, address _user)\n    internal\n    view\n    returns (uint256)\n    {\n        CoreLibrary.InterestRateMode rateMode = getUserCurrentBorrowRateMode(_reserve, _user);\n\n        if (rateMode == CoreLibrary.InterestRateMode.NONE) {\n            return 0;\n        }\n\n        return\n        rateMode == CoreLibrary.InterestRateMode.STABLE\n        ? usersReserveData[_user][_reserve].stableBorrowRate\n        : reserves[_reserve].currentVariableBorrowRate;\n    }\n\n    /\n    * @dev the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all\n    * @param _reserve the address of the reserve for which the information is needed\n    * @param _user the address of the user for which the information is needed\n    * @return the user stable rate\n    /\n    function getUserCurrentStableBorrowRate(address _reserve, address _user)\n    external\n    view\n    returns (uint256)\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        return user.stableBorrowRate;\n    }\n\n    /\n    * @dev calculates and returns the borrow balances of the user\n    * @param _reserve the address of the reserve\n    * @param _user the address of the user\n    * @return the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance\n    /\n\n    function getUserBorrowBalances(address _reserve, address _user)\n    public\n    view\n    returns (uint256, uint256, uint256)\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        if (user.principalBorrowBalance == 0) {\n            return (0, 0, 0);\n        }\n\n        uint256 principal = user.principalBorrowBalance;\n        uint256 compoundedBalance = CoreLibrary.getCompoundedBorrowBalance(\n            user,\n            reserves[_reserve]\n        );\n        return (principal, compoundedBalance, compoundedBalance.sub(principal));\n    }\n\n    /\n    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable\n    * @param _reserve the address of the reserve for which the information is needed\n    * @param _user the address of the user for which the information is needed\n    * @return the variable borrow index for the user\n    /\n\n    function getUserVariableBorrowCumulativeIndex(address _reserve, address _user)\n    external\n    view\n    returns (uint256)\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        return user.lastVariableBorrowCumulativeIndex;\n    }\n\n    /\n    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable\n    * @param _reserve the address of the reserve for which the information is needed\n    * @param _user the address of the user for which the information is needed\n    * @return the variable borrow index for the user\n    /\n\n    function getUserLastUpdate(address _reserve, address _user)\n    external\n    view\n    returns (uint256 timestamp)\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        timestamp = user.lastUpdateTimestamp;\n    }\n\n    /\n    * @dev updates the lending pool core configuration\n    /\n    function refreshConfiguration() external onlyLendingPoolConfigurator {\n        refreshConfigInternal();\n    }\n\n    /\n    * @dev initializes a reserve\n    * @param _reserve the address of the reserve\n    * @param _aTokenAddress the address of the overlying aToken contract\n    * @param _decimals the decimals of the reserve currency\n    * @param _interestRateStrategyAddress the address of the interest rate strategy contract\n    /\n    function initReserve(\n        address _reserve,\n        address _aTokenAddress,\n        uint256 _decimals,\n        address _interestRateStrategyAddress\n    ) external onlyLendingPoolConfigurator {\n        reserves[_reserve].init(_aTokenAddress, _decimals, _interestRateStrategyAddress);\n        addReserveToListInternal(_reserve);\n\n    }\n\n\n\n    /\n    * @dev removes the last added reserve in the reservesList array\n    * @param _reserveToRemove the address of the reserve\n    /\n    function removeLastAddedReserve(address _reserveToRemove)\n    external onlyLendingPoolConfigurator {\n\n        address lastReserve = reservesList[reservesList.length-1];\n\n        require(lastReserve == _reserveToRemove, "Reserve being removed is different than the reserve requested");\n\n        //as we can\'t check if totalLiquidity is 0 (since the reserve added might not be an ERC20) we at least check that there is nothing borrowed\n        require(getReserveTotalBorrows(lastReserve) == 0, "Cannot remove a reserve with liquidity deposited");\n\n        reserves[lastReserve].isActive = false;\n        reserves[lastReserve].aTokenAddress = address(0);\n        reserves[lastReserve].decimals = 0;\n        reserves[lastReserve].lastLiquidityCumulativeIndex = 0;\n        reserves[lastReserve].lastVariableBorrowCumulativeIndex = 0;\n        reserves[lastReserve].borrowingEnabled = false;\n        reserves[lastReserve].usageAsCollateralEnabled = false;\n        reserves[lastReserve].baseLTVasCollateral = 0;\n        reserves[lastReserve].liquidationThreshold = 0;\n        reserves[lastReserve].liquidationBonus = 0;\n        reserves[lastReserve].interestRateStrategyAddress = address(0);\n\n        reservesList.pop();\n    }\n\n    /\n    * @dev updates the address of the interest rate strategy contract\n    * @param _reserve the address of the reserve\n    * @param _rateStrategyAddress the address of the interest rate strategy contract\n    /\n\n    function setReserveInterestRateStrategyAddress(address _reserve, address _rateStrategyAddress)\n    external\n    onlyLendingPoolConfigurator\n    {\n        reserves[_reserve].interestRateStrategyAddress = _rateStrategyAddress;\n    }\n\n    /\n    * @dev enables borrowing on a reserve. Also sets the stable rate borrowing\n    * @param _reserve the address of the reserve\n    * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise\n    /\n\n    function enableBorrowingOnReserve(address _reserve, bool _stableBorrowRateEnabled)\n    external\n    onlyLendingPoolConfigurator\n    {\n        reserves[_reserve].enableBorrowing(_stableBorrowRateEnabled);\n    }\n\n    /\n    * @dev disables borrowing on a reserve\n    * @param _reserve the address of the reserve\n    /\n\n    function disableBorrowingOnReserve(address _reserve) external onlyLendingPoolConfigurator {\n        reserves[_reserve].disableBorrowing();\n    }\n\n    /\n    * @dev enables a reserve to be used as collateral\n    * @param _reserve the address of the reserve\n    /\n    function enableReserveAsCollateral(\n        address _reserve,\n        uint256 _baseLTVasCollateral,\n        uint256 _liquidationThreshold,\n        uint256 _liquidationBonus\n    ) external onlyLendingPoolConfigurator {\n        reserves[_reserve].enableAsCollateral(\n            _baseLTVasCollateral,\n            _liquidationThreshold,\n            _liquidationBonus\n        );\n    }\n\n    /\n    * @dev disables a reserve to be used as collateral\n    * @param _reserve the address of the reserve\n    /\n    function disableReserveAsCollateral(address _reserve) external onlyLendingPoolConfigurator {\n        reserves[_reserve].disableAsCollateral();\n    }\n\n    /\n    * @dev enable the stable borrow rate mode on a reserve\n    * @param _reserve the address of the reserve\n    /\n    function enableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.isStableBorrowRateEnabled = true;\n    }\n\n    /\n    * @dev disable the stable borrow rate mode on a reserve\n    * @param _reserve the address of the reserve\n    /\n    function disableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.isStableBorrowRateEnabled = false;\n    }\n\n    /\n    * @dev activates a reserve\n    * @param _reserve the address of the reserve\n    /\n    function activateReserve(address _reserve) external onlyLendingPoolConfigurator {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n\n        require(\n            reserve.lastLiquidityCumulativeIndex &gt; 0 &amp;&amp;\n            reserve.lastVariableBorrowCumulativeIndex &gt; 0,\n            "Reserve has not been initialized yet"\n        );\n        reserve.isActive = true;\n    }\n\n    /\n    * @dev deactivates a reserve\n    * @param _reserve the address of the reserve\n    /\n    function deactivateReserve(address _reserve) external onlyLendingPoolConfigurator {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.isActive = false;\n    }\n\n    /\n    * @notice allows the configurator to freeze the reserve.\n    * A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance.\n    * @param _reserve the address of the reserve\n    /\n    function freezeReserve(address _reserve) external onlyLendingPoolConfigurator {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.isFreezed = true;\n    }\n\n    /\n    * @notice allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed.\n    * @param _reserve the address of the reserve\n    /\n    function unfreezeReserve(address _reserve) external onlyLendingPoolConfigurator {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.isFreezed = false;\n    }\n\n    /\n    * @notice allows the configurator to update the loan to value of a reserve\n    * @param _reserve the address of the reserve\n    * @param _ltv the new loan to value\n    /\n    function setReserveBaseLTVasCollateral(address _reserve, uint256 _ltv)\n    external\n    onlyLendingPoolConfigurator\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.baseLTVasCollateral = _ltv;\n    }\n\n    /\n    * @notice allows the configurator to update the liquidation threshold of a reserve\n    * @param _reserve the address of the reserve\n    * @param _threshold the new liquidation threshold\n    /\n    function setReserveLiquidationThreshold(address _reserve, uint256 _threshold)\n    external\n    onlyLendingPoolConfigurator\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.liquidationThreshold = _threshold;\n    }\n\n    /\n    * @notice allows the configurator to update the liquidation bonus of a reserve\n    * @param _reserve the address of the reserve\n    * @param _bonus the new liquidation bonus\n    /\n    function setReserveLiquidationBonus(address _reserve, uint256 _bonus)\n    external\n    onlyLendingPoolConfigurator\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.liquidationBonus = _bonus;\n    }\n\n    /\n    * @notice allows the configurator to update the reserve decimals\n    * @param _reserve the address of the reserve\n    * @param _decimals the decimals of the reserve\n    /\n    function setReserveDecimals(address _reserve, uint256 _decimals)\n    external\n    onlyLendingPoolConfigurator\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.decimals = _decimals;\n    }\n\n    /\n    * @notice internal functions\n    /\n\n    /\n    * @dev updates the state of a reserve as a consequence of a borrow action.\n    * @param _reserve the address of the reserve on which the user is borrowing\n    * @param _user the address of the borrower\n    * @param _principalBorrowBalance the previous borrow balance of the borrower before the action\n    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount\n    * @param _amountBorrowed the new amount borrowed\n    * @param _rateMode the borrow rate mode (stable, variable)\n    /\n\n    function updateReserveStateOnBorrowInternal(\n        address _reserve,\n        address _user,\n        uint256 _principalBorrowBalance,\n        uint256 _balanceIncrease,\n        uint256 _amountBorrowed,\n        CoreLibrary.InterestRateMode _rateMode\n    ) internal {\n        reserves[_reserve].updateCumulativeIndexes();\n\n        //increasing reserve total borrows to account for the new borrow balance of the user\n        //NOTE: Depending on the previous borrow mode, the borrows might need to be switched from variable to stable or vice versa\n\n        updateReserveTotalBorrowsByRateModeInternal(\n            _reserve,\n            _user,\n            _principalBorrowBalance,\n            _balanceIncrease,\n            _amountBorrowed,\n            _rateMode\n        );\n    }\n\n    /\n    * @dev updates the state of a user as a consequence of a borrow action.\n    * @param _reserve the address of the reserve on which the user is borrowing\n    * @param _user the address of the borrower\n    * @param _amountBorrowed the amount borrowed\n    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount\n    * @param _rateMode the borrow rate mode (stable, variable)\n    * @return the final borrow rate for the user. Emitted by the borrow() event\n    /\n\n    function updateUserStateOnBorrowInternal(\n        address _reserve,\n        address _user,\n        uint256 _amountBorrowed,\n        uint256 _balanceIncrease,\n        uint256 _fee,\n        CoreLibrary.InterestRateMode _rateMode\n    ) internal {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n\n        if (_rateMode == CoreLibrary.InterestRateMode.STABLE) {\n            //stable\n            //reset the user variable index, and update the stable rate\n            user.stableBorrowRate = reserve.currentStableBorrowRate;\n            user.lastVariableBorrowCumulativeIndex = 0;\n        } else if (_rateMode == CoreLibrary.InterestRateMode.VARIABLE) {\n            //variable\n            //reset the user stable rate, and store the new borrow index\n            user.stableBorrowRate = 0;\n            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;\n        } else {\n            revert("Invalid borrow rate mode");\n        }\n        //increase the principal borrows and the origination fee\n        user.principalBorrowBalance = user.principalBorrowBalance.add(_amountBorrowed).add(\n            _balanceIncrease\n        );\n        user.originationFee = user.originationFee.add(_fee);\n\n        //solium-disable-next-line\n        user.lastUpdateTimestamp = uint40(block.timestamp);\n\n    }\n\n    /\n    * @dev updates the state of the reserve as a consequence of a repay action.\n    * @param _reserve the address of the reserve on which the user is repaying\n    * @param _user the address of the borrower\n    * @param _paybackAmountMinusFees the amount being paid back minus fees\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    /\n\n    function updateReserveStateOnRepayInternal(\n        address _reserve,\n        address _user,\n        uint256 _paybackAmountMinusFees,\n        uint256 _balanceIncrease\n    ) internal {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_reserve][_user];\n\n        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(_reserve, _user);\n\n        //update the indexes\n        reserves[_reserve].updateCumulativeIndexes();\n\n        //compound the cumulated interest to the borrow balance and then subtracting the payback amount\n        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {\n            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(\n                _balanceIncrease,\n                user.stableBorrowRate\n            );\n            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(\n                _paybackAmountMinusFees,\n                user.stableBorrowRate\n            );\n        } else {\n            reserve.increaseTotalBorrowsVariable(_balanceIncrease);\n            reserve.decreaseTotalBorrowsVariable(_paybackAmountMinusFees);\n        }\n    }\n\n    /\n    * @dev updates the state of the user as a consequence of a repay action.\n    * @param _reserve the address of the reserve on which the user is repaying\n    * @param _user the address of the borrower\n    * @param _paybackAmountMinusFees the amount being paid back minus fees\n    * @param _originationFeeRepaid the fee on the amount that is being repaid\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    * @param _repaidWholeLoan true if the user is repaying the whole loan\n    /\n    function updateUserStateOnRepayInternal(\n        address _reserve,\n        address _user,\n        uint256 _paybackAmountMinusFees,\n        uint256 _originationFeeRepaid,\n        uint256 _balanceIncrease,\n        bool _repaidWholeLoan\n    ) internal {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n\n        //update the user principal borrow balance, adding the cumulated interest and then subtracting the payback amount\n        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(\n            _paybackAmountMinusFees\n        );\n        user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;\n\n        //if the balance decrease is equal to the previous principal (user is repaying the whole loan)\n        //and the rate mode is stable, we reset the interest rate mode of the user\n        if (_repaidWholeLoan) {\n            user.stableBorrowRate = 0;\n            user.lastVariableBorrowCumulativeIndex = 0;\n        }\n        user.originationFee = user.originationFee.sub(_originationFeeRepaid);\n\n        //solium-disable-next-line\n        user.lastUpdateTimestamp = uint40(block.timestamp);\n\n    }\n\n    /\n    * @dev updates the state of the user as a consequence of a swap rate action.\n    * @param _reserve the address of the reserve on which the user is performing the rate swap\n    * @param _user the address of the borrower\n    * @param _principalBorrowBalance the the principal amount borrowed by the user\n    * @param _compoundedBorrowBalance the principal amount plus the accrued interest\n    * @param _currentRateMode the rate mode at which the user borrowed\n    /\n    function updateReserveStateOnSwapRateInternal(\n        address _reserve,\n        address _user,\n        uint256 _principalBorrowBalance,\n        uint256 _compoundedBorrowBalance,\n        CoreLibrary.InterestRateMode _currentRateMode\n    ) internal {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n\n        //compounding reserve indexes\n        reserve.updateCumulativeIndexes();\n\n        if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {\n            uint256 userCurrentStableRate = user.stableBorrowRate;\n\n            //swap to variable\n            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(\n                _principalBorrowBalance,\n                userCurrentStableRate\n            ); //decreasing stable from old principal balance\n            reserve.increaseTotalBorrowsVariable(_compoundedBorrowBalance); //increase variable borrows\n        } else if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {\n            //swap to stable\n            uint256 currentStableRate = reserve.currentStableBorrowRate;\n            reserve.decreaseTotalBorrowsVariable(_principalBorrowBalance);\n            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(\n                _compoundedBorrowBalance,\n                currentStableRate\n            );\n\n        } else {\n            revert("Invalid rate mode received");\n        }\n    }\n\n    /\n    * @dev updates the state of the user as a consequence of a swap rate action.\n    * @param _reserve the address of the reserve on which the user is performing the swap\n    * @param _user the address of the borrower\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    * @param _currentRateMode the current rate mode of the user\n    /\n\n    function updateUserStateOnSwapRateInternal(\n        address _reserve,\n        address _user,\n        uint256 _balanceIncrease,\n        CoreLibrary.InterestRateMode _currentRateMode\n    ) internal returns (CoreLibrary.InterestRateMode) {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n\n        CoreLibrary.InterestRateMode newMode = CoreLibrary.InterestRateMode.NONE;\n\n        if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {\n            //switch to stable\n            newMode = CoreLibrary.InterestRateMode.STABLE;\n            user.stableBorrowRate = reserve.currentStableBorrowRate;\n            user.lastVariableBorrowCumulativeIndex = 0;\n        } else if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {\n            newMode = CoreLibrary.InterestRateMode.VARIABLE;\n            user.stableBorrowRate = 0;\n            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;\n        } else {\n            revert("Invalid interest rate mode received");\n        }\n        //compounding cumulated interest\n        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);\n        //solium-disable-next-line\n        user.lastUpdateTimestamp = uint40(block.timestamp);\n\n        return newMode;\n    }\n\n    /\n    * @dev updates the state of the principal reserve as a consequence of a liquidation action.\n    * @param _principalReserve the address of the principal reserve that is being repaid\n    * @param _user the address of the borrower\n    * @param _amountToLiquidate the amount being repaid by the liquidator\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    /\n\n    function updatePrincipalReserveStateOnLiquidationInternal(\n        address _principalReserve,\n        address _user,\n        uint256 _amountToLiquidate,\n        uint256 _balanceIncrease\n    ) internal {\n        CoreLibrary.ReserveData storage reserve = reserves[_principalReserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_principalReserve];\n\n        //update principal reserve data\n        reserve.updateCumulativeIndexes();\n\n        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(\n            _principalReserve,\n            _user\n        );\n\n        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {\n            //increase the total borrows by the compounded interest\n            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(\n                _balanceIncrease,\n                user.stableBorrowRate\n            );\n\n            //decrease by the actual amount to liquidate\n            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(\n                _amountToLiquidate,\n                user.stableBorrowRate\n            );\n\n        } else {\n            //increase the total borrows by the compounded interest\n            reserve.increaseTotalBorrowsVariable(_balanceIncrease);\n\n            //decrease by the actual amount to liquidate\n            reserve.decreaseTotalBorrowsVariable(_amountToLiquidate);\n        }\n\n    }\n\n    /\n    * @dev updates the state of the collateral reserve as a consequence of a liquidation action.\n    * @param _collateralReserve the address of the collateral reserve that is being liquidated\n    /\n    function updateCollateralReserveStateOnLiquidationInternal(\n        address _collateralReserve\n    ) internal {\n        //update collateral reserve\n        reserves[_collateralReserve].updateCumulativeIndexes();\n\n    }\n\n    /\n    * @dev updates the state of the user being liquidated as a consequence of a liquidation action.\n    * @param _reserve the address of the principal reserve that is being repaid\n    * @param _user the address of the borrower\n    * @param _amountToLiquidate the amount being repaid by the liquidator\n    * @param _feeLiquidated the amount of origination fee being liquidated\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    /\n    function updateUserStateOnLiquidationInternal(\n        address _reserve,\n        address _user,\n        uint256 _amountToLiquidate,\n        uint256 _feeLiquidated,\n        uint256 _balanceIncrease\n    ) internal {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        //first increase by the compounded interest, then decrease by the liquidated amount\n        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(\n            _amountToLiquidate\n        );\n\n        if (\n            getUserCurrentBorrowRateMode(_reserve, _user) == CoreLibrary.InterestRateMode.VARIABLE\n        ) {\n            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;\n        }\n\n        if(_feeLiquidated &gt; 0){\n            user.originationFee = user.originationFee.sub(_feeLiquidated);\n        }\n\n        //solium-disable-next-line\n        user.lastUpdateTimestamp = uint40(block.timestamp);\n    }\n\n    /\n    * @dev updates the state of the reserve as a consequence of a stable rate rebalance\n    * @param _reserve the address of the principal reserve where the user borrowed\n    * @param _user the address of the borrower\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    /\n\n    function updateReserveStateOnRebalanceInternal(\n        address _reserve,\n        address _user,\n        uint256 _balanceIncrease\n    ) internal {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n\n        reserve.updateCumulativeIndexes();\n\n        reserve.increaseTotalBorrowsStableAndUpdateAverageRate(\n            _balanceIncrease,\n            user.stableBorrowRate\n        );\n\n    }\n\n    /\n    * @dev updates the state of the user as a consequence of a stable rate rebalance\n    * @param _reserve the address of the principal reserve where the user borrowed\n    * @param _user the address of the borrower\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    /\n\n    function updateUserStateOnRebalanceInternal(\n        address _reserve,\n        address _user,\n        uint256 _balanceIncrease\n    ) internal {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n\n        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);\n        user.stableBorrowRate = reserve.currentStableBorrowRate;\n\n        //solium-disable-next-line\n        user.lastUpdateTimestamp = uint40(block.timestamp);\n    }\n\n    /\n    * @dev updates the state of the user as a consequence of a stable rate rebalance\n    * @param _reserve the address of the principal reserve where the user borrowed\n    * @param _user the address of the borrower\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    * @param _amountBorrowed the accrued interest on the borrowed amount\n    /\n    function updateReserveTotalBorrowsByRateModeInternal(\n        address _reserve,\n        address _user,\n        uint256 _principalBalance,\n        uint256 _balanceIncrease,\n        uint256 _amountBorrowed,\n        CoreLibrary.InterestRateMode _newBorrowRateMode\n    ) internal {\n        CoreLibrary.InterestRateMode previousRateMode = getUserCurrentBorrowRateMode(\n            _reserve,\n            _user\n        );\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n\n        if (previousRateMode == CoreLibrary.InterestRateMode.STABLE) {\n            CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(\n                _principalBalance,\n                user.stableBorrowRate\n            );\n        } else if (previousRateMode == CoreLibrary.InterestRateMode.VARIABLE) {\n            reserve.decreaseTotalBorrowsVariable(_principalBalance);\n        }\n\n        uint256 newPrincipalAmount = _principalBalance.add(_balanceIncrease).add(_amountBorrowed);\n        if (_newBorrowRateMode == CoreLibrary.InterestRateMode.STABLE) {\n            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(\n                newPrincipalAmount,\n                reserve.currentStableBorrowRate\n            );\n        } else if (_newBorrowRateMode == CoreLibrary.InterestRateMode.VARIABLE) {\n            reserve.increaseTotalBorrowsVariable(newPrincipalAmount);\n        } else {\n            revert("Invalid new borrow rate mode");\n        }\n    }\n\n    /\n    * @dev Updates the reserve current stable borrow rate Rf, the current variable borrow rate Rv and the current liquidity rate Rl.\n    * Also updates the lastUpdateTimestamp value. Please refer to the whitepaper for further information.\n    * @param _reserve the address of the reserve to be updated\n    * @param _liquidityAdded the amount of liquidity added to the protocol (deposit or repay) in the previous action\n    * @param _liquidityTaken the amount of liquidity taken from the protocol (redeem or borrow)\n    /\n\n    function updateReserveInterestRatesAndTimestampInternal(\n        address _reserve,\n        uint256 _liquidityAdded,\n        uint256 _liquidityTaken\n    ) internal {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        (uint256 newLiquidityRate, uint256 newStableRate, uint256 newVariableRate) = IReserveInterestRateStrategy(\n            reserve\n            .interestRateStrategyAddress\n        )\n        .calculateInterestRates(\n            _reserve,\n            getReserveAvailableLiquidity(_reserve).add(_liquidityAdded).sub(_liquidityTaken),\n            reserve.totalBorrowsStable,\n            reserve.totalBorrowsVariable,\n            reserve.currentAverageStableBorrowRate\n        );\n\n        reserve.currentLiquidityRate = newLiquidityRate;\n        reserve.currentStableBorrowRate = newStableRate;\n        reserve.currentVariableBorrowRate = newVariableRate;\n\n        //solium-disable-next-line\n        reserve.lastUpdateTimestamp = uint40(block.timestamp);\n\n        emit ReserveUpdated(\n            _reserve,\n            newLiquidityRate,\n            newStableRate,\n            newVariableRate,\n            reserve.lastLiquidityCumulativeIndex,\n            reserve.lastVariableBorrowCumulativeIndex\n        );\n    }\n\n    /\n    * @dev transfers to the protocol fees of a flashloan to the fees collection address\n    * @param _token the address of the token being transferred\n    * @param _amount the amount being transferred\n    /\n\n    function transferFlashLoanProtocolFeeInternal(address _token, uint256 _amount) internal {\n        address payable receiver = address(uint160(addressesProvider.getTokenDistributor()));\n\n        if (_token != EthAddressLib.ethAddress()) {\n            ERC20(_token).safeTransfer(receiver, _amount);\n        } else {\n            receiver.transfer(_amount);\n        }\n    }\n\n    /\n    * @dev updates the internal configuration of the core\n    /\n    function refreshConfigInternal() internal {\n        lendingPoolAddress = addressesProvider.getLendingPool();\n    }\n\n    /\n    * @dev adds a reserve to the array of the reserves address\n    /\n    function addReserveToListInternal(address _reserve) internal {\n        bool reserveAlreadyAdded = false;\n        for (uint256 i = 0; i &lt; reservesList.length; i++)\n            if (reservesList[i] == _reserve) {\n                reserveAlreadyAdded = true;\n            }\n        if (!reserveAlreadyAdded) reservesList.push(_reserve);\n    }\n\n}\n', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 04:31:42 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | pragma solidity ^0.5.0; import "openzeppelin-solidity/contracts/math/SafeMath.sol"; import "openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol"; import "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol"; import "openzeppelin-solidity/contracts/utils/Address.sol"; import "../libraries/openzeppelin-upgradeability/VersionedInitializable.sol"; import "../libraries/CoreLibrary.sol"; import "../configuration/LendingPoolAddressesProvider.sol"; import "../interfaces/ILendingRateOracle.sol"; import "../interfaces/IReserveInterestRateStrategy.sol"; import "../libraries/WadRayMath.sol"; import "../tokenization/AToken.sol"; import "../libraries/EthAddressLib.sol"; / * @title LendingPoolCore contract * @author Aave * @notice Holds the state of the lending pool and all the funds deposited * @dev NOTE: The core does not enforce security checks on the update of the state * (eg, updateStateOnBorrow() does not enforce that borrowed is enabled on the reserve). * The check that an action can be performed is a duty of the overlying LendingPool contract. / contract LendingPoolCore is VersionedInitializable {     using SafeMath for uint256;     using WadRayMath for uint256;     using CoreLibrary for CoreLibrary.ReserveData;     using CoreLibrary for CoreLibrary.UserReserveData;     using SafeERC20 for ERC20;     using Address for address payable; /** * @dev Emitted when the state of a reserve is updated * @param reserve the address of the reserve * @param liquidityRate the new liquidity rate * @param stableBorrowRate the new stable borrow rate * @param variableBorrowRate the new variable borrow rate * @param liquidityIndex the new liquidity index * @param variableBorrowIndex the new variable borrow index **/ event ReserveUpdated(     address indexed reserve,     uint256 liquidityRate,     uint256 stableBorrowRate,     uint256 variableBorrowRate,     uint256 liquidityIndex,     uint256 variableBorrowIndex );  address public lendingPoolAddress;  LendingPoolAddressesProvider public addressesProvider;  /** * @dev only lending pools can use functions affected by this modifier **/ modifier onlyLendingPool {     require(lendingPoolAddress == msg.sender, "The caller must be a lending pool contract");     _; }  /** * @dev only lending pools configurator can use functions affected by this modifier **/ modifier onlyLendingPoolConfigurator {     require(         addressesProvider.getLendingPoolConfigurator() == msg.sender,         "The caller must be a lending pool configurator contract"     );     _; }  mapping(address =&gt; CoreLibrary.ReserveData) internal reserves; mapping(address =&gt; mapping(address =&gt; CoreLibrary.UserReserveData)) internal usersReserveData;  address[] public reservesList;  uint256 public constant CORE_REVISION = 0x4;  /** * @dev returns the revision number of the contract **/ function getRevision() internal pure returns (uint256) {     return CORE_REVISION; }  /** * @dev initializes the Core contract, invoked upon registration on the AddressesProvider * @param _addressesProvider the addressesProvider contract **/  function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {     addressesProvider = _addressesProvider;     refreshConfigInternal(); }  /** * @dev updates the state of the core as a result of a deposit action * @param _reserve the address of the reserve in which the deposit is happening * @param _user the address of the the user depositing * @param _amount the amount being deposited * @param _isFirstDeposit true if the user is depositing for the first time **/  function updateStateOnDeposit(     address _reserve,     address _user,     uint256 _amount,     bool _isFirstDeposit ) external onlyLendingPool {     reserves[_reserve].updateCumulativeIndexes();     updateReserveInterestRatesAndTimestampInternal(_reserve, _amount, 0);      if (_isFirstDeposit) {         //if this is the first deposit of the user, we configure the deposit as enabled to be used as collateral         setUserUseReserveAsCollateral(_reserve, _user, true);     } }  /** * @dev updates the state of the core as a result of a redeem action * @param _reserve the address of the reserve in which the redeem is happening * @param _user the address of the the user redeeming * @param _amountRedeemed the amount being redeemed * @param _userRedeemedEverything true if the user is redeeming everything **/ function updateStateOnRedeem(     address _reserve,     address _user,     uint256 _amountRedeemed,     bool _userRedeemedEverything ) external onlyLendingPool {     //compound liquidity and variable borrow interests     reserves[_reserve].updateCumulativeIndexes();     updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountRedeemed);      //if user redeemed everything the useReserveAsCollateral flag is reset     if (_userRedeemedEverything) {         setUserUseReserveAsCollateral(_reserve, _user, false);     } }  /** * @dev updates the state of the core as a result of a flashloan action * @param _reserve the address of the reserve in which the flashloan is happening * @param _income the income of the protocol as a result of the action **/ function updateStateOnFlashLoan(     address _reserve,     uint256 _availableLiquidityBefore,     uint256 _income,     uint256 _protocolFee ) external onlyLendingPool {     transferFlashLoanProtocolFeeInternal(_reserve, _protocolFee);      //compounding the cumulated interest     reserves[_reserve].updateCumulativeIndexes();      uint256 totalLiquidityBefore = _availableLiquidityBefore.add(         getReserveTotalBorrows(_reserve)     );      //compounding the received fee into the reserve     reserves[_reserve].cumulateToLiquidityIndex(totalLiquidityBefore, _income);      //refresh interest rates     updateReserveInterestRatesAndTimestampInternal(_reserve, _income, 0); }  /** * @dev updates the state of the core as a consequence of a borrow action. * @param _reserve the address of the reserve on which the user is borrowing * @param _user the address of the borrower * @param _amountBorrowed the new amount borrowed * @param _borrowFee the fee on the amount borrowed * @param _rateMode the borrow rate mode (stable, variable) * @return the new borrow rate for the user **/ function updateStateOnBorrow(     address _reserve,     address _user,     uint256 _amountBorrowed,     uint256 _borrowFee,     CoreLibrary.InterestRateMode _rateMode ) external onlyLendingPool returns (uint256, uint256) {     // getting the previous borrow data of the user     (uint256 principalBorrowBalance, , uint256 balanceIncrease) = getUserBorrowBalances(         _reserve,         _user     );      updateReserveStateOnBorrowInternal(         _reserve,         _user,         principalBorrowBalance,         balanceIncrease,         _amountBorrowed,         _rateMode     );      updateUserStateOnBorrowInternal(         _reserve,         _user,         _amountBorrowed,         balanceIncrease,         _borrowFee,         _rateMode     );      updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountBorrowed);      return (getUserCurrentBorrowRate(_reserve, _user), balanceIncrease); }  /** * @dev updates the state of the core as a consequence of a repay action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _paybackAmountMinusFees the amount being paid back minus fees * @param _originationFeeRepaid the fee on the amount that is being repaid * @param _balanceIncrease the accrued interest on the borrowed amount * @param _repaidWholeLoan true if the user is repaying the whole loan **/  function updateStateOnRepay(     address _reserve,     address _user,     uint256 _paybackAmountMinusFees,     uint256 _originationFeeRepaid,     uint256 _balanceIncrease,     bool _repaidWholeLoan ) external onlyLendingPool {     updateReserveStateOnRepayInternal(         _reserve,         _user,         _paybackAmountMinusFees,         _balanceIncrease     );     updateUserStateOnRepayInternal(         _reserve,         _user,         _paybackAmountMinusFees,         _originationFeeRepaid,         _balanceIncrease,         _repaidWholeLoan     );      updateReserveInterestRatesAndTimestampInternal(_reserve, _paybackAmountMinusFees, 0); }  /** * @dev updates the state of the core as a consequence of a swap rate action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _principalBorrowBalance the amount borrowed by the user * @param _compoundedBorrowBalance the amount borrowed plus accrued interest * @param _balanceIncrease the accrued interest on the borrowed amount * @param _currentRateMode the current interest rate mode for the user **/ function updateStateOnSwapRate(     address _reserve,     address _user,     uint256 _principalBorrowBalance,     uint256 _compoundedBorrowBalance,     uint256 _balanceIncrease,     CoreLibrary.InterestRateMode _currentRateMode ) external onlyLendingPool returns (CoreLibrary.InterestRateMode, uint256) {     updateReserveStateOnSwapRateInternal(         _reserve,         _user,         _principalBorrowBalance,         _compoundedBorrowBalance,         _currentRateMode     );      CoreLibrary.InterestRateMode newRateMode = updateUserStateOnSwapRateInternal(         _reserve,         _user,         _balanceIncrease,         _currentRateMode     );      updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);      return (newRateMode, getUserCurrentBorrowRate(_reserve, _user)); }  /** * @dev updates the state of the core as a consequence of a liquidation action. * @param _principalReserve the address of the principal reserve that is being repaid * @param _collateralReserve the address of the collateral reserve that is being liquidated * @param _user the address of the borrower * @param _amountToLiquidate the amount being repaid by the liquidator * @param _collateralToLiquidate the amount of collateral being liquidated * @param _feeLiquidated the amount of origination fee being liquidated * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus * @param _balanceIncrease the accrued interest on the borrowed amount * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise **/ function updateStateOnLiquidation(     address _principalReserve,     address _collateralReserve,     address _user,     uint256 _amountToLiquidate,     uint256 _collateralToLiquidate,     uint256 _feeLiquidated,     uint256 _liquidatedCollateralForFee,     uint256 _balanceIncrease,     bool _liquidatorReceivesAToken ) external onlyLendingPool {     updatePrincipalReserveStateOnLiquidationInternal(         _principalReserve,         _user,         _amountToLiquidate,         _balanceIncrease     );      updateCollateralReserveStateOnLiquidationInternal(         _collateralReserve     );      updateUserStateOnLiquidationInternal(         _principalReserve,         _user,         _amountToLiquidate,         _feeLiquidated,         _balanceIncrease     );      updateReserveInterestRatesAndTimestampInternal(_principalReserve, _amountToLiquidate, 0);      if (!_liquidatorReceivesAToken) {         updateReserveInterestRatesAndTimestampInternal(             _collateralReserve,             0,             _collateralToLiquidate.add(_liquidatedCollateralForFee)         );     }  }  /** * @dev updates the state of the core as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount * @return the new stable rate for the user **/ function updateStateOnRebalance(address _reserve, address _user, uint256 _balanceIncrease) external onlyLendingPool returns (uint256) {     updateReserveStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);      //update user data and rebalance the rate     updateUserStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);     updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);     return usersReserveData[_user][_reserve].stableBorrowRate; }  /** * @dev enables or disables a reserve as collateral * @param _reserve the address of the principal reserve where the user deposited * @param _user the address of the depositor * @param _useAsCollateral true if the depositor wants to use the reserve as collateral **/ function setUserUseReserveAsCollateral(address _reserve, address _user, bool _useAsCollateral) public onlyLendingPool {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     user.useAsCollateral = _useAsCollateral; }  /** * @notice ETH/token transfer functions **/  /** * @dev fallback function enforces that the caller is a contract, to support flashloan transfers **/ function() external payable {     //only contracts can send ETH to the core     require(msg.sender.isContract(), "Only contracts can send ether to the Lending pool core");  }  /** * @dev transfers to the user a specific amount from the reserve. * @param _reserve the address of the reserve where the transfer is happening * @param _user the address of the user receiving the transfer * @param _amount the amount being transferred **/ function transferToUser(address _reserve, address payable _user, uint256 _amount) external onlyLendingPool {     if (_reserve != EthAddressLib.ethAddress()) {         ERC20(_reserve).safeTransfer(_user, _amount);     } else {         //solium-disable-next-line         (bool result, ) = _user.call.value(_amount).gas(50000)("");         require(result, "Transfer of ETH failed");     } }  /** * @dev transfers the protocol fees to the fees collection address * @param _token the address of the token being transferred * @param _user the address of the user from where the transfer is happening * @param _amount the amount being transferred * @param _destination the fee receiver address **/  function transferToFeeCollectionAddress(     address _token,     address _user,     uint256 _amount,     address _destination ) external payable onlyLendingPool {     address payable feeAddress = address(uint160(_destination)); //cast the address to payable      if (_token != EthAddressLib.ethAddress()) {         require(             msg.value == 0,             "User is sending ETH along with the ERC20 transfer. Check the value attribute of the transaction"         );         ERC20(_token).safeTransferFrom(_user, feeAddress, _amount);     } else {         require(msg.value &gt;= _amount, "The amount and the value sent to deposit do not match");         //solium-disable-next-line         (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");         require(result, "Transfer of ETH failed");     } }  /** * @dev transfers the fees to the fees collection address in the case of liquidation * @param _token the address of the token being transferred * @param _amount the amount being transferred * @param _destination the fee receiver address **/ function liquidateFee(     address _token,     uint256 _amount,     address _destination ) external payable onlyLendingPool {     address payable feeAddress = address(uint160(_destination)); //cast the address to payable     require(         msg.value == 0,         "Fee liquidation does not require any transfer of value"     );      if (_token != EthAddressLib.ethAddress()) {         ERC20(_token).safeTransfer(feeAddress, _amount);     } else {         //solium-disable-next-line         (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");         require(result, "Transfer of ETH failed");     } }  /** * @dev transfers an amount from a user to the destination reserve * @param _reserve the address of the reserve where the amount is being transferred * @param _user the address of the user from where the transfer is happening * @param _amount the amount being transferred **/ function transferToReserve(address _reserve, address payable _user, uint256 _amount) external payable onlyLendingPool {     if (_reserve != EthAddressLib.ethAddress()) {         require(msg.value == 0, "User is sending ETH along with the ERC20 transfer.");         ERC20(_reserve).safeTransferFrom(_user, address(this), _amount);      } else {         require(msg.value &gt;= _amount, "The amount and the value sent to deposit do not match");          if (msg.value &gt; _amount) {             //send back excess ETH             uint256 excessAmount = msg.value.sub(_amount);             //solium-disable-next-line             (bool result, ) = _user.call.value(excessAmount).gas(50000)("");             require(result, "Transfer of ETH failed");         }     } }  /** * @notice data access functions **/  /** * @dev returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral) * needed to calculate the global account data in the LendingPoolDataProvider * @param _reserve the address of the reserve * @param _user the address of the user * @return the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not **/ function getUserBasicReserveData(address _reserve, address _user) external view returns (uint256, uint256, uint256, bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      uint256 underlyingBalance = getUserUnderlyingAssetBalance(_reserve, _user);      if (user.principalBorrowBalance == 0) {         return (underlyingBalance, 0, 0, user.useAsCollateral);     }      return (     underlyingBalance,     user.getCompoundedBorrowBalance(reserve),     user.originationFee,     user.useAsCollateral     ); }  /** * @dev checks if a user is allowed to borrow at a stable rate * @param _reserve the reserve address * @param _user the user * @param _amount the amount the the user wants to borrow * @return true if the user is allowed to borrow at a stable rate, false otherwise **/  function isUserAllowedToBorrowAtStable(address _reserve, address _user, uint256 _amount) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      if (!reserve.isStableBorrowRateEnabled) return false;      return     !user.useAsCollateral ||     !reserve.usageAsCollateralEnabled ||     _amount &gt; getUserUnderlyingAssetBalance(_reserve, _user); }  /** * @dev gets the underlying asset balance of a user based on the corresponding aToken balance. * @param _reserve the reserve address * @param _user the user address * @return the underlying deposit balance of the user **/  function getUserUnderlyingAssetBalance(address _reserve, address _user) public view returns (uint256) {     AToken aToken = AToken(reserves[_reserve].aTokenAddress);     return aToken.balanceOf(_user);  }  /** * @dev gets the interest rate strategy contract address for the reserve * @param _reserve the reserve address * @return the address of the interest rate strategy contract **/ function getReserveInterestRateStrategyAddress(address _reserve) public view returns (address) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.interestRateStrategyAddress; }  /** * @dev gets the aToken contract address for the reserve * @param _reserve the reserve address * @return the address of the aToken contract **/  function getReserveATokenAddress(address _reserve) public view returns (address) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.aTokenAddress; }  /** * @dev gets the available liquidity in the reserve. The available liquidity is the balance of the core contract * @param _reserve the reserve address * @return the available liquidity **/ function getReserveAvailableLiquidity(address _reserve) public view returns (uint256) {     uint256 balance = 0;      if (_reserve == EthAddressLib.ethAddress()) {         balance = address(this).balance;     } else {         balance = IERC20(_reserve).balanceOf(address(this));     }     return balance; }  /** * @dev gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows * @param _reserve the reserve address * @return the total liquidity **/ function getReserveTotalLiquidity(address _reserve) public view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return getReserveAvailableLiquidity(_reserve).add(reserve.getTotalBorrows()); }  /** * @dev gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there * there has been 100% income. * @param _reserve the reserve address * @return the reserve normalized income **/ function getReserveNormalizedIncome(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.getNormalizedIncome(); }  /** * @dev gets the reserve total borrows * @param _reserve the reserve address * @return the total borrows (stable + variable) **/ function getReserveTotalBorrows(address _reserve) public view returns (uint256) {     return reserves[_reserve].getTotalBorrows(); }  /** * @dev gets the reserve total borrows stable * @param _reserve the reserve address * @return the total borrows stable **/ function getReserveTotalBorrowsStable(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.totalBorrowsStable; }  /** * @dev gets the reserve total borrows variable * @param _reserve the reserve address * @return the total borrows variable **/  function getReserveTotalBorrowsVariable(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.totalBorrowsVariable; }  /** * @dev gets the reserve liquidation threshold * @param _reserve the reserve address * @return the reserve liquidation threshold **/  function getReserveLiquidationThreshold(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.liquidationThreshold; }  /** * @dev gets the reserve liquidation bonus * @param _reserve the reserve address * @return the reserve liquidation bonus **/  function getReserveLiquidationBonus(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.liquidationBonus; }  /** * @dev gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty * @param _reserve the reserve address * @return the reserve current variable borrow rate **/  function getReserveCurrentVariableBorrowRate(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      if (reserve.currentVariableBorrowRate == 0) {         return         IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)         .getBaseVariableBorrowRate();     }     return reserve.currentVariableBorrowRate; }  /** * @dev gets the reserve current stable borrow rate. Is the market rate if the reserve is empty * @param _reserve the reserve address * @return the reserve current stable borrow rate **/  function getReserveCurrentStableBorrowRate(address _reserve) public view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     ILendingRateOracle oracle = ILendingRateOracle(addressesProvider.getLendingRateOracle());      if (reserve.currentStableBorrowRate == 0) {         //no stable rate borrows yet         return oracle.getMarketBorrowRate(_reserve);     }      return reserve.currentStableBorrowRate; }  /** * @dev gets the reserve average stable borrow rate. The average stable rate is the weighted average * of all the loans taken at stable rate. * @param _reserve the reserve address * @return the reserve current average borrow rate **/ function getReserveCurrentAverageStableBorrowRate(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.currentAverageStableBorrowRate; }  /** * @dev gets the reserve liquidity rate * @param _reserve the reserve address * @return the reserve liquidity rate **/ function getReserveCurrentLiquidityRate(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.currentLiquidityRate; }  /** * @dev gets the reserve liquidity cumulative index * @param _reserve the reserve address * @return the reserve liquidity cumulative index **/ function getReserveLiquidityCumulativeIndex(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.lastLiquidityCumulativeIndex; }  /** * @dev gets the reserve variable borrow index * @param _reserve the reserve address * @return the reserve variable borrow index **/ function getReserveVariableBorrowsCumulativeIndex(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.lastVariableBorrowCumulativeIndex; }  /** * @dev this function aggregates the configuration parameters of the reserve. * It's used in the LendingPoolDataProvider specifically to save gas, and avoid * multiple external contract calls to fetch the same data. * @param _reserve the reserve address * @return the reserve decimals * @return the base ltv as collateral * @return the liquidation threshold * @return if the reserve is used as collateral or not **/ function getReserveConfiguration(address _reserve) external view returns (uint256, uint256, uint256, bool) {     uint256 decimals;     uint256 baseLTVasCollateral;     uint256 liquidationThreshold;     bool usageAsCollateralEnabled;      CoreLibrary.ReserveData storage reserve = reserves[_reserve];     decimals = reserve.decimals;     baseLTVasCollateral = reserve.baseLTVasCollateral;     liquidationThreshold = reserve.liquidationThreshold;     usageAsCollateralEnabled = reserve.usageAsCollateralEnabled;      return (decimals, baseLTVasCollateral, liquidationThreshold, usageAsCollateralEnabled); }  /** * @dev returns the decimals of the reserve * @param _reserve the reserve address * @return the reserve decimals **/ function getReserveDecimals(address _reserve) external view returns (uint256) {     return reserves[_reserve].decimals; }  /** * @dev returns true if the reserve is enabled for borrowing * @param _reserve the reserve address * @return true if the reserve is enabled for borrowing, false otherwise **/  function isReserveBorrowingEnabled(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.borrowingEnabled; }  /** * @dev returns true if the reserve is enabled as collateral * @param _reserve the reserve address * @return true if the reserve is enabled as collateral, false otherwise **/  function isReserveUsageAsCollateralEnabled(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.usageAsCollateralEnabled; }  /** * @dev returns true if the stable rate is enabled on reserve * @param _reserve the reserve address * @return true if the stable rate is enabled on reserve, false otherwise **/ function getReserveIsStableBorrowRateEnabled(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.isStableBorrowRateEnabled; }  /** * @dev returns true if the reserve is active * @param _reserve the reserve address * @return true if the reserve is active, false otherwise **/ function getReserveIsActive(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.isActive; }  /** * @notice returns if a reserve is freezed * @param _reserve the reserve for which the information is needed * @return true if the reserve is freezed, false otherwise **/  function getReserveIsFreezed(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.isFreezed; }  /** * @notice returns the timestamp of the last action on the reserve * @param _reserve the reserve for which the information is needed * @return the last updated timestamp of the reserve **/  function getReserveLastUpdate(address _reserve) external view returns (uint40 timestamp) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     timestamp = reserve.lastUpdateTimestamp; }  /** * @dev returns the utilization rate U of a specific reserve * @param _reserve the reserve for which the information is needed * @return the utilization rate in ray **/  function getReserveUtilizationRate(address _reserve) public view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      uint256 totalBorrows = reserve.getTotalBorrows();      if (totalBorrows == 0) {         return 0;     }      uint256 availableLiquidity = getReserveAvailableLiquidity(_reserve);      return totalBorrows.rayDiv(availableLiquidity.add(totalBorrows)); }  /** * @return the array of reserves configured on the core **/ function getReserves() external view returns (address[] memory) {     return reservesList; }  /** * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return true if the user has chosen to use the reserve as collateral, false otherwise **/ function isUserUseReserveAsCollateralEnabled(address _reserve, address _user) external view returns (bool) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.useAsCollateral; }  /** * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the origination fee for the user **/ function getUserOriginationFee(address _reserve, address _user) external view returns (uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.originationFee; }  /** * @dev users with no loans in progress have NONE as borrow rate mode * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the borrow rate mode for the user, **/  function getUserCurrentBorrowRateMode(address _reserve, address _user) public view returns (CoreLibrary.InterestRateMode) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      if (user.principalBorrowBalance == 0) {         return CoreLibrary.InterestRateMode.NONE;     }      return     user.stableBorrowRate &gt; 0     ? CoreLibrary.InterestRateMode.STABLE     : CoreLibrary.InterestRateMode.VARIABLE; }  /** * @dev gets the current borrow rate of the user * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the borrow rate for the user, **/ function getUserCurrentBorrowRate(address _reserve, address _user) internal view returns (uint256) {     CoreLibrary.InterestRateMode rateMode = getUserCurrentBorrowRateMode(_reserve, _user);      if (rateMode == CoreLibrary.InterestRateMode.NONE) {         return 0;     }      return     rateMode == CoreLibrary.InterestRateMode.STABLE     ? usersReserveData[_user][_reserve].stableBorrowRate     : reserves[_reserve].currentVariableBorrowRate; }  /** * @dev the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the user stable rate **/ function getUserCurrentStableBorrowRate(address _reserve, address _user) external view returns (uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.stableBorrowRate; }  /** * @dev calculates and returns the borrow balances of the user * @param _reserve the address of the reserve * @param _user the address of the user * @return the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance **/  function getUserBorrowBalances(address _reserve, address _user) public view returns (uint256, uint256, uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     if (user.principalBorrowBalance == 0) {         return (0, 0, 0);     }      uint256 principal = user.principalBorrowBalance;     uint256 compoundedBalance = CoreLibrary.getCompoundedBorrowBalance(         user,         reserves[_reserve]     );     return (principal, compoundedBalance, compoundedBalance.sub(principal)); }  /** * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the variable borrow index for the user **/  function getUserVariableBorrowCumulativeIndex(address _reserve, address _user) external view returns (uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.lastVariableBorrowCumulativeIndex; }  /** * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the variable borrow index for the user **/  function getUserLastUpdate(address _reserve, address _user) external view returns (uint256 timestamp) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     timestamp = user.lastUpdateTimestamp; }  /** * @dev updates the lending pool core configuration **/ function refreshConfiguration() external onlyLendingPoolConfigurator {     refreshConfigInternal(); }  /** * @dev initializes a reserve * @param _reserve the address of the reserve * @param _aTokenAddress the address of the overlying aToken contract * @param _decimals the decimals of the reserve currency * @param _interestRateStrategyAddress the address of the interest rate strategy contract **/ function initReserve(     address _reserve,     address _aTokenAddress,     uint256 _decimals,     address _interestRateStrategyAddress ) external onlyLendingPoolConfigurator {     reserves[_reserve].init(_aTokenAddress, _decimals, _interestRateStrategyAddress);     addReserveToListInternal(_reserve);  }    /** * @dev removes the last added reserve in the reservesList array * @param _reserveToRemove the address of the reserve **/ function removeLastAddedReserve(address _reserveToRemove) external onlyLendingPoolConfigurator {      address lastReserve = reservesList[reservesList.length-1];      require(lastReserve == _reserveToRemove, "Reserve being removed is different than the reserve requested");      //as we can't check if totalLiquidity is 0 (since the reserve added might not be an ERC20) we at least check that there is nothing borrowed     require(getReserveTotalBorrows(lastReserve) == 0, "Cannot remove a reserve with liquidity deposited");      reserves[lastReserve].isActive = false;     reserves[lastReserve].aTokenAddress = address(0);     reserves[lastReserve].decimals = 0;     reserves[lastReserve].lastLiquidityCumulativeIndex = 0;     reserves[lastReserve].lastVariableBorrowCumulativeIndex = 0;     reserves[lastReserve].borrowingEnabled = false;     reserves[lastReserve].usageAsCollateralEnabled = false;     reserves[lastReserve].baseLTVasCollateral = 0;     reserves[lastReserve].liquidationThreshold = 0;     reserves[lastReserve].liquidationBonus = 0;     reserves[lastReserve].interestRateStrategyAddress = address(0);      reservesList.pop(); }  /** * @dev updates the address of the interest rate strategy contract * @param _reserve the address of the reserve * @param _rateStrategyAddress the address of the interest rate strategy contract **/  function setReserveInterestRateStrategyAddress(address _reserve, address _rateStrategyAddress) external onlyLendingPoolConfigurator {     reserves[_reserve].interestRateStrategyAddress = _rateStrategyAddress; }  /** * @dev enables borrowing on a reserve. Also sets the stable rate borrowing * @param _reserve the address of the reserve * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise **/  function enableBorrowingOnReserve(address _reserve, bool _stableBorrowRateEnabled) external onlyLendingPoolConfigurator {     reserves[_reserve].enableBorrowing(_stableBorrowRateEnabled); }  /** * @dev disables borrowing on a reserve * @param _reserve the address of the reserve **/  function disableBorrowingOnReserve(address _reserve) external onlyLendingPoolConfigurator {     reserves[_reserve].disableBorrowing(); }  /** * @dev enables a reserve to be used as collateral * @param _reserve the address of the reserve **/ function enableReserveAsCollateral(     address _reserve,     uint256 _baseLTVasCollateral,     uint256 _liquidationThreshold,     uint256 _liquidationBonus ) external onlyLendingPoolConfigurator {     reserves[_reserve].enableAsCollateral(         _baseLTVasCollateral,         _liquidationThreshold,         _liquidationBonus     ); }  /** * @dev disables a reserve to be used as collateral * @param _reserve the address of the reserve **/ function disableReserveAsCollateral(address _reserve) external onlyLendingPoolConfigurator {     reserves[_reserve].disableAsCollateral(); }  /** * @dev enable the stable borrow rate mode on a reserve * @param _reserve the address of the reserve **/ function enableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isStableBorrowRateEnabled = true; }  /** * @dev disable the stable borrow rate mode on a reserve * @param _reserve the address of the reserve **/ function disableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isStableBorrowRateEnabled = false; }  /** * @dev activates a reserve * @param _reserve the address of the reserve **/ function activateReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      require(         reserve.lastLiquidityCumulativeIndex &gt; 0 &amp;&amp;         reserve.lastVariableBorrowCumulativeIndex &gt; 0,         "Reserve has not been initialized yet"     );     reserve.isActive = true; }  /** * @dev deactivates a reserve * @param _reserve the address of the reserve **/ function deactivateReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isActive = false; }  /** * @notice allows the configurator to freeze the reserve. * A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance. * @param _reserve the address of the reserve **/ function freezeReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isFreezed = true; }  /** * @notice allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed. * @param _reserve the address of the reserve **/ function unfreezeReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isFreezed = false; }  /** * @notice allows the configurator to update the loan to value of a reserve * @param _reserve the address of the reserve * @param _ltv the new loan to value **/ function setReserveBaseLTVasCollateral(address _reserve, uint256 _ltv) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.baseLTVasCollateral = _ltv; }  /** * @notice allows the configurator to update the liquidation threshold of a reserve * @param _reserve the address of the reserve * @param _threshold the new liquidation threshold **/ function setReserveLiquidationThreshold(address _reserve, uint256 _threshold) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.liquidationThreshold = _threshold; }  /** * @notice allows the configurator to update the liquidation bonus of a reserve * @param _reserve the address of the reserve * @param _bonus the new liquidation bonus **/ function setReserveLiquidationBonus(address _reserve, uint256 _bonus) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.liquidationBonus = _bonus; }  /** * @notice allows the configurator to update the reserve decimals * @param _reserve the address of the reserve * @param _decimals the decimals of the reserve **/ function setReserveDecimals(address _reserve, uint256 _decimals) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.decimals = _decimals; }  /** * @notice internal functions **/  /** * @dev updates the state of a reserve as a consequence of a borrow action. * @param _reserve the address of the reserve on which the user is borrowing * @param _user the address of the borrower * @param _principalBorrowBalance the previous borrow balance of the borrower before the action * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount * @param _amountBorrowed the new amount borrowed * @param _rateMode the borrow rate mode (stable, variable) **/  function updateReserveStateOnBorrowInternal(     address _reserve,     address _user,     uint256 _principalBorrowBalance,     uint256 _balanceIncrease,     uint256 _amountBorrowed,     CoreLibrary.InterestRateMode _rateMode ) internal {     reserves[_reserve].updateCumulativeIndexes();      //increasing reserve total borrows to account for the new borrow balance of the user     //NOTE: Depending on the previous borrow mode, the borrows might need to be switched from variable to stable or vice versa      updateReserveTotalBorrowsByRateModeInternal(         _reserve,         _user,         _principalBorrowBalance,         _balanceIncrease,         _amountBorrowed,         _rateMode     ); }  /** * @dev updates the state of a user as a consequence of a borrow action. * @param _reserve the address of the reserve on which the user is borrowing * @param _user the address of the borrower * @param _amountBorrowed the amount borrowed * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount * @param _rateMode the borrow rate mode (stable, variable) * @return the final borrow rate for the user. Emitted by the borrow() event **/  function updateUserStateOnBorrowInternal(     address _reserve,     address _user,     uint256 _amountBorrowed,     uint256 _balanceIncrease,     uint256 _fee,     CoreLibrary.InterestRateMode _rateMode ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      if (_rateMode == CoreLibrary.InterestRateMode.STABLE) {         //stable         //reset the user variable index, and update the stable rate         user.stableBorrowRate = reserve.currentStableBorrowRate;         user.lastVariableBorrowCumulativeIndex = 0;     } else if (_rateMode == CoreLibrary.InterestRateMode.VARIABLE) {         //variable         //reset the user stable rate, and store the new borrow index         user.stableBorrowRate = 0;         user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;     } else {         revert("Invalid borrow rate mode");     }     //increase the principal borrows and the origination fee     user.principalBorrowBalance = user.principalBorrowBalance.add(_amountBorrowed).add(         _balanceIncrease     );     user.originationFee = user.originationFee.add(_fee);      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp);  }  /** * @dev updates the state of the reserve as a consequence of a repay action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _paybackAmountMinusFees the amount being paid back minus fees * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updateReserveStateOnRepayInternal(     address _reserve,     address _user,     uint256 _paybackAmountMinusFees,     uint256 _balanceIncrease ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_reserve][_user];      CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(_reserve, _user);      //update the indexes     reserves[_reserve].updateCumulativeIndexes();      //compound the cumulated interest to the borrow balance and then subtracting the payback amount     if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             _balanceIncrease,             user.stableBorrowRate         );         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _paybackAmountMinusFees,             user.stableBorrowRate         );     } else {         reserve.increaseTotalBorrowsVariable(_balanceIncrease);         reserve.decreaseTotalBorrowsVariable(_paybackAmountMinusFees);     } }  /** * @dev updates the state of the user as a consequence of a repay action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _paybackAmountMinusFees the amount being paid back minus fees * @param _originationFeeRepaid the fee on the amount that is being repaid * @param _balanceIncrease the accrued interest on the borrowed amount * @param _repaidWholeLoan true if the user is repaying the whole loan **/ function updateUserStateOnRepayInternal(     address _reserve,     address _user,     uint256 _paybackAmountMinusFees,     uint256 _originationFeeRepaid,     uint256 _balanceIncrease,     bool _repaidWholeLoan ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      //update the user principal borrow balance, adding the cumulated interest and then subtracting the payback amount     user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(         _paybackAmountMinusFees     );     user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;      //if the balance decrease is equal to the previous principal (user is repaying the whole loan)     //and the rate mode is stable, we reset the interest rate mode of the user     if (_repaidWholeLoan) {         user.stableBorrowRate = 0;         user.lastVariableBorrowCumulativeIndex = 0;     }     user.originationFee = user.originationFee.sub(_originationFeeRepaid);      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp);  }  /** * @dev updates the state of the user as a consequence of a swap rate action. * @param _reserve the address of the reserve on which the user is performing the rate swap * @param _user the address of the borrower * @param _principalBorrowBalance the the principal amount borrowed by the user * @param _compoundedBorrowBalance the principal amount plus the accrued interest * @param _currentRateMode the rate mode at which the user borrowed **/ function updateReserveStateOnSwapRateInternal(     address _reserve,     address _user,     uint256 _principalBorrowBalance,     uint256 _compoundedBorrowBalance,     CoreLibrary.InterestRateMode _currentRateMode ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      //compounding reserve indexes     reserve.updateCumulativeIndexes();      if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {         uint256 userCurrentStableRate = user.stableBorrowRate;          //swap to variable         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _principalBorrowBalance,             userCurrentStableRate         ); //decreasing stable from old principal balance         reserve.increaseTotalBorrowsVariable(_compoundedBorrowBalance); //increase variable borrows     } else if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         //swap to stable         uint256 currentStableRate = reserve.currentStableBorrowRate;         reserve.decreaseTotalBorrowsVariable(_principalBorrowBalance);         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             _compoundedBorrowBalance,             currentStableRate         );      } else {         revert("Invalid rate mode received");     } }  /** * @dev updates the state of the user as a consequence of a swap rate action. * @param _reserve the address of the reserve on which the user is performing the swap * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount * @param _currentRateMode the current rate mode of the user **/  function updateUserStateOnSwapRateInternal(     address _reserve,     address _user,     uint256 _balanceIncrease,     CoreLibrary.InterestRateMode _currentRateMode ) internal returns (CoreLibrary.InterestRateMode) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      CoreLibrary.InterestRateMode newMode = CoreLibrary.InterestRateMode.NONE;      if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         //switch to stable         newMode = CoreLibrary.InterestRateMode.STABLE;         user.stableBorrowRate = reserve.currentStableBorrowRate;         user.lastVariableBorrowCumulativeIndex = 0;     } else if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {         newMode = CoreLibrary.InterestRateMode.VARIABLE;         user.stableBorrowRate = 0;         user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;     } else {         revert("Invalid interest rate mode received");     }     //compounding cumulated interest     user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);     //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp);      return newMode; }  /** * @dev updates the state of the principal reserve as a consequence of a liquidation action. * @param _principalReserve the address of the principal reserve that is being repaid * @param _user the address of the borrower * @param _amountToLiquidate the amount being repaid by the liquidator * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updatePrincipalReserveStateOnLiquidationInternal(     address _principalReserve,     address _user,     uint256 _amountToLiquidate,     uint256 _balanceIncrease ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_principalReserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_principalReserve];      //update principal reserve data     reserve.updateCumulativeIndexes();      CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(         _principalReserve,         _user     );      if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {         //increase the total borrows by the compounded interest         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             _balanceIncrease,             user.stableBorrowRate         );          //decrease by the actual amount to liquidate         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _amountToLiquidate,             user.stableBorrowRate         );      } else {         //increase the total borrows by the compounded interest         reserve.increaseTotalBorrowsVariable(_balanceIncrease);          //decrease by the actual amount to liquidate         reserve.decreaseTotalBorrowsVariable(_amountToLiquidate);     }  }  /** * @dev updates the state of the collateral reserve as a consequence of a liquidation action. * @param _collateralReserve the address of the collateral reserve that is being liquidated **/ function updateCollateralReserveStateOnLiquidationInternal(     address _collateralReserve ) internal {     //update collateral reserve     reserves[_collateralReserve].updateCumulativeIndexes();  }  /** * @dev updates the state of the user being liquidated as a consequence of a liquidation action. * @param _reserve the address of the principal reserve that is being repaid * @param _user the address of the borrower * @param _amountToLiquidate the amount being repaid by the liquidator * @param _feeLiquidated the amount of origination fee being liquidated * @param _balanceIncrease the accrued interest on the borrowed amount **/ function updateUserStateOnLiquidationInternal(     address _reserve,     address _user,     uint256 _amountToLiquidate,     uint256 _feeLiquidated,     uint256 _balanceIncrease ) internal {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     //first increase by the compounded interest, then decrease by the liquidated amount     user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(         _amountToLiquidate     );      if (         getUserCurrentBorrowRateMode(_reserve, _user) == CoreLibrary.InterestRateMode.VARIABLE     ) {         user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;     }      if(_feeLiquidated &gt; 0){         user.originationFee = user.originationFee.sub(_feeLiquidated);     }      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp); }  /** * @dev updates the state of the reserve as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updateReserveStateOnRebalanceInternal(     address _reserve,     address _user,     uint256 _balanceIncrease ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      reserve.updateCumulativeIndexes();      reserve.increaseTotalBorrowsStableAndUpdateAverageRate(         _balanceIncrease,         user.stableBorrowRate     );  }  /** * @dev updates the state of the user as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updateUserStateOnRebalanceInternal(     address _reserve,     address _user,     uint256 _balanceIncrease ) internal {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);     user.stableBorrowRate = reserve.currentStableBorrowRate;      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp); }  /** * @dev updates the state of the user as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount * @param _amountBorrowed the accrued interest on the borrowed amount **/ function updateReserveTotalBorrowsByRateModeInternal(     address _reserve,     address _user,     uint256 _principalBalance,     uint256 _balanceIncrease,     uint256 _amountBorrowed,     CoreLibrary.InterestRateMode _newBorrowRateMode ) internal {     CoreLibrary.InterestRateMode previousRateMode = getUserCurrentBorrowRateMode(         _reserve,         _user     );     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      if (previousRateMode == CoreLibrary.InterestRateMode.STABLE) {         CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _principalBalance,             user.stableBorrowRate         );     } else if (previousRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         reserve.decreaseTotalBorrowsVariable(_principalBalance);     }      uint256 newPrincipalAmount = _principalBalance.add(_balanceIncrease).add(_amountBorrowed);     if (_newBorrowRateMode == CoreLibrary.InterestRateMode.STABLE) {         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             newPrincipalAmount,             reserve.currentStableBorrowRate         );     } else if (_newBorrowRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         reserve.increaseTotalBorrowsVariable(newPrincipalAmount);     } else {         revert("Invalid new borrow rate mode");     } }  /** * @dev Updates the reserve current stable borrow rate Rf, the current variable borrow rate Rv and the current liquidity rate Rl. * Also updates the lastUpdateTimestamp value. Please refer to the whitepaper for further information. * @param _reserve the address of the reserve to be updated * @param _liquidityAdded the amount of liquidity added to the protocol (deposit or repay) in the previous action * @param _liquidityTaken the amount of liquidity taken from the protocol (redeem or borrow) **/  function updateReserveInterestRatesAndTimestampInternal(     address _reserve,     uint256 _liquidityAdded,     uint256 _liquidityTaken ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     (uint256 newLiquidityRate, uint256 newStableRate, uint256 newVariableRate) = IReserveInterestRateStrategy(         reserve         .interestRateStrategyAddress     )     .calculateInterestRates(         _reserve,         getReserveAvailableLiquidity(_reserve).add(_liquidityAdded).sub(_liquidityTaken),         reserve.totalBorrowsStable,         reserve.totalBorrowsVariable,         reserve.currentAverageStableBorrowRate     );      reserve.currentLiquidityRate = newLiquidityRate;     reserve.currentStableBorrowRate = newStableRate;     reserve.currentVariableBorrowRate = newVariableRate;      //solium-disable-next-line     reserve.lastUpdateTimestamp = uint40(block.timestamp);      emit ReserveUpdated(         _reserve,         newLiquidityRate,         newStableRate,         newVariableRate,         reserve.lastLiquidityCumulativeIndex,         reserve.lastVariableBorrowCumulativeIndex     ); }  /** * @dev transfers to the protocol fees of a flashloan to the fees collection address * @param _token the address of the token being transferred * @param _amount the amount being transferred **/  function transferFlashLoanProtocolFeeInternal(address _token, uint256 _amount) internal {     address payable receiver = address(uint160(addressesProvider.getTokenDistributor()));      if (_token != EthAddressLib.ethAddress()) {         ERC20(_token).safeTransfer(receiver, _amount);     } else {         receiver.transfer(_amount);     } }  /** * @dev updates the internal configuration of the core **/ function refreshConfigInternal() internal {     lendingPoolAddress = addressesProvider.getLendingPool(); }  /** * @dev adds a reserve to the array of the reserves address **/ function addReserveToListInternal(address _reserve) internal {     bool reserveAlreadyAdded = false;     for (uint256 i = 0; i &lt; reservesList.length; i++)         if (reservesList[i] == _reserve) {             reserveAlreadyAdded = true;         }     if (!reserveAlreadyAdded) reservesList.push(_reserve); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 04:31:42 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: pragma solidity ^0.5.0;

import "openzeppelin-solidity/contracts/math/SafeMath.sol";
import "openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol";
import "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol";
import "openzeppelin-solidity/contracts/utils/Address.sol";
import "../libraries/openzeppelin-upgradeability/VersionedInitializable.sol";

import "../libraries/CoreLibrary.sol";
import "../configuration/LendingPoolAddressesProvider.sol";
import "../interfaces/ILendingRateOracle.sol";
import "../interfaces/IReserveInterestRateStrategy.sol";
import "../libraries/WadRayMath.sol";
import "../tokenization/AToken.sol";
import "../libraries/EthAddressLib.sol";

/**
* @title LendingPoolCore contract
* @author Aave
* @notice Holds the state of the lending pool and all the funds deposited
* @dev NOTE: The core does not enforce security checks on the update of the state
* (eg, updateStateOnBorrow() does not enforce that borrowed is enabled on the reserve).
* The check that an action can be performed is a duty of the overlying LendingPool contract.
**/

contract LendingPoolCore is VersionedInitializable {
    using SafeMath for uint256;
    using WadRayMath for uint256;
    using CoreLibrary for CoreLibrary.ReserveData;
    using CoreLibrary for CoreLibrary.UserReserveData;
    using SafeERC20 for ERC20;
    using Address for address payable;

    /**
    * @dev Emitted when the state of a reserve is updated
    * @param reserve the address of the reserve
    * @param liquidityRate the new liquidity rate
    * @param stableBorrowRate the new stable borrow rate
    * @param variableBorrowRate the new variable borrow rate
    * @param liquidityIndex the new liquidity index
    * @param variableBorrowIndex the new variable borrow index
    **/
    event ReserveUpdated(
        address indexed reserve,
        uint256 liquidityRate,
        uint256 stableBorrowRate,
        uint256 variableBorrowRate,
        uint256 liquidityIndex,
        uint256 variableBorrowIndex
    );

    address public lendingPoolAddress;

    LendingPoolAddressesProvider public addressesProvider;

    /**
    * @dev only lending pools can use functions affected by this modifier
    **/
    modifier onlyLendingPool {
        require(lendingPoolAddress == msg.sender, "The caller must be a lending pool contract");
        _;
    }

    /**
    * @dev only lending pools configurator can use functions affected by this modifier
    **/
    modifier onlyLendingPoolConfigurator {
        require(
            addressesProvider.getLendingPoolConfigurator() == msg.sender,
            "The caller must be a lending pool configurator contract"
        );
        _;
    }

    mapping(address => CoreLibrary.ReserveData) internal reserves;
    mapping(address => mapping(address => CoreLibrary.UserReserveData)) internal usersReserveData;

    address[] public reservesList;

    uint256 public constant CORE_REVISION = 0x4;

    /**
    * @dev returns the revision number of the contract
    **/
    function getRevision() internal pure returns (uint256) {
        return CORE_REVISION;
    }

    /**
    * @dev initializes the Core contract, invoked upon registration on the AddressesProvider
    * @param _addressesProvider the addressesProvider contract
    **/

    function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {
        addressesProvider = _addressesProvider;
        refreshConfigInternal();
    }

    /**
    * @dev updates the state of the core as a result of a deposit action
    * @param _reserve the address of the reserve in which the deposit is happening
    * @param _user the address of the the user depositing
    * @param _amount the amount being deposited
    * @param _isFirstDeposit true if the user is depositing for the first time
    **/

    function updateStateOnDeposit(
        address _reserve,
        address _user,
        uint256 _amount,
        bool _isFirstDeposit
    ) external onlyLendingPool {
        reserves[_reserve].updateCumulativeIndexes();
        updateReserveInterestRatesAndTimestampInternal(_reserve, _amount, 0);

        if (_isFirstDeposit) {
            //if this is the first deposit of the user, we configure the deposit as enabled to be used as collateral
            setUserUseReserveAsCollateral(_reserve, _user, true);
        }
    }

    /**
    * @dev updates the state of the core as a result of a redeem action
    * @param _reserve the address of the reserve in which the redeem is happening
    * @param _user the address of the the user redeeming
    * @param _amountRedeemed the amount being redeemed
    * @param _userRedeemedEverything true if the user is redeeming everything
    **/
    function updateStateOnRedeem(
        address _reserve,
        address _user,
        uint256 _amountRedeemed,
        bool _userRedeemedEverything
    ) external onlyLendingPool {
        //compound liquidity and variable borrow interests
        reserves[_reserve].updateCumulativeIndexes();
        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountRedeemed);

        //if user redeemed everything the useReserveAsCollateral flag is reset
        if (_userRedeemedEverything) {
            setUserUseReserveAsCollateral(_reserve, _user, false);
        }
    }

    /**
    * @dev updates the state of the core as a result of a flashloan action
    * @param _reserve the address of the reserve in which the flashloan is happening
    * @param _income the income of the protocol as a result of the action
    **/
    function updateStateOnFlashLoan(
        address _reserve,
        uint256 _availableLiquidityBefore,
        uint256 _income,
        uint256 _protocolFee
    ) external onlyLendingPool {
        transferFlashLoanProtocolFeeInternal(_reserve, _protocolFee);

        //compounding the cumulated interest
        reserves[_reserve].updateCumulativeIndexes();

        uint256 totalLiquidityBefore = _availableLiquidityBefore.add(
            getReserveTotalBorrows(_reserve)
        );

        //compounding the received fee into the reserve
        reserves[_reserve].cumulateToLiquidityIndex(totalLiquidityBefore, _income);

        //refresh interest rates
        updateReserveInterestRatesAndTimestampInternal(_reserve, _income, 0);
    }

    /**
    * @dev updates the state of the core as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _amountBorrowed the new amount borrowed
    * @param _borrowFee the fee on the amount borrowed
    * @param _rateMode the borrow rate mode (stable, variable)
    * @return the new borrow rate for the user
    **/
    function updateStateOnBorrow(
        address _reserve,
        address _user,
        uint256 _amountBorrowed,
        uint256 _borrowFee,
        CoreLibrary.InterestRateMode _rateMode
    ) external onlyLendingPool returns (uint256, uint256) {
        // getting the previous borrow data of the user
        (uint256 principalBorrowBalance, , uint256 balanceIncrease) = getUserBorrowBalances(
            _reserve,
            _user
        );

        updateReserveStateOnBorrowInternal(
            _reserve,
            _user,
            principalBorrowBalance,
            balanceIncrease,
            _amountBorrowed,
            _rateMode
        );

        updateUserStateOnBorrowInternal(
            _reserve,
            _user,
            _amountBorrowed,
            balanceIncrease,
            _borrowFee,
            _rateMode
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountBorrowed);

        return (getUserCurrentBorrowRate(_reserve, _user), balanceIncrease);
    }

    /**
    * @dev updates the state of the core as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _originationFeeRepaid the fee on the amount that is being repaid
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _repaidWholeLoan true if the user is repaying the whole loan
    **/

    function updateStateOnRepay(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _originationFeeRepaid,
        uint256 _balanceIncrease,
        bool _repaidWholeLoan
    ) external onlyLendingPool {
        updateReserveStateOnRepayInternal(
            _reserve,
            _user,
            _paybackAmountMinusFees,
            _balanceIncrease
        );
        updateUserStateOnRepayInternal(
            _reserve,
            _user,
            _paybackAmountMinusFees,
            _originationFeeRepaid,
            _balanceIncrease,
            _repaidWholeLoan
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, _paybackAmountMinusFees, 0);
    }

    /**
    * @dev updates the state of the core as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the amount borrowed by the user
    * @param _compoundedBorrowBalance the amount borrowed plus accrued interest
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _currentRateMode the current interest rate mode for the user
    **/
    function updateStateOnSwapRate(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _compoundedBorrowBalance,
        uint256 _balanceIncrease,
        CoreLibrary.InterestRateMode _currentRateMode
    ) external onlyLendingPool returns (CoreLibrary.InterestRateMode, uint256) {
        updateReserveStateOnSwapRateInternal(
            _reserve,
            _user,
            _principalBorrowBalance,
            _compoundedBorrowBalance,
            _currentRateMode
        );

        CoreLibrary.InterestRateMode newRateMode = updateUserStateOnSwapRateInternal(
            _reserve,
            _user,
            _balanceIncrease,
            _currentRateMode
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);

        return (newRateMode, getUserCurrentBorrowRate(_reserve, _user));
    }

    /**
    * @dev updates the state of the core as a consequence of a liquidation action.
    * @param _principalReserve the address of the principal reserve that is being repaid
    * @param _collateralReserve the address of the collateral reserve that is being liquidated
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _collateralToLiquidate the amount of collateral being liquidated
    * @param _feeLiquidated the amount of origination fee being liquidated
    * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise
    **/
    function updateStateOnLiquidation(
        address _principalReserve,
        address _collateralReserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _collateralToLiquidate,
        uint256 _feeLiquidated,
        uint256 _liquidatedCollateralForFee,
        uint256 _balanceIncrease,
        bool _liquidatorReceivesAToken
    ) external onlyLendingPool {
        updatePrincipalReserveStateOnLiquidationInternal(
            _principalReserve,
            _user,
            _amountToLiquidate,
            _balanceIncrease
        );

        updateCollateralReserveStateOnLiquidationInternal(
            _collateralReserve
        );

        updateUserStateOnLiquidationInternal(
            _principalReserve,
            _user,
            _amountToLiquidate,
            _feeLiquidated,
            _balanceIncrease
        );

        updateReserveInterestRatesAndTimestampInternal(_principalReserve, _amountToLiquidate, 0);

        if (!_liquidatorReceivesAToken) {
            updateReserveInterestRatesAndTimestampInternal(
                _collateralReserve,
                0,
                _collateralToLiquidate.add(_liquidatedCollateralForFee)
            );
        }

    }

    /**
    * @dev updates the state of the core as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @return the new stable rate for the user
    **/
    function updateStateOnRebalance(address _reserve, address _user, uint256 _balanceIncrease)
    external
    onlyLendingPool
    returns (uint256)
    {
        updateReserveStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);

        //update user data and rebalance the rate
        updateUserStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);
        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);
        return usersReserveData[_user][_reserve].stableBorrowRate;
    }

    /**
    * @dev enables or disables a reserve as collateral
    * @param _reserve the address of the principal reserve where the user deposited
    * @param _user the address of the depositor
    * @param _useAsCollateral true if the depositor wants to use the reserve as collateral
    **/
    function setUserUseReserveAsCollateral(address _reserve, address _user, bool _useAsCollateral)
    public
    onlyLendingPool
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        user.useAsCollateral = _useAsCollateral;
    }

    /**
    * @notice ETH/token transfer functions
    **/

    /**
    * @dev fallback function enforces that the caller is a contract, to support flashloan transfers
    **/
    function() external payable {
        //only contracts can send ETH to the core
        require(msg.sender.isContract(), "Only contracts can send ether to the Lending pool core");

    }

    /**
    * @dev transfers to the user a specific amount from the reserve.
    * @param _reserve the address of the reserve where the transfer is happening
    * @param _user the address of the user receiving the transfer
    * @param _amount the amount being transferred
    **/
    function transferToUser(address _reserve, address payable _user, uint256 _amount)
    external
    onlyLendingPool
    {
        if (_reserve != EthAddressLib.ethAddress()) {
            ERC20(_reserve).safeTransfer(_user, _amount);
        } else {
            //solium-disable-next-line
            (bool result, ) = _user.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers the protocol fees to the fees collection address
    * @param _token the address of the token being transferred
    * @param _user the address of the user from where the transfer is happening
    * @param _amount the amount being transferred
    * @param _destination the fee receiver address
    **/

    function transferToFeeCollectionAddress(
        address _token,
        address _user,
        uint256 _amount,
        address _destination
    ) external payable onlyLendingPool {
        address payable feeAddress = address(uint160(_destination)); //cast the address to payable

        if (_token != EthAddressLib.ethAddress()) {
            require(
                msg.value == 0,
                "User is sending ETH along with the ERC20 transfer. Check the value attribute of the transaction"
            );
            ERC20(_token).safeTransferFrom(_user, feeAddress, _amount);
        } else {
            require(msg.value >= _amount, "The amount and the value sent to deposit do not match");
            //solium-disable-next-line
            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers the fees to the fees collection address in the case of liquidation
    * @param _token the address of the token being transferred
    * @param _amount the amount being transferred
    * @param _destination the fee receiver address
    **/
    function liquidateFee(
        address _token,
        uint256 _amount,
        address _destination
    ) external payable onlyLendingPool {
        address payable feeAddress = address(uint160(_destination)); //cast the address to payable
        require(
            msg.value == 0,
            "Fee liquidation does not require any transfer of value"
        );

        if (_token != EthAddressLib.ethAddress()) {
            ERC20(_token).safeTransfer(feeAddress, _amount);
        } else {
            //solium-disable-next-line
            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers an amount from a user to the destination reserve
    * @param _reserve the address of the reserve where the amount is being transferred
    * @param _user the address of the user from where the transfer is happening
    * @param _amount the amount being transferred
    **/
    function transferToReserve(address _reserve, address payable _user, uint256 _amount)
    external
    payable
    onlyLendingPool
    {
        if (_reserve != EthAddressLib.ethAddress()) {
            require(msg.value == 0, "User is sending ETH along with the ERC20 transfer.");
            ERC20(_reserve).safeTransferFrom(_user, address(this), _amount);

        } else {
            require(msg.value >= _amount, "The amount and the value sent to deposit do not match");

            if (msg.value > _amount) {
                //send back excess ETH
                uint256 excessAmount = msg.value.sub(_amount);
                //solium-disable-next-line
                (bool result, ) = _user.call.value(excessAmount).gas(50000)("");
                require(result, "Transfer of ETH failed");
            }
        }
    }

    /**
    * @notice data access functions
    **/

    /**
    * @dev returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral)
    * needed to calculate the global account data in the LendingPoolDataProvider
    * @param _reserve the address of the reserve
    * @param _user the address of the user
    * @return the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not
    **/
    function getUserBasicReserveData(address _reserve, address _user)
    external
    view
    returns (uint256, uint256, uint256, bool)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        uint256 underlyingBalance = getUserUnderlyingAssetBalance(_reserve, _user);

        if (user.principalBorrowBalance == 0) {
            return (underlyingBalance, 0, 0, user.useAsCollateral);
        }

        return (
        underlyingBalance,
        user.getCompoundedBorrowBalance(reserve),
        user.originationFee,
        user.useAsCollateral
        );
    }

    /**
    * @dev checks if a user is allowed to borrow at a stable rate
    * @param _reserve the reserve address
    * @param _user the user
    * @param _amount the amount the the user wants to borrow
    * @return true if the user is allowed to borrow at a stable rate, false otherwise
    **/

    function isUserAllowedToBorrowAtStable(address _reserve, address _user, uint256 _amount)
    external
    view
    returns (bool)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (!reserve.isStableBorrowRateEnabled) return false;

        return
        !user.useAsCollateral ||
        !reserve.usageAsCollateralEnabled ||
        _amount > getUserUnderlyingAssetBalance(_reserve, _user);
    }

    /**
    * @dev gets the underlying asset balance of a user based on the corresponding aToken balance.
    * @param _reserve the reserve address
    * @param _user the user address
    * @return the underlying deposit balance of the user
    **/

    function getUserUnderlyingAssetBalance(address _reserve, address _user)
    public
    view
    returns (uint256)
    {
        AToken aToken = AToken(reserves[_reserve].aTokenAddress);
        return aToken.balanceOf(_user);

    }

    /**
    * @dev gets the interest rate strategy contract address for the reserve
    * @param _reserve the reserve address
    * @return the address of the interest rate strategy contract
    **/
    function getReserveInterestRateStrategyAddress(address _reserve) public view returns (address) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.interestRateStrategyAddress;
    }

    /**
    * @dev gets the aToken contract address for the reserve
    * @param _reserve the reserve address
    * @return the address of the aToken contract
    **/

    function getReserveATokenAddress(address _reserve) public view returns (address) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.aTokenAddress;
    }

    /**
    * @dev gets the available liquidity in the reserve. The available liquidity is the balance of the core contract
    * @param _reserve the reserve address
    * @return the available liquidity
    **/
    function getReserveAvailableLiquidity(address _reserve) public view returns (uint256) {
        uint256 balance = 0;

        if (_reserve == EthAddressLib.ethAddress()) {
            balance = address(this).balance;
        } else {
            balance = IERC20(_reserve).balanceOf(address(this));
        }
        return balance;
    }

    /**
    * @dev gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows
    * @param _reserve the reserve address
    * @return the total liquidity
    **/
    function getReserveTotalLiquidity(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return getReserveAvailableLiquidity(_reserve).add(reserve.getTotalBorrows());
    }

    /**
    * @dev gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there
    * there has been 100% income.
    * @param _reserve the reserve address
    * @return the reserve normalized income
    **/
    function getReserveNormalizedIncome(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.getNormalizedIncome();
    }

    /**
    * @dev gets the reserve total borrows
    * @param _reserve the reserve address
    * @return the total borrows (stable + variable)
    **/
    function getReserveTotalBorrows(address _reserve) public view returns (uint256) {
        return reserves[_reserve].getTotalBorrows();
    }

    /**
    * @dev gets the reserve total borrows stable
    * @param _reserve the reserve address
    * @return the total borrows stable
    **/
    function getReserveTotalBorrowsStable(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.totalBorrowsStable;
    }

    /**
    * @dev gets the reserve total borrows variable
    * @param _reserve the reserve address
    * @return the total borrows variable
    **/

    function getReserveTotalBorrowsVariable(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.totalBorrowsVariable;
    }

    /**
    * @dev gets the reserve liquidation threshold
    * @param _reserve the reserve address
    * @return the reserve liquidation threshold
    **/

    function getReserveLiquidationThreshold(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.liquidationThreshold;
    }

    /**
    * @dev gets the reserve liquidation bonus
    * @param _reserve the reserve address
    * @return the reserve liquidation bonus
    **/

    function getReserveLiquidationBonus(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.liquidationBonus;
    }

    /**
    * @dev gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty
    * @param _reserve the reserve address
    * @return the reserve current variable borrow rate
    **/

    function getReserveCurrentVariableBorrowRate(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        if (reserve.currentVariableBorrowRate == 0) {
            return
            IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)
            .getBaseVariableBorrowRate();
        }
        return reserve.currentVariableBorrowRate;
    }

    /**
    * @dev gets the reserve current stable borrow rate. Is the market rate if the reserve is empty
    * @param _reserve the reserve address
    * @return the reserve current stable borrow rate
    **/

    function getReserveCurrentStableBorrowRate(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        ILendingRateOracle oracle = ILendingRateOracle(addressesProvider.getLendingRateOracle());

        if (reserve.currentStableBorrowRate == 0) {
            //no stable rate borrows yet
            return oracle.getMarketBorrowRate(_reserve);
        }

        return reserve.currentStableBorrowRate;
    }

    /**
    * @dev gets the reserve average stable borrow rate. The average stable rate is the weighted average
    * of all the loans taken at stable rate.
    * @param _reserve the reserve address
    * @return the reserve current average borrow rate
    **/
    function getReserveCurrentAverageStableBorrowRate(address _reserve)
    external
    view
    returns (uint256)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.currentAverageStableBorrowRate;
    }

    /**
    * @dev gets the reserve liquidity rate
    * @param _reserve the reserve address
    * @return the reserve liquidity rate
    **/
    function getReserveCurrentLiquidityRate(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.currentLiquidityRate;
    }

    /**
    * @dev gets the reserve liquidity cumulative index
    * @param _reserve the reserve address
    * @return the reserve liquidity cumulative index
    **/
    function getReserveLiquidityCumulativeIndex(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.lastLiquidityCumulativeIndex;
    }

    /**
    * @dev gets the reserve variable borrow index
    * @param _reserve the reserve address
    * @return the reserve variable borrow index
    **/
    function getReserveVariableBorrowsCumulativeIndex(address _reserve)
    external
    view
    returns (uint256)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.lastVariableBorrowCumulativeIndex;
    }

    /**
    * @dev this function aggregates the configuration parameters of the reserve.
    * It's used in the LendingPoolDataProvider specifically to save gas, and avoid
    * multiple external contract calls to fetch the same data.
    * @param _reserve the reserve address
    * @return the reserve decimals
    * @return the base ltv as collateral
    * @return the liquidation threshold
    * @return if the reserve is used as collateral or not
    **/
    function getReserveConfiguration(address _reserve)
    external
    view
    returns (uint256, uint256, uint256, bool)
    {
        uint256 decimals;
        uint256 baseLTVasCollateral;
        uint256 liquidationThreshold;
        bool usageAsCollateralEnabled;

        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        decimals = reserve.decimals;
        baseLTVasCollateral = reserve.baseLTVasCollateral;
        liquidationThreshold = reserve.liquidationThreshold;
        usageAsCollateralEnabled = reserve.usageAsCollateralEnabled;

        return (decimals, baseLTVasCollateral, liquidationThreshold, usageAsCollateralEnabled);
    }

    /**
    * @dev returns the decimals of the reserve
    * @param _reserve the reserve address
    * @return the reserve decimals
    **/
    function getReserveDecimals(address _reserve) external view returns (uint256) {
        return reserves[_reserve].decimals;
    }

    /**
    * @dev returns true if the reserve is enabled for borrowing
    * @param _reserve the reserve address
    * @return true if the reserve is enabled for borrowing, false otherwise
    **/

    function isReserveBorrowingEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.borrowingEnabled;
    }

    /**
    * @dev returns true if the reserve is enabled as collateral
    * @param _reserve the reserve address
    * @return true if the reserve is enabled as collateral, false otherwise
    **/

    function isReserveUsageAsCollateralEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.usageAsCollateralEnabled;
    }

    /**
    * @dev returns true if the stable rate is enabled on reserve
    * @param _reserve the reserve address
    * @return true if the stable rate is enabled on reserve, false otherwise
    **/
    function getReserveIsStableBorrowRateEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isStableBorrowRateEnabled;
    }

    /**
    * @dev returns true if the reserve is active
    * @param _reserve the reserve address
    * @return true if the reserve is active, false otherwise
    **/
    function getReserveIsActive(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isActive;
    }

    /**
    * @notice returns if a reserve is freezed
    * @param _reserve the reserve for which the information is needed
    * @return true if the reserve is freezed, false otherwise
    **/

    function getReserveIsFreezed(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isFreezed;
    }

    /**
    * @notice returns the timestamp of the last action on the reserve
    * @param _reserve the reserve for which the information is needed
    * @return the last updated timestamp of the reserve
    **/

    function getReserveLastUpdate(address _reserve) external view returns (uint40 timestamp) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        timestamp = reserve.lastUpdateTimestamp;
    }

    /**
    * @dev returns the utilization rate U of a specific reserve
    * @param _reserve the reserve for which the information is needed
    * @return the utilization rate in ray
    **/

    function getReserveUtilizationRate(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        uint256 totalBorrows = reserve.getTotalBorrows();

        if (totalBorrows == 0) {
            return 0;
        }

        uint256 availableLiquidity = getReserveAvailableLiquidity(_reserve);

        return totalBorrows.rayDiv(availableLiquidity.add(totalBorrows));
    }

    /**
    * @return the array of reserves configured on the core
    **/
    function getReserves() external view returns (address[] memory) {
        return reservesList;
    }

    /**
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return true if the user has chosen to use the reserve as collateral, false otherwise
    **/
    function isUserUseReserveAsCollateralEnabled(address _reserve, address _user)
    external
    view
    returns (bool)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.useAsCollateral;
    }

    /**
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the origination fee for the user
    **/
    function getUserOriginationFee(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.originationFee;
    }

    /**
    * @dev users with no loans in progress have NONE as borrow rate mode
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the borrow rate mode for the user,
    **/

    function getUserCurrentBorrowRateMode(address _reserve, address _user)
    public
    view
    returns (CoreLibrary.InterestRateMode)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (user.principalBorrowBalance == 0) {
            return CoreLibrary.InterestRateMode.NONE;
        }

        return
        user.stableBorrowRate > 0
        ? CoreLibrary.InterestRateMode.STABLE
        : CoreLibrary.InterestRateMode.VARIABLE;
    }

    /**
    * @dev gets the current borrow rate of the user
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the borrow rate for the user,
    **/
    function getUserCurrentBorrowRate(address _reserve, address _user)
    internal
    view
    returns (uint256)
    {
        CoreLibrary.InterestRateMode rateMode = getUserCurrentBorrowRateMode(_reserve, _user);

        if (rateMode == CoreLibrary.InterestRateMode.NONE) {
            return 0;
        }

        return
        rateMode == CoreLibrary.InterestRateMode.STABLE
        ? usersReserveData[_user][_reserve].stableBorrowRate
        : reserves[_reserve].currentVariableBorrowRate;
    }

    /**
    * @dev the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the user stable rate
    **/
    function getUserCurrentStableBorrowRate(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.stableBorrowRate;
    }

    /**
    * @dev calculates and returns the borrow balances of the user
    * @param _reserve the address of the reserve
    * @param _user the address of the user
    * @return the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance
    **/

    function getUserBorrowBalances(address _reserve, address _user)
    public
    view
    returns (uint256, uint256, uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        if (user.principalBorrowBalance == 0) {
            return (0, 0, 0);
        }

        uint256 principal = user.principalBorrowBalance;
        uint256 compoundedBalance = CoreLibrary.getCompoundedBorrowBalance(
            user,
            reserves[_reserve]
        );
        return (principal, compoundedBalance, compoundedBalance.sub(principal));
    }

    /**
    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the variable borrow index for the user
    **/

    function getUserVariableBorrowCumulativeIndex(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.lastVariableBorrowCumulativeIndex;
    }

    /**
    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the variable borrow index for the user
    **/

    function getUserLastUpdate(address _reserve, address _user)
    external
    view
    returns (uint256 timestamp)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        timestamp = user.lastUpdateTimestamp;
    }

    /**
    * @dev updates the lending pool core configuration
    **/
    function refreshConfiguration() external onlyLendingPoolConfigurator {
        refreshConfigInternal();
    }

    /**
    * @dev initializes a reserve
    * @param _reserve the address of the reserve
    * @param _aTokenAddress the address of the overlying aToken contract
    * @param _decimals the decimals of the reserve currency
    * @param _interestRateStrategyAddress the address of the interest rate strategy contract
    **/
    function initReserve(
        address _reserve,
        address _aTokenAddress,
        uint256 _decimals,
        address _interestRateStrategyAddress
    ) external onlyLendingPoolConfigurator {
        reserves[_reserve].init(_aTokenAddress, _decimals, _interestRateStrategyAddress);
        addReserveToListInternal(_reserve);

    }



    /**
    * @dev removes the last added reserve in the reservesList array
    * @param _reserveToRemove the address of the reserve
    **/
    function removeLastAddedReserve(address _reserveToRemove)
    external onlyLendingPoolConfigurator {

        address lastReserve = reservesList[reservesList.length-1];

        require(lastReserve == _reserveToRemove, "Reserve being removed is different than the reserve requested");

        //as we can't check if totalLiquidity is 0 (since the reserve added might not be an ERC20) we at least check that there is nothing borrowed
        require(getReserveTotalBorrows(lastReserve) == 0, "Cannot remove a reserve with liquidity deposited");

        reserves[lastReserve].isActive = false;
        reserves[lastReserve].aTokenAddress = address(0);
        reserves[lastReserve].decimals = 0;
        reserves[lastReserve].lastLiquidityCumulativeIndex = 0;
        reserves[lastReserve].lastVariableBorrowCumulativeIndex = 0;
        reserves[lastReserve].borrowingEnabled = false;
        reserves[lastReserve].usageAsCollateralEnabled = false;
        reserves[lastReserve].baseLTVasCollateral = 0;
        reserves[lastReserve].liquidationThreshold = 0;
        reserves[lastReserve].liquidationBonus = 0;
        reserves[lastReserve].interestRateStrategyAddress = address(0);

        reservesList.pop();
    }

    /**
    * @dev updates the address of the interest rate strategy contract
    * @param _reserve the address of the reserve
    * @param _rateStrategyAddress the address of the interest rate strategy contract
    **/

    function setReserveInterestRateStrategyAddress(address _reserve, address _rateStrategyAddress)
    external
    onlyLendingPoolConfigurator
    {
        reserves[_reserve].interestRateStrategyAddress = _rateStrategyAddress;
    }

    /**
    * @dev enables borrowing on a reserve. Also sets the stable rate borrowing
    * @param _reserve the address of the reserve
    * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise
    **/

    function enableBorrowingOnReserve(address _reserve, bool _stableBorrowRateEnabled)
    external
    onlyLendingPoolConfigurator
    {
        reserves[_reserve].enableBorrowing(_stableBorrowRateEnabled);
    }

    /**
    * @dev disables borrowing on a reserve
    * @param _reserve the address of the reserve
    **/

    function disableBorrowingOnReserve(address _reserve) external onlyLendingPoolConfigurator {
        reserves[_reserve].disableBorrowing();
    }

    /**
    * @dev enables a reserve to be used as collateral
    * @param _reserve the address of the reserve
    **/
    function enableReserveAsCollateral(
        address _reserve,
        uint256 _baseLTVasCollateral,
        uint256 _liquidationThreshold,
        uint256 _liquidationBonus
    ) external onlyLendingPoolConfigurator {
        reserves[_reserve].enableAsCollateral(
            _baseLTVasCollateral,
            _liquidationThreshold,
            _liquidationBonus
        );
    }

    /**
    * @dev disables a reserve to be used as collateral
    * @param _reserve the address of the reserve
    **/
    function disableReserveAsCollateral(address _reserve) external onlyLendingPoolConfigurator {
        reserves[_reserve].disableAsCollateral();
    }

    /**
    * @dev enable the stable borrow rate mode on a reserve
    * @param _reserve the address of the reserve
    **/
    function enableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isStableBorrowRateEnabled = true;
    }

    /**
    * @dev disable the stable borrow rate mode on a reserve
    * @param _reserve the address of the reserve
    **/
    function disableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isStableBorrowRateEnabled = false;
    }

    /**
    * @dev activates a reserve
    * @param _reserve the address of the reserve
    **/
    function activateReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        require(
            reserve.lastLiquidityCumulativeIndex > 0 &&
            reserve.lastVariableBorrowCumulativeIndex > 0,
            "Reserve has not been initialized yet"
        );
        reserve.isActive = true;
    }

    /**
    * @dev deactivates a reserve
    * @param _reserve the address of the reserve
    **/
    function deactivateReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isActive = false;
    }

    /**
    * @notice allows the configurator to freeze the reserve.
    * A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance.
    * @param _reserve the address of the reserve
    **/
    function freezeReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isFreezed = true;
    }

    /**
    * @notice allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed.
    * @param _reserve the address of the reserve
    **/
    function unfreezeReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isFreezed = false;
    }

    /**
    * @notice allows the configurator to update the loan to value of a reserve
    * @param _reserve the address of the reserve
    * @param _ltv the new loan to value
    **/
    function setReserveBaseLTVasCollateral(address _reserve, uint256 _ltv)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.baseLTVasCollateral = _ltv;
    }

    /**
    * @notice allows the configurator to update the liquidation threshold of a reserve
    * @param _reserve the address of the reserve
    * @param _threshold the new liquidation threshold
    **/
    function setReserveLiquidationThreshold(address _reserve, uint256 _threshold)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.liquidationThreshold = _threshold;
    }

    /**
    * @notice allows the configurator to update the liquidation bonus of a reserve
    * @param _reserve the address of the reserve
    * @param _bonus the new liquidation bonus
    **/
    function setReserveLiquidationBonus(address _reserve, uint256 _bonus)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.liquidationBonus = _bonus;
    }

    /**
    * @notice allows the configurator to update the reserve decimals
    * @param _reserve the address of the reserve
    * @param _decimals the decimals of the reserve
    **/
    function setReserveDecimals(address _reserve, uint256 _decimals)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.decimals = _decimals;
    }

    /**
    * @notice internal functions
    **/

    /**
    * @dev updates the state of a reserve as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the previous borrow balance of the borrower before the action
    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount
    * @param _amountBorrowed the new amount borrowed
    * @param _rateMode the borrow rate mode (stable, variable)
    **/

    function updateReserveStateOnBorrowInternal(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _balanceIncrease,
        uint256 _amountBorrowed,
        CoreLibrary.InterestRateMode _rateMode
    ) internal {
        reserves[_reserve].updateCumulativeIndexes();

        //increasing reserve total borrows to account for the new borrow balance of the user
        //NOTE: Depending on the previous borrow mode, the borrows might need to be switched from variable to stable or vice versa

        updateReserveTotalBorrowsByRateModeInternal(
            _reserve,
            _user,
            _principalBorrowBalance,
            _balanceIncrease,
            _amountBorrowed,
            _rateMode
        );
    }

    /**
    * @dev updates the state of a user as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _amountBorrowed the amount borrowed
    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount
    * @param _rateMode the borrow rate mode (stable, variable)
    * @return the final borrow rate for the user. Emitted by the borrow() event
    **/

    function updateUserStateOnBorrowInternal(
        address _reserve,
        address _user,
        uint256 _amountBorrowed,
        uint256 _balanceIncrease,
        uint256 _fee,
        CoreLibrary.InterestRateMode _rateMode
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (_rateMode == CoreLibrary.InterestRateMode.STABLE) {
            //stable
            //reset the user variable index, and update the stable rate
            user.stableBorrowRate = reserve.currentStableBorrowRate;
            user.lastVariableBorrowCumulativeIndex = 0;
        } else if (_rateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //variable
            //reset the user stable rate, and store the new borrow index
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        } else {
            revert("Invalid borrow rate mode");
        }
        //increase the principal borrows and the origination fee
        user.principalBorrowBalance = user.principalBorrowBalance.add(_amountBorrowed).add(
            _balanceIncrease
        );
        user.originationFee = user.originationFee.add(_fee);

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

    }

    /**
    * @dev updates the state of the reserve as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateReserveStateOnRepayInternal(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_reserve][_user];

        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(_reserve, _user);

        //update the indexes
        reserves[_reserve].updateCumulativeIndexes();

        //compound the cumulated interest to the borrow balance and then subtracting the payback amount
        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _balanceIncrease,
                user.stableBorrowRate
            );
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _paybackAmountMinusFees,
                user.stableBorrowRate
            );
        } else {
            reserve.increaseTotalBorrowsVariable(_balanceIncrease);
            reserve.decreaseTotalBorrowsVariable(_paybackAmountMinusFees);
        }
    }

    /**
    * @dev updates the state of the user as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _originationFeeRepaid the fee on the amount that is being repaid
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _repaidWholeLoan true if the user is repaying the whole loan
    **/
    function updateUserStateOnRepayInternal(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _originationFeeRepaid,
        uint256 _balanceIncrease,
        bool _repaidWholeLoan
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        //update the user principal borrow balance, adding the cumulated interest and then subtracting the payback amount
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(
            _paybackAmountMinusFees
        );
        user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;

        //if the balance decrease is equal to the previous principal (user is repaying the whole loan)
        //and the rate mode is stable, we reset the interest rate mode of the user
        if (_repaidWholeLoan) {
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = 0;
        }
        user.originationFee = user.originationFee.sub(_originationFeeRepaid);

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

    }

    /**
    * @dev updates the state of the user as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is performing the rate swap
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the the principal amount borrowed by the user
    * @param _compoundedBorrowBalance the principal amount plus the accrued interest
    * @param _currentRateMode the rate mode at which the user borrowed
    **/
    function updateReserveStateOnSwapRateInternal(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _compoundedBorrowBalance,
        CoreLibrary.InterestRateMode _currentRateMode
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        //compounding reserve indexes
        reserve.updateCumulativeIndexes();

        if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {
            uint256 userCurrentStableRate = user.stableBorrowRate;

            //swap to variable
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _principalBorrowBalance,
                userCurrentStableRate
            ); //decreasing stable from old principal balance
            reserve.increaseTotalBorrowsVariable(_compoundedBorrowBalance); //increase variable borrows
        } else if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //swap to stable
            uint256 currentStableRate = reserve.currentStableBorrowRate;
            reserve.decreaseTotalBorrowsVariable(_principalBorrowBalance);
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _compoundedBorrowBalance,
                currentStableRate
            );

        } else {
            revert("Invalid rate mode received");
        }
    }

    /**
    * @dev updates the state of the user as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is performing the swap
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _currentRateMode the current rate mode of the user
    **/

    function updateUserStateOnSwapRateInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease,
        CoreLibrary.InterestRateMode _currentRateMode
    ) internal returns (CoreLibrary.InterestRateMode) {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        CoreLibrary.InterestRateMode newMode = CoreLibrary.InterestRateMode.NONE;

        if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //switch to stable
            newMode = CoreLibrary.InterestRateMode.STABLE;
            user.stableBorrowRate = reserve.currentStableBorrowRate;
            user.lastVariableBorrowCumulativeIndex = 0;
        } else if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {
            newMode = CoreLibrary.InterestRateMode.VARIABLE;
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        } else {
            revert("Invalid interest rate mode received");
        }
        //compounding cumulated interest
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);
        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

        return newMode;
    }

    /**
    * @dev updates the state of the principal reserve as a consequence of a liquidation action.
    * @param _principalReserve the address of the principal reserve that is being repaid
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updatePrincipalReserveStateOnLiquidationInternal(
        address _principalReserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_principalReserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_principalReserve];

        //update principal reserve data
        reserve.updateCumulativeIndexes();

        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(
            _principalReserve,
            _user
        );

        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            //increase the total borrows by the compounded interest
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _balanceIncrease,
                user.stableBorrowRate
            );

            //decrease by the actual amount to liquidate
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _amountToLiquidate,
                user.stableBorrowRate
            );

        } else {
            //increase the total borrows by the compounded interest
            reserve.increaseTotalBorrowsVariable(_balanceIncrease);

            //decrease by the actual amount to liquidate
            reserve.decreaseTotalBorrowsVariable(_amountToLiquidate);
        }

    }

    /**
    * @dev updates the state of the collateral reserve as a consequence of a liquidation action.
    * @param _collateralReserve the address of the collateral reserve that is being liquidated
    **/
    function updateCollateralReserveStateOnLiquidationInternal(
        address _collateralReserve
    ) internal {
        //update collateral reserve
        reserves[_collateralReserve].updateCumulativeIndexes();

    }

    /**
    * @dev updates the state of the user being liquidated as a consequence of a liquidation action.
    * @param _reserve the address of the principal reserve that is being repaid
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _feeLiquidated the amount of origination fee being liquidated
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/
    function updateUserStateOnLiquidationInternal(
        address _reserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _feeLiquidated,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        //first increase by the compounded interest, then decrease by the liquidated amount
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(
            _amountToLiquidate
        );

        if (
            getUserCurrentBorrowRateMode(_reserve, _user) == CoreLibrary.InterestRateMode.VARIABLE
        ) {
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        }

        if(_feeLiquidated > 0){
            user.originationFee = user.originationFee.sub(_feeLiquidated);
        }

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);
    }

    /**
    * @dev updates the state of the reserve as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateReserveStateOnRebalanceInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        reserve.updateCumulativeIndexes();

        reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
            _balanceIncrease,
            user.stableBorrowRate
        );

    }

    /**
    * @dev updates the state of the user as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateUserStateOnRebalanceInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);
        user.stableBorrowRate = reserve.currentStableBorrowRate;

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);
    }

    /**
    * @dev updates the state of the user as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _amountBorrowed the accrued interest on the borrowed amount
    **/
    function updateReserveTotalBorrowsByRateModeInternal(
        address _reserve,
        address _user,
        uint256 _principalBalance,
        uint256 _balanceIncrease,
        uint256 _amountBorrowed,
        CoreLibrary.InterestRateMode _newBorrowRateMode
    ) internal {
        CoreLibrary.InterestRateMode previousRateMode = getUserCurrentBorrowRateMode(
            _reserve,
            _user
        );
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        if (previousRateMode == CoreLibrary.InterestRateMode.STABLE) {
            CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _principalBalance,
                user.stableBorrowRate
            );
        } else if (previousRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            reserve.decreaseTotalBorrowsVariable(_principalBalance);
        }

        uint256 newPrincipalAmount = _principalBalance.add(_balanceIncrease).add(_amountBorrowed);
        if (_newBorrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                newPrincipalAmount,
                reserve.currentStableBorrowRate
            );
        } else if (_newBorrowRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            reserve.increaseTotalBorrowsVariable(newPrincipalAmount);
        } else {
            revert("Invalid new borrow rate mode");
        }
    }

    /**
    * @dev Updates the reserve current stable borrow rate Rf, the current variable borrow rate Rv and the current liquidity rate Rl.
    * Also updates the lastUpdateTimestamp value. Please refer to the whitepaper for further information.
    * @param _reserve the address of the reserve to be updated
    * @param _liquidityAdded the amount of liquidity added to the protocol (deposit or repay) in the previous action
    * @param _liquidityTaken the amount of liquidity taken from the protocol (redeem or borrow)
    **/

    function updateReserveInterestRatesAndTimestampInternal(
        address _reserve,
        uint256 _liquidityAdded,
        uint256 _liquidityTaken
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        (uint256 newLiquidityRate, uint256 newStableRate, uint256 newVariableRate) = IReserveInterestRateStrategy(
            reserve
            .interestRateStrategyAddress
        )
        .calculateInterestRates(
            _reserve,
            getReserveAvailableLiquidity(_reserve).add(_liquidityAdded).sub(_liquidityTaken),
            reserve.totalBorrowsStable,
            reserve.totalBorrowsVariable,
            reserve.currentAverageStableBorrowRate
        );

        reserve.currentLiquidityRate = newLiquidityRate;
        reserve.currentStableBorrowRate = newStableRate;
        reserve.currentVariableBorrowRate = newVariableRate;

        //solium-disable-next-line
        reserve.lastUpdateTimestamp = uint40(block.timestamp);

        emit ReserveUpdated(
            _reserve,
            newLiquidityRate,
            newStableRate,
            newVariableRate,
            reserve.lastLiquidityCumulativeIndex,
            reserve.lastVariableBorrowCumulativeIndex
        );
    }

    /**
    * @dev transfers to the protocol fees of a flashloan to the fees collection address
    * @param _token the address of the token being transferred
    * @param _amount the amount being transferred
    **/

    function transferFlashLoanProtocolFeeInternal(address _token, uint256 _amount) internal {
        address payable receiver = address(uint160(addressesProvider.getTokenDistributor()));

        if (_token != EthAddressLib.ethAddress()) {
            ERC20(_token).safeTransfer(receiver, _amount);
        } else {
            receiver.transfer(_amount);
        }
    }

    /**
    * @dev updates the internal configuration of the core
    **/
    function refreshConfigInternal() internal {
        lendingPoolAddress = addressesProvider.getLendingPool();
    }

    /**
    * @dev adds a reserve to the array of the reserves address
    **/
    function addReserveToListInternal(address _reserve) internal {
        bool reserveAlreadyAdded = false;
        for (uint256 i = 0; i < reservesList.length; i++)
            if (reservesList[i] == _reserve) {
                reserveAlreadyAdded = true;
            }
        if (!reserveAlreadyAdded) reservesList.push(_reserve);
    }

}
.]

Given the user's task and the brainstorming ideas provided:
Task: "pragma solidity ^0.5.0;

import "openzeppelin-solidity/contracts/math/SafeMath.sol";
import "openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol";
import "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol";
import "openzeppelin-solidity/contracts/utils/Address.sol";
import "../libraries/openzeppelin-upgradeability/VersionedInitializable.sol";

import "../libraries/CoreLibrary.sol";
import "../configuration/LendingPoolAddressesProvider.sol";
import "../interfaces/ILendingRateOracle.sol";
import "../interfaces/IReserveInterestRateStrategy.sol";
import "../libraries/WadRayMath.sol";
import "../tokenization/AToken.sol";
import "../libraries/EthAddressLib.sol";

/**
* @title LendingPoolCore contract
* @author Aave
* @notice Holds the state of the lending pool and all the funds deposited
* @dev NOTE: The core does not enforce security checks on the update of the state
* (eg, updateStateOnBorrow() does not enforce that borrowed is enabled on the reserve).
* The check that an action can be performed is a duty of the overlying LendingPool contract.
**/

contract LendingPoolCore is VersionedInitializable {
    using SafeMath for uint256;
    using WadRayMath for uint256;
    using CoreLibrary for CoreLibrary.ReserveData;
    using CoreLibrary for CoreLibrary.UserReserveData;
    using SafeERC20 for ERC20;
    using Address for address payable;

    /**
    * @dev Emitted when the state of a reserve is updated
    * @param reserve the address of the reserve
    * @param liquidityRate the new liquidity rate
    * @param stableBorrowRate the new stable borrow rate
    * @param variableBorrowRate the new variable borrow rate
    * @param liquidityIndex the new liquidity index
    * @param variableBorrowIndex the new variable borrow index
    **/
    event ReserveUpdated(
        address indexed reserve,
        uint256 liquidityRate,
        uint256 stableBorrowRate,
        uint256 variableBorrowRate,
        uint256 liquidityIndex,
        uint256 variableBorrowIndex
    );

    address public lendingPoolAddress;

    LendingPoolAddressesProvider public addressesProvider;

    /**
    * @dev only lending pools can use functions affected by this modifier
    **/
    modifier onlyLendingPool {
        require(lendingPoolAddress == msg.sender, "The caller must be a lending pool contract");
        _;
    }

    /**
    * @dev only lending pools configurator can use functions affected by this modifier
    **/
    modifier onlyLendingPoolConfigurator {
        require(
            addressesProvider.getLendingPoolConfigurator() == msg.sender,
            "The caller must be a lending pool configurator contract"
        );
        _;
    }

    mapping(address => CoreLibrary.ReserveData) internal reserves;
    mapping(address => mapping(address => CoreLibrary.UserReserveData)) internal usersReserveData;

    address[] public reservesList;

    uint256 public constant CORE_REVISION = 0x4;

    /**
    * @dev returns the revision number of the contract
    **/
    function getRevision() internal pure returns (uint256) {
        return CORE_REVISION;
    }

    /**
    * @dev initializes the Core contract, invoked upon registration on the AddressesProvider
    * @param _addressesProvider the addressesProvider contract
    **/

    function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {
        addressesProvider = _addressesProvider;
        refreshConfigInternal();
    }

    /**
    * @dev updates the state of the core as a result of a deposit action
    * @param _reserve the address of the reserve in which the deposit is happening
    * @param _user the address of the the user depositing
    * @param _amount the amount being deposited
    * @param _isFirstDeposit true if the user is depositing for the first time
    **/

    function updateStateOnDeposit(
        address _reserve,
        address _user,
        uint256 _amount,
        bool _isFirstDeposit
    ) external onlyLendingPool {
        reserves[_reserve].updateCumulativeIndexes();
        updateReserveInterestRatesAndTimestampInternal(_reserve, _amount, 0);

        if (_isFirstDeposit) {
            //if this is the first deposit of the user, we configure the deposit as enabled to be used as collateral
            setUserUseReserveAsCollateral(_reserve, _user, true);
        }
    }

    /**
    * @dev updates the state of the core as a result of a redeem action
    * @param _reserve the address of the reserve in which the redeem is happening
    * @param _user the address of the the user redeeming
    * @param _amountRedeemed the amount being redeemed
    * @param _userRedeemedEverything true if the user is redeeming everything
    **/
    function updateStateOnRedeem(
        address _reserve,
        address _user,
        uint256 _amountRedeemed,
        bool _userRedeemedEverything
    ) external onlyLendingPool {
        //compound liquidity and variable borrow interests
        reserves[_reserve].updateCumulativeIndexes();
        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountRedeemed);

        //if user redeemed everything the useReserveAsCollateral flag is reset
        if (_userRedeemedEverything) {
            setUserUseReserveAsCollateral(_reserve, _user, false);
        }
    }

    /**
    * @dev updates the state of the core as a result of a flashloan action
    * @param _reserve the address of the reserve in which the flashloan is happening
    * @param _income the income of the protocol as a result of the action
    **/
    function updateStateOnFlashLoan(
        address _reserve,
        uint256 _availableLiquidityBefore,
        uint256 _income,
        uint256 _protocolFee
    ) external onlyLendingPool {
        transferFlashLoanProtocolFeeInternal(_reserve, _protocolFee);

        //compounding the cumulated interest
        reserves[_reserve].updateCumulativeIndexes();

        uint256 totalLiquidityBefore = _availableLiquidityBefore.add(
            getReserveTotalBorrows(_reserve)
        );

        //compounding the received fee into the reserve
        reserves[_reserve].cumulateToLiquidityIndex(totalLiquidityBefore, _income);

        //refresh interest rates
        updateReserveInterestRatesAndTimestampInternal(_reserve, _income, 0);
    }

    /**
    * @dev updates the state of the core as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _amountBorrowed the new amount borrowed
    * @param _borrowFee the fee on the amount borrowed
    * @param _rateMode the borrow rate mode (stable, variable)
    * @return the new borrow rate for the user
    **/
    function updateStateOnBorrow(
        address _reserve,
        address _user,
        uint256 _amountBorrowed,
        uint256 _borrowFee,
        CoreLibrary.InterestRateMode _rateMode
    ) external onlyLendingPool returns (uint256, uint256) {
        // getting the previous borrow data of the user
        (uint256 principalBorrowBalance, , uint256 balanceIncrease) = getUserBorrowBalances(
            _reserve,
            _user
        );

        updateReserveStateOnBorrowInternal(
            _reserve,
            _user,
            principalBorrowBalance,
            balanceIncrease,
            _amountBorrowed,
            _rateMode
        );

        updateUserStateOnBorrowInternal(
            _reserve,
            _user,
            _amountBorrowed,
            balanceIncrease,
            _borrowFee,
            _rateMode
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountBorrowed);

        return (getUserCurrentBorrowRate(_reserve, _user), balanceIncrease);
    }

    /**
    * @dev updates the state of the core as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _originationFeeRepaid the fee on the amount that is being repaid
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _repaidWholeLoan true if the user is repaying the whole loan
    **/

    function updateStateOnRepay(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _originationFeeRepaid,
        uint256 _balanceIncrease,
        bool _repaidWholeLoan
    ) external onlyLendingPool {
        updateReserveStateOnRepayInternal(
            _reserve,
            _user,
            _paybackAmountMinusFees,
            _balanceIncrease
        );
        updateUserStateOnRepayInternal(
            _reserve,
            _user,
            _paybackAmountMinusFees,
            _originationFeeRepaid,
            _balanceIncrease,
            _repaidWholeLoan
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, _paybackAmountMinusFees, 0);
    }

    /**
    * @dev updates the state of the core as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the amount borrowed by the user
    * @param _compoundedBorrowBalance the amount borrowed plus accrued interest
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _currentRateMode the current interest rate mode for the user
    **/
    function updateStateOnSwapRate(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _compoundedBorrowBalance,
        uint256 _balanceIncrease,
        CoreLibrary.InterestRateMode _currentRateMode
    ) external onlyLendingPool returns (CoreLibrary.InterestRateMode, uint256) {
        updateReserveStateOnSwapRateInternal(
            _reserve,
            _user,
            _principalBorrowBalance,
            _compoundedBorrowBalance,
            _currentRateMode
        );

        CoreLibrary.InterestRateMode newRateMode = updateUserStateOnSwapRateInternal(
            _reserve,
            _user,
            _balanceIncrease,
            _currentRateMode
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);

        return (newRateMode, getUserCurrentBorrowRate(_reserve, _user));
    }

    /**
    * @dev updates the state of the core as a consequence of a liquidation action.
    * @param _principalReserve the address of the principal reserve that is being repaid
    * @param _collateralReserve the address of the collateral reserve that is being liquidated
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _collateralToLiquidate the amount of collateral being liquidated
    * @param _feeLiquidated the amount of origination fee being liquidated
    * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise
    **/
    function updateStateOnLiquidation(
        address _principalReserve,
        address _collateralReserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _collateralToLiquidate,
        uint256 _feeLiquidated,
        uint256 _liquidatedCollateralForFee,
        uint256 _balanceIncrease,
        bool _liquidatorReceivesAToken
    ) external onlyLendingPool {
        updatePrincipalReserveStateOnLiquidationInternal(
            _principalReserve,
            _user,
            _amountToLiquidate,
            _balanceIncrease
        );

        updateCollateralReserveStateOnLiquidationInternal(
            _collateralReserve
        );

        updateUserStateOnLiquidationInternal(
            _principalReserve,
            _user,
            _amountToLiquidate,
            _feeLiquidated,
            _balanceIncrease
        );

        updateReserveInterestRatesAndTimestampInternal(_principalReserve, _amountToLiquidate, 0);

        if (!_liquidatorReceivesAToken) {
            updateReserveInterestRatesAndTimestampInternal(
                _collateralReserve,
                0,
                _collateralToLiquidate.add(_liquidatedCollateralForFee)
            );
        }

    }

    /**
    * @dev updates the state of the core as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @return the new stable rate for the user
    **/
    function updateStateOnRebalance(address _reserve, address _user, uint256 _balanceIncrease)
    external
    onlyLendingPool
    returns (uint256)
    {
        updateReserveStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);

        //update user data and rebalance the rate
        updateUserStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);
        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);
        return usersReserveData[_user][_reserve].stableBorrowRate;
    }

    /**
    * @dev enables or disables a reserve as collateral
    * @param _reserve the address of the principal reserve where the user deposited
    * @param _user the address of the depositor
    * @param _useAsCollateral true if the depositor wants to use the reserve as collateral
    **/
    function setUserUseReserveAsCollateral(address _reserve, address _user, bool _useAsCollateral)
    public
    onlyLendingPool
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        user.useAsCollateral = _useAsCollateral;
    }

    /**
    * @notice ETH/token transfer functions
    **/

    /**
    * @dev fallback function enforces that the caller is a contract, to support flashloan transfers
    **/
    function() external payable {
        //only contracts can send ETH to the core
        require(msg.sender.isContract(), "Only contracts can send ether to the Lending pool core");

    }

    /**
    * @dev transfers to the user a specific amount from the reserve.
    * @param _reserve the address of the reserve where the transfer is happening
    * @param _user the address of the user receiving the transfer
    * @param _amount the amount being transferred
    **/
    function transferToUser(address _reserve, address payable _user, uint256 _amount)
    external
    onlyLendingPool
    {
        if (_reserve != EthAddressLib.ethAddress()) {
            ERC20(_reserve).safeTransfer(_user, _amount);
        } else {
            //solium-disable-next-line
            (bool result, ) = _user.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers the protocol fees to the fees collection address
    * @param _token the address of the token being transferred
    * @param _user the address of the user from where the transfer is happening
    * @param _amount the amount being transferred
    * @param _destination the fee receiver address
    **/

    function transferToFeeCollectionAddress(
        address _token,
        address _user,
        uint256 _amount,
        address _destination
    ) external payable onlyLendingPool {
        address payable feeAddress = address(uint160(_destination)); //cast the address to payable

        if (_token != EthAddressLib.ethAddress()) {
            require(
                msg.value == 0,
                "User is sending ETH along with the ERC20 transfer. Check the value attribute of the transaction"
            );
            ERC20(_token).safeTransferFrom(_user, feeAddress, _amount);
        } else {
            require(msg.value >= _amount, "The amount and the value sent to deposit do not match");
            //solium-disable-next-line
            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers the fees to the fees collection address in the case of liquidation
    * @param _token the address of the token being transferred
    * @param _amount the amount being transferred
    * @param _destination the fee receiver address
    **/
    function liquidateFee(
        address _token,
        uint256 _amount,
        address _destination
    ) external payable onlyLendingPool {
        address payable feeAddress = address(uint160(_destination)); //cast the address to payable
        require(
            msg.value == 0,
            "Fee liquidation does not require any transfer of value"
        );

        if (_token != EthAddressLib.ethAddress()) {
            ERC20(_token).safeTransfer(feeAddress, _amount);
        } else {
            //solium-disable-next-line
            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers an amount from a user to the destination reserve
    * @param _reserve the address of the reserve where the amount is being transferred
    * @param _user the address of the user from where the transfer is happening
    * @param _amount the amount being transferred
    **/
    function transferToReserve(address _reserve, address payable _user, uint256 _amount)
    external
    payable
    onlyLendingPool
    {
        if (_reserve != EthAddressLib.ethAddress()) {
            require(msg.value == 0, "User is sending ETH along with the ERC20 transfer.");
            ERC20(_reserve).safeTransferFrom(_user, address(this), _amount);

        } else {
            require(msg.value >= _amount, "The amount and the value sent to deposit do not match");

            if (msg.value > _amount) {
                //send back excess ETH
                uint256 excessAmount = msg.value.sub(_amount);
                //solium-disable-next-line
                (bool result, ) = _user.call.value(excessAmount).gas(50000)("");
                require(result, "Transfer of ETH failed");
            }
        }
    }

    /**
    * @notice data access functions
    **/

    /**
    * @dev returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral)
    * needed to calculate the global account data in the LendingPoolDataProvider
    * @param _reserve the address of the reserve
    * @param _user the address of the user
    * @return the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not
    **/
    function getUserBasicReserveData(address _reserve, address _user)
    external
    view
    returns (uint256, uint256, uint256, bool)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        uint256 underlyingBalance = getUserUnderlyingAssetBalance(_reserve, _user);

        if (user.principalBorrowBalance == 0) {
            return (underlyingBalance, 0, 0, user.useAsCollateral);
        }

        return (
        underlyingBalance,
        user.getCompoundedBorrowBalance(reserve),
        user.originationFee,
        user.useAsCollateral
        );
    }

    /**
    * @dev checks if a user is allowed to borrow at a stable rate
    * @param _reserve the reserve address
    * @param _user the user
    * @param _amount the amount the the user wants to borrow
    * @return true if the user is allowed to borrow at a stable rate, false otherwise
    **/

    function isUserAllowedToBorrowAtStable(address _reserve, address _user, uint256 _amount)
    external
    view
    returns (bool)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (!reserve.isStableBorrowRateEnabled) return false;

        return
        !user.useAsCollateral ||
        !reserve.usageAsCollateralEnabled ||
        _amount > getUserUnderlyingAssetBalance(_reserve, _user);
    }

    /**
    * @dev gets the underlying asset balance of a user based on the corresponding aToken balance.
    * @param _reserve the reserve address
    * @param _user the user address
    * @return the underlying deposit balance of the user
    **/

    function getUserUnderlyingAssetBalance(address _reserve, address _user)
    public
    view
    returns (uint256)
    {
        AToken aToken = AToken(reserves[_reserve].aTokenAddress);
        return aToken.balanceOf(_user);

    }

    /**
    * @dev gets the interest rate strategy contract address for the reserve
    * @param _reserve the reserve address
    * @return the address of the interest rate strategy contract
    **/
    function getReserveInterestRateStrategyAddress(address _reserve) public view returns (address) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.interestRateStrategyAddress;
    }

    /**
    * @dev gets the aToken contract address for the reserve
    * @param _reserve the reserve address
    * @return the address of the aToken contract
    **/

    function getReserveATokenAddress(address _reserve) public view returns (address) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.aTokenAddress;
    }

    /**
    * @dev gets the available liquidity in the reserve. The available liquidity is the balance of the core contract
    * @param _reserve the reserve address
    * @return the available liquidity
    **/
    function getReserveAvailableLiquidity(address _reserve) public view returns (uint256) {
        uint256 balance = 0;

        if (_reserve == EthAddressLib.ethAddress()) {
            balance = address(this).balance;
        } else {
            balance = IERC20(_reserve).balanceOf(address(this));
        }
        return balance;
    }

    /**
    * @dev gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows
    * @param _reserve the reserve address
    * @return the total liquidity
    **/
    function getReserveTotalLiquidity(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return getReserveAvailableLiquidity(_reserve).add(reserve.getTotalBorrows());
    }

    /**
    * @dev gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there
    * there has been 100% income.
    * @param _reserve the reserve address
    * @return the reserve normalized income
    **/
    function getReserveNormalizedIncome(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.getNormalizedIncome();
    }

    /**
    * @dev gets the reserve total borrows
    * @param _reserve the reserve address
    * @return the total borrows (stable + variable)
    **/
    function getReserveTotalBorrows(address _reserve) public view returns (uint256) {
        return reserves[_reserve].getTotalBorrows();
    }

    /**
    * @dev gets the reserve total borrows stable
    * @param _reserve the reserve address
    * @return the total borrows stable
    **/
    function getReserveTotalBorrowsStable(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.totalBorrowsStable;
    }

    /**
    * @dev gets the reserve total borrows variable
    * @param _reserve the reserve address
    * @return the total borrows variable
    **/

    function getReserveTotalBorrowsVariable(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.totalBorrowsVariable;
    }

    /**
    * @dev gets the reserve liquidation threshold
    * @param _reserve the reserve address
    * @return the reserve liquidation threshold
    **/

    function getReserveLiquidationThreshold(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.liquidationThreshold;
    }

    /**
    * @dev gets the reserve liquidation bonus
    * @param _reserve the reserve address
    * @return the reserve liquidation bonus
    **/

    function getReserveLiquidationBonus(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.liquidationBonus;
    }

    /**
    * @dev gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty
    * @param _reserve the reserve address
    * @return the reserve current variable borrow rate
    **/

    function getReserveCurrentVariableBorrowRate(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        if (reserve.currentVariableBorrowRate == 0) {
            return
            IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)
            .getBaseVariableBorrowRate();
        }
        return reserve.currentVariableBorrowRate;
    }

    /**
    * @dev gets the reserve current stable borrow rate. Is the market rate if the reserve is empty
    * @param _reserve the reserve address
    * @return the reserve current stable borrow rate
    **/

    function getReserveCurrentStableBorrowRate(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        ILendingRateOracle oracle = ILendingRateOracle(addressesProvider.getLendingRateOracle());

        if (reserve.currentStableBorrowRate == 0) {
            //no stable rate borrows yet
            return oracle.getMarketBorrowRate(_reserve);
        }

        return reserve.currentStableBorrowRate;
    }

    /**
    * @dev gets the reserve average stable borrow rate. The average stable rate is the weighted average
    * of all the loans taken at stable rate.
    * @param _reserve the reserve address
    * @return the reserve current average borrow rate
    **/
    function getReserveCurrentAverageStableBorrowRate(address _reserve)
    external
    view
    returns (uint256)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.currentAverageStableBorrowRate;
    }

    /**
    * @dev gets the reserve liquidity rate
    * @param _reserve the reserve address
    * @return the reserve liquidity rate
    **/
    function getReserveCurrentLiquidityRate(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.currentLiquidityRate;
    }

    /**
    * @dev gets the reserve liquidity cumulative index
    * @param _reserve the reserve address
    * @return the reserve liquidity cumulative index
    **/
    function getReserveLiquidityCumulativeIndex(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.lastLiquidityCumulativeIndex;
    }

    /**
    * @dev gets the reserve variable borrow index
    * @param _reserve the reserve address
    * @return the reserve variable borrow index
    **/
    function getReserveVariableBorrowsCumulativeIndex(address _reserve)
    external
    view
    returns (uint256)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.lastVariableBorrowCumulativeIndex;
    }

    /**
    * @dev this function aggregates the configuration parameters of the reserve.
    * It's used in the LendingPoolDataProvider specifically to save gas, and avoid
    * multiple external contract calls to fetch the same data.
    * @param _reserve the reserve address
    * @return the reserve decimals
    * @return the base ltv as collateral
    * @return the liquidation threshold
    * @return if the reserve is used as collateral or not
    **/
    function getReserveConfiguration(address _reserve)
    external
    view
    returns (uint256, uint256, uint256, bool)
    {
        uint256 decimals;
        uint256 baseLTVasCollateral;
        uint256 liquidationThreshold;
        bool usageAsCollateralEnabled;

        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        decimals = reserve.decimals;
        baseLTVasCollateral = reserve.baseLTVasCollateral;
        liquidationThreshold = reserve.liquidationThreshold;
        usageAsCollateralEnabled = reserve.usageAsCollateralEnabled;

        return (decimals, baseLTVasCollateral, liquidationThreshold, usageAsCollateralEnabled);
    }

    /**
    * @dev returns the decimals of the reserve
    * @param _reserve the reserve address
    * @return the reserve decimals
    **/
    function getReserveDecimals(address _reserve) external view returns (uint256) {
        return reserves[_reserve].decimals;
    }

    /**
    * @dev returns true if the reserve is enabled for borrowing
    * @param _reserve the reserve address
    * @return true if the reserve is enabled for borrowing, false otherwise
    **/

    function isReserveBorrowingEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.borrowingEnabled;
    }

    /**
    * @dev returns true if the reserve is enabled as collateral
    * @param _reserve the reserve address
    * @return true if the reserve is enabled as collateral, false otherwise
    **/

    function isReserveUsageAsCollateralEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.usageAsCollateralEnabled;
    }

    /**
    * @dev returns true if the stable rate is enabled on reserve
    * @param _reserve the reserve address
    * @return true if the stable rate is enabled on reserve, false otherwise
    **/
    function getReserveIsStableBorrowRateEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isStableBorrowRateEnabled;
    }

    /**
    * @dev returns true if the reserve is active
    * @param _reserve the reserve address
    * @return true if the reserve is active, false otherwise
    **/
    function getReserveIsActive(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isActive;
    }

    /**
    * @notice returns if a reserve is freezed
    * @param _reserve the reserve for which the information is needed
    * @return true if the reserve is freezed, false otherwise
    **/

    function getReserveIsFreezed(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isFreezed;
    }

    /**
    * @notice returns the timestamp of the last action on the reserve
    * @param _reserve the reserve for which the information is needed
    * @return the last updated timestamp of the reserve
    **/

    function getReserveLastUpdate(address _reserve) external view returns (uint40 timestamp) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        timestamp = reserve.lastUpdateTimestamp;
    }

    /**
    * @dev returns the utilization rate U of a specific reserve
    * @param _reserve the reserve for which the information is needed
    * @return the utilization rate in ray
    **/

    function getReserveUtilizationRate(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        uint256 totalBorrows = reserve.getTotalBorrows();

        if (totalBorrows == 0) {
            return 0;
        }

        uint256 availableLiquidity = getReserveAvailableLiquidity(_reserve);

        return totalBorrows.rayDiv(availableLiquidity.add(totalBorrows));
    }

    /**
    * @return the array of reserves configured on the core
    **/
    function getReserves() external view returns (address[] memory) {
        return reservesList;
    }

    /**
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return true if the user has chosen to use the reserve as collateral, false otherwise
    **/
    function isUserUseReserveAsCollateralEnabled(address _reserve, address _user)
    external
    view
    returns (bool)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.useAsCollateral;
    }

    /**
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the origination fee for the user
    **/
    function getUserOriginationFee(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.originationFee;
    }

    /**
    * @dev users with no loans in progress have NONE as borrow rate mode
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the borrow rate mode for the user,
    **/

    function getUserCurrentBorrowRateMode(address _reserve, address _user)
    public
    view
    returns (CoreLibrary.InterestRateMode)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (user.principalBorrowBalance == 0) {
            return CoreLibrary.InterestRateMode.NONE;
        }

        return
        user.stableBorrowRate > 0
        ? CoreLibrary.InterestRateMode.STABLE
        : CoreLibrary.InterestRateMode.VARIABLE;
    }

    /**
    * @dev gets the current borrow rate of the user
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the borrow rate for the user,
    **/
    function getUserCurrentBorrowRate(address _reserve, address _user)
    internal
    view
    returns (uint256)
    {
        CoreLibrary.InterestRateMode rateMode = getUserCurrentBorrowRateMode(_reserve, _user);

        if (rateMode == CoreLibrary.InterestRateMode.NONE) {
            return 0;
        }

        return
        rateMode == CoreLibrary.InterestRateMode.STABLE
        ? usersReserveData[_user][_reserve].stableBorrowRate
        : reserves[_reserve].currentVariableBorrowRate;
    }

    /**
    * @dev the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the user stable rate
    **/
    function getUserCurrentStableBorrowRate(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.stableBorrowRate;
    }

    /**
    * @dev calculates and returns the borrow balances of the user
    * @param _reserve the address of the reserve
    * @param _user the address of the user
    * @return the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance
    **/

    function getUserBorrowBalances(address _reserve, address _user)
    public
    view
    returns (uint256, uint256, uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        if (user.principalBorrowBalance == 0) {
            return (0, 0, 0);
        }

        uint256 principal = user.principalBorrowBalance;
        uint256 compoundedBalance = CoreLibrary.getCompoundedBorrowBalance(
            user,
            reserves[_reserve]
        );
        return (principal, compoundedBalance, compoundedBalance.sub(principal));
    }

    /**
    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the variable borrow index for the user
    **/

    function getUserVariableBorrowCumulativeIndex(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.lastVariableBorrowCumulativeIndex;
    }

    /**
    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the variable borrow index for the user
    **/

    function getUserLastUpdate(address _reserve, address _user)
    external
    view
    returns (uint256 timestamp)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        timestamp = user.lastUpdateTimestamp;
    }

    /**
    * @dev updates the lending pool core configuration
    **/
    function refreshConfiguration() external onlyLendingPoolConfigurator {
        refreshConfigInternal();
    }

    /**
    * @dev initializes a reserve
    * @param _reserve the address of the reserve
    * @param _aTokenAddress the address of the overlying aToken contract
    * @param _decimals the decimals of the reserve currency
    * @param _interestRateStrategyAddress the address of the interest rate strategy contract
    **/
    function initReserve(
        address _reserve,
        address _aTokenAddress,
        uint256 _decimals,
        address _interestRateStrategyAddress
    ) external onlyLendingPoolConfigurator {
        reserves[_reserve].init(_aTokenAddress, _decimals, _interestRateStrategyAddress);
        addReserveToListInternal(_reserve);

    }



    /**
    * @dev removes the last added reserve in the reservesList array
    * @param _reserveToRemove the address of the reserve
    **/
    function removeLastAddedReserve(address _reserveToRemove)
    external onlyLendingPoolConfigurator {

        address lastReserve = reservesList[reservesList.length-1];

        require(lastReserve == _reserveToRemove, "Reserve being removed is different than the reserve requested");

        //as we can't check if totalLiquidity is 0 (since the reserve added might not be an ERC20) we at least check that there is nothing borrowed
        require(getReserveTotalBorrows(lastReserve) == 0, "Cannot remove a reserve with liquidity deposited");

        reserves[lastReserve].isActive = false;
        reserves[lastReserve].aTokenAddress = address(0);
        reserves[lastReserve].decimals = 0;
        reserves[lastReserve].lastLiquidityCumulativeIndex = 0;
        reserves[lastReserve].lastVariableBorrowCumulativeIndex = 0;
        reserves[lastReserve].borrowingEnabled = false;
        reserves[lastReserve].usageAsCollateralEnabled = false;
        reserves[lastReserve].baseLTVasCollateral = 0;
        reserves[lastReserve].liquidationThreshold = 0;
        reserves[lastReserve].liquidationBonus = 0;
        reserves[lastReserve].interestRateStrategyAddress = address(0);

        reservesList.pop();
    }

    /**
    * @dev updates the address of the interest rate strategy contract
    * @param _reserve the address of the reserve
    * @param _rateStrategyAddress the address of the interest rate strategy contract
    **/

    function setReserveInterestRateStrategyAddress(address _reserve, address _rateStrategyAddress)
    external
    onlyLendingPoolConfigurator
    {
        reserves[_reserve].interestRateStrategyAddress = _rateStrategyAddress;
    }

    /**
    * @dev enables borrowing on a reserve. Also sets the stable rate borrowing
    * @param _reserve the address of the reserve
    * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise
    **/

    function enableBorrowingOnReserve(address _reserve, bool _stableBorrowRateEnabled)
    external
    onlyLendingPoolConfigurator
    {
        reserves[_reserve].enableBorrowing(_stableBorrowRateEnabled);
    }

    /**
    * @dev disables borrowing on a reserve
    * @param _reserve the address of the reserve
    **/

    function disableBorrowingOnReserve(address _reserve) external onlyLendingPoolConfigurator {
        reserves[_reserve].disableBorrowing();
    }

    /**
    * @dev enables a reserve to be used as collateral
    * @param _reserve the address of the reserve
    **/
    function enableReserveAsCollateral(
        address _reserve,
        uint256 _baseLTVasCollateral,
        uint256 _liquidationThreshold,
        uint256 _liquidationBonus
    ) external onlyLendingPoolConfigurator {
        reserves[_reserve].enableAsCollateral(
            _baseLTVasCollateral,
            _liquidationThreshold,
            _liquidationBonus
        );
    }

    /**
    * @dev disables a reserve to be used as collateral
    * @param _reserve the address of the reserve
    **/
    function disableReserveAsCollateral(address _reserve) external onlyLendingPoolConfigurator {
        reserves[_reserve].disableAsCollateral();
    }

    /**
    * @dev enable the stable borrow rate mode on a reserve
    * @param _reserve the address of the reserve
    **/
    function enableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isStableBorrowRateEnabled = true;
    }

    /**
    * @dev disable the stable borrow rate mode on a reserve
    * @param _reserve the address of the reserve
    **/
    function disableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isStableBorrowRateEnabled = false;
    }

    /**
    * @dev activates a reserve
    * @param _reserve the address of the reserve
    **/
    function activateReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        require(
            reserve.lastLiquidityCumulativeIndex > 0 &&
            reserve.lastVariableBorrowCumulativeIndex > 0,
            "Reserve has not been initialized yet"
        );
        reserve.isActive = true;
    }

    /**
    * @dev deactivates a reserve
    * @param _reserve the address of the reserve
    **/
    function deactivateReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isActive = false;
    }

    /**
    * @notice allows the configurator to freeze the reserve.
    * A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance.
    * @param _reserve the address of the reserve
    **/
    function freezeReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isFreezed = true;
    }

    /**
    * @notice allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed.
    * @param _reserve the address of the reserve
    **/
    function unfreezeReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isFreezed = false;
    }

    /**
    * @notice allows the configurator to update the loan to value of a reserve
    * @param _reserve the address of the reserve
    * @param _ltv the new loan to value
    **/
    function setReserveBaseLTVasCollateral(address _reserve, uint256 _ltv)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.baseLTVasCollateral = _ltv;
    }

    /**
    * @notice allows the configurator to update the liquidation threshold of a reserve
    * @param _reserve the address of the reserve
    * @param _threshold the new liquidation threshold
    **/
    function setReserveLiquidationThreshold(address _reserve, uint256 _threshold)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.liquidationThreshold = _threshold;
    }

    /**
    * @notice allows the configurator to update the liquidation bonus of a reserve
    * @param _reserve the address of the reserve
    * @param _bonus the new liquidation bonus
    **/
    function setReserveLiquidationBonus(address _reserve, uint256 _bonus)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.liquidationBonus = _bonus;
    }

    /**
    * @notice allows the configurator to update the reserve decimals
    * @param _reserve the address of the reserve
    * @param _decimals the decimals of the reserve
    **/
    function setReserveDecimals(address _reserve, uint256 _decimals)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.decimals = _decimals;
    }

    /**
    * @notice internal functions
    **/

    /**
    * @dev updates the state of a reserve as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the previous borrow balance of the borrower before the action
    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount
    * @param _amountBorrowed the new amount borrowed
    * @param _rateMode the borrow rate mode (stable, variable)
    **/

    function updateReserveStateOnBorrowInternal(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _balanceIncrease,
        uint256 _amountBorrowed,
        CoreLibrary.InterestRateMode _rateMode
    ) internal {
        reserves[_reserve].updateCumulativeIndexes();

        //increasing reserve total borrows to account for the new borrow balance of the user
        //NOTE: Depending on the previous borrow mode, the borrows might need to be switched from variable to stable or vice versa

        updateReserveTotalBorrowsByRateModeInternal(
            _reserve,
            _user,
            _principalBorrowBalance,
            _balanceIncrease,
            _amountBorrowed,
            _rateMode
        );
    }

    /**
    * @dev updates the state of a user as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _amountBorrowed the amount borrowed
    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount
    * @param _rateMode the borrow rate mode (stable, variable)
    * @return the final borrow rate for the user. Emitted by the borrow() event
    **/

    function updateUserStateOnBorrowInternal(
        address _reserve,
        address _user,
        uint256 _amountBorrowed,
        uint256 _balanceIncrease,
        uint256 _fee,
        CoreLibrary.InterestRateMode _rateMode
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (_rateMode == CoreLibrary.InterestRateMode.STABLE) {
            //stable
            //reset the user variable index, and update the stable rate
            user.stableBorrowRate = reserve.currentStableBorrowRate;
            user.lastVariableBorrowCumulativeIndex = 0;
        } else if (_rateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //variable
            //reset the user stable rate, and store the new borrow index
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        } else {
            revert("Invalid borrow rate mode");
        }
        //increase the principal borrows and the origination fee
        user.principalBorrowBalance = user.principalBorrowBalance.add(_amountBorrowed).add(
            _balanceIncrease
        );
        user.originationFee = user.originationFee.add(_fee);

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

    }

    /**
    * @dev updates the state of the reserve as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateReserveStateOnRepayInternal(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_reserve][_user];

        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(_reserve, _user);

        //update the indexes
        reserves[_reserve].updateCumulativeIndexes();

        //compound the cumulated interest to the borrow balance and then subtracting the payback amount
        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _balanceIncrease,
                user.stableBorrowRate
            );
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _paybackAmountMinusFees,
                user.stableBorrowRate
            );
        } else {
            reserve.increaseTotalBorrowsVariable(_balanceIncrease);
            reserve.decreaseTotalBorrowsVariable(_paybackAmountMinusFees);
        }
    }

    /**
    * @dev updates the state of the user as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _originationFeeRepaid the fee on the amount that is being repaid
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _repaidWholeLoan true if the user is repaying the whole loan
    **/
    function updateUserStateOnRepayInternal(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _originationFeeRepaid,
        uint256 _balanceIncrease,
        bool _repaidWholeLoan
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        //update the user principal borrow balance, adding the cumulated interest and then subtracting the payback amount
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(
            _paybackAmountMinusFees
        );
        user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;

        //if the balance decrease is equal to the previous principal (user is repaying the whole loan)
        //and the rate mode is stable, we reset the interest rate mode of the user
        if (_repaidWholeLoan) {
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = 0;
        }
        user.originationFee = user.originationFee.sub(_originationFeeRepaid);

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

    }

    /**
    * @dev updates the state of the user as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is performing the rate swap
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the the principal amount borrowed by the user
    * @param _compoundedBorrowBalance the principal amount plus the accrued interest
    * @param _currentRateMode the rate mode at which the user borrowed
    **/
    function updateReserveStateOnSwapRateInternal(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _compoundedBorrowBalance,
        CoreLibrary.InterestRateMode _currentRateMode
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        //compounding reserve indexes
        reserve.updateCumulativeIndexes();

        if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {
            uint256 userCurrentStableRate = user.stableBorrowRate;

            //swap to variable
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _principalBorrowBalance,
                userCurrentStableRate
            ); //decreasing stable from old principal balance
            reserve.increaseTotalBorrowsVariable(_compoundedBorrowBalance); //increase variable borrows
        } else if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //swap to stable
            uint256 currentStableRate = reserve.currentStableBorrowRate;
            reserve.decreaseTotalBorrowsVariable(_principalBorrowBalance);
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _compoundedBorrowBalance,
                currentStableRate
            );

        } else {
            revert("Invalid rate mode received");
        }
    }

    /**
    * @dev updates the state of the user as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is performing the swap
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _currentRateMode the current rate mode of the user
    **/

    function updateUserStateOnSwapRateInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease,
        CoreLibrary.InterestRateMode _currentRateMode
    ) internal returns (CoreLibrary.InterestRateMode) {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        CoreLibrary.InterestRateMode newMode = CoreLibrary.InterestRateMode.NONE;

        if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //switch to stable
            newMode = CoreLibrary.InterestRateMode.STABLE;
            user.stableBorrowRate = reserve.currentStableBorrowRate;
            user.lastVariableBorrowCumulativeIndex = 0;
        } else if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {
            newMode = CoreLibrary.InterestRateMode.VARIABLE;
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        } else {
            revert("Invalid interest rate mode received");
        }
        //compounding cumulated interest
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);
        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

        return newMode;
    }

    /**
    * @dev updates the state of the principal reserve as a consequence of a liquidation action.
    * @param _principalReserve the address of the principal reserve that is being repaid
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updatePrincipalReserveStateOnLiquidationInternal(
        address _principalReserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_principalReserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_principalReserve];

        //update principal reserve data
        reserve.updateCumulativeIndexes();

        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(
            _principalReserve,
            _user
        );

        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            //increase the total borrows by the compounded interest
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _balanceIncrease,
                user.stableBorrowRate
            );

            //decrease by the actual amount to liquidate
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _amountToLiquidate,
                user.stableBorrowRate
            );

        } else {
            //increase the total borrows by the compounded interest
            reserve.increaseTotalBorrowsVariable(_balanceIncrease);

            //decrease by the actual amount to liquidate
            reserve.decreaseTotalBorrowsVariable(_amountToLiquidate);
        }

    }

    /**
    * @dev updates the state of the collateral reserve as a consequence of a liquidation action.
    * @param _collateralReserve the address of the collateral reserve that is being liquidated
    **/
    function updateCollateralReserveStateOnLiquidationInternal(
        address _collateralReserve
    ) internal {
        //update collateral reserve
        reserves[_collateralReserve].updateCumulativeIndexes();

    }

    /**
    * @dev updates the state of the user being liquidated as a consequence of a liquidation action.
    * @param _reserve the address of the principal reserve that is being repaid
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _feeLiquidated the amount of origination fee being liquidated
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/
    function updateUserStateOnLiquidationInternal(
        address _reserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _feeLiquidated,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        //first increase by the compounded interest, then decrease by the liquidated amount
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(
            _amountToLiquidate
        );

        if (
            getUserCurrentBorrowRateMode(_reserve, _user) == CoreLibrary.InterestRateMode.VARIABLE
        ) {
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        }

        if(_feeLiquidated > 0){
            user.originationFee = user.originationFee.sub(_feeLiquidated);
        }

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);
    }

    /**
    * @dev updates the state of the reserve as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateReserveStateOnRebalanceInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        reserve.updateCumulativeIndexes();

        reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
            _balanceIncrease,
            user.stableBorrowRate
        );

    }

    /**
    * @dev updates the state of the user as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateUserStateOnRebalanceInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);
        user.stableBorrowRate = reserve.currentStableBorrowRate;

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);
    }

    /**
    * @dev updates the state of the user as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _amountBorrowed the accrued interest on the borrowed amount
    **/
    function updateReserveTotalBorrowsByRateModeInternal(
        address _reserve,
        address _user,
        uint256 _principalBalance,
        uint256 _balanceIncrease,
        uint256 _amountBorrowed,
        CoreLibrary.InterestRateMode _newBorrowRateMode
    ) internal {
        CoreLibrary.InterestRateMode previousRateMode = getUserCurrentBorrowRateMode(
            _reserve,
            _user
        );
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        if (previousRateMode == CoreLibrary.InterestRateMode.STABLE) {
            CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _principalBalance,
                user.stableBorrowRate
            );
        } else if (previousRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            reserve.decreaseTotalBorrowsVariable(_principalBalance);
        }

        uint256 newPrincipalAmount = _principalBalance.add(_balanceIncrease).add(_amountBorrowed);
        if (_newBorrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                newPrincipalAmount,
                reserve.currentStableBorrowRate
            );
        } else if (_newBorrowRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            reserve.increaseTotalBorrowsVariable(newPrincipalAmount);
        } else {
            revert("Invalid new borrow rate mode");
        }
    }

    /**
    * @dev Updates the reserve current stable borrow rate Rf, the current variable borrow rate Rv and the current liquidity rate Rl.
    * Also updates the lastUpdateTimestamp value. Please refer to the whitepaper for further information.
    * @param _reserve the address of the reserve to be updated
    * @param _liquidityAdded the amount of liquidity added to the protocol (deposit or repay) in the previous action
    * @param _liquidityTaken the amount of liquidity taken from the protocol (redeem or borrow)
    **/

    function updateReserveInterestRatesAndTimestampInternal(
        address _reserve,
        uint256 _liquidityAdded,
        uint256 _liquidityTaken
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        (uint256 newLiquidityRate, uint256 newStableRate, uint256 newVariableRate) = IReserveInterestRateStrategy(
            reserve
            .interestRateStrategyAddress
        )
        .calculateInterestRates(
            _reserve,
            getReserveAvailableLiquidity(_reserve).add(_liquidityAdded).sub(_liquidityTaken),
            reserve.totalBorrowsStable,
            reserve.totalBorrowsVariable,
            reserve.currentAverageStableBorrowRate
        );

        reserve.currentLiquidityRate = newLiquidityRate;
        reserve.currentStableBorrowRate = newStableRate;
        reserve.currentVariableBorrowRate = newVariableRate;

        //solium-disable-next-line
        reserve.lastUpdateTimestamp = uint40(block.timestamp);

        emit ReserveUpdated(
            _reserve,
            newLiquidityRate,
            newStableRate,
            newVariableRate,
            reserve.lastLiquidityCumulativeIndex,
            reserve.lastVariableBorrowCumulativeIndex
        );
    }

    /**
    * @dev transfers to the protocol fees of a flashloan to the fees collection address
    * @param _token the address of the token being transferred
    * @param _amount the amount being transferred
    **/

    function transferFlashLoanProtocolFeeInternal(address _token, uint256 _amount) internal {
        address payable receiver = address(uint160(addressesProvider.getTokenDistributor()));

        if (_token != EthAddressLib.ethAddress()) {
            ERC20(_token).safeTransfer(receiver, _amount);
        } else {
            receiver.transfer(_amount);
        }
    }

    /**
    * @dev updates the internal configuration of the core
    **/
    function refreshConfigInternal() internal {
        lendingPoolAddress = addressesProvider.getLendingPool();
    }

    /**
    * @dev adds a reserve to the array of the reserves address
    **/
    function addReserveToListInternal(address _reserve) internal {
        bool reserveAlreadyAdded = false;
        for (uint256 i = 0; i < reservesList.length; i++)
            if (reservesList[i] == _reserve) {
                reserveAlreadyAdded = true;
            }
        if (!reserveAlreadyAdded) reservesList.push(_reserve);
    }

}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-01-09 04:31:45 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 04:31:45 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 28820
completion_tokens: 1
total_tokens: 28821
cost: $-1.000000


[2024-01-09 04:31:45 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: pragma solidity ^0.5.0;

import "openzeppelin-solidity/contracts/math/SafeMath.sol";
import "openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol";
import "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol";
import "openzeppelin-solidity/contracts/utils/Address.sol";
import "../libraries/openzeppelin-upgradeability/VersionedInitializable.sol";

import "../libraries/CoreLibrary.sol";
import "../configuration/LendingPoolAddressesProvider.sol";
import "../interfaces/ILendingRateOracle.sol";
import "../interfaces/IReserveInterestRateStrategy.sol";
import "../libraries/WadRayMath.sol";
import "../tokenization/AToken.sol";
import "../libraries/EthAddressLib.sol";

/**
* @title LendingPoolCore contract
* @author Aave
* @notice Holds the state of the lending pool and all the funds deposited
* @dev NOTE: The core does not enforce security checks on the update of the state
* (eg, updateStateOnBorrow() does not enforce that borrowed is enabled on the reserve).
* The check that an action can be performed is a duty of the overlying LendingPool contract.
**/

contract LendingPoolCore is VersionedInitializable {
    using SafeMath for uint256;
    using WadRayMath for uint256;
    using CoreLibrary for CoreLibrary.ReserveData;
    using CoreLibrary for CoreLibrary.UserReserveData;
    using SafeERC20 for ERC20;
    using Address for address payable;

    /**
    * @dev Emitted when the state of a reserve is updated
    * @param reserve the address of the reserve
    * @param liquidityRate the new liquidity rate
    * @param stableBorrowRate the new stable borrow rate
    * @param variableBorrowRate the new variable borrow rate
    * @param liquidityIndex the new liquidity index
    * @param variableBorrowIndex the new variable borrow index
    **/
    event ReserveUpdated(
        address indexed reserve,
        uint256 liquidityRate,
        uint256 stableBorrowRate,
        uint256 variableBorrowRate,
        uint256 liquidityIndex,
        uint256 variableBorrowIndex
    );

    address public lendingPoolAddress;

    LendingPoolAddressesProvider public addressesProvider;

    /**
    * @dev only lending pools can use functions affected by this modifier
    **/
    modifier onlyLendingPool {
        require(lendingPoolAddress == msg.sender, "The caller must be a lending pool contract");
        _;
    }

    /**
    * @dev only lending pools configurator can use functions affected by this modifier
    **/
    modifier onlyLendingPoolConfigurator {
        require(
            addressesProvider.getLendingPoolConfigurator() == msg.sender,
            "The caller must be a lending pool configurator contract"
        );
        _;
    }

    mapping(address => CoreLibrary.ReserveData) internal reserves;
    mapping(address => mapping(address => CoreLibrary.UserReserveData)) internal usersReserveData;

    address[] public reservesList;

    uint256 public constant CORE_REVISION = 0x4;

    /**
    * @dev returns the revision number of the contract
    **/
    function getRevision() internal pure returns (uint256) {
        return CORE_REVISION;
    }

    /**
    * @dev initializes the Core contract, invoked upon registration on the AddressesProvider
    * @param _addressesProvider the addressesProvider contract
    **/

    function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {
        addressesProvider = _addressesProvider;
        refreshConfigInternal();
    }

    /**
    * @dev updates the state of the core as a result of a deposit action
    * @param _reserve the address of the reserve in which the deposit is happening
    * @param _user the address of the the user depositing
    * @param _amount the amount being deposited
    * @param _isFirstDeposit true if the user is depositing for the first time
    **/

    function updateStateOnDeposit(
        address _reserve,
        address _user,
        uint256 _amount,
        bool _isFirstDeposit
    ) external onlyLendingPool {
        reserves[_reserve].updateCumulativeIndexes();
        updateReserveInterestRatesAndTimestampInternal(_reserve, _amount, 0);

        if (_isFirstDeposit) {
            //if this is the first deposit of the user, we configure the deposit as enabled to be used as collateral
            setUserUseReserveAsCollateral(_reserve, _user, true);
        }
    }

    /**
    * @dev updates the state of the core as a result of a redeem action
    * @param _reserve the address of the reserve in which the redeem is happening
    * @param _user the address of the the user redeeming
    * @param _amountRedeemed the amount being redeemed
    * @param _userRedeemedEverything true if the user is redeeming everything
    **/
    function updateStateOnRedeem(
        address _reserve,
        address _user,
        uint256 _amountRedeemed,
        bool _userRedeemedEverything
    ) external onlyLendingPool {
        //compound liquidity and variable borrow interests
        reserves[_reserve].updateCumulativeIndexes();
        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountRedeemed);

        //if user redeemed everything the useReserveAsCollateral flag is reset
        if (_userRedeemedEverything) {
            setUserUseReserveAsCollateral(_reserve, _user, false);
        }
    }

    /**
    * @dev updates the state of the core as a result of a flashloan action
    * @param _reserve the address of the reserve in which the flashloan is happening
    * @param _income the income of the protocol as a result of the action
    **/
    function updateStateOnFlashLoan(
        address _reserve,
        uint256 _availableLiquidityBefore,
        uint256 _income,
        uint256 _protocolFee
    ) external onlyLendingPool {
        transferFlashLoanProtocolFeeInternal(_reserve, _protocolFee);

        //compounding the cumulated interest
        reserves[_reserve].updateCumulativeIndexes();

        uint256 totalLiquidityBefore = _availableLiquidityBefore.add(
            getReserveTotalBorrows(_reserve)
        );

        //compounding the received fee into the reserve
        reserves[_reserve].cumulateToLiquidityIndex(totalLiquidityBefore, _income);

        //refresh interest rates
        updateReserveInterestRatesAndTimestampInternal(_reserve, _income, 0);
    }

    /**
    * @dev updates the state of the core as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _amountBorrowed the new amount borrowed
    * @param _borrowFee the fee on the amount borrowed
    * @param _rateMode the borrow rate mode (stable, variable)
    * @return the new borrow rate for the user
    **/
    function updateStateOnBorrow(
        address _reserve,
        address _user,
        uint256 _amountBorrowed,
        uint256 _borrowFee,
        CoreLibrary.InterestRateMode _rateMode
    ) external onlyLendingPool returns (uint256, uint256) {
        // getting the previous borrow data of the user
        (uint256 principalBorrowBalance, , uint256 balanceIncrease) = getUserBorrowBalances(
            _reserve,
            _user
        );

        updateReserveStateOnBorrowInternal(
            _reserve,
            _user,
            principalBorrowBalance,
            balanceIncrease,
            _amountBorrowed,
            _rateMode
        );

        updateUserStateOnBorrowInternal(
            _reserve,
            _user,
            _amountBorrowed,
            balanceIncrease,
            _borrowFee,
            _rateMode
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountBorrowed);

        return (getUserCurrentBorrowRate(_reserve, _user), balanceIncrease);
    }

    /**
    * @dev updates the state of the core as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _originationFeeRepaid the fee on the amount that is being repaid
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _repaidWholeLoan true if the user is repaying the whole loan
    **/

    function updateStateOnRepay(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _originationFeeRepaid,
        uint256 _balanceIncrease,
        bool _repaidWholeLoan
    ) external onlyLendingPool {
        updateReserveStateOnRepayInternal(
            _reserve,
            _user,
            _paybackAmountMinusFees,
            _balanceIncrease
        );
        updateUserStateOnRepayInternal(
            _reserve,
            _user,
            _paybackAmountMinusFees,
            _originationFeeRepaid,
            _balanceIncrease,
            _repaidWholeLoan
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, _paybackAmountMinusFees, 0);
    }

    /**
    * @dev updates the state of the core as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the amount borrowed by the user
    * @param _compoundedBorrowBalance the amount borrowed plus accrued interest
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _currentRateMode the current interest rate mode for the user
    **/
    function updateStateOnSwapRate(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _compoundedBorrowBalance,
        uint256 _balanceIncrease,
        CoreLibrary.InterestRateMode _currentRateMode
    ) external onlyLendingPool returns (CoreLibrary.InterestRateMode, uint256) {
        updateReserveStateOnSwapRateInternal(
            _reserve,
            _user,
            _principalBorrowBalance,
            _compoundedBorrowBalance,
            _currentRateMode
        );

        CoreLibrary.InterestRateMode newRateMode = updateUserStateOnSwapRateInternal(
            _reserve,
            _user,
            _balanceIncrease,
            _currentRateMode
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);

        return (newRateMode, getUserCurrentBorrowRate(_reserve, _user));
    }

    /**
    * @dev updates the state of the core as a consequence of a liquidation action.
    * @param _principalReserve the address of the principal reserve that is being repaid
    * @param _collateralReserve the address of the collateral reserve that is being liquidated
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _collateralToLiquidate the amount of collateral being liquidated
    * @param _feeLiquidated the amount of origination fee being liquidated
    * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise
    **/
    function updateStateOnLiquidation(
        address _principalReserve,
        address _collateralReserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _collateralToLiquidate,
        uint256 _feeLiquidated,
        uint256 _liquidatedCollateralForFee,
        uint256 _balanceIncrease,
        bool _liquidatorReceivesAToken
    ) external onlyLendingPool {
        updatePrincipalReserveStateOnLiquidationInternal(
            _principalReserve,
            _user,
            _amountToLiquidate,
            _balanceIncrease
        );

        updateCollateralReserveStateOnLiquidationInternal(
            _collateralReserve
        );

        updateUserStateOnLiquidationInternal(
            _principalReserve,
            _user,
            _amountToLiquidate,
            _feeLiquidated,
            _balanceIncrease
        );

        updateReserveInterestRatesAndTimestampInternal(_principalReserve, _amountToLiquidate, 0);

        if (!_liquidatorReceivesAToken) {
            updateReserveInterestRatesAndTimestampInternal(
                _collateralReserve,
                0,
                _collateralToLiquidate.add(_liquidatedCollateralForFee)
            );
        }

    }

    /**
    * @dev updates the state of the core as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @return the new stable rate for the user
    **/
    function updateStateOnRebalance(address _reserve, address _user, uint256 _balanceIncrease)
    external
    onlyLendingPool
    returns (uint256)
    {
        updateReserveStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);

        //update user data and rebalance the rate
        updateUserStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);
        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);
        return usersReserveData[_user][_reserve].stableBorrowRate;
    }

    /**
    * @dev enables or disables a reserve as collateral
    * @param _reserve the address of the principal reserve where the user deposited
    * @param _user the address of the depositor
    * @param _useAsCollateral true if the depositor wants to use the reserve as collateral
    **/
    function setUserUseReserveAsCollateral(address _reserve, address _user, bool _useAsCollateral)
    public
    onlyLendingPool
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        user.useAsCollateral = _useAsCollateral;
    }

    /**
    * @notice ETH/token transfer functions
    **/

    /**
    * @dev fallback function enforces that the caller is a contract, to support flashloan transfers
    **/
    function() external payable {
        //only contracts can send ETH to the core
        require(msg.sender.isContract(), "Only contracts can send ether to the Lending pool core");

    }

    /**
    * @dev transfers to the user a specific amount from the reserve.
    * @param _reserve the address of the reserve where the transfer is happening
    * @param _user the address of the user receiving the transfer
    * @param _amount the amount being transferred
    **/
    function transferToUser(address _reserve, address payable _user, uint256 _amount)
    external
    onlyLendingPool
    {
        if (_reserve != EthAddressLib.ethAddress()) {
            ERC20(_reserve).safeTransfer(_user, _amount);
        } else {
            //solium-disable-next-line
            (bool result, ) = _user.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers the protocol fees to the fees collection address
    * @param _token the address of the token being transferred
    * @param _user the address of the user from where the transfer is happening
    * @param _amount the amount being transferred
    * @param _destination the fee receiver address
    **/

    function transferToFeeCollectionAddress(
        address _token,
        address _user,
        uint256 _amount,
        address _destination
    ) external payable onlyLendingPool {
        address payable feeAddress = address(uint160(_destination)); //cast the address to payable

        if (_token != EthAddressLib.ethAddress()) {
            require(
                msg.value == 0,
                "User is sending ETH along with the ERC20 transfer. Check the value attribute of the transaction"
            );
            ERC20(_token).safeTransferFrom(_user, feeAddress, _amount);
        } else {
            require(msg.value >= _amount, "The amount and the value sent to deposit do not match");
            //solium-disable-next-line
            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers the fees to the fees collection address in the case of liquidation
    * @param _token the address of the token being transferred
    * @param _amount the amount being transferred
    * @param _destination the fee receiver address
    **/
    function liquidateFee(
        address _token,
        uint256 _amount,
        address _destination
    ) external payable onlyLendingPool {
        address payable feeAddress = address(uint160(_destination)); //cast the address to payable
        require(
            msg.value == 0,
            "Fee liquidation does not require any transfer of value"
        );

        if (_token != EthAddressLib.ethAddress()) {
            ERC20(_token).safeTransfer(feeAddress, _amount);
        } else {
            //solium-disable-next-line
            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers an amount from a user to the destination reserve
    * @param _reserve the address of the reserve where the amount is being transferred
    * @param _user the address of the user from where the transfer is happening
    * @param _amount the amount being transferred
    **/
    function transferToReserve(address _reserve, address payable _user, uint256 _amount)
    external
    payable
    onlyLendingPool
    {
        if (_reserve != EthAddressLib.ethAddress()) {
            require(msg.value == 0, "User is sending ETH along with the ERC20 transfer.");
            ERC20(_reserve).safeTransferFrom(_user, address(this), _amount);

        } else {
            require(msg.value >= _amount, "The amount and the value sent to deposit do not match");

            if (msg.value > _amount) {
                //send back excess ETH
                uint256 excessAmount = msg.value.sub(_amount);
                //solium-disable-next-line
                (bool result, ) = _user.call.value(excessAmount).gas(50000)("");
                require(result, "Transfer of ETH failed");
            }
        }
    }

    /**
    * @notice data access functions
    **/

    /**
    * @dev returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral)
    * needed to calculate the global account data in the LendingPoolDataProvider
    * @param _reserve the address of the reserve
    * @param _user the address of the user
    * @return the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not
    **/
    function getUserBasicReserveData(address _reserve, address _user)
    external
    view
    returns (uint256, uint256, uint256, bool)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        uint256 underlyingBalance = getUserUnderlyingAssetBalance(_reserve, _user);

        if (user.principalBorrowBalance == 0) {
            return (underlyingBalance, 0, 0, user.useAsCollateral);
        }

        return (
        underlyingBalance,
        user.getCompoundedBorrowBalance(reserve),
        user.originationFee,
        user.useAsCollateral
        );
    }

    /**
    * @dev checks if a user is allowed to borrow at a stable rate
    * @param _reserve the reserve address
    * @param _user the user
    * @param _amount the amount the the user wants to borrow
    * @return true if the user is allowed to borrow at a stable rate, false otherwise
    **/

    function isUserAllowedToBorrowAtStable(address _reserve, address _user, uint256 _amount)
    external
    view
    returns (bool)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (!reserve.isStableBorrowRateEnabled) return false;

        return
        !user.useAsCollateral ||
        !reserve.usageAsCollateralEnabled ||
        _amount > getUserUnderlyingAssetBalance(_reserve, _user);
    }

    /**
    * @dev gets the underlying asset balance of a user based on the corresponding aToken balance.
    * @param _reserve the reserve address
    * @param _user the user address
    * @return the underlying deposit balance of the user
    **/

    function getUserUnderlyingAssetBalance(address _reserve, address _user)
    public
    view
    returns (uint256)
    {
        AToken aToken = AToken(reserves[_reserve].aTokenAddress);
        return aToken.balanceOf(_user);

    }

    /**
    * @dev gets the interest rate strategy contract address for the reserve
    * @param _reserve the reserve address
    * @return the address of the interest rate strategy contract
    **/
    function getReserveInterestRateStrategyAddress(address _reserve) public view returns (address) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.interestRateStrategyAddress;
    }

    /**
    * @dev gets the aToken contract address for the reserve
    * @param _reserve the reserve address
    * @return the address of the aToken contract
    **/

    function getReserveATokenAddress(address _reserve) public view returns (address) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.aTokenAddress;
    }

    /**
    * @dev gets the available liquidity in the reserve. The available liquidity is the balance of the core contract
    * @param _reserve the reserve address
    * @return the available liquidity
    **/
    function getReserveAvailableLiquidity(address _reserve) public view returns (uint256) {
        uint256 balance = 0;

        if (_reserve == EthAddressLib.ethAddress()) {
            balance = address(this).balance;
        } else {
            balance = IERC20(_reserve).balanceOf(address(this));
        }
        return balance;
    }

    /**
    * @dev gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows
    * @param _reserve the reserve address
    * @return the total liquidity
    **/
    function getReserveTotalLiquidity(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return getReserveAvailableLiquidity(_reserve).add(reserve.getTotalBorrows());
    }

    /**
    * @dev gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there
    * there has been 100% income.
    * @param _reserve the reserve address
    * @return the reserve normalized income
    **/
    function getReserveNormalizedIncome(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.getNormalizedIncome();
    }

    /**
    * @dev gets the reserve total borrows
    * @param _reserve the reserve address
    * @return the total borrows (stable + variable)
    **/
    function getReserveTotalBorrows(address _reserve) public view returns (uint256) {
        return reserves[_reserve].getTotalBorrows();
    }

    /**
    * @dev gets the reserve total borrows stable
    * @param _reserve the reserve address
    * @return the total borrows stable
    **/
    function getReserveTotalBorrowsStable(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.totalBorrowsStable;
    }

    /**
    * @dev gets the reserve total borrows variable
    * @param _reserve the reserve address
    * @return the total borrows variable
    **/

    function getReserveTotalBorrowsVariable(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.totalBorrowsVariable;
    }

    /**
    * @dev gets the reserve liquidation threshold
    * @param _reserve the reserve address
    * @return the reserve liquidation threshold
    **/

    function getReserveLiquidationThreshold(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.liquidationThreshold;
    }

    /**
    * @dev gets the reserve liquidation bonus
    * @param _reserve the reserve address
    * @return the reserve liquidation bonus
    **/

    function getReserveLiquidationBonus(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.liquidationBonus;
    }

    /**
    * @dev gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty
    * @param _reserve the reserve address
    * @return the reserve current variable borrow rate
    **/

    function getReserveCurrentVariableBorrowRate(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        if (reserve.currentVariableBorrowRate == 0) {
            return
            IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)
            .getBaseVariableBorrowRate();
        }
        return reserve.currentVariableBorrowRate;
    }

    /**
    * @dev gets the reserve current stable borrow rate. Is the market rate if the reserve is empty
    * @param _reserve the reserve address
    * @return the reserve current stable borrow rate
    **/

    function getReserveCurrentStableBorrowRate(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        ILendingRateOracle oracle = ILendingRateOracle(addressesProvider.getLendingRateOracle());

        if (reserve.currentStableBorrowRate == 0) {
            //no stable rate borrows yet
            return oracle.getMarketBorrowRate(_reserve);
        }

        return reserve.currentStableBorrowRate;
    }

    /**
    * @dev gets the reserve average stable borrow rate. The average stable rate is the weighted average
    * of all the loans taken at stable rate.
    * @param _reserve the reserve address
    * @return the reserve current average borrow rate
    **/
    function getReserveCurrentAverageStableBorrowRate(address _reserve)
    external
    view
    returns (uint256)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.currentAverageStableBorrowRate;
    }

    /**
    * @dev gets the reserve liquidity rate
    * @param _reserve the reserve address
    * @return the reserve liquidity rate
    **/
    function getReserveCurrentLiquidityRate(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.currentLiquidityRate;
    }

    /**
    * @dev gets the reserve liquidity cumulative index
    * @param _reserve the reserve address
    * @return the reserve liquidity cumulative index
    **/
    function getReserveLiquidityCumulativeIndex(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.lastLiquidityCumulativeIndex;
    }

    /**
    * @dev gets the reserve variable borrow index
    * @param _reserve the reserve address
    * @return the reserve variable borrow index
    **/
    function getReserveVariableBorrowsCumulativeIndex(address _reserve)
    external
    view
    returns (uint256)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.lastVariableBorrowCumulativeIndex;
    }

    /**
    * @dev this function aggregates the configuration parameters of the reserve.
    * It's used in the LendingPoolDataProvider specifically to save gas, and avoid
    * multiple external contract calls to fetch the same data.
    * @param _reserve the reserve address
    * @return the reserve decimals
    * @return the base ltv as collateral
    * @return the liquidation threshold
    * @return if the reserve is used as collateral or not
    **/
    function getReserveConfiguration(address _reserve)
    external
    view
    returns (uint256, uint256, uint256, bool)
    {
        uint256 decimals;
        uint256 baseLTVasCollateral;
        uint256 liquidationThreshold;
        bool usageAsCollateralEnabled;

        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        decimals = reserve.decimals;
        baseLTVasCollateral = reserve.baseLTVasCollateral;
        liquidationThreshold = reserve.liquidationThreshold;
        usageAsCollateralEnabled = reserve.usageAsCollateralEnabled;

        return (decimals, baseLTVasCollateral, liquidationThreshold, usageAsCollateralEnabled);
    }

    /**
    * @dev returns the decimals of the reserve
    * @param _reserve the reserve address
    * @return the reserve decimals
    **/
    function getReserveDecimals(address _reserve) external view returns (uint256) {
        return reserves[_reserve].decimals;
    }

    /**
    * @dev returns true if the reserve is enabled for borrowing
    * @param _reserve the reserve address
    * @return true if the reserve is enabled for borrowing, false otherwise
    **/

    function isReserveBorrowingEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.borrowingEnabled;
    }

    /**
    * @dev returns true if the reserve is enabled as collateral
    * @param _reserve the reserve address
    * @return true if the reserve is enabled as collateral, false otherwise
    **/

    function isReserveUsageAsCollateralEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.usageAsCollateralEnabled;
    }

    /**
    * @dev returns true if the stable rate is enabled on reserve
    * @param _reserve the reserve address
    * @return true if the stable rate is enabled on reserve, false otherwise
    **/
    function getReserveIsStableBorrowRateEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isStableBorrowRateEnabled;
    }

    /**
    * @dev returns true if the reserve is active
    * @param _reserve the reserve address
    * @return true if the reserve is active, false otherwise
    **/
    function getReserveIsActive(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isActive;
    }

    /**
    * @notice returns if a reserve is freezed
    * @param _reserve the reserve for which the information is needed
    * @return true if the reserve is freezed, false otherwise
    **/

    function getReserveIsFreezed(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isFreezed;
    }

    /**
    * @notice returns the timestamp of the last action on the reserve
    * @param _reserve the reserve for which the information is needed
    * @return the last updated timestamp of the reserve
    **/

    function getReserveLastUpdate(address _reserve) external view returns (uint40 timestamp) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        timestamp = reserve.lastUpdateTimestamp;
    }

    /**
    * @dev returns the utilization rate U of a specific reserve
    * @param _reserve the reserve for which the information is needed
    * @return the utilization rate in ray
    **/

    function getReserveUtilizationRate(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        uint256 totalBorrows = reserve.getTotalBorrows();

        if (totalBorrows == 0) {
            return 0;
        }

        uint256 availableLiquidity = getReserveAvailableLiquidity(_reserve);

        return totalBorrows.rayDiv(availableLiquidity.add(totalBorrows));
    }

    /**
    * @return the array of reserves configured on the core
    **/
    function getReserves() external view returns (address[] memory) {
        return reservesList;
    }

    /**
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return true if the user has chosen to use the reserve as collateral, false otherwise
    **/
    function isUserUseReserveAsCollateralEnabled(address _reserve, address _user)
    external
    view
    returns (bool)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.useAsCollateral;
    }

    /**
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the origination fee for the user
    **/
    function getUserOriginationFee(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.originationFee;
    }

    /**
    * @dev users with no loans in progress have NONE as borrow rate mode
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the borrow rate mode for the user,
    **/

    function getUserCurrentBorrowRateMode(address _reserve, address _user)
    public
    view
    returns (CoreLibrary.InterestRateMode)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (user.principalBorrowBalance == 0) {
            return CoreLibrary.InterestRateMode.NONE;
        }

        return
        user.stableBorrowRate > 0
        ? CoreLibrary.InterestRateMode.STABLE
        : CoreLibrary.InterestRateMode.VARIABLE;
    }

    /**
    * @dev gets the current borrow rate of the user
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the borrow rate for the user,
    **/
    function getUserCurrentBorrowRate(address _reserve, address _user)
    internal
    view
    returns (uint256)
    {
        CoreLibrary.InterestRateMode rateMode = getUserCurrentBorrowRateMode(_reserve, _user);

        if (rateMode == CoreLibrary.InterestRateMode.NONE) {
            return 0;
        }

        return
        rateMode == CoreLibrary.InterestRateMode.STABLE
        ? usersReserveData[_user][_reserve].stableBorrowRate
        : reserves[_reserve].currentVariableBorrowRate;
    }

    /**
    * @dev the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the user stable rate
    **/
    function getUserCurrentStableBorrowRate(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.stableBorrowRate;
    }

    /**
    * @dev calculates and returns the borrow balances of the user
    * @param _reserve the address of the reserve
    * @param _user the address of the user
    * @return the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance
    **/

    function getUserBorrowBalances(address _reserve, address _user)
    public
    view
    returns (uint256, uint256, uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        if (user.principalBorrowBalance == 0) {
            return (0, 0, 0);
        }

        uint256 principal = user.principalBorrowBalance;
        uint256 compoundedBalance = CoreLibrary.getCompoundedBorrowBalance(
            user,
            reserves[_reserve]
        );
        return (principal, compoundedBalance, compoundedBalance.sub(principal));
    }

    /**
    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the variable borrow index for the user
    **/

    function getUserVariableBorrowCumulativeIndex(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.lastVariableBorrowCumulativeIndex;
    }

    /**
    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the variable borrow index for the user
    **/

    function getUserLastUpdate(address _reserve, address _user)
    external
    view
    returns (uint256 timestamp)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        timestamp = user.lastUpdateTimestamp;
    }

    /**
    * @dev updates the lending pool core configuration
    **/
    function refreshConfiguration() external onlyLendingPoolConfigurator {
        refreshConfigInternal();
    }

    /**
    * @dev initializes a reserve
    * @param _reserve the address of the reserve
    * @param _aTokenAddress the address of the overlying aToken contract
    * @param _decimals the decimals of the reserve currency
    * @param _interestRateStrategyAddress the address of the interest rate strategy contract
    **/
    function initReserve(
        address _reserve,
        address _aTokenAddress,
        uint256 _decimals,
        address _interestRateStrategyAddress
    ) external onlyLendingPoolConfigurator {
        reserves[_reserve].init(_aTokenAddress, _decimals, _interestRateStrategyAddress);
        addReserveToListInternal(_reserve);

    }



    /**
    * @dev removes the last added reserve in the reservesList array
    * @param _reserveToRemove the address of the reserve
    **/
    function removeLastAddedReserve(address _reserveToRemove)
    external onlyLendingPoolConfigurator {

        address lastReserve = reservesList[reservesList.length-1];

        require(lastReserve == _reserveToRemove, "Reserve being removed is different than the reserve requested");

        //as we can't check if totalLiquidity is 0 (since the reserve added might not be an ERC20) we at least check that there is nothing borrowed
        require(getReserveTotalBorrows(lastReserve) == 0, "Cannot remove a reserve with liquidity deposited");

        reserves[lastReserve].isActive = false;
        reserves[lastReserve].aTokenAddress = address(0);
        reserves[lastReserve].decimals = 0;
        reserves[lastReserve].lastLiquidityCumulativeIndex = 0;
        reserves[lastReserve].lastVariableBorrowCumulativeIndex = 0;
        reserves[lastReserve].borrowingEnabled = false;
        reserves[lastReserve].usageAsCollateralEnabled = false;
        reserves[lastReserve].baseLTVasCollateral = 0;
        reserves[lastReserve].liquidationThreshold = 0;
        reserves[lastReserve].liquidationBonus = 0;
        reserves[lastReserve].interestRateStrategyAddress = address(0);

        reservesList.pop();
    }

    /**
    * @dev updates the address of the interest rate strategy contract
    * @param _reserve the address of the reserve
    * @param _rateStrategyAddress the address of the interest rate strategy contract
    **/

    function setReserveInterestRateStrategyAddress(address _reserve, address _rateStrategyAddress)
    external
    onlyLendingPoolConfigurator
    {
        reserves[_reserve].interestRateStrategyAddress = _rateStrategyAddress;
    }

    /**
    * @dev enables borrowing on a reserve. Also sets the stable rate borrowing
    * @param _reserve the address of the reserve
    * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise
    **/

    function enableBorrowingOnReserve(address _reserve, bool _stableBorrowRateEnabled)
    external
    onlyLendingPoolConfigurator
    {
        reserves[_reserve].enableBorrowing(_stableBorrowRateEnabled);
    }

    /**
    * @dev disables borrowing on a reserve
    * @param _reserve the address of the reserve
    **/

    function disableBorrowingOnReserve(address _reserve) external onlyLendingPoolConfigurator {
        reserves[_reserve].disableBorrowing();
    }

    /**
    * @dev enables a reserve to be used as collateral
    * @param _reserve the address of the reserve
    **/
    function enableReserveAsCollateral(
        address _reserve,
        uint256 _baseLTVasCollateral,
        uint256 _liquidationThreshold,
        uint256 _liquidationBonus
    ) external onlyLendingPoolConfigurator {
        reserves[_reserve].enableAsCollateral(
            _baseLTVasCollateral,
            _liquidationThreshold,
            _liquidationBonus
        );
    }

    /**
    * @dev disables a reserve to be used as collateral
    * @param _reserve the address of the reserve
    **/
    function disableReserveAsCollateral(address _reserve) external onlyLendingPoolConfigurator {
        reserves[_reserve].disableAsCollateral();
    }

    /**
    * @dev enable the stable borrow rate mode on a reserve
    * @param _reserve the address of the reserve
    **/
    function enableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isStableBorrowRateEnabled = true;
    }

    /**
    * @dev disable the stable borrow rate mode on a reserve
    * @param _reserve the address of the reserve
    **/
    function disableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isStableBorrowRateEnabled = false;
    }

    /**
    * @dev activates a reserve
    * @param _reserve the address of the reserve
    **/
    function activateReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        require(
            reserve.lastLiquidityCumulativeIndex > 0 &&
            reserve.lastVariableBorrowCumulativeIndex > 0,
            "Reserve has not been initialized yet"
        );
        reserve.isActive = true;
    }

    /**
    * @dev deactivates a reserve
    * @param _reserve the address of the reserve
    **/
    function deactivateReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isActive = false;
    }

    /**
    * @notice allows the configurator to freeze the reserve.
    * A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance.
    * @param _reserve the address of the reserve
    **/
    function freezeReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isFreezed = true;
    }

    /**
    * @notice allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed.
    * @param _reserve the address of the reserve
    **/
    function unfreezeReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isFreezed = false;
    }

    /**
    * @notice allows the configurator to update the loan to value of a reserve
    * @param _reserve the address of the reserve
    * @param _ltv the new loan to value
    **/
    function setReserveBaseLTVasCollateral(address _reserve, uint256 _ltv)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.baseLTVasCollateral = _ltv;
    }

    /**
    * @notice allows the configurator to update the liquidation threshold of a reserve
    * @param _reserve the address of the reserve
    * @param _threshold the new liquidation threshold
    **/
    function setReserveLiquidationThreshold(address _reserve, uint256 _threshold)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.liquidationThreshold = _threshold;
    }

    /**
    * @notice allows the configurator to update the liquidation bonus of a reserve
    * @param _reserve the address of the reserve
    * @param _bonus the new liquidation bonus
    **/
    function setReserveLiquidationBonus(address _reserve, uint256 _bonus)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.liquidationBonus = _bonus;
    }

    /**
    * @notice allows the configurator to update the reserve decimals
    * @param _reserve the address of the reserve
    * @param _decimals the decimals of the reserve
    **/
    function setReserveDecimals(address _reserve, uint256 _decimals)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.decimals = _decimals;
    }

    /**
    * @notice internal functions
    **/

    /**
    * @dev updates the state of a reserve as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the previous borrow balance of the borrower before the action
    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount
    * @param _amountBorrowed the new amount borrowed
    * @param _rateMode the borrow rate mode (stable, variable)
    **/

    function updateReserveStateOnBorrowInternal(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _balanceIncrease,
        uint256 _amountBorrowed,
        CoreLibrary.InterestRateMode _rateMode
    ) internal {
        reserves[_reserve].updateCumulativeIndexes();

        //increasing reserve total borrows to account for the new borrow balance of the user
        //NOTE: Depending on the previous borrow mode, the borrows might need to be switched from variable to stable or vice versa

        updateReserveTotalBorrowsByRateModeInternal(
            _reserve,
            _user,
            _principalBorrowBalance,
            _balanceIncrease,
            _amountBorrowed,
            _rateMode
        );
    }

    /**
    * @dev updates the state of a user as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _amountBorrowed the amount borrowed
    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount
    * @param _rateMode the borrow rate mode (stable, variable)
    * @return the final borrow rate for the user. Emitted by the borrow() event
    **/

    function updateUserStateOnBorrowInternal(
        address _reserve,
        address _user,
        uint256 _amountBorrowed,
        uint256 _balanceIncrease,
        uint256 _fee,
        CoreLibrary.InterestRateMode _rateMode
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (_rateMode == CoreLibrary.InterestRateMode.STABLE) {
            //stable
            //reset the user variable index, and update the stable rate
            user.stableBorrowRate = reserve.currentStableBorrowRate;
            user.lastVariableBorrowCumulativeIndex = 0;
        } else if (_rateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //variable
            //reset the user stable rate, and store the new borrow index
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        } else {
            revert("Invalid borrow rate mode");
        }
        //increase the principal borrows and the origination fee
        user.principalBorrowBalance = user.principalBorrowBalance.add(_amountBorrowed).add(
            _balanceIncrease
        );
        user.originationFee = user.originationFee.add(_fee);

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

    }

    /**
    * @dev updates the state of the reserve as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateReserveStateOnRepayInternal(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_reserve][_user];

        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(_reserve, _user);

        //update the indexes
        reserves[_reserve].updateCumulativeIndexes();

        //compound the cumulated interest to the borrow balance and then subtracting the payback amount
        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _balanceIncrease,
                user.stableBorrowRate
            );
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _paybackAmountMinusFees,
                user.stableBorrowRate
            );
        } else {
            reserve.increaseTotalBorrowsVariable(_balanceIncrease);
            reserve.decreaseTotalBorrowsVariable(_paybackAmountMinusFees);
        }
    }

    /**
    * @dev updates the state of the user as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _originationFeeRepaid the fee on the amount that is being repaid
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _repaidWholeLoan true if the user is repaying the whole loan
    **/
    function updateUserStateOnRepayInternal(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _originationFeeRepaid,
        uint256 _balanceIncrease,
        bool _repaidWholeLoan
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        //update the user principal borrow balance, adding the cumulated interest and then subtracting the payback amount
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(
            _paybackAmountMinusFees
        );
        user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;

        //if the balance decrease is equal to the previous principal (user is repaying the whole loan)
        //and the rate mode is stable, we reset the interest rate mode of the user
        if (_repaidWholeLoan) {
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = 0;
        }
        user.originationFee = user.originationFee.sub(_originationFeeRepaid);

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

    }

    /**
    * @dev updates the state of the user as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is performing the rate swap
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the the principal amount borrowed by the user
    * @param _compoundedBorrowBalance the principal amount plus the accrued interest
    * @param _currentRateMode the rate mode at which the user borrowed
    **/
    function updateReserveStateOnSwapRateInternal(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _compoundedBorrowBalance,
        CoreLibrary.InterestRateMode _currentRateMode
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        //compounding reserve indexes
        reserve.updateCumulativeIndexes();

        if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {
            uint256 userCurrentStableRate = user.stableBorrowRate;

            //swap to variable
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _principalBorrowBalance,
                userCurrentStableRate
            ); //decreasing stable from old principal balance
            reserve.increaseTotalBorrowsVariable(_compoundedBorrowBalance); //increase variable borrows
        } else if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //swap to stable
            uint256 currentStableRate = reserve.currentStableBorrowRate;
            reserve.decreaseTotalBorrowsVariable(_principalBorrowBalance);
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _compoundedBorrowBalance,
                currentStableRate
            );

        } else {
            revert("Invalid rate mode received");
        }
    }

    /**
    * @dev updates the state of the user as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is performing the swap
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _currentRateMode the current rate mode of the user
    **/

    function updateUserStateOnSwapRateInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease,
        CoreLibrary.InterestRateMode _currentRateMode
    ) internal returns (CoreLibrary.InterestRateMode) {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        CoreLibrary.InterestRateMode newMode = CoreLibrary.InterestRateMode.NONE;

        if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //switch to stable
            newMode = CoreLibrary.InterestRateMode.STABLE;
            user.stableBorrowRate = reserve.currentStableBorrowRate;
            user.lastVariableBorrowCumulativeIndex = 0;
        } else if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {
            newMode = CoreLibrary.InterestRateMode.VARIABLE;
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        } else {
            revert("Invalid interest rate mode received");
        }
        //compounding cumulated interest
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);
        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

        return newMode;
    }

    /**
    * @dev updates the state of the principal reserve as a consequence of a liquidation action.
    * @param _principalReserve the address of the principal reserve that is being repaid
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updatePrincipalReserveStateOnLiquidationInternal(
        address _principalReserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_principalReserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_principalReserve];

        //update principal reserve data
        reserve.updateCumulativeIndexes();

        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(
            _principalReserve,
            _user
        );

        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            //increase the total borrows by the compounded interest
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _balanceIncrease,
                user.stableBorrowRate
            );

            //decrease by the actual amount to liquidate
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _amountToLiquidate,
                user.stableBorrowRate
            );

        } else {
            //increase the total borrows by the compounded interest
            reserve.increaseTotalBorrowsVariable(_balanceIncrease);

            //decrease by the actual amount to liquidate
            reserve.decreaseTotalBorrowsVariable(_amountToLiquidate);
        }

    }

    /**
    * @dev updates the state of the collateral reserve as a consequence of a liquidation action.
    * @param _collateralReserve the address of the collateral reserve that is being liquidated
    **/
    function updateCollateralReserveStateOnLiquidationInternal(
        address _collateralReserve
    ) internal {
        //update collateral reserve
        reserves[_collateralReserve].updateCumulativeIndexes();

    }

    /**
    * @dev updates the state of the user being liquidated as a consequence of a liquidation action.
    * @param _reserve the address of the principal reserve that is being repaid
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _feeLiquidated the amount of origination fee being liquidated
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/
    function updateUserStateOnLiquidationInternal(
        address _reserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _feeLiquidated,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        //first increase by the compounded interest, then decrease by the liquidated amount
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(
            _amountToLiquidate
        );

        if (
            getUserCurrentBorrowRateMode(_reserve, _user) == CoreLibrary.InterestRateMode.VARIABLE
        ) {
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        }

        if(_feeLiquidated > 0){
            user.originationFee = user.originationFee.sub(_feeLiquidated);
        }

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);
    }

    /**
    * @dev updates the state of the reserve as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateReserveStateOnRebalanceInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        reserve.updateCumulativeIndexes();

        reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
            _balanceIncrease,
            user.stableBorrowRate
        );

    }

    /**
    * @dev updates the state of the user as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateUserStateOnRebalanceInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);
        user.stableBorrowRate = reserve.currentStableBorrowRate;

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);
    }

    /**
    * @dev updates the state of the user as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _amountBorrowed the accrued interest on the borrowed amount
    **/
    function updateReserveTotalBorrowsByRateModeInternal(
        address _reserve,
        address _user,
        uint256 _principalBalance,
        uint256 _balanceIncrease,
        uint256 _amountBorrowed,
        CoreLibrary.InterestRateMode _newBorrowRateMode
    ) internal {
        CoreLibrary.InterestRateMode previousRateMode = getUserCurrentBorrowRateMode(
            _reserve,
            _user
        );
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        if (previousRateMode == CoreLibrary.InterestRateMode.STABLE) {
            CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _principalBalance,
                user.stableBorrowRate
            );
        } else if (previousRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            reserve.decreaseTotalBorrowsVariable(_principalBalance);
        }

        uint256 newPrincipalAmount = _principalBalance.add(_balanceIncrease).add(_amountBorrowed);
        if (_newBorrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                newPrincipalAmount,
                reserve.currentStableBorrowRate
            );
        } else if (_newBorrowRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            reserve.increaseTotalBorrowsVariable(newPrincipalAmount);
        } else {
            revert("Invalid new borrow rate mode");
        }
    }

    /**
    * @dev Updates the reserve current stable borrow rate Rf, the current variable borrow rate Rv and the current liquidity rate Rl.
    * Also updates the lastUpdateTimestamp value. Please refer to the whitepaper for further information.
    * @param _reserve the address of the reserve to be updated
    * @param _liquidityAdded the amount of liquidity added to the protocol (deposit or repay) in the previous action
    * @param _liquidityTaken the amount of liquidity taken from the protocol (redeem or borrow)
    **/

    function updateReserveInterestRatesAndTimestampInternal(
        address _reserve,
        uint256 _liquidityAdded,
        uint256 _liquidityTaken
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        (uint256 newLiquidityRate, uint256 newStableRate, uint256 newVariableRate) = IReserveInterestRateStrategy(
            reserve
            .interestRateStrategyAddress
        )
        .calculateInterestRates(
            _reserve,
            getReserveAvailableLiquidity(_reserve).add(_liquidityAdded).sub(_liquidityTaken),
            reserve.totalBorrowsStable,
            reserve.totalBorrowsVariable,
            reserve.currentAverageStableBorrowRate
        );

        reserve.currentLiquidityRate = newLiquidityRate;
        reserve.currentStableBorrowRate = newStableRate;
        reserve.currentVariableBorrowRate = newVariableRate;

        //solium-disable-next-line
        reserve.lastUpdateTimestamp = uint40(block.timestamp);

        emit ReserveUpdated(
            _reserve,
            newLiquidityRate,
            newStableRate,
            newVariableRate,
            reserve.lastLiquidityCumulativeIndex,
            reserve.lastVariableBorrowCumulativeIndex
        );
    }

    /**
    * @dev transfers to the protocol fees of a flashloan to the fees collection address
    * @param _token the address of the token being transferred
    * @param _amount the amount being transferred
    **/

    function transferFlashLoanProtocolFeeInternal(address _token, uint256 _amount) internal {
        address payable receiver = address(uint160(addressesProvider.getTokenDistributor()));

        if (_token != EthAddressLib.ethAddress()) {
            ERC20(_token).safeTransfer(receiver, _amount);
        } else {
            receiver.transfer(_amount);
        }
    }

    /**
    * @dev updates the internal configuration of the core
    **/
    function refreshConfigInternal() internal {
        lendingPoolAddress = addressesProvider.getLendingPool();
    }

    /**
    * @dev adds a reserve to the array of the reserves address
    **/
    function addReserveToListInternal(address _reserve) internal {
        bool reserveAlreadyAdded = false;
        for (uint256 i = 0; i < reservesList.length; i++)
            if (reservesList[i] == _reserve) {
                reserveAlreadyAdded = true;
            }
        if (!reserveAlreadyAdded) reservesList.push(_reserve);
    }

}
.]

###

[2024-01-09 04:31:45 INFO] **[Seminar Conclusion]**:

 ###

[2024-01-09 04:31:45 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 2

[2024-01-09 04:31:45 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | pragma solidity ^0.5.0; import "openzeppelin-solidity/contracts/math/SafeMath.sol"; import "openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol"; import "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol"; import "openzeppelin-solidity/contracts/utils/Address.sol"; import "../libraries/openzeppelin-upgradeability/VersionedInitializable.sol"; import "../libraries/CoreLibrary.sol"; import "../configuration/LendingPoolAddressesProvider.sol"; import "../interfaces/ILendingRateOracle.sol"; import "../interfaces/IReserveInterestRateStrategy.sol"; import "../libraries/WadRayMath.sol"; import "../tokenization/AToken.sol"; import "../libraries/EthAddressLib.sol"; / * @title LendingPoolCore contract * @author Aave * @notice Holds the state of the lending pool and all the funds deposited * @dev NOTE: The core does not enforce security checks on the update of the state * (eg, updateStateOnBorrow() does not enforce that borrowed is enabled on the reserve). * The check that an action can be performed is a duty of the overlying LendingPool contract. / contract LendingPoolCore is VersionedInitializable {     using SafeMath for uint256;     using WadRayMath for uint256;     using CoreLibrary for CoreLibrary.ReserveData;     using CoreLibrary for CoreLibrary.UserReserveData;     using SafeERC20 for ERC20;     using Address for address payable; /** * @dev Emitted when the state of a reserve is updated * @param reserve the address of the reserve * @param liquidityRate the new liquidity rate * @param stableBorrowRate the new stable borrow rate * @param variableBorrowRate the new variable borrow rate * @param liquidityIndex the new liquidity index * @param variableBorrowIndex the new variable borrow index **/ event ReserveUpdated(     address indexed reserve,     uint256 liquidityRate,     uint256 stableBorrowRate,     uint256 variableBorrowRate,     uint256 liquidityIndex,     uint256 variableBorrowIndex );  address public lendingPoolAddress;  LendingPoolAddressesProvider public addressesProvider;  /** * @dev only lending pools can use functions affected by this modifier **/ modifier onlyLendingPool {     require(lendingPoolAddress == msg.sender, "The caller must be a lending pool contract");     _; }  /** * @dev only lending pools configurator can use functions affected by this modifier **/ modifier onlyLendingPoolConfigurator {     require(         addressesProvider.getLendingPoolConfigurator() == msg.sender,         "The caller must be a lending pool configurator contract"     );     _; }  mapping(address =&gt; CoreLibrary.ReserveData) internal reserves; mapping(address =&gt; mapping(address =&gt; CoreLibrary.UserReserveData)) internal usersReserveData;  address[] public reservesList;  uint256 public constant CORE_REVISION = 0x4;  /** * @dev returns the revision number of the contract **/ function getRevision() internal pure returns (uint256) {     return CORE_REVISION; }  /** * @dev initializes the Core contract, invoked upon registration on the AddressesProvider * @param _addressesProvider the addressesProvider contract **/  function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {     addressesProvider = _addressesProvider;     refreshConfigInternal(); }  /** * @dev updates the state of the core as a result of a deposit action * @param _reserve the address of the reserve in which the deposit is happening * @param _user the address of the the user depositing * @param _amount the amount being deposited * @param _isFirstDeposit true if the user is depositing for the first time **/  function updateStateOnDeposit(     address _reserve,     address _user,     uint256 _amount,     bool _isFirstDeposit ) external onlyLendingPool {     reserves[_reserve].updateCumulativeIndexes();     updateReserveInterestRatesAndTimestampInternal(_reserve, _amount, 0);      if (_isFirstDeposit) {         //if this is the first deposit of the user, we configure the deposit as enabled to be used as collateral         setUserUseReserveAsCollateral(_reserve, _user, true);     } }  /** * @dev updates the state of the core as a result of a redeem action * @param _reserve the address of the reserve in which the redeem is happening * @param _user the address of the the user redeeming * @param _amountRedeemed the amount being redeemed * @param _userRedeemedEverything true if the user is redeeming everything **/ function updateStateOnRedeem(     address _reserve,     address _user,     uint256 _amountRedeemed,     bool _userRedeemedEverything ) external onlyLendingPool {     //compound liquidity and variable borrow interests     reserves[_reserve].updateCumulativeIndexes();     updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountRedeemed);      //if user redeemed everything the useReserveAsCollateral flag is reset     if (_userRedeemedEverything) {         setUserUseReserveAsCollateral(_reserve, _user, false);     } }  /** * @dev updates the state of the core as a result of a flashloan action * @param _reserve the address of the reserve in which the flashloan is happening * @param _income the income of the protocol as a result of the action **/ function updateStateOnFlashLoan(     address _reserve,     uint256 _availableLiquidityBefore,     uint256 _income,     uint256 _protocolFee ) external onlyLendingPool {     transferFlashLoanProtocolFeeInternal(_reserve, _protocolFee);      //compounding the cumulated interest     reserves[_reserve].updateCumulativeIndexes();      uint256 totalLiquidityBefore = _availableLiquidityBefore.add(         getReserveTotalBorrows(_reserve)     );      //compounding the received fee into the reserve     reserves[_reserve].cumulateToLiquidityIndex(totalLiquidityBefore, _income);      //refresh interest rates     updateReserveInterestRatesAndTimestampInternal(_reserve, _income, 0); }  /** * @dev updates the state of the core as a consequence of a borrow action. * @param _reserve the address of the reserve on which the user is borrowing * @param _user the address of the borrower * @param _amountBorrowed the new amount borrowed * @param _borrowFee the fee on the amount borrowed * @param _rateMode the borrow rate mode (stable, variable) * @return the new borrow rate for the user **/ function updateStateOnBorrow(     address _reserve,     address _user,     uint256 _amountBorrowed,     uint256 _borrowFee,     CoreLibrary.InterestRateMode _rateMode ) external onlyLendingPool returns (uint256, uint256) {     // getting the previous borrow data of the user     (uint256 principalBorrowBalance, , uint256 balanceIncrease) = getUserBorrowBalances(         _reserve,         _user     );      updateReserveStateOnBorrowInternal(         _reserve,         _user,         principalBorrowBalance,         balanceIncrease,         _amountBorrowed,         _rateMode     );      updateUserStateOnBorrowInternal(         _reserve,         _user,         _amountBorrowed,         balanceIncrease,         _borrowFee,         _rateMode     );      updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountBorrowed);      return (getUserCurrentBorrowRate(_reserve, _user), balanceIncrease); }  /** * @dev updates the state of the core as a consequence of a repay action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _paybackAmountMinusFees the amount being paid back minus fees * @param _originationFeeRepaid the fee on the amount that is being repaid * @param _balanceIncrease the accrued interest on the borrowed amount * @param _repaidWholeLoan true if the user is repaying the whole loan **/  function updateStateOnRepay(     address _reserve,     address _user,     uint256 _paybackAmountMinusFees,     uint256 _originationFeeRepaid,     uint256 _balanceIncrease,     bool _repaidWholeLoan ) external onlyLendingPool {     updateReserveStateOnRepayInternal(         _reserve,         _user,         _paybackAmountMinusFees,         _balanceIncrease     );     updateUserStateOnRepayInternal(         _reserve,         _user,         _paybackAmountMinusFees,         _originationFeeRepaid,         _balanceIncrease,         _repaidWholeLoan     );      updateReserveInterestRatesAndTimestampInternal(_reserve, _paybackAmountMinusFees, 0); }  /** * @dev updates the state of the core as a consequence of a swap rate action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _principalBorrowBalance the amount borrowed by the user * @param _compoundedBorrowBalance the amount borrowed plus accrued interest * @param _balanceIncrease the accrued interest on the borrowed amount * @param _currentRateMode the current interest rate mode for the user **/ function updateStateOnSwapRate(     address _reserve,     address _user,     uint256 _principalBorrowBalance,     uint256 _compoundedBorrowBalance,     uint256 _balanceIncrease,     CoreLibrary.InterestRateMode _currentRateMode ) external onlyLendingPool returns (CoreLibrary.InterestRateMode, uint256) {     updateReserveStateOnSwapRateInternal(         _reserve,         _user,         _principalBorrowBalance,         _compoundedBorrowBalance,         _currentRateMode     );      CoreLibrary.InterestRateMode newRateMode = updateUserStateOnSwapRateInternal(         _reserve,         _user,         _balanceIncrease,         _currentRateMode     );      updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);      return (newRateMode, getUserCurrentBorrowRate(_reserve, _user)); }  /** * @dev updates the state of the core as a consequence of a liquidation action. * @param _principalReserve the address of the principal reserve that is being repaid * @param _collateralReserve the address of the collateral reserve that is being liquidated * @param _user the address of the borrower * @param _amountToLiquidate the amount being repaid by the liquidator * @param _collateralToLiquidate the amount of collateral being liquidated * @param _feeLiquidated the amount of origination fee being liquidated * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus * @param _balanceIncrease the accrued interest on the borrowed amount * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise **/ function updateStateOnLiquidation(     address _principalReserve,     address _collateralReserve,     address _user,     uint256 _amountToLiquidate,     uint256 _collateralToLiquidate,     uint256 _feeLiquidated,     uint256 _liquidatedCollateralForFee,     uint256 _balanceIncrease,     bool _liquidatorReceivesAToken ) external onlyLendingPool {     updatePrincipalReserveStateOnLiquidationInternal(         _principalReserve,         _user,         _amountToLiquidate,         _balanceIncrease     );      updateCollateralReserveStateOnLiquidationInternal(         _collateralReserve     );      updateUserStateOnLiquidationInternal(         _principalReserve,         _user,         _amountToLiquidate,         _feeLiquidated,         _balanceIncrease     );      updateReserveInterestRatesAndTimestampInternal(_principalReserve, _amountToLiquidate, 0);      if (!_liquidatorReceivesAToken) {         updateReserveInterestRatesAndTimestampInternal(             _collateralReserve,             0,             _collateralToLiquidate.add(_liquidatedCollateralForFee)         );     }  }  /** * @dev updates the state of the core as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount * @return the new stable rate for the user **/ function updateStateOnRebalance(address _reserve, address _user, uint256 _balanceIncrease) external onlyLendingPool returns (uint256) {     updateReserveStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);      //update user data and rebalance the rate     updateUserStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);     updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);     return usersReserveData[_user][_reserve].stableBorrowRate; }  /** * @dev enables or disables a reserve as collateral * @param _reserve the address of the principal reserve where the user deposited * @param _user the address of the depositor * @param _useAsCollateral true if the depositor wants to use the reserve as collateral **/ function setUserUseReserveAsCollateral(address _reserve, address _user, bool _useAsCollateral) public onlyLendingPool {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     user.useAsCollateral = _useAsCollateral; }  /** * @notice ETH/token transfer functions **/  /** * @dev fallback function enforces that the caller is a contract, to support flashloan transfers **/ function() external payable {     //only contracts can send ETH to the core     require(msg.sender.isContract(), "Only contracts can send ether to the Lending pool core");  }  /** * @dev transfers to the user a specific amount from the reserve. * @param _reserve the address of the reserve where the transfer is happening * @param _user the address of the user receiving the transfer * @param _amount the amount being transferred **/ function transferToUser(address _reserve, address payable _user, uint256 _amount) external onlyLendingPool {     if (_reserve != EthAddressLib.ethAddress()) {         ERC20(_reserve).safeTransfer(_user, _amount);     } else {         //solium-disable-next-line         (bool result, ) = _user.call.value(_amount).gas(50000)("");         require(result, "Transfer of ETH failed");     } }  /** * @dev transfers the protocol fees to the fees collection address * @param _token the address of the token being transferred * @param _user the address of the user from where the transfer is happening * @param _amount the amount being transferred * @param _destination the fee receiver address **/  function transferToFeeCollectionAddress(     address _token,     address _user,     uint256 _amount,     address _destination ) external payable onlyLendingPool {     address payable feeAddress = address(uint160(_destination)); //cast the address to payable      if (_token != EthAddressLib.ethAddress()) {         require(             msg.value == 0,             "User is sending ETH along with the ERC20 transfer. Check the value attribute of the transaction"         );         ERC20(_token).safeTransferFrom(_user, feeAddress, _amount);     } else {         require(msg.value &gt;= _amount, "The amount and the value sent to deposit do not match");         //solium-disable-next-line         (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");         require(result, "Transfer of ETH failed");     } }  /** * @dev transfers the fees to the fees collection address in the case of liquidation * @param _token the address of the token being transferred * @param _amount the amount being transferred * @param _destination the fee receiver address **/ function liquidateFee(     address _token,     uint256 _amount,     address _destination ) external payable onlyLendingPool {     address payable feeAddress = address(uint160(_destination)); //cast the address to payable     require(         msg.value == 0,         "Fee liquidation does not require any transfer of value"     );      if (_token != EthAddressLib.ethAddress()) {         ERC20(_token).safeTransfer(feeAddress, _amount);     } else {         //solium-disable-next-line         (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");         require(result, "Transfer of ETH failed");     } }  /** * @dev transfers an amount from a user to the destination reserve * @param _reserve the address of the reserve where the amount is being transferred * @param _user the address of the user from where the transfer is happening * @param _amount the amount being transferred **/ function transferToReserve(address _reserve, address payable _user, uint256 _amount) external payable onlyLendingPool {     if (_reserve != EthAddressLib.ethAddress()) {         require(msg.value == 0, "User is sending ETH along with the ERC20 transfer.");         ERC20(_reserve).safeTransferFrom(_user, address(this), _amount);      } else {         require(msg.value &gt;= _amount, "The amount and the value sent to deposit do not match");          if (msg.value &gt; _amount) {             //send back excess ETH             uint256 excessAmount = msg.value.sub(_amount);             //solium-disable-next-line             (bool result, ) = _user.call.value(excessAmount).gas(50000)("");             require(result, "Transfer of ETH failed");         }     } }  /** * @notice data access functions **/  /** * @dev returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral) * needed to calculate the global account data in the LendingPoolDataProvider * @param _reserve the address of the reserve * @param _user the address of the user * @return the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not **/ function getUserBasicReserveData(address _reserve, address _user) external view returns (uint256, uint256, uint256, bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      uint256 underlyingBalance = getUserUnderlyingAssetBalance(_reserve, _user);      if (user.principalBorrowBalance == 0) {         return (underlyingBalance, 0, 0, user.useAsCollateral);     }      return (     underlyingBalance,     user.getCompoundedBorrowBalance(reserve),     user.originationFee,     user.useAsCollateral     ); }  /** * @dev checks if a user is allowed to borrow at a stable rate * @param _reserve the reserve address * @param _user the user * @param _amount the amount the the user wants to borrow * @return true if the user is allowed to borrow at a stable rate, false otherwise **/  function isUserAllowedToBorrowAtStable(address _reserve, address _user, uint256 _amount) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      if (!reserve.isStableBorrowRateEnabled) return false;      return     !user.useAsCollateral ||     !reserve.usageAsCollateralEnabled ||     _amount &gt; getUserUnderlyingAssetBalance(_reserve, _user); }  /** * @dev gets the underlying asset balance of a user based on the corresponding aToken balance. * @param _reserve the reserve address * @param _user the user address * @return the underlying deposit balance of the user **/  function getUserUnderlyingAssetBalance(address _reserve, address _user) public view returns (uint256) {     AToken aToken = AToken(reserves[_reserve].aTokenAddress);     return aToken.balanceOf(_user);  }  /** * @dev gets the interest rate strategy contract address for the reserve * @param _reserve the reserve address * @return the address of the interest rate strategy contract **/ function getReserveInterestRateStrategyAddress(address _reserve) public view returns (address) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.interestRateStrategyAddress; }  /** * @dev gets the aToken contract address for the reserve * @param _reserve the reserve address * @return the address of the aToken contract **/  function getReserveATokenAddress(address _reserve) public view returns (address) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.aTokenAddress; }  /** * @dev gets the available liquidity in the reserve. The available liquidity is the balance of the core contract * @param _reserve the reserve address * @return the available liquidity **/ function getReserveAvailableLiquidity(address _reserve) public view returns (uint256) {     uint256 balance = 0;      if (_reserve == EthAddressLib.ethAddress()) {         balance = address(this).balance;     } else {         balance = IERC20(_reserve).balanceOf(address(this));     }     return balance; }  /** * @dev gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows * @param _reserve the reserve address * @return the total liquidity **/ function getReserveTotalLiquidity(address _reserve) public view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return getReserveAvailableLiquidity(_reserve).add(reserve.getTotalBorrows()); }  /** * @dev gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there * there has been 100% income. * @param _reserve the reserve address * @return the reserve normalized income **/ function getReserveNormalizedIncome(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.getNormalizedIncome(); }  /** * @dev gets the reserve total borrows * @param _reserve the reserve address * @return the total borrows (stable + variable) **/ function getReserveTotalBorrows(address _reserve) public view returns (uint256) {     return reserves[_reserve].getTotalBorrows(); }  /** * @dev gets the reserve total borrows stable * @param _reserve the reserve address * @return the total borrows stable **/ function getReserveTotalBorrowsStable(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.totalBorrowsStable; }  /** * @dev gets the reserve total borrows variable * @param _reserve the reserve address * @return the total borrows variable **/  function getReserveTotalBorrowsVariable(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.totalBorrowsVariable; }  /** * @dev gets the reserve liquidation threshold * @param _reserve the reserve address * @return the reserve liquidation threshold **/  function getReserveLiquidationThreshold(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.liquidationThreshold; }  /** * @dev gets the reserve liquidation bonus * @param _reserve the reserve address * @return the reserve liquidation bonus **/  function getReserveLiquidationBonus(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.liquidationBonus; }  /** * @dev gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty * @param _reserve the reserve address * @return the reserve current variable borrow rate **/  function getReserveCurrentVariableBorrowRate(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      if (reserve.currentVariableBorrowRate == 0) {         return         IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)         .getBaseVariableBorrowRate();     }     return reserve.currentVariableBorrowRate; }  /** * @dev gets the reserve current stable borrow rate. Is the market rate if the reserve is empty * @param _reserve the reserve address * @return the reserve current stable borrow rate **/  function getReserveCurrentStableBorrowRate(address _reserve) public view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     ILendingRateOracle oracle = ILendingRateOracle(addressesProvider.getLendingRateOracle());      if (reserve.currentStableBorrowRate == 0) {         //no stable rate borrows yet         return oracle.getMarketBorrowRate(_reserve);     }      return reserve.currentStableBorrowRate; }  /** * @dev gets the reserve average stable borrow rate. The average stable rate is the weighted average * of all the loans taken at stable rate. * @param _reserve the reserve address * @return the reserve current average borrow rate **/ function getReserveCurrentAverageStableBorrowRate(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.currentAverageStableBorrowRate; }  /** * @dev gets the reserve liquidity rate * @param _reserve the reserve address * @return the reserve liquidity rate **/ function getReserveCurrentLiquidityRate(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.currentLiquidityRate; }  /** * @dev gets the reserve liquidity cumulative index * @param _reserve the reserve address * @return the reserve liquidity cumulative index **/ function getReserveLiquidityCumulativeIndex(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.lastLiquidityCumulativeIndex; }  /** * @dev gets the reserve variable borrow index * @param _reserve the reserve address * @return the reserve variable borrow index **/ function getReserveVariableBorrowsCumulativeIndex(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.lastVariableBorrowCumulativeIndex; }  /** * @dev this function aggregates the configuration parameters of the reserve. * It's used in the LendingPoolDataProvider specifically to save gas, and avoid * multiple external contract calls to fetch the same data. * @param _reserve the reserve address * @return the reserve decimals * @return the base ltv as collateral * @return the liquidation threshold * @return if the reserve is used as collateral or not **/ function getReserveConfiguration(address _reserve) external view returns (uint256, uint256, uint256, bool) {     uint256 decimals;     uint256 baseLTVasCollateral;     uint256 liquidationThreshold;     bool usageAsCollateralEnabled;      CoreLibrary.ReserveData storage reserve = reserves[_reserve];     decimals = reserve.decimals;     baseLTVasCollateral = reserve.baseLTVasCollateral;     liquidationThreshold = reserve.liquidationThreshold;     usageAsCollateralEnabled = reserve.usageAsCollateralEnabled;      return (decimals, baseLTVasCollateral, liquidationThreshold, usageAsCollateralEnabled); }  /** * @dev returns the decimals of the reserve * @param _reserve the reserve address * @return the reserve decimals **/ function getReserveDecimals(address _reserve) external view returns (uint256) {     return reserves[_reserve].decimals; }  /** * @dev returns true if the reserve is enabled for borrowing * @param _reserve the reserve address * @return true if the reserve is enabled for borrowing, false otherwise **/  function isReserveBorrowingEnabled(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.borrowingEnabled; }  /** * @dev returns true if the reserve is enabled as collateral * @param _reserve the reserve address * @return true if the reserve is enabled as collateral, false otherwise **/  function isReserveUsageAsCollateralEnabled(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.usageAsCollateralEnabled; }  /** * @dev returns true if the stable rate is enabled on reserve * @param _reserve the reserve address * @return true if the stable rate is enabled on reserve, false otherwise **/ function getReserveIsStableBorrowRateEnabled(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.isStableBorrowRateEnabled; }  /** * @dev returns true if the reserve is active * @param _reserve the reserve address * @return true if the reserve is active, false otherwise **/ function getReserveIsActive(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.isActive; }  /** * @notice returns if a reserve is freezed * @param _reserve the reserve for which the information is needed * @return true if the reserve is freezed, false otherwise **/  function getReserveIsFreezed(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.isFreezed; }  /** * @notice returns the timestamp of the last action on the reserve * @param _reserve the reserve for which the information is needed * @return the last updated timestamp of the reserve **/  function getReserveLastUpdate(address _reserve) external view returns (uint40 timestamp) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     timestamp = reserve.lastUpdateTimestamp; }  /** * @dev returns the utilization rate U of a specific reserve * @param _reserve the reserve for which the information is needed * @return the utilization rate in ray **/  function getReserveUtilizationRate(address _reserve) public view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      uint256 totalBorrows = reserve.getTotalBorrows();      if (totalBorrows == 0) {         return 0;     }      uint256 availableLiquidity = getReserveAvailableLiquidity(_reserve);      return totalBorrows.rayDiv(availableLiquidity.add(totalBorrows)); }  /** * @return the array of reserves configured on the core **/ function getReserves() external view returns (address[] memory) {     return reservesList; }  /** * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return true if the user has chosen to use the reserve as collateral, false otherwise **/ function isUserUseReserveAsCollateralEnabled(address _reserve, address _user) external view returns (bool) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.useAsCollateral; }  /** * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the origination fee for the user **/ function getUserOriginationFee(address _reserve, address _user) external view returns (uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.originationFee; }  /** * @dev users with no loans in progress have NONE as borrow rate mode * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the borrow rate mode for the user, **/  function getUserCurrentBorrowRateMode(address _reserve, address _user) public view returns (CoreLibrary.InterestRateMode) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      if (user.principalBorrowBalance == 0) {         return CoreLibrary.InterestRateMode.NONE;     }      return     user.stableBorrowRate &gt; 0     ? CoreLibrary.InterestRateMode.STABLE     : CoreLibrary.InterestRateMode.VARIABLE; }  /** * @dev gets the current borrow rate of the user * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the borrow rate for the user, **/ function getUserCurrentBorrowRate(address _reserve, address _user) internal view returns (uint256) {     CoreLibrary.InterestRateMode rateMode = getUserCurrentBorrowRateMode(_reserve, _user);      if (rateMode == CoreLibrary.InterestRateMode.NONE) {         return 0;     }      return     rateMode == CoreLibrary.InterestRateMode.STABLE     ? usersReserveData[_user][_reserve].stableBorrowRate     : reserves[_reserve].currentVariableBorrowRate; }  /** * @dev the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the user stable rate **/ function getUserCurrentStableBorrowRate(address _reserve, address _user) external view returns (uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.stableBorrowRate; }  /** * @dev calculates and returns the borrow balances of the user * @param _reserve the address of the reserve * @param _user the address of the user * @return the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance **/  function getUserBorrowBalances(address _reserve, address _user) public view returns (uint256, uint256, uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     if (user.principalBorrowBalance == 0) {         return (0, 0, 0);     }      uint256 principal = user.principalBorrowBalance;     uint256 compoundedBalance = CoreLibrary.getCompoundedBorrowBalance(         user,         reserves[_reserve]     );     return (principal, compoundedBalance, compoundedBalance.sub(principal)); }  /** * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the variable borrow index for the user **/  function getUserVariableBorrowCumulativeIndex(address _reserve, address _user) external view returns (uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.lastVariableBorrowCumulativeIndex; }  /** * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the variable borrow index for the user **/  function getUserLastUpdate(address _reserve, address _user) external view returns (uint256 timestamp) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     timestamp = user.lastUpdateTimestamp; }  /** * @dev updates the lending pool core configuration **/ function refreshConfiguration() external onlyLendingPoolConfigurator {     refreshConfigInternal(); }  /** * @dev initializes a reserve * @param _reserve the address of the reserve * @param _aTokenAddress the address of the overlying aToken contract * @param _decimals the decimals of the reserve currency * @param _interestRateStrategyAddress the address of the interest rate strategy contract **/ function initReserve(     address _reserve,     address _aTokenAddress,     uint256 _decimals,     address _interestRateStrategyAddress ) external onlyLendingPoolConfigurator {     reserves[_reserve].init(_aTokenAddress, _decimals, _interestRateStrategyAddress);     addReserveToListInternal(_reserve);  }    /** * @dev removes the last added reserve in the reservesList array * @param _reserveToRemove the address of the reserve **/ function removeLastAddedReserve(address _reserveToRemove) external onlyLendingPoolConfigurator {      address lastReserve = reservesList[reservesList.length-1];      require(lastReserve == _reserveToRemove, "Reserve being removed is different than the reserve requested");      //as we can't check if totalLiquidity is 0 (since the reserve added might not be an ERC20) we at least check that there is nothing borrowed     require(getReserveTotalBorrows(lastReserve) == 0, "Cannot remove a reserve with liquidity deposited");      reserves[lastReserve].isActive = false;     reserves[lastReserve].aTokenAddress = address(0);     reserves[lastReserve].decimals = 0;     reserves[lastReserve].lastLiquidityCumulativeIndex = 0;     reserves[lastReserve].lastVariableBorrowCumulativeIndex = 0;     reserves[lastReserve].borrowingEnabled = false;     reserves[lastReserve].usageAsCollateralEnabled = false;     reserves[lastReserve].baseLTVasCollateral = 0;     reserves[lastReserve].liquidationThreshold = 0;     reserves[lastReserve].liquidationBonus = 0;     reserves[lastReserve].interestRateStrategyAddress = address(0);      reservesList.pop(); }  /** * @dev updates the address of the interest rate strategy contract * @param _reserve the address of the reserve * @param _rateStrategyAddress the address of the interest rate strategy contract **/  function setReserveInterestRateStrategyAddress(address _reserve, address _rateStrategyAddress) external onlyLendingPoolConfigurator {     reserves[_reserve].interestRateStrategyAddress = _rateStrategyAddress; }  /** * @dev enables borrowing on a reserve. Also sets the stable rate borrowing * @param _reserve the address of the reserve * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise **/  function enableBorrowingOnReserve(address _reserve, bool _stableBorrowRateEnabled) external onlyLendingPoolConfigurator {     reserves[_reserve].enableBorrowing(_stableBorrowRateEnabled); }  /** * @dev disables borrowing on a reserve * @param _reserve the address of the reserve **/  function disableBorrowingOnReserve(address _reserve) external onlyLendingPoolConfigurator {     reserves[_reserve].disableBorrowing(); }  /** * @dev enables a reserve to be used as collateral * @param _reserve the address of the reserve **/ function enableReserveAsCollateral(     address _reserve,     uint256 _baseLTVasCollateral,     uint256 _liquidationThreshold,     uint256 _liquidationBonus ) external onlyLendingPoolConfigurator {     reserves[_reserve].enableAsCollateral(         _baseLTVasCollateral,         _liquidationThreshold,         _liquidationBonus     ); }  /** * @dev disables a reserve to be used as collateral * @param _reserve the address of the reserve **/ function disableReserveAsCollateral(address _reserve) external onlyLendingPoolConfigurator {     reserves[_reserve].disableAsCollateral(); }  /** * @dev enable the stable borrow rate mode on a reserve * @param _reserve the address of the reserve **/ function enableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isStableBorrowRateEnabled = true; }  /** * @dev disable the stable borrow rate mode on a reserve * @param _reserve the address of the reserve **/ function disableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isStableBorrowRateEnabled = false; }  /** * @dev activates a reserve * @param _reserve the address of the reserve **/ function activateReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      require(         reserve.lastLiquidityCumulativeIndex &gt; 0 &amp;&amp;         reserve.lastVariableBorrowCumulativeIndex &gt; 0,         "Reserve has not been initialized yet"     );     reserve.isActive = true; }  /** * @dev deactivates a reserve * @param _reserve the address of the reserve **/ function deactivateReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isActive = false; }  /** * @notice allows the configurator to freeze the reserve. * A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance. * @param _reserve the address of the reserve **/ function freezeReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isFreezed = true; }  /** * @notice allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed. * @param _reserve the address of the reserve **/ function unfreezeReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isFreezed = false; }  /** * @notice allows the configurator to update the loan to value of a reserve * @param _reserve the address of the reserve * @param _ltv the new loan to value **/ function setReserveBaseLTVasCollateral(address _reserve, uint256 _ltv) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.baseLTVasCollateral = _ltv; }  /** * @notice allows the configurator to update the liquidation threshold of a reserve * @param _reserve the address of the reserve * @param _threshold the new liquidation threshold **/ function setReserveLiquidationThreshold(address _reserve, uint256 _threshold) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.liquidationThreshold = _threshold; }  /** * @notice allows the configurator to update the liquidation bonus of a reserve * @param _reserve the address of the reserve * @param _bonus the new liquidation bonus **/ function setReserveLiquidationBonus(address _reserve, uint256 _bonus) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.liquidationBonus = _bonus; }  /** * @notice allows the configurator to update the reserve decimals * @param _reserve the address of the reserve * @param _decimals the decimals of the reserve **/ function setReserveDecimals(address _reserve, uint256 _decimals) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.decimals = _decimals; }  /** * @notice internal functions **/  /** * @dev updates the state of a reserve as a consequence of a borrow action. * @param _reserve the address of the reserve on which the user is borrowing * @param _user the address of the borrower * @param _principalBorrowBalance the previous borrow balance of the borrower before the action * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount * @param _amountBorrowed the new amount borrowed * @param _rateMode the borrow rate mode (stable, variable) **/  function updateReserveStateOnBorrowInternal(     address _reserve,     address _user,     uint256 _principalBorrowBalance,     uint256 _balanceIncrease,     uint256 _amountBorrowed,     CoreLibrary.InterestRateMode _rateMode ) internal {     reserves[_reserve].updateCumulativeIndexes();      //increasing reserve total borrows to account for the new borrow balance of the user     //NOTE: Depending on the previous borrow mode, the borrows might need to be switched from variable to stable or vice versa      updateReserveTotalBorrowsByRateModeInternal(         _reserve,         _user,         _principalBorrowBalance,         _balanceIncrease,         _amountBorrowed,         _rateMode     ); }  /** * @dev updates the state of a user as a consequence of a borrow action. * @param _reserve the address of the reserve on which the user is borrowing * @param _user the address of the borrower * @param _amountBorrowed the amount borrowed * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount * @param _rateMode the borrow rate mode (stable, variable) * @return the final borrow rate for the user. Emitted by the borrow() event **/  function updateUserStateOnBorrowInternal(     address _reserve,     address _user,     uint256 _amountBorrowed,     uint256 _balanceIncrease,     uint256 _fee,     CoreLibrary.InterestRateMode _rateMode ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      if (_rateMode == CoreLibrary.InterestRateMode.STABLE) {         //stable         //reset the user variable index, and update the stable rate         user.stableBorrowRate = reserve.currentStableBorrowRate;         user.lastVariableBorrowCumulativeIndex = 0;     } else if (_rateMode == CoreLibrary.InterestRateMode.VARIABLE) {         //variable         //reset the user stable rate, and store the new borrow index         user.stableBorrowRate = 0;         user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;     } else {         revert("Invalid borrow rate mode");     }     //increase the principal borrows and the origination fee     user.principalBorrowBalance = user.principalBorrowBalance.add(_amountBorrowed).add(         _balanceIncrease     );     user.originationFee = user.originationFee.add(_fee);      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp);  }  /** * @dev updates the state of the reserve as a consequence of a repay action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _paybackAmountMinusFees the amount being paid back minus fees * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updateReserveStateOnRepayInternal(     address _reserve,     address _user,     uint256 _paybackAmountMinusFees,     uint256 _balanceIncrease ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_reserve][_user];      CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(_reserve, _user);      //update the indexes     reserves[_reserve].updateCumulativeIndexes();      //compound the cumulated interest to the borrow balance and then subtracting the payback amount     if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             _balanceIncrease,             user.stableBorrowRate         );         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _paybackAmountMinusFees,             user.stableBorrowRate         );     } else {         reserve.increaseTotalBorrowsVariable(_balanceIncrease);         reserve.decreaseTotalBorrowsVariable(_paybackAmountMinusFees);     } }  /** * @dev updates the state of the user as a consequence of a repay action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _paybackAmountMinusFees the amount being paid back minus fees * @param _originationFeeRepaid the fee on the amount that is being repaid * @param _balanceIncrease the accrued interest on the borrowed amount * @param _repaidWholeLoan true if the user is repaying the whole loan **/ function updateUserStateOnRepayInternal(     address _reserve,     address _user,     uint256 _paybackAmountMinusFees,     uint256 _originationFeeRepaid,     uint256 _balanceIncrease,     bool _repaidWholeLoan ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      //update the user principal borrow balance, adding the cumulated interest and then subtracting the payback amount     user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(         _paybackAmountMinusFees     );     user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;      //if the balance decrease is equal to the previous principal (user is repaying the whole loan)     //and the rate mode is stable, we reset the interest rate mode of the user     if (_repaidWholeLoan) {         user.stableBorrowRate = 0;         user.lastVariableBorrowCumulativeIndex = 0;     }     user.originationFee = user.originationFee.sub(_originationFeeRepaid);      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp);  }  /** * @dev updates the state of the user as a consequence of a swap rate action. * @param _reserve the address of the reserve on which the user is performing the rate swap * @param _user the address of the borrower * @param _principalBorrowBalance the the principal amount borrowed by the user * @param _compoundedBorrowBalance the principal amount plus the accrued interest * @param _currentRateMode the rate mode at which the user borrowed **/ function updateReserveStateOnSwapRateInternal(     address _reserve,     address _user,     uint256 _principalBorrowBalance,     uint256 _compoundedBorrowBalance,     CoreLibrary.InterestRateMode _currentRateMode ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      //compounding reserve indexes     reserve.updateCumulativeIndexes();      if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {         uint256 userCurrentStableRate = user.stableBorrowRate;          //swap to variable         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _principalBorrowBalance,             userCurrentStableRate         ); //decreasing stable from old principal balance         reserve.increaseTotalBorrowsVariable(_compoundedBorrowBalance); //increase variable borrows     } else if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         //swap to stable         uint256 currentStableRate = reserve.currentStableBorrowRate;         reserve.decreaseTotalBorrowsVariable(_principalBorrowBalance);         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             _compoundedBorrowBalance,             currentStableRate         );      } else {         revert("Invalid rate mode received");     } }  /** * @dev updates the state of the user as a consequence of a swap rate action. * @param _reserve the address of the reserve on which the user is performing the swap * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount * @param _currentRateMode the current rate mode of the user **/  function updateUserStateOnSwapRateInternal(     address _reserve,     address _user,     uint256 _balanceIncrease,     CoreLibrary.InterestRateMode _currentRateMode ) internal returns (CoreLibrary.InterestRateMode) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      CoreLibrary.InterestRateMode newMode = CoreLibrary.InterestRateMode.NONE;      if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         //switch to stable         newMode = CoreLibrary.InterestRateMode.STABLE;         user.stableBorrowRate = reserve.currentStableBorrowRate;         user.lastVariableBorrowCumulativeIndex = 0;     } else if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {         newMode = CoreLibrary.InterestRateMode.VARIABLE;         user.stableBorrowRate = 0;         user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;     } else {         revert("Invalid interest rate mode received");     }     //compounding cumulated interest     user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);     //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp);      return newMode; }  /** * @dev updates the state of the principal reserve as a consequence of a liquidation action. * @param _principalReserve the address of the principal reserve that is being repaid * @param _user the address of the borrower * @param _amountToLiquidate the amount being repaid by the liquidator * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updatePrincipalReserveStateOnLiquidationInternal(     address _principalReserve,     address _user,     uint256 _amountToLiquidate,     uint256 _balanceIncrease ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_principalReserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_principalReserve];      //update principal reserve data     reserve.updateCumulativeIndexes();      CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(         _principalReserve,         _user     );      if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {         //increase the total borrows by the compounded interest         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             _balanceIncrease,             user.stableBorrowRate         );          //decrease by the actual amount to liquidate         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _amountToLiquidate,             user.stableBorrowRate         );      } else {         //increase the total borrows by the compounded interest         reserve.increaseTotalBorrowsVariable(_balanceIncrease);          //decrease by the actual amount to liquidate         reserve.decreaseTotalBorrowsVariable(_amountToLiquidate);     }  }  /** * @dev updates the state of the collateral reserve as a consequence of a liquidation action. * @param _collateralReserve the address of the collateral reserve that is being liquidated **/ function updateCollateralReserveStateOnLiquidationInternal(     address _collateralReserve ) internal {     //update collateral reserve     reserves[_collateralReserve].updateCumulativeIndexes();  }  /** * @dev updates the state of the user being liquidated as a consequence of a liquidation action. * @param _reserve the address of the principal reserve that is being repaid * @param _user the address of the borrower * @param _amountToLiquidate the amount being repaid by the liquidator * @param _feeLiquidated the amount of origination fee being liquidated * @param _balanceIncrease the accrued interest on the borrowed amount **/ function updateUserStateOnLiquidationInternal(     address _reserve,     address _user,     uint256 _amountToLiquidate,     uint256 _feeLiquidated,     uint256 _balanceIncrease ) internal {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     //first increase by the compounded interest, then decrease by the liquidated amount     user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(         _amountToLiquidate     );      if (         getUserCurrentBorrowRateMode(_reserve, _user) == CoreLibrary.InterestRateMode.VARIABLE     ) {         user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;     }      if(_feeLiquidated &gt; 0){         user.originationFee = user.originationFee.sub(_feeLiquidated);     }      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp); }  /** * @dev updates the state of the reserve as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updateReserveStateOnRebalanceInternal(     address _reserve,     address _user,     uint256 _balanceIncrease ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      reserve.updateCumulativeIndexes();      reserve.increaseTotalBorrowsStableAndUpdateAverageRate(         _balanceIncrease,         user.stableBorrowRate     );  }  /** * @dev updates the state of the user as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updateUserStateOnRebalanceInternal(     address _reserve,     address _user,     uint256 _balanceIncrease ) internal {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);     user.stableBorrowRate = reserve.currentStableBorrowRate;      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp); }  /** * @dev updates the state of the user as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount * @param _amountBorrowed the accrued interest on the borrowed amount **/ function updateReserveTotalBorrowsByRateModeInternal(     address _reserve,     address _user,     uint256 _principalBalance,     uint256 _balanceIncrease,     uint256 _amountBorrowed,     CoreLibrary.InterestRateMode _newBorrowRateMode ) internal {     CoreLibrary.InterestRateMode previousRateMode = getUserCurrentBorrowRateMode(         _reserve,         _user     );     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      if (previousRateMode == CoreLibrary.InterestRateMode.STABLE) {         CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _principalBalance,             user.stableBorrowRate         );     } else if (previousRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         reserve.decreaseTotalBorrowsVariable(_principalBalance);     }      uint256 newPrincipalAmount = _principalBalance.add(_balanceIncrease).add(_amountBorrowed);     if (_newBorrowRateMode == CoreLibrary.InterestRateMode.STABLE) {         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             newPrincipalAmount,             reserve.currentStableBorrowRate         );     } else if (_newBorrowRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         reserve.increaseTotalBorrowsVariable(newPrincipalAmount);     } else {         revert("Invalid new borrow rate mode");     } }  /** * @dev Updates the reserve current stable borrow rate Rf, the current variable borrow rate Rv and the current liquidity rate Rl. * Also updates the lastUpdateTimestamp value. Please refer to the whitepaper for further information. * @param _reserve the address of the reserve to be updated * @param _liquidityAdded the amount of liquidity added to the protocol (deposit or repay) in the previous action * @param _liquidityTaken the amount of liquidity taken from the protocol (redeem or borrow) **/  function updateReserveInterestRatesAndTimestampInternal(     address _reserve,     uint256 _liquidityAdded,     uint256 _liquidityTaken ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     (uint256 newLiquidityRate, uint256 newStableRate, uint256 newVariableRate) = IReserveInterestRateStrategy(         reserve         .interestRateStrategyAddress     )     .calculateInterestRates(         _reserve,         getReserveAvailableLiquidity(_reserve).add(_liquidityAdded).sub(_liquidityTaken),         reserve.totalBorrowsStable,         reserve.totalBorrowsVariable,         reserve.currentAverageStableBorrowRate     );      reserve.currentLiquidityRate = newLiquidityRate;     reserve.currentStableBorrowRate = newStableRate;     reserve.currentVariableBorrowRate = newVariableRate;      //solium-disable-next-line     reserve.lastUpdateTimestamp = uint40(block.timestamp);      emit ReserveUpdated(         _reserve,         newLiquidityRate,         newStableRate,         newVariableRate,         reserve.lastLiquidityCumulativeIndex,         reserve.lastVariableBorrowCumulativeIndex     ); }  /** * @dev transfers to the protocol fees of a flashloan to the fees collection address * @param _token the address of the token being transferred * @param _amount the amount being transferred **/  function transferFlashLoanProtocolFeeInternal(address _token, uint256 _amount) internal {     address payable receiver = address(uint160(addressesProvider.getTokenDistributor()));      if (_token != EthAddressLib.ethAddress()) {         ERC20(_token).safeTransfer(receiver, _amount);     } else {         receiver.transfer(_amount);     } }  /** * @dev updates the internal configuration of the core **/ function refreshConfigInternal() internal {     lendingPoolAddress = addressesProvider.getLendingPool(); }  /** * @dev adds a reserve to the array of the reserves address **/ function addReserveToListInternal(address _reserve) internal {     bool reserveAlreadyAdded = false;     for (uint256 i = 0; i &lt; reservesList.length; i++)         if (reservesList[i] == _reserve) {             reserveAlreadyAdded = true;         }     if (!reserveAlreadyAdded) reservesList.push(_reserve); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 04:31:46 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | pragma solidity ^0.5.0; import "openzeppelin-solidity/contracts/math/SafeMath.sol"; import "openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol"; import "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol"; import "openzeppelin-solidity/contracts/utils/Address.sol"; import "../libraries/openzeppelin-upgradeability/VersionedInitializable.sol"; import "../libraries/CoreLibrary.sol"; import "../configuration/LendingPoolAddressesProvider.sol"; import "../interfaces/ILendingRateOracle.sol"; import "../interfaces/IReserveInterestRateStrategy.sol"; import "../libraries/WadRayMath.sol"; import "../tokenization/AToken.sol"; import "../libraries/EthAddressLib.sol"; / * @title LendingPoolCore contract * @author Aave * @notice Holds the state of the lending pool and all the funds deposited * @dev NOTE: The core does not enforce security checks on the update of the state * (eg, updateStateOnBorrow() does not enforce that borrowed is enabled on the reserve). * The check that an action can be performed is a duty of the overlying LendingPool contract. / contract LendingPoolCore is VersionedInitializable {     using SafeMath for uint256;     using WadRayMath for uint256;     using CoreLibrary for CoreLibrary.ReserveData;     using CoreLibrary for CoreLibrary.UserReserveData;     using SafeERC20 for ERC20;     using Address for address payable; /** * @dev Emitted when the state of a reserve is updated * @param reserve the address of the reserve * @param liquidityRate the new liquidity rate * @param stableBorrowRate the new stable borrow rate * @param variableBorrowRate the new variable borrow rate * @param liquidityIndex the new liquidity index * @param variableBorrowIndex the new variable borrow index **/ event ReserveUpdated(     address indexed reserve,     uint256 liquidityRate,     uint256 stableBorrowRate,     uint256 variableBorrowRate,     uint256 liquidityIndex,     uint256 variableBorrowIndex );  address public lendingPoolAddress;  LendingPoolAddressesProvider public addressesProvider;  /** * @dev only lending pools can use functions affected by this modifier **/ modifier onlyLendingPool {     require(lendingPoolAddress == msg.sender, "The caller must be a lending pool contract");     _; }  /** * @dev only lending pools configurator can use functions affected by this modifier **/ modifier onlyLendingPoolConfigurator {     require(         addressesProvider.getLendingPoolConfigurator() == msg.sender,         "The caller must be a lending pool configurator contract"     );     _; }  mapping(address =&gt; CoreLibrary.ReserveData) internal reserves; mapping(address =&gt; mapping(address =&gt; CoreLibrary.UserReserveData)) internal usersReserveData;  address[] public reservesList;  uint256 public constant CORE_REVISION = 0x4;  /** * @dev returns the revision number of the contract **/ function getRevision() internal pure returns (uint256) {     return CORE_REVISION; }  /** * @dev initializes the Core contract, invoked upon registration on the AddressesProvider * @param _addressesProvider the addressesProvider contract **/  function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {     addressesProvider = _addressesProvider;     refreshConfigInternal(); }  /** * @dev updates the state of the core as a result of a deposit action * @param _reserve the address of the reserve in which the deposit is happening * @param _user the address of the the user depositing * @param _amount the amount being deposited * @param _isFirstDeposit true if the user is depositing for the first time **/  function updateStateOnDeposit(     address _reserve,     address _user,     uint256 _amount,     bool _isFirstDeposit ) external onlyLendingPool {     reserves[_reserve].updateCumulativeIndexes();     updateReserveInterestRatesAndTimestampInternal(_reserve, _amount, 0);      if (_isFirstDeposit) {         //if this is the first deposit of the user, we configure the deposit as enabled to be used as collateral         setUserUseReserveAsCollateral(_reserve, _user, true);     } }  /** * @dev updates the state of the core as a result of a redeem action * @param _reserve the address of the reserve in which the redeem is happening * @param _user the address of the the user redeeming * @param _amountRedeemed the amount being redeemed * @param _userRedeemedEverything true if the user is redeeming everything **/ function updateStateOnRedeem(     address _reserve,     address _user,     uint256 _amountRedeemed,     bool _userRedeemedEverything ) external onlyLendingPool {     //compound liquidity and variable borrow interests     reserves[_reserve].updateCumulativeIndexes();     updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountRedeemed);      //if user redeemed everything the useReserveAsCollateral flag is reset     if (_userRedeemedEverything) {         setUserUseReserveAsCollateral(_reserve, _user, false);     } }  /** * @dev updates the state of the core as a result of a flashloan action * @param _reserve the address of the reserve in which the flashloan is happening * @param _income the income of the protocol as a result of the action **/ function updateStateOnFlashLoan(     address _reserve,     uint256 _availableLiquidityBefore,     uint256 _income,     uint256 _protocolFee ) external onlyLendingPool {     transferFlashLoanProtocolFeeInternal(_reserve, _protocolFee);      //compounding the cumulated interest     reserves[_reserve].updateCumulativeIndexes();      uint256 totalLiquidityBefore = _availableLiquidityBefore.add(         getReserveTotalBorrows(_reserve)     );      //compounding the received fee into the reserve     reserves[_reserve].cumulateToLiquidityIndex(totalLiquidityBefore, _income);      //refresh interest rates     updateReserveInterestRatesAndTimestampInternal(_reserve, _income, 0); }  /** * @dev updates the state of the core as a consequence of a borrow action. * @param _reserve the address of the reserve on which the user is borrowing * @param _user the address of the borrower * @param _amountBorrowed the new amount borrowed * @param _borrowFee the fee on the amount borrowed * @param _rateMode the borrow rate mode (stable, variable) * @return the new borrow rate for the user **/ function updateStateOnBorrow(     address _reserve,     address _user,     uint256 _amountBorrowed,     uint256 _borrowFee,     CoreLibrary.InterestRateMode _rateMode ) external onlyLendingPool returns (uint256, uint256) {     // getting the previous borrow data of the user     (uint256 principalBorrowBalance, , uint256 balanceIncrease) = getUserBorrowBalances(         _reserve,         _user     );      updateReserveStateOnBorrowInternal(         _reserve,         _user,         principalBorrowBalance,         balanceIncrease,         _amountBorrowed,         _rateMode     );      updateUserStateOnBorrowInternal(         _reserve,         _user,         _amountBorrowed,         balanceIncrease,         _borrowFee,         _rateMode     );      updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountBorrowed);      return (getUserCurrentBorrowRate(_reserve, _user), balanceIncrease); }  /** * @dev updates the state of the core as a consequence of a repay action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _paybackAmountMinusFees the amount being paid back minus fees * @param _originationFeeRepaid the fee on the amount that is being repaid * @param _balanceIncrease the accrued interest on the borrowed amount * @param _repaidWholeLoan true if the user is repaying the whole loan **/  function updateStateOnRepay(     address _reserve,     address _user,     uint256 _paybackAmountMinusFees,     uint256 _originationFeeRepaid,     uint256 _balanceIncrease,     bool _repaidWholeLoan ) external onlyLendingPool {     updateReserveStateOnRepayInternal(         _reserve,         _user,         _paybackAmountMinusFees,         _balanceIncrease     );     updateUserStateOnRepayInternal(         _reserve,         _user,         _paybackAmountMinusFees,         _originationFeeRepaid,         _balanceIncrease,         _repaidWholeLoan     );      updateReserveInterestRatesAndTimestampInternal(_reserve, _paybackAmountMinusFees, 0); }  /** * @dev updates the state of the core as a consequence of a swap rate action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _principalBorrowBalance the amount borrowed by the user * @param _compoundedBorrowBalance the amount borrowed plus accrued interest * @param _balanceIncrease the accrued interest on the borrowed amount * @param _currentRateMode the current interest rate mode for the user **/ function updateStateOnSwapRate(     address _reserve,     address _user,     uint256 _principalBorrowBalance,     uint256 _compoundedBorrowBalance,     uint256 _balanceIncrease,     CoreLibrary.InterestRateMode _currentRateMode ) external onlyLendingPool returns (CoreLibrary.InterestRateMode, uint256) {     updateReserveStateOnSwapRateInternal(         _reserve,         _user,         _principalBorrowBalance,         _compoundedBorrowBalance,         _currentRateMode     );      CoreLibrary.InterestRateMode newRateMode = updateUserStateOnSwapRateInternal(         _reserve,         _user,         _balanceIncrease,         _currentRateMode     );      updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);      return (newRateMode, getUserCurrentBorrowRate(_reserve, _user)); }  /** * @dev updates the state of the core as a consequence of a liquidation action. * @param _principalReserve the address of the principal reserve that is being repaid * @param _collateralReserve the address of the collateral reserve that is being liquidated * @param _user the address of the borrower * @param _amountToLiquidate the amount being repaid by the liquidator * @param _collateralToLiquidate the amount of collateral being liquidated * @param _feeLiquidated the amount of origination fee being liquidated * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus * @param _balanceIncrease the accrued interest on the borrowed amount * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise **/ function updateStateOnLiquidation(     address _principalReserve,     address _collateralReserve,     address _user,     uint256 _amountToLiquidate,     uint256 _collateralToLiquidate,     uint256 _feeLiquidated,     uint256 _liquidatedCollateralForFee,     uint256 _balanceIncrease,     bool _liquidatorReceivesAToken ) external onlyLendingPool {     updatePrincipalReserveStateOnLiquidationInternal(         _principalReserve,         _user,         _amountToLiquidate,         _balanceIncrease     );      updateCollateralReserveStateOnLiquidationInternal(         _collateralReserve     );      updateUserStateOnLiquidationInternal(         _principalReserve,         _user,         _amountToLiquidate,         _feeLiquidated,         _balanceIncrease     );      updateReserveInterestRatesAndTimestampInternal(_principalReserve, _amountToLiquidate, 0);      if (!_liquidatorReceivesAToken) {         updateReserveInterestRatesAndTimestampInternal(             _collateralReserve,             0,             _collateralToLiquidate.add(_liquidatedCollateralForFee)         );     }  }  /** * @dev updates the state of the core as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount * @return the new stable rate for the user **/ function updateStateOnRebalance(address _reserve, address _user, uint256 _balanceIncrease) external onlyLendingPool returns (uint256) {     updateReserveStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);      //update user data and rebalance the rate     updateUserStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);     updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);     return usersReserveData[_user][_reserve].stableBorrowRate; }  /** * @dev enables or disables a reserve as collateral * @param _reserve the address of the principal reserve where the user deposited * @param _user the address of the depositor * @param _useAsCollateral true if the depositor wants to use the reserve as collateral **/ function setUserUseReserveAsCollateral(address _reserve, address _user, bool _useAsCollateral) public onlyLendingPool {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     user.useAsCollateral = _useAsCollateral; }  /** * @notice ETH/token transfer functions **/  /** * @dev fallback function enforces that the caller is a contract, to support flashloan transfers **/ function() external payable {     //only contracts can send ETH to the core     require(msg.sender.isContract(), "Only contracts can send ether to the Lending pool core");  }  /** * @dev transfers to the user a specific amount from the reserve. * @param _reserve the address of the reserve where the transfer is happening * @param _user the address of the user receiving the transfer * @param _amount the amount being transferred **/ function transferToUser(address _reserve, address payable _user, uint256 _amount) external onlyLendingPool {     if (_reserve != EthAddressLib.ethAddress()) {         ERC20(_reserve).safeTransfer(_user, _amount);     } else {         //solium-disable-next-line         (bool result, ) = _user.call.value(_amount).gas(50000)("");         require(result, "Transfer of ETH failed");     } }  /** * @dev transfers the protocol fees to the fees collection address * @param _token the address of the token being transferred * @param _user the address of the user from where the transfer is happening * @param _amount the amount being transferred * @param _destination the fee receiver address **/  function transferToFeeCollectionAddress(     address _token,     address _user,     uint256 _amount,     address _destination ) external payable onlyLendingPool {     address payable feeAddress = address(uint160(_destination)); //cast the address to payable      if (_token != EthAddressLib.ethAddress()) {         require(             msg.value == 0,             "User is sending ETH along with the ERC20 transfer. Check the value attribute of the transaction"         );         ERC20(_token).safeTransferFrom(_user, feeAddress, _amount);     } else {         require(msg.value &gt;= _amount, "The amount and the value sent to deposit do not match");         //solium-disable-next-line         (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");         require(result, "Transfer of ETH failed");     } }  /** * @dev transfers the fees to the fees collection address in the case of liquidation * @param _token the address of the token being transferred * @param _amount the amount being transferred * @param _destination the fee receiver address **/ function liquidateFee(     address _token,     uint256 _amount,     address _destination ) external payable onlyLendingPool {     address payable feeAddress = address(uint160(_destination)); //cast the address to payable     require(         msg.value == 0,         "Fee liquidation does not require any transfer of value"     );      if (_token != EthAddressLib.ethAddress()) {         ERC20(_token).safeTransfer(feeAddress, _amount);     } else {         //solium-disable-next-line         (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");         require(result, "Transfer of ETH failed");     } }  /** * @dev transfers an amount from a user to the destination reserve * @param _reserve the address of the reserve where the amount is being transferred * @param _user the address of the user from where the transfer is happening * @param _amount the amount being transferred **/ function transferToReserve(address _reserve, address payable _user, uint256 _amount) external payable onlyLendingPool {     if (_reserve != EthAddressLib.ethAddress()) {         require(msg.value == 0, "User is sending ETH along with the ERC20 transfer.");         ERC20(_reserve).safeTransferFrom(_user, address(this), _amount);      } else {         require(msg.value &gt;= _amount, "The amount and the value sent to deposit do not match");          if (msg.value &gt; _amount) {             //send back excess ETH             uint256 excessAmount = msg.value.sub(_amount);             //solium-disable-next-line             (bool result, ) = _user.call.value(excessAmount).gas(50000)("");             require(result, "Transfer of ETH failed");         }     } }  /** * @notice data access functions **/  /** * @dev returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral) * needed to calculate the global account data in the LendingPoolDataProvider * @param _reserve the address of the reserve * @param _user the address of the user * @return the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not **/ function getUserBasicReserveData(address _reserve, address _user) external view returns (uint256, uint256, uint256, bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      uint256 underlyingBalance = getUserUnderlyingAssetBalance(_reserve, _user);      if (user.principalBorrowBalance == 0) {         return (underlyingBalance, 0, 0, user.useAsCollateral);     }      return (     underlyingBalance,     user.getCompoundedBorrowBalance(reserve),     user.originationFee,     user.useAsCollateral     ); }  /** * @dev checks if a user is allowed to borrow at a stable rate * @param _reserve the reserve address * @param _user the user * @param _amount the amount the the user wants to borrow * @return true if the user is allowed to borrow at a stable rate, false otherwise **/  function isUserAllowedToBorrowAtStable(address _reserve, address _user, uint256 _amount) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      if (!reserve.isStableBorrowRateEnabled) return false;      return     !user.useAsCollateral ||     !reserve.usageAsCollateralEnabled ||     _amount &gt; getUserUnderlyingAssetBalance(_reserve, _user); }  /** * @dev gets the underlying asset balance of a user based on the corresponding aToken balance. * @param _reserve the reserve address * @param _user the user address * @return the underlying deposit balance of the user **/  function getUserUnderlyingAssetBalance(address _reserve, address _user) public view returns (uint256) {     AToken aToken = AToken(reserves[_reserve].aTokenAddress);     return aToken.balanceOf(_user);  }  /** * @dev gets the interest rate strategy contract address for the reserve * @param _reserve the reserve address * @return the address of the interest rate strategy contract **/ function getReserveInterestRateStrategyAddress(address _reserve) public view returns (address) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.interestRateStrategyAddress; }  /** * @dev gets the aToken contract address for the reserve * @param _reserve the reserve address * @return the address of the aToken contract **/  function getReserveATokenAddress(address _reserve) public view returns (address) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.aTokenAddress; }  /** * @dev gets the available liquidity in the reserve. The available liquidity is the balance of the core contract * @param _reserve the reserve address * @return the available liquidity **/ function getReserveAvailableLiquidity(address _reserve) public view returns (uint256) {     uint256 balance = 0;      if (_reserve == EthAddressLib.ethAddress()) {         balance = address(this).balance;     } else {         balance = IERC20(_reserve).balanceOf(address(this));     }     return balance; }  /** * @dev gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows * @param _reserve the reserve address * @return the total liquidity **/ function getReserveTotalLiquidity(address _reserve) public view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return getReserveAvailableLiquidity(_reserve).add(reserve.getTotalBorrows()); }  /** * @dev gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there * there has been 100% income. * @param _reserve the reserve address * @return the reserve normalized income **/ function getReserveNormalizedIncome(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.getNormalizedIncome(); }  /** * @dev gets the reserve total borrows * @param _reserve the reserve address * @return the total borrows (stable + variable) **/ function getReserveTotalBorrows(address _reserve) public view returns (uint256) {     return reserves[_reserve].getTotalBorrows(); }  /** * @dev gets the reserve total borrows stable * @param _reserve the reserve address * @return the total borrows stable **/ function getReserveTotalBorrowsStable(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.totalBorrowsStable; }  /** * @dev gets the reserve total borrows variable * @param _reserve the reserve address * @return the total borrows variable **/  function getReserveTotalBorrowsVariable(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.totalBorrowsVariable; }  /** * @dev gets the reserve liquidation threshold * @param _reserve the reserve address * @return the reserve liquidation threshold **/  function getReserveLiquidationThreshold(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.liquidationThreshold; }  /** * @dev gets the reserve liquidation bonus * @param _reserve the reserve address * @return the reserve liquidation bonus **/  function getReserveLiquidationBonus(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.liquidationBonus; }  /** * @dev gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty * @param _reserve the reserve address * @return the reserve current variable borrow rate **/  function getReserveCurrentVariableBorrowRate(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      if (reserve.currentVariableBorrowRate == 0) {         return         IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)         .getBaseVariableBorrowRate();     }     return reserve.currentVariableBorrowRate; }  /** * @dev gets the reserve current stable borrow rate. Is the market rate if the reserve is empty * @param _reserve the reserve address * @return the reserve current stable borrow rate **/  function getReserveCurrentStableBorrowRate(address _reserve) public view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     ILendingRateOracle oracle = ILendingRateOracle(addressesProvider.getLendingRateOracle());      if (reserve.currentStableBorrowRate == 0) {         //no stable rate borrows yet         return oracle.getMarketBorrowRate(_reserve);     }      return reserve.currentStableBorrowRate; }  /** * @dev gets the reserve average stable borrow rate. The average stable rate is the weighted average * of all the loans taken at stable rate. * @param _reserve the reserve address * @return the reserve current average borrow rate **/ function getReserveCurrentAverageStableBorrowRate(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.currentAverageStableBorrowRate; }  /** * @dev gets the reserve liquidity rate * @param _reserve the reserve address * @return the reserve liquidity rate **/ function getReserveCurrentLiquidityRate(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.currentLiquidityRate; }  /** * @dev gets the reserve liquidity cumulative index * @param _reserve the reserve address * @return the reserve liquidity cumulative index **/ function getReserveLiquidityCumulativeIndex(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.lastLiquidityCumulativeIndex; }  /** * @dev gets the reserve variable borrow index * @param _reserve the reserve address * @return the reserve variable borrow index **/ function getReserveVariableBorrowsCumulativeIndex(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.lastVariableBorrowCumulativeIndex; }  /** * @dev this function aggregates the configuration parameters of the reserve. * It's used in the LendingPoolDataProvider specifically to save gas, and avoid * multiple external contract calls to fetch the same data. * @param _reserve the reserve address * @return the reserve decimals * @return the base ltv as collateral * @return the liquidation threshold * @return if the reserve is used as collateral or not **/ function getReserveConfiguration(address _reserve) external view returns (uint256, uint256, uint256, bool) {     uint256 decimals;     uint256 baseLTVasCollateral;     uint256 liquidationThreshold;     bool usageAsCollateralEnabled;      CoreLibrary.ReserveData storage reserve = reserves[_reserve];     decimals = reserve.decimals;     baseLTVasCollateral = reserve.baseLTVasCollateral;     liquidationThreshold = reserve.liquidationThreshold;     usageAsCollateralEnabled = reserve.usageAsCollateralEnabled;      return (decimals, baseLTVasCollateral, liquidationThreshold, usageAsCollateralEnabled); }  /** * @dev returns the decimals of the reserve * @param _reserve the reserve address * @return the reserve decimals **/ function getReserveDecimals(address _reserve) external view returns (uint256) {     return reserves[_reserve].decimals; }  /** * @dev returns true if the reserve is enabled for borrowing * @param _reserve the reserve address * @return true if the reserve is enabled for borrowing, false otherwise **/  function isReserveBorrowingEnabled(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.borrowingEnabled; }  /** * @dev returns true if the reserve is enabled as collateral * @param _reserve the reserve address * @return true if the reserve is enabled as collateral, false otherwise **/  function isReserveUsageAsCollateralEnabled(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.usageAsCollateralEnabled; }  /** * @dev returns true if the stable rate is enabled on reserve * @param _reserve the reserve address * @return true if the stable rate is enabled on reserve, false otherwise **/ function getReserveIsStableBorrowRateEnabled(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.isStableBorrowRateEnabled; }  /** * @dev returns true if the reserve is active * @param _reserve the reserve address * @return true if the reserve is active, false otherwise **/ function getReserveIsActive(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.isActive; }  /** * @notice returns if a reserve is freezed * @param _reserve the reserve for which the information is needed * @return true if the reserve is freezed, false otherwise **/  function getReserveIsFreezed(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.isFreezed; }  /** * @notice returns the timestamp of the last action on the reserve * @param _reserve the reserve for which the information is needed * @return the last updated timestamp of the reserve **/  function getReserveLastUpdate(address _reserve) external view returns (uint40 timestamp) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     timestamp = reserve.lastUpdateTimestamp; }  /** * @dev returns the utilization rate U of a specific reserve * @param _reserve the reserve for which the information is needed * @return the utilization rate in ray **/  function getReserveUtilizationRate(address _reserve) public view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      uint256 totalBorrows = reserve.getTotalBorrows();      if (totalBorrows == 0) {         return 0;     }      uint256 availableLiquidity = getReserveAvailableLiquidity(_reserve);      return totalBorrows.rayDiv(availableLiquidity.add(totalBorrows)); }  /** * @return the array of reserves configured on the core **/ function getReserves() external view returns (address[] memory) {     return reservesList; }  /** * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return true if the user has chosen to use the reserve as collateral, false otherwise **/ function isUserUseReserveAsCollateralEnabled(address _reserve, address _user) external view returns (bool) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.useAsCollateral; }  /** * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the origination fee for the user **/ function getUserOriginationFee(address _reserve, address _user) external view returns (uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.originationFee; }  /** * @dev users with no loans in progress have NONE as borrow rate mode * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the borrow rate mode for the user, **/  function getUserCurrentBorrowRateMode(address _reserve, address _user) public view returns (CoreLibrary.InterestRateMode) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      if (user.principalBorrowBalance == 0) {         return CoreLibrary.InterestRateMode.NONE;     }      return     user.stableBorrowRate &gt; 0     ? CoreLibrary.InterestRateMode.STABLE     : CoreLibrary.InterestRateMode.VARIABLE; }  /** * @dev gets the current borrow rate of the user * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the borrow rate for the user, **/ function getUserCurrentBorrowRate(address _reserve, address _user) internal view returns (uint256) {     CoreLibrary.InterestRateMode rateMode = getUserCurrentBorrowRateMode(_reserve, _user);      if (rateMode == CoreLibrary.InterestRateMode.NONE) {         return 0;     }      return     rateMode == CoreLibrary.InterestRateMode.STABLE     ? usersReserveData[_user][_reserve].stableBorrowRate     : reserves[_reserve].currentVariableBorrowRate; }  /** * @dev the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the user stable rate **/ function getUserCurrentStableBorrowRate(address _reserve, address _user) external view returns (uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.stableBorrowRate; }  /** * @dev calculates and returns the borrow balances of the user * @param _reserve the address of the reserve * @param _user the address of the user * @return the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance **/  function getUserBorrowBalances(address _reserve, address _user) public view returns (uint256, uint256, uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     if (user.principalBorrowBalance == 0) {         return (0, 0, 0);     }      uint256 principal = user.principalBorrowBalance;     uint256 compoundedBalance = CoreLibrary.getCompoundedBorrowBalance(         user,         reserves[_reserve]     );     return (principal, compoundedBalance, compoundedBalance.sub(principal)); }  /** * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the variable borrow index for the user **/  function getUserVariableBorrowCumulativeIndex(address _reserve, address _user) external view returns (uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.lastVariableBorrowCumulativeIndex; }  /** * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the variable borrow index for the user **/  function getUserLastUpdate(address _reserve, address _user) external view returns (uint256 timestamp) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     timestamp = user.lastUpdateTimestamp; }  /** * @dev updates the lending pool core configuration **/ function refreshConfiguration() external onlyLendingPoolConfigurator {     refreshConfigInternal(); }  /** * @dev initializes a reserve * @param _reserve the address of the reserve * @param _aTokenAddress the address of the overlying aToken contract * @param _decimals the decimals of the reserve currency * @param _interestRateStrategyAddress the address of the interest rate strategy contract **/ function initReserve(     address _reserve,     address _aTokenAddress,     uint256 _decimals,     address _interestRateStrategyAddress ) external onlyLendingPoolConfigurator {     reserves[_reserve].init(_aTokenAddress, _decimals, _interestRateStrategyAddress);     addReserveToListInternal(_reserve);  }    /** * @dev removes the last added reserve in the reservesList array * @param _reserveToRemove the address of the reserve **/ function removeLastAddedReserve(address _reserveToRemove) external onlyLendingPoolConfigurator {      address lastReserve = reservesList[reservesList.length-1];      require(lastReserve == _reserveToRemove, "Reserve being removed is different than the reserve requested");      //as we can't check if totalLiquidity is 0 (since the reserve added might not be an ERC20) we at least check that there is nothing borrowed     require(getReserveTotalBorrows(lastReserve) == 0, "Cannot remove a reserve with liquidity deposited");      reserves[lastReserve].isActive = false;     reserves[lastReserve].aTokenAddress = address(0);     reserves[lastReserve].decimals = 0;     reserves[lastReserve].lastLiquidityCumulativeIndex = 0;     reserves[lastReserve].lastVariableBorrowCumulativeIndex = 0;     reserves[lastReserve].borrowingEnabled = false;     reserves[lastReserve].usageAsCollateralEnabled = false;     reserves[lastReserve].baseLTVasCollateral = 0;     reserves[lastReserve].liquidationThreshold = 0;     reserves[lastReserve].liquidationBonus = 0;     reserves[lastReserve].interestRateStrategyAddress = address(0);      reservesList.pop(); }  /** * @dev updates the address of the interest rate strategy contract * @param _reserve the address of the reserve * @param _rateStrategyAddress the address of the interest rate strategy contract **/  function setReserveInterestRateStrategyAddress(address _reserve, address _rateStrategyAddress) external onlyLendingPoolConfigurator {     reserves[_reserve].interestRateStrategyAddress = _rateStrategyAddress; }  /** * @dev enables borrowing on a reserve. Also sets the stable rate borrowing * @param _reserve the address of the reserve * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise **/  function enableBorrowingOnReserve(address _reserve, bool _stableBorrowRateEnabled) external onlyLendingPoolConfigurator {     reserves[_reserve].enableBorrowing(_stableBorrowRateEnabled); }  /** * @dev disables borrowing on a reserve * @param _reserve the address of the reserve **/  function disableBorrowingOnReserve(address _reserve) external onlyLendingPoolConfigurator {     reserves[_reserve].disableBorrowing(); }  /** * @dev enables a reserve to be used as collateral * @param _reserve the address of the reserve **/ function enableReserveAsCollateral(     address _reserve,     uint256 _baseLTVasCollateral,     uint256 _liquidationThreshold,     uint256 _liquidationBonus ) external onlyLendingPoolConfigurator {     reserves[_reserve].enableAsCollateral(         _baseLTVasCollateral,         _liquidationThreshold,         _liquidationBonus     ); }  /** * @dev disables a reserve to be used as collateral * @param _reserve the address of the reserve **/ function disableReserveAsCollateral(address _reserve) external onlyLendingPoolConfigurator {     reserves[_reserve].disableAsCollateral(); }  /** * @dev enable the stable borrow rate mode on a reserve * @param _reserve the address of the reserve **/ function enableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isStableBorrowRateEnabled = true; }  /** * @dev disable the stable borrow rate mode on a reserve * @param _reserve the address of the reserve **/ function disableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isStableBorrowRateEnabled = false; }  /** * @dev activates a reserve * @param _reserve the address of the reserve **/ function activateReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      require(         reserve.lastLiquidityCumulativeIndex &gt; 0 &amp;&amp;         reserve.lastVariableBorrowCumulativeIndex &gt; 0,         "Reserve has not been initialized yet"     );     reserve.isActive = true; }  /** * @dev deactivates a reserve * @param _reserve the address of the reserve **/ function deactivateReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isActive = false; }  /** * @notice allows the configurator to freeze the reserve. * A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance. * @param _reserve the address of the reserve **/ function freezeReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isFreezed = true; }  /** * @notice allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed. * @param _reserve the address of the reserve **/ function unfreezeReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isFreezed = false; }  /** * @notice allows the configurator to update the loan to value of a reserve * @param _reserve the address of the reserve * @param _ltv the new loan to value **/ function setReserveBaseLTVasCollateral(address _reserve, uint256 _ltv) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.baseLTVasCollateral = _ltv; }  /** * @notice allows the configurator to update the liquidation threshold of a reserve * @param _reserve the address of the reserve * @param _threshold the new liquidation threshold **/ function setReserveLiquidationThreshold(address _reserve, uint256 _threshold) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.liquidationThreshold = _threshold; }  /** * @notice allows the configurator to update the liquidation bonus of a reserve * @param _reserve the address of the reserve * @param _bonus the new liquidation bonus **/ function setReserveLiquidationBonus(address _reserve, uint256 _bonus) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.liquidationBonus = _bonus; }  /** * @notice allows the configurator to update the reserve decimals * @param _reserve the address of the reserve * @param _decimals the decimals of the reserve **/ function setReserveDecimals(address _reserve, uint256 _decimals) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.decimals = _decimals; }  /** * @notice internal functions **/  /** * @dev updates the state of a reserve as a consequence of a borrow action. * @param _reserve the address of the reserve on which the user is borrowing * @param _user the address of the borrower * @param _principalBorrowBalance the previous borrow balance of the borrower before the action * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount * @param _amountBorrowed the new amount borrowed * @param _rateMode the borrow rate mode (stable, variable) **/  function updateReserveStateOnBorrowInternal(     address _reserve,     address _user,     uint256 _principalBorrowBalance,     uint256 _balanceIncrease,     uint256 _amountBorrowed,     CoreLibrary.InterestRateMode _rateMode ) internal {     reserves[_reserve].updateCumulativeIndexes();      //increasing reserve total borrows to account for the new borrow balance of the user     //NOTE: Depending on the previous borrow mode, the borrows might need to be switched from variable to stable or vice versa      updateReserveTotalBorrowsByRateModeInternal(         _reserve,         _user,         _principalBorrowBalance,         _balanceIncrease,         _amountBorrowed,         _rateMode     ); }  /** * @dev updates the state of a user as a consequence of a borrow action. * @param _reserve the address of the reserve on which the user is borrowing * @param _user the address of the borrower * @param _amountBorrowed the amount borrowed * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount * @param _rateMode the borrow rate mode (stable, variable) * @return the final borrow rate for the user. Emitted by the borrow() event **/  function updateUserStateOnBorrowInternal(     address _reserve,     address _user,     uint256 _amountBorrowed,     uint256 _balanceIncrease,     uint256 _fee,     CoreLibrary.InterestRateMode _rateMode ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      if (_rateMode == CoreLibrary.InterestRateMode.STABLE) {         //stable         //reset the user variable index, and update the stable rate         user.stableBorrowRate = reserve.currentStableBorrowRate;         user.lastVariableBorrowCumulativeIndex = 0;     } else if (_rateMode == CoreLibrary.InterestRateMode.VARIABLE) {         //variable         //reset the user stable rate, and store the new borrow index         user.stableBorrowRate = 0;         user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;     } else {         revert("Invalid borrow rate mode");     }     //increase the principal borrows and the origination fee     user.principalBorrowBalance = user.principalBorrowBalance.add(_amountBorrowed).add(         _balanceIncrease     );     user.originationFee = user.originationFee.add(_fee);      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp);  }  /** * @dev updates the state of the reserve as a consequence of a repay action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _paybackAmountMinusFees the amount being paid back minus fees * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updateReserveStateOnRepayInternal(     address _reserve,     address _user,     uint256 _paybackAmountMinusFees,     uint256 _balanceIncrease ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_reserve][_user];      CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(_reserve, _user);      //update the indexes     reserves[_reserve].updateCumulativeIndexes();      //compound the cumulated interest to the borrow balance and then subtracting the payback amount     if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             _balanceIncrease,             user.stableBorrowRate         );         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _paybackAmountMinusFees,             user.stableBorrowRate         );     } else {         reserve.increaseTotalBorrowsVariable(_balanceIncrease);         reserve.decreaseTotalBorrowsVariable(_paybackAmountMinusFees);     } }  /** * @dev updates the state of the user as a consequence of a repay action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _paybackAmountMinusFees the amount being paid back minus fees * @param _originationFeeRepaid the fee on the amount that is being repaid * @param _balanceIncrease the accrued interest on the borrowed amount * @param _repaidWholeLoan true if the user is repaying the whole loan **/ function updateUserStateOnRepayInternal(     address _reserve,     address _user,     uint256 _paybackAmountMinusFees,     uint256 _originationFeeRepaid,     uint256 _balanceIncrease,     bool _repaidWholeLoan ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      //update the user principal borrow balance, adding the cumulated interest and then subtracting the payback amount     user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(         _paybackAmountMinusFees     );     user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;      //if the balance decrease is equal to the previous principal (user is repaying the whole loan)     //and the rate mode is stable, we reset the interest rate mode of the user     if (_repaidWholeLoan) {         user.stableBorrowRate = 0;         user.lastVariableBorrowCumulativeIndex = 0;     }     user.originationFee = user.originationFee.sub(_originationFeeRepaid);      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp);  }  /** * @dev updates the state of the user as a consequence of a swap rate action. * @param _reserve the address of the reserve on which the user is performing the rate swap * @param _user the address of the borrower * @param _principalBorrowBalance the the principal amount borrowed by the user * @param _compoundedBorrowBalance the principal amount plus the accrued interest * @param _currentRateMode the rate mode at which the user borrowed **/ function updateReserveStateOnSwapRateInternal(     address _reserve,     address _user,     uint256 _principalBorrowBalance,     uint256 _compoundedBorrowBalance,     CoreLibrary.InterestRateMode _currentRateMode ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      //compounding reserve indexes     reserve.updateCumulativeIndexes();      if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {         uint256 userCurrentStableRate = user.stableBorrowRate;          //swap to variable         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _principalBorrowBalance,             userCurrentStableRate         ); //decreasing stable from old principal balance         reserve.increaseTotalBorrowsVariable(_compoundedBorrowBalance); //increase variable borrows     } else if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         //swap to stable         uint256 currentStableRate = reserve.currentStableBorrowRate;         reserve.decreaseTotalBorrowsVariable(_principalBorrowBalance);         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             _compoundedBorrowBalance,             currentStableRate         );      } else {         revert("Invalid rate mode received");     } }  /** * @dev updates the state of the user as a consequence of a swap rate action. * @param _reserve the address of the reserve on which the user is performing the swap * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount * @param _currentRateMode the current rate mode of the user **/  function updateUserStateOnSwapRateInternal(     address _reserve,     address _user,     uint256 _balanceIncrease,     CoreLibrary.InterestRateMode _currentRateMode ) internal returns (CoreLibrary.InterestRateMode) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      CoreLibrary.InterestRateMode newMode = CoreLibrary.InterestRateMode.NONE;      if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         //switch to stable         newMode = CoreLibrary.InterestRateMode.STABLE;         user.stableBorrowRate = reserve.currentStableBorrowRate;         user.lastVariableBorrowCumulativeIndex = 0;     } else if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {         newMode = CoreLibrary.InterestRateMode.VARIABLE;         user.stableBorrowRate = 0;         user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;     } else {         revert("Invalid interest rate mode received");     }     //compounding cumulated interest     user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);     //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp);      return newMode; }  /** * @dev updates the state of the principal reserve as a consequence of a liquidation action. * @param _principalReserve the address of the principal reserve that is being repaid * @param _user the address of the borrower * @param _amountToLiquidate the amount being repaid by the liquidator * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updatePrincipalReserveStateOnLiquidationInternal(     address _principalReserve,     address _user,     uint256 _amountToLiquidate,     uint256 _balanceIncrease ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_principalReserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_principalReserve];      //update principal reserve data     reserve.updateCumulativeIndexes();      CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(         _principalReserve,         _user     );      if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {         //increase the total borrows by the compounded interest         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             _balanceIncrease,             user.stableBorrowRate         );          //decrease by the actual amount to liquidate         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _amountToLiquidate,             user.stableBorrowRate         );      } else {         //increase the total borrows by the compounded interest         reserve.increaseTotalBorrowsVariable(_balanceIncrease);          //decrease by the actual amount to liquidate         reserve.decreaseTotalBorrowsVariable(_amountToLiquidate);     }  }  /** * @dev updates the state of the collateral reserve as a consequence of a liquidation action. * @param _collateralReserve the address of the collateral reserve that is being liquidated **/ function updateCollateralReserveStateOnLiquidationInternal(     address _collateralReserve ) internal {     //update collateral reserve     reserves[_collateralReserve].updateCumulativeIndexes();  }  /** * @dev updates the state of the user being liquidated as a consequence of a liquidation action. * @param _reserve the address of the principal reserve that is being repaid * @param _user the address of the borrower * @param _amountToLiquidate the amount being repaid by the liquidator * @param _feeLiquidated the amount of origination fee being liquidated * @param _balanceIncrease the accrued interest on the borrowed amount **/ function updateUserStateOnLiquidationInternal(     address _reserve,     address _user,     uint256 _amountToLiquidate,     uint256 _feeLiquidated,     uint256 _balanceIncrease ) internal {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     //first increase by the compounded interest, then decrease by the liquidated amount     user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(         _amountToLiquidate     );      if (         getUserCurrentBorrowRateMode(_reserve, _user) == CoreLibrary.InterestRateMode.VARIABLE     ) {         user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;     }      if(_feeLiquidated &gt; 0){         user.originationFee = user.originationFee.sub(_feeLiquidated);     }      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp); }  /** * @dev updates the state of the reserve as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updateReserveStateOnRebalanceInternal(     address _reserve,     address _user,     uint256 _balanceIncrease ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      reserve.updateCumulativeIndexes();      reserve.increaseTotalBorrowsStableAndUpdateAverageRate(         _balanceIncrease,         user.stableBorrowRate     );  }  /** * @dev updates the state of the user as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updateUserStateOnRebalanceInternal(     address _reserve,     address _user,     uint256 _balanceIncrease ) internal {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);     user.stableBorrowRate = reserve.currentStableBorrowRate;      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp); }  /** * @dev updates the state of the user as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount * @param _amountBorrowed the accrued interest on the borrowed amount **/ function updateReserveTotalBorrowsByRateModeInternal(     address _reserve,     address _user,     uint256 _principalBalance,     uint256 _balanceIncrease,     uint256 _amountBorrowed,     CoreLibrary.InterestRateMode _newBorrowRateMode ) internal {     CoreLibrary.InterestRateMode previousRateMode = getUserCurrentBorrowRateMode(         _reserve,         _user     );     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      if (previousRateMode == CoreLibrary.InterestRateMode.STABLE) {         CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _principalBalance,             user.stableBorrowRate         );     } else if (previousRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         reserve.decreaseTotalBorrowsVariable(_principalBalance);     }      uint256 newPrincipalAmount = _principalBalance.add(_balanceIncrease).add(_amountBorrowed);     if (_newBorrowRateMode == CoreLibrary.InterestRateMode.STABLE) {         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             newPrincipalAmount,             reserve.currentStableBorrowRate         );     } else if (_newBorrowRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         reserve.increaseTotalBorrowsVariable(newPrincipalAmount);     } else {         revert("Invalid new borrow rate mode");     } }  /** * @dev Updates the reserve current stable borrow rate Rf, the current variable borrow rate Rv and the current liquidity rate Rl. * Also updates the lastUpdateTimestamp value. Please refer to the whitepaper for further information. * @param _reserve the address of the reserve to be updated * @param _liquidityAdded the amount of liquidity added to the protocol (deposit or repay) in the previous action * @param _liquidityTaken the amount of liquidity taken from the protocol (redeem or borrow) **/  function updateReserveInterestRatesAndTimestampInternal(     address _reserve,     uint256 _liquidityAdded,     uint256 _liquidityTaken ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     (uint256 newLiquidityRate, uint256 newStableRate, uint256 newVariableRate) = IReserveInterestRateStrategy(         reserve         .interestRateStrategyAddress     )     .calculateInterestRates(         _reserve,         getReserveAvailableLiquidity(_reserve).add(_liquidityAdded).sub(_liquidityTaken),         reserve.totalBorrowsStable,         reserve.totalBorrowsVariable,         reserve.currentAverageStableBorrowRate     );      reserve.currentLiquidityRate = newLiquidityRate;     reserve.currentStableBorrowRate = newStableRate;     reserve.currentVariableBorrowRate = newVariableRate;      //solium-disable-next-line     reserve.lastUpdateTimestamp = uint40(block.timestamp);      emit ReserveUpdated(         _reserve,         newLiquidityRate,         newStableRate,         newVariableRate,         reserve.lastLiquidityCumulativeIndex,         reserve.lastVariableBorrowCumulativeIndex     ); }  /** * @dev transfers to the protocol fees of a flashloan to the fees collection address * @param _token the address of the token being transferred * @param _amount the amount being transferred **/  function transferFlashLoanProtocolFeeInternal(address _token, uint256 _amount) internal {     address payable receiver = address(uint160(addressesProvider.getTokenDistributor()));      if (_token != EthAddressLib.ethAddress()) {         ERC20(_token).safeTransfer(receiver, _amount);     } else {         receiver.transfer(_amount);     } }  /** * @dev updates the internal configuration of the core **/ function refreshConfigInternal() internal {     lendingPoolAddress = addressesProvider.getLendingPool(); }  /** * @dev adds a reserve to the array of the reserves address **/ function addReserveToListInternal(address _reserve) internal {     bool reserveAlreadyAdded = false;     for (uint256 i = 0; i &lt; reservesList.length; i++)         if (reservesList[i] == _reserve) {             reserveAlreadyAdded = true;         }     if (!reserveAlreadyAdded) reservesList.push(_reserve); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 04:31:46 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: pragma solidity ^0.5.0;

import "openzeppelin-solidity/contracts/math/SafeMath.sol";
import "openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol";
import "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol";
import "openzeppelin-solidity/contracts/utils/Address.sol";
import "../libraries/openzeppelin-upgradeability/VersionedInitializable.sol";

import "../libraries/CoreLibrary.sol";
import "../configuration/LendingPoolAddressesProvider.sol";
import "../interfaces/ILendingRateOracle.sol";
import "../interfaces/IReserveInterestRateStrategy.sol";
import "../libraries/WadRayMath.sol";
import "../tokenization/AToken.sol";
import "../libraries/EthAddressLib.sol";

/**
* @title LendingPoolCore contract
* @author Aave
* @notice Holds the state of the lending pool and all the funds deposited
* @dev NOTE: The core does not enforce security checks on the update of the state
* (eg, updateStateOnBorrow() does not enforce that borrowed is enabled on the reserve).
* The check that an action can be performed is a duty of the overlying LendingPool contract.
**/

contract LendingPoolCore is VersionedInitializable {
    using SafeMath for uint256;
    using WadRayMath for uint256;
    using CoreLibrary for CoreLibrary.ReserveData;
    using CoreLibrary for CoreLibrary.UserReserveData;
    using SafeERC20 for ERC20;
    using Address for address payable;

    /**
    * @dev Emitted when the state of a reserve is updated
    * @param reserve the address of the reserve
    * @param liquidityRate the new liquidity rate
    * @param stableBorrowRate the new stable borrow rate
    * @param variableBorrowRate the new variable borrow rate
    * @param liquidityIndex the new liquidity index
    * @param variableBorrowIndex the new variable borrow index
    **/
    event ReserveUpdated(
        address indexed reserve,
        uint256 liquidityRate,
        uint256 stableBorrowRate,
        uint256 variableBorrowRate,
        uint256 liquidityIndex,
        uint256 variableBorrowIndex
    );

    address public lendingPoolAddress;

    LendingPoolAddressesProvider public addressesProvider;

    /**
    * @dev only lending pools can use functions affected by this modifier
    **/
    modifier onlyLendingPool {
        require(lendingPoolAddress == msg.sender, "The caller must be a lending pool contract");
        _;
    }

    /**
    * @dev only lending pools configurator can use functions affected by this modifier
    **/
    modifier onlyLendingPoolConfigurator {
        require(
            addressesProvider.getLendingPoolConfigurator() == msg.sender,
            "The caller must be a lending pool configurator contract"
        );
        _;
    }

    mapping(address => CoreLibrary.ReserveData) internal reserves;
    mapping(address => mapping(address => CoreLibrary.UserReserveData)) internal usersReserveData;

    address[] public reservesList;

    uint256 public constant CORE_REVISION = 0x4;

    /**
    * @dev returns the revision number of the contract
    **/
    function getRevision() internal pure returns (uint256) {
        return CORE_REVISION;
    }

    /**
    * @dev initializes the Core contract, invoked upon registration on the AddressesProvider
    * @param _addressesProvider the addressesProvider contract
    **/

    function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {
        addressesProvider = _addressesProvider;
        refreshConfigInternal();
    }

    /**
    * @dev updates the state of the core as a result of a deposit action
    * @param _reserve the address of the reserve in which the deposit is happening
    * @param _user the address of the the user depositing
    * @param _amount the amount being deposited
    * @param _isFirstDeposit true if the user is depositing for the first time
    **/

    function updateStateOnDeposit(
        address _reserve,
        address _user,
        uint256 _amount,
        bool _isFirstDeposit
    ) external onlyLendingPool {
        reserves[_reserve].updateCumulativeIndexes();
        updateReserveInterestRatesAndTimestampInternal(_reserve, _amount, 0);

        if (_isFirstDeposit) {
            //if this is the first deposit of the user, we configure the deposit as enabled to be used as collateral
            setUserUseReserveAsCollateral(_reserve, _user, true);
        }
    }

    /**
    * @dev updates the state of the core as a result of a redeem action
    * @param _reserve the address of the reserve in which the redeem is happening
    * @param _user the address of the the user redeeming
    * @param _amountRedeemed the amount being redeemed
    * @param _userRedeemedEverything true if the user is redeeming everything
    **/
    function updateStateOnRedeem(
        address _reserve,
        address _user,
        uint256 _amountRedeemed,
        bool _userRedeemedEverything
    ) external onlyLendingPool {
        //compound liquidity and variable borrow interests
        reserves[_reserve].updateCumulativeIndexes();
        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountRedeemed);

        //if user redeemed everything the useReserveAsCollateral flag is reset
        if (_userRedeemedEverything) {
            setUserUseReserveAsCollateral(_reserve, _user, false);
        }
    }

    /**
    * @dev updates the state of the core as a result of a flashloan action
    * @param _reserve the address of the reserve in which the flashloan is happening
    * @param _income the income of the protocol as a result of the action
    **/
    function updateStateOnFlashLoan(
        address _reserve,
        uint256 _availableLiquidityBefore,
        uint256 _income,
        uint256 _protocolFee
    ) external onlyLendingPool {
        transferFlashLoanProtocolFeeInternal(_reserve, _protocolFee);

        //compounding the cumulated interest
        reserves[_reserve].updateCumulativeIndexes();

        uint256 totalLiquidityBefore = _availableLiquidityBefore.add(
            getReserveTotalBorrows(_reserve)
        );

        //compounding the received fee into the reserve
        reserves[_reserve].cumulateToLiquidityIndex(totalLiquidityBefore, _income);

        //refresh interest rates
        updateReserveInterestRatesAndTimestampInternal(_reserve, _income, 0);
    }

    /**
    * @dev updates the state of the core as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _amountBorrowed the new amount borrowed
    * @param _borrowFee the fee on the amount borrowed
    * @param _rateMode the borrow rate mode (stable, variable)
    * @return the new borrow rate for the user
    **/
    function updateStateOnBorrow(
        address _reserve,
        address _user,
        uint256 _amountBorrowed,
        uint256 _borrowFee,
        CoreLibrary.InterestRateMode _rateMode
    ) external onlyLendingPool returns (uint256, uint256) {
        // getting the previous borrow data of the user
        (uint256 principalBorrowBalance, , uint256 balanceIncrease) = getUserBorrowBalances(
            _reserve,
            _user
        );

        updateReserveStateOnBorrowInternal(
            _reserve,
            _user,
            principalBorrowBalance,
            balanceIncrease,
            _amountBorrowed,
            _rateMode
        );

        updateUserStateOnBorrowInternal(
            _reserve,
            _user,
            _amountBorrowed,
            balanceIncrease,
            _borrowFee,
            _rateMode
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountBorrowed);

        return (getUserCurrentBorrowRate(_reserve, _user), balanceIncrease);
    }

    /**
    * @dev updates the state of the core as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _originationFeeRepaid the fee on the amount that is being repaid
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _repaidWholeLoan true if the user is repaying the whole loan
    **/

    function updateStateOnRepay(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _originationFeeRepaid,
        uint256 _balanceIncrease,
        bool _repaidWholeLoan
    ) external onlyLendingPool {
        updateReserveStateOnRepayInternal(
            _reserve,
            _user,
            _paybackAmountMinusFees,
            _balanceIncrease
        );
        updateUserStateOnRepayInternal(
            _reserve,
            _user,
            _paybackAmountMinusFees,
            _originationFeeRepaid,
            _balanceIncrease,
            _repaidWholeLoan
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, _paybackAmountMinusFees, 0);
    }

    /**
    * @dev updates the state of the core as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the amount borrowed by the user
    * @param _compoundedBorrowBalance the amount borrowed plus accrued interest
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _currentRateMode the current interest rate mode for the user
    **/
    function updateStateOnSwapRate(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _compoundedBorrowBalance,
        uint256 _balanceIncrease,
        CoreLibrary.InterestRateMode _currentRateMode
    ) external onlyLendingPool returns (CoreLibrary.InterestRateMode, uint256) {
        updateReserveStateOnSwapRateInternal(
            _reserve,
            _user,
            _principalBorrowBalance,
            _compoundedBorrowBalance,
            _currentRateMode
        );

        CoreLibrary.InterestRateMode newRateMode = updateUserStateOnSwapRateInternal(
            _reserve,
            _user,
            _balanceIncrease,
            _currentRateMode
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);

        return (newRateMode, getUserCurrentBorrowRate(_reserve, _user));
    }

    /**
    * @dev updates the state of the core as a consequence of a liquidation action.
    * @param _principalReserve the address of the principal reserve that is being repaid
    * @param _collateralReserve the address of the collateral reserve that is being liquidated
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _collateralToLiquidate the amount of collateral being liquidated
    * @param _feeLiquidated the amount of origination fee being liquidated
    * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise
    **/
    function updateStateOnLiquidation(
        address _principalReserve,
        address _collateralReserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _collateralToLiquidate,
        uint256 _feeLiquidated,
        uint256 _liquidatedCollateralForFee,
        uint256 _balanceIncrease,
        bool _liquidatorReceivesAToken
    ) external onlyLendingPool {
        updatePrincipalReserveStateOnLiquidationInternal(
            _principalReserve,
            _user,
            _amountToLiquidate,
            _balanceIncrease
        );

        updateCollateralReserveStateOnLiquidationInternal(
            _collateralReserve
        );

        updateUserStateOnLiquidationInternal(
            _principalReserve,
            _user,
            _amountToLiquidate,
            _feeLiquidated,
            _balanceIncrease
        );

        updateReserveInterestRatesAndTimestampInternal(_principalReserve, _amountToLiquidate, 0);

        if (!_liquidatorReceivesAToken) {
            updateReserveInterestRatesAndTimestampInternal(
                _collateralReserve,
                0,
                _collateralToLiquidate.add(_liquidatedCollateralForFee)
            );
        }

    }

    /**
    * @dev updates the state of the core as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @return the new stable rate for the user
    **/
    function updateStateOnRebalance(address _reserve, address _user, uint256 _balanceIncrease)
    external
    onlyLendingPool
    returns (uint256)
    {
        updateReserveStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);

        //update user data and rebalance the rate
        updateUserStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);
        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);
        return usersReserveData[_user][_reserve].stableBorrowRate;
    }

    /**
    * @dev enables or disables a reserve as collateral
    * @param _reserve the address of the principal reserve where the user deposited
    * @param _user the address of the depositor
    * @param _useAsCollateral true if the depositor wants to use the reserve as collateral
    **/
    function setUserUseReserveAsCollateral(address _reserve, address _user, bool _useAsCollateral)
    public
    onlyLendingPool
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        user.useAsCollateral = _useAsCollateral;
    }

    /**
    * @notice ETH/token transfer functions
    **/

    /**
    * @dev fallback function enforces that the caller is a contract, to support flashloan transfers
    **/
    function() external payable {
        //only contracts can send ETH to the core
        require(msg.sender.isContract(), "Only contracts can send ether to the Lending pool core");

    }

    /**
    * @dev transfers to the user a specific amount from the reserve.
    * @param _reserve the address of the reserve where the transfer is happening
    * @param _user the address of the user receiving the transfer
    * @param _amount the amount being transferred
    **/
    function transferToUser(address _reserve, address payable _user, uint256 _amount)
    external
    onlyLendingPool
    {
        if (_reserve != EthAddressLib.ethAddress()) {
            ERC20(_reserve).safeTransfer(_user, _amount);
        } else {
            //solium-disable-next-line
            (bool result, ) = _user.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers the protocol fees to the fees collection address
    * @param _token the address of the token being transferred
    * @param _user the address of the user from where the transfer is happening
    * @param _amount the amount being transferred
    * @param _destination the fee receiver address
    **/

    function transferToFeeCollectionAddress(
        address _token,
        address _user,
        uint256 _amount,
        address _destination
    ) external payable onlyLendingPool {
        address payable feeAddress = address(uint160(_destination)); //cast the address to payable

        if (_token != EthAddressLib.ethAddress()) {
            require(
                msg.value == 0,
                "User is sending ETH along with the ERC20 transfer. Check the value attribute of the transaction"
            );
            ERC20(_token).safeTransferFrom(_user, feeAddress, _amount);
        } else {
            require(msg.value >= _amount, "The amount and the value sent to deposit do not match");
            //solium-disable-next-line
            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers the fees to the fees collection address in the case of liquidation
    * @param _token the address of the token being transferred
    * @param _amount the amount being transferred
    * @param _destination the fee receiver address
    **/
    function liquidateFee(
        address _token,
        uint256 _amount,
        address _destination
    ) external payable onlyLendingPool {
        address payable feeAddress = address(uint160(_destination)); //cast the address to payable
        require(
            msg.value == 0,
            "Fee liquidation does not require any transfer of value"
        );

        if (_token != EthAddressLib.ethAddress()) {
            ERC20(_token).safeTransfer(feeAddress, _amount);
        } else {
            //solium-disable-next-line
            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers an amount from a user to the destination reserve
    * @param _reserve the address of the reserve where the amount is being transferred
    * @param _user the address of the user from where the transfer is happening
    * @param _amount the amount being transferred
    **/
    function transferToReserve(address _reserve, address payable _user, uint256 _amount)
    external
    payable
    onlyLendingPool
    {
        if (_reserve != EthAddressLib.ethAddress()) {
            require(msg.value == 0, "User is sending ETH along with the ERC20 transfer.");
            ERC20(_reserve).safeTransferFrom(_user, address(this), _amount);

        } else {
            require(msg.value >= _amount, "The amount and the value sent to deposit do not match");

            if (msg.value > _amount) {
                //send back excess ETH
                uint256 excessAmount = msg.value.sub(_amount);
                //solium-disable-next-line
                (bool result, ) = _user.call.value(excessAmount).gas(50000)("");
                require(result, "Transfer of ETH failed");
            }
        }
    }

    /**
    * @notice data access functions
    **/

    /**
    * @dev returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral)
    * needed to calculate the global account data in the LendingPoolDataProvider
    * @param _reserve the address of the reserve
    * @param _user the address of the user
    * @return the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not
    **/
    function getUserBasicReserveData(address _reserve, address _user)
    external
    view
    returns (uint256, uint256, uint256, bool)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        uint256 underlyingBalance = getUserUnderlyingAssetBalance(_reserve, _user);

        if (user.principalBorrowBalance == 0) {
            return (underlyingBalance, 0, 0, user.useAsCollateral);
        }

        return (
        underlyingBalance,
        user.getCompoundedBorrowBalance(reserve),
        user.originationFee,
        user.useAsCollateral
        );
    }

    /**
    * @dev checks if a user is allowed to borrow at a stable rate
    * @param _reserve the reserve address
    * @param _user the user
    * @param _amount the amount the the user wants to borrow
    * @return true if the user is allowed to borrow at a stable rate, false otherwise
    **/

    function isUserAllowedToBorrowAtStable(address _reserve, address _user, uint256 _amount)
    external
    view
    returns (bool)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (!reserve.isStableBorrowRateEnabled) return false;

        return
        !user.useAsCollateral ||
        !reserve.usageAsCollateralEnabled ||
        _amount > getUserUnderlyingAssetBalance(_reserve, _user);
    }

    /**
    * @dev gets the underlying asset balance of a user based on the corresponding aToken balance.
    * @param _reserve the reserve address
    * @param _user the user address
    * @return the underlying deposit balance of the user
    **/

    function getUserUnderlyingAssetBalance(address _reserve, address _user)
    public
    view
    returns (uint256)
    {
        AToken aToken = AToken(reserves[_reserve].aTokenAddress);
        return aToken.balanceOf(_user);

    }

    /**
    * @dev gets the interest rate strategy contract address for the reserve
    * @param _reserve the reserve address
    * @return the address of the interest rate strategy contract
    **/
    function getReserveInterestRateStrategyAddress(address _reserve) public view returns (address) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.interestRateStrategyAddress;
    }

    /**
    * @dev gets the aToken contract address for the reserve
    * @param _reserve the reserve address
    * @return the address of the aToken contract
    **/

    function getReserveATokenAddress(address _reserve) public view returns (address) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.aTokenAddress;
    }

    /**
    * @dev gets the available liquidity in the reserve. The available liquidity is the balance of the core contract
    * @param _reserve the reserve address
    * @return the available liquidity
    **/
    function getReserveAvailableLiquidity(address _reserve) public view returns (uint256) {
        uint256 balance = 0;

        if (_reserve == EthAddressLib.ethAddress()) {
            balance = address(this).balance;
        } else {
            balance = IERC20(_reserve).balanceOf(address(this));
        }
        return balance;
    }

    /**
    * @dev gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows
    * @param _reserve the reserve address
    * @return the total liquidity
    **/
    function getReserveTotalLiquidity(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return getReserveAvailableLiquidity(_reserve).add(reserve.getTotalBorrows());
    }

    /**
    * @dev gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there
    * there has been 100% income.
    * @param _reserve the reserve address
    * @return the reserve normalized income
    **/
    function getReserveNormalizedIncome(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.getNormalizedIncome();
    }

    /**
    * @dev gets the reserve total borrows
    * @param _reserve the reserve address
    * @return the total borrows (stable + variable)
    **/
    function getReserveTotalBorrows(address _reserve) public view returns (uint256) {
        return reserves[_reserve].getTotalBorrows();
    }

    /**
    * @dev gets the reserve total borrows stable
    * @param _reserve the reserve address
    * @return the total borrows stable
    **/
    function getReserveTotalBorrowsStable(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.totalBorrowsStable;
    }

    /**
    * @dev gets the reserve total borrows variable
    * @param _reserve the reserve address
    * @return the total borrows variable
    **/

    function getReserveTotalBorrowsVariable(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.totalBorrowsVariable;
    }

    /**
    * @dev gets the reserve liquidation threshold
    * @param _reserve the reserve address
    * @return the reserve liquidation threshold
    **/

    function getReserveLiquidationThreshold(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.liquidationThreshold;
    }

    /**
    * @dev gets the reserve liquidation bonus
    * @param _reserve the reserve address
    * @return the reserve liquidation bonus
    **/

    function getReserveLiquidationBonus(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.liquidationBonus;
    }

    /**
    * @dev gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty
    * @param _reserve the reserve address
    * @return the reserve current variable borrow rate
    **/

    function getReserveCurrentVariableBorrowRate(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        if (reserve.currentVariableBorrowRate == 0) {
            return
            IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)
            .getBaseVariableBorrowRate();
        }
        return reserve.currentVariableBorrowRate;
    }

    /**
    * @dev gets the reserve current stable borrow rate. Is the market rate if the reserve is empty
    * @param _reserve the reserve address
    * @return the reserve current stable borrow rate
    **/

    function getReserveCurrentStableBorrowRate(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        ILendingRateOracle oracle = ILendingRateOracle(addressesProvider.getLendingRateOracle());

        if (reserve.currentStableBorrowRate == 0) {
            //no stable rate borrows yet
            return oracle.getMarketBorrowRate(_reserve);
        }

        return reserve.currentStableBorrowRate;
    }

    /**
    * @dev gets the reserve average stable borrow rate. The average stable rate is the weighted average
    * of all the loans taken at stable rate.
    * @param _reserve the reserve address
    * @return the reserve current average borrow rate
    **/
    function getReserveCurrentAverageStableBorrowRate(address _reserve)
    external
    view
    returns (uint256)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.currentAverageStableBorrowRate;
    }

    /**
    * @dev gets the reserve liquidity rate
    * @param _reserve the reserve address
    * @return the reserve liquidity rate
    **/
    function getReserveCurrentLiquidityRate(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.currentLiquidityRate;
    }

    /**
    * @dev gets the reserve liquidity cumulative index
    * @param _reserve the reserve address
    * @return the reserve liquidity cumulative index
    **/
    function getReserveLiquidityCumulativeIndex(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.lastLiquidityCumulativeIndex;
    }

    /**
    * @dev gets the reserve variable borrow index
    * @param _reserve the reserve address
    * @return the reserve variable borrow index
    **/
    function getReserveVariableBorrowsCumulativeIndex(address _reserve)
    external
    view
    returns (uint256)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.lastVariableBorrowCumulativeIndex;
    }

    /**
    * @dev this function aggregates the configuration parameters of the reserve.
    * It's used in the LendingPoolDataProvider specifically to save gas, and avoid
    * multiple external contract calls to fetch the same data.
    * @param _reserve the reserve address
    * @return the reserve decimals
    * @return the base ltv as collateral
    * @return the liquidation threshold
    * @return if the reserve is used as collateral or not
    **/
    function getReserveConfiguration(address _reserve)
    external
    view
    returns (uint256, uint256, uint256, bool)
    {
        uint256 decimals;
        uint256 baseLTVasCollateral;
        uint256 liquidationThreshold;
        bool usageAsCollateralEnabled;

        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        decimals = reserve.decimals;
        baseLTVasCollateral = reserve.baseLTVasCollateral;
        liquidationThreshold = reserve.liquidationThreshold;
        usageAsCollateralEnabled = reserve.usageAsCollateralEnabled;

        return (decimals, baseLTVasCollateral, liquidationThreshold, usageAsCollateralEnabled);
    }

    /**
    * @dev returns the decimals of the reserve
    * @param _reserve the reserve address
    * @return the reserve decimals
    **/
    function getReserveDecimals(address _reserve) external view returns (uint256) {
        return reserves[_reserve].decimals;
    }

    /**
    * @dev returns true if the reserve is enabled for borrowing
    * @param _reserve the reserve address
    * @return true if the reserve is enabled for borrowing, false otherwise
    **/

    function isReserveBorrowingEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.borrowingEnabled;
    }

    /**
    * @dev returns true if the reserve is enabled as collateral
    * @param _reserve the reserve address
    * @return true if the reserve is enabled as collateral, false otherwise
    **/

    function isReserveUsageAsCollateralEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.usageAsCollateralEnabled;
    }

    /**
    * @dev returns true if the stable rate is enabled on reserve
    * @param _reserve the reserve address
    * @return true if the stable rate is enabled on reserve, false otherwise
    **/
    function getReserveIsStableBorrowRateEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isStableBorrowRateEnabled;
    }

    /**
    * @dev returns true if the reserve is active
    * @param _reserve the reserve address
    * @return true if the reserve is active, false otherwise
    **/
    function getReserveIsActive(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isActive;
    }

    /**
    * @notice returns if a reserve is freezed
    * @param _reserve the reserve for which the information is needed
    * @return true if the reserve is freezed, false otherwise
    **/

    function getReserveIsFreezed(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isFreezed;
    }

    /**
    * @notice returns the timestamp of the last action on the reserve
    * @param _reserve the reserve for which the information is needed
    * @return the last updated timestamp of the reserve
    **/

    function getReserveLastUpdate(address _reserve) external view returns (uint40 timestamp) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        timestamp = reserve.lastUpdateTimestamp;
    }

    /**
    * @dev returns the utilization rate U of a specific reserve
    * @param _reserve the reserve for which the information is needed
    * @return the utilization rate in ray
    **/

    function getReserveUtilizationRate(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        uint256 totalBorrows = reserve.getTotalBorrows();

        if (totalBorrows == 0) {
            return 0;
        }

        uint256 availableLiquidity = getReserveAvailableLiquidity(_reserve);

        return totalBorrows.rayDiv(availableLiquidity.add(totalBorrows));
    }

    /**
    * @return the array of reserves configured on the core
    **/
    function getReserves() external view returns (address[] memory) {
        return reservesList;
    }

    /**
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return true if the user has chosen to use the reserve as collateral, false otherwise
    **/
    function isUserUseReserveAsCollateralEnabled(address _reserve, address _user)
    external
    view
    returns (bool)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.useAsCollateral;
    }

    /**
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the origination fee for the user
    **/
    function getUserOriginationFee(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.originationFee;
    }

    /**
    * @dev users with no loans in progress have NONE as borrow rate mode
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the borrow rate mode for the user,
    **/

    function getUserCurrentBorrowRateMode(address _reserve, address _user)
    public
    view
    returns (CoreLibrary.InterestRateMode)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (user.principalBorrowBalance == 0) {
            return CoreLibrary.InterestRateMode.NONE;
        }

        return
        user.stableBorrowRate > 0
        ? CoreLibrary.InterestRateMode.STABLE
        : CoreLibrary.InterestRateMode.VARIABLE;
    }

    /**
    * @dev gets the current borrow rate of the user
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the borrow rate for the user,
    **/
    function getUserCurrentBorrowRate(address _reserve, address _user)
    internal
    view
    returns (uint256)
    {
        CoreLibrary.InterestRateMode rateMode = getUserCurrentBorrowRateMode(_reserve, _user);

        if (rateMode == CoreLibrary.InterestRateMode.NONE) {
            return 0;
        }

        return
        rateMode == CoreLibrary.InterestRateMode.STABLE
        ? usersReserveData[_user][_reserve].stableBorrowRate
        : reserves[_reserve].currentVariableBorrowRate;
    }

    /**
    * @dev the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the user stable rate
    **/
    function getUserCurrentStableBorrowRate(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.stableBorrowRate;
    }

    /**
    * @dev calculates and returns the borrow balances of the user
    * @param _reserve the address of the reserve
    * @param _user the address of the user
    * @return the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance
    **/

    function getUserBorrowBalances(address _reserve, address _user)
    public
    view
    returns (uint256, uint256, uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        if (user.principalBorrowBalance == 0) {
            return (0, 0, 0);
        }

        uint256 principal = user.principalBorrowBalance;
        uint256 compoundedBalance = CoreLibrary.getCompoundedBorrowBalance(
            user,
            reserves[_reserve]
        );
        return (principal, compoundedBalance, compoundedBalance.sub(principal));
    }

    /**
    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the variable borrow index for the user
    **/

    function getUserVariableBorrowCumulativeIndex(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.lastVariableBorrowCumulativeIndex;
    }

    /**
    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the variable borrow index for the user
    **/

    function getUserLastUpdate(address _reserve, address _user)
    external
    view
    returns (uint256 timestamp)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        timestamp = user.lastUpdateTimestamp;
    }

    /**
    * @dev updates the lending pool core configuration
    **/
    function refreshConfiguration() external onlyLendingPoolConfigurator {
        refreshConfigInternal();
    }

    /**
    * @dev initializes a reserve
    * @param _reserve the address of the reserve
    * @param _aTokenAddress the address of the overlying aToken contract
    * @param _decimals the decimals of the reserve currency
    * @param _interestRateStrategyAddress the address of the interest rate strategy contract
    **/
    function initReserve(
        address _reserve,
        address _aTokenAddress,
        uint256 _decimals,
        address _interestRateStrategyAddress
    ) external onlyLendingPoolConfigurator {
        reserves[_reserve].init(_aTokenAddress, _decimals, _interestRateStrategyAddress);
        addReserveToListInternal(_reserve);

    }



    /**
    * @dev removes the last added reserve in the reservesList array
    * @param _reserveToRemove the address of the reserve
    **/
    function removeLastAddedReserve(address _reserveToRemove)
    external onlyLendingPoolConfigurator {

        address lastReserve = reservesList[reservesList.length-1];

        require(lastReserve == _reserveToRemove, "Reserve being removed is different than the reserve requested");

        //as we can't check if totalLiquidity is 0 (since the reserve added might not be an ERC20) we at least check that there is nothing borrowed
        require(getReserveTotalBorrows(lastReserve) == 0, "Cannot remove a reserve with liquidity deposited");

        reserves[lastReserve].isActive = false;
        reserves[lastReserve].aTokenAddress = address(0);
        reserves[lastReserve].decimals = 0;
        reserves[lastReserve].lastLiquidityCumulativeIndex = 0;
        reserves[lastReserve].lastVariableBorrowCumulativeIndex = 0;
        reserves[lastReserve].borrowingEnabled = false;
        reserves[lastReserve].usageAsCollateralEnabled = false;
        reserves[lastReserve].baseLTVasCollateral = 0;
        reserves[lastReserve].liquidationThreshold = 0;
        reserves[lastReserve].liquidationBonus = 0;
        reserves[lastReserve].interestRateStrategyAddress = address(0);

        reservesList.pop();
    }

    /**
    * @dev updates the address of the interest rate strategy contract
    * @param _reserve the address of the reserve
    * @param _rateStrategyAddress the address of the interest rate strategy contract
    **/

    function setReserveInterestRateStrategyAddress(address _reserve, address _rateStrategyAddress)
    external
    onlyLendingPoolConfigurator
    {
        reserves[_reserve].interestRateStrategyAddress = _rateStrategyAddress;
    }

    /**
    * @dev enables borrowing on a reserve. Also sets the stable rate borrowing
    * @param _reserve the address of the reserve
    * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise
    **/

    function enableBorrowingOnReserve(address _reserve, bool _stableBorrowRateEnabled)
    external
    onlyLendingPoolConfigurator
    {
        reserves[_reserve].enableBorrowing(_stableBorrowRateEnabled);
    }

    /**
    * @dev disables borrowing on a reserve
    * @param _reserve the address of the reserve
    **/

    function disableBorrowingOnReserve(address _reserve) external onlyLendingPoolConfigurator {
        reserves[_reserve].disableBorrowing();
    }

    /**
    * @dev enables a reserve to be used as collateral
    * @param _reserve the address of the reserve
    **/
    function enableReserveAsCollateral(
        address _reserve,
        uint256 _baseLTVasCollateral,
        uint256 _liquidationThreshold,
        uint256 _liquidationBonus
    ) external onlyLendingPoolConfigurator {
        reserves[_reserve].enableAsCollateral(
            _baseLTVasCollateral,
            _liquidationThreshold,
            _liquidationBonus
        );
    }

    /**
    * @dev disables a reserve to be used as collateral
    * @param _reserve the address of the reserve
    **/
    function disableReserveAsCollateral(address _reserve) external onlyLendingPoolConfigurator {
        reserves[_reserve].disableAsCollateral();
    }

    /**
    * @dev enable the stable borrow rate mode on a reserve
    * @param _reserve the address of the reserve
    **/
    function enableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isStableBorrowRateEnabled = true;
    }

    /**
    * @dev disable the stable borrow rate mode on a reserve
    * @param _reserve the address of the reserve
    **/
    function disableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isStableBorrowRateEnabled = false;
    }

    /**
    * @dev activates a reserve
    * @param _reserve the address of the reserve
    **/
    function activateReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        require(
            reserve.lastLiquidityCumulativeIndex > 0 &&
            reserve.lastVariableBorrowCumulativeIndex > 0,
            "Reserve has not been initialized yet"
        );
        reserve.isActive = true;
    }

    /**
    * @dev deactivates a reserve
    * @param _reserve the address of the reserve
    **/
    function deactivateReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isActive = false;
    }

    /**
    * @notice allows the configurator to freeze the reserve.
    * A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance.
    * @param _reserve the address of the reserve
    **/
    function freezeReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isFreezed = true;
    }

    /**
    * @notice allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed.
    * @param _reserve the address of the reserve
    **/
    function unfreezeReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isFreezed = false;
    }

    /**
    * @notice allows the configurator to update the loan to value of a reserve
    * @param _reserve the address of the reserve
    * @param _ltv the new loan to value
    **/
    function setReserveBaseLTVasCollateral(address _reserve, uint256 _ltv)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.baseLTVasCollateral = _ltv;
    }

    /**
    * @notice allows the configurator to update the liquidation threshold of a reserve
    * @param _reserve the address of the reserve
    * @param _threshold the new liquidation threshold
    **/
    function setReserveLiquidationThreshold(address _reserve, uint256 _threshold)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.liquidationThreshold = _threshold;
    }

    /**
    * @notice allows the configurator to update the liquidation bonus of a reserve
    * @param _reserve the address of the reserve
    * @param _bonus the new liquidation bonus
    **/
    function setReserveLiquidationBonus(address _reserve, uint256 _bonus)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.liquidationBonus = _bonus;
    }

    /**
    * @notice allows the configurator to update the reserve decimals
    * @param _reserve the address of the reserve
    * @param _decimals the decimals of the reserve
    **/
    function setReserveDecimals(address _reserve, uint256 _decimals)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.decimals = _decimals;
    }

    /**
    * @notice internal functions
    **/

    /**
    * @dev updates the state of a reserve as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the previous borrow balance of the borrower before the action
    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount
    * @param _amountBorrowed the new amount borrowed
    * @param _rateMode the borrow rate mode (stable, variable)
    **/

    function updateReserveStateOnBorrowInternal(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _balanceIncrease,
        uint256 _amountBorrowed,
        CoreLibrary.InterestRateMode _rateMode
    ) internal {
        reserves[_reserve].updateCumulativeIndexes();

        //increasing reserve total borrows to account for the new borrow balance of the user
        //NOTE: Depending on the previous borrow mode, the borrows might need to be switched from variable to stable or vice versa

        updateReserveTotalBorrowsByRateModeInternal(
            _reserve,
            _user,
            _principalBorrowBalance,
            _balanceIncrease,
            _amountBorrowed,
            _rateMode
        );
    }

    /**
    * @dev updates the state of a user as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _amountBorrowed the amount borrowed
    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount
    * @param _rateMode the borrow rate mode (stable, variable)
    * @return the final borrow rate for the user. Emitted by the borrow() event
    **/

    function updateUserStateOnBorrowInternal(
        address _reserve,
        address _user,
        uint256 _amountBorrowed,
        uint256 _balanceIncrease,
        uint256 _fee,
        CoreLibrary.InterestRateMode _rateMode
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (_rateMode == CoreLibrary.InterestRateMode.STABLE) {
            //stable
            //reset the user variable index, and update the stable rate
            user.stableBorrowRate = reserve.currentStableBorrowRate;
            user.lastVariableBorrowCumulativeIndex = 0;
        } else if (_rateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //variable
            //reset the user stable rate, and store the new borrow index
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        } else {
            revert("Invalid borrow rate mode");
        }
        //increase the principal borrows and the origination fee
        user.principalBorrowBalance = user.principalBorrowBalance.add(_amountBorrowed).add(
            _balanceIncrease
        );
        user.originationFee = user.originationFee.add(_fee);

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

    }

    /**
    * @dev updates the state of the reserve as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateReserveStateOnRepayInternal(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_reserve][_user];

        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(_reserve, _user);

        //update the indexes
        reserves[_reserve].updateCumulativeIndexes();

        //compound the cumulated interest to the borrow balance and then subtracting the payback amount
        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _balanceIncrease,
                user.stableBorrowRate
            );
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _paybackAmountMinusFees,
                user.stableBorrowRate
            );
        } else {
            reserve.increaseTotalBorrowsVariable(_balanceIncrease);
            reserve.decreaseTotalBorrowsVariable(_paybackAmountMinusFees);
        }
    }

    /**
    * @dev updates the state of the user as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _originationFeeRepaid the fee on the amount that is being repaid
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _repaidWholeLoan true if the user is repaying the whole loan
    **/
    function updateUserStateOnRepayInternal(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _originationFeeRepaid,
        uint256 _balanceIncrease,
        bool _repaidWholeLoan
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        //update the user principal borrow balance, adding the cumulated interest and then subtracting the payback amount
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(
            _paybackAmountMinusFees
        );
        user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;

        //if the balance decrease is equal to the previous principal (user is repaying the whole loan)
        //and the rate mode is stable, we reset the interest rate mode of the user
        if (_repaidWholeLoan) {
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = 0;
        }
        user.originationFee = user.originationFee.sub(_originationFeeRepaid);

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

    }

    /**
    * @dev updates the state of the user as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is performing the rate swap
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the the principal amount borrowed by the user
    * @param _compoundedBorrowBalance the principal amount plus the accrued interest
    * @param _currentRateMode the rate mode at which the user borrowed
    **/
    function updateReserveStateOnSwapRateInternal(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _compoundedBorrowBalance,
        CoreLibrary.InterestRateMode _currentRateMode
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        //compounding reserve indexes
        reserve.updateCumulativeIndexes();

        if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {
            uint256 userCurrentStableRate = user.stableBorrowRate;

            //swap to variable
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _principalBorrowBalance,
                userCurrentStableRate
            ); //decreasing stable from old principal balance
            reserve.increaseTotalBorrowsVariable(_compoundedBorrowBalance); //increase variable borrows
        } else if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //swap to stable
            uint256 currentStableRate = reserve.currentStableBorrowRate;
            reserve.decreaseTotalBorrowsVariable(_principalBorrowBalance);
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _compoundedBorrowBalance,
                currentStableRate
            );

        } else {
            revert("Invalid rate mode received");
        }
    }

    /**
    * @dev updates the state of the user as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is performing the swap
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _currentRateMode the current rate mode of the user
    **/

    function updateUserStateOnSwapRateInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease,
        CoreLibrary.InterestRateMode _currentRateMode
    ) internal returns (CoreLibrary.InterestRateMode) {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        CoreLibrary.InterestRateMode newMode = CoreLibrary.InterestRateMode.NONE;

        if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //switch to stable
            newMode = CoreLibrary.InterestRateMode.STABLE;
            user.stableBorrowRate = reserve.currentStableBorrowRate;
            user.lastVariableBorrowCumulativeIndex = 0;
        } else if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {
            newMode = CoreLibrary.InterestRateMode.VARIABLE;
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        } else {
            revert("Invalid interest rate mode received");
        }
        //compounding cumulated interest
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);
        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

        return newMode;
    }

    /**
    * @dev updates the state of the principal reserve as a consequence of a liquidation action.
    * @param _principalReserve the address of the principal reserve that is being repaid
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updatePrincipalReserveStateOnLiquidationInternal(
        address _principalReserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_principalReserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_principalReserve];

        //update principal reserve data
        reserve.updateCumulativeIndexes();

        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(
            _principalReserve,
            _user
        );

        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            //increase the total borrows by the compounded interest
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _balanceIncrease,
                user.stableBorrowRate
            );

            //decrease by the actual amount to liquidate
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _amountToLiquidate,
                user.stableBorrowRate
            );

        } else {
            //increase the total borrows by the compounded interest
            reserve.increaseTotalBorrowsVariable(_balanceIncrease);

            //decrease by the actual amount to liquidate
            reserve.decreaseTotalBorrowsVariable(_amountToLiquidate);
        }

    }

    /**
    * @dev updates the state of the collateral reserve as a consequence of a liquidation action.
    * @param _collateralReserve the address of the collateral reserve that is being liquidated
    **/
    function updateCollateralReserveStateOnLiquidationInternal(
        address _collateralReserve
    ) internal {
        //update collateral reserve
        reserves[_collateralReserve].updateCumulativeIndexes();

    }

    /**
    * @dev updates the state of the user being liquidated as a consequence of a liquidation action.
    * @param _reserve the address of the principal reserve that is being repaid
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _feeLiquidated the amount of origination fee being liquidated
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/
    function updateUserStateOnLiquidationInternal(
        address _reserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _feeLiquidated,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        //first increase by the compounded interest, then decrease by the liquidated amount
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(
            _amountToLiquidate
        );

        if (
            getUserCurrentBorrowRateMode(_reserve, _user) == CoreLibrary.InterestRateMode.VARIABLE
        ) {
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        }

        if(_feeLiquidated > 0){
            user.originationFee = user.originationFee.sub(_feeLiquidated);
        }

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);
    }

    /**
    * @dev updates the state of the reserve as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateReserveStateOnRebalanceInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        reserve.updateCumulativeIndexes();

        reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
            _balanceIncrease,
            user.stableBorrowRate
        );

    }

    /**
    * @dev updates the state of the user as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateUserStateOnRebalanceInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);
        user.stableBorrowRate = reserve.currentStableBorrowRate;

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);
    }

    /**
    * @dev updates the state of the user as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _amountBorrowed the accrued interest on the borrowed amount
    **/
    function updateReserveTotalBorrowsByRateModeInternal(
        address _reserve,
        address _user,
        uint256 _principalBalance,
        uint256 _balanceIncrease,
        uint256 _amountBorrowed,
        CoreLibrary.InterestRateMode _newBorrowRateMode
    ) internal {
        CoreLibrary.InterestRateMode previousRateMode = getUserCurrentBorrowRateMode(
            _reserve,
            _user
        );
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        if (previousRateMode == CoreLibrary.InterestRateMode.STABLE) {
            CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _principalBalance,
                user.stableBorrowRate
            );
        } else if (previousRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            reserve.decreaseTotalBorrowsVariable(_principalBalance);
        }

        uint256 newPrincipalAmount = _principalBalance.add(_balanceIncrease).add(_amountBorrowed);
        if (_newBorrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                newPrincipalAmount,
                reserve.currentStableBorrowRate
            );
        } else if (_newBorrowRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            reserve.increaseTotalBorrowsVariable(newPrincipalAmount);
        } else {
            revert("Invalid new borrow rate mode");
        }
    }

    /**
    * @dev Updates the reserve current stable borrow rate Rf, the current variable borrow rate Rv and the current liquidity rate Rl.
    * Also updates the lastUpdateTimestamp value. Please refer to the whitepaper for further information.
    * @param _reserve the address of the reserve to be updated
    * @param _liquidityAdded the amount of liquidity added to the protocol (deposit or repay) in the previous action
    * @param _liquidityTaken the amount of liquidity taken from the protocol (redeem or borrow)
    **/

    function updateReserveInterestRatesAndTimestampInternal(
        address _reserve,
        uint256 _liquidityAdded,
        uint256 _liquidityTaken
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        (uint256 newLiquidityRate, uint256 newStableRate, uint256 newVariableRate) = IReserveInterestRateStrategy(
            reserve
            .interestRateStrategyAddress
        )
        .calculateInterestRates(
            _reserve,
            getReserveAvailableLiquidity(_reserve).add(_liquidityAdded).sub(_liquidityTaken),
            reserve.totalBorrowsStable,
            reserve.totalBorrowsVariable,
            reserve.currentAverageStableBorrowRate
        );

        reserve.currentLiquidityRate = newLiquidityRate;
        reserve.currentStableBorrowRate = newStableRate;
        reserve.currentVariableBorrowRate = newVariableRate;

        //solium-disable-next-line
        reserve.lastUpdateTimestamp = uint40(block.timestamp);

        emit ReserveUpdated(
            _reserve,
            newLiquidityRate,
            newStableRate,
            newVariableRate,
            reserve.lastLiquidityCumulativeIndex,
            reserve.lastVariableBorrowCumulativeIndex
        );
    }

    /**
    * @dev transfers to the protocol fees of a flashloan to the fees collection address
    * @param _token the address of the token being transferred
    * @param _amount the amount being transferred
    **/

    function transferFlashLoanProtocolFeeInternal(address _token, uint256 _amount) internal {
        address payable receiver = address(uint160(addressesProvider.getTokenDistributor()));

        if (_token != EthAddressLib.ethAddress()) {
            ERC20(_token).safeTransfer(receiver, _amount);
        } else {
            receiver.transfer(_amount);
        }
    }

    /**
    * @dev updates the internal configuration of the core
    **/
    function refreshConfigInternal() internal {
        lendingPoolAddress = addressesProvider.getLendingPool();
    }

    /**
    * @dev adds a reserve to the array of the reserves address
    **/
    function addReserveToListInternal(address _reserve) internal {
        bool reserveAlreadyAdded = false;
        for (uint256 i = 0; i < reservesList.length; i++)
            if (reservesList[i] == _reserve) {
                reserveAlreadyAdded = true;
            }
        if (!reserveAlreadyAdded) reservesList.push(_reserve);
    }

}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-01-09 04:31:56 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 04:31:56 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 14469
completion_tokens: 645
total_tokens: 15114
cost: $-1.000000


[2024-01-09 04:31:56 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: pragma solidity ^0.5.0;

import "openzeppelin-solidity/contracts/math/SafeMath.sol";
import "openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol";
import "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol";
import "openzeppelin-solidity/contracts/utils/Address.sol";
import "../libraries/openzeppelin-upgradeability/VersionedInitializable.sol";

import "../libraries/CoreLibrary.sol";
import "../configuration/LendingPoolAddressesProvider.sol";
import "../interfaces/ILendingRateOracle.sol";
import "../interfaces/IReserveInterestRateStrategy.sol";
import "../libraries/WadRayMath.sol";
import "../tokenization/AToken.sol";
import "../libraries/EthAddressLib.sol";

/**
* @title LendingPoolCore contract
* @author Aave
* @notice Holds the state of the lending pool and all the funds deposited
* @dev NOTE: The core does not enforce security checks on the update of the state
* (eg, updateStateOnBorrow() does not enforce that borrowed is enabled on the reserve).
* The check that an action can be performed is a duty of the overlying LendingPool contract.
**/

contract LendingPoolCore is VersionedInitializable {
    using SafeMath for uint256;
    using WadRayMath for uint256;
    using CoreLibrary for CoreLibrary.ReserveData;
    using CoreLibrary for CoreLibrary.UserReserveData;
    using SafeERC20 for ERC20;
    using Address for address payable;

    /**
    * @dev Emitted when the state of a reserve is updated
    * @param reserve the address of the reserve
    * @param liquidityRate the new liquidity rate
    * @param stableBorrowRate the new stable borrow rate
    * @param variableBorrowRate the new variable borrow rate
    * @param liquidityIndex the new liquidity index
    * @param variableBorrowIndex the new variable borrow index
    **/
    event ReserveUpdated(
        address indexed reserve,
        uint256 liquidityRate,
        uint256 stableBorrowRate,
        uint256 variableBorrowRate,
        uint256 liquidityIndex,
        uint256 variableBorrowIndex
    );

    address public lendingPoolAddress;

    LendingPoolAddressesProvider public addressesProvider;

    /**
    * @dev only lending pools can use functions affected by this modifier
    **/
    modifier onlyLendingPool {
        require(lendingPoolAddress == msg.sender, "The caller must be a lending pool contract");
        _;
    }

    /**
    * @dev only lending pools configurator can use functions affected by this modifier
    **/
    modifier onlyLendingPoolConfigurator {
        require(
            addressesProvider.getLendingPoolConfigurator() == msg.sender,
            "The caller must be a lending pool configurator contract"
        );
        _;
    }

    mapping(address => CoreLibrary.ReserveData) internal reserves;
    mapping(address => mapping(address => CoreLibrary.UserReserveData)) internal usersReserveData;

    address[] public reservesList;

    uint256 public constant CORE_REVISION = 0x4;

    /**
    * @dev returns the revision number of the contract
    **/
    function getRevision() internal pure returns (uint256) {
        return CORE_REVISION;
    }

    /**
    * @dev initializes the Core contract, invoked upon registration on the AddressesProvider
    * @param _addressesProvider the addressesProvider contract
    **/

    function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {
        addressesProvider = _addressesProvider;
        refreshConfigInternal();
    }

    /**
    * @dev updates the state of the core as a result of a deposit action
    * @param _reserve the address of the reserve in which the deposit is happening
    * @param _user the address of the the user depositing
    * @param _amount the amount being deposited
    * @param _isFirstDeposit true if the user is depositing for the first time
    **/

    function updateStateOnDeposit(
        address _reserve,
        address _user,
        uint256 _amount,
        bool _isFirstDeposit
    ) external onlyLendingPool {
        reserves[_reserve].updateCumulativeIndexes();
        updateReserveInterestRatesAndTimestampInternal(_reserve, _amount, 0);

        if (_isFirstDeposit) {
            //if this is the first deposit of the user, we configure the deposit as enabled to be used as collateral
            setUserUseReserveAsCollateral(_reserve, _user, true);
        }
    }

    /**
    * @dev updates the state of the core as a result of a redeem action
    * @param _reserve the address of the reserve in which the redeem is happening
    * @param _user the address of the the user redeeming
    * @param _amountRedeemed the amount being redeemed
    * @param _userRedeemedEverything true if the user is redeeming everything
    **/
    function updateStateOnRedeem(
        address _reserve,
        address _user,
        uint256 _amountRedeemed,
        bool _userRedeemedEverything
    ) external onlyLendingPool {
        //compound liquidity and variable borrow interests
        reserves[_reserve].updateCumulativeIndexes();
        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountRedeemed);

        //if user redeemed everything the useReserveAsCollateral flag is reset
        if (_userRedeemedEverything) {
            setUserUseReserveAsCollateral(_reserve, _user, false);
        }
    }

    /**
    * @dev updates the state of the core as a result of a flashloan action
    * @param _reserve the address of the reserve in which the flashloan is happening
    * @param _income the income of the protocol as a result of the action
    **/
    function updateStateOnFlashLoan(
        address _reserve,
        uint256 _availableLiquidityBefore,
        uint256 _income,
        uint256 _protocolFee
    ) external onlyLendingPool {
        transferFlashLoanProtocolFeeInternal(_reserve, _protocolFee);

        //compounding the cumulated interest
        reserves[_reserve].updateCumulativeIndexes();

        uint256 totalLiquidityBefore = _availableLiquidityBefore.add(
            getReserveTotalBorrows(_reserve)
        );

        //compounding the received fee into the reserve
        reserves[_reserve].cumulateToLiquidityIndex(totalLiquidityBefore, _income);

        //refresh interest rates
        updateReserveInterestRatesAndTimestampInternal(_reserve, _income, 0);
    }

    /**
    * @dev updates the state of the core as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _amountBorrowed the new amount borrowed
    * @param _borrowFee the fee on the amount borrowed
    * @param _rateMode the borrow rate mode (stable, variable)
    * @return the new borrow rate for the user
    **/
    function updateStateOnBorrow(
        address _reserve,
        address _user,
        uint256 _amountBorrowed,
        uint256 _borrowFee,
        CoreLibrary.InterestRateMode _rateMode
    ) external onlyLendingPool returns (uint256, uint256) {
        // getting the previous borrow data of the user
        (uint256 principalBorrowBalance, , uint256 balanceIncrease) = getUserBorrowBalances(
            _reserve,
            _user
        );

        updateReserveStateOnBorrowInternal(
            _reserve,
            _user,
            principalBorrowBalance,
            balanceIncrease,
            _amountBorrowed,
            _rateMode
        );

        updateUserStateOnBorrowInternal(
            _reserve,
            _user,
            _amountBorrowed,
            balanceIncrease,
            _borrowFee,
            _rateMode
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountBorrowed);

        return (getUserCurrentBorrowRate(_reserve, _user), balanceIncrease);
    }

    /**
    * @dev updates the state of the core as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _originationFeeRepaid the fee on the amount that is being repaid
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _repaidWholeLoan true if the user is repaying the whole loan
    **/

    function updateStateOnRepay(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _originationFeeRepaid,
        uint256 _balanceIncrease,
        bool _repaidWholeLoan
    ) external onlyLendingPool {
        updateReserveStateOnRepayInternal(
            _reserve,
            _user,
            _paybackAmountMinusFees,
            _balanceIncrease
        );
        updateUserStateOnRepayInternal(
            _reserve,
            _user,
            _paybackAmountMinusFees,
            _originationFeeRepaid,
            _balanceIncrease,
            _repaidWholeLoan
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, _paybackAmountMinusFees, 0);
    }

    /**
    * @dev updates the state of the core as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the amount borrowed by the user
    * @param _compoundedBorrowBalance the amount borrowed plus accrued interest
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _currentRateMode the current interest rate mode for the user
    **/
    function updateStateOnSwapRate(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _compoundedBorrowBalance,
        uint256 _balanceIncrease,
        CoreLibrary.InterestRateMode _currentRateMode
    ) external onlyLendingPool returns (CoreLibrary.InterestRateMode, uint256) {
        updateReserveStateOnSwapRateInternal(
            _reserve,
            _user,
            _principalBorrowBalance,
            _compoundedBorrowBalance,
            _currentRateMode
        );

        CoreLibrary.InterestRateMode newRateMode = updateUserStateOnSwapRateInternal(
            _reserve,
            _user,
            _balanceIncrease,
            _currentRateMode
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);

        return (newRateMode, getUserCurrentBorrowRate(_reserve, _user));
    }

    /**
    * @dev updates the state of the core as a consequence of a liquidation action.
    * @param _principalReserve the address of the principal reserve that is being repaid
    * @param _collateralReserve the address of the collateral reserve that is being liquidated
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _collateralToLiquidate the amount of collateral being liquidated
    * @param _feeLiquidated the amount of origination fee being liquidated
    * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise
    **/
    function updateStateOnLiquidation(
        address _principalReserve,
        address _collateralReserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _collateralToLiquidate,
        uint256 _feeLiquidated,
        uint256 _liquidatedCollateralForFee,
        uint256 _balanceIncrease,
        bool _liquidatorReceivesAToken
    ) external onlyLendingPool {
        updatePrincipalReserveStateOnLiquidationInternal(
            _principalReserve,
            _user,
            _amountToLiquidate,
            _balanceIncrease
        );

        updateCollateralReserveStateOnLiquidationInternal(
            _collateralReserve
        );

        updateUserStateOnLiquidationInternal(
            _principalReserve,
            _user,
            _amountToLiquidate,
            _feeLiquidated,
            _balanceIncrease
        );

        updateReserveInterestRatesAndTimestampInternal(_principalReserve, _amountToLiquidate, 0);

        if (!_liquidatorReceivesAToken) {
            updateReserveInterestRatesAndTimestampInternal(
                _collateralReserve,
                0,
                _collateralToLiquidate.add(_liquidatedCollateralForFee)
            );
        }

    }

    /**
    * @dev updates the state of the core as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @return the new stable rate for the user
    **/
    function updateStateOnRebalance(address _reserve, address _user, uint256 _balanceIncrease)
    external
    onlyLendingPool
    returns (uint256)
    {
        updateReserveStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);

        //update user data and rebalance the rate
        updateUserStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);
        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);
        return usersReserveData[_user][_reserve].stableBorrowRate;
    }

    /**
    * @dev enables or disables a reserve as collateral
    * @param _reserve the address of the principal reserve where the user deposited
    * @param _user the address of the depositor
    * @param _useAsCollateral true if the depositor wants to use the reserve as collateral
    **/
    function setUserUseReserveAsCollateral(address _reserve, address _user, bool _useAsCollateral)
    public
    onlyLendingPool
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        user.useAsCollateral = _useAsCollateral;
    }

    /**
    * @notice ETH/token transfer functions
    **/

    /**
    * @dev fallback function enforces that the caller is a contract, to support flashloan transfers
    **/
    function() external payable {
        //only contracts can send ETH to the core
        require(msg.sender.isContract(), "Only contracts can send ether to the Lending pool core");

    }

    /**
    * @dev transfers to the user a specific amount from the reserve.
    * @param _reserve the address of the reserve where the transfer is happening
    * @param _user the address of the user receiving the transfer
    * @param _amount the amount being transferred
    **/
    function transferToUser(address _reserve, address payable _user, uint256 _amount)
    external
    onlyLendingPool
    {
        if (_reserve != EthAddressLib.ethAddress()) {
            ERC20(_reserve).safeTransfer(_user, _amount);
        } else {
            //solium-disable-next-line
            (bool result, ) = _user.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers the protocol fees to the fees collection address
    * @param _token the address of the token being transferred
    * @param _user the address of the user from where the transfer is happening
    * @param _amount the amount being transferred
    * @param _destination the fee receiver address
    **/

    function transferToFeeCollectionAddress(
        address _token,
        address _user,
        uint256 _amount,
        address _destination
    ) external payable onlyLendingPool {
        address payable feeAddress = address(uint160(_destination)); //cast the address to payable

        if (_token != EthAddressLib.ethAddress()) {
            require(
                msg.value == 0,
                "User is sending ETH along with the ERC20 transfer. Check the value attribute of the transaction"
            );
            ERC20(_token).safeTransferFrom(_user, feeAddress, _amount);
        } else {
            require(msg.value >= _amount, "The amount and the value sent to deposit do not match");
            //solium-disable-next-line
            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers the fees to the fees collection address in the case of liquidation
    * @param _token the address of the token being transferred
    * @param _amount the amount being transferred
    * @param _destination the fee receiver address
    **/
    function liquidateFee(
        address _token,
        uint256 _amount,
        address _destination
    ) external payable onlyLendingPool {
        address payable feeAddress = address(uint160(_destination)); //cast the address to payable
        require(
            msg.value == 0,
            "Fee liquidation does not require any transfer of value"
        );

        if (_token != EthAddressLib.ethAddress()) {
            ERC20(_token).safeTransfer(feeAddress, _amount);
        } else {
            //solium-disable-next-line
            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers an amount from a user to the destination reserve
    * @param _reserve the address of the reserve where the amount is being transferred
    * @param _user the address of the user from where the transfer is happening
    * @param _amount the amount being transferred
    **/
    function transferToReserve(address _reserve, address payable _user, uint256 _amount)
    external
    payable
    onlyLendingPool
    {
        if (_reserve != EthAddressLib.ethAddress()) {
            require(msg.value == 0, "User is sending ETH along with the ERC20 transfer.");
            ERC20(_reserve).safeTransferFrom(_user, address(this), _amount);

        } else {
            require(msg.value >= _amount, "The amount and the value sent to deposit do not match");

            if (msg.value > _amount) {
                //send back excess ETH
                uint256 excessAmount = msg.value.sub(_amount);
                //solium-disable-next-line
                (bool result, ) = _user.call.value(excessAmount).gas(50000)("");
                require(result, "Transfer of ETH failed");
            }
        }
    }

    /**
    * @notice data access functions
    **/

    /**
    * @dev returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral)
    * needed to calculate the global account data in the LendingPoolDataProvider
    * @param _reserve the address of the reserve
    * @param _user the address of the user
    * @return the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not
    **/
    function getUserBasicReserveData(address _reserve, address _user)
    external
    view
    returns (uint256, uint256, uint256, bool)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        uint256 underlyingBalance = getUserUnderlyingAssetBalance(_reserve, _user);

        if (user.principalBorrowBalance == 0) {
            return (underlyingBalance, 0, 0, user.useAsCollateral);
        }

        return (
        underlyingBalance,
        user.getCompoundedBorrowBalance(reserve),
        user.originationFee,
        user.useAsCollateral
        );
    }

    /**
    * @dev checks if a user is allowed to borrow at a stable rate
    * @param _reserve the reserve address
    * @param _user the user
    * @param _amount the amount the the user wants to borrow
    * @return true if the user is allowed to borrow at a stable rate, false otherwise
    **/

    function isUserAllowedToBorrowAtStable(address _reserve, address _user, uint256 _amount)
    external
    view
    returns (bool)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (!reserve.isStableBorrowRateEnabled) return false;

        return
        !user.useAsCollateral ||
        !reserve.usageAsCollateralEnabled ||
        _amount > getUserUnderlyingAssetBalance(_reserve, _user);
    }

    /**
    * @dev gets the underlying asset balance of a user based on the corresponding aToken balance.
    * @param _reserve the reserve address
    * @param _user the user address
    * @return the underlying deposit balance of the user
    **/

    function getUserUnderlyingAssetBalance(address _reserve, address _user)
    public
    view
    returns (uint256)
    {
        AToken aToken = AToken(reserves[_reserve].aTokenAddress);
        return aToken.balanceOf(_user);

    }

    /**
    * @dev gets the interest rate strategy contract address for the reserve
    * @param _reserve the reserve address
    * @return the address of the interest rate strategy contract
    **/
    function getReserveInterestRateStrategyAddress(address _reserve) public view returns (address) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.interestRateStrategyAddress;
    }

    /**
    * @dev gets the aToken contract address for the reserve
    * @param _reserve the reserve address
    * @return the address of the aToken contract
    **/

    function getReserveATokenAddress(address _reserve) public view returns (address) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.aTokenAddress;
    }

    /**
    * @dev gets the available liquidity in the reserve. The available liquidity is the balance of the core contract
    * @param _reserve the reserve address
    * @return the available liquidity
    **/
    function getReserveAvailableLiquidity(address _reserve) public view returns (uint256) {
        uint256 balance = 0;

        if (_reserve == EthAddressLib.ethAddress()) {
            balance = address(this).balance;
        } else {
            balance = IERC20(_reserve).balanceOf(address(this));
        }
        return balance;
    }

    /**
    * @dev gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows
    * @param _reserve the reserve address
    * @return the total liquidity
    **/
    function getReserveTotalLiquidity(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return getReserveAvailableLiquidity(_reserve).add(reserve.getTotalBorrows());
    }

    /**
    * @dev gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there
    * there has been 100% income.
    * @param _reserve the reserve address
    * @return the reserve normalized income
    **/
    function getReserveNormalizedIncome(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.getNormalizedIncome();
    }

    /**
    * @dev gets the reserve total borrows
    * @param _reserve the reserve address
    * @return the total borrows (stable + variable)
    **/
    function getReserveTotalBorrows(address _reserve) public view returns (uint256) {
        return reserves[_reserve].getTotalBorrows();
    }

    /**
    * @dev gets the reserve total borrows stable
    * @param _reserve the reserve address
    * @return the total borrows stable
    **/
    function getReserveTotalBorrowsStable(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.totalBorrowsStable;
    }

    /**
    * @dev gets the reserve total borrows variable
    * @param _reserve the reserve address
    * @return the total borrows variable
    **/

    function getReserveTotalBorrowsVariable(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.totalBorrowsVariable;
    }

    /**
    * @dev gets the reserve liquidation threshold
    * @param _reserve the reserve address
    * @return the reserve liquidation threshold
    **/

    function getReserveLiquidationThreshold(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.liquidationThreshold;
    }

    /**
    * @dev gets the reserve liquidation bonus
    * @param _reserve the reserve address
    * @return the reserve liquidation bonus
    **/

    function getReserveLiquidationBonus(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.liquidationBonus;
    }

    /**
    * @dev gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty
    * @param _reserve the reserve address
    * @return the reserve current variable borrow rate
    **/

    function getReserveCurrentVariableBorrowRate(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        if (reserve.currentVariableBorrowRate == 0) {
            return
            IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)
            .getBaseVariableBorrowRate();
        }
        return reserve.currentVariableBorrowRate;
    }

    /**
    * @dev gets the reserve current stable borrow rate. Is the market rate if the reserve is empty
    * @param _reserve the reserve address
    * @return the reserve current stable borrow rate
    **/

    function getReserveCurrentStableBorrowRate(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        ILendingRateOracle oracle = ILendingRateOracle(addressesProvider.getLendingRateOracle());

        if (reserve.currentStableBorrowRate == 0) {
            //no stable rate borrows yet
            return oracle.getMarketBorrowRate(_reserve);
        }

        return reserve.currentStableBorrowRate;
    }

    /**
    * @dev gets the reserve average stable borrow rate. The average stable rate is the weighted average
    * of all the loans taken at stable rate.
    * @param _reserve the reserve address
    * @return the reserve current average borrow rate
    **/
    function getReserveCurrentAverageStableBorrowRate(address _reserve)
    external
    view
    returns (uint256)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.currentAverageStableBorrowRate;
    }

    /**
    * @dev gets the reserve liquidity rate
    * @param _reserve the reserve address
    * @return the reserve liquidity rate
    **/
    function getReserveCurrentLiquidityRate(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.currentLiquidityRate;
    }

    /**
    * @dev gets the reserve liquidity cumulative index
    * @param _reserve the reserve address
    * @return the reserve liquidity cumulative index
    **/
    function getReserveLiquidityCumulativeIndex(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.lastLiquidityCumulativeIndex;
    }

    /**
    * @dev gets the reserve variable borrow index
    * @param _reserve the reserve address
    * @return the reserve variable borrow index
    **/
    function getReserveVariableBorrowsCumulativeIndex(address _reserve)
    external
    view
    returns (uint256)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.lastVariableBorrowCumulativeIndex;
    }

    /**
    * @dev this function aggregates the configuration parameters of the reserve.
    * It's used in the LendingPoolDataProvider specifically to save gas, and avoid
    * multiple external contract calls to fetch the same data.
    * @param _reserve the reserve address
    * @return the reserve decimals
    * @return the base ltv as collateral
    * @return the liquidation threshold
    * @return if the reserve is used as collateral or not
    **/
    function getReserveConfiguration(address _reserve)
    external
    view
    returns (uint256, uint256, uint256, bool)
    {
        uint256 decimals;
        uint256 baseLTVasCollateral;
        uint256 liquidationThreshold;
        bool usageAsCollateralEnabled;

        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        decimals = reserve.decimals;
        baseLTVasCollateral = reserve.baseLTVasCollateral;
        liquidationThreshold = reserve.liquidationThreshold;
        usageAsCollateralEnabled = reserve.usageAsCollateralEnabled;

        return (decimals, baseLTVasCollateral, liquidationThreshold, usageAsCollateralEnabled);
    }

    /**
    * @dev returns the decimals of the reserve
    * @param _reserve the reserve address
    * @return the reserve decimals
    **/
    function getReserveDecimals(address _reserve) external view returns (uint256) {
        return reserves[_reserve].decimals;
    }

    /**
    * @dev returns true if the reserve is enabled for borrowing
    * @param _reserve the reserve address
    * @return true if the reserve is enabled for borrowing, false otherwise
    **/

    function isReserveBorrowingEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.borrowingEnabled;
    }

    /**
    * @dev returns true if the reserve is enabled as collateral
    * @param _reserve the reserve address
    * @return true if the reserve is enabled as collateral, false otherwise
    **/

    function isReserveUsageAsCollateralEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.usageAsCollateralEnabled;
    }

    /**
    * @dev returns true if the stable rate is enabled on reserve
    * @param _reserve the reserve address
    * @return true if the stable rate is enabled on reserve, false otherwise
    **/
    function getReserveIsStableBorrowRateEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isStableBorrowRateEnabled;
    }

    /**
    * @dev returns true if the reserve is active
    * @param _reserve the reserve address
    * @return true if the reserve is active, false otherwise
    **/
    function getReserveIsActive(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isActive;
    }

    /**
    * @notice returns if a reserve is freezed
    * @param _reserve the reserve for which the information is needed
    * @return true if the reserve is freezed, false otherwise
    **/

    function getReserveIsFreezed(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isFreezed;
    }

    /**
    * @notice returns the timestamp of the last action on the reserve
    * @param _reserve the reserve for which the information is needed
    * @return the last updated timestamp of the reserve
    **/

    function getReserveLastUpdate(address _reserve) external view returns (uint40 timestamp) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        timestamp = reserve.lastUpdateTimestamp;
    }

    /**
    * @dev returns the utilization rate U of a specific reserve
    * @param _reserve the reserve for which the information is needed
    * @return the utilization rate in ray
    **/

    function getReserveUtilizationRate(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        uint256 totalBorrows = reserve.getTotalBorrows();

        if (totalBorrows == 0) {
            return 0;
        }

        uint256 availableLiquidity = getReserveAvailableLiquidity(_reserve);

        return totalBorrows.rayDiv(availableLiquidity.add(totalBorrows));
    }

    /**
    * @return the array of reserves configured on the core
    **/
    function getReserves() external view returns (address[] memory) {
        return reservesList;
    }

    /**
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return true if the user has chosen to use the reserve as collateral, false otherwise
    **/
    function isUserUseReserveAsCollateralEnabled(address _reserve, address _user)
    external
    view
    returns (bool)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.useAsCollateral;
    }

    /**
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the origination fee for the user
    **/
    function getUserOriginationFee(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.originationFee;
    }

    /**
    * @dev users with no loans in progress have NONE as borrow rate mode
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the borrow rate mode for the user,
    **/

    function getUserCurrentBorrowRateMode(address _reserve, address _user)
    public
    view
    returns (CoreLibrary.InterestRateMode)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (user.principalBorrowBalance == 0) {
            return CoreLibrary.InterestRateMode.NONE;
        }

        return
        user.stableBorrowRate > 0
        ? CoreLibrary.InterestRateMode.STABLE
        : CoreLibrary.InterestRateMode.VARIABLE;
    }

    /**
    * @dev gets the current borrow rate of the user
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the borrow rate for the user,
    **/
    function getUserCurrentBorrowRate(address _reserve, address _user)
    internal
    view
    returns (uint256)
    {
        CoreLibrary.InterestRateMode rateMode = getUserCurrentBorrowRateMode(_reserve, _user);

        if (rateMode == CoreLibrary.InterestRateMode.NONE) {
            return 0;
        }

        return
        rateMode == CoreLibrary.InterestRateMode.STABLE
        ? usersReserveData[_user][_reserve].stableBorrowRate
        : reserves[_reserve].currentVariableBorrowRate;
    }

    /**
    * @dev the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the user stable rate
    **/
    function getUserCurrentStableBorrowRate(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.stableBorrowRate;
    }

    /**
    * @dev calculates and returns the borrow balances of the user
    * @param _reserve the address of the reserve
    * @param _user the address of the user
    * @return the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance
    **/

    function getUserBorrowBalances(address _reserve, address _user)
    public
    view
    returns (uint256, uint256, uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        if (user.principalBorrowBalance == 0) {
            return (0, 0, 0);
        }

        uint256 principal = user.principalBorrowBalance;
        uint256 compoundedBalance = CoreLibrary.getCompoundedBorrowBalance(
            user,
            reserves[_reserve]
        );
        return (principal, compoundedBalance, compoundedBalance.sub(principal));
    }

    /**
    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the variable borrow index for the user
    **/

    function getUserVariableBorrowCumulativeIndex(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.lastVariableBorrowCumulativeIndex;
    }

    /**
    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the variable borrow index for the user
    **/

    function getUserLastUpdate(address _reserve, address _user)
    external
    view
    returns (uint256 timestamp)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        timestamp = user.lastUpdateTimestamp;
    }

    /**
    * @dev updates the lending pool core configuration
    **/
    function refreshConfiguration() external onlyLendingPoolConfigurator {
        refreshConfigInternal();
    }

    /**
    * @dev initializes a reserve
    * @param _reserve the address of the reserve
    * @param _aTokenAddress the address of the overlying aToken contract
    * @param _decimals the decimals of the reserve currency
    * @param _interestRateStrategyAddress the address of the interest rate strategy contract
    **/
    function initReserve(
        address _reserve,
        address _aTokenAddress,
        uint256 _decimals,
        address _interestRateStrategyAddress
    ) external onlyLendingPoolConfigurator {
        reserves[_reserve].init(_aTokenAddress, _decimals, _interestRateStrategyAddress);
        addReserveToListInternal(_reserve);

    }



    /**
    * @dev removes the last added reserve in the reservesList array
    * @param _reserveToRemove the address of the reserve
    **/
    function removeLastAddedReserve(address _reserveToRemove)
    external onlyLendingPoolConfigurator {

        address lastReserve = reservesList[reservesList.length-1];

        require(lastReserve == _reserveToRemove, "Reserve being removed is different than the reserve requested");

        //as we can't check if totalLiquidity is 0 (since the reserve added might not be an ERC20) we at least check that there is nothing borrowed
        require(getReserveTotalBorrows(lastReserve) == 0, "Cannot remove a reserve with liquidity deposited");

        reserves[lastReserve].isActive = false;
        reserves[lastReserve].aTokenAddress = address(0);
        reserves[lastReserve].decimals = 0;
        reserves[lastReserve].lastLiquidityCumulativeIndex = 0;
        reserves[lastReserve].lastVariableBorrowCumulativeIndex = 0;
        reserves[lastReserve].borrowingEnabled = false;
        reserves[lastReserve].usageAsCollateralEnabled = false;
        reserves[lastReserve].baseLTVasCollateral = 0;
        reserves[lastReserve].liquidationThreshold = 0;
        reserves[lastReserve].liquidationBonus = 0;
        reserves[lastReserve].interestRateStrategyAddress = address(0);

        reservesList.pop();
    }

    /**
    * @dev updates the address of the interest rate strategy contract
    * @param _reserve the address of the reserve
    * @param _rateStrategyAddress the address of the interest rate strategy contract
    **/

    function setReserveInterestRateStrategyAddress(address _reserve, address _rateStrategyAddress)
    external
    onlyLendingPoolConfigurator
    {
        reserves[_reserve].interestRateStrategyAddress = _rateStrategyAddress;
    }

    /**
    * @dev enables borrowing on a reserve. Also sets the stable rate borrowing
    * @param _reserve the address of the reserve
    * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise
    **/

    function enableBorrowingOnReserve(address _reserve, bool _stableBorrowRateEnabled)
    external
    onlyLendingPoolConfigurator
    {
        reserves[_reserve].enableBorrowing(_stableBorrowRateEnabled);
    }

    /**
    * @dev disables borrowing on a reserve
    * @param _reserve the address of the reserve
    **/

    function disableBorrowingOnReserve(address _reserve) external onlyLendingPoolConfigurator {
        reserves[_reserve].disableBorrowing();
    }

    /**
    * @dev enables a reserve to be used as collateral
    * @param _reserve the address of the reserve
    **/
    function enableReserveAsCollateral(
        address _reserve,
        uint256 _baseLTVasCollateral,
        uint256 _liquidationThreshold,
        uint256 _liquidationBonus
    ) external onlyLendingPoolConfigurator {
        reserves[_reserve].enableAsCollateral(
            _baseLTVasCollateral,
            _liquidationThreshold,
            _liquidationBonus
        );
    }

    /**
    * @dev disables a reserve to be used as collateral
    * @param _reserve the address of the reserve
    **/
    function disableReserveAsCollateral(address _reserve) external onlyLendingPoolConfigurator {
        reserves[_reserve].disableAsCollateral();
    }

    /**
    * @dev enable the stable borrow rate mode on a reserve
    * @param _reserve the address of the reserve
    **/
    function enableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isStableBorrowRateEnabled = true;
    }

    /**
    * @dev disable the stable borrow rate mode on a reserve
    * @param _reserve the address of the reserve
    **/
    function disableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isStableBorrowRateEnabled = false;
    }

    /**
    * @dev activates a reserve
    * @param _reserve the address of the reserve
    **/
    function activateReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        require(
            reserve.lastLiquidityCumulativeIndex > 0 &&
            reserve.lastVariableBorrowCumulativeIndex > 0,
            "Reserve has not been initialized yet"
        );
        reserve.isActive = true;
    }

    /**
    * @dev deactivates a reserve
    * @param _reserve the address of the reserve
    **/
    function deactivateReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isActive = false;
    }

    /**
    * @notice allows the configurator to freeze the reserve.
    * A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance.
    * @param _reserve the address of the reserve
    **/
    function freezeReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isFreezed = true;
    }

    /**
    * @notice allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed.
    * @param _reserve the address of the reserve
    **/
    function unfreezeReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isFreezed = false;
    }

    /**
    * @notice allows the configurator to update the loan to value of a reserve
    * @param _reserve the address of the reserve
    * @param _ltv the new loan to value
    **/
    function setReserveBaseLTVasCollateral(address _reserve, uint256 _ltv)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.baseLTVasCollateral = _ltv;
    }

    /**
    * @notice allows the configurator to update the liquidation threshold of a reserve
    * @param _reserve the address of the reserve
    * @param _threshold the new liquidation threshold
    **/
    function setReserveLiquidationThreshold(address _reserve, uint256 _threshold)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.liquidationThreshold = _threshold;
    }

    /**
    * @notice allows the configurator to update the liquidation bonus of a reserve
    * @param _reserve the address of the reserve
    * @param _bonus the new liquidation bonus
    **/
    function setReserveLiquidationBonus(address _reserve, uint256 _bonus)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.liquidationBonus = _bonus;
    }

    /**
    * @notice allows the configurator to update the reserve decimals
    * @param _reserve the address of the reserve
    * @param _decimals the decimals of the reserve
    **/
    function setReserveDecimals(address _reserve, uint256 _decimals)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.decimals = _decimals;
    }

    /**
    * @notice internal functions
    **/

    /**
    * @dev updates the state of a reserve as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the previous borrow balance of the borrower before the action
    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount
    * @param _amountBorrowed the new amount borrowed
    * @param _rateMode the borrow rate mode (stable, variable)
    **/

    function updateReserveStateOnBorrowInternal(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _balanceIncrease,
        uint256 _amountBorrowed,
        CoreLibrary.InterestRateMode _rateMode
    ) internal {
        reserves[_reserve].updateCumulativeIndexes();

        //increasing reserve total borrows to account for the new borrow balance of the user
        //NOTE: Depending on the previous borrow mode, the borrows might need to be switched from variable to stable or vice versa

        updateReserveTotalBorrowsByRateModeInternal(
            _reserve,
            _user,
            _principalBorrowBalance,
            _balanceIncrease,
            _amountBorrowed,
            _rateMode
        );
    }

    /**
    * @dev updates the state of a user as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _amountBorrowed the amount borrowed
    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount
    * @param _rateMode the borrow rate mode (stable, variable)
    * @return the final borrow rate for the user. Emitted by the borrow() event
    **/

    function updateUserStateOnBorrowInternal(
        address _reserve,
        address _user,
        uint256 _amountBorrowed,
        uint256 _balanceIncrease,
        uint256 _fee,
        CoreLibrary.InterestRateMode _rateMode
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (_rateMode == CoreLibrary.InterestRateMode.STABLE) {
            //stable
            //reset the user variable index, and update the stable rate
            user.stableBorrowRate = reserve.currentStableBorrowRate;
            user.lastVariableBorrowCumulativeIndex = 0;
        } else if (_rateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //variable
            //reset the user stable rate, and store the new borrow index
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        } else {
            revert("Invalid borrow rate mode");
        }
        //increase the principal borrows and the origination fee
        user.principalBorrowBalance = user.principalBorrowBalance.add(_amountBorrowed).add(
            _balanceIncrease
        );
        user.originationFee = user.originationFee.add(_fee);

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

    }

    /**
    * @dev updates the state of the reserve as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateReserveStateOnRepayInternal(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_reserve][_user];

        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(_reserve, _user);

        //update the indexes
        reserves[_reserve].updateCumulativeIndexes();

        //compound the cumulated interest to the borrow balance and then subtracting the payback amount
        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _balanceIncrease,
                user.stableBorrowRate
            );
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _paybackAmountMinusFees,
                user.stableBorrowRate
            );
        } else {
            reserve.increaseTotalBorrowsVariable(_balanceIncrease);
            reserve.decreaseTotalBorrowsVariable(_paybackAmountMinusFees);
        }
    }

    /**
    * @dev updates the state of the user as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _originationFeeRepaid the fee on the amount that is being repaid
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _repaidWholeLoan true if the user is repaying the whole loan
    **/
    function updateUserStateOnRepayInternal(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _originationFeeRepaid,
        uint256 _balanceIncrease,
        bool _repaidWholeLoan
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        //update the user principal borrow balance, adding the cumulated interest and then subtracting the payback amount
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(
            _paybackAmountMinusFees
        );
        user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;

        //if the balance decrease is equal to the previous principal (user is repaying the whole loan)
        //and the rate mode is stable, we reset the interest rate mode of the user
        if (_repaidWholeLoan) {
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = 0;
        }
        user.originationFee = user.originationFee.sub(_originationFeeRepaid);

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

    }

    /**
    * @dev updates the state of the user as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is performing the rate swap
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the the principal amount borrowed by the user
    * @param _compoundedBorrowBalance the principal amount plus the accrued interest
    * @param _currentRateMode the rate mode at which the user borrowed
    **/
    function updateReserveStateOnSwapRateInternal(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _compoundedBorrowBalance,
        CoreLibrary.InterestRateMode _currentRateMode
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        //compounding reserve indexes
        reserve.updateCumulativeIndexes();

        if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {
            uint256 userCurrentStableRate = user.stableBorrowRate;

            //swap to variable
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _principalBorrowBalance,
                userCurrentStableRate
            ); //decreasing stable from old principal balance
            reserve.increaseTotalBorrowsVariable(_compoundedBorrowBalance); //increase variable borrows
        } else if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //swap to stable
            uint256 currentStableRate = reserve.currentStableBorrowRate;
            reserve.decreaseTotalBorrowsVariable(_principalBorrowBalance);
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _compoundedBorrowBalance,
                currentStableRate
            );

        } else {
            revert("Invalid rate mode received");
        }
    }

    /**
    * @dev updates the state of the user as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is performing the swap
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _currentRateMode the current rate mode of the user
    **/

    function updateUserStateOnSwapRateInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease,
        CoreLibrary.InterestRateMode _currentRateMode
    ) internal returns (CoreLibrary.InterestRateMode) {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        CoreLibrary.InterestRateMode newMode = CoreLibrary.InterestRateMode.NONE;

        if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //switch to stable
            newMode = CoreLibrary.InterestRateMode.STABLE;
            user.stableBorrowRate = reserve.currentStableBorrowRate;
            user.lastVariableBorrowCumulativeIndex = 0;
        } else if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {
            newMode = CoreLibrary.InterestRateMode.VARIABLE;
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        } else {
            revert("Invalid interest rate mode received");
        }
        //compounding cumulated interest
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);
        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

        return newMode;
    }

    /**
    * @dev updates the state of the principal reserve as a consequence of a liquidation action.
    * @param _principalReserve the address of the principal reserve that is being repaid
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updatePrincipalReserveStateOnLiquidationInternal(
        address _principalReserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_principalReserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_principalReserve];

        //update principal reserve data
        reserve.updateCumulativeIndexes();

        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(
            _principalReserve,
            _user
        );

        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            //increase the total borrows by the compounded interest
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _balanceIncrease,
                user.stableBorrowRate
            );

            //decrease by the actual amount to liquidate
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _amountToLiquidate,
                user.stableBorrowRate
            );

        } else {
            //increase the total borrows by the compounded interest
            reserve.increaseTotalBorrowsVariable(_balanceIncrease);

            //decrease by the actual amount to liquidate
            reserve.decreaseTotalBorrowsVariable(_amountToLiquidate);
        }

    }

    /**
    * @dev updates the state of the collateral reserve as a consequence of a liquidation action.
    * @param _collateralReserve the address of the collateral reserve that is being liquidated
    **/
    function updateCollateralReserveStateOnLiquidationInternal(
        address _collateralReserve
    ) internal {
        //update collateral reserve
        reserves[_collateralReserve].updateCumulativeIndexes();

    }

    /**
    * @dev updates the state of the user being liquidated as a consequence of a liquidation action.
    * @param _reserve the address of the principal reserve that is being repaid
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _feeLiquidated the amount of origination fee being liquidated
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/
    function updateUserStateOnLiquidationInternal(
        address _reserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _feeLiquidated,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        //first increase by the compounded interest, then decrease by the liquidated amount
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(
            _amountToLiquidate
        );

        if (
            getUserCurrentBorrowRateMode(_reserve, _user) == CoreLibrary.InterestRateMode.VARIABLE
        ) {
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        }

        if(_feeLiquidated > 0){
            user.originationFee = user.originationFee.sub(_feeLiquidated);
        }

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);
    }

    /**
    * @dev updates the state of the reserve as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateReserveStateOnRebalanceInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        reserve.updateCumulativeIndexes();

        reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
            _balanceIncrease,
            user.stableBorrowRate
        );

    }

    /**
    * @dev updates the state of the user as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateUserStateOnRebalanceInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);
        user.stableBorrowRate = reserve.currentStableBorrowRate;

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);
    }

    /**
    * @dev updates the state of the user as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _amountBorrowed the accrued interest on the borrowed amount
    **/
    function updateReserveTotalBorrowsByRateModeInternal(
        address _reserve,
        address _user,
        uint256 _principalBalance,
        uint256 _balanceIncrease,
        uint256 _amountBorrowed,
        CoreLibrary.InterestRateMode _newBorrowRateMode
    ) internal {
        CoreLibrary.InterestRateMode previousRateMode = getUserCurrentBorrowRateMode(
            _reserve,
            _user
        );
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        if (previousRateMode == CoreLibrary.InterestRateMode.STABLE) {
            CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _principalBalance,
                user.stableBorrowRate
            );
        } else if (previousRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            reserve.decreaseTotalBorrowsVariable(_principalBalance);
        }

        uint256 newPrincipalAmount = _principalBalance.add(_balanceIncrease).add(_amountBorrowed);
        if (_newBorrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                newPrincipalAmount,
                reserve.currentStableBorrowRate
            );
        } else if (_newBorrowRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            reserve.increaseTotalBorrowsVariable(newPrincipalAmount);
        } else {
            revert("Invalid new borrow rate mode");
        }
    }

    /**
    * @dev Updates the reserve current stable borrow rate Rf, the current variable borrow rate Rv and the current liquidity rate Rl.
    * Also updates the lastUpdateTimestamp value. Please refer to the whitepaper for further information.
    * @param _reserve the address of the reserve to be updated
    * @param _liquidityAdded the amount of liquidity added to the protocol (deposit or repay) in the previous action
    * @param _liquidityTaken the amount of liquidity taken from the protocol (redeem or borrow)
    **/

    function updateReserveInterestRatesAndTimestampInternal(
        address _reserve,
        uint256 _liquidityAdded,
        uint256 _liquidityTaken
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        (uint256 newLiquidityRate, uint256 newStableRate, uint256 newVariableRate) = IReserveInterestRateStrategy(
            reserve
            .interestRateStrategyAddress
        )
        .calculateInterestRates(
            _reserve,
            getReserveAvailableLiquidity(_reserve).add(_liquidityAdded).sub(_liquidityTaken),
            reserve.totalBorrowsStable,
            reserve.totalBorrowsVariable,
            reserve.currentAverageStableBorrowRate
        );

        reserve.currentLiquidityRate = newLiquidityRate;
        reserve.currentStableBorrowRate = newStableRate;
        reserve.currentVariableBorrowRate = newVariableRate;

        //solium-disable-next-line
        reserve.lastUpdateTimestamp = uint40(block.timestamp);

        emit ReserveUpdated(
            _reserve,
            newLiquidityRate,
            newStableRate,
            newVariableRate,
            reserve.lastLiquidityCumulativeIndex,
            reserve.lastVariableBorrowCumulativeIndex
        );
    }

    /**
    * @dev transfers to the protocol fees of a flashloan to the fees collection address
    * @param _token the address of the token being transferred
    * @param _amount the amount being transferred
    **/

    function transferFlashLoanProtocolFeeInternal(address _token, uint256 _amount) internal {
        address payable receiver = address(uint160(addressesProvider.getTokenDistributor()));

        if (_token != EthAddressLib.ethAddress()) {
            ERC20(_token).safeTransfer(receiver, _amount);
        } else {
            receiver.transfer(_amount);
        }
    }

    /**
    * @dev updates the internal configuration of the core
    **/
    function refreshConfigInternal() internal {
        lendingPoolAddress = addressesProvider.getLendingPool();
    }

    /**
    * @dev adds a reserve to the array of the reserves address
    **/
    function addReserveToListInternal(address _reserve) internal {
        bool reserveAlreadyAdded = false;
        for (uint256 i = 0; i < reservesList.length; i++)
            if (reservesList[i] == _reserve) {
                reserveAlreadyAdded = true;
            }
        if (!reserveAlreadyAdded) reservesList.push(_reserve);
    }

}
.]

### Summary of Security Vulnerabilities in the LendingPoolCore Contract

1. **Lack of Input Validation**: 
   - The contract does not perform sufficient input validation on parameters in various functions, which could lead to unexpected behaviors or vulnerabilities.

2. **Reentrancy Vulnerability**: 
   - Functions that transfer ETH or tokens (e.g., `transferToUser`, `transferToFeeCollectionAddress`, `liquidateFee`, etc.) could be susceptible to reentrancy attacks if not properly guarded. Although the contract uses `SafeERC20`, it does not implement a reentrancy guard.

3. **Access Control Issues**:
   - The `onlyLendingPool` and `onlyLendingPoolConfigurator` modifiers are used to restrict access to certain functions. However, if the lending pool address or configurator address is compromised, it could lead to unauthorized access to critical functions.

4. **Gas Limit and Loops**:
   - The `addReserveToListInternal` function checks if a reserve is already added by iterating through the `reservesList`. This could lead to high gas costs and potential failures if the list grows large.

5. **Fallback Function**:
   - The fallback function only allows contracts to send ETH to the core. If a malicious contract calls this function, it could lead to unexpected behavior or denial of service.

6. **Timestamp Dependency**:
   - The contract relies on block timestamps in several functions (e.g., `lastUpdateTimestamp`). This could be manipulated by miners, leading to potential exploitation.

7. **Lack of Proper Error Handling**:
   - The contract uses `require` statements for error handling, but there are instances where more descriptive error messages could provide better context for debugging.

8. **Potential for Integer Overflow/Underflow**:
   - Although the contract uses `SafeMath`, there are still areas where integer overflow/underflow could occur if not properly handled, especially in arithmetic operations.

9. **Uninitialized Variables**:
   - Certain state variables may not be initialized properly, leading to unexpected behaviors if accessed before being set.

### Comprehensive Analysis Report

The `LendingPoolCore` contract exhibits several security vulnerabilities that could be exploited by malicious actors. The lack of input validation and reentrancy protections are particularly concerning, as they could lead to significant financial losses. Access control mechanisms, while present, rely heavily on the integrity of the lending pool and configurator addresses, which, if compromised, could allow unauthorized access to critical functions.

The gas consumption issues due to looping through reserves could lead to denial of service, especially as the number of reserves increases. Additionally, the reliance on block timestamps introduces a potential attack vector that could be exploited by miners.

Overall, while the contract employs some best practices, such as using `SafeERC20` and `SafeMath`, it requires further enhancements in input validation, access control, and error handling to mitigate the identified vulnerabilities. A thorough review and testing phase, including the implementation of reentrancy guards and gas optimization strategies, is recommended before deployment. Additionally, conducting a formal audit by a specialized security team would provide further assurance of the contract's security posture.

[2024-01-09 04:31:56 INFO] **[Seminar Conclusion]**:

 ### Summary of Security Vulnerabilities in the LendingPoolCore Contract

1. **Lack of Input Validation**: 
   - The contract does not perform sufficient input validation on parameters in various functions, which could lead to unexpected behaviors or vulnerabilities.

2. **Reentrancy Vulnerability**: 
   - Functions that transfer ETH or tokens (e.g., `transferToUser`, `transferToFeeCollectionAddress`, `liquidateFee`, etc.) could be susceptible to reentrancy attacks if not properly guarded. Although the contract uses `SafeERC20`, it does not implement a reentrancy guard.

3. **Access Control Issues**:
   - The `onlyLendingPool` and `onlyLendingPoolConfigurator` modifiers are used to restrict access to certain functions. However, if the lending pool address or configurator address is compromised, it could lead to unauthorized access to critical functions.

4. **Gas Limit and Loops**:
   - The `addReserveToListInternal` function checks if a reserve is already added by iterating through the `reservesList`. This could lead to high gas costs and potential failures if the list grows large.

5. **Fallback Function**:
   - The fallback function only allows contracts to send ETH to the core. If a malicious contract calls this function, it could lead to unexpected behavior or denial of service.

6. **Timestamp Dependency**:
   - The contract relies on block timestamps in several functions (e.g., `lastUpdateTimestamp`). This could be manipulated by miners, leading to potential exploitation.

7. **Lack of Proper Error Handling**:
   - The contract uses `require` statements for error handling, but there are instances where more descriptive error messages could provide better context for debugging.

8. **Potential for Integer Overflow/Underflow**:
   - Although the contract uses `SafeMath`, there are still areas where integer overflow/underflow could occur if not properly handled, especially in arithmetic operations.

9. **Uninitialized Variables**:
   - Certain state variables may not be initialized properly, leading to unexpected behaviors if accessed before being set.

### Comprehensive Analysis Report

The `LendingPoolCore` contract exhibits several security vulnerabilities that could be exploited by malicious actors. The lack of input validation and reentrancy protections are particularly concerning, as they could lead to significant financial losses. Access control mechanisms, while present, rely heavily on the integrity of the lending pool and configurator addresses, which, if compromised, could allow unauthorized access to critical functions.

The gas consumption issues due to looping through reserves could lead to denial of service, especially as the number of reserves increases. Additionally, the reliance on block timestamps introduces a potential attack vector that could be exploited by miners.

Overall, while the contract employs some best practices, such as using `SafeERC20` and `SafeMath`, it requires further enhancements in input validation, access control, and error handling to mitigate the identified vulnerabilities. A thorough review and testing phase, including the implementation of reentrancy guards and gas optimization strategies, is recommended before deployment. Additionally, conducting a formal audit by a specialized security team would provide further assurance of the contract's security posture.

[2024-01-09 04:31:56 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 3

[2024-01-09 04:31:57 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | pragma solidity ^0.5.0; import "openzeppelin-solidity/contracts/math/SafeMath.sol"; import "openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol"; import "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol"; import "openzeppelin-solidity/contracts/utils/Address.sol"; import "../libraries/openzeppelin-upgradeability/VersionedInitializable.sol"; import "../libraries/CoreLibrary.sol"; import "../configuration/LendingPoolAddressesProvider.sol"; import "../interfaces/ILendingRateOracle.sol"; import "../interfaces/IReserveInterestRateStrategy.sol"; import "../libraries/WadRayMath.sol"; import "../tokenization/AToken.sol"; import "../libraries/EthAddressLib.sol"; / * @title LendingPoolCore contract * @author Aave * @notice Holds the state of the lending pool and all the funds deposited * @dev NOTE: The core does not enforce security checks on the update of the state * (eg, updateStateOnBorrow() does not enforce that borrowed is enabled on the reserve). * The check that an action can be performed is a duty of the overlying LendingPool contract. / contract LendingPoolCore is VersionedInitializable {     using SafeMath for uint256;     using WadRayMath for uint256;     using CoreLibrary for CoreLibrary.ReserveData;     using CoreLibrary for CoreLibrary.UserReserveData;     using SafeERC20 for ERC20;     using Address for address payable; /** * @dev Emitted when the state of a reserve is updated * @param reserve the address of the reserve * @param liquidityRate the new liquidity rate * @param stableBorrowRate the new stable borrow rate * @param variableBorrowRate the new variable borrow rate * @param liquidityIndex the new liquidity index * @param variableBorrowIndex the new variable borrow index **/ event ReserveUpdated(     address indexed reserve,     uint256 liquidityRate,     uint256 stableBorrowRate,     uint256 variableBorrowRate,     uint256 liquidityIndex,     uint256 variableBorrowIndex );  address public lendingPoolAddress;  LendingPoolAddressesProvider public addressesProvider;  /** * @dev only lending pools can use functions affected by this modifier **/ modifier onlyLendingPool {     require(lendingPoolAddress == msg.sender, "The caller must be a lending pool contract");     _; }  /** * @dev only lending pools configurator can use functions affected by this modifier **/ modifier onlyLendingPoolConfigurator {     require(         addressesProvider.getLendingPoolConfigurator() == msg.sender,         "The caller must be a lending pool configurator contract"     );     _; }  mapping(address =&gt; CoreLibrary.ReserveData) internal reserves; mapping(address =&gt; mapping(address =&gt; CoreLibrary.UserReserveData)) internal usersReserveData;  address[] public reservesList;  uint256 public constant CORE_REVISION = 0x4;  /** * @dev returns the revision number of the contract **/ function getRevision() internal pure returns (uint256) {     return CORE_REVISION; }  /** * @dev initializes the Core contract, invoked upon registration on the AddressesProvider * @param _addressesProvider the addressesProvider contract **/  function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {     addressesProvider = _addressesProvider;     refreshConfigInternal(); }  /** * @dev updates the state of the core as a result of a deposit action * @param _reserve the address of the reserve in which the deposit is happening * @param _user the address of the the user depositing * @param _amount the amount being deposited * @param _isFirstDeposit true if the user is depositing for the first time **/  function updateStateOnDeposit(     address _reserve,     address _user,     uint256 _amount,     bool _isFirstDeposit ) external onlyLendingPool {     reserves[_reserve].updateCumulativeIndexes();     updateReserveInterestRatesAndTimestampInternal(_reserve, _amount, 0);      if (_isFirstDeposit) {         //if this is the first deposit of the user, we configure the deposit as enabled to be used as collateral         setUserUseReserveAsCollateral(_reserve, _user, true);     } }  /** * @dev updates the state of the core as a result of a redeem action * @param _reserve the address of the reserve in which the redeem is happening * @param _user the address of the the user redeeming * @param _amountRedeemed the amount being redeemed * @param _userRedeemedEverything true if the user is redeeming everything **/ function updateStateOnRedeem(     address _reserve,     address _user,     uint256 _amountRedeemed,     bool _userRedeemedEverything ) external onlyLendingPool {     //compound liquidity and variable borrow interests     reserves[_reserve].updateCumulativeIndexes();     updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountRedeemed);      //if user redeemed everything the useReserveAsCollateral flag is reset     if (_userRedeemedEverything) {         setUserUseReserveAsCollateral(_reserve, _user, false);     } }  /** * @dev updates the state of the core as a result of a flashloan action * @param _reserve the address of the reserve in which the flashloan is happening * @param _income the income of the protocol as a result of the action **/ function updateStateOnFlashLoan(     address _reserve,     uint256 _availableLiquidityBefore,     uint256 _income,     uint256 _protocolFee ) external onlyLendingPool {     transferFlashLoanProtocolFeeInternal(_reserve, _protocolFee);      //compounding the cumulated interest     reserves[_reserve].updateCumulativeIndexes();      uint256 totalLiquidityBefore = _availableLiquidityBefore.add(         getReserveTotalBorrows(_reserve)     );      //compounding the received fee into the reserve     reserves[_reserve].cumulateToLiquidityIndex(totalLiquidityBefore, _income);      //refresh interest rates     updateReserveInterestRatesAndTimestampInternal(_reserve, _income, 0); }  /** * @dev updates the state of the core as a consequence of a borrow action. * @param _reserve the address of the reserve on which the user is borrowing * @param _user the address of the borrower * @param _amountBorrowed the new amount borrowed * @param _borrowFee the fee on the amount borrowed * @param _rateMode the borrow rate mode (stable, variable) * @return the new borrow rate for the user **/ function updateStateOnBorrow(     address _reserve,     address _user,     uint256 _amountBorrowed,     uint256 _borrowFee,     CoreLibrary.InterestRateMode _rateMode ) external onlyLendingPool returns (uint256, uint256) {     // getting the previous borrow data of the user     (uint256 principalBorrowBalance, , uint256 balanceIncrease) = getUserBorrowBalances(         _reserve,         _user     );      updateReserveStateOnBorrowInternal(         _reserve,         _user,         principalBorrowBalance,         balanceIncrease,         _amountBorrowed,         _rateMode     );      updateUserStateOnBorrowInternal(         _reserve,         _user,         _amountBorrowed,         balanceIncrease,         _borrowFee,         _rateMode     );      updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountBorrowed);      return (getUserCurrentBorrowRate(_reserve, _user), balanceIncrease); }  /** * @dev updates the state of the core as a consequence of a repay action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _paybackAmountMinusFees the amount being paid back minus fees * @param _originationFeeRepaid the fee on the amount that is being repaid * @param _balanceIncrease the accrued interest on the borrowed amount * @param _repaidWholeLoan true if the user is repaying the whole loan **/  function updateStateOnRepay(     address _reserve,     address _user,     uint256 _paybackAmountMinusFees,     uint256 _originationFeeRepaid,     uint256 _balanceIncrease,     bool _repaidWholeLoan ) external onlyLendingPool {     updateReserveStateOnRepayInternal(         _reserve,         _user,         _paybackAmountMinusFees,         _balanceIncrease     );     updateUserStateOnRepayInternal(         _reserve,         _user,         _paybackAmountMinusFees,         _originationFeeRepaid,         _balanceIncrease,         _repaidWholeLoan     );      updateReserveInterestRatesAndTimestampInternal(_reserve, _paybackAmountMinusFees, 0); }  /** * @dev updates the state of the core as a consequence of a swap rate action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _principalBorrowBalance the amount borrowed by the user * @param _compoundedBorrowBalance the amount borrowed plus accrued interest * @param _balanceIncrease the accrued interest on the borrowed amount * @param _currentRateMode the current interest rate mode for the user **/ function updateStateOnSwapRate(     address _reserve,     address _user,     uint256 _principalBorrowBalance,     uint256 _compoundedBorrowBalance,     uint256 _balanceIncrease,     CoreLibrary.InterestRateMode _currentRateMode ) external onlyLendingPool returns (CoreLibrary.InterestRateMode, uint256) {     updateReserveStateOnSwapRateInternal(         _reserve,         _user,         _principalBorrowBalance,         _compoundedBorrowBalance,         _currentRateMode     );      CoreLibrary.InterestRateMode newRateMode = updateUserStateOnSwapRateInternal(         _reserve,         _user,         _balanceIncrease,         _currentRateMode     );      updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);      return (newRateMode, getUserCurrentBorrowRate(_reserve, _user)); }  /** * @dev updates the state of the core as a consequence of a liquidation action. * @param _principalReserve the address of the principal reserve that is being repaid * @param _collateralReserve the address of the collateral reserve that is being liquidated * @param _user the address of the borrower * @param _amountToLiquidate the amount being repaid by the liquidator * @param _collateralToLiquidate the amount of collateral being liquidated * @param _feeLiquidated the amount of origination fee being liquidated * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus * @param _balanceIncrease the accrued interest on the borrowed amount * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise **/ function updateStateOnLiquidation(     address _principalReserve,     address _collateralReserve,     address _user,     uint256 _amountToLiquidate,     uint256 _collateralToLiquidate,     uint256 _feeLiquidated,     uint256 _liquidatedCollateralForFee,     uint256 _balanceIncrease,     bool _liquidatorReceivesAToken ) external onlyLendingPool {     updatePrincipalReserveStateOnLiquidationInternal(         _principalReserve,         _user,         _amountToLiquidate,         _balanceIncrease     );      updateCollateralReserveStateOnLiquidationInternal(         _collateralReserve     );      updateUserStateOnLiquidationInternal(         _principalReserve,         _user,         _amountToLiquidate,         _feeLiquidated,         _balanceIncrease     );      updateReserveInterestRatesAndTimestampInternal(_principalReserve, _amountToLiquidate, 0);      if (!_liquidatorReceivesAToken) {         updateReserveInterestRatesAndTimestampInternal(             _collateralReserve,             0,             _collateralToLiquidate.add(_liquidatedCollateralForFee)         );     }  }  /** * @dev updates the state of the core as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount * @return the new stable rate for the user **/ function updateStateOnRebalance(address _reserve, address _user, uint256 _balanceIncrease) external onlyLendingPool returns (uint256) {     updateReserveStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);      //update user data and rebalance the rate     updateUserStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);     updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);     return usersReserveData[_user][_reserve].stableBorrowRate; }  /** * @dev enables or disables a reserve as collateral * @param _reserve the address of the principal reserve where the user deposited * @param _user the address of the depositor * @param _useAsCollateral true if the depositor wants to use the reserve as collateral **/ function setUserUseReserveAsCollateral(address _reserve, address _user, bool _useAsCollateral) public onlyLendingPool {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     user.useAsCollateral = _useAsCollateral; }  /** * @notice ETH/token transfer functions **/  /** * @dev fallback function enforces that the caller is a contract, to support flashloan transfers **/ function() external payable {     //only contracts can send ETH to the core     require(msg.sender.isContract(), "Only contracts can send ether to the Lending pool core");  }  /** * @dev transfers to the user a specific amount from the reserve. * @param _reserve the address of the reserve where the transfer is happening * @param _user the address of the user receiving the transfer * @param _amount the amount being transferred **/ function transferToUser(address _reserve, address payable _user, uint256 _amount) external onlyLendingPool {     if (_reserve != EthAddressLib.ethAddress()) {         ERC20(_reserve).safeTransfer(_user, _amount);     } else {         //solium-disable-next-line         (bool result, ) = _user.call.value(_amount).gas(50000)("");         require(result, "Transfer of ETH failed");     } }  /** * @dev transfers the protocol fees to the fees collection address * @param _token the address of the token being transferred * @param _user the address of the user from where the transfer is happening * @param _amount the amount being transferred * @param _destination the fee receiver address **/  function transferToFeeCollectionAddress(     address _token,     address _user,     uint256 _amount,     address _destination ) external payable onlyLendingPool {     address payable feeAddress = address(uint160(_destination)); //cast the address to payable      if (_token != EthAddressLib.ethAddress()) {         require(             msg.value == 0,             "User is sending ETH along with the ERC20 transfer. Check the value attribute of the transaction"         );         ERC20(_token).safeTransferFrom(_user, feeAddress, _amount);     } else {         require(msg.value &gt;= _amount, "The amount and the value sent to deposit do not match");         //solium-disable-next-line         (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");         require(result, "Transfer of ETH failed");     } }  /** * @dev transfers the fees to the fees collection address in the case of liquidation * @param _token the address of the token being transferred * @param _amount the amount being transferred * @param _destination the fee receiver address **/ function liquidateFee(     address _token,     uint256 _amount,     address _destination ) external payable onlyLendingPool {     address payable feeAddress = address(uint160(_destination)); //cast the address to payable     require(         msg.value == 0,         "Fee liquidation does not require any transfer of value"     );      if (_token != EthAddressLib.ethAddress()) {         ERC20(_token).safeTransfer(feeAddress, _amount);     } else {         //solium-disable-next-line         (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");         require(result, "Transfer of ETH failed");     } }  /** * @dev transfers an amount from a user to the destination reserve * @param _reserve the address of the reserve where the amount is being transferred * @param _user the address of the user from where the transfer is happening * @param _amount the amount being transferred **/ function transferToReserve(address _reserve, address payable _user, uint256 _amount) external payable onlyLendingPool {     if (_reserve != EthAddressLib.ethAddress()) {         require(msg.value == 0, "User is sending ETH along with the ERC20 transfer.");         ERC20(_reserve).safeTransferFrom(_user, address(this), _amount);      } else {         require(msg.value &gt;= _amount, "The amount and the value sent to deposit do not match");          if (msg.value &gt; _amount) {             //send back excess ETH             uint256 excessAmount = msg.value.sub(_amount);             //solium-disable-next-line             (bool result, ) = _user.call.value(excessAmount).gas(50000)("");             require(result, "Transfer of ETH failed");         }     } }  /** * @notice data access functions **/  /** * @dev returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral) * needed to calculate the global account data in the LendingPoolDataProvider * @param _reserve the address of the reserve * @param _user the address of the user * @return the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not **/ function getUserBasicReserveData(address _reserve, address _user) external view returns (uint256, uint256, uint256, bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      uint256 underlyingBalance = getUserUnderlyingAssetBalance(_reserve, _user);      if (user.principalBorrowBalance == 0) {         return (underlyingBalance, 0, 0, user.useAsCollateral);     }      return (     underlyingBalance,     user.getCompoundedBorrowBalance(reserve),     user.originationFee,     user.useAsCollateral     ); }  /** * @dev checks if a user is allowed to borrow at a stable rate * @param _reserve the reserve address * @param _user the user * @param _amount the amount the the user wants to borrow * @return true if the user is allowed to borrow at a stable rate, false otherwise **/  function isUserAllowedToBorrowAtStable(address _reserve, address _user, uint256 _amount) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      if (!reserve.isStableBorrowRateEnabled) return false;      return     !user.useAsCollateral ||     !reserve.usageAsCollateralEnabled ||     _amount &gt; getUserUnderlyingAssetBalance(_reserve, _user); }  /** * @dev gets the underlying asset balance of a user based on the corresponding aToken balance. * @param _reserve the reserve address * @param _user the user address * @return the underlying deposit balance of the user **/  function getUserUnderlyingAssetBalance(address _reserve, address _user) public view returns (uint256) {     AToken aToken = AToken(reserves[_reserve].aTokenAddress);     return aToken.balanceOf(_user);  }  /** * @dev gets the interest rate strategy contract address for the reserve * @param _reserve the reserve address * @return the address of the interest rate strategy contract **/ function getReserveInterestRateStrategyAddress(address _reserve) public view returns (address) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.interestRateStrategyAddress; }  /** * @dev gets the aToken contract address for the reserve * @param _reserve the reserve address * @return the address of the aToken contract **/  function getReserveATokenAddress(address _reserve) public view returns (address) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.aTokenAddress; }  /** * @dev gets the available liquidity in the reserve. The available liquidity is the balance of the core contract * @param _reserve the reserve address * @return the available liquidity **/ function getReserveAvailableLiquidity(address _reserve) public view returns (uint256) {     uint256 balance = 0;      if (_reserve == EthAddressLib.ethAddress()) {         balance = address(this).balance;     } else {         balance = IERC20(_reserve).balanceOf(address(this));     }     return balance; }  /** * @dev gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows * @param _reserve the reserve address * @return the total liquidity **/ function getReserveTotalLiquidity(address _reserve) public view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return getReserveAvailableLiquidity(_reserve).add(reserve.getTotalBorrows()); }  /** * @dev gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there * there has been 100% income. * @param _reserve the reserve address * @return the reserve normalized income **/ function getReserveNormalizedIncome(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.getNormalizedIncome(); }  /** * @dev gets the reserve total borrows * @param _reserve the reserve address * @return the total borrows (stable + variable) **/ function getReserveTotalBorrows(address _reserve) public view returns (uint256) {     return reserves[_reserve].getTotalBorrows(); }  /** * @dev gets the reserve total borrows stable * @param _reserve the reserve address * @return the total borrows stable **/ function getReserveTotalBorrowsStable(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.totalBorrowsStable; }  /** * @dev gets the reserve total borrows variable * @param _reserve the reserve address * @return the total borrows variable **/  function getReserveTotalBorrowsVariable(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.totalBorrowsVariable; }  /** * @dev gets the reserve liquidation threshold * @param _reserve the reserve address * @return the reserve liquidation threshold **/  function getReserveLiquidationThreshold(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.liquidationThreshold; }  /** * @dev gets the reserve liquidation bonus * @param _reserve the reserve address * @return the reserve liquidation bonus **/  function getReserveLiquidationBonus(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.liquidationBonus; }  /** * @dev gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty * @param _reserve the reserve address * @return the reserve current variable borrow rate **/  function getReserveCurrentVariableBorrowRate(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      if (reserve.currentVariableBorrowRate == 0) {         return         IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)         .getBaseVariableBorrowRate();     }     return reserve.currentVariableBorrowRate; }  /** * @dev gets the reserve current stable borrow rate. Is the market rate if the reserve is empty * @param _reserve the reserve address * @return the reserve current stable borrow rate **/  function getReserveCurrentStableBorrowRate(address _reserve) public view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     ILendingRateOracle oracle = ILendingRateOracle(addressesProvider.getLendingRateOracle());      if (reserve.currentStableBorrowRate == 0) {         //no stable rate borrows yet         return oracle.getMarketBorrowRate(_reserve);     }      return reserve.currentStableBorrowRate; }  /** * @dev gets the reserve average stable borrow rate. The average stable rate is the weighted average * of all the loans taken at stable rate. * @param _reserve the reserve address * @return the reserve current average borrow rate **/ function getReserveCurrentAverageStableBorrowRate(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.currentAverageStableBorrowRate; }  /** * @dev gets the reserve liquidity rate * @param _reserve the reserve address * @return the reserve liquidity rate **/ function getReserveCurrentLiquidityRate(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.currentLiquidityRate; }  /** * @dev gets the reserve liquidity cumulative index * @param _reserve the reserve address * @return the reserve liquidity cumulative index **/ function getReserveLiquidityCumulativeIndex(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.lastLiquidityCumulativeIndex; }  /** * @dev gets the reserve variable borrow index * @param _reserve the reserve address * @return the reserve variable borrow index **/ function getReserveVariableBorrowsCumulativeIndex(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.lastVariableBorrowCumulativeIndex; }  /** * @dev this function aggregates the configuration parameters of the reserve. * It's used in the LendingPoolDataProvider specifically to save gas, and avoid * multiple external contract calls to fetch the same data. * @param _reserve the reserve address * @return the reserve decimals * @return the base ltv as collateral * @return the liquidation threshold * @return if the reserve is used as collateral or not **/ function getReserveConfiguration(address _reserve) external view returns (uint256, uint256, uint256, bool) {     uint256 decimals;     uint256 baseLTVasCollateral;     uint256 liquidationThreshold;     bool usageAsCollateralEnabled;      CoreLibrary.ReserveData storage reserve = reserves[_reserve];     decimals = reserve.decimals;     baseLTVasCollateral = reserve.baseLTVasCollateral;     liquidationThreshold = reserve.liquidationThreshold;     usageAsCollateralEnabled = reserve.usageAsCollateralEnabled;      return (decimals, baseLTVasCollateral, liquidationThreshold, usageAsCollateralEnabled); }  /** * @dev returns the decimals of the reserve * @param _reserve the reserve address * @return the reserve decimals **/ function getReserveDecimals(address _reserve) external view returns (uint256) {     return reserves[_reserve].decimals; }  /** * @dev returns true if the reserve is enabled for borrowing * @param _reserve the reserve address * @return true if the reserve is enabled for borrowing, false otherwise **/  function isReserveBorrowingEnabled(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.borrowingEnabled; }  /** * @dev returns true if the reserve is enabled as collateral * @param _reserve the reserve address * @return true if the reserve is enabled as collateral, false otherwise **/  function isReserveUsageAsCollateralEnabled(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.usageAsCollateralEnabled; }  /** * @dev returns true if the stable rate is enabled on reserve * @param _reserve the reserve address * @return true if the stable rate is enabled on reserve, false otherwise **/ function getReserveIsStableBorrowRateEnabled(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.isStableBorrowRateEnabled; }  /** * @dev returns true if the reserve is active * @param _reserve the reserve address * @return true if the reserve is active, false otherwise **/ function getReserveIsActive(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.isActive; }  /** * @notice returns if a reserve is freezed * @param _reserve the reserve for which the information is needed * @return true if the reserve is freezed, false otherwise **/  function getReserveIsFreezed(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.isFreezed; }  /** * @notice returns the timestamp of the last action on the reserve * @param _reserve the reserve for which the information is needed * @return the last updated timestamp of the reserve **/  function getReserveLastUpdate(address _reserve) external view returns (uint40 timestamp) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     timestamp = reserve.lastUpdateTimestamp; }  /** * @dev returns the utilization rate U of a specific reserve * @param _reserve the reserve for which the information is needed * @return the utilization rate in ray **/  function getReserveUtilizationRate(address _reserve) public view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      uint256 totalBorrows = reserve.getTotalBorrows();      if (totalBorrows == 0) {         return 0;     }      uint256 availableLiquidity = getReserveAvailableLiquidity(_reserve);      return totalBorrows.rayDiv(availableLiquidity.add(totalBorrows)); }  /** * @return the array of reserves configured on the core **/ function getReserves() external view returns (address[] memory) {     return reservesList; }  /** * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return true if the user has chosen to use the reserve as collateral, false otherwise **/ function isUserUseReserveAsCollateralEnabled(address _reserve, address _user) external view returns (bool) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.useAsCollateral; }  /** * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the origination fee for the user **/ function getUserOriginationFee(address _reserve, address _user) external view returns (uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.originationFee; }  /** * @dev users with no loans in progress have NONE as borrow rate mode * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the borrow rate mode for the user, **/  function getUserCurrentBorrowRateMode(address _reserve, address _user) public view returns (CoreLibrary.InterestRateMode) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      if (user.principalBorrowBalance == 0) {         return CoreLibrary.InterestRateMode.NONE;     }      return     user.stableBorrowRate &gt; 0     ? CoreLibrary.InterestRateMode.STABLE     : CoreLibrary.InterestRateMode.VARIABLE; }  /** * @dev gets the current borrow rate of the user * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the borrow rate for the user, **/ function getUserCurrentBorrowRate(address _reserve, address _user) internal view returns (uint256) {     CoreLibrary.InterestRateMode rateMode = getUserCurrentBorrowRateMode(_reserve, _user);      if (rateMode == CoreLibrary.InterestRateMode.NONE) {         return 0;     }      return     rateMode == CoreLibrary.InterestRateMode.STABLE     ? usersReserveData[_user][_reserve].stableBorrowRate     : reserves[_reserve].currentVariableBorrowRate; }  /** * @dev the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the user stable rate **/ function getUserCurrentStableBorrowRate(address _reserve, address _user) external view returns (uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.stableBorrowRate; }  /** * @dev calculates and returns the borrow balances of the user * @param _reserve the address of the reserve * @param _user the address of the user * @return the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance **/  function getUserBorrowBalances(address _reserve, address _user) public view returns (uint256, uint256, uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     if (user.principalBorrowBalance == 0) {         return (0, 0, 0);     }      uint256 principal = user.principalBorrowBalance;     uint256 compoundedBalance = CoreLibrary.getCompoundedBorrowBalance(         user,         reserves[_reserve]     );     return (principal, compoundedBalance, compoundedBalance.sub(principal)); }  /** * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the variable borrow index for the user **/  function getUserVariableBorrowCumulativeIndex(address _reserve, address _user) external view returns (uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.lastVariableBorrowCumulativeIndex; }  /** * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the variable borrow index for the user **/  function getUserLastUpdate(address _reserve, address _user) external view returns (uint256 timestamp) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     timestamp = user.lastUpdateTimestamp; }  /** * @dev updates the lending pool core configuration **/ function refreshConfiguration() external onlyLendingPoolConfigurator {     refreshConfigInternal(); }  /** * @dev initializes a reserve * @param _reserve the address of the reserve * @param _aTokenAddress the address of the overlying aToken contract * @param _decimals the decimals of the reserve currency * @param _interestRateStrategyAddress the address of the interest rate strategy contract **/ function initReserve(     address _reserve,     address _aTokenAddress,     uint256 _decimals,     address _interestRateStrategyAddress ) external onlyLendingPoolConfigurator {     reserves[_reserve].init(_aTokenAddress, _decimals, _interestRateStrategyAddress);     addReserveToListInternal(_reserve);  }    /** * @dev removes the last added reserve in the reservesList array * @param _reserveToRemove the address of the reserve **/ function removeLastAddedReserve(address _reserveToRemove) external onlyLendingPoolConfigurator {      address lastReserve = reservesList[reservesList.length-1];      require(lastReserve == _reserveToRemove, "Reserve being removed is different than the reserve requested");      //as we can't check if totalLiquidity is 0 (since the reserve added might not be an ERC20) we at least check that there is nothing borrowed     require(getReserveTotalBorrows(lastReserve) == 0, "Cannot remove a reserve with liquidity deposited");      reserves[lastReserve].isActive = false;     reserves[lastReserve].aTokenAddress = address(0);     reserves[lastReserve].decimals = 0;     reserves[lastReserve].lastLiquidityCumulativeIndex = 0;     reserves[lastReserve].lastVariableBorrowCumulativeIndex = 0;     reserves[lastReserve].borrowingEnabled = false;     reserves[lastReserve].usageAsCollateralEnabled = false;     reserves[lastReserve].baseLTVasCollateral = 0;     reserves[lastReserve].liquidationThreshold = 0;     reserves[lastReserve].liquidationBonus = 0;     reserves[lastReserve].interestRateStrategyAddress = address(0);      reservesList.pop(); }  /** * @dev updates the address of the interest rate strategy contract * @param _reserve the address of the reserve * @param _rateStrategyAddress the address of the interest rate strategy contract **/  function setReserveInterestRateStrategyAddress(address _reserve, address _rateStrategyAddress) external onlyLendingPoolConfigurator {     reserves[_reserve].interestRateStrategyAddress = _rateStrategyAddress; }  /** * @dev enables borrowing on a reserve. Also sets the stable rate borrowing * @param _reserve the address of the reserve * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise **/  function enableBorrowingOnReserve(address _reserve, bool _stableBorrowRateEnabled) external onlyLendingPoolConfigurator {     reserves[_reserve].enableBorrowing(_stableBorrowRateEnabled); }  /** * @dev disables borrowing on a reserve * @param _reserve the address of the reserve **/  function disableBorrowingOnReserve(address _reserve) external onlyLendingPoolConfigurator {     reserves[_reserve].disableBorrowing(); }  /** * @dev enables a reserve to be used as collateral * @param _reserve the address of the reserve **/ function enableReserveAsCollateral(     address _reserve,     uint256 _baseLTVasCollateral,     uint256 _liquidationThreshold,     uint256 _liquidationBonus ) external onlyLendingPoolConfigurator {     reserves[_reserve].enableAsCollateral(         _baseLTVasCollateral,         _liquidationThreshold,         _liquidationBonus     ); }  /** * @dev disables a reserve to be used as collateral * @param _reserve the address of the reserve **/ function disableReserveAsCollateral(address _reserve) external onlyLendingPoolConfigurator {     reserves[_reserve].disableAsCollateral(); }  /** * @dev enable the stable borrow rate mode on a reserve * @param _reserve the address of the reserve **/ function enableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isStableBorrowRateEnabled = true; }  /** * @dev disable the stable borrow rate mode on a reserve * @param _reserve the address of the reserve **/ function disableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isStableBorrowRateEnabled = false; }  /** * @dev activates a reserve * @param _reserve the address of the reserve **/ function activateReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      require(         reserve.lastLiquidityCumulativeIndex &gt; 0 &amp;&amp;         reserve.lastVariableBorrowCumulativeIndex &gt; 0,         "Reserve has not been initialized yet"     );     reserve.isActive = true; }  /** * @dev deactivates a reserve * @param _reserve the address of the reserve **/ function deactivateReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isActive = false; }  /** * @notice allows the configurator to freeze the reserve. * A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance. * @param _reserve the address of the reserve **/ function freezeReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isFreezed = true; }  /** * @notice allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed. * @param _reserve the address of the reserve **/ function unfreezeReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isFreezed = false; }  /** * @notice allows the configurator to update the loan to value of a reserve * @param _reserve the address of the reserve * @param _ltv the new loan to value **/ function setReserveBaseLTVasCollateral(address _reserve, uint256 _ltv) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.baseLTVasCollateral = _ltv; }  /** * @notice allows the configurator to update the liquidation threshold of a reserve * @param _reserve the address of the reserve * @param _threshold the new liquidation threshold **/ function setReserveLiquidationThreshold(address _reserve, uint256 _threshold) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.liquidationThreshold = _threshold; }  /** * @notice allows the configurator to update the liquidation bonus of a reserve * @param _reserve the address of the reserve * @param _bonus the new liquidation bonus **/ function setReserveLiquidationBonus(address _reserve, uint256 _bonus) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.liquidationBonus = _bonus; }  /** * @notice allows the configurator to update the reserve decimals * @param _reserve the address of the reserve * @param _decimals the decimals of the reserve **/ function setReserveDecimals(address _reserve, uint256 _decimals) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.decimals = _decimals; }  /** * @notice internal functions **/  /** * @dev updates the state of a reserve as a consequence of a borrow action. * @param _reserve the address of the reserve on which the user is borrowing * @param _user the address of the borrower * @param _principalBorrowBalance the previous borrow balance of the borrower before the action * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount * @param _amountBorrowed the new amount borrowed * @param _rateMode the borrow rate mode (stable, variable) **/  function updateReserveStateOnBorrowInternal(     address _reserve,     address _user,     uint256 _principalBorrowBalance,     uint256 _balanceIncrease,     uint256 _amountBorrowed,     CoreLibrary.InterestRateMode _rateMode ) internal {     reserves[_reserve].updateCumulativeIndexes();      //increasing reserve total borrows to account for the new borrow balance of the user     //NOTE: Depending on the previous borrow mode, the borrows might need to be switched from variable to stable or vice versa      updateReserveTotalBorrowsByRateModeInternal(         _reserve,         _user,         _principalBorrowBalance,         _balanceIncrease,         _amountBorrowed,         _rateMode     ); }  /** * @dev updates the state of a user as a consequence of a borrow action. * @param _reserve the address of the reserve on which the user is borrowing * @param _user the address of the borrower * @param _amountBorrowed the amount borrowed * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount * @param _rateMode the borrow rate mode (stable, variable) * @return the final borrow rate for the user. Emitted by the borrow() event **/  function updateUserStateOnBorrowInternal(     address _reserve,     address _user,     uint256 _amountBorrowed,     uint256 _balanceIncrease,     uint256 _fee,     CoreLibrary.InterestRateMode _rateMode ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      if (_rateMode == CoreLibrary.InterestRateMode.STABLE) {         //stable         //reset the user variable index, and update the stable rate         user.stableBorrowRate = reserve.currentStableBorrowRate;         user.lastVariableBorrowCumulativeIndex = 0;     } else if (_rateMode == CoreLibrary.InterestRateMode.VARIABLE) {         //variable         //reset the user stable rate, and store the new borrow index         user.stableBorrowRate = 0;         user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;     } else {         revert("Invalid borrow rate mode");     }     //increase the principal borrows and the origination fee     user.principalBorrowBalance = user.principalBorrowBalance.add(_amountBorrowed).add(         _balanceIncrease     );     user.originationFee = user.originationFee.add(_fee);      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp);  }  /** * @dev updates the state of the reserve as a consequence of a repay action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _paybackAmountMinusFees the amount being paid back minus fees * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updateReserveStateOnRepayInternal(     address _reserve,     address _user,     uint256 _paybackAmountMinusFees,     uint256 _balanceIncrease ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_reserve][_user];      CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(_reserve, _user);      //update the indexes     reserves[_reserve].updateCumulativeIndexes();      //compound the cumulated interest to the borrow balance and then subtracting the payback amount     if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             _balanceIncrease,             user.stableBorrowRate         );         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _paybackAmountMinusFees,             user.stableBorrowRate         );     } else {         reserve.increaseTotalBorrowsVariable(_balanceIncrease);         reserve.decreaseTotalBorrowsVariable(_paybackAmountMinusFees);     } }  /** * @dev updates the state of the user as a consequence of a repay action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _paybackAmountMinusFees the amount being paid back minus fees * @param _originationFeeRepaid the fee on the amount that is being repaid * @param _balanceIncrease the accrued interest on the borrowed amount * @param _repaidWholeLoan true if the user is repaying the whole loan **/ function updateUserStateOnRepayInternal(     address _reserve,     address _user,     uint256 _paybackAmountMinusFees,     uint256 _originationFeeRepaid,     uint256 _balanceIncrease,     bool _repaidWholeLoan ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      //update the user principal borrow balance, adding the cumulated interest and then subtracting the payback amount     user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(         _paybackAmountMinusFees     );     user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;      //if the balance decrease is equal to the previous principal (user is repaying the whole loan)     //and the rate mode is stable, we reset the interest rate mode of the user     if (_repaidWholeLoan) {         user.stableBorrowRate = 0;         user.lastVariableBorrowCumulativeIndex = 0;     }     user.originationFee = user.originationFee.sub(_originationFeeRepaid);      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp);  }  /** * @dev updates the state of the user as a consequence of a swap rate action. * @param _reserve the address of the reserve on which the user is performing the rate swap * @param _user the address of the borrower * @param _principalBorrowBalance the the principal amount borrowed by the user * @param _compoundedBorrowBalance the principal amount plus the accrued interest * @param _currentRateMode the rate mode at which the user borrowed **/ function updateReserveStateOnSwapRateInternal(     address _reserve,     address _user,     uint256 _principalBorrowBalance,     uint256 _compoundedBorrowBalance,     CoreLibrary.InterestRateMode _currentRateMode ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      //compounding reserve indexes     reserve.updateCumulativeIndexes();      if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {         uint256 userCurrentStableRate = user.stableBorrowRate;          //swap to variable         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _principalBorrowBalance,             userCurrentStableRate         ); //decreasing stable from old principal balance         reserve.increaseTotalBorrowsVariable(_compoundedBorrowBalance); //increase variable borrows     } else if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         //swap to stable         uint256 currentStableRate = reserve.currentStableBorrowRate;         reserve.decreaseTotalBorrowsVariable(_principalBorrowBalance);         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             _compoundedBorrowBalance,             currentStableRate         );      } else {         revert("Invalid rate mode received");     } }  /** * @dev updates the state of the user as a consequence of a swap rate action. * @param _reserve the address of the reserve on which the user is performing the swap * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount * @param _currentRateMode the current rate mode of the user **/  function updateUserStateOnSwapRateInternal(     address _reserve,     address _user,     uint256 _balanceIncrease,     CoreLibrary.InterestRateMode _currentRateMode ) internal returns (CoreLibrary.InterestRateMode) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      CoreLibrary.InterestRateMode newMode = CoreLibrary.InterestRateMode.NONE;      if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         //switch to stable         newMode = CoreLibrary.InterestRateMode.STABLE;         user.stableBorrowRate = reserve.currentStableBorrowRate;         user.lastVariableBorrowCumulativeIndex = 0;     } else if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {         newMode = CoreLibrary.InterestRateMode.VARIABLE;         user.stableBorrowRate = 0;         user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;     } else {         revert("Invalid interest rate mode received");     }     //compounding cumulated interest     user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);     //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp);      return newMode; }  /** * @dev updates the state of the principal reserve as a consequence of a liquidation action. * @param _principalReserve the address of the principal reserve that is being repaid * @param _user the address of the borrower * @param _amountToLiquidate the amount being repaid by the liquidator * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updatePrincipalReserveStateOnLiquidationInternal(     address _principalReserve,     address _user,     uint256 _amountToLiquidate,     uint256 _balanceIncrease ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_principalReserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_principalReserve];      //update principal reserve data     reserve.updateCumulativeIndexes();      CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(         _principalReserve,         _user     );      if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {         //increase the total borrows by the compounded interest         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             _balanceIncrease,             user.stableBorrowRate         );          //decrease by the actual amount to liquidate         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _amountToLiquidate,             user.stableBorrowRate         );      } else {         //increase the total borrows by the compounded interest         reserve.increaseTotalBorrowsVariable(_balanceIncrease);          //decrease by the actual amount to liquidate         reserve.decreaseTotalBorrowsVariable(_amountToLiquidate);     }  }  /** * @dev updates the state of the collateral reserve as a consequence of a liquidation action. * @param _collateralReserve the address of the collateral reserve that is being liquidated **/ function updateCollateralReserveStateOnLiquidationInternal(     address _collateralReserve ) internal {     //update collateral reserve     reserves[_collateralReserve].updateCumulativeIndexes();  }  /** * @dev updates the state of the user being liquidated as a consequence of a liquidation action. * @param _reserve the address of the principal reserve that is being repaid * @param _user the address of the borrower * @param _amountToLiquidate the amount being repaid by the liquidator * @param _feeLiquidated the amount of origination fee being liquidated * @param _balanceIncrease the accrued interest on the borrowed amount **/ function updateUserStateOnLiquidationInternal(     address _reserve,     address _user,     uint256 _amountToLiquidate,     uint256 _feeLiquidated,     uint256 _balanceIncrease ) internal {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     //first increase by the compounded interest, then decrease by the liquidated amount     user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(         _amountToLiquidate     );      if (         getUserCurrentBorrowRateMode(_reserve, _user) == CoreLibrary.InterestRateMode.VARIABLE     ) {         user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;     }      if(_feeLiquidated &gt; 0){         user.originationFee = user.originationFee.sub(_feeLiquidated);     }      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp); }  /** * @dev updates the state of the reserve as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updateReserveStateOnRebalanceInternal(     address _reserve,     address _user,     uint256 _balanceIncrease ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      reserve.updateCumulativeIndexes();      reserve.increaseTotalBorrowsStableAndUpdateAverageRate(         _balanceIncrease,         user.stableBorrowRate     );  }  /** * @dev updates the state of the user as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updateUserStateOnRebalanceInternal(     address _reserve,     address _user,     uint256 _balanceIncrease ) internal {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);     user.stableBorrowRate = reserve.currentStableBorrowRate;      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp); }  /** * @dev updates the state of the user as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount * @param _amountBorrowed the accrued interest on the borrowed amount **/ function updateReserveTotalBorrowsByRateModeInternal(     address _reserve,     address _user,     uint256 _principalBalance,     uint256 _balanceIncrease,     uint256 _amountBorrowed,     CoreLibrary.InterestRateMode _newBorrowRateMode ) internal {     CoreLibrary.InterestRateMode previousRateMode = getUserCurrentBorrowRateMode(         _reserve,         _user     );     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      if (previousRateMode == CoreLibrary.InterestRateMode.STABLE) {         CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _principalBalance,             user.stableBorrowRate         );     } else if (previousRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         reserve.decreaseTotalBorrowsVariable(_principalBalance);     }      uint256 newPrincipalAmount = _principalBalance.add(_balanceIncrease).add(_amountBorrowed);     if (_newBorrowRateMode == CoreLibrary.InterestRateMode.STABLE) {         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             newPrincipalAmount,             reserve.currentStableBorrowRate         );     } else if (_newBorrowRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         reserve.increaseTotalBorrowsVariable(newPrincipalAmount);     } else {         revert("Invalid new borrow rate mode");     } }  /** * @dev Updates the reserve current stable borrow rate Rf, the current variable borrow rate Rv and the current liquidity rate Rl. * Also updates the lastUpdateTimestamp value. Please refer to the whitepaper for further information. * @param _reserve the address of the reserve to be updated * @param _liquidityAdded the amount of liquidity added to the protocol (deposit or repay) in the previous action * @param _liquidityTaken the amount of liquidity taken from the protocol (redeem or borrow) **/  function updateReserveInterestRatesAndTimestampInternal(     address _reserve,     uint256 _liquidityAdded,     uint256 _liquidityTaken ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     (uint256 newLiquidityRate, uint256 newStableRate, uint256 newVariableRate) = IReserveInterestRateStrategy(         reserve         .interestRateStrategyAddress     )     .calculateInterestRates(         _reserve,         getReserveAvailableLiquidity(_reserve).add(_liquidityAdded).sub(_liquidityTaken),         reserve.totalBorrowsStable,         reserve.totalBorrowsVariable,         reserve.currentAverageStableBorrowRate     );      reserve.currentLiquidityRate = newLiquidityRate;     reserve.currentStableBorrowRate = newStableRate;     reserve.currentVariableBorrowRate = newVariableRate;      //solium-disable-next-line     reserve.lastUpdateTimestamp = uint40(block.timestamp);      emit ReserveUpdated(         _reserve,         newLiquidityRate,         newStableRate,         newVariableRate,         reserve.lastLiquidityCumulativeIndex,         reserve.lastVariableBorrowCumulativeIndex     ); }  /** * @dev transfers to the protocol fees of a flashloan to the fees collection address * @param _token the address of the token being transferred * @param _amount the amount being transferred **/  function transferFlashLoanProtocolFeeInternal(address _token, uint256 _amount) internal {     address payable receiver = address(uint160(addressesProvider.getTokenDistributor()));      if (_token != EthAddressLib.ethAddress()) {         ERC20(_token).safeTransfer(receiver, _amount);     } else {         receiver.transfer(_amount);     } }  /** * @dev updates the internal configuration of the core **/ function refreshConfigInternal() internal {     lendingPoolAddress = addressesProvider.getLendingPool(); }  /** * @dev adds a reserve to the array of the reserves address **/ function addReserveToListInternal(address _reserve) internal {     bool reserveAlreadyAdded = false;     for (uint256 i = 0; i &lt; reservesList.length; i++)         if (reservesList[i] == _reserve) {             reserveAlreadyAdded = true;         }     if (!reserveAlreadyAdded) reservesList.push(_reserve); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': 'pragma solidity ^0.5.0;\n\nimport "openzeppelin-solidity/contracts/math/SafeMath.sol";\nimport "openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol";\nimport "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol";\nimport "openzeppelin-solidity/contracts/utils/Address.sol";\nimport "../libraries/openzeppelin-upgradeability/VersionedInitializable.sol";\n\nimport "../libraries/CoreLibrary.sol";\nimport "../configuration/LendingPoolAddressesProvider.sol";\nimport "../interfaces/ILendingRateOracle.sol";\nimport "../interfaces/IReserveInterestRateStrategy.sol";\nimport "../libraries/WadRayMath.sol";\nimport "../tokenization/AToken.sol";\nimport "../libraries/EthAddressLib.sol";\n\n/\n @title LendingPoolCore contract\n @author Aave\n @notice Holds the state of the lending pool and all the funds deposited\n @dev NOTE: The core does not enforce security checks on the update of the state\n (eg, updateStateOnBorrow() does not enforce that borrowed is enabled on the reserve).\n The check that an action can be performed is a duty of the overlying LendingPool contract.\n/\n\ncontract LendingPoolCore is VersionedInitializable {\n    using SafeMath for uint256;\n    using WadRayMath for uint256;\n    using CoreLibrary for CoreLibrary.ReserveData;\n    using CoreLibrary for CoreLibrary.UserReserveData;\n    using SafeERC20 for ERC20;\n    using Address for address payable;\n\n    /\n    * @dev Emitted when the state of a reserve is updated\n    * @param reserve the address of the reserve\n    * @param liquidityRate the new liquidity rate\n    * @param stableBorrowRate the new stable borrow rate\n    * @param variableBorrowRate the new variable borrow rate\n    * @param liquidityIndex the new liquidity index\n    * @param variableBorrowIndex the new variable borrow index\n    /\n    event ReserveUpdated(\n        address indexed reserve,\n        uint256 liquidityRate,\n        uint256 stableBorrowRate,\n        uint256 variableBorrowRate,\n        uint256 liquidityIndex,\n        uint256 variableBorrowIndex\n    );\n\n    address public lendingPoolAddress;\n\n    LendingPoolAddressesProvider public addressesProvider;\n\n    /\n    * @dev only lending pools can use functions affected by this modifier\n    /\n    modifier onlyLendingPool {\n        require(lendingPoolAddress == msg.sender, "The caller must be a lending pool contract");\n        ;\n    }\n\n    /\n    * @dev only lending pools configurator can use functions affected by this modifier\n    /\n    modifier onlyLendingPoolConfigurator {\n        require(\n            addressesProvider.getLendingPoolConfigurator() == msg.sender,\n            "The caller must be a lending pool configurator contract"\n        );\n        ;\n    }\n\n    mapping(address =&gt; CoreLibrary.ReserveData) internal reserves;\n    mapping(address =&gt; mapping(address =&gt; CoreLibrary.UserReserveData)) internal usersReserveData;\n\n    address[] public reservesList;\n\n    uint256 public constant CORE_REVISION = 0x4;\n\n    /\n    * @dev returns the revision number of the contract\n    /\n    function getRevision() internal pure returns (uint256) {\n        return CORE_REVISION;\n    }\n\n    /\n    * @dev initializes the Core contract, invoked upon registration on the AddressesProvider\n    * @param _addressesProvider the addressesProvider contract\n    /\n\n    function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {\n        addressesProvider = _addressesProvider;\n        refreshConfigInternal();\n    }\n\n    /\n    * @dev updates the state of the core as a result of a deposit action\n    * @param _reserve the address of the reserve in which the deposit is happening\n    * @param _user the address of the the user depositing\n    * @param _amount the amount being deposited\n    * @param _isFirstDeposit true if the user is depositing for the first time\n    /\n\n    function updateStateOnDeposit(\n        address _reserve,\n        address _user,\n        uint256 _amount,\n        bool _isFirstDeposit\n    ) external onlyLendingPool {\n        reserves[_reserve].updateCumulativeIndexes();\n        updateReserveInterestRatesAndTimestampInternal(_reserve, _amount, 0);\n\n        if (_isFirstDeposit) {\n            //if this is the first deposit of the user, we configure the deposit as enabled to be used as collateral\n            setUserUseReserveAsCollateral(_reserve, _user, true);\n        }\n    }\n\n    /\n    * @dev updates the state of the core as a result of a redeem action\n    * @param _reserve the address of the reserve in which the redeem is happening\n    * @param _user the address of the the user redeeming\n    * @param _amountRedeemed the amount being redeemed\n    * @param _userRedeemedEverything true if the user is redeeming everything\n    /\n    function updateStateOnRedeem(\n        address _reserve,\n        address _user,\n        uint256 _amountRedeemed,\n        bool _userRedeemedEverything\n    ) external onlyLendingPool {\n        //compound liquidity and variable borrow interests\n        reserves[_reserve].updateCumulativeIndexes();\n        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountRedeemed);\n\n        //if user redeemed everything the useReserveAsCollateral flag is reset\n        if (_userRedeemedEverything) {\n            setUserUseReserveAsCollateral(_reserve, _user, false);\n        }\n    }\n\n    /\n    * @dev updates the state of the core as a result of a flashloan action\n    * @param _reserve the address of the reserve in which the flashloan is happening\n    * @param _income the income of the protocol as a result of the action\n    /\n    function updateStateOnFlashLoan(\n        address _reserve,\n        uint256 _availableLiquidityBefore,\n        uint256 _income,\n        uint256 _protocolFee\n    ) external onlyLendingPool {\n        transferFlashLoanProtocolFeeInternal(_reserve, _protocolFee);\n\n        //compounding the cumulated interest\n        reserves[_reserve].updateCumulativeIndexes();\n\n        uint256 totalLiquidityBefore = _availableLiquidityBefore.add(\n            getReserveTotalBorrows(_reserve)\n        );\n\n        //compounding the received fee into the reserve\n        reserves[_reserve].cumulateToLiquidityIndex(totalLiquidityBefore, _income);\n\n        //refresh interest rates\n        updateReserveInterestRatesAndTimestampInternal(_reserve, _income, 0);\n    }\n\n    /\n    * @dev updates the state of the core as a consequence of a borrow action.\n    * @param _reserve the address of the reserve on which the user is borrowing\n    * @param _user the address of the borrower\n    * @param _amountBorrowed the new amount borrowed\n    * @param _borrowFee the fee on the amount borrowed\n    * @param _rateMode the borrow rate mode (stable, variable)\n    * @return the new borrow rate for the user\n    /\n    function updateStateOnBorrow(\n        address _reserve,\n        address _user,\n        uint256 _amountBorrowed,\n        uint256 _borrowFee,\n        CoreLibrary.InterestRateMode _rateMode\n    ) external onlyLendingPool returns (uint256, uint256) {\n        // getting the previous borrow data of the user\n        (uint256 principalBorrowBalance, , uint256 balanceIncrease) = getUserBorrowBalances(\n            _reserve,\n            _user\n        );\n\n        updateReserveStateOnBorrowInternal(\n            _reserve,\n            _user,\n            principalBorrowBalance,\n            balanceIncrease,\n            _amountBorrowed,\n            _rateMode\n        );\n\n        updateUserStateOnBorrowInternal(\n            _reserve,\n            _user,\n            _amountBorrowed,\n            balanceIncrease,\n            _borrowFee,\n            _rateMode\n        );\n\n        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountBorrowed);\n\n        return (getUserCurrentBorrowRate(_reserve, _user), balanceIncrease);\n    }\n\n    /\n    * @dev updates the state of the core as a consequence of a repay action.\n    * @param _reserve the address of the reserve on which the user is repaying\n    * @param _user the address of the borrower\n    * @param _paybackAmountMinusFees the amount being paid back minus fees\n    * @param _originationFeeRepaid the fee on the amount that is being repaid\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    * @param _repaidWholeLoan true if the user is repaying the whole loan\n    /\n\n    function updateStateOnRepay(\n        address _reserve,\n        address _user,\n        uint256 _paybackAmountMinusFees,\n        uint256 _originationFeeRepaid,\n        uint256 _balanceIncrease,\n        bool _repaidWholeLoan\n    ) external onlyLendingPool {\n        updateReserveStateOnRepayInternal(\n            _reserve,\n            _user,\n            _paybackAmountMinusFees,\n            _balanceIncrease\n        );\n        updateUserStateOnRepayInternal(\n            _reserve,\n            _user,\n            _paybackAmountMinusFees,\n            _originationFeeRepaid,\n            _balanceIncrease,\n            _repaidWholeLoan\n        );\n\n        updateReserveInterestRatesAndTimestampInternal(_reserve, _paybackAmountMinusFees, 0);\n    }\n\n    /\n    * @dev updates the state of the core as a consequence of a swap rate action.\n    * @param _reserve the address of the reserve on which the user is repaying\n    * @param _user the address of the borrower\n    * @param _principalBorrowBalance the amount borrowed by the user\n    * @param _compoundedBorrowBalance the amount borrowed plus accrued interest\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    * @param _currentRateMode the current interest rate mode for the user\n    /\n    function updateStateOnSwapRate(\n        address _reserve,\n        address _user,\n        uint256 _principalBorrowBalance,\n        uint256 _compoundedBorrowBalance,\n        uint256 _balanceIncrease,\n        CoreLibrary.InterestRateMode _currentRateMode\n    ) external onlyLendingPool returns (CoreLibrary.InterestRateMode, uint256) {\n        updateReserveStateOnSwapRateInternal(\n            _reserve,\n            _user,\n            _principalBorrowBalance,\n            _compoundedBorrowBalance,\n            _currentRateMode\n        );\n\n        CoreLibrary.InterestRateMode newRateMode = updateUserStateOnSwapRateInternal(\n            _reserve,\n            _user,\n            _balanceIncrease,\n            _currentRateMode\n        );\n\n        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);\n\n        return (newRateMode, getUserCurrentBorrowRate(_reserve, _user));\n    }\n\n    /\n    * @dev updates the state of the core as a consequence of a liquidation action.\n    * @param _principalReserve the address of the principal reserve that is being repaid\n    * @param _collateralReserve the address of the collateral reserve that is being liquidated\n    * @param _user the address of the borrower\n    * @param _amountToLiquidate the amount being repaid by the liquidator\n    * @param _collateralToLiquidate the amount of collateral being liquidated\n    * @param _feeLiquidated the amount of origination fee being liquidated\n    * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise\n    /\n    function updateStateOnLiquidation(\n        address _principalReserve,\n        address _collateralReserve,\n        address _user,\n        uint256 _amountToLiquidate,\n        uint256 _collateralToLiquidate,\n        uint256 _feeLiquidated,\n        uint256 _liquidatedCollateralForFee,\n        uint256 _balanceIncrease,\n        bool _liquidatorReceivesAToken\n    ) external onlyLendingPool {\n        updatePrincipalReserveStateOnLiquidationInternal(\n            _principalReserve,\n            _user,\n            _amountToLiquidate,\n            _balanceIncrease\n        );\n\n        updateCollateralReserveStateOnLiquidationInternal(\n            _collateralReserve\n        );\n\n        updateUserStateOnLiquidationInternal(\n            _principalReserve,\n            _user,\n            _amountToLiquidate,\n            _feeLiquidated,\n            _balanceIncrease\n        );\n\n        updateReserveInterestRatesAndTimestampInternal(_principalReserve, _amountToLiquidate, 0);\n\n        if (!_liquidatorReceivesAToken) {\n            updateReserveInterestRatesAndTimestampInternal(\n                _collateralReserve,\n                0,\n                _collateralToLiquidate.add(_liquidatedCollateralForFee)\n            );\n        }\n\n    }\n\n    /\n    * @dev updates the state of the core as a consequence of a stable rate rebalance\n    * @param _reserve the address of the principal reserve where the user borrowed\n    * @param _user the address of the borrower\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    * @return the new stable rate for the user\n    /\n    function updateStateOnRebalance(address _reserve, address _user, uint256 _balanceIncrease)\n    external\n    onlyLendingPool\n    returns (uint256)\n    {\n        updateReserveStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);\n\n        //update user data and rebalance the rate\n        updateUserStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);\n        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);\n        return usersReserveData[_user][_reserve].stableBorrowRate;\n    }\n\n    /\n    * @dev enables or disables a reserve as collateral\n    * @param _reserve the address of the principal reserve where the user deposited\n    * @param _user the address of the depositor\n    * @param _useAsCollateral true if the depositor wants to use the reserve as collateral\n    /\n    function setUserUseReserveAsCollateral(address _reserve, address _user, bool _useAsCollateral)\n    public\n    onlyLendingPool\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        user.useAsCollateral = _useAsCollateral;\n    }\n\n    /\n    * @notice ETH/token transfer functions\n    /\n\n    /\n    * @dev fallback function enforces that the caller is a contract, to support flashloan transfers\n    /\n    function() external payable {\n        //only contracts can send ETH to the core\n        require(msg.sender.isContract(), "Only contracts can send ether to the Lending pool core");\n\n    }\n\n    /\n    * @dev transfers to the user a specific amount from the reserve.\n    * @param _reserve the address of the reserve where the transfer is happening\n    * @param _user the address of the user receiving the transfer\n    * @param _amount the amount being transferred\n    /\n    function transferToUser(address _reserve, address payable _user, uint256 _amount)\n    external\n    onlyLendingPool\n    {\n        if (_reserve != EthAddressLib.ethAddress()) {\n            ERC20(_reserve).safeTransfer(_user, _amount);\n        } else {\n            //solium-disable-next-line\n            (bool result, ) = _user.call.value(_amount).gas(50000)("");\n            require(result, "Transfer of ETH failed");\n        }\n    }\n\n    /\n    * @dev transfers the protocol fees to the fees collection address\n    * @param _token the address of the token being transferred\n    * @param _user the address of the user from where the transfer is happening\n    * @param _amount the amount being transferred\n    * @param _destination the fee receiver address\n    /\n\n    function transferToFeeCollectionAddress(\n        address _token,\n        address _user,\n        uint256 _amount,\n        address _destination\n    ) external payable onlyLendingPool {\n        address payable feeAddress = address(uint160(_destination)); //cast the address to payable\n\n        if (_token != EthAddressLib.ethAddress()) {\n            require(\n                msg.value == 0,\n                "User is sending ETH along with the ERC20 transfer. Check the value attribute of the transaction"\n            );\n            ERC20(_token).safeTransferFrom(_user, feeAddress, _amount);\n        } else {\n            require(msg.value &gt;= _amount, "The amount and the value sent to deposit do not match");\n            //solium-disable-next-line\n            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");\n            require(result, "Transfer of ETH failed");\n        }\n    }\n\n    /\n    * @dev transfers the fees to the fees collection address in the case of liquidation\n    * @param _token the address of the token being transferred\n    * @param _amount the amount being transferred\n    * @param _destination the fee receiver address\n    /\n    function liquidateFee(\n        address _token,\n        uint256 _amount,\n        address _destination\n    ) external payable onlyLendingPool {\n        address payable feeAddress = address(uint160(_destination)); //cast the address to payable\n        require(\n            msg.value == 0,\n            "Fee liquidation does not require any transfer of value"\n        );\n\n        if (_token != EthAddressLib.ethAddress()) {\n            ERC20(_token).safeTransfer(feeAddress, _amount);\n        } else {\n            //solium-disable-next-line\n            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");\n            require(result, "Transfer of ETH failed");\n        }\n    }\n\n    /\n    * @dev transfers an amount from a user to the destination reserve\n    * @param _reserve the address of the reserve where the amount is being transferred\n    * @param _user the address of the user from where the transfer is happening\n    * @param _amount the amount being transferred\n    /\n    function transferToReserve(address _reserve, address payable _user, uint256 _amount)\n    external\n    payable\n    onlyLendingPool\n    {\n        if (_reserve != EthAddressLib.ethAddress()) {\n            require(msg.value == 0, "User is sending ETH along with the ERC20 transfer.");\n            ERC20(_reserve).safeTransferFrom(_user, address(this), _amount);\n\n        } else {\n            require(msg.value &gt;= _amount, "The amount and the value sent to deposit do not match");\n\n            if (msg.value &gt; _amount) {\n                //send back excess ETH\n                uint256 excessAmount = msg.value.sub(_amount);\n                //solium-disable-next-line\n                (bool result, ) = _user.call.value(excessAmount).gas(50000)("");\n                require(result, "Transfer of ETH failed");\n            }\n        }\n    }\n\n    /\n    * @notice data access functions\n    /\n\n    /\n    * @dev returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral)\n    * needed to calculate the global account data in the LendingPoolDataProvider\n    * @param _reserve the address of the reserve\n    * @param _user the address of the user\n    * @return the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not\n    /\n    function getUserBasicReserveData(address _reserve, address _user)\n    external\n    view\n    returns (uint256, uint256, uint256, bool)\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n\n        uint256 underlyingBalance = getUserUnderlyingAssetBalance(_reserve, _user);\n\n        if (user.principalBorrowBalance == 0) {\n            return (underlyingBalance, 0, 0, user.useAsCollateral);\n        }\n\n        return (\n        underlyingBalance,\n        user.getCompoundedBorrowBalance(reserve),\n        user.originationFee,\n        user.useAsCollateral\n        );\n    }\n\n    /\n    * @dev checks if a user is allowed to borrow at a stable rate\n    * @param _reserve the reserve address\n    * @param _user the user\n    * @param _amount the amount the the user wants to borrow\n    * @return true if the user is allowed to borrow at a stable rate, false otherwise\n    /\n\n    function isUserAllowedToBorrowAtStable(address _reserve, address _user, uint256 _amount)\n    external\n    view\n    returns (bool)\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n\n        if (!reserve.isStableBorrowRateEnabled) return false;\n\n        return\n        !user.useAsCollateral ||\n        !reserve.usageAsCollateralEnabled ||\n        _amount &gt; getUserUnderlyingAssetBalance(_reserve, _user);\n    }\n\n    /\n    * @dev gets the underlying asset balance of a user based on the corresponding aToken balance.\n    * @param _reserve the reserve address\n    * @param _user the user address\n    * @return the underlying deposit balance of the user\n    /\n\n    function getUserUnderlyingAssetBalance(address _reserve, address _user)\n    public\n    view\n    returns (uint256)\n    {\n        AToken aToken = AToken(reserves[_reserve].aTokenAddress);\n        return aToken.balanceOf(_user);\n\n    }\n\n    /\n    * @dev gets the interest rate strategy contract address for the reserve\n    * @param _reserve the reserve address\n    * @return the address of the interest rate strategy contract\n    /\n    function getReserveInterestRateStrategyAddress(address _reserve) public view returns (address) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.interestRateStrategyAddress;\n    }\n\n    /\n    * @dev gets the aToken contract address for the reserve\n    * @param _reserve the reserve address\n    * @return the address of the aToken contract\n    /\n\n    function getReserveATokenAddress(address _reserve) public view returns (address) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.aTokenAddress;\n    }\n\n    /\n    * @dev gets the available liquidity in the reserve. The available liquidity is the balance of the core contract\n    * @param _reserve the reserve address\n    * @return the available liquidity\n    /\n    function getReserveAvailableLiquidity(address _reserve) public view returns (uint256) {\n        uint256 balance = 0;\n\n        if (_reserve == EthAddressLib.ethAddress()) {\n            balance = address(this).balance;\n        } else {\n            balance = IERC20(_reserve).balanceOf(address(this));\n        }\n        return balance;\n    }\n\n    /\n    * @dev gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows\n    * @param _reserve the reserve address\n    * @return the total liquidity\n    /\n    function getReserveTotalLiquidity(address _reserve) public view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return getReserveAvailableLiquidity(_reserve).add(reserve.getTotalBorrows());\n    }\n\n    /\n    * @dev gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there\n    * there has been 100% income.\n    * @param _reserve the reserve address\n    * @return the reserve normalized income\n    /\n    function getReserveNormalizedIncome(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.getNormalizedIncome();\n    }\n\n    /\n    * @dev gets the reserve total borrows\n    * @param _reserve the reserve address\n    * @return the total borrows (stable + variable)\n    /\n    function getReserveTotalBorrows(address _reserve) public view returns (uint256) {\n        return reserves[_reserve].getTotalBorrows();\n    }\n\n    /\n    * @dev gets the reserve total borrows stable\n    * @param _reserve the reserve address\n    * @return the total borrows stable\n    /\n    function getReserveTotalBorrowsStable(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.totalBorrowsStable;\n    }\n\n    /\n    * @dev gets the reserve total borrows variable\n    * @param _reserve the reserve address\n    * @return the total borrows variable\n    /\n\n    function getReserveTotalBorrowsVariable(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.totalBorrowsVariable;\n    }\n\n    /\n    * @dev gets the reserve liquidation threshold\n    * @param _reserve the reserve address\n    * @return the reserve liquidation threshold\n    /\n\n    function getReserveLiquidationThreshold(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.liquidationThreshold;\n    }\n\n    /\n    * @dev gets the reserve liquidation bonus\n    * @param _reserve the reserve address\n    * @return the reserve liquidation bonus\n    /\n\n    function getReserveLiquidationBonus(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.liquidationBonus;\n    }\n\n    /\n    * @dev gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty\n    * @param _reserve the reserve address\n    * @return the reserve current variable borrow rate\n    /\n\n    function getReserveCurrentVariableBorrowRate(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n\n        if (reserve.currentVariableBorrowRate == 0) {\n            return\n            IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)\n            .getBaseVariableBorrowRate();\n        }\n        return reserve.currentVariableBorrowRate;\n    }\n\n    /\n    * @dev gets the reserve current stable borrow rate. Is the market rate if the reserve is empty\n    * @param _reserve the reserve address\n    * @return the reserve current stable borrow rate\n    /\n\n    function getReserveCurrentStableBorrowRate(address _reserve) public view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        ILendingRateOracle oracle = ILendingRateOracle(addressesProvider.getLendingRateOracle());\n\n        if (reserve.currentStableBorrowRate == 0) {\n            //no stable rate borrows yet\n            return oracle.getMarketBorrowRate(_reserve);\n        }\n\n        return reserve.currentStableBorrowRate;\n    }\n\n    /\n    * @dev gets the reserve average stable borrow rate. The average stable rate is the weighted average\n    * of all the loans taken at stable rate.\n    * @param _reserve the reserve address\n    * @return the reserve current average borrow rate\n    /\n    function getReserveCurrentAverageStableBorrowRate(address _reserve)\n    external\n    view\n    returns (uint256)\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.currentAverageStableBorrowRate;\n    }\n\n    /\n    * @dev gets the reserve liquidity rate\n    * @param _reserve the reserve address\n    * @return the reserve liquidity rate\n    /\n    function getReserveCurrentLiquidityRate(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.currentLiquidityRate;\n    }\n\n    /\n    * @dev gets the reserve liquidity cumulative index\n    * @param _reserve the reserve address\n    * @return the reserve liquidity cumulative index\n    /\n    function getReserveLiquidityCumulativeIndex(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.lastLiquidityCumulativeIndex;\n    }\n\n    /\n    * @dev gets the reserve variable borrow index\n    * @param _reserve the reserve address\n    * @return the reserve variable borrow index\n    /\n    function getReserveVariableBorrowsCumulativeIndex(address _reserve)\n    external\n    view\n    returns (uint256)\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.lastVariableBorrowCumulativeIndex;\n    }\n\n    /\n    * @dev this function aggregates the configuration parameters of the reserve.\n    * It\'s used in the LendingPoolDataProvider specifically to save gas, and avoid\n    * multiple external contract calls to fetch the same data.\n    * @param _reserve the reserve address\n    * @return the reserve decimals\n    * @return the base ltv as collateral\n    * @return the liquidation threshold\n    * @return if the reserve is used as collateral or not\n    /\n    function getReserveConfiguration(address _reserve)\n    external\n    view\n    returns (uint256, uint256, uint256, bool)\n    {\n        uint256 decimals;\n        uint256 baseLTVasCollateral;\n        uint256 liquidationThreshold;\n        bool usageAsCollateralEnabled;\n\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        decimals = reserve.decimals;\n        baseLTVasCollateral = reserve.baseLTVasCollateral;\n        liquidationThreshold = reserve.liquidationThreshold;\n        usageAsCollateralEnabled = reserve.usageAsCollateralEnabled;\n\n        return (decimals, baseLTVasCollateral, liquidationThreshold, usageAsCollateralEnabled);\n    }\n\n    /\n    * @dev returns the decimals of the reserve\n    * @param _reserve the reserve address\n    * @return the reserve decimals\n    /\n    function getReserveDecimals(address _reserve) external view returns (uint256) {\n        return reserves[_reserve].decimals;\n    }\n\n    /\n    * @dev returns true if the reserve is enabled for borrowing\n    * @param _reserve the reserve address\n    * @return true if the reserve is enabled for borrowing, false otherwise\n    /\n\n    function isReserveBorrowingEnabled(address _reserve) external view returns (bool) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.borrowingEnabled;\n    }\n\n    /\n    * @dev returns true if the reserve is enabled as collateral\n    * @param _reserve the reserve address\n    * @return true if the reserve is enabled as collateral, false otherwise\n    /\n\n    function isReserveUsageAsCollateralEnabled(address _reserve) external view returns (bool) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.usageAsCollateralEnabled;\n    }\n\n    /\n    * @dev returns true if the stable rate is enabled on reserve\n    * @param _reserve the reserve address\n    * @return true if the stable rate is enabled on reserve, false otherwise\n    /\n    function getReserveIsStableBorrowRateEnabled(address _reserve) external view returns (bool) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.isStableBorrowRateEnabled;\n    }\n\n    /\n    * @dev returns true if the reserve is active\n    * @param _reserve the reserve address\n    * @return true if the reserve is active, false otherwise\n    /\n    function getReserveIsActive(address _reserve) external view returns (bool) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.isActive;\n    }\n\n    /\n    * @notice returns if a reserve is freezed\n    * @param _reserve the reserve for which the information is needed\n    * @return true if the reserve is freezed, false otherwise\n    /\n\n    function getReserveIsFreezed(address _reserve) external view returns (bool) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.isFreezed;\n    }\n\n    /\n    * @notice returns the timestamp of the last action on the reserve\n    * @param _reserve the reserve for which the information is needed\n    * @return the last updated timestamp of the reserve\n    /\n\n    function getReserveLastUpdate(address _reserve) external view returns (uint40 timestamp) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        timestamp = reserve.lastUpdateTimestamp;\n    }\n\n    /\n    * @dev returns the utilization rate U of a specific reserve\n    * @param _reserve the reserve for which the information is needed\n    * @return the utilization rate in ray\n    /\n\n    function getReserveUtilizationRate(address _reserve) public view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n\n        uint256 totalBorrows = reserve.getTotalBorrows();\n\n        if (totalBorrows == 0) {\n            return 0;\n        }\n\n        uint256 availableLiquidity = getReserveAvailableLiquidity(_reserve);\n\n        return totalBorrows.rayDiv(availableLiquidity.add(totalBorrows));\n    }\n\n    /\n    * @return the array of reserves configured on the core\n    /\n    function getReserves() external view returns (address[] memory) {\n        return reservesList;\n    }\n\n    /\n    * @param _reserve the address of the reserve for which the information is needed\n    * @param _user the address of the user for which the information is needed\n    * @return true if the user has chosen to use the reserve as collateral, false otherwise\n    /\n    function isUserUseReserveAsCollateralEnabled(address _reserve, address _user)\n    external\n    view\n    returns (bool)\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        return user.useAsCollateral;\n    }\n\n    /\n    * @param _reserve the address of the reserve for which the information is needed\n    * @param _user the address of the user for which the information is needed\n    * @return the origination fee for the user\n    /\n    function getUserOriginationFee(address _reserve, address _user)\n    external\n    view\n    returns (uint256)\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        return user.originationFee;\n    }\n\n    /\n    * @dev users with no loans in progress have NONE as borrow rate mode\n    * @param _reserve the address of the reserve for which the information is needed\n    * @param _user the address of the user for which the information is needed\n    * @return the borrow rate mode for the user,\n    /\n\n    function getUserCurrentBorrowRateMode(address _reserve, address _user)\n    public\n    view\n    returns (CoreLibrary.InterestRateMode)\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n\n        if (user.principalBorrowBalance == 0) {\n            return CoreLibrary.InterestRateMode.NONE;\n        }\n\n        return\n        user.stableBorrowRate &gt; 0\n        ? CoreLibrary.InterestRateMode.STABLE\n        : CoreLibrary.InterestRateMode.VARIABLE;\n    }\n\n    /\n    * @dev gets the current borrow rate of the user\n    * @param _reserve the address of the reserve for which the information is needed\n    * @param _user the address of the user for which the information is needed\n    * @return the borrow rate for the user,\n    /\n    function getUserCurrentBorrowRate(address _reserve, address _user)\n    internal\n    view\n    returns (uint256)\n    {\n        CoreLibrary.InterestRateMode rateMode = getUserCurrentBorrowRateMode(_reserve, _user);\n\n        if (rateMode == CoreLibrary.InterestRateMode.NONE) {\n            return 0;\n        }\n\n        return\n        rateMode == CoreLibrary.InterestRateMode.STABLE\n        ? usersReserveData[_user][_reserve].stableBorrowRate\n        : reserves[_reserve].currentVariableBorrowRate;\n    }\n\n    /\n    * @dev the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all\n    * @param _reserve the address of the reserve for which the information is needed\n    * @param _user the address of the user for which the information is needed\n    * @return the user stable rate\n    /\n    function getUserCurrentStableBorrowRate(address _reserve, address _user)\n    external\n    view\n    returns (uint256)\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        return user.stableBorrowRate;\n    }\n\n    /\n    * @dev calculates and returns the borrow balances of the user\n    * @param _reserve the address of the reserve\n    * @param _user the address of the user\n    * @return the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance\n    /\n\n    function getUserBorrowBalances(address _reserve, address _user)\n    public\n    view\n    returns (uint256, uint256, uint256)\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        if (user.principalBorrowBalance == 0) {\n            return (0, 0, 0);\n        }\n\n        uint256 principal = user.principalBorrowBalance;\n        uint256 compoundedBalance = CoreLibrary.getCompoundedBorrowBalance(\n            user,\n            reserves[_reserve]\n        );\n        return (principal, compoundedBalance, compoundedBalance.sub(principal));\n    }\n\n    /\n    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable\n    * @param _reserve the address of the reserve for which the information is needed\n    * @param _user the address of the user for which the information is needed\n    * @return the variable borrow index for the user\n    /\n\n    function getUserVariableBorrowCumulativeIndex(address _reserve, address _user)\n    external\n    view\n    returns (uint256)\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        return user.lastVariableBorrowCumulativeIndex;\n    }\n\n    /\n    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable\n    * @param _reserve the address of the reserve for which the information is needed\n    * @param _user the address of the user for which the information is needed\n    * @return the variable borrow index for the user\n    /\n\n    function getUserLastUpdate(address _reserve, address _user)\n    external\n    view\n    returns (uint256 timestamp)\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        timestamp = user.lastUpdateTimestamp;\n    }\n\n    /\n    * @dev updates the lending pool core configuration\n    /\n    function refreshConfiguration() external onlyLendingPoolConfigurator {\n        refreshConfigInternal();\n    }\n\n    /\n    * @dev initializes a reserve\n    * @param _reserve the address of the reserve\n    * @param _aTokenAddress the address of the overlying aToken contract\n    * @param _decimals the decimals of the reserve currency\n    * @param _interestRateStrategyAddress the address of the interest rate strategy contract\n    /\n    function initReserve(\n        address _reserve,\n        address _aTokenAddress,\n        uint256 _decimals,\n        address _interestRateStrategyAddress\n    ) external onlyLendingPoolConfigurator {\n        reserves[_reserve].init(_aTokenAddress, _decimals, _interestRateStrategyAddress);\n        addReserveToListInternal(_reserve);\n\n    }\n\n\n\n    /\n    * @dev removes the last added reserve in the reservesList array\n    * @param _reserveToRemove the address of the reserve\n    /\n    function removeLastAddedReserve(address _reserveToRemove)\n    external onlyLendingPoolConfigurator {\n\n        address lastReserve = reservesList[reservesList.length-1];\n\n        require(lastReserve == _reserveToRemove, "Reserve being removed is different than the reserve requested");\n\n        //as we can\'t check if totalLiquidity is 0 (since the reserve added might not be an ERC20) we at least check that there is nothing borrowed\n        require(getReserveTotalBorrows(lastReserve) == 0, "Cannot remove a reserve with liquidity deposited");\n\n        reserves[lastReserve].isActive = false;\n        reserves[lastReserve].aTokenAddress = address(0);\n        reserves[lastReserve].decimals = 0;\n        reserves[lastReserve].lastLiquidityCumulativeIndex = 0;\n        reserves[lastReserve].lastVariableBorrowCumulativeIndex = 0;\n        reserves[lastReserve].borrowingEnabled = false;\n        reserves[lastReserve].usageAsCollateralEnabled = false;\n        reserves[lastReserve].baseLTVasCollateral = 0;\n        reserves[lastReserve].liquidationThreshold = 0;\n        reserves[lastReserve].liquidationBonus = 0;\n        reserves[lastReserve].interestRateStrategyAddress = address(0);\n\n        reservesList.pop();\n    }\n\n    /\n    * @dev updates the address of the interest rate strategy contract\n    * @param _reserve the address of the reserve\n    * @param _rateStrategyAddress the address of the interest rate strategy contract\n    /\n\n    function setReserveInterestRateStrategyAddress(address _reserve, address _rateStrategyAddress)\n    external\n    onlyLendingPoolConfigurator\n    {\n        reserves[_reserve].interestRateStrategyAddress = _rateStrategyAddress;\n    }\n\n    /\n    * @dev enables borrowing on a reserve. Also sets the stable rate borrowing\n    * @param _reserve the address of the reserve\n    * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise\n    /\n\n    function enableBorrowingOnReserve(address _reserve, bool _stableBorrowRateEnabled)\n    external\n    onlyLendingPoolConfigurator\n    {\n        reserves[_reserve].enableBorrowing(_stableBorrowRateEnabled);\n    }\n\n    /\n    * @dev disables borrowing on a reserve\n    * @param _reserve the address of the reserve\n    /\n\n    function disableBorrowingOnReserve(address _reserve) external onlyLendingPoolConfigurator {\n        reserves[_reserve].disableBorrowing();\n    }\n\n    /\n    * @dev enables a reserve to be used as collateral\n    * @param _reserve the address of the reserve\n    /\n    function enableReserveAsCollateral(\n        address _reserve,\n        uint256 _baseLTVasCollateral,\n        uint256 _liquidationThreshold,\n        uint256 _liquidationBonus\n    ) external onlyLendingPoolConfigurator {\n        reserves[_reserve].enableAsCollateral(\n            _baseLTVasCollateral,\n            _liquidationThreshold,\n            _liquidationBonus\n        );\n    }\n\n    /\n    * @dev disables a reserve to be used as collateral\n    * @param _reserve the address of the reserve\n    /\n    function disableReserveAsCollateral(address _reserve) external onlyLendingPoolConfigurator {\n        reserves[_reserve].disableAsCollateral();\n    }\n\n    /\n    * @dev enable the stable borrow rate mode on a reserve\n    * @param _reserve the address of the reserve\n    /\n    function enableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.isStableBorrowRateEnabled = true;\n    }\n\n    /\n    * @dev disable the stable borrow rate mode on a reserve\n    * @param _reserve the address of the reserve\n    /\n    function disableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.isStableBorrowRateEnabled = false;\n    }\n\n    /\n    * @dev activates a reserve\n    * @param _reserve the address of the reserve\n    /\n    function activateReserve(address _reserve) external onlyLendingPoolConfigurator {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n\n        require(\n            reserve.lastLiquidityCumulativeIndex &gt; 0 &amp;&amp;\n            reserve.lastVariableBorrowCumulativeIndex &gt; 0,\n            "Reserve has not been initialized yet"\n        );\n        reserve.isActive = true;\n    }\n\n    /\n    * @dev deactivates a reserve\n    * @param _reserve the address of the reserve\n    /\n    function deactivateReserve(address _reserve) external onlyLendingPoolConfigurator {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.isActive = false;\n    }\n\n    /\n    * @notice allows the configurator to freeze the reserve.\n    * A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance.\n    * @param _reserve the address of the reserve\n    /\n    function freezeReserve(address _reserve) external onlyLendingPoolConfigurator {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.isFreezed = true;\n    }\n\n    /\n    * @notice allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed.\n    * @param _reserve the address of the reserve\n    /\n    function unfreezeReserve(address _reserve) external onlyLendingPoolConfigurator {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.isFreezed = false;\n    }\n\n    /\n    * @notice allows the configurator to update the loan to value of a reserve\n    * @param _reserve the address of the reserve\n    * @param _ltv the new loan to value\n    /\n    function setReserveBaseLTVasCollateral(address _reserve, uint256 _ltv)\n    external\n    onlyLendingPoolConfigurator\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.baseLTVasCollateral = _ltv;\n    }\n\n    /\n    * @notice allows the configurator to update the liquidation threshold of a reserve\n    * @param _reserve the address of the reserve\n    * @param _threshold the new liquidation threshold\n    /\n    function setReserveLiquidationThreshold(address _reserve, uint256 _threshold)\n    external\n    onlyLendingPoolConfigurator\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.liquidationThreshold = _threshold;\n    }\n\n    /\n    * @notice allows the configurator to update the liquidation bonus of a reserve\n    * @param _reserve the address of the reserve\n    * @param _bonus the new liquidation bonus\n    /\n    function setReserveLiquidationBonus(address _reserve, uint256 _bonus)\n    external\n    onlyLendingPoolConfigurator\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.liquidationBonus = _bonus;\n    }\n\n    /\n    * @notice allows the configurator to update the reserve decimals\n    * @param _reserve the address of the reserve\n    * @param _decimals the decimals of the reserve\n    /\n    function setReserveDecimals(address _reserve, uint256 _decimals)\n    external\n    onlyLendingPoolConfigurator\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.decimals = _decimals;\n    }\n\n    /\n    * @notice internal functions\n    /\n\n    /\n    * @dev updates the state of a reserve as a consequence of a borrow action.\n    * @param _reserve the address of the reserve on which the user is borrowing\n    * @param _user the address of the borrower\n    * @param _principalBorrowBalance the previous borrow balance of the borrower before the action\n    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount\n    * @param _amountBorrowed the new amount borrowed\n    * @param _rateMode the borrow rate mode (stable, variable)\n    /\n\n    function updateReserveStateOnBorrowInternal(\n        address _reserve,\n        address _user,\n        uint256 _principalBorrowBalance,\n        uint256 _balanceIncrease,\n        uint256 _amountBorrowed,\n        CoreLibrary.InterestRateMode _rateMode\n    ) internal {\n        reserves[_reserve].updateCumulativeIndexes();\n\n        //increasing reserve total borrows to account for the new borrow balance of the user\n        //NOTE: Depending on the previous borrow mode, the borrows might need to be switched from variable to stable or vice versa\n\n        updateReserveTotalBorrowsByRateModeInternal(\n            _reserve,\n            _user,\n            _principalBorrowBalance,\n            _balanceIncrease,\n            _amountBorrowed,\n            _rateMode\n        );\n    }\n\n    /\n    * @dev updates the state of a user as a consequence of a borrow action.\n    * @param _reserve the address of the reserve on which the user is borrowing\n    * @param _user the address of the borrower\n    * @param _amountBorrowed the amount borrowed\n    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount\n    * @param _rateMode the borrow rate mode (stable, variable)\n    * @return the final borrow rate for the user. Emitted by the borrow() event\n    /\n\n    function updateUserStateOnBorrowInternal(\n        address _reserve,\n        address _user,\n        uint256 _amountBorrowed,\n        uint256 _balanceIncrease,\n        uint256 _fee,\n        CoreLibrary.InterestRateMode _rateMode\n    ) internal {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n\n        if (_rateMode == CoreLibrary.InterestRateMode.STABLE) {\n            //stable\n            //reset the user variable index, and update the stable rate\n            user.stableBorrowRate = reserve.currentStableBorrowRate;\n            user.lastVariableBorrowCumulativeIndex = 0;\n        } else if (_rateMode == CoreLibrary.InterestRateMode.VARIABLE) {\n            //variable\n            //reset the user stable rate, and store the new borrow index\n            user.stableBorrowRate = 0;\n            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;\n        } else {\n            revert("Invalid borrow rate mode");\n        }\n        //increase the principal borrows and the origination fee\n        user.principalBorrowBalance = user.principalBorrowBalance.add(_amountBorrowed).add(\n            _balanceIncrease\n        );\n        user.originationFee = user.originationFee.add(_fee);\n\n        //solium-disable-next-line\n        user.lastUpdateTimestamp = uint40(block.timestamp);\n\n    }\n\n    /\n    * @dev updates the state of the reserve as a consequence of a repay action.\n    * @param _reserve the address of the reserve on which the user is repaying\n    * @param _user the address of the borrower\n    * @param _paybackAmountMinusFees the amount being paid back minus fees\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    /\n\n    function updateReserveStateOnRepayInternal(\n        address _reserve,\n        address _user,\n        uint256 _paybackAmountMinusFees,\n        uint256 _balanceIncrease\n    ) internal {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_reserve][_user];\n\n        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(_reserve, _user);\n\n        //update the indexes\n        reserves[_reserve].updateCumulativeIndexes();\n\n        //compound the cumulated interest to the borrow balance and then subtracting the payback amount\n        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {\n            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(\n                _balanceIncrease,\n                user.stableBorrowRate\n            );\n            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(\n                _paybackAmountMinusFees,\n                user.stableBorrowRate\n            );\n        } else {\n            reserve.increaseTotalBorrowsVariable(_balanceIncrease);\n            reserve.decreaseTotalBorrowsVariable(_paybackAmountMinusFees);\n        }\n    }\n\n    /\n    * @dev updates the state of the user as a consequence of a repay action.\n    * @param _reserve the address of the reserve on which the user is repaying\n    * @param _user the address of the borrower\n    * @param _paybackAmountMinusFees the amount being paid back minus fees\n    * @param _originationFeeRepaid the fee on the amount that is being repaid\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    * @param _repaidWholeLoan true if the user is repaying the whole loan\n    /\n    function updateUserStateOnRepayInternal(\n        address _reserve,\n        address _user,\n        uint256 _paybackAmountMinusFees,\n        uint256 _originationFeeRepaid,\n        uint256 _balanceIncrease,\n        bool _repaidWholeLoan\n    ) internal {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n\n        //update the user principal borrow balance, adding the cumulated interest and then subtracting the payback amount\n        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(\n            _paybackAmountMinusFees\n        );\n        user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;\n\n        //if the balance decrease is equal to the previous principal (user is repaying the whole loan)\n        //and the rate mode is stable, we reset the interest rate mode of the user\n        if (_repaidWholeLoan) {\n            user.stableBorrowRate = 0;\n            user.lastVariableBorrowCumulativeIndex = 0;\n        }\n        user.originationFee = user.originationFee.sub(_originationFeeRepaid);\n\n        //solium-disable-next-line\n        user.lastUpdateTimestamp = uint40(block.timestamp);\n\n    }\n\n    /\n    * @dev updates the state of the user as a consequence of a swap rate action.\n    * @param _reserve the address of the reserve on which the user is performing the rate swap\n    * @param _user the address of the borrower\n    * @param _principalBorrowBalance the the principal amount borrowed by the user\n    * @param _compoundedBorrowBalance the principal amount plus the accrued interest\n    * @param _currentRateMode the rate mode at which the user borrowed\n    /\n    function updateReserveStateOnSwapRateInternal(\n        address _reserve,\n        address _user,\n        uint256 _principalBorrowBalance,\n        uint256 _compoundedBorrowBalance,\n        CoreLibrary.InterestRateMode _currentRateMode\n    ) internal {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n\n        //compounding reserve indexes\n        reserve.updateCumulativeIndexes();\n\n        if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {\n            uint256 userCurrentStableRate = user.stableBorrowRate;\n\n            //swap to variable\n            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(\n                _principalBorrowBalance,\n                userCurrentStableRate\n            ); //decreasing stable from old principal balance\n            reserve.increaseTotalBorrowsVariable(_compoundedBorrowBalance); //increase variable borrows\n        } else if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {\n            //swap to stable\n            uint256 currentStableRate = reserve.currentStableBorrowRate;\n            reserve.decreaseTotalBorrowsVariable(_principalBorrowBalance);\n            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(\n                _compoundedBorrowBalance,\n                currentStableRate\n            );\n\n        } else {\n            revert("Invalid rate mode received");\n        }\n    }\n\n    /\n    * @dev updates the state of the user as a consequence of a swap rate action.\n    * @param _reserve the address of the reserve on which the user is performing the swap\n    * @param _user the address of the borrower\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    * @param _currentRateMode the current rate mode of the user\n    /\n\n    function updateUserStateOnSwapRateInternal(\n        address _reserve,\n        address _user,\n        uint256 _balanceIncrease,\n        CoreLibrary.InterestRateMode _currentRateMode\n    ) internal returns (CoreLibrary.InterestRateMode) {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n\n        CoreLibrary.InterestRateMode newMode = CoreLibrary.InterestRateMode.NONE;\n\n        if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {\n            //switch to stable\n            newMode = CoreLibrary.InterestRateMode.STABLE;\n            user.stableBorrowRate = reserve.currentStableBorrowRate;\n            user.lastVariableBorrowCumulativeIndex = 0;\n        } else if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {\n            newMode = CoreLibrary.InterestRateMode.VARIABLE;\n            user.stableBorrowRate = 0;\n            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;\n        } else {\n            revert("Invalid interest rate mode received");\n        }\n        //compounding cumulated interest\n        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);\n        //solium-disable-next-line\n        user.lastUpdateTimestamp = uint40(block.timestamp);\n\n        return newMode;\n    }\n\n    /\n    * @dev updates the state of the principal reserve as a consequence of a liquidation action.\n    * @param _principalReserve the address of the principal reserve that is being repaid\n    * @param _user the address of the borrower\n    * @param _amountToLiquidate the amount being repaid by the liquidator\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    /\n\n    function updatePrincipalReserveStateOnLiquidationInternal(\n        address _principalReserve,\n        address _user,\n        uint256 _amountToLiquidate,\n        uint256 _balanceIncrease\n    ) internal {\n        CoreLibrary.ReserveData storage reserve = reserves[_principalReserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_principalReserve];\n\n        //update principal reserve data\n        reserve.updateCumulativeIndexes();\n\n        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(\n            _principalReserve,\n            _user\n        );\n\n        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {\n            //increase the total borrows by the compounded interest\n            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(\n                _balanceIncrease,\n                user.stableBorrowRate\n            );\n\n            //decrease by the actual amount to liquidate\n            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(\n                _amountToLiquidate,\n                user.stableBorrowRate\n            );\n\n        } else {\n            //increase the total borrows by the compounded interest\n            reserve.increaseTotalBorrowsVariable(_balanceIncrease);\n\n            //decrease by the actual amount to liquidate\n            reserve.decreaseTotalBorrowsVariable(_amountToLiquidate);\n        }\n\n    }\n\n    /\n    * @dev updates the state of the collateral reserve as a consequence of a liquidation action.\n    * @param _collateralReserve the address of the collateral reserve that is being liquidated\n    /\n    function updateCollateralReserveStateOnLiquidationInternal(\n        address _collateralReserve\n    ) internal {\n        //update collateral reserve\n        reserves[_collateralReserve].updateCumulativeIndexes();\n\n    }\n\n    /\n    * @dev updates the state of the user being liquidated as a consequence of a liquidation action.\n    * @param _reserve the address of the principal reserve that is being repaid\n    * @param _user the address of the borrower\n    * @param _amountToLiquidate the amount being repaid by the liquidator\n    * @param _feeLiquidated the amount of origination fee being liquidated\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    /\n    function updateUserStateOnLiquidationInternal(\n        address _reserve,\n        address _user,\n        uint256 _amountToLiquidate,\n        uint256 _feeLiquidated,\n        uint256 _balanceIncrease\n    ) internal {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        //first increase by the compounded interest, then decrease by the liquidated amount\n        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(\n            _amountToLiquidate\n        );\n\n        if (\n            getUserCurrentBorrowRateMode(_reserve, _user) == CoreLibrary.InterestRateMode.VARIABLE\n        ) {\n            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;\n        }\n\n        if(_feeLiquidated &gt; 0){\n            user.originationFee = user.originationFee.sub(_feeLiquidated);\n        }\n\n        //solium-disable-next-line\n        user.lastUpdateTimestamp = uint40(block.timestamp);\n    }\n\n    /\n    * @dev updates the state of the reserve as a consequence of a stable rate rebalance\n    * @param _reserve the address of the principal reserve where the user borrowed\n    * @param _user the address of the borrower\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    /\n\n    function updateReserveStateOnRebalanceInternal(\n        address _reserve,\n        address _user,\n        uint256 _balanceIncrease\n    ) internal {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n\n        reserve.updateCumulativeIndexes();\n\n        reserve.increaseTotalBorrowsStableAndUpdateAverageRate(\n            _balanceIncrease,\n            user.stableBorrowRate\n        );\n\n    }\n\n    /\n    * @dev updates the state of the user as a consequence of a stable rate rebalance\n    * @param _reserve the address of the principal reserve where the user borrowed\n    * @param _user the address of the borrower\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    /\n\n    function updateUserStateOnRebalanceInternal(\n        address _reserve,\n        address _user,\n        uint256 _balanceIncrease\n    ) internal {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n\n        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);\n        user.stableBorrowRate = reserve.currentStableBorrowRate;\n\n        //solium-disable-next-line\n        user.lastUpdateTimestamp = uint40(block.timestamp);\n    }\n\n    /\n    * @dev updates the state of the user as a consequence of a stable rate rebalance\n    * @param _reserve the address of the principal reserve where the user borrowed\n    * @param _user the address of the borrower\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    * @param _amountBorrowed the accrued interest on the borrowed amount\n    /\n    function updateReserveTotalBorrowsByRateModeInternal(\n        address _reserve,\n        address _user,\n        uint256 _principalBalance,\n        uint256 _balanceIncrease,\n        uint256 _amountBorrowed,\n        CoreLibrary.InterestRateMode _newBorrowRateMode\n    ) internal {\n        CoreLibrary.InterestRateMode previousRateMode = getUserCurrentBorrowRateMode(\n            _reserve,\n            _user\n        );\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n\n        if (previousRateMode == CoreLibrary.InterestRateMode.STABLE) {\n            CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(\n                _principalBalance,\n                user.stableBorrowRate\n            );\n        } else if (previousRateMode == CoreLibrary.InterestRateMode.VARIABLE) {\n            reserve.decreaseTotalBorrowsVariable(_principalBalance);\n        }\n\n        uint256 newPrincipalAmount = _principalBalance.add(_balanceIncrease).add(_amountBorrowed);\n        if (_newBorrowRateMode == CoreLibrary.InterestRateMode.STABLE) {\n            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(\n                newPrincipalAmount,\n                reserve.currentStableBorrowRate\n            );\n        } else if (_newBorrowRateMode == CoreLibrary.InterestRateMode.VARIABLE) {\n            reserve.increaseTotalBorrowsVariable(newPrincipalAmount);\n        } else {\n            revert("Invalid new borrow rate mode");\n        }\n    }\n\n    /\n    * @dev Updates the reserve current stable borrow rate Rf, the current variable borrow rate Rv and the current liquidity rate Rl.\n    * Also updates the lastUpdateTimestamp value. Please refer to the whitepaper for further information.\n    * @param _reserve the address of the reserve to be updated\n    * @param _liquidityAdded the amount of liquidity added to the protocol (deposit or repay) in the previous action\n    * @param _liquidityTaken the amount of liquidity taken from the protocol (redeem or borrow)\n    /\n\n    function updateReserveInterestRatesAndTimestampInternal(\n        address _reserve,\n        uint256 _liquidityAdded,\n        uint256 _liquidityTaken\n    ) internal {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        (uint256 newLiquidityRate, uint256 newStableRate, uint256 newVariableRate) = IReserveInterestRateStrategy(\n            reserve\n            .interestRateStrategyAddress\n        )\n        .calculateInterestRates(\n            _reserve,\n            getReserveAvailableLiquidity(_reserve).add(_liquidityAdded).sub(_liquidityTaken),\n            reserve.totalBorrowsStable,\n            reserve.totalBorrowsVariable,\n            reserve.currentAverageStableBorrowRate\n        );\n\n        reserve.currentLiquidityRate = newLiquidityRate;\n        reserve.currentStableBorrowRate = newStableRate;\n        reserve.currentVariableBorrowRate = newVariableRate;\n\n        //solium-disable-next-line\n        reserve.lastUpdateTimestamp = uint40(block.timestamp);\n\n        emit ReserveUpdated(\n            _reserve,\n            newLiquidityRate,\n            newStableRate,\n            newVariableRate,\n            reserve.lastLiquidityCumulativeIndex,\n            reserve.lastVariableBorrowCumulativeIndex\n        );\n    }\n\n    /\n    * @dev transfers to the protocol fees of a flashloan to the fees collection address\n    * @param _token the address of the token being transferred\n    * @param _amount the amount being transferred\n    /\n\n    function transferFlashLoanProtocolFeeInternal(address _token, uint256 _amount) internal {\n        address payable receiver = address(uint160(addressesProvider.getTokenDistributor()));\n\n        if (_token != EthAddressLib.ethAddress()) {\n            ERC20(_token).safeTransfer(receiver, _amount);\n        } else {\n            receiver.transfer(_amount);\n        }\n    }\n\n    /\n    * @dev updates the internal configuration of the core\n    /\n    function refreshConfigInternal() internal {\n        lendingPoolAddress = addressesProvider.getLendingPool();\n    }\n\n    /\n    * @dev adds a reserve to the array of the reserves address\n    /\n    function addReserveToListInternal(address _reserve) internal {\n        bool reserveAlreadyAdded = false;\n        for (uint256 i = 0; i &lt; reservesList.length; i++)\n            if (reservesList[i] == _reserve) {\n                reserveAlreadyAdded = true;\n            }\n        if (!reserveAlreadyAdded) reservesList.push(_reserve);\n    }\n\n}\n', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 04:31:57 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | pragma solidity ^0.5.0; import "openzeppelin-solidity/contracts/math/SafeMath.sol"; import "openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol"; import "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol"; import "openzeppelin-solidity/contracts/utils/Address.sol"; import "../libraries/openzeppelin-upgradeability/VersionedInitializable.sol"; import "../libraries/CoreLibrary.sol"; import "../configuration/LendingPoolAddressesProvider.sol"; import "../interfaces/ILendingRateOracle.sol"; import "../interfaces/IReserveInterestRateStrategy.sol"; import "../libraries/WadRayMath.sol"; import "../tokenization/AToken.sol"; import "../libraries/EthAddressLib.sol"; / * @title LendingPoolCore contract * @author Aave * @notice Holds the state of the lending pool and all the funds deposited * @dev NOTE: The core does not enforce security checks on the update of the state * (eg, updateStateOnBorrow() does not enforce that borrowed is enabled on the reserve). * The check that an action can be performed is a duty of the overlying LendingPool contract. / contract LendingPoolCore is VersionedInitializable {     using SafeMath for uint256;     using WadRayMath for uint256;     using CoreLibrary for CoreLibrary.ReserveData;     using CoreLibrary for CoreLibrary.UserReserveData;     using SafeERC20 for ERC20;     using Address for address payable; /** * @dev Emitted when the state of a reserve is updated * @param reserve the address of the reserve * @param liquidityRate the new liquidity rate * @param stableBorrowRate the new stable borrow rate * @param variableBorrowRate the new variable borrow rate * @param liquidityIndex the new liquidity index * @param variableBorrowIndex the new variable borrow index **/ event ReserveUpdated(     address indexed reserve,     uint256 liquidityRate,     uint256 stableBorrowRate,     uint256 variableBorrowRate,     uint256 liquidityIndex,     uint256 variableBorrowIndex );  address public lendingPoolAddress;  LendingPoolAddressesProvider public addressesProvider;  /** * @dev only lending pools can use functions affected by this modifier **/ modifier onlyLendingPool {     require(lendingPoolAddress == msg.sender, "The caller must be a lending pool contract");     _; }  /** * @dev only lending pools configurator can use functions affected by this modifier **/ modifier onlyLendingPoolConfigurator {     require(         addressesProvider.getLendingPoolConfigurator() == msg.sender,         "The caller must be a lending pool configurator contract"     );     _; }  mapping(address =&gt; CoreLibrary.ReserveData) internal reserves; mapping(address =&gt; mapping(address =&gt; CoreLibrary.UserReserveData)) internal usersReserveData;  address[] public reservesList;  uint256 public constant CORE_REVISION = 0x4;  /** * @dev returns the revision number of the contract **/ function getRevision() internal pure returns (uint256) {     return CORE_REVISION; }  /** * @dev initializes the Core contract, invoked upon registration on the AddressesProvider * @param _addressesProvider the addressesProvider contract **/  function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {     addressesProvider = _addressesProvider;     refreshConfigInternal(); }  /** * @dev updates the state of the core as a result of a deposit action * @param _reserve the address of the reserve in which the deposit is happening * @param _user the address of the the user depositing * @param _amount the amount being deposited * @param _isFirstDeposit true if the user is depositing for the first time **/  function updateStateOnDeposit(     address _reserve,     address _user,     uint256 _amount,     bool _isFirstDeposit ) external onlyLendingPool {     reserves[_reserve].updateCumulativeIndexes();     updateReserveInterestRatesAndTimestampInternal(_reserve, _amount, 0);      if (_isFirstDeposit) {         //if this is the first deposit of the user, we configure the deposit as enabled to be used as collateral         setUserUseReserveAsCollateral(_reserve, _user, true);     } }  /** * @dev updates the state of the core as a result of a redeem action * @param _reserve the address of the reserve in which the redeem is happening * @param _user the address of the the user redeeming * @param _amountRedeemed the amount being redeemed * @param _userRedeemedEverything true if the user is redeeming everything **/ function updateStateOnRedeem(     address _reserve,     address _user,     uint256 _amountRedeemed,     bool _userRedeemedEverything ) external onlyLendingPool {     //compound liquidity and variable borrow interests     reserves[_reserve].updateCumulativeIndexes();     updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountRedeemed);      //if user redeemed everything the useReserveAsCollateral flag is reset     if (_userRedeemedEverything) {         setUserUseReserveAsCollateral(_reserve, _user, false);     } }  /** * @dev updates the state of the core as a result of a flashloan action * @param _reserve the address of the reserve in which the flashloan is happening * @param _income the income of the protocol as a result of the action **/ function updateStateOnFlashLoan(     address _reserve,     uint256 _availableLiquidityBefore,     uint256 _income,     uint256 _protocolFee ) external onlyLendingPool {     transferFlashLoanProtocolFeeInternal(_reserve, _protocolFee);      //compounding the cumulated interest     reserves[_reserve].updateCumulativeIndexes();      uint256 totalLiquidityBefore = _availableLiquidityBefore.add(         getReserveTotalBorrows(_reserve)     );      //compounding the received fee into the reserve     reserves[_reserve].cumulateToLiquidityIndex(totalLiquidityBefore, _income);      //refresh interest rates     updateReserveInterestRatesAndTimestampInternal(_reserve, _income, 0); }  /** * @dev updates the state of the core as a consequence of a borrow action. * @param _reserve the address of the reserve on which the user is borrowing * @param _user the address of the borrower * @param _amountBorrowed the new amount borrowed * @param _borrowFee the fee on the amount borrowed * @param _rateMode the borrow rate mode (stable, variable) * @return the new borrow rate for the user **/ function updateStateOnBorrow(     address _reserve,     address _user,     uint256 _amountBorrowed,     uint256 _borrowFee,     CoreLibrary.InterestRateMode _rateMode ) external onlyLendingPool returns (uint256, uint256) {     // getting the previous borrow data of the user     (uint256 principalBorrowBalance, , uint256 balanceIncrease) = getUserBorrowBalances(         _reserve,         _user     );      updateReserveStateOnBorrowInternal(         _reserve,         _user,         principalBorrowBalance,         balanceIncrease,         _amountBorrowed,         _rateMode     );      updateUserStateOnBorrowInternal(         _reserve,         _user,         _amountBorrowed,         balanceIncrease,         _borrowFee,         _rateMode     );      updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountBorrowed);      return (getUserCurrentBorrowRate(_reserve, _user), balanceIncrease); }  /** * @dev updates the state of the core as a consequence of a repay action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _paybackAmountMinusFees the amount being paid back minus fees * @param _originationFeeRepaid the fee on the amount that is being repaid * @param _balanceIncrease the accrued interest on the borrowed amount * @param _repaidWholeLoan true if the user is repaying the whole loan **/  function updateStateOnRepay(     address _reserve,     address _user,     uint256 _paybackAmountMinusFees,     uint256 _originationFeeRepaid,     uint256 _balanceIncrease,     bool _repaidWholeLoan ) external onlyLendingPool {     updateReserveStateOnRepayInternal(         _reserve,         _user,         _paybackAmountMinusFees,         _balanceIncrease     );     updateUserStateOnRepayInternal(         _reserve,         _user,         _paybackAmountMinusFees,         _originationFeeRepaid,         _balanceIncrease,         _repaidWholeLoan     );      updateReserveInterestRatesAndTimestampInternal(_reserve, _paybackAmountMinusFees, 0); }  /** * @dev updates the state of the core as a consequence of a swap rate action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _principalBorrowBalance the amount borrowed by the user * @param _compoundedBorrowBalance the amount borrowed plus accrued interest * @param _balanceIncrease the accrued interest on the borrowed amount * @param _currentRateMode the current interest rate mode for the user **/ function updateStateOnSwapRate(     address _reserve,     address _user,     uint256 _principalBorrowBalance,     uint256 _compoundedBorrowBalance,     uint256 _balanceIncrease,     CoreLibrary.InterestRateMode _currentRateMode ) external onlyLendingPool returns (CoreLibrary.InterestRateMode, uint256) {     updateReserveStateOnSwapRateInternal(         _reserve,         _user,         _principalBorrowBalance,         _compoundedBorrowBalance,         _currentRateMode     );      CoreLibrary.InterestRateMode newRateMode = updateUserStateOnSwapRateInternal(         _reserve,         _user,         _balanceIncrease,         _currentRateMode     );      updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);      return (newRateMode, getUserCurrentBorrowRate(_reserve, _user)); }  /** * @dev updates the state of the core as a consequence of a liquidation action. * @param _principalReserve the address of the principal reserve that is being repaid * @param _collateralReserve the address of the collateral reserve that is being liquidated * @param _user the address of the borrower * @param _amountToLiquidate the amount being repaid by the liquidator * @param _collateralToLiquidate the amount of collateral being liquidated * @param _feeLiquidated the amount of origination fee being liquidated * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus * @param _balanceIncrease the accrued interest on the borrowed amount * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise **/ function updateStateOnLiquidation(     address _principalReserve,     address _collateralReserve,     address _user,     uint256 _amountToLiquidate,     uint256 _collateralToLiquidate,     uint256 _feeLiquidated,     uint256 _liquidatedCollateralForFee,     uint256 _balanceIncrease,     bool _liquidatorReceivesAToken ) external onlyLendingPool {     updatePrincipalReserveStateOnLiquidationInternal(         _principalReserve,         _user,         _amountToLiquidate,         _balanceIncrease     );      updateCollateralReserveStateOnLiquidationInternal(         _collateralReserve     );      updateUserStateOnLiquidationInternal(         _principalReserve,         _user,         _amountToLiquidate,         _feeLiquidated,         _balanceIncrease     );      updateReserveInterestRatesAndTimestampInternal(_principalReserve, _amountToLiquidate, 0);      if (!_liquidatorReceivesAToken) {         updateReserveInterestRatesAndTimestampInternal(             _collateralReserve,             0,             _collateralToLiquidate.add(_liquidatedCollateralForFee)         );     }  }  /** * @dev updates the state of the core as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount * @return the new stable rate for the user **/ function updateStateOnRebalance(address _reserve, address _user, uint256 _balanceIncrease) external onlyLendingPool returns (uint256) {     updateReserveStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);      //update user data and rebalance the rate     updateUserStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);     updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);     return usersReserveData[_user][_reserve].stableBorrowRate; }  /** * @dev enables or disables a reserve as collateral * @param _reserve the address of the principal reserve where the user deposited * @param _user the address of the depositor * @param _useAsCollateral true if the depositor wants to use the reserve as collateral **/ function setUserUseReserveAsCollateral(address _reserve, address _user, bool _useAsCollateral) public onlyLendingPool {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     user.useAsCollateral = _useAsCollateral; }  /** * @notice ETH/token transfer functions **/  /** * @dev fallback function enforces that the caller is a contract, to support flashloan transfers **/ function() external payable {     //only contracts can send ETH to the core     require(msg.sender.isContract(), "Only contracts can send ether to the Lending pool core");  }  /** * @dev transfers to the user a specific amount from the reserve. * @param _reserve the address of the reserve where the transfer is happening * @param _user the address of the user receiving the transfer * @param _amount the amount being transferred **/ function transferToUser(address _reserve, address payable _user, uint256 _amount) external onlyLendingPool {     if (_reserve != EthAddressLib.ethAddress()) {         ERC20(_reserve).safeTransfer(_user, _amount);     } else {         //solium-disable-next-line         (bool result, ) = _user.call.value(_amount).gas(50000)("");         require(result, "Transfer of ETH failed");     } }  /** * @dev transfers the protocol fees to the fees collection address * @param _token the address of the token being transferred * @param _user the address of the user from where the transfer is happening * @param _amount the amount being transferred * @param _destination the fee receiver address **/  function transferToFeeCollectionAddress(     address _token,     address _user,     uint256 _amount,     address _destination ) external payable onlyLendingPool {     address payable feeAddress = address(uint160(_destination)); //cast the address to payable      if (_token != EthAddressLib.ethAddress()) {         require(             msg.value == 0,             "User is sending ETH along with the ERC20 transfer. Check the value attribute of the transaction"         );         ERC20(_token).safeTransferFrom(_user, feeAddress, _amount);     } else {         require(msg.value &gt;= _amount, "The amount and the value sent to deposit do not match");         //solium-disable-next-line         (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");         require(result, "Transfer of ETH failed");     } }  /** * @dev transfers the fees to the fees collection address in the case of liquidation * @param _token the address of the token being transferred * @param _amount the amount being transferred * @param _destination the fee receiver address **/ function liquidateFee(     address _token,     uint256 _amount,     address _destination ) external payable onlyLendingPool {     address payable feeAddress = address(uint160(_destination)); //cast the address to payable     require(         msg.value == 0,         "Fee liquidation does not require any transfer of value"     );      if (_token != EthAddressLib.ethAddress()) {         ERC20(_token).safeTransfer(feeAddress, _amount);     } else {         //solium-disable-next-line         (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");         require(result, "Transfer of ETH failed");     } }  /** * @dev transfers an amount from a user to the destination reserve * @param _reserve the address of the reserve where the amount is being transferred * @param _user the address of the user from where the transfer is happening * @param _amount the amount being transferred **/ function transferToReserve(address _reserve, address payable _user, uint256 _amount) external payable onlyLendingPool {     if (_reserve != EthAddressLib.ethAddress()) {         require(msg.value == 0, "User is sending ETH along with the ERC20 transfer.");         ERC20(_reserve).safeTransferFrom(_user, address(this), _amount);      } else {         require(msg.value &gt;= _amount, "The amount and the value sent to deposit do not match");          if (msg.value &gt; _amount) {             //send back excess ETH             uint256 excessAmount = msg.value.sub(_amount);             //solium-disable-next-line             (bool result, ) = _user.call.value(excessAmount).gas(50000)("");             require(result, "Transfer of ETH failed");         }     } }  /** * @notice data access functions **/  /** * @dev returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral) * needed to calculate the global account data in the LendingPoolDataProvider * @param _reserve the address of the reserve * @param _user the address of the user * @return the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not **/ function getUserBasicReserveData(address _reserve, address _user) external view returns (uint256, uint256, uint256, bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      uint256 underlyingBalance = getUserUnderlyingAssetBalance(_reserve, _user);      if (user.principalBorrowBalance == 0) {         return (underlyingBalance, 0, 0, user.useAsCollateral);     }      return (     underlyingBalance,     user.getCompoundedBorrowBalance(reserve),     user.originationFee,     user.useAsCollateral     ); }  /** * @dev checks if a user is allowed to borrow at a stable rate * @param _reserve the reserve address * @param _user the user * @param _amount the amount the the user wants to borrow * @return true if the user is allowed to borrow at a stable rate, false otherwise **/  function isUserAllowedToBorrowAtStable(address _reserve, address _user, uint256 _amount) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      if (!reserve.isStableBorrowRateEnabled) return false;      return     !user.useAsCollateral ||     !reserve.usageAsCollateralEnabled ||     _amount &gt; getUserUnderlyingAssetBalance(_reserve, _user); }  /** * @dev gets the underlying asset balance of a user based on the corresponding aToken balance. * @param _reserve the reserve address * @param _user the user address * @return the underlying deposit balance of the user **/  function getUserUnderlyingAssetBalance(address _reserve, address _user) public view returns (uint256) {     AToken aToken = AToken(reserves[_reserve].aTokenAddress);     return aToken.balanceOf(_user);  }  /** * @dev gets the interest rate strategy contract address for the reserve * @param _reserve the reserve address * @return the address of the interest rate strategy contract **/ function getReserveInterestRateStrategyAddress(address _reserve) public view returns (address) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.interestRateStrategyAddress; }  /** * @dev gets the aToken contract address for the reserve * @param _reserve the reserve address * @return the address of the aToken contract **/  function getReserveATokenAddress(address _reserve) public view returns (address) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.aTokenAddress; }  /** * @dev gets the available liquidity in the reserve. The available liquidity is the balance of the core contract * @param _reserve the reserve address * @return the available liquidity **/ function getReserveAvailableLiquidity(address _reserve) public view returns (uint256) {     uint256 balance = 0;      if (_reserve == EthAddressLib.ethAddress()) {         balance = address(this).balance;     } else {         balance = IERC20(_reserve).balanceOf(address(this));     }     return balance; }  /** * @dev gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows * @param _reserve the reserve address * @return the total liquidity **/ function getReserveTotalLiquidity(address _reserve) public view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return getReserveAvailableLiquidity(_reserve).add(reserve.getTotalBorrows()); }  /** * @dev gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there * there has been 100% income. * @param _reserve the reserve address * @return the reserve normalized income **/ function getReserveNormalizedIncome(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.getNormalizedIncome(); }  /** * @dev gets the reserve total borrows * @param _reserve the reserve address * @return the total borrows (stable + variable) **/ function getReserveTotalBorrows(address _reserve) public view returns (uint256) {     return reserves[_reserve].getTotalBorrows(); }  /** * @dev gets the reserve total borrows stable * @param _reserve the reserve address * @return the total borrows stable **/ function getReserveTotalBorrowsStable(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.totalBorrowsStable; }  /** * @dev gets the reserve total borrows variable * @param _reserve the reserve address * @return the total borrows variable **/  function getReserveTotalBorrowsVariable(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.totalBorrowsVariable; }  /** * @dev gets the reserve liquidation threshold * @param _reserve the reserve address * @return the reserve liquidation threshold **/  function getReserveLiquidationThreshold(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.liquidationThreshold; }  /** * @dev gets the reserve liquidation bonus * @param _reserve the reserve address * @return the reserve liquidation bonus **/  function getReserveLiquidationBonus(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.liquidationBonus; }  /** * @dev gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty * @param _reserve the reserve address * @return the reserve current variable borrow rate **/  function getReserveCurrentVariableBorrowRate(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      if (reserve.currentVariableBorrowRate == 0) {         return         IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)         .getBaseVariableBorrowRate();     }     return reserve.currentVariableBorrowRate; }  /** * @dev gets the reserve current stable borrow rate. Is the market rate if the reserve is empty * @param _reserve the reserve address * @return the reserve current stable borrow rate **/  function getReserveCurrentStableBorrowRate(address _reserve) public view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     ILendingRateOracle oracle = ILendingRateOracle(addressesProvider.getLendingRateOracle());      if (reserve.currentStableBorrowRate == 0) {         //no stable rate borrows yet         return oracle.getMarketBorrowRate(_reserve);     }      return reserve.currentStableBorrowRate; }  /** * @dev gets the reserve average stable borrow rate. The average stable rate is the weighted average * of all the loans taken at stable rate. * @param _reserve the reserve address * @return the reserve current average borrow rate **/ function getReserveCurrentAverageStableBorrowRate(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.currentAverageStableBorrowRate; }  /** * @dev gets the reserve liquidity rate * @param _reserve the reserve address * @return the reserve liquidity rate **/ function getReserveCurrentLiquidityRate(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.currentLiquidityRate; }  /** * @dev gets the reserve liquidity cumulative index * @param _reserve the reserve address * @return the reserve liquidity cumulative index **/ function getReserveLiquidityCumulativeIndex(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.lastLiquidityCumulativeIndex; }  /** * @dev gets the reserve variable borrow index * @param _reserve the reserve address * @return the reserve variable borrow index **/ function getReserveVariableBorrowsCumulativeIndex(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.lastVariableBorrowCumulativeIndex; }  /** * @dev this function aggregates the configuration parameters of the reserve. * It's used in the LendingPoolDataProvider specifically to save gas, and avoid * multiple external contract calls to fetch the same data. * @param _reserve the reserve address * @return the reserve decimals * @return the base ltv as collateral * @return the liquidation threshold * @return if the reserve is used as collateral or not **/ function getReserveConfiguration(address _reserve) external view returns (uint256, uint256, uint256, bool) {     uint256 decimals;     uint256 baseLTVasCollateral;     uint256 liquidationThreshold;     bool usageAsCollateralEnabled;      CoreLibrary.ReserveData storage reserve = reserves[_reserve];     decimals = reserve.decimals;     baseLTVasCollateral = reserve.baseLTVasCollateral;     liquidationThreshold = reserve.liquidationThreshold;     usageAsCollateralEnabled = reserve.usageAsCollateralEnabled;      return (decimals, baseLTVasCollateral, liquidationThreshold, usageAsCollateralEnabled); }  /** * @dev returns the decimals of the reserve * @param _reserve the reserve address * @return the reserve decimals **/ function getReserveDecimals(address _reserve) external view returns (uint256) {     return reserves[_reserve].decimals; }  /** * @dev returns true if the reserve is enabled for borrowing * @param _reserve the reserve address * @return true if the reserve is enabled for borrowing, false otherwise **/  function isReserveBorrowingEnabled(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.borrowingEnabled; }  /** * @dev returns true if the reserve is enabled as collateral * @param _reserve the reserve address * @return true if the reserve is enabled as collateral, false otherwise **/  function isReserveUsageAsCollateralEnabled(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.usageAsCollateralEnabled; }  /** * @dev returns true if the stable rate is enabled on reserve * @param _reserve the reserve address * @return true if the stable rate is enabled on reserve, false otherwise **/ function getReserveIsStableBorrowRateEnabled(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.isStableBorrowRateEnabled; }  /** * @dev returns true if the reserve is active * @param _reserve the reserve address * @return true if the reserve is active, false otherwise **/ function getReserveIsActive(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.isActive; }  /** * @notice returns if a reserve is freezed * @param _reserve the reserve for which the information is needed * @return true if the reserve is freezed, false otherwise **/  function getReserveIsFreezed(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.isFreezed; }  /** * @notice returns the timestamp of the last action on the reserve * @param _reserve the reserve for which the information is needed * @return the last updated timestamp of the reserve **/  function getReserveLastUpdate(address _reserve) external view returns (uint40 timestamp) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     timestamp = reserve.lastUpdateTimestamp; }  /** * @dev returns the utilization rate U of a specific reserve * @param _reserve the reserve for which the information is needed * @return the utilization rate in ray **/  function getReserveUtilizationRate(address _reserve) public view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      uint256 totalBorrows = reserve.getTotalBorrows();      if (totalBorrows == 0) {         return 0;     }      uint256 availableLiquidity = getReserveAvailableLiquidity(_reserve);      return totalBorrows.rayDiv(availableLiquidity.add(totalBorrows)); }  /** * @return the array of reserves configured on the core **/ function getReserves() external view returns (address[] memory) {     return reservesList; }  /** * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return true if the user has chosen to use the reserve as collateral, false otherwise **/ function isUserUseReserveAsCollateralEnabled(address _reserve, address _user) external view returns (bool) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.useAsCollateral; }  /** * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the origination fee for the user **/ function getUserOriginationFee(address _reserve, address _user) external view returns (uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.originationFee; }  /** * @dev users with no loans in progress have NONE as borrow rate mode * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the borrow rate mode for the user, **/  function getUserCurrentBorrowRateMode(address _reserve, address _user) public view returns (CoreLibrary.InterestRateMode) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      if (user.principalBorrowBalance == 0) {         return CoreLibrary.InterestRateMode.NONE;     }      return     user.stableBorrowRate &gt; 0     ? CoreLibrary.InterestRateMode.STABLE     : CoreLibrary.InterestRateMode.VARIABLE; }  /** * @dev gets the current borrow rate of the user * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the borrow rate for the user, **/ function getUserCurrentBorrowRate(address _reserve, address _user) internal view returns (uint256) {     CoreLibrary.InterestRateMode rateMode = getUserCurrentBorrowRateMode(_reserve, _user);      if (rateMode == CoreLibrary.InterestRateMode.NONE) {         return 0;     }      return     rateMode == CoreLibrary.InterestRateMode.STABLE     ? usersReserveData[_user][_reserve].stableBorrowRate     : reserves[_reserve].currentVariableBorrowRate; }  /** * @dev the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the user stable rate **/ function getUserCurrentStableBorrowRate(address _reserve, address _user) external view returns (uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.stableBorrowRate; }  /** * @dev calculates and returns the borrow balances of the user * @param _reserve the address of the reserve * @param _user the address of the user * @return the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance **/  function getUserBorrowBalances(address _reserve, address _user) public view returns (uint256, uint256, uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     if (user.principalBorrowBalance == 0) {         return (0, 0, 0);     }      uint256 principal = user.principalBorrowBalance;     uint256 compoundedBalance = CoreLibrary.getCompoundedBorrowBalance(         user,         reserves[_reserve]     );     return (principal, compoundedBalance, compoundedBalance.sub(principal)); }  /** * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the variable borrow index for the user **/  function getUserVariableBorrowCumulativeIndex(address _reserve, address _user) external view returns (uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.lastVariableBorrowCumulativeIndex; }  /** * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the variable borrow index for the user **/  function getUserLastUpdate(address _reserve, address _user) external view returns (uint256 timestamp) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     timestamp = user.lastUpdateTimestamp; }  /** * @dev updates the lending pool core configuration **/ function refreshConfiguration() external onlyLendingPoolConfigurator {     refreshConfigInternal(); }  /** * @dev initializes a reserve * @param _reserve the address of the reserve * @param _aTokenAddress the address of the overlying aToken contract * @param _decimals the decimals of the reserve currency * @param _interestRateStrategyAddress the address of the interest rate strategy contract **/ function initReserve(     address _reserve,     address _aTokenAddress,     uint256 _decimals,     address _interestRateStrategyAddress ) external onlyLendingPoolConfigurator {     reserves[_reserve].init(_aTokenAddress, _decimals, _interestRateStrategyAddress);     addReserveToListInternal(_reserve);  }    /** * @dev removes the last added reserve in the reservesList array * @param _reserveToRemove the address of the reserve **/ function removeLastAddedReserve(address _reserveToRemove) external onlyLendingPoolConfigurator {      address lastReserve = reservesList[reservesList.length-1];      require(lastReserve == _reserveToRemove, "Reserve being removed is different than the reserve requested");      //as we can't check if totalLiquidity is 0 (since the reserve added might not be an ERC20) we at least check that there is nothing borrowed     require(getReserveTotalBorrows(lastReserve) == 0, "Cannot remove a reserve with liquidity deposited");      reserves[lastReserve].isActive = false;     reserves[lastReserve].aTokenAddress = address(0);     reserves[lastReserve].decimals = 0;     reserves[lastReserve].lastLiquidityCumulativeIndex = 0;     reserves[lastReserve].lastVariableBorrowCumulativeIndex = 0;     reserves[lastReserve].borrowingEnabled = false;     reserves[lastReserve].usageAsCollateralEnabled = false;     reserves[lastReserve].baseLTVasCollateral = 0;     reserves[lastReserve].liquidationThreshold = 0;     reserves[lastReserve].liquidationBonus = 0;     reserves[lastReserve].interestRateStrategyAddress = address(0);      reservesList.pop(); }  /** * @dev updates the address of the interest rate strategy contract * @param _reserve the address of the reserve * @param _rateStrategyAddress the address of the interest rate strategy contract **/  function setReserveInterestRateStrategyAddress(address _reserve, address _rateStrategyAddress) external onlyLendingPoolConfigurator {     reserves[_reserve].interestRateStrategyAddress = _rateStrategyAddress; }  /** * @dev enables borrowing on a reserve. Also sets the stable rate borrowing * @param _reserve the address of the reserve * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise **/  function enableBorrowingOnReserve(address _reserve, bool _stableBorrowRateEnabled) external onlyLendingPoolConfigurator {     reserves[_reserve].enableBorrowing(_stableBorrowRateEnabled); }  /** * @dev disables borrowing on a reserve * @param _reserve the address of the reserve **/  function disableBorrowingOnReserve(address _reserve) external onlyLendingPoolConfigurator {     reserves[_reserve].disableBorrowing(); }  /** * @dev enables a reserve to be used as collateral * @param _reserve the address of the reserve **/ function enableReserveAsCollateral(     address _reserve,     uint256 _baseLTVasCollateral,     uint256 _liquidationThreshold,     uint256 _liquidationBonus ) external onlyLendingPoolConfigurator {     reserves[_reserve].enableAsCollateral(         _baseLTVasCollateral,         _liquidationThreshold,         _liquidationBonus     ); }  /** * @dev disables a reserve to be used as collateral * @param _reserve the address of the reserve **/ function disableReserveAsCollateral(address _reserve) external onlyLendingPoolConfigurator {     reserves[_reserve].disableAsCollateral(); }  /** * @dev enable the stable borrow rate mode on a reserve * @param _reserve the address of the reserve **/ function enableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isStableBorrowRateEnabled = true; }  /** * @dev disable the stable borrow rate mode on a reserve * @param _reserve the address of the reserve **/ function disableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isStableBorrowRateEnabled = false; }  /** * @dev activates a reserve * @param _reserve the address of the reserve **/ function activateReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      require(         reserve.lastLiquidityCumulativeIndex &gt; 0 &amp;&amp;         reserve.lastVariableBorrowCumulativeIndex &gt; 0,         "Reserve has not been initialized yet"     );     reserve.isActive = true; }  /** * @dev deactivates a reserve * @param _reserve the address of the reserve **/ function deactivateReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isActive = false; }  /** * @notice allows the configurator to freeze the reserve. * A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance. * @param _reserve the address of the reserve **/ function freezeReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isFreezed = true; }  /** * @notice allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed. * @param _reserve the address of the reserve **/ function unfreezeReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isFreezed = false; }  /** * @notice allows the configurator to update the loan to value of a reserve * @param _reserve the address of the reserve * @param _ltv the new loan to value **/ function setReserveBaseLTVasCollateral(address _reserve, uint256 _ltv) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.baseLTVasCollateral = _ltv; }  /** * @notice allows the configurator to update the liquidation threshold of a reserve * @param _reserve the address of the reserve * @param _threshold the new liquidation threshold **/ function setReserveLiquidationThreshold(address _reserve, uint256 _threshold) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.liquidationThreshold = _threshold; }  /** * @notice allows the configurator to update the liquidation bonus of a reserve * @param _reserve the address of the reserve * @param _bonus the new liquidation bonus **/ function setReserveLiquidationBonus(address _reserve, uint256 _bonus) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.liquidationBonus = _bonus; }  /** * @notice allows the configurator to update the reserve decimals * @param _reserve the address of the reserve * @param _decimals the decimals of the reserve **/ function setReserveDecimals(address _reserve, uint256 _decimals) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.decimals = _decimals; }  /** * @notice internal functions **/  /** * @dev updates the state of a reserve as a consequence of a borrow action. * @param _reserve the address of the reserve on which the user is borrowing * @param _user the address of the borrower * @param _principalBorrowBalance the previous borrow balance of the borrower before the action * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount * @param _amountBorrowed the new amount borrowed * @param _rateMode the borrow rate mode (stable, variable) **/  function updateReserveStateOnBorrowInternal(     address _reserve,     address _user,     uint256 _principalBorrowBalance,     uint256 _balanceIncrease,     uint256 _amountBorrowed,     CoreLibrary.InterestRateMode _rateMode ) internal {     reserves[_reserve].updateCumulativeIndexes();      //increasing reserve total borrows to account for the new borrow balance of the user     //NOTE: Depending on the previous borrow mode, the borrows might need to be switched from variable to stable or vice versa      updateReserveTotalBorrowsByRateModeInternal(         _reserve,         _user,         _principalBorrowBalance,         _balanceIncrease,         _amountBorrowed,         _rateMode     ); }  /** * @dev updates the state of a user as a consequence of a borrow action. * @param _reserve the address of the reserve on which the user is borrowing * @param _user the address of the borrower * @param _amountBorrowed the amount borrowed * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount * @param _rateMode the borrow rate mode (stable, variable) * @return the final borrow rate for the user. Emitted by the borrow() event **/  function updateUserStateOnBorrowInternal(     address _reserve,     address _user,     uint256 _amountBorrowed,     uint256 _balanceIncrease,     uint256 _fee,     CoreLibrary.InterestRateMode _rateMode ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      if (_rateMode == CoreLibrary.InterestRateMode.STABLE) {         //stable         //reset the user variable index, and update the stable rate         user.stableBorrowRate = reserve.currentStableBorrowRate;         user.lastVariableBorrowCumulativeIndex = 0;     } else if (_rateMode == CoreLibrary.InterestRateMode.VARIABLE) {         //variable         //reset the user stable rate, and store the new borrow index         user.stableBorrowRate = 0;         user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;     } else {         revert("Invalid borrow rate mode");     }     //increase the principal borrows and the origination fee     user.principalBorrowBalance = user.principalBorrowBalance.add(_amountBorrowed).add(         _balanceIncrease     );     user.originationFee = user.originationFee.add(_fee);      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp);  }  /** * @dev updates the state of the reserve as a consequence of a repay action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _paybackAmountMinusFees the amount being paid back minus fees * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updateReserveStateOnRepayInternal(     address _reserve,     address _user,     uint256 _paybackAmountMinusFees,     uint256 _balanceIncrease ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_reserve][_user];      CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(_reserve, _user);      //update the indexes     reserves[_reserve].updateCumulativeIndexes();      //compound the cumulated interest to the borrow balance and then subtracting the payback amount     if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             _balanceIncrease,             user.stableBorrowRate         );         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _paybackAmountMinusFees,             user.stableBorrowRate         );     } else {         reserve.increaseTotalBorrowsVariable(_balanceIncrease);         reserve.decreaseTotalBorrowsVariable(_paybackAmountMinusFees);     } }  /** * @dev updates the state of the user as a consequence of a repay action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _paybackAmountMinusFees the amount being paid back minus fees * @param _originationFeeRepaid the fee on the amount that is being repaid * @param _balanceIncrease the accrued interest on the borrowed amount * @param _repaidWholeLoan true if the user is repaying the whole loan **/ function updateUserStateOnRepayInternal(     address _reserve,     address _user,     uint256 _paybackAmountMinusFees,     uint256 _originationFeeRepaid,     uint256 _balanceIncrease,     bool _repaidWholeLoan ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      //update the user principal borrow balance, adding the cumulated interest and then subtracting the payback amount     user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(         _paybackAmountMinusFees     );     user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;      //if the balance decrease is equal to the previous principal (user is repaying the whole loan)     //and the rate mode is stable, we reset the interest rate mode of the user     if (_repaidWholeLoan) {         user.stableBorrowRate = 0;         user.lastVariableBorrowCumulativeIndex = 0;     }     user.originationFee = user.originationFee.sub(_originationFeeRepaid);      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp);  }  /** * @dev updates the state of the user as a consequence of a swap rate action. * @param _reserve the address of the reserve on which the user is performing the rate swap * @param _user the address of the borrower * @param _principalBorrowBalance the the principal amount borrowed by the user * @param _compoundedBorrowBalance the principal amount plus the accrued interest * @param _currentRateMode the rate mode at which the user borrowed **/ function updateReserveStateOnSwapRateInternal(     address _reserve,     address _user,     uint256 _principalBorrowBalance,     uint256 _compoundedBorrowBalance,     CoreLibrary.InterestRateMode _currentRateMode ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      //compounding reserve indexes     reserve.updateCumulativeIndexes();      if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {         uint256 userCurrentStableRate = user.stableBorrowRate;          //swap to variable         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _principalBorrowBalance,             userCurrentStableRate         ); //decreasing stable from old principal balance         reserve.increaseTotalBorrowsVariable(_compoundedBorrowBalance); //increase variable borrows     } else if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         //swap to stable         uint256 currentStableRate = reserve.currentStableBorrowRate;         reserve.decreaseTotalBorrowsVariable(_principalBorrowBalance);         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             _compoundedBorrowBalance,             currentStableRate         );      } else {         revert("Invalid rate mode received");     } }  /** * @dev updates the state of the user as a consequence of a swap rate action. * @param _reserve the address of the reserve on which the user is performing the swap * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount * @param _currentRateMode the current rate mode of the user **/  function updateUserStateOnSwapRateInternal(     address _reserve,     address _user,     uint256 _balanceIncrease,     CoreLibrary.InterestRateMode _currentRateMode ) internal returns (CoreLibrary.InterestRateMode) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      CoreLibrary.InterestRateMode newMode = CoreLibrary.InterestRateMode.NONE;      if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         //switch to stable         newMode = CoreLibrary.InterestRateMode.STABLE;         user.stableBorrowRate = reserve.currentStableBorrowRate;         user.lastVariableBorrowCumulativeIndex = 0;     } else if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {         newMode = CoreLibrary.InterestRateMode.VARIABLE;         user.stableBorrowRate = 0;         user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;     } else {         revert("Invalid interest rate mode received");     }     //compounding cumulated interest     user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);     //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp);      return newMode; }  /** * @dev updates the state of the principal reserve as a consequence of a liquidation action. * @param _principalReserve the address of the principal reserve that is being repaid * @param _user the address of the borrower * @param _amountToLiquidate the amount being repaid by the liquidator * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updatePrincipalReserveStateOnLiquidationInternal(     address _principalReserve,     address _user,     uint256 _amountToLiquidate,     uint256 _balanceIncrease ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_principalReserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_principalReserve];      //update principal reserve data     reserve.updateCumulativeIndexes();      CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(         _principalReserve,         _user     );      if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {         //increase the total borrows by the compounded interest         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             _balanceIncrease,             user.stableBorrowRate         );          //decrease by the actual amount to liquidate         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _amountToLiquidate,             user.stableBorrowRate         );      } else {         //increase the total borrows by the compounded interest         reserve.increaseTotalBorrowsVariable(_balanceIncrease);          //decrease by the actual amount to liquidate         reserve.decreaseTotalBorrowsVariable(_amountToLiquidate);     }  }  /** * @dev updates the state of the collateral reserve as a consequence of a liquidation action. * @param _collateralReserve the address of the collateral reserve that is being liquidated **/ function updateCollateralReserveStateOnLiquidationInternal(     address _collateralReserve ) internal {     //update collateral reserve     reserves[_collateralReserve].updateCumulativeIndexes();  }  /** * @dev updates the state of the user being liquidated as a consequence of a liquidation action. * @param _reserve the address of the principal reserve that is being repaid * @param _user the address of the borrower * @param _amountToLiquidate the amount being repaid by the liquidator * @param _feeLiquidated the amount of origination fee being liquidated * @param _balanceIncrease the accrued interest on the borrowed amount **/ function updateUserStateOnLiquidationInternal(     address _reserve,     address _user,     uint256 _amountToLiquidate,     uint256 _feeLiquidated,     uint256 _balanceIncrease ) internal {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     //first increase by the compounded interest, then decrease by the liquidated amount     user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(         _amountToLiquidate     );      if (         getUserCurrentBorrowRateMode(_reserve, _user) == CoreLibrary.InterestRateMode.VARIABLE     ) {         user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;     }      if(_feeLiquidated &gt; 0){         user.originationFee = user.originationFee.sub(_feeLiquidated);     }      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp); }  /** * @dev updates the state of the reserve as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updateReserveStateOnRebalanceInternal(     address _reserve,     address _user,     uint256 _balanceIncrease ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      reserve.updateCumulativeIndexes();      reserve.increaseTotalBorrowsStableAndUpdateAverageRate(         _balanceIncrease,         user.stableBorrowRate     );  }  /** * @dev updates the state of the user as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updateUserStateOnRebalanceInternal(     address _reserve,     address _user,     uint256 _balanceIncrease ) internal {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);     user.stableBorrowRate = reserve.currentStableBorrowRate;      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp); }  /** * @dev updates the state of the user as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount * @param _amountBorrowed the accrued interest on the borrowed amount **/ function updateReserveTotalBorrowsByRateModeInternal(     address _reserve,     address _user,     uint256 _principalBalance,     uint256 _balanceIncrease,     uint256 _amountBorrowed,     CoreLibrary.InterestRateMode _newBorrowRateMode ) internal {     CoreLibrary.InterestRateMode previousRateMode = getUserCurrentBorrowRateMode(         _reserve,         _user     );     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      if (previousRateMode == CoreLibrary.InterestRateMode.STABLE) {         CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _principalBalance,             user.stableBorrowRate         );     } else if (previousRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         reserve.decreaseTotalBorrowsVariable(_principalBalance);     }      uint256 newPrincipalAmount = _principalBalance.add(_balanceIncrease).add(_amountBorrowed);     if (_newBorrowRateMode == CoreLibrary.InterestRateMode.STABLE) {         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             newPrincipalAmount,             reserve.currentStableBorrowRate         );     } else if (_newBorrowRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         reserve.increaseTotalBorrowsVariable(newPrincipalAmount);     } else {         revert("Invalid new borrow rate mode");     } }  /** * @dev Updates the reserve current stable borrow rate Rf, the current variable borrow rate Rv and the current liquidity rate Rl. * Also updates the lastUpdateTimestamp value. Please refer to the whitepaper for further information. * @param _reserve the address of the reserve to be updated * @param _liquidityAdded the amount of liquidity added to the protocol (deposit or repay) in the previous action * @param _liquidityTaken the amount of liquidity taken from the protocol (redeem or borrow) **/  function updateReserveInterestRatesAndTimestampInternal(     address _reserve,     uint256 _liquidityAdded,     uint256 _liquidityTaken ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     (uint256 newLiquidityRate, uint256 newStableRate, uint256 newVariableRate) = IReserveInterestRateStrategy(         reserve         .interestRateStrategyAddress     )     .calculateInterestRates(         _reserve,         getReserveAvailableLiquidity(_reserve).add(_liquidityAdded).sub(_liquidityTaken),         reserve.totalBorrowsStable,         reserve.totalBorrowsVariable,         reserve.currentAverageStableBorrowRate     );      reserve.currentLiquidityRate = newLiquidityRate;     reserve.currentStableBorrowRate = newStableRate;     reserve.currentVariableBorrowRate = newVariableRate;      //solium-disable-next-line     reserve.lastUpdateTimestamp = uint40(block.timestamp);      emit ReserveUpdated(         _reserve,         newLiquidityRate,         newStableRate,         newVariableRate,         reserve.lastLiquidityCumulativeIndex,         reserve.lastVariableBorrowCumulativeIndex     ); }  /** * @dev transfers to the protocol fees of a flashloan to the fees collection address * @param _token the address of the token being transferred * @param _amount the amount being transferred **/  function transferFlashLoanProtocolFeeInternal(address _token, uint256 _amount) internal {     address payable receiver = address(uint160(addressesProvider.getTokenDistributor()));      if (_token != EthAddressLib.ethAddress()) {         ERC20(_token).safeTransfer(receiver, _amount);     } else {         receiver.transfer(_amount);     } }  /** * @dev updates the internal configuration of the core **/ function refreshConfigInternal() internal {     lendingPoolAddress = addressesProvider.getLendingPool(); }  /** * @dev adds a reserve to the array of the reserves address **/ function addReserveToListInternal(address _reserve) internal {     bool reserveAlreadyAdded = false;     for (uint256 i = 0; i &lt; reservesList.length; i++)         if (reservesList[i] == _reserve) {             reserveAlreadyAdded = true;         }     if (!reserveAlreadyAdded) reservesList.push(_reserve); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 04:31:57 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: pragma solidity ^0.5.0;

import "openzeppelin-solidity/contracts/math/SafeMath.sol";
import "openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol";
import "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol";
import "openzeppelin-solidity/contracts/utils/Address.sol";
import "../libraries/openzeppelin-upgradeability/VersionedInitializable.sol";

import "../libraries/CoreLibrary.sol";
import "../configuration/LendingPoolAddressesProvider.sol";
import "../interfaces/ILendingRateOracle.sol";
import "../interfaces/IReserveInterestRateStrategy.sol";
import "../libraries/WadRayMath.sol";
import "../tokenization/AToken.sol";
import "../libraries/EthAddressLib.sol";

/**
* @title LendingPoolCore contract
* @author Aave
* @notice Holds the state of the lending pool and all the funds deposited
* @dev NOTE: The core does not enforce security checks on the update of the state
* (eg, updateStateOnBorrow() does not enforce that borrowed is enabled on the reserve).
* The check that an action can be performed is a duty of the overlying LendingPool contract.
**/

contract LendingPoolCore is VersionedInitializable {
    using SafeMath for uint256;
    using WadRayMath for uint256;
    using CoreLibrary for CoreLibrary.ReserveData;
    using CoreLibrary for CoreLibrary.UserReserveData;
    using SafeERC20 for ERC20;
    using Address for address payable;

    /**
    * @dev Emitted when the state of a reserve is updated
    * @param reserve the address of the reserve
    * @param liquidityRate the new liquidity rate
    * @param stableBorrowRate the new stable borrow rate
    * @param variableBorrowRate the new variable borrow rate
    * @param liquidityIndex the new liquidity index
    * @param variableBorrowIndex the new variable borrow index
    **/
    event ReserveUpdated(
        address indexed reserve,
        uint256 liquidityRate,
        uint256 stableBorrowRate,
        uint256 variableBorrowRate,
        uint256 liquidityIndex,
        uint256 variableBorrowIndex
    );

    address public lendingPoolAddress;

    LendingPoolAddressesProvider public addressesProvider;

    /**
    * @dev only lending pools can use functions affected by this modifier
    **/
    modifier onlyLendingPool {
        require(lendingPoolAddress == msg.sender, "The caller must be a lending pool contract");
        _;
    }

    /**
    * @dev only lending pools configurator can use functions affected by this modifier
    **/
    modifier onlyLendingPoolConfigurator {
        require(
            addressesProvider.getLendingPoolConfigurator() == msg.sender,
            "The caller must be a lending pool configurator contract"
        );
        _;
    }

    mapping(address => CoreLibrary.ReserveData) internal reserves;
    mapping(address => mapping(address => CoreLibrary.UserReserveData)) internal usersReserveData;

    address[] public reservesList;

    uint256 public constant CORE_REVISION = 0x4;

    /**
    * @dev returns the revision number of the contract
    **/
    function getRevision() internal pure returns (uint256) {
        return CORE_REVISION;
    }

    /**
    * @dev initializes the Core contract, invoked upon registration on the AddressesProvider
    * @param _addressesProvider the addressesProvider contract
    **/

    function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {
        addressesProvider = _addressesProvider;
        refreshConfigInternal();
    }

    /**
    * @dev updates the state of the core as a result of a deposit action
    * @param _reserve the address of the reserve in which the deposit is happening
    * @param _user the address of the the user depositing
    * @param _amount the amount being deposited
    * @param _isFirstDeposit true if the user is depositing for the first time
    **/

    function updateStateOnDeposit(
        address _reserve,
        address _user,
        uint256 _amount,
        bool _isFirstDeposit
    ) external onlyLendingPool {
        reserves[_reserve].updateCumulativeIndexes();
        updateReserveInterestRatesAndTimestampInternal(_reserve, _amount, 0);

        if (_isFirstDeposit) {
            //if this is the first deposit of the user, we configure the deposit as enabled to be used as collateral
            setUserUseReserveAsCollateral(_reserve, _user, true);
        }
    }

    /**
    * @dev updates the state of the core as a result of a redeem action
    * @param _reserve the address of the reserve in which the redeem is happening
    * @param _user the address of the the user redeeming
    * @param _amountRedeemed the amount being redeemed
    * @param _userRedeemedEverything true if the user is redeeming everything
    **/
    function updateStateOnRedeem(
        address _reserve,
        address _user,
        uint256 _amountRedeemed,
        bool _userRedeemedEverything
    ) external onlyLendingPool {
        //compound liquidity and variable borrow interests
        reserves[_reserve].updateCumulativeIndexes();
        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountRedeemed);

        //if user redeemed everything the useReserveAsCollateral flag is reset
        if (_userRedeemedEverything) {
            setUserUseReserveAsCollateral(_reserve, _user, false);
        }
    }

    /**
    * @dev updates the state of the core as a result of a flashloan action
    * @param _reserve the address of the reserve in which the flashloan is happening
    * @param _income the income of the protocol as a result of the action
    **/
    function updateStateOnFlashLoan(
        address _reserve,
        uint256 _availableLiquidityBefore,
        uint256 _income,
        uint256 _protocolFee
    ) external onlyLendingPool {
        transferFlashLoanProtocolFeeInternal(_reserve, _protocolFee);

        //compounding the cumulated interest
        reserves[_reserve].updateCumulativeIndexes();

        uint256 totalLiquidityBefore = _availableLiquidityBefore.add(
            getReserveTotalBorrows(_reserve)
        );

        //compounding the received fee into the reserve
        reserves[_reserve].cumulateToLiquidityIndex(totalLiquidityBefore, _income);

        //refresh interest rates
        updateReserveInterestRatesAndTimestampInternal(_reserve, _income, 0);
    }

    /**
    * @dev updates the state of the core as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _amountBorrowed the new amount borrowed
    * @param _borrowFee the fee on the amount borrowed
    * @param _rateMode the borrow rate mode (stable, variable)
    * @return the new borrow rate for the user
    **/
    function updateStateOnBorrow(
        address _reserve,
        address _user,
        uint256 _amountBorrowed,
        uint256 _borrowFee,
        CoreLibrary.InterestRateMode _rateMode
    ) external onlyLendingPool returns (uint256, uint256) {
        // getting the previous borrow data of the user
        (uint256 principalBorrowBalance, , uint256 balanceIncrease) = getUserBorrowBalances(
            _reserve,
            _user
        );

        updateReserveStateOnBorrowInternal(
            _reserve,
            _user,
            principalBorrowBalance,
            balanceIncrease,
            _amountBorrowed,
            _rateMode
        );

        updateUserStateOnBorrowInternal(
            _reserve,
            _user,
            _amountBorrowed,
            balanceIncrease,
            _borrowFee,
            _rateMode
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountBorrowed);

        return (getUserCurrentBorrowRate(_reserve, _user), balanceIncrease);
    }

    /**
    * @dev updates the state of the core as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _originationFeeRepaid the fee on the amount that is being repaid
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _repaidWholeLoan true if the user is repaying the whole loan
    **/

    function updateStateOnRepay(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _originationFeeRepaid,
        uint256 _balanceIncrease,
        bool _repaidWholeLoan
    ) external onlyLendingPool {
        updateReserveStateOnRepayInternal(
            _reserve,
            _user,
            _paybackAmountMinusFees,
            _balanceIncrease
        );
        updateUserStateOnRepayInternal(
            _reserve,
            _user,
            _paybackAmountMinusFees,
            _originationFeeRepaid,
            _balanceIncrease,
            _repaidWholeLoan
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, _paybackAmountMinusFees, 0);
    }

    /**
    * @dev updates the state of the core as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the amount borrowed by the user
    * @param _compoundedBorrowBalance the amount borrowed plus accrued interest
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _currentRateMode the current interest rate mode for the user
    **/
    function updateStateOnSwapRate(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _compoundedBorrowBalance,
        uint256 _balanceIncrease,
        CoreLibrary.InterestRateMode _currentRateMode
    ) external onlyLendingPool returns (CoreLibrary.InterestRateMode, uint256) {
        updateReserveStateOnSwapRateInternal(
            _reserve,
            _user,
            _principalBorrowBalance,
            _compoundedBorrowBalance,
            _currentRateMode
        );

        CoreLibrary.InterestRateMode newRateMode = updateUserStateOnSwapRateInternal(
            _reserve,
            _user,
            _balanceIncrease,
            _currentRateMode
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);

        return (newRateMode, getUserCurrentBorrowRate(_reserve, _user));
    }

    /**
    * @dev updates the state of the core as a consequence of a liquidation action.
    * @param _principalReserve the address of the principal reserve that is being repaid
    * @param _collateralReserve the address of the collateral reserve that is being liquidated
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _collateralToLiquidate the amount of collateral being liquidated
    * @param _feeLiquidated the amount of origination fee being liquidated
    * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise
    **/
    function updateStateOnLiquidation(
        address _principalReserve,
        address _collateralReserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _collateralToLiquidate,
        uint256 _feeLiquidated,
        uint256 _liquidatedCollateralForFee,
        uint256 _balanceIncrease,
        bool _liquidatorReceivesAToken
    ) external onlyLendingPool {
        updatePrincipalReserveStateOnLiquidationInternal(
            _principalReserve,
            _user,
            _amountToLiquidate,
            _balanceIncrease
        );

        updateCollateralReserveStateOnLiquidationInternal(
            _collateralReserve
        );

        updateUserStateOnLiquidationInternal(
            _principalReserve,
            _user,
            _amountToLiquidate,
            _feeLiquidated,
            _balanceIncrease
        );

        updateReserveInterestRatesAndTimestampInternal(_principalReserve, _amountToLiquidate, 0);

        if (!_liquidatorReceivesAToken) {
            updateReserveInterestRatesAndTimestampInternal(
                _collateralReserve,
                0,
                _collateralToLiquidate.add(_liquidatedCollateralForFee)
            );
        }

    }

    /**
    * @dev updates the state of the core as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @return the new stable rate for the user
    **/
    function updateStateOnRebalance(address _reserve, address _user, uint256 _balanceIncrease)
    external
    onlyLendingPool
    returns (uint256)
    {
        updateReserveStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);

        //update user data and rebalance the rate
        updateUserStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);
        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);
        return usersReserveData[_user][_reserve].stableBorrowRate;
    }

    /**
    * @dev enables or disables a reserve as collateral
    * @param _reserve the address of the principal reserve where the user deposited
    * @param _user the address of the depositor
    * @param _useAsCollateral true if the depositor wants to use the reserve as collateral
    **/
    function setUserUseReserveAsCollateral(address _reserve, address _user, bool _useAsCollateral)
    public
    onlyLendingPool
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        user.useAsCollateral = _useAsCollateral;
    }

    /**
    * @notice ETH/token transfer functions
    **/

    /**
    * @dev fallback function enforces that the caller is a contract, to support flashloan transfers
    **/
    function() external payable {
        //only contracts can send ETH to the core
        require(msg.sender.isContract(), "Only contracts can send ether to the Lending pool core");

    }

    /**
    * @dev transfers to the user a specific amount from the reserve.
    * @param _reserve the address of the reserve where the transfer is happening
    * @param _user the address of the user receiving the transfer
    * @param _amount the amount being transferred
    **/
    function transferToUser(address _reserve, address payable _user, uint256 _amount)
    external
    onlyLendingPool
    {
        if (_reserve != EthAddressLib.ethAddress()) {
            ERC20(_reserve).safeTransfer(_user, _amount);
        } else {
            //solium-disable-next-line
            (bool result, ) = _user.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers the protocol fees to the fees collection address
    * @param _token the address of the token being transferred
    * @param _user the address of the user from where the transfer is happening
    * @param _amount the amount being transferred
    * @param _destination the fee receiver address
    **/

    function transferToFeeCollectionAddress(
        address _token,
        address _user,
        uint256 _amount,
        address _destination
    ) external payable onlyLendingPool {
        address payable feeAddress = address(uint160(_destination)); //cast the address to payable

        if (_token != EthAddressLib.ethAddress()) {
            require(
                msg.value == 0,
                "User is sending ETH along with the ERC20 transfer. Check the value attribute of the transaction"
            );
            ERC20(_token).safeTransferFrom(_user, feeAddress, _amount);
        } else {
            require(msg.value >= _amount, "The amount and the value sent to deposit do not match");
            //solium-disable-next-line
            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers the fees to the fees collection address in the case of liquidation
    * @param _token the address of the token being transferred
    * @param _amount the amount being transferred
    * @param _destination the fee receiver address
    **/
    function liquidateFee(
        address _token,
        uint256 _amount,
        address _destination
    ) external payable onlyLendingPool {
        address payable feeAddress = address(uint160(_destination)); //cast the address to payable
        require(
            msg.value == 0,
            "Fee liquidation does not require any transfer of value"
        );

        if (_token != EthAddressLib.ethAddress()) {
            ERC20(_token).safeTransfer(feeAddress, _amount);
        } else {
            //solium-disable-next-line
            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers an amount from a user to the destination reserve
    * @param _reserve the address of the reserve where the amount is being transferred
    * @param _user the address of the user from where the transfer is happening
    * @param _amount the amount being transferred
    **/
    function transferToReserve(address _reserve, address payable _user, uint256 _amount)
    external
    payable
    onlyLendingPool
    {
        if (_reserve != EthAddressLib.ethAddress()) {
            require(msg.value == 0, "User is sending ETH along with the ERC20 transfer.");
            ERC20(_reserve).safeTransferFrom(_user, address(this), _amount);

        } else {
            require(msg.value >= _amount, "The amount and the value sent to deposit do not match");

            if (msg.value > _amount) {
                //send back excess ETH
                uint256 excessAmount = msg.value.sub(_amount);
                //solium-disable-next-line
                (bool result, ) = _user.call.value(excessAmount).gas(50000)("");
                require(result, "Transfer of ETH failed");
            }
        }
    }

    /**
    * @notice data access functions
    **/

    /**
    * @dev returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral)
    * needed to calculate the global account data in the LendingPoolDataProvider
    * @param _reserve the address of the reserve
    * @param _user the address of the user
    * @return the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not
    **/
    function getUserBasicReserveData(address _reserve, address _user)
    external
    view
    returns (uint256, uint256, uint256, bool)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        uint256 underlyingBalance = getUserUnderlyingAssetBalance(_reserve, _user);

        if (user.principalBorrowBalance == 0) {
            return (underlyingBalance, 0, 0, user.useAsCollateral);
        }

        return (
        underlyingBalance,
        user.getCompoundedBorrowBalance(reserve),
        user.originationFee,
        user.useAsCollateral
        );
    }

    /**
    * @dev checks if a user is allowed to borrow at a stable rate
    * @param _reserve the reserve address
    * @param _user the user
    * @param _amount the amount the the user wants to borrow
    * @return true if the user is allowed to borrow at a stable rate, false otherwise
    **/

    function isUserAllowedToBorrowAtStable(address _reserve, address _user, uint256 _amount)
    external
    view
    returns (bool)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (!reserve.isStableBorrowRateEnabled) return false;

        return
        !user.useAsCollateral ||
        !reserve.usageAsCollateralEnabled ||
        _amount > getUserUnderlyingAssetBalance(_reserve, _user);
    }

    /**
    * @dev gets the underlying asset balance of a user based on the corresponding aToken balance.
    * @param _reserve the reserve address
    * @param _user the user address
    * @return the underlying deposit balance of the user
    **/

    function getUserUnderlyingAssetBalance(address _reserve, address _user)
    public
    view
    returns (uint256)
    {
        AToken aToken = AToken(reserves[_reserve].aTokenAddress);
        return aToken.balanceOf(_user);

    }

    /**
    * @dev gets the interest rate strategy contract address for the reserve
    * @param _reserve the reserve address
    * @return the address of the interest rate strategy contract
    **/
    function getReserveInterestRateStrategyAddress(address _reserve) public view returns (address) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.interestRateStrategyAddress;
    }

    /**
    * @dev gets the aToken contract address for the reserve
    * @param _reserve the reserve address
    * @return the address of the aToken contract
    **/

    function getReserveATokenAddress(address _reserve) public view returns (address) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.aTokenAddress;
    }

    /**
    * @dev gets the available liquidity in the reserve. The available liquidity is the balance of the core contract
    * @param _reserve the reserve address
    * @return the available liquidity
    **/
    function getReserveAvailableLiquidity(address _reserve) public view returns (uint256) {
        uint256 balance = 0;

        if (_reserve == EthAddressLib.ethAddress()) {
            balance = address(this).balance;
        } else {
            balance = IERC20(_reserve).balanceOf(address(this));
        }
        return balance;
    }

    /**
    * @dev gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows
    * @param _reserve the reserve address
    * @return the total liquidity
    **/
    function getReserveTotalLiquidity(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return getReserveAvailableLiquidity(_reserve).add(reserve.getTotalBorrows());
    }

    /**
    * @dev gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there
    * there has been 100% income.
    * @param _reserve the reserve address
    * @return the reserve normalized income
    **/
    function getReserveNormalizedIncome(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.getNormalizedIncome();
    }

    /**
    * @dev gets the reserve total borrows
    * @param _reserve the reserve address
    * @return the total borrows (stable + variable)
    **/
    function getReserveTotalBorrows(address _reserve) public view returns (uint256) {
        return reserves[_reserve].getTotalBorrows();
    }

    /**
    * @dev gets the reserve total borrows stable
    * @param _reserve the reserve address
    * @return the total borrows stable
    **/
    function getReserveTotalBorrowsStable(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.totalBorrowsStable;
    }

    /**
    * @dev gets the reserve total borrows variable
    * @param _reserve the reserve address
    * @return the total borrows variable
    **/

    function getReserveTotalBorrowsVariable(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.totalBorrowsVariable;
    }

    /**
    * @dev gets the reserve liquidation threshold
    * @param _reserve the reserve address
    * @return the reserve liquidation threshold
    **/

    function getReserveLiquidationThreshold(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.liquidationThreshold;
    }

    /**
    * @dev gets the reserve liquidation bonus
    * @param _reserve the reserve address
    * @return the reserve liquidation bonus
    **/

    function getReserveLiquidationBonus(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.liquidationBonus;
    }

    /**
    * @dev gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty
    * @param _reserve the reserve address
    * @return the reserve current variable borrow rate
    **/

    function getReserveCurrentVariableBorrowRate(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        if (reserve.currentVariableBorrowRate == 0) {
            return
            IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)
            .getBaseVariableBorrowRate();
        }
        return reserve.currentVariableBorrowRate;
    }

    /**
    * @dev gets the reserve current stable borrow rate. Is the market rate if the reserve is empty
    * @param _reserve the reserve address
    * @return the reserve current stable borrow rate
    **/

    function getReserveCurrentStableBorrowRate(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        ILendingRateOracle oracle = ILendingRateOracle(addressesProvider.getLendingRateOracle());

        if (reserve.currentStableBorrowRate == 0) {
            //no stable rate borrows yet
            return oracle.getMarketBorrowRate(_reserve);
        }

        return reserve.currentStableBorrowRate;
    }

    /**
    * @dev gets the reserve average stable borrow rate. The average stable rate is the weighted average
    * of all the loans taken at stable rate.
    * @param _reserve the reserve address
    * @return the reserve current average borrow rate
    **/
    function getReserveCurrentAverageStableBorrowRate(address _reserve)
    external
    view
    returns (uint256)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.currentAverageStableBorrowRate;
    }

    /**
    * @dev gets the reserve liquidity rate
    * @param _reserve the reserve address
    * @return the reserve liquidity rate
    **/
    function getReserveCurrentLiquidityRate(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.currentLiquidityRate;
    }

    /**
    * @dev gets the reserve liquidity cumulative index
    * @param _reserve the reserve address
    * @return the reserve liquidity cumulative index
    **/
    function getReserveLiquidityCumulativeIndex(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.lastLiquidityCumulativeIndex;
    }

    /**
    * @dev gets the reserve variable borrow index
    * @param _reserve the reserve address
    * @return the reserve variable borrow index
    **/
    function getReserveVariableBorrowsCumulativeIndex(address _reserve)
    external
    view
    returns (uint256)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.lastVariableBorrowCumulativeIndex;
    }

    /**
    * @dev this function aggregates the configuration parameters of the reserve.
    * It's used in the LendingPoolDataProvider specifically to save gas, and avoid
    * multiple external contract calls to fetch the same data.
    * @param _reserve the reserve address
    * @return the reserve decimals
    * @return the base ltv as collateral
    * @return the liquidation threshold
    * @return if the reserve is used as collateral or not
    **/
    function getReserveConfiguration(address _reserve)
    external
    view
    returns (uint256, uint256, uint256, bool)
    {
        uint256 decimals;
        uint256 baseLTVasCollateral;
        uint256 liquidationThreshold;
        bool usageAsCollateralEnabled;

        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        decimals = reserve.decimals;
        baseLTVasCollateral = reserve.baseLTVasCollateral;
        liquidationThreshold = reserve.liquidationThreshold;
        usageAsCollateralEnabled = reserve.usageAsCollateralEnabled;

        return (decimals, baseLTVasCollateral, liquidationThreshold, usageAsCollateralEnabled);
    }

    /**
    * @dev returns the decimals of the reserve
    * @param _reserve the reserve address
    * @return the reserve decimals
    **/
    function getReserveDecimals(address _reserve) external view returns (uint256) {
        return reserves[_reserve].decimals;
    }

    /**
    * @dev returns true if the reserve is enabled for borrowing
    * @param _reserve the reserve address
    * @return true if the reserve is enabled for borrowing, false otherwise
    **/

    function isReserveBorrowingEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.borrowingEnabled;
    }

    /**
    * @dev returns true if the reserve is enabled as collateral
    * @param _reserve the reserve address
    * @return true if the reserve is enabled as collateral, false otherwise
    **/

    function isReserveUsageAsCollateralEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.usageAsCollateralEnabled;
    }

    /**
    * @dev returns true if the stable rate is enabled on reserve
    * @param _reserve the reserve address
    * @return true if the stable rate is enabled on reserve, false otherwise
    **/
    function getReserveIsStableBorrowRateEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isStableBorrowRateEnabled;
    }

    /**
    * @dev returns true if the reserve is active
    * @param _reserve the reserve address
    * @return true if the reserve is active, false otherwise
    **/
    function getReserveIsActive(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isActive;
    }

    /**
    * @notice returns if a reserve is freezed
    * @param _reserve the reserve for which the information is needed
    * @return true if the reserve is freezed, false otherwise
    **/

    function getReserveIsFreezed(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isFreezed;
    }

    /**
    * @notice returns the timestamp of the last action on the reserve
    * @param _reserve the reserve for which the information is needed
    * @return the last updated timestamp of the reserve
    **/

    function getReserveLastUpdate(address _reserve) external view returns (uint40 timestamp) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        timestamp = reserve.lastUpdateTimestamp;
    }

    /**
    * @dev returns the utilization rate U of a specific reserve
    * @param _reserve the reserve for which the information is needed
    * @return the utilization rate in ray
    **/

    function getReserveUtilizationRate(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        uint256 totalBorrows = reserve.getTotalBorrows();

        if (totalBorrows == 0) {
            return 0;
        }

        uint256 availableLiquidity = getReserveAvailableLiquidity(_reserve);

        return totalBorrows.rayDiv(availableLiquidity.add(totalBorrows));
    }

    /**
    * @return the array of reserves configured on the core
    **/
    function getReserves() external view returns (address[] memory) {
        return reservesList;
    }

    /**
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return true if the user has chosen to use the reserve as collateral, false otherwise
    **/
    function isUserUseReserveAsCollateralEnabled(address _reserve, address _user)
    external
    view
    returns (bool)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.useAsCollateral;
    }

    /**
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the origination fee for the user
    **/
    function getUserOriginationFee(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.originationFee;
    }

    /**
    * @dev users with no loans in progress have NONE as borrow rate mode
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the borrow rate mode for the user,
    **/

    function getUserCurrentBorrowRateMode(address _reserve, address _user)
    public
    view
    returns (CoreLibrary.InterestRateMode)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (user.principalBorrowBalance == 0) {
            return CoreLibrary.InterestRateMode.NONE;
        }

        return
        user.stableBorrowRate > 0
        ? CoreLibrary.InterestRateMode.STABLE
        : CoreLibrary.InterestRateMode.VARIABLE;
    }

    /**
    * @dev gets the current borrow rate of the user
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the borrow rate for the user,
    **/
    function getUserCurrentBorrowRate(address _reserve, address _user)
    internal
    view
    returns (uint256)
    {
        CoreLibrary.InterestRateMode rateMode = getUserCurrentBorrowRateMode(_reserve, _user);

        if (rateMode == CoreLibrary.InterestRateMode.NONE) {
            return 0;
        }

        return
        rateMode == CoreLibrary.InterestRateMode.STABLE
        ? usersReserveData[_user][_reserve].stableBorrowRate
        : reserves[_reserve].currentVariableBorrowRate;
    }

    /**
    * @dev the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the user stable rate
    **/
    function getUserCurrentStableBorrowRate(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.stableBorrowRate;
    }

    /**
    * @dev calculates and returns the borrow balances of the user
    * @param _reserve the address of the reserve
    * @param _user the address of the user
    * @return the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance
    **/

    function getUserBorrowBalances(address _reserve, address _user)
    public
    view
    returns (uint256, uint256, uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        if (user.principalBorrowBalance == 0) {
            return (0, 0, 0);
        }

        uint256 principal = user.principalBorrowBalance;
        uint256 compoundedBalance = CoreLibrary.getCompoundedBorrowBalance(
            user,
            reserves[_reserve]
        );
        return (principal, compoundedBalance, compoundedBalance.sub(principal));
    }

    /**
    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the variable borrow index for the user
    **/

    function getUserVariableBorrowCumulativeIndex(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.lastVariableBorrowCumulativeIndex;
    }

    /**
    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the variable borrow index for the user
    **/

    function getUserLastUpdate(address _reserve, address _user)
    external
    view
    returns (uint256 timestamp)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        timestamp = user.lastUpdateTimestamp;
    }

    /**
    * @dev updates the lending pool core configuration
    **/
    function refreshConfiguration() external onlyLendingPoolConfigurator {
        refreshConfigInternal();
    }

    /**
    * @dev initializes a reserve
    * @param _reserve the address of the reserve
    * @param _aTokenAddress the address of the overlying aToken contract
    * @param _decimals the decimals of the reserve currency
    * @param _interestRateStrategyAddress the address of the interest rate strategy contract
    **/
    function initReserve(
        address _reserve,
        address _aTokenAddress,
        uint256 _decimals,
        address _interestRateStrategyAddress
    ) external onlyLendingPoolConfigurator {
        reserves[_reserve].init(_aTokenAddress, _decimals, _interestRateStrategyAddress);
        addReserveToListInternal(_reserve);

    }



    /**
    * @dev removes the last added reserve in the reservesList array
    * @param _reserveToRemove the address of the reserve
    **/
    function removeLastAddedReserve(address _reserveToRemove)
    external onlyLendingPoolConfigurator {

        address lastReserve = reservesList[reservesList.length-1];

        require(lastReserve == _reserveToRemove, "Reserve being removed is different than the reserve requested");

        //as we can't check if totalLiquidity is 0 (since the reserve added might not be an ERC20) we at least check that there is nothing borrowed
        require(getReserveTotalBorrows(lastReserve) == 0, "Cannot remove a reserve with liquidity deposited");

        reserves[lastReserve].isActive = false;
        reserves[lastReserve].aTokenAddress = address(0);
        reserves[lastReserve].decimals = 0;
        reserves[lastReserve].lastLiquidityCumulativeIndex = 0;
        reserves[lastReserve].lastVariableBorrowCumulativeIndex = 0;
        reserves[lastReserve].borrowingEnabled = false;
        reserves[lastReserve].usageAsCollateralEnabled = false;
        reserves[lastReserve].baseLTVasCollateral = 0;
        reserves[lastReserve].liquidationThreshold = 0;
        reserves[lastReserve].liquidationBonus = 0;
        reserves[lastReserve].interestRateStrategyAddress = address(0);

        reservesList.pop();
    }

    /**
    * @dev updates the address of the interest rate strategy contract
    * @param _reserve the address of the reserve
    * @param _rateStrategyAddress the address of the interest rate strategy contract
    **/

    function setReserveInterestRateStrategyAddress(address _reserve, address _rateStrategyAddress)
    external
    onlyLendingPoolConfigurator
    {
        reserves[_reserve].interestRateStrategyAddress = _rateStrategyAddress;
    }

    /**
    * @dev enables borrowing on a reserve. Also sets the stable rate borrowing
    * @param _reserve the address of the reserve
    * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise
    **/

    function enableBorrowingOnReserve(address _reserve, bool _stableBorrowRateEnabled)
    external
    onlyLendingPoolConfigurator
    {
        reserves[_reserve].enableBorrowing(_stableBorrowRateEnabled);
    }

    /**
    * @dev disables borrowing on a reserve
    * @param _reserve the address of the reserve
    **/

    function disableBorrowingOnReserve(address _reserve) external onlyLendingPoolConfigurator {
        reserves[_reserve].disableBorrowing();
    }

    /**
    * @dev enables a reserve to be used as collateral
    * @param _reserve the address of the reserve
    **/
    function enableReserveAsCollateral(
        address _reserve,
        uint256 _baseLTVasCollateral,
        uint256 _liquidationThreshold,
        uint256 _liquidationBonus
    ) external onlyLendingPoolConfigurator {
        reserves[_reserve].enableAsCollateral(
            _baseLTVasCollateral,
            _liquidationThreshold,
            _liquidationBonus
        );
    }

    /**
    * @dev disables a reserve to be used as collateral
    * @param _reserve the address of the reserve
    **/
    function disableReserveAsCollateral(address _reserve) external onlyLendingPoolConfigurator {
        reserves[_reserve].disableAsCollateral();
    }

    /**
    * @dev enable the stable borrow rate mode on a reserve
    * @param _reserve the address of the reserve
    **/
    function enableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isStableBorrowRateEnabled = true;
    }

    /**
    * @dev disable the stable borrow rate mode on a reserve
    * @param _reserve the address of the reserve
    **/
    function disableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isStableBorrowRateEnabled = false;
    }

    /**
    * @dev activates a reserve
    * @param _reserve the address of the reserve
    **/
    function activateReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        require(
            reserve.lastLiquidityCumulativeIndex > 0 &&
            reserve.lastVariableBorrowCumulativeIndex > 0,
            "Reserve has not been initialized yet"
        );
        reserve.isActive = true;
    }

    /**
    * @dev deactivates a reserve
    * @param _reserve the address of the reserve
    **/
    function deactivateReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isActive = false;
    }

    /**
    * @notice allows the configurator to freeze the reserve.
    * A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance.
    * @param _reserve the address of the reserve
    **/
    function freezeReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isFreezed = true;
    }

    /**
    * @notice allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed.
    * @param _reserve the address of the reserve
    **/
    function unfreezeReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isFreezed = false;
    }

    /**
    * @notice allows the configurator to update the loan to value of a reserve
    * @param _reserve the address of the reserve
    * @param _ltv the new loan to value
    **/
    function setReserveBaseLTVasCollateral(address _reserve, uint256 _ltv)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.baseLTVasCollateral = _ltv;
    }

    /**
    * @notice allows the configurator to update the liquidation threshold of a reserve
    * @param _reserve the address of the reserve
    * @param _threshold the new liquidation threshold
    **/
    function setReserveLiquidationThreshold(address _reserve, uint256 _threshold)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.liquidationThreshold = _threshold;
    }

    /**
    * @notice allows the configurator to update the liquidation bonus of a reserve
    * @param _reserve the address of the reserve
    * @param _bonus the new liquidation bonus
    **/
    function setReserveLiquidationBonus(address _reserve, uint256 _bonus)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.liquidationBonus = _bonus;
    }

    /**
    * @notice allows the configurator to update the reserve decimals
    * @param _reserve the address of the reserve
    * @param _decimals the decimals of the reserve
    **/
    function setReserveDecimals(address _reserve, uint256 _decimals)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.decimals = _decimals;
    }

    /**
    * @notice internal functions
    **/

    /**
    * @dev updates the state of a reserve as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the previous borrow balance of the borrower before the action
    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount
    * @param _amountBorrowed the new amount borrowed
    * @param _rateMode the borrow rate mode (stable, variable)
    **/

    function updateReserveStateOnBorrowInternal(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _balanceIncrease,
        uint256 _amountBorrowed,
        CoreLibrary.InterestRateMode _rateMode
    ) internal {
        reserves[_reserve].updateCumulativeIndexes();

        //increasing reserve total borrows to account for the new borrow balance of the user
        //NOTE: Depending on the previous borrow mode, the borrows might need to be switched from variable to stable or vice versa

        updateReserveTotalBorrowsByRateModeInternal(
            _reserve,
            _user,
            _principalBorrowBalance,
            _balanceIncrease,
            _amountBorrowed,
            _rateMode
        );
    }

    /**
    * @dev updates the state of a user as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _amountBorrowed the amount borrowed
    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount
    * @param _rateMode the borrow rate mode (stable, variable)
    * @return the final borrow rate for the user. Emitted by the borrow() event
    **/

    function updateUserStateOnBorrowInternal(
        address _reserve,
        address _user,
        uint256 _amountBorrowed,
        uint256 _balanceIncrease,
        uint256 _fee,
        CoreLibrary.InterestRateMode _rateMode
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (_rateMode == CoreLibrary.InterestRateMode.STABLE) {
            //stable
            //reset the user variable index, and update the stable rate
            user.stableBorrowRate = reserve.currentStableBorrowRate;
            user.lastVariableBorrowCumulativeIndex = 0;
        } else if (_rateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //variable
            //reset the user stable rate, and store the new borrow index
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        } else {
            revert("Invalid borrow rate mode");
        }
        //increase the principal borrows and the origination fee
        user.principalBorrowBalance = user.principalBorrowBalance.add(_amountBorrowed).add(
            _balanceIncrease
        );
        user.originationFee = user.originationFee.add(_fee);

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

    }

    /**
    * @dev updates the state of the reserve as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateReserveStateOnRepayInternal(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_reserve][_user];

        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(_reserve, _user);

        //update the indexes
        reserves[_reserve].updateCumulativeIndexes();

        //compound the cumulated interest to the borrow balance and then subtracting the payback amount
        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _balanceIncrease,
                user.stableBorrowRate
            );
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _paybackAmountMinusFees,
                user.stableBorrowRate
            );
        } else {
            reserve.increaseTotalBorrowsVariable(_balanceIncrease);
            reserve.decreaseTotalBorrowsVariable(_paybackAmountMinusFees);
        }
    }

    /**
    * @dev updates the state of the user as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _originationFeeRepaid the fee on the amount that is being repaid
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _repaidWholeLoan true if the user is repaying the whole loan
    **/
    function updateUserStateOnRepayInternal(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _originationFeeRepaid,
        uint256 _balanceIncrease,
        bool _repaidWholeLoan
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        //update the user principal borrow balance, adding the cumulated interest and then subtracting the payback amount
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(
            _paybackAmountMinusFees
        );
        user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;

        //if the balance decrease is equal to the previous principal (user is repaying the whole loan)
        //and the rate mode is stable, we reset the interest rate mode of the user
        if (_repaidWholeLoan) {
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = 0;
        }
        user.originationFee = user.originationFee.sub(_originationFeeRepaid);

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

    }

    /**
    * @dev updates the state of the user as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is performing the rate swap
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the the principal amount borrowed by the user
    * @param _compoundedBorrowBalance the principal amount plus the accrued interest
    * @param _currentRateMode the rate mode at which the user borrowed
    **/
    function updateReserveStateOnSwapRateInternal(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _compoundedBorrowBalance,
        CoreLibrary.InterestRateMode _currentRateMode
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        //compounding reserve indexes
        reserve.updateCumulativeIndexes();

        if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {
            uint256 userCurrentStableRate = user.stableBorrowRate;

            //swap to variable
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _principalBorrowBalance,
                userCurrentStableRate
            ); //decreasing stable from old principal balance
            reserve.increaseTotalBorrowsVariable(_compoundedBorrowBalance); //increase variable borrows
        } else if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //swap to stable
            uint256 currentStableRate = reserve.currentStableBorrowRate;
            reserve.decreaseTotalBorrowsVariable(_principalBorrowBalance);
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _compoundedBorrowBalance,
                currentStableRate
            );

        } else {
            revert("Invalid rate mode received");
        }
    }

    /**
    * @dev updates the state of the user as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is performing the swap
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _currentRateMode the current rate mode of the user
    **/

    function updateUserStateOnSwapRateInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease,
        CoreLibrary.InterestRateMode _currentRateMode
    ) internal returns (CoreLibrary.InterestRateMode) {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        CoreLibrary.InterestRateMode newMode = CoreLibrary.InterestRateMode.NONE;

        if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //switch to stable
            newMode = CoreLibrary.InterestRateMode.STABLE;
            user.stableBorrowRate = reserve.currentStableBorrowRate;
            user.lastVariableBorrowCumulativeIndex = 0;
        } else if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {
            newMode = CoreLibrary.InterestRateMode.VARIABLE;
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        } else {
            revert("Invalid interest rate mode received");
        }
        //compounding cumulated interest
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);
        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

        return newMode;
    }

    /**
    * @dev updates the state of the principal reserve as a consequence of a liquidation action.
    * @param _principalReserve the address of the principal reserve that is being repaid
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updatePrincipalReserveStateOnLiquidationInternal(
        address _principalReserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_principalReserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_principalReserve];

        //update principal reserve data
        reserve.updateCumulativeIndexes();

        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(
            _principalReserve,
            _user
        );

        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            //increase the total borrows by the compounded interest
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _balanceIncrease,
                user.stableBorrowRate
            );

            //decrease by the actual amount to liquidate
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _amountToLiquidate,
                user.stableBorrowRate
            );

        } else {
            //increase the total borrows by the compounded interest
            reserve.increaseTotalBorrowsVariable(_balanceIncrease);

            //decrease by the actual amount to liquidate
            reserve.decreaseTotalBorrowsVariable(_amountToLiquidate);
        }

    }

    /**
    * @dev updates the state of the collateral reserve as a consequence of a liquidation action.
    * @param _collateralReserve the address of the collateral reserve that is being liquidated
    **/
    function updateCollateralReserveStateOnLiquidationInternal(
        address _collateralReserve
    ) internal {
        //update collateral reserve
        reserves[_collateralReserve].updateCumulativeIndexes();

    }

    /**
    * @dev updates the state of the user being liquidated as a consequence of a liquidation action.
    * @param _reserve the address of the principal reserve that is being repaid
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _feeLiquidated the amount of origination fee being liquidated
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/
    function updateUserStateOnLiquidationInternal(
        address _reserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _feeLiquidated,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        //first increase by the compounded interest, then decrease by the liquidated amount
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(
            _amountToLiquidate
        );

        if (
            getUserCurrentBorrowRateMode(_reserve, _user) == CoreLibrary.InterestRateMode.VARIABLE
        ) {
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        }

        if(_feeLiquidated > 0){
            user.originationFee = user.originationFee.sub(_feeLiquidated);
        }

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);
    }

    /**
    * @dev updates the state of the reserve as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateReserveStateOnRebalanceInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        reserve.updateCumulativeIndexes();

        reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
            _balanceIncrease,
            user.stableBorrowRate
        );

    }

    /**
    * @dev updates the state of the user as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateUserStateOnRebalanceInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);
        user.stableBorrowRate = reserve.currentStableBorrowRate;

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);
    }

    /**
    * @dev updates the state of the user as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _amountBorrowed the accrued interest on the borrowed amount
    **/
    function updateReserveTotalBorrowsByRateModeInternal(
        address _reserve,
        address _user,
        uint256 _principalBalance,
        uint256 _balanceIncrease,
        uint256 _amountBorrowed,
        CoreLibrary.InterestRateMode _newBorrowRateMode
    ) internal {
        CoreLibrary.InterestRateMode previousRateMode = getUserCurrentBorrowRateMode(
            _reserve,
            _user
        );
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        if (previousRateMode == CoreLibrary.InterestRateMode.STABLE) {
            CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _principalBalance,
                user.stableBorrowRate
            );
        } else if (previousRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            reserve.decreaseTotalBorrowsVariable(_principalBalance);
        }

        uint256 newPrincipalAmount = _principalBalance.add(_balanceIncrease).add(_amountBorrowed);
        if (_newBorrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                newPrincipalAmount,
                reserve.currentStableBorrowRate
            );
        } else if (_newBorrowRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            reserve.increaseTotalBorrowsVariable(newPrincipalAmount);
        } else {
            revert("Invalid new borrow rate mode");
        }
    }

    /**
    * @dev Updates the reserve current stable borrow rate Rf, the current variable borrow rate Rv and the current liquidity rate Rl.
    * Also updates the lastUpdateTimestamp value. Please refer to the whitepaper for further information.
    * @param _reserve the address of the reserve to be updated
    * @param _liquidityAdded the amount of liquidity added to the protocol (deposit or repay) in the previous action
    * @param _liquidityTaken the amount of liquidity taken from the protocol (redeem or borrow)
    **/

    function updateReserveInterestRatesAndTimestampInternal(
        address _reserve,
        uint256 _liquidityAdded,
        uint256 _liquidityTaken
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        (uint256 newLiquidityRate, uint256 newStableRate, uint256 newVariableRate) = IReserveInterestRateStrategy(
            reserve
            .interestRateStrategyAddress
        )
        .calculateInterestRates(
            _reserve,
            getReserveAvailableLiquidity(_reserve).add(_liquidityAdded).sub(_liquidityTaken),
            reserve.totalBorrowsStable,
            reserve.totalBorrowsVariable,
            reserve.currentAverageStableBorrowRate
        );

        reserve.currentLiquidityRate = newLiquidityRate;
        reserve.currentStableBorrowRate = newStableRate;
        reserve.currentVariableBorrowRate = newVariableRate;

        //solium-disable-next-line
        reserve.lastUpdateTimestamp = uint40(block.timestamp);

        emit ReserveUpdated(
            _reserve,
            newLiquidityRate,
            newStableRate,
            newVariableRate,
            reserve.lastLiquidityCumulativeIndex,
            reserve.lastVariableBorrowCumulativeIndex
        );
    }

    /**
    * @dev transfers to the protocol fees of a flashloan to the fees collection address
    * @param _token the address of the token being transferred
    * @param _amount the amount being transferred
    **/

    function transferFlashLoanProtocolFeeInternal(address _token, uint256 _amount) internal {
        address payable receiver = address(uint160(addressesProvider.getTokenDistributor()));

        if (_token != EthAddressLib.ethAddress()) {
            ERC20(_token).safeTransfer(receiver, _amount);
        } else {
            receiver.transfer(_amount);
        }
    }

    /**
    * @dev updates the internal configuration of the core
    **/
    function refreshConfigInternal() internal {
        lendingPoolAddress = addressesProvider.getLendingPool();
    }

    /**
    * @dev adds a reserve to the array of the reserves address
    **/
    function addReserveToListInternal(address _reserve) internal {
        bool reserveAlreadyAdded = false;
        for (uint256 i = 0; i < reservesList.length; i++)
            if (reservesList[i] == _reserve) {
                reserveAlreadyAdded = true;
            }
        if (!reserveAlreadyAdded) reservesList.push(_reserve);
    }

}
.]

Given the user's task and the brainstorming ideas provided:
Task: "pragma solidity ^0.5.0;

import "openzeppelin-solidity/contracts/math/SafeMath.sol";
import "openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol";
import "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol";
import "openzeppelin-solidity/contracts/utils/Address.sol";
import "../libraries/openzeppelin-upgradeability/VersionedInitializable.sol";

import "../libraries/CoreLibrary.sol";
import "../configuration/LendingPoolAddressesProvider.sol";
import "../interfaces/ILendingRateOracle.sol";
import "../interfaces/IReserveInterestRateStrategy.sol";
import "../libraries/WadRayMath.sol";
import "../tokenization/AToken.sol";
import "../libraries/EthAddressLib.sol";

/**
* @title LendingPoolCore contract
* @author Aave
* @notice Holds the state of the lending pool and all the funds deposited
* @dev NOTE: The core does not enforce security checks on the update of the state
* (eg, updateStateOnBorrow() does not enforce that borrowed is enabled on the reserve).
* The check that an action can be performed is a duty of the overlying LendingPool contract.
**/

contract LendingPoolCore is VersionedInitializable {
    using SafeMath for uint256;
    using WadRayMath for uint256;
    using CoreLibrary for CoreLibrary.ReserveData;
    using CoreLibrary for CoreLibrary.UserReserveData;
    using SafeERC20 for ERC20;
    using Address for address payable;

    /**
    * @dev Emitted when the state of a reserve is updated
    * @param reserve the address of the reserve
    * @param liquidityRate the new liquidity rate
    * @param stableBorrowRate the new stable borrow rate
    * @param variableBorrowRate the new variable borrow rate
    * @param liquidityIndex the new liquidity index
    * @param variableBorrowIndex the new variable borrow index
    **/
    event ReserveUpdated(
        address indexed reserve,
        uint256 liquidityRate,
        uint256 stableBorrowRate,
        uint256 variableBorrowRate,
        uint256 liquidityIndex,
        uint256 variableBorrowIndex
    );

    address public lendingPoolAddress;

    LendingPoolAddressesProvider public addressesProvider;

    /**
    * @dev only lending pools can use functions affected by this modifier
    **/
    modifier onlyLendingPool {
        require(lendingPoolAddress == msg.sender, "The caller must be a lending pool contract");
        _;
    }

    /**
    * @dev only lending pools configurator can use functions affected by this modifier
    **/
    modifier onlyLendingPoolConfigurator {
        require(
            addressesProvider.getLendingPoolConfigurator() == msg.sender,
            "The caller must be a lending pool configurator contract"
        );
        _;
    }

    mapping(address => CoreLibrary.ReserveData) internal reserves;
    mapping(address => mapping(address => CoreLibrary.UserReserveData)) internal usersReserveData;

    address[] public reservesList;

    uint256 public constant CORE_REVISION = 0x4;

    /**
    * @dev returns the revision number of the contract
    **/
    function getRevision() internal pure returns (uint256) {
        return CORE_REVISION;
    }

    /**
    * @dev initializes the Core contract, invoked upon registration on the AddressesProvider
    * @param _addressesProvider the addressesProvider contract
    **/

    function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {
        addressesProvider = _addressesProvider;
        refreshConfigInternal();
    }

    /**
    * @dev updates the state of the core as a result of a deposit action
    * @param _reserve the address of the reserve in which the deposit is happening
    * @param _user the address of the the user depositing
    * @param _amount the amount being deposited
    * @param _isFirstDeposit true if the user is depositing for the first time
    **/

    function updateStateOnDeposit(
        address _reserve,
        address _user,
        uint256 _amount,
        bool _isFirstDeposit
    ) external onlyLendingPool {
        reserves[_reserve].updateCumulativeIndexes();
        updateReserveInterestRatesAndTimestampInternal(_reserve, _amount, 0);

        if (_isFirstDeposit) {
            //if this is the first deposit of the user, we configure the deposit as enabled to be used as collateral
            setUserUseReserveAsCollateral(_reserve, _user, true);
        }
    }

    /**
    * @dev updates the state of the core as a result of a redeem action
    * @param _reserve the address of the reserve in which the redeem is happening
    * @param _user the address of the the user redeeming
    * @param _amountRedeemed the amount being redeemed
    * @param _userRedeemedEverything true if the user is redeeming everything
    **/
    function updateStateOnRedeem(
        address _reserve,
        address _user,
        uint256 _amountRedeemed,
        bool _userRedeemedEverything
    ) external onlyLendingPool {
        //compound liquidity and variable borrow interests
        reserves[_reserve].updateCumulativeIndexes();
        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountRedeemed);

        //if user redeemed everything the useReserveAsCollateral flag is reset
        if (_userRedeemedEverything) {
            setUserUseReserveAsCollateral(_reserve, _user, false);
        }
    }

    /**
    * @dev updates the state of the core as a result of a flashloan action
    * @param _reserve the address of the reserve in which the flashloan is happening
    * @param _income the income of the protocol as a result of the action
    **/
    function updateStateOnFlashLoan(
        address _reserve,
        uint256 _availableLiquidityBefore,
        uint256 _income,
        uint256 _protocolFee
    ) external onlyLendingPool {
        transferFlashLoanProtocolFeeInternal(_reserve, _protocolFee);

        //compounding the cumulated interest
        reserves[_reserve].updateCumulativeIndexes();

        uint256 totalLiquidityBefore = _availableLiquidityBefore.add(
            getReserveTotalBorrows(_reserve)
        );

        //compounding the received fee into the reserve
        reserves[_reserve].cumulateToLiquidityIndex(totalLiquidityBefore, _income);

        //refresh interest rates
        updateReserveInterestRatesAndTimestampInternal(_reserve, _income, 0);
    }

    /**
    * @dev updates the state of the core as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _amountBorrowed the new amount borrowed
    * @param _borrowFee the fee on the amount borrowed
    * @param _rateMode the borrow rate mode (stable, variable)
    * @return the new borrow rate for the user
    **/
    function updateStateOnBorrow(
        address _reserve,
        address _user,
        uint256 _amountBorrowed,
        uint256 _borrowFee,
        CoreLibrary.InterestRateMode _rateMode
    ) external onlyLendingPool returns (uint256, uint256) {
        // getting the previous borrow data of the user
        (uint256 principalBorrowBalance, , uint256 balanceIncrease) = getUserBorrowBalances(
            _reserve,
            _user
        );

        updateReserveStateOnBorrowInternal(
            _reserve,
            _user,
            principalBorrowBalance,
            balanceIncrease,
            _amountBorrowed,
            _rateMode
        );

        updateUserStateOnBorrowInternal(
            _reserve,
            _user,
            _amountBorrowed,
            balanceIncrease,
            _borrowFee,
            _rateMode
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountBorrowed);

        return (getUserCurrentBorrowRate(_reserve, _user), balanceIncrease);
    }

    /**
    * @dev updates the state of the core as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _originationFeeRepaid the fee on the amount that is being repaid
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _repaidWholeLoan true if the user is repaying the whole loan
    **/

    function updateStateOnRepay(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _originationFeeRepaid,
        uint256 _balanceIncrease,
        bool _repaidWholeLoan
    ) external onlyLendingPool {
        updateReserveStateOnRepayInternal(
            _reserve,
            _user,
            _paybackAmountMinusFees,
            _balanceIncrease
        );
        updateUserStateOnRepayInternal(
            _reserve,
            _user,
            _paybackAmountMinusFees,
            _originationFeeRepaid,
            _balanceIncrease,
            _repaidWholeLoan
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, _paybackAmountMinusFees, 0);
    }

    /**
    * @dev updates the state of the core as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the amount borrowed by the user
    * @param _compoundedBorrowBalance the amount borrowed plus accrued interest
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _currentRateMode the current interest rate mode for the user
    **/
    function updateStateOnSwapRate(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _compoundedBorrowBalance,
        uint256 _balanceIncrease,
        CoreLibrary.InterestRateMode _currentRateMode
    ) external onlyLendingPool returns (CoreLibrary.InterestRateMode, uint256) {
        updateReserveStateOnSwapRateInternal(
            _reserve,
            _user,
            _principalBorrowBalance,
            _compoundedBorrowBalance,
            _currentRateMode
        );

        CoreLibrary.InterestRateMode newRateMode = updateUserStateOnSwapRateInternal(
            _reserve,
            _user,
            _balanceIncrease,
            _currentRateMode
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);

        return (newRateMode, getUserCurrentBorrowRate(_reserve, _user));
    }

    /**
    * @dev updates the state of the core as a consequence of a liquidation action.
    * @param _principalReserve the address of the principal reserve that is being repaid
    * @param _collateralReserve the address of the collateral reserve that is being liquidated
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _collateralToLiquidate the amount of collateral being liquidated
    * @param _feeLiquidated the amount of origination fee being liquidated
    * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise
    **/
    function updateStateOnLiquidation(
        address _principalReserve,
        address _collateralReserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _collateralToLiquidate,
        uint256 _feeLiquidated,
        uint256 _liquidatedCollateralForFee,
        uint256 _balanceIncrease,
        bool _liquidatorReceivesAToken
    ) external onlyLendingPool {
        updatePrincipalReserveStateOnLiquidationInternal(
            _principalReserve,
            _user,
            _amountToLiquidate,
            _balanceIncrease
        );

        updateCollateralReserveStateOnLiquidationInternal(
            _collateralReserve
        );

        updateUserStateOnLiquidationInternal(
            _principalReserve,
            _user,
            _amountToLiquidate,
            _feeLiquidated,
            _balanceIncrease
        );

        updateReserveInterestRatesAndTimestampInternal(_principalReserve, _amountToLiquidate, 0);

        if (!_liquidatorReceivesAToken) {
            updateReserveInterestRatesAndTimestampInternal(
                _collateralReserve,
                0,
                _collateralToLiquidate.add(_liquidatedCollateralForFee)
            );
        }

    }

    /**
    * @dev updates the state of the core as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @return the new stable rate for the user
    **/
    function updateStateOnRebalance(address _reserve, address _user, uint256 _balanceIncrease)
    external
    onlyLendingPool
    returns (uint256)
    {
        updateReserveStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);

        //update user data and rebalance the rate
        updateUserStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);
        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);
        return usersReserveData[_user][_reserve].stableBorrowRate;
    }

    /**
    * @dev enables or disables a reserve as collateral
    * @param _reserve the address of the principal reserve where the user deposited
    * @param _user the address of the depositor
    * @param _useAsCollateral true if the depositor wants to use the reserve as collateral
    **/
    function setUserUseReserveAsCollateral(address _reserve, address _user, bool _useAsCollateral)
    public
    onlyLendingPool
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        user.useAsCollateral = _useAsCollateral;
    }

    /**
    * @notice ETH/token transfer functions
    **/

    /**
    * @dev fallback function enforces that the caller is a contract, to support flashloan transfers
    **/
    function() external payable {
        //only contracts can send ETH to the core
        require(msg.sender.isContract(), "Only contracts can send ether to the Lending pool core");

    }

    /**
    * @dev transfers to the user a specific amount from the reserve.
    * @param _reserve the address of the reserve where the transfer is happening
    * @param _user the address of the user receiving the transfer
    * @param _amount the amount being transferred
    **/
    function transferToUser(address _reserve, address payable _user, uint256 _amount)
    external
    onlyLendingPool
    {
        if (_reserve != EthAddressLib.ethAddress()) {
            ERC20(_reserve).safeTransfer(_user, _amount);
        } else {
            //solium-disable-next-line
            (bool result, ) = _user.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers the protocol fees to the fees collection address
    * @param _token the address of the token being transferred
    * @param _user the address of the user from where the transfer is happening
    * @param _amount the amount being transferred
    * @param _destination the fee receiver address
    **/

    function transferToFeeCollectionAddress(
        address _token,
        address _user,
        uint256 _amount,
        address _destination
    ) external payable onlyLendingPool {
        address payable feeAddress = address(uint160(_destination)); //cast the address to payable

        if (_token != EthAddressLib.ethAddress()) {
            require(
                msg.value == 0,
                "User is sending ETH along with the ERC20 transfer. Check the value attribute of the transaction"
            );
            ERC20(_token).safeTransferFrom(_user, feeAddress, _amount);
        } else {
            require(msg.value >= _amount, "The amount and the value sent to deposit do not match");
            //solium-disable-next-line
            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers the fees to the fees collection address in the case of liquidation
    * @param _token the address of the token being transferred
    * @param _amount the amount being transferred
    * @param _destination the fee receiver address
    **/
    function liquidateFee(
        address _token,
        uint256 _amount,
        address _destination
    ) external payable onlyLendingPool {
        address payable feeAddress = address(uint160(_destination)); //cast the address to payable
        require(
            msg.value == 0,
            "Fee liquidation does not require any transfer of value"
        );

        if (_token != EthAddressLib.ethAddress()) {
            ERC20(_token).safeTransfer(feeAddress, _amount);
        } else {
            //solium-disable-next-line
            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers an amount from a user to the destination reserve
    * @param _reserve the address of the reserve where the amount is being transferred
    * @param _user the address of the user from where the transfer is happening
    * @param _amount the amount being transferred
    **/
    function transferToReserve(address _reserve, address payable _user, uint256 _amount)
    external
    payable
    onlyLendingPool
    {
        if (_reserve != EthAddressLib.ethAddress()) {
            require(msg.value == 0, "User is sending ETH along with the ERC20 transfer.");
            ERC20(_reserve).safeTransferFrom(_user, address(this), _amount);

        } else {
            require(msg.value >= _amount, "The amount and the value sent to deposit do not match");

            if (msg.value > _amount) {
                //send back excess ETH
                uint256 excessAmount = msg.value.sub(_amount);
                //solium-disable-next-line
                (bool result, ) = _user.call.value(excessAmount).gas(50000)("");
                require(result, "Transfer of ETH failed");
            }
        }
    }

    /**
    * @notice data access functions
    **/

    /**
    * @dev returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral)
    * needed to calculate the global account data in the LendingPoolDataProvider
    * @param _reserve the address of the reserve
    * @param _user the address of the user
    * @return the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not
    **/
    function getUserBasicReserveData(address _reserve, address _user)
    external
    view
    returns (uint256, uint256, uint256, bool)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        uint256 underlyingBalance = getUserUnderlyingAssetBalance(_reserve, _user);

        if (user.principalBorrowBalance == 0) {
            return (underlyingBalance, 0, 0, user.useAsCollateral);
        }

        return (
        underlyingBalance,
        user.getCompoundedBorrowBalance(reserve),
        user.originationFee,
        user.useAsCollateral
        );
    }

    /**
    * @dev checks if a user is allowed to borrow at a stable rate
    * @param _reserve the reserve address
    * @param _user the user
    * @param _amount the amount the the user wants to borrow
    * @return true if the user is allowed to borrow at a stable rate, false otherwise
    **/

    function isUserAllowedToBorrowAtStable(address _reserve, address _user, uint256 _amount)
    external
    view
    returns (bool)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (!reserve.isStableBorrowRateEnabled) return false;

        return
        !user.useAsCollateral ||
        !reserve.usageAsCollateralEnabled ||
        _amount > getUserUnderlyingAssetBalance(_reserve, _user);
    }

    /**
    * @dev gets the underlying asset balance of a user based on the corresponding aToken balance.
    * @param _reserve the reserve address
    * @param _user the user address
    * @return the underlying deposit balance of the user
    **/

    function getUserUnderlyingAssetBalance(address _reserve, address _user)
    public
    view
    returns (uint256)
    {
        AToken aToken = AToken(reserves[_reserve].aTokenAddress);
        return aToken.balanceOf(_user);

    }

    /**
    * @dev gets the interest rate strategy contract address for the reserve
    * @param _reserve the reserve address
    * @return the address of the interest rate strategy contract
    **/
    function getReserveInterestRateStrategyAddress(address _reserve) public view returns (address) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.interestRateStrategyAddress;
    }

    /**
    * @dev gets the aToken contract address for the reserve
    * @param _reserve the reserve address
    * @return the address of the aToken contract
    **/

    function getReserveATokenAddress(address _reserve) public view returns (address) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.aTokenAddress;
    }

    /**
    * @dev gets the available liquidity in the reserve. The available liquidity is the balance of the core contract
    * @param _reserve the reserve address
    * @return the available liquidity
    **/
    function getReserveAvailableLiquidity(address _reserve) public view returns (uint256) {
        uint256 balance = 0;

        if (_reserve == EthAddressLib.ethAddress()) {
            balance = address(this).balance;
        } else {
            balance = IERC20(_reserve).balanceOf(address(this));
        }
        return balance;
    }

    /**
    * @dev gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows
    * @param _reserve the reserve address
    * @return the total liquidity
    **/
    function getReserveTotalLiquidity(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return getReserveAvailableLiquidity(_reserve).add(reserve.getTotalBorrows());
    }

    /**
    * @dev gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there
    * there has been 100% income.
    * @param _reserve the reserve address
    * @return the reserve normalized income
    **/
    function getReserveNormalizedIncome(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.getNormalizedIncome();
    }

    /**
    * @dev gets the reserve total borrows
    * @param _reserve the reserve address
    * @return the total borrows (stable + variable)
    **/
    function getReserveTotalBorrows(address _reserve) public view returns (uint256) {
        return reserves[_reserve].getTotalBorrows();
    }

    /**
    * @dev gets the reserve total borrows stable
    * @param _reserve the reserve address
    * @return the total borrows stable
    **/
    function getReserveTotalBorrowsStable(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.totalBorrowsStable;
    }

    /**
    * @dev gets the reserve total borrows variable
    * @param _reserve the reserve address
    * @return the total borrows variable
    **/

    function getReserveTotalBorrowsVariable(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.totalBorrowsVariable;
    }

    /**
    * @dev gets the reserve liquidation threshold
    * @param _reserve the reserve address
    * @return the reserve liquidation threshold
    **/

    function getReserveLiquidationThreshold(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.liquidationThreshold;
    }

    /**
    * @dev gets the reserve liquidation bonus
    * @param _reserve the reserve address
    * @return the reserve liquidation bonus
    **/

    function getReserveLiquidationBonus(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.liquidationBonus;
    }

    /**
    * @dev gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty
    * @param _reserve the reserve address
    * @return the reserve current variable borrow rate
    **/

    function getReserveCurrentVariableBorrowRate(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        if (reserve.currentVariableBorrowRate == 0) {
            return
            IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)
            .getBaseVariableBorrowRate();
        }
        return reserve.currentVariableBorrowRate;
    }

    /**
    * @dev gets the reserve current stable borrow rate. Is the market rate if the reserve is empty
    * @param _reserve the reserve address
    * @return the reserve current stable borrow rate
    **/

    function getReserveCurrentStableBorrowRate(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        ILendingRateOracle oracle = ILendingRateOracle(addressesProvider.getLendingRateOracle());

        if (reserve.currentStableBorrowRate == 0) {
            //no stable rate borrows yet
            return oracle.getMarketBorrowRate(_reserve);
        }

        return reserve.currentStableBorrowRate;
    }

    /**
    * @dev gets the reserve average stable borrow rate. The average stable rate is the weighted average
    * of all the loans taken at stable rate.
    * @param _reserve the reserve address
    * @return the reserve current average borrow rate
    **/
    function getReserveCurrentAverageStableBorrowRate(address _reserve)
    external
    view
    returns (uint256)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.currentAverageStableBorrowRate;
    }

    /**
    * @dev gets the reserve liquidity rate
    * @param _reserve the reserve address
    * @return the reserve liquidity rate
    **/
    function getReserveCurrentLiquidityRate(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.currentLiquidityRate;
    }

    /**
    * @dev gets the reserve liquidity cumulative index
    * @param _reserve the reserve address
    * @return the reserve liquidity cumulative index
    **/
    function getReserveLiquidityCumulativeIndex(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.lastLiquidityCumulativeIndex;
    }

    /**
    * @dev gets the reserve variable borrow index
    * @param _reserve the reserve address
    * @return the reserve variable borrow index
    **/
    function getReserveVariableBorrowsCumulativeIndex(address _reserve)
    external
    view
    returns (uint256)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.lastVariableBorrowCumulativeIndex;
    }

    /**
    * @dev this function aggregates the configuration parameters of the reserve.
    * It's used in the LendingPoolDataProvider specifically to save gas, and avoid
    * multiple external contract calls to fetch the same data.
    * @param _reserve the reserve address
    * @return the reserve decimals
    * @return the base ltv as collateral
    * @return the liquidation threshold
    * @return if the reserve is used as collateral or not
    **/
    function getReserveConfiguration(address _reserve)
    external
    view
    returns (uint256, uint256, uint256, bool)
    {
        uint256 decimals;
        uint256 baseLTVasCollateral;
        uint256 liquidationThreshold;
        bool usageAsCollateralEnabled;

        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        decimals = reserve.decimals;
        baseLTVasCollateral = reserve.baseLTVasCollateral;
        liquidationThreshold = reserve.liquidationThreshold;
        usageAsCollateralEnabled = reserve.usageAsCollateralEnabled;

        return (decimals, baseLTVasCollateral, liquidationThreshold, usageAsCollateralEnabled);
    }

    /**
    * @dev returns the decimals of the reserve
    * @param _reserve the reserve address
    * @return the reserve decimals
    **/
    function getReserveDecimals(address _reserve) external view returns (uint256) {
        return reserves[_reserve].decimals;
    }

    /**
    * @dev returns true if the reserve is enabled for borrowing
    * @param _reserve the reserve address
    * @return true if the reserve is enabled for borrowing, false otherwise
    **/

    function isReserveBorrowingEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.borrowingEnabled;
    }

    /**
    * @dev returns true if the reserve is enabled as collateral
    * @param _reserve the reserve address
    * @return true if the reserve is enabled as collateral, false otherwise
    **/

    function isReserveUsageAsCollateralEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.usageAsCollateralEnabled;
    }

    /**
    * @dev returns true if the stable rate is enabled on reserve
    * @param _reserve the reserve address
    * @return true if the stable rate is enabled on reserve, false otherwise
    **/
    function getReserveIsStableBorrowRateEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isStableBorrowRateEnabled;
    }

    /**
    * @dev returns true if the reserve is active
    * @param _reserve the reserve address
    * @return true if the reserve is active, false otherwise
    **/
    function getReserveIsActive(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isActive;
    }

    /**
    * @notice returns if a reserve is freezed
    * @param _reserve the reserve for which the information is needed
    * @return true if the reserve is freezed, false otherwise
    **/

    function getReserveIsFreezed(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isFreezed;
    }

    /**
    * @notice returns the timestamp of the last action on the reserve
    * @param _reserve the reserve for which the information is needed
    * @return the last updated timestamp of the reserve
    **/

    function getReserveLastUpdate(address _reserve) external view returns (uint40 timestamp) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        timestamp = reserve.lastUpdateTimestamp;
    }

    /**
    * @dev returns the utilization rate U of a specific reserve
    * @param _reserve the reserve for which the information is needed
    * @return the utilization rate in ray
    **/

    function getReserveUtilizationRate(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        uint256 totalBorrows = reserve.getTotalBorrows();

        if (totalBorrows == 0) {
            return 0;
        }

        uint256 availableLiquidity = getReserveAvailableLiquidity(_reserve);

        return totalBorrows.rayDiv(availableLiquidity.add(totalBorrows));
    }

    /**
    * @return the array of reserves configured on the core
    **/
    function getReserves() external view returns (address[] memory) {
        return reservesList;
    }

    /**
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return true if the user has chosen to use the reserve as collateral, false otherwise
    **/
    function isUserUseReserveAsCollateralEnabled(address _reserve, address _user)
    external
    view
    returns (bool)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.useAsCollateral;
    }

    /**
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the origination fee for the user
    **/
    function getUserOriginationFee(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.originationFee;
    }

    /**
    * @dev users with no loans in progress have NONE as borrow rate mode
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the borrow rate mode for the user,
    **/

    function getUserCurrentBorrowRateMode(address _reserve, address _user)
    public
    view
    returns (CoreLibrary.InterestRateMode)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (user.principalBorrowBalance == 0) {
            return CoreLibrary.InterestRateMode.NONE;
        }

        return
        user.stableBorrowRate > 0
        ? CoreLibrary.InterestRateMode.STABLE
        : CoreLibrary.InterestRateMode.VARIABLE;
    }

    /**
    * @dev gets the current borrow rate of the user
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the borrow rate for the user,
    **/
    function getUserCurrentBorrowRate(address _reserve, address _user)
    internal
    view
    returns (uint256)
    {
        CoreLibrary.InterestRateMode rateMode = getUserCurrentBorrowRateMode(_reserve, _user);

        if (rateMode == CoreLibrary.InterestRateMode.NONE) {
            return 0;
        }

        return
        rateMode == CoreLibrary.InterestRateMode.STABLE
        ? usersReserveData[_user][_reserve].stableBorrowRate
        : reserves[_reserve].currentVariableBorrowRate;
    }

    /**
    * @dev the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the user stable rate
    **/
    function getUserCurrentStableBorrowRate(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.stableBorrowRate;
    }

    /**
    * @dev calculates and returns the borrow balances of the user
    * @param _reserve the address of the reserve
    * @param _user the address of the user
    * @return the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance
    **/

    function getUserBorrowBalances(address _reserve, address _user)
    public
    view
    returns (uint256, uint256, uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        if (user.principalBorrowBalance == 0) {
            return (0, 0, 0);
        }

        uint256 principal = user.principalBorrowBalance;
        uint256 compoundedBalance = CoreLibrary.getCompoundedBorrowBalance(
            user,
            reserves[_reserve]
        );
        return (principal, compoundedBalance, compoundedBalance.sub(principal));
    }

    /**
    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the variable borrow index for the user
    **/

    function getUserVariableBorrowCumulativeIndex(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.lastVariableBorrowCumulativeIndex;
    }

    /**
    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the variable borrow index for the user
    **/

    function getUserLastUpdate(address _reserve, address _user)
    external
    view
    returns (uint256 timestamp)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        timestamp = user.lastUpdateTimestamp;
    }

    /**
    * @dev updates the lending pool core configuration
    **/
    function refreshConfiguration() external onlyLendingPoolConfigurator {
        refreshConfigInternal();
    }

    /**
    * @dev initializes a reserve
    * @param _reserve the address of the reserve
    * @param _aTokenAddress the address of the overlying aToken contract
    * @param _decimals the decimals of the reserve currency
    * @param _interestRateStrategyAddress the address of the interest rate strategy contract
    **/
    function initReserve(
        address _reserve,
        address _aTokenAddress,
        uint256 _decimals,
        address _interestRateStrategyAddress
    ) external onlyLendingPoolConfigurator {
        reserves[_reserve].init(_aTokenAddress, _decimals, _interestRateStrategyAddress);
        addReserveToListInternal(_reserve);

    }



    /**
    * @dev removes the last added reserve in the reservesList array
    * @param _reserveToRemove the address of the reserve
    **/
    function removeLastAddedReserve(address _reserveToRemove)
    external onlyLendingPoolConfigurator {

        address lastReserve = reservesList[reservesList.length-1];

        require(lastReserve == _reserveToRemove, "Reserve being removed is different than the reserve requested");

        //as we can't check if totalLiquidity is 0 (since the reserve added might not be an ERC20) we at least check that there is nothing borrowed
        require(getReserveTotalBorrows(lastReserve) == 0, "Cannot remove a reserve with liquidity deposited");

        reserves[lastReserve].isActive = false;
        reserves[lastReserve].aTokenAddress = address(0);
        reserves[lastReserve].decimals = 0;
        reserves[lastReserve].lastLiquidityCumulativeIndex = 0;
        reserves[lastReserve].lastVariableBorrowCumulativeIndex = 0;
        reserves[lastReserve].borrowingEnabled = false;
        reserves[lastReserve].usageAsCollateralEnabled = false;
        reserves[lastReserve].baseLTVasCollateral = 0;
        reserves[lastReserve].liquidationThreshold = 0;
        reserves[lastReserve].liquidationBonus = 0;
        reserves[lastReserve].interestRateStrategyAddress = address(0);

        reservesList.pop();
    }

    /**
    * @dev updates the address of the interest rate strategy contract
    * @param _reserve the address of the reserve
    * @param _rateStrategyAddress the address of the interest rate strategy contract
    **/

    function setReserveInterestRateStrategyAddress(address _reserve, address _rateStrategyAddress)
    external
    onlyLendingPoolConfigurator
    {
        reserves[_reserve].interestRateStrategyAddress = _rateStrategyAddress;
    }

    /**
    * @dev enables borrowing on a reserve. Also sets the stable rate borrowing
    * @param _reserve the address of the reserve
    * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise
    **/

    function enableBorrowingOnReserve(address _reserve, bool _stableBorrowRateEnabled)
    external
    onlyLendingPoolConfigurator
    {
        reserves[_reserve].enableBorrowing(_stableBorrowRateEnabled);
    }

    /**
    * @dev disables borrowing on a reserve
    * @param _reserve the address of the reserve
    **/

    function disableBorrowingOnReserve(address _reserve) external onlyLendingPoolConfigurator {
        reserves[_reserve].disableBorrowing();
    }

    /**
    * @dev enables a reserve to be used as collateral
    * @param _reserve the address of the reserve
    **/
    function enableReserveAsCollateral(
        address _reserve,
        uint256 _baseLTVasCollateral,
        uint256 _liquidationThreshold,
        uint256 _liquidationBonus
    ) external onlyLendingPoolConfigurator {
        reserves[_reserve].enableAsCollateral(
            _baseLTVasCollateral,
            _liquidationThreshold,
            _liquidationBonus
        );
    }

    /**
    * @dev disables a reserve to be used as collateral
    * @param _reserve the address of the reserve
    **/
    function disableReserveAsCollateral(address _reserve) external onlyLendingPoolConfigurator {
        reserves[_reserve].disableAsCollateral();
    }

    /**
    * @dev enable the stable borrow rate mode on a reserve
    * @param _reserve the address of the reserve
    **/
    function enableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isStableBorrowRateEnabled = true;
    }

    /**
    * @dev disable the stable borrow rate mode on a reserve
    * @param _reserve the address of the reserve
    **/
    function disableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isStableBorrowRateEnabled = false;
    }

    /**
    * @dev activates a reserve
    * @param _reserve the address of the reserve
    **/
    function activateReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        require(
            reserve.lastLiquidityCumulativeIndex > 0 &&
            reserve.lastVariableBorrowCumulativeIndex > 0,
            "Reserve has not been initialized yet"
        );
        reserve.isActive = true;
    }

    /**
    * @dev deactivates a reserve
    * @param _reserve the address of the reserve
    **/
    function deactivateReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isActive = false;
    }

    /**
    * @notice allows the configurator to freeze the reserve.
    * A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance.
    * @param _reserve the address of the reserve
    **/
    function freezeReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isFreezed = true;
    }

    /**
    * @notice allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed.
    * @param _reserve the address of the reserve
    **/
    function unfreezeReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isFreezed = false;
    }

    /**
    * @notice allows the configurator to update the loan to value of a reserve
    * @param _reserve the address of the reserve
    * @param _ltv the new loan to value
    **/
    function setReserveBaseLTVasCollateral(address _reserve, uint256 _ltv)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.baseLTVasCollateral = _ltv;
    }

    /**
    * @notice allows the configurator to update the liquidation threshold of a reserve
    * @param _reserve the address of the reserve
    * @param _threshold the new liquidation threshold
    **/
    function setReserveLiquidationThreshold(address _reserve, uint256 _threshold)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.liquidationThreshold = _threshold;
    }

    /**
    * @notice allows the configurator to update the liquidation bonus of a reserve
    * @param _reserve the address of the reserve
    * @param _bonus the new liquidation bonus
    **/
    function setReserveLiquidationBonus(address _reserve, uint256 _bonus)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.liquidationBonus = _bonus;
    }

    /**
    * @notice allows the configurator to update the reserve decimals
    * @param _reserve the address of the reserve
    * @param _decimals the decimals of the reserve
    **/
    function setReserveDecimals(address _reserve, uint256 _decimals)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.decimals = _decimals;
    }

    /**
    * @notice internal functions
    **/

    /**
    * @dev updates the state of a reserve as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the previous borrow balance of the borrower before the action
    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount
    * @param _amountBorrowed the new amount borrowed
    * @param _rateMode the borrow rate mode (stable, variable)
    **/

    function updateReserveStateOnBorrowInternal(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _balanceIncrease,
        uint256 _amountBorrowed,
        CoreLibrary.InterestRateMode _rateMode
    ) internal {
        reserves[_reserve].updateCumulativeIndexes();

        //increasing reserve total borrows to account for the new borrow balance of the user
        //NOTE: Depending on the previous borrow mode, the borrows might need to be switched from variable to stable or vice versa

        updateReserveTotalBorrowsByRateModeInternal(
            _reserve,
            _user,
            _principalBorrowBalance,
            _balanceIncrease,
            _amountBorrowed,
            _rateMode
        );
    }

    /**
    * @dev updates the state of a user as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _amountBorrowed the amount borrowed
    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount
    * @param _rateMode the borrow rate mode (stable, variable)
    * @return the final borrow rate for the user. Emitted by the borrow() event
    **/

    function updateUserStateOnBorrowInternal(
        address _reserve,
        address _user,
        uint256 _amountBorrowed,
        uint256 _balanceIncrease,
        uint256 _fee,
        CoreLibrary.InterestRateMode _rateMode
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (_rateMode == CoreLibrary.InterestRateMode.STABLE) {
            //stable
            //reset the user variable index, and update the stable rate
            user.stableBorrowRate = reserve.currentStableBorrowRate;
            user.lastVariableBorrowCumulativeIndex = 0;
        } else if (_rateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //variable
            //reset the user stable rate, and store the new borrow index
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        } else {
            revert("Invalid borrow rate mode");
        }
        //increase the principal borrows and the origination fee
        user.principalBorrowBalance = user.principalBorrowBalance.add(_amountBorrowed).add(
            _balanceIncrease
        );
        user.originationFee = user.originationFee.add(_fee);

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

    }

    /**
    * @dev updates the state of the reserve as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateReserveStateOnRepayInternal(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_reserve][_user];

        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(_reserve, _user);

        //update the indexes
        reserves[_reserve].updateCumulativeIndexes();

        //compound the cumulated interest to the borrow balance and then subtracting the payback amount
        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _balanceIncrease,
                user.stableBorrowRate
            );
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _paybackAmountMinusFees,
                user.stableBorrowRate
            );
        } else {
            reserve.increaseTotalBorrowsVariable(_balanceIncrease);
            reserve.decreaseTotalBorrowsVariable(_paybackAmountMinusFees);
        }
    }

    /**
    * @dev updates the state of the user as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _originationFeeRepaid the fee on the amount that is being repaid
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _repaidWholeLoan true if the user is repaying the whole loan
    **/
    function updateUserStateOnRepayInternal(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _originationFeeRepaid,
        uint256 _balanceIncrease,
        bool _repaidWholeLoan
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        //update the user principal borrow balance, adding the cumulated interest and then subtracting the payback amount
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(
            _paybackAmountMinusFees
        );
        user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;

        //if the balance decrease is equal to the previous principal (user is repaying the whole loan)
        //and the rate mode is stable, we reset the interest rate mode of the user
        if (_repaidWholeLoan) {
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = 0;
        }
        user.originationFee = user.originationFee.sub(_originationFeeRepaid);

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

    }

    /**
    * @dev updates the state of the user as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is performing the rate swap
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the the principal amount borrowed by the user
    * @param _compoundedBorrowBalance the principal amount plus the accrued interest
    * @param _currentRateMode the rate mode at which the user borrowed
    **/
    function updateReserveStateOnSwapRateInternal(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _compoundedBorrowBalance,
        CoreLibrary.InterestRateMode _currentRateMode
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        //compounding reserve indexes
        reserve.updateCumulativeIndexes();

        if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {
            uint256 userCurrentStableRate = user.stableBorrowRate;

            //swap to variable
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _principalBorrowBalance,
                userCurrentStableRate
            ); //decreasing stable from old principal balance
            reserve.increaseTotalBorrowsVariable(_compoundedBorrowBalance); //increase variable borrows
        } else if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //swap to stable
            uint256 currentStableRate = reserve.currentStableBorrowRate;
            reserve.decreaseTotalBorrowsVariable(_principalBorrowBalance);
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _compoundedBorrowBalance,
                currentStableRate
            );

        } else {
            revert("Invalid rate mode received");
        }
    }

    /**
    * @dev updates the state of the user as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is performing the swap
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _currentRateMode the current rate mode of the user
    **/

    function updateUserStateOnSwapRateInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease,
        CoreLibrary.InterestRateMode _currentRateMode
    ) internal returns (CoreLibrary.InterestRateMode) {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        CoreLibrary.InterestRateMode newMode = CoreLibrary.InterestRateMode.NONE;

        if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //switch to stable
            newMode = CoreLibrary.InterestRateMode.STABLE;
            user.stableBorrowRate = reserve.currentStableBorrowRate;
            user.lastVariableBorrowCumulativeIndex = 0;
        } else if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {
            newMode = CoreLibrary.InterestRateMode.VARIABLE;
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        } else {
            revert("Invalid interest rate mode received");
        }
        //compounding cumulated interest
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);
        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

        return newMode;
    }

    /**
    * @dev updates the state of the principal reserve as a consequence of a liquidation action.
    * @param _principalReserve the address of the principal reserve that is being repaid
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updatePrincipalReserveStateOnLiquidationInternal(
        address _principalReserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_principalReserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_principalReserve];

        //update principal reserve data
        reserve.updateCumulativeIndexes();

        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(
            _principalReserve,
            _user
        );

        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            //increase the total borrows by the compounded interest
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _balanceIncrease,
                user.stableBorrowRate
            );

            //decrease by the actual amount to liquidate
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _amountToLiquidate,
                user.stableBorrowRate
            );

        } else {
            //increase the total borrows by the compounded interest
            reserve.increaseTotalBorrowsVariable(_balanceIncrease);

            //decrease by the actual amount to liquidate
            reserve.decreaseTotalBorrowsVariable(_amountToLiquidate);
        }

    }

    /**
    * @dev updates the state of the collateral reserve as a consequence of a liquidation action.
    * @param _collateralReserve the address of the collateral reserve that is being liquidated
    **/
    function updateCollateralReserveStateOnLiquidationInternal(
        address _collateralReserve
    ) internal {
        //update collateral reserve
        reserves[_collateralReserve].updateCumulativeIndexes();

    }

    /**
    * @dev updates the state of the user being liquidated as a consequence of a liquidation action.
    * @param _reserve the address of the principal reserve that is being repaid
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _feeLiquidated the amount of origination fee being liquidated
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/
    function updateUserStateOnLiquidationInternal(
        address _reserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _feeLiquidated,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        //first increase by the compounded interest, then decrease by the liquidated amount
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(
            _amountToLiquidate
        );

        if (
            getUserCurrentBorrowRateMode(_reserve, _user) == CoreLibrary.InterestRateMode.VARIABLE
        ) {
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        }

        if(_feeLiquidated > 0){
            user.originationFee = user.originationFee.sub(_feeLiquidated);
        }

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);
    }

    /**
    * @dev updates the state of the reserve as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateReserveStateOnRebalanceInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        reserve.updateCumulativeIndexes();

        reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
            _balanceIncrease,
            user.stableBorrowRate
        );

    }

    /**
    * @dev updates the state of the user as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateUserStateOnRebalanceInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);
        user.stableBorrowRate = reserve.currentStableBorrowRate;

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);
    }

    /**
    * @dev updates the state of the user as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _amountBorrowed the accrued interest on the borrowed amount
    **/
    function updateReserveTotalBorrowsByRateModeInternal(
        address _reserve,
        address _user,
        uint256 _principalBalance,
        uint256 _balanceIncrease,
        uint256 _amountBorrowed,
        CoreLibrary.InterestRateMode _newBorrowRateMode
    ) internal {
        CoreLibrary.InterestRateMode previousRateMode = getUserCurrentBorrowRateMode(
            _reserve,
            _user
        );
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        if (previousRateMode == CoreLibrary.InterestRateMode.STABLE) {
            CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _principalBalance,
                user.stableBorrowRate
            );
        } else if (previousRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            reserve.decreaseTotalBorrowsVariable(_principalBalance);
        }

        uint256 newPrincipalAmount = _principalBalance.add(_balanceIncrease).add(_amountBorrowed);
        if (_newBorrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                newPrincipalAmount,
                reserve.currentStableBorrowRate
            );
        } else if (_newBorrowRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            reserve.increaseTotalBorrowsVariable(newPrincipalAmount);
        } else {
            revert("Invalid new borrow rate mode");
        }
    }

    /**
    * @dev Updates the reserve current stable borrow rate Rf, the current variable borrow rate Rv and the current liquidity rate Rl.
    * Also updates the lastUpdateTimestamp value. Please refer to the whitepaper for further information.
    * @param _reserve the address of the reserve to be updated
    * @param _liquidityAdded the amount of liquidity added to the protocol (deposit or repay) in the previous action
    * @param _liquidityTaken the amount of liquidity taken from the protocol (redeem or borrow)
    **/

    function updateReserveInterestRatesAndTimestampInternal(
        address _reserve,
        uint256 _liquidityAdded,
        uint256 _liquidityTaken
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        (uint256 newLiquidityRate, uint256 newStableRate, uint256 newVariableRate) = IReserveInterestRateStrategy(
            reserve
            .interestRateStrategyAddress
        )
        .calculateInterestRates(
            _reserve,
            getReserveAvailableLiquidity(_reserve).add(_liquidityAdded).sub(_liquidityTaken),
            reserve.totalBorrowsStable,
            reserve.totalBorrowsVariable,
            reserve.currentAverageStableBorrowRate
        );

        reserve.currentLiquidityRate = newLiquidityRate;
        reserve.currentStableBorrowRate = newStableRate;
        reserve.currentVariableBorrowRate = newVariableRate;

        //solium-disable-next-line
        reserve.lastUpdateTimestamp = uint40(block.timestamp);

        emit ReserveUpdated(
            _reserve,
            newLiquidityRate,
            newStableRate,
            newVariableRate,
            reserve.lastLiquidityCumulativeIndex,
            reserve.lastVariableBorrowCumulativeIndex
        );
    }

    /**
    * @dev transfers to the protocol fees of a flashloan to the fees collection address
    * @param _token the address of the token being transferred
    * @param _amount the amount being transferred
    **/

    function transferFlashLoanProtocolFeeInternal(address _token, uint256 _amount) internal {
        address payable receiver = address(uint160(addressesProvider.getTokenDistributor()));

        if (_token != EthAddressLib.ethAddress()) {
            ERC20(_token).safeTransfer(receiver, _amount);
        } else {
            receiver.transfer(_amount);
        }
    }

    /**
    * @dev updates the internal configuration of the core
    **/
    function refreshConfigInternal() internal {
        lendingPoolAddress = addressesProvider.getLendingPool();
    }

    /**
    * @dev adds a reserve to the array of the reserves address
    **/
    function addReserveToListInternal(address _reserve) internal {
        bool reserveAlreadyAdded = false;
        for (uint256 i = 0; i < reservesList.length; i++)
            if (reservesList[i] == _reserve) {
                reserveAlreadyAdded = true;
            }
        if (!reserveAlreadyAdded) reservesList.push(_reserve);
    }

}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-01-09 04:32:00 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 04:32:00 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 28820
completion_tokens: 1
total_tokens: 28821
cost: $-1.000000


[2024-01-09 04:32:00 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: pragma solidity ^0.5.0;

import "openzeppelin-solidity/contracts/math/SafeMath.sol";
import "openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol";
import "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol";
import "openzeppelin-solidity/contracts/utils/Address.sol";
import "../libraries/openzeppelin-upgradeability/VersionedInitializable.sol";

import "../libraries/CoreLibrary.sol";
import "../configuration/LendingPoolAddressesProvider.sol";
import "../interfaces/ILendingRateOracle.sol";
import "../interfaces/IReserveInterestRateStrategy.sol";
import "../libraries/WadRayMath.sol";
import "../tokenization/AToken.sol";
import "../libraries/EthAddressLib.sol";

/**
* @title LendingPoolCore contract
* @author Aave
* @notice Holds the state of the lending pool and all the funds deposited
* @dev NOTE: The core does not enforce security checks on the update of the state
* (eg, updateStateOnBorrow() does not enforce that borrowed is enabled on the reserve).
* The check that an action can be performed is a duty of the overlying LendingPool contract.
**/

contract LendingPoolCore is VersionedInitializable {
    using SafeMath for uint256;
    using WadRayMath for uint256;
    using CoreLibrary for CoreLibrary.ReserveData;
    using CoreLibrary for CoreLibrary.UserReserveData;
    using SafeERC20 for ERC20;
    using Address for address payable;

    /**
    * @dev Emitted when the state of a reserve is updated
    * @param reserve the address of the reserve
    * @param liquidityRate the new liquidity rate
    * @param stableBorrowRate the new stable borrow rate
    * @param variableBorrowRate the new variable borrow rate
    * @param liquidityIndex the new liquidity index
    * @param variableBorrowIndex the new variable borrow index
    **/
    event ReserveUpdated(
        address indexed reserve,
        uint256 liquidityRate,
        uint256 stableBorrowRate,
        uint256 variableBorrowRate,
        uint256 liquidityIndex,
        uint256 variableBorrowIndex
    );

    address public lendingPoolAddress;

    LendingPoolAddressesProvider public addressesProvider;

    /**
    * @dev only lending pools can use functions affected by this modifier
    **/
    modifier onlyLendingPool {
        require(lendingPoolAddress == msg.sender, "The caller must be a lending pool contract");
        _;
    }

    /**
    * @dev only lending pools configurator can use functions affected by this modifier
    **/
    modifier onlyLendingPoolConfigurator {
        require(
            addressesProvider.getLendingPoolConfigurator() == msg.sender,
            "The caller must be a lending pool configurator contract"
        );
        _;
    }

    mapping(address => CoreLibrary.ReserveData) internal reserves;
    mapping(address => mapping(address => CoreLibrary.UserReserveData)) internal usersReserveData;

    address[] public reservesList;

    uint256 public constant CORE_REVISION = 0x4;

    /**
    * @dev returns the revision number of the contract
    **/
    function getRevision() internal pure returns (uint256) {
        return CORE_REVISION;
    }

    /**
    * @dev initializes the Core contract, invoked upon registration on the AddressesProvider
    * @param _addressesProvider the addressesProvider contract
    **/

    function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {
        addressesProvider = _addressesProvider;
        refreshConfigInternal();
    }

    /**
    * @dev updates the state of the core as a result of a deposit action
    * @param _reserve the address of the reserve in which the deposit is happening
    * @param _user the address of the the user depositing
    * @param _amount the amount being deposited
    * @param _isFirstDeposit true if the user is depositing for the first time
    **/

    function updateStateOnDeposit(
        address _reserve,
        address _user,
        uint256 _amount,
        bool _isFirstDeposit
    ) external onlyLendingPool {
        reserves[_reserve].updateCumulativeIndexes();
        updateReserveInterestRatesAndTimestampInternal(_reserve, _amount, 0);

        if (_isFirstDeposit) {
            //if this is the first deposit of the user, we configure the deposit as enabled to be used as collateral
            setUserUseReserveAsCollateral(_reserve, _user, true);
        }
    }

    /**
    * @dev updates the state of the core as a result of a redeem action
    * @param _reserve the address of the reserve in which the redeem is happening
    * @param _user the address of the the user redeeming
    * @param _amountRedeemed the amount being redeemed
    * @param _userRedeemedEverything true if the user is redeeming everything
    **/
    function updateStateOnRedeem(
        address _reserve,
        address _user,
        uint256 _amountRedeemed,
        bool _userRedeemedEverything
    ) external onlyLendingPool {
        //compound liquidity and variable borrow interests
        reserves[_reserve].updateCumulativeIndexes();
        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountRedeemed);

        //if user redeemed everything the useReserveAsCollateral flag is reset
        if (_userRedeemedEverything) {
            setUserUseReserveAsCollateral(_reserve, _user, false);
        }
    }

    /**
    * @dev updates the state of the core as a result of a flashloan action
    * @param _reserve the address of the reserve in which the flashloan is happening
    * @param _income the income of the protocol as a result of the action
    **/
    function updateStateOnFlashLoan(
        address _reserve,
        uint256 _availableLiquidityBefore,
        uint256 _income,
        uint256 _protocolFee
    ) external onlyLendingPool {
        transferFlashLoanProtocolFeeInternal(_reserve, _protocolFee);

        //compounding the cumulated interest
        reserves[_reserve].updateCumulativeIndexes();

        uint256 totalLiquidityBefore = _availableLiquidityBefore.add(
            getReserveTotalBorrows(_reserve)
        );

        //compounding the received fee into the reserve
        reserves[_reserve].cumulateToLiquidityIndex(totalLiquidityBefore, _income);

        //refresh interest rates
        updateReserveInterestRatesAndTimestampInternal(_reserve, _income, 0);
    }

    /**
    * @dev updates the state of the core as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _amountBorrowed the new amount borrowed
    * @param _borrowFee the fee on the amount borrowed
    * @param _rateMode the borrow rate mode (stable, variable)
    * @return the new borrow rate for the user
    **/
    function updateStateOnBorrow(
        address _reserve,
        address _user,
        uint256 _amountBorrowed,
        uint256 _borrowFee,
        CoreLibrary.InterestRateMode _rateMode
    ) external onlyLendingPool returns (uint256, uint256) {
        // getting the previous borrow data of the user
        (uint256 principalBorrowBalance, , uint256 balanceIncrease) = getUserBorrowBalances(
            _reserve,
            _user
        );

        updateReserveStateOnBorrowInternal(
            _reserve,
            _user,
            principalBorrowBalance,
            balanceIncrease,
            _amountBorrowed,
            _rateMode
        );

        updateUserStateOnBorrowInternal(
            _reserve,
            _user,
            _amountBorrowed,
            balanceIncrease,
            _borrowFee,
            _rateMode
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountBorrowed);

        return (getUserCurrentBorrowRate(_reserve, _user), balanceIncrease);
    }

    /**
    * @dev updates the state of the core as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _originationFeeRepaid the fee on the amount that is being repaid
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _repaidWholeLoan true if the user is repaying the whole loan
    **/

    function updateStateOnRepay(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _originationFeeRepaid,
        uint256 _balanceIncrease,
        bool _repaidWholeLoan
    ) external onlyLendingPool {
        updateReserveStateOnRepayInternal(
            _reserve,
            _user,
            _paybackAmountMinusFees,
            _balanceIncrease
        );
        updateUserStateOnRepayInternal(
            _reserve,
            _user,
            _paybackAmountMinusFees,
            _originationFeeRepaid,
            _balanceIncrease,
            _repaidWholeLoan
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, _paybackAmountMinusFees, 0);
    }

    /**
    * @dev updates the state of the core as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the amount borrowed by the user
    * @param _compoundedBorrowBalance the amount borrowed plus accrued interest
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _currentRateMode the current interest rate mode for the user
    **/
    function updateStateOnSwapRate(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _compoundedBorrowBalance,
        uint256 _balanceIncrease,
        CoreLibrary.InterestRateMode _currentRateMode
    ) external onlyLendingPool returns (CoreLibrary.InterestRateMode, uint256) {
        updateReserveStateOnSwapRateInternal(
            _reserve,
            _user,
            _principalBorrowBalance,
            _compoundedBorrowBalance,
            _currentRateMode
        );

        CoreLibrary.InterestRateMode newRateMode = updateUserStateOnSwapRateInternal(
            _reserve,
            _user,
            _balanceIncrease,
            _currentRateMode
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);

        return (newRateMode, getUserCurrentBorrowRate(_reserve, _user));
    }

    /**
    * @dev updates the state of the core as a consequence of a liquidation action.
    * @param _principalReserve the address of the principal reserve that is being repaid
    * @param _collateralReserve the address of the collateral reserve that is being liquidated
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _collateralToLiquidate the amount of collateral being liquidated
    * @param _feeLiquidated the amount of origination fee being liquidated
    * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise
    **/
    function updateStateOnLiquidation(
        address _principalReserve,
        address _collateralReserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _collateralToLiquidate,
        uint256 _feeLiquidated,
        uint256 _liquidatedCollateralForFee,
        uint256 _balanceIncrease,
        bool _liquidatorReceivesAToken
    ) external onlyLendingPool {
        updatePrincipalReserveStateOnLiquidationInternal(
            _principalReserve,
            _user,
            _amountToLiquidate,
            _balanceIncrease
        );

        updateCollateralReserveStateOnLiquidationInternal(
            _collateralReserve
        );

        updateUserStateOnLiquidationInternal(
            _principalReserve,
            _user,
            _amountToLiquidate,
            _feeLiquidated,
            _balanceIncrease
        );

        updateReserveInterestRatesAndTimestampInternal(_principalReserve, _amountToLiquidate, 0);

        if (!_liquidatorReceivesAToken) {
            updateReserveInterestRatesAndTimestampInternal(
                _collateralReserve,
                0,
                _collateralToLiquidate.add(_liquidatedCollateralForFee)
            );
        }

    }

    /**
    * @dev updates the state of the core as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @return the new stable rate for the user
    **/
    function updateStateOnRebalance(address _reserve, address _user, uint256 _balanceIncrease)
    external
    onlyLendingPool
    returns (uint256)
    {
        updateReserveStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);

        //update user data and rebalance the rate
        updateUserStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);
        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);
        return usersReserveData[_user][_reserve].stableBorrowRate;
    }

    /**
    * @dev enables or disables a reserve as collateral
    * @param _reserve the address of the principal reserve where the user deposited
    * @param _user the address of the depositor
    * @param _useAsCollateral true if the depositor wants to use the reserve as collateral
    **/
    function setUserUseReserveAsCollateral(address _reserve, address _user, bool _useAsCollateral)
    public
    onlyLendingPool
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        user.useAsCollateral = _useAsCollateral;
    }

    /**
    * @notice ETH/token transfer functions
    **/

    /**
    * @dev fallback function enforces that the caller is a contract, to support flashloan transfers
    **/
    function() external payable {
        //only contracts can send ETH to the core
        require(msg.sender.isContract(), "Only contracts can send ether to the Lending pool core");

    }

    /**
    * @dev transfers to the user a specific amount from the reserve.
    * @param _reserve the address of the reserve where the transfer is happening
    * @param _user the address of the user receiving the transfer
    * @param _amount the amount being transferred
    **/
    function transferToUser(address _reserve, address payable _user, uint256 _amount)
    external
    onlyLendingPool
    {
        if (_reserve != EthAddressLib.ethAddress()) {
            ERC20(_reserve).safeTransfer(_user, _amount);
        } else {
            //solium-disable-next-line
            (bool result, ) = _user.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers the protocol fees to the fees collection address
    * @param _token the address of the token being transferred
    * @param _user the address of the user from where the transfer is happening
    * @param _amount the amount being transferred
    * @param _destination the fee receiver address
    **/

    function transferToFeeCollectionAddress(
        address _token,
        address _user,
        uint256 _amount,
        address _destination
    ) external payable onlyLendingPool {
        address payable feeAddress = address(uint160(_destination)); //cast the address to payable

        if (_token != EthAddressLib.ethAddress()) {
            require(
                msg.value == 0,
                "User is sending ETH along with the ERC20 transfer. Check the value attribute of the transaction"
            );
            ERC20(_token).safeTransferFrom(_user, feeAddress, _amount);
        } else {
            require(msg.value >= _amount, "The amount and the value sent to deposit do not match");
            //solium-disable-next-line
            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers the fees to the fees collection address in the case of liquidation
    * @param _token the address of the token being transferred
    * @param _amount the amount being transferred
    * @param _destination the fee receiver address
    **/
    function liquidateFee(
        address _token,
        uint256 _amount,
        address _destination
    ) external payable onlyLendingPool {
        address payable feeAddress = address(uint160(_destination)); //cast the address to payable
        require(
            msg.value == 0,
            "Fee liquidation does not require any transfer of value"
        );

        if (_token != EthAddressLib.ethAddress()) {
            ERC20(_token).safeTransfer(feeAddress, _amount);
        } else {
            //solium-disable-next-line
            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers an amount from a user to the destination reserve
    * @param _reserve the address of the reserve where the amount is being transferred
    * @param _user the address of the user from where the transfer is happening
    * @param _amount the amount being transferred
    **/
    function transferToReserve(address _reserve, address payable _user, uint256 _amount)
    external
    payable
    onlyLendingPool
    {
        if (_reserve != EthAddressLib.ethAddress()) {
            require(msg.value == 0, "User is sending ETH along with the ERC20 transfer.");
            ERC20(_reserve).safeTransferFrom(_user, address(this), _amount);

        } else {
            require(msg.value >= _amount, "The amount and the value sent to deposit do not match");

            if (msg.value > _amount) {
                //send back excess ETH
                uint256 excessAmount = msg.value.sub(_amount);
                //solium-disable-next-line
                (bool result, ) = _user.call.value(excessAmount).gas(50000)("");
                require(result, "Transfer of ETH failed");
            }
        }
    }

    /**
    * @notice data access functions
    **/

    /**
    * @dev returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral)
    * needed to calculate the global account data in the LendingPoolDataProvider
    * @param _reserve the address of the reserve
    * @param _user the address of the user
    * @return the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not
    **/
    function getUserBasicReserveData(address _reserve, address _user)
    external
    view
    returns (uint256, uint256, uint256, bool)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        uint256 underlyingBalance = getUserUnderlyingAssetBalance(_reserve, _user);

        if (user.principalBorrowBalance == 0) {
            return (underlyingBalance, 0, 0, user.useAsCollateral);
        }

        return (
        underlyingBalance,
        user.getCompoundedBorrowBalance(reserve),
        user.originationFee,
        user.useAsCollateral
        );
    }

    /**
    * @dev checks if a user is allowed to borrow at a stable rate
    * @param _reserve the reserve address
    * @param _user the user
    * @param _amount the amount the the user wants to borrow
    * @return true if the user is allowed to borrow at a stable rate, false otherwise
    **/

    function isUserAllowedToBorrowAtStable(address _reserve, address _user, uint256 _amount)
    external
    view
    returns (bool)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (!reserve.isStableBorrowRateEnabled) return false;

        return
        !user.useAsCollateral ||
        !reserve.usageAsCollateralEnabled ||
        _amount > getUserUnderlyingAssetBalance(_reserve, _user);
    }

    /**
    * @dev gets the underlying asset balance of a user based on the corresponding aToken balance.
    * @param _reserve the reserve address
    * @param _user the user address
    * @return the underlying deposit balance of the user
    **/

    function getUserUnderlyingAssetBalance(address _reserve, address _user)
    public
    view
    returns (uint256)
    {
        AToken aToken = AToken(reserves[_reserve].aTokenAddress);
        return aToken.balanceOf(_user);

    }

    /**
    * @dev gets the interest rate strategy contract address for the reserve
    * @param _reserve the reserve address
    * @return the address of the interest rate strategy contract
    **/
    function getReserveInterestRateStrategyAddress(address _reserve) public view returns (address) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.interestRateStrategyAddress;
    }

    /**
    * @dev gets the aToken contract address for the reserve
    * @param _reserve the reserve address
    * @return the address of the aToken contract
    **/

    function getReserveATokenAddress(address _reserve) public view returns (address) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.aTokenAddress;
    }

    /**
    * @dev gets the available liquidity in the reserve. The available liquidity is the balance of the core contract
    * @param _reserve the reserve address
    * @return the available liquidity
    **/
    function getReserveAvailableLiquidity(address _reserve) public view returns (uint256) {
        uint256 balance = 0;

        if (_reserve == EthAddressLib.ethAddress()) {
            balance = address(this).balance;
        } else {
            balance = IERC20(_reserve).balanceOf(address(this));
        }
        return balance;
    }

    /**
    * @dev gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows
    * @param _reserve the reserve address
    * @return the total liquidity
    **/
    function getReserveTotalLiquidity(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return getReserveAvailableLiquidity(_reserve).add(reserve.getTotalBorrows());
    }

    /**
    * @dev gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there
    * there has been 100% income.
    * @param _reserve the reserve address
    * @return the reserve normalized income
    **/
    function getReserveNormalizedIncome(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.getNormalizedIncome();
    }

    /**
    * @dev gets the reserve total borrows
    * @param _reserve the reserve address
    * @return the total borrows (stable + variable)
    **/
    function getReserveTotalBorrows(address _reserve) public view returns (uint256) {
        return reserves[_reserve].getTotalBorrows();
    }

    /**
    * @dev gets the reserve total borrows stable
    * @param _reserve the reserve address
    * @return the total borrows stable
    **/
    function getReserveTotalBorrowsStable(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.totalBorrowsStable;
    }

    /**
    * @dev gets the reserve total borrows variable
    * @param _reserve the reserve address
    * @return the total borrows variable
    **/

    function getReserveTotalBorrowsVariable(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.totalBorrowsVariable;
    }

    /**
    * @dev gets the reserve liquidation threshold
    * @param _reserve the reserve address
    * @return the reserve liquidation threshold
    **/

    function getReserveLiquidationThreshold(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.liquidationThreshold;
    }

    /**
    * @dev gets the reserve liquidation bonus
    * @param _reserve the reserve address
    * @return the reserve liquidation bonus
    **/

    function getReserveLiquidationBonus(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.liquidationBonus;
    }

    /**
    * @dev gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty
    * @param _reserve the reserve address
    * @return the reserve current variable borrow rate
    **/

    function getReserveCurrentVariableBorrowRate(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        if (reserve.currentVariableBorrowRate == 0) {
            return
            IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)
            .getBaseVariableBorrowRate();
        }
        return reserve.currentVariableBorrowRate;
    }

    /**
    * @dev gets the reserve current stable borrow rate. Is the market rate if the reserve is empty
    * @param _reserve the reserve address
    * @return the reserve current stable borrow rate
    **/

    function getReserveCurrentStableBorrowRate(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        ILendingRateOracle oracle = ILendingRateOracle(addressesProvider.getLendingRateOracle());

        if (reserve.currentStableBorrowRate == 0) {
            //no stable rate borrows yet
            return oracle.getMarketBorrowRate(_reserve);
        }

        return reserve.currentStableBorrowRate;
    }

    /**
    * @dev gets the reserve average stable borrow rate. The average stable rate is the weighted average
    * of all the loans taken at stable rate.
    * @param _reserve the reserve address
    * @return the reserve current average borrow rate
    **/
    function getReserveCurrentAverageStableBorrowRate(address _reserve)
    external
    view
    returns (uint256)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.currentAverageStableBorrowRate;
    }

    /**
    * @dev gets the reserve liquidity rate
    * @param _reserve the reserve address
    * @return the reserve liquidity rate
    **/
    function getReserveCurrentLiquidityRate(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.currentLiquidityRate;
    }

    /**
    * @dev gets the reserve liquidity cumulative index
    * @param _reserve the reserve address
    * @return the reserve liquidity cumulative index
    **/
    function getReserveLiquidityCumulativeIndex(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.lastLiquidityCumulativeIndex;
    }

    /**
    * @dev gets the reserve variable borrow index
    * @param _reserve the reserve address
    * @return the reserve variable borrow index
    **/
    function getReserveVariableBorrowsCumulativeIndex(address _reserve)
    external
    view
    returns (uint256)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.lastVariableBorrowCumulativeIndex;
    }

    /**
    * @dev this function aggregates the configuration parameters of the reserve.
    * It's used in the LendingPoolDataProvider specifically to save gas, and avoid
    * multiple external contract calls to fetch the same data.
    * @param _reserve the reserve address
    * @return the reserve decimals
    * @return the base ltv as collateral
    * @return the liquidation threshold
    * @return if the reserve is used as collateral or not
    **/
    function getReserveConfiguration(address _reserve)
    external
    view
    returns (uint256, uint256, uint256, bool)
    {
        uint256 decimals;
        uint256 baseLTVasCollateral;
        uint256 liquidationThreshold;
        bool usageAsCollateralEnabled;

        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        decimals = reserve.decimals;
        baseLTVasCollateral = reserve.baseLTVasCollateral;
        liquidationThreshold = reserve.liquidationThreshold;
        usageAsCollateralEnabled = reserve.usageAsCollateralEnabled;

        return (decimals, baseLTVasCollateral, liquidationThreshold, usageAsCollateralEnabled);
    }

    /**
    * @dev returns the decimals of the reserve
    * @param _reserve the reserve address
    * @return the reserve decimals
    **/
    function getReserveDecimals(address _reserve) external view returns (uint256) {
        return reserves[_reserve].decimals;
    }

    /**
    * @dev returns true if the reserve is enabled for borrowing
    * @param _reserve the reserve address
    * @return true if the reserve is enabled for borrowing, false otherwise
    **/

    function isReserveBorrowingEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.borrowingEnabled;
    }

    /**
    * @dev returns true if the reserve is enabled as collateral
    * @param _reserve the reserve address
    * @return true if the reserve is enabled as collateral, false otherwise
    **/

    function isReserveUsageAsCollateralEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.usageAsCollateralEnabled;
    }

    /**
    * @dev returns true if the stable rate is enabled on reserve
    * @param _reserve the reserve address
    * @return true if the stable rate is enabled on reserve, false otherwise
    **/
    function getReserveIsStableBorrowRateEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isStableBorrowRateEnabled;
    }

    /**
    * @dev returns true if the reserve is active
    * @param _reserve the reserve address
    * @return true if the reserve is active, false otherwise
    **/
    function getReserveIsActive(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isActive;
    }

    /**
    * @notice returns if a reserve is freezed
    * @param _reserve the reserve for which the information is needed
    * @return true if the reserve is freezed, false otherwise
    **/

    function getReserveIsFreezed(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isFreezed;
    }

    /**
    * @notice returns the timestamp of the last action on the reserve
    * @param _reserve the reserve for which the information is needed
    * @return the last updated timestamp of the reserve
    **/

    function getReserveLastUpdate(address _reserve) external view returns (uint40 timestamp) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        timestamp = reserve.lastUpdateTimestamp;
    }

    /**
    * @dev returns the utilization rate U of a specific reserve
    * @param _reserve the reserve for which the information is needed
    * @return the utilization rate in ray
    **/

    function getReserveUtilizationRate(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        uint256 totalBorrows = reserve.getTotalBorrows();

        if (totalBorrows == 0) {
            return 0;
        }

        uint256 availableLiquidity = getReserveAvailableLiquidity(_reserve);

        return totalBorrows.rayDiv(availableLiquidity.add(totalBorrows));
    }

    /**
    * @return the array of reserves configured on the core
    **/
    function getReserves() external view returns (address[] memory) {
        return reservesList;
    }

    /**
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return true if the user has chosen to use the reserve as collateral, false otherwise
    **/
    function isUserUseReserveAsCollateralEnabled(address _reserve, address _user)
    external
    view
    returns (bool)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.useAsCollateral;
    }

    /**
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the origination fee for the user
    **/
    function getUserOriginationFee(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.originationFee;
    }

    /**
    * @dev users with no loans in progress have NONE as borrow rate mode
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the borrow rate mode for the user,
    **/

    function getUserCurrentBorrowRateMode(address _reserve, address _user)
    public
    view
    returns (CoreLibrary.InterestRateMode)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (user.principalBorrowBalance == 0) {
            return CoreLibrary.InterestRateMode.NONE;
        }

        return
        user.stableBorrowRate > 0
        ? CoreLibrary.InterestRateMode.STABLE
        : CoreLibrary.InterestRateMode.VARIABLE;
    }

    /**
    * @dev gets the current borrow rate of the user
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the borrow rate for the user,
    **/
    function getUserCurrentBorrowRate(address _reserve, address _user)
    internal
    view
    returns (uint256)
    {
        CoreLibrary.InterestRateMode rateMode = getUserCurrentBorrowRateMode(_reserve, _user);

        if (rateMode == CoreLibrary.InterestRateMode.NONE) {
            return 0;
        }

        return
        rateMode == CoreLibrary.InterestRateMode.STABLE
        ? usersReserveData[_user][_reserve].stableBorrowRate
        : reserves[_reserve].currentVariableBorrowRate;
    }

    /**
    * @dev the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the user stable rate
    **/
    function getUserCurrentStableBorrowRate(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.stableBorrowRate;
    }

    /**
    * @dev calculates and returns the borrow balances of the user
    * @param _reserve the address of the reserve
    * @param _user the address of the user
    * @return the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance
    **/

    function getUserBorrowBalances(address _reserve, address _user)
    public
    view
    returns (uint256, uint256, uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        if (user.principalBorrowBalance == 0) {
            return (0, 0, 0);
        }

        uint256 principal = user.principalBorrowBalance;
        uint256 compoundedBalance = CoreLibrary.getCompoundedBorrowBalance(
            user,
            reserves[_reserve]
        );
        return (principal, compoundedBalance, compoundedBalance.sub(principal));
    }

    /**
    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the variable borrow index for the user
    **/

    function getUserVariableBorrowCumulativeIndex(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.lastVariableBorrowCumulativeIndex;
    }

    /**
    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the variable borrow index for the user
    **/

    function getUserLastUpdate(address _reserve, address _user)
    external
    view
    returns (uint256 timestamp)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        timestamp = user.lastUpdateTimestamp;
    }

    /**
    * @dev updates the lending pool core configuration
    **/
    function refreshConfiguration() external onlyLendingPoolConfigurator {
        refreshConfigInternal();
    }

    /**
    * @dev initializes a reserve
    * @param _reserve the address of the reserve
    * @param _aTokenAddress the address of the overlying aToken contract
    * @param _decimals the decimals of the reserve currency
    * @param _interestRateStrategyAddress the address of the interest rate strategy contract
    **/
    function initReserve(
        address _reserve,
        address _aTokenAddress,
        uint256 _decimals,
        address _interestRateStrategyAddress
    ) external onlyLendingPoolConfigurator {
        reserves[_reserve].init(_aTokenAddress, _decimals, _interestRateStrategyAddress);
        addReserveToListInternal(_reserve);

    }



    /**
    * @dev removes the last added reserve in the reservesList array
    * @param _reserveToRemove the address of the reserve
    **/
    function removeLastAddedReserve(address _reserveToRemove)
    external onlyLendingPoolConfigurator {

        address lastReserve = reservesList[reservesList.length-1];

        require(lastReserve == _reserveToRemove, "Reserve being removed is different than the reserve requested");

        //as we can't check if totalLiquidity is 0 (since the reserve added might not be an ERC20) we at least check that there is nothing borrowed
        require(getReserveTotalBorrows(lastReserve) == 0, "Cannot remove a reserve with liquidity deposited");

        reserves[lastReserve].isActive = false;
        reserves[lastReserve].aTokenAddress = address(0);
        reserves[lastReserve].decimals = 0;
        reserves[lastReserve].lastLiquidityCumulativeIndex = 0;
        reserves[lastReserve].lastVariableBorrowCumulativeIndex = 0;
        reserves[lastReserve].borrowingEnabled = false;
        reserves[lastReserve].usageAsCollateralEnabled = false;
        reserves[lastReserve].baseLTVasCollateral = 0;
        reserves[lastReserve].liquidationThreshold = 0;
        reserves[lastReserve].liquidationBonus = 0;
        reserves[lastReserve].interestRateStrategyAddress = address(0);

        reservesList.pop();
    }

    /**
    * @dev updates the address of the interest rate strategy contract
    * @param _reserve the address of the reserve
    * @param _rateStrategyAddress the address of the interest rate strategy contract
    **/

    function setReserveInterestRateStrategyAddress(address _reserve, address _rateStrategyAddress)
    external
    onlyLendingPoolConfigurator
    {
        reserves[_reserve].interestRateStrategyAddress = _rateStrategyAddress;
    }

    /**
    * @dev enables borrowing on a reserve. Also sets the stable rate borrowing
    * @param _reserve the address of the reserve
    * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise
    **/

    function enableBorrowingOnReserve(address _reserve, bool _stableBorrowRateEnabled)
    external
    onlyLendingPoolConfigurator
    {
        reserves[_reserve].enableBorrowing(_stableBorrowRateEnabled);
    }

    /**
    * @dev disables borrowing on a reserve
    * @param _reserve the address of the reserve
    **/

    function disableBorrowingOnReserve(address _reserve) external onlyLendingPoolConfigurator {
        reserves[_reserve].disableBorrowing();
    }

    /**
    * @dev enables a reserve to be used as collateral
    * @param _reserve the address of the reserve
    **/
    function enableReserveAsCollateral(
        address _reserve,
        uint256 _baseLTVasCollateral,
        uint256 _liquidationThreshold,
        uint256 _liquidationBonus
    ) external onlyLendingPoolConfigurator {
        reserves[_reserve].enableAsCollateral(
            _baseLTVasCollateral,
            _liquidationThreshold,
            _liquidationBonus
        );
    }

    /**
    * @dev disables a reserve to be used as collateral
    * @param _reserve the address of the reserve
    **/
    function disableReserveAsCollateral(address _reserve) external onlyLendingPoolConfigurator {
        reserves[_reserve].disableAsCollateral();
    }

    /**
    * @dev enable the stable borrow rate mode on a reserve
    * @param _reserve the address of the reserve
    **/
    function enableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isStableBorrowRateEnabled = true;
    }

    /**
    * @dev disable the stable borrow rate mode on a reserve
    * @param _reserve the address of the reserve
    **/
    function disableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isStableBorrowRateEnabled = false;
    }

    /**
    * @dev activates a reserve
    * @param _reserve the address of the reserve
    **/
    function activateReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        require(
            reserve.lastLiquidityCumulativeIndex > 0 &&
            reserve.lastVariableBorrowCumulativeIndex > 0,
            "Reserve has not been initialized yet"
        );
        reserve.isActive = true;
    }

    /**
    * @dev deactivates a reserve
    * @param _reserve the address of the reserve
    **/
    function deactivateReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isActive = false;
    }

    /**
    * @notice allows the configurator to freeze the reserve.
    * A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance.
    * @param _reserve the address of the reserve
    **/
    function freezeReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isFreezed = true;
    }

    /**
    * @notice allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed.
    * @param _reserve the address of the reserve
    **/
    function unfreezeReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isFreezed = false;
    }

    /**
    * @notice allows the configurator to update the loan to value of a reserve
    * @param _reserve the address of the reserve
    * @param _ltv the new loan to value
    **/
    function setReserveBaseLTVasCollateral(address _reserve, uint256 _ltv)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.baseLTVasCollateral = _ltv;
    }

    /**
    * @notice allows the configurator to update the liquidation threshold of a reserve
    * @param _reserve the address of the reserve
    * @param _threshold the new liquidation threshold
    **/
    function setReserveLiquidationThreshold(address _reserve, uint256 _threshold)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.liquidationThreshold = _threshold;
    }

    /**
    * @notice allows the configurator to update the liquidation bonus of a reserve
    * @param _reserve the address of the reserve
    * @param _bonus the new liquidation bonus
    **/
    function setReserveLiquidationBonus(address _reserve, uint256 _bonus)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.liquidationBonus = _bonus;
    }

    /**
    * @notice allows the configurator to update the reserve decimals
    * @param _reserve the address of the reserve
    * @param _decimals the decimals of the reserve
    **/
    function setReserveDecimals(address _reserve, uint256 _decimals)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.decimals = _decimals;
    }

    /**
    * @notice internal functions
    **/

    /**
    * @dev updates the state of a reserve as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the previous borrow balance of the borrower before the action
    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount
    * @param _amountBorrowed the new amount borrowed
    * @param _rateMode the borrow rate mode (stable, variable)
    **/

    function updateReserveStateOnBorrowInternal(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _balanceIncrease,
        uint256 _amountBorrowed,
        CoreLibrary.InterestRateMode _rateMode
    ) internal {
        reserves[_reserve].updateCumulativeIndexes();

        //increasing reserve total borrows to account for the new borrow balance of the user
        //NOTE: Depending on the previous borrow mode, the borrows might need to be switched from variable to stable or vice versa

        updateReserveTotalBorrowsByRateModeInternal(
            _reserve,
            _user,
            _principalBorrowBalance,
            _balanceIncrease,
            _amountBorrowed,
            _rateMode
        );
    }

    /**
    * @dev updates the state of a user as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _amountBorrowed the amount borrowed
    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount
    * @param _rateMode the borrow rate mode (stable, variable)
    * @return the final borrow rate for the user. Emitted by the borrow() event
    **/

    function updateUserStateOnBorrowInternal(
        address _reserve,
        address _user,
        uint256 _amountBorrowed,
        uint256 _balanceIncrease,
        uint256 _fee,
        CoreLibrary.InterestRateMode _rateMode
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (_rateMode == CoreLibrary.InterestRateMode.STABLE) {
            //stable
            //reset the user variable index, and update the stable rate
            user.stableBorrowRate = reserve.currentStableBorrowRate;
            user.lastVariableBorrowCumulativeIndex = 0;
        } else if (_rateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //variable
            //reset the user stable rate, and store the new borrow index
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        } else {
            revert("Invalid borrow rate mode");
        }
        //increase the principal borrows and the origination fee
        user.principalBorrowBalance = user.principalBorrowBalance.add(_amountBorrowed).add(
            _balanceIncrease
        );
        user.originationFee = user.originationFee.add(_fee);

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

    }

    /**
    * @dev updates the state of the reserve as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateReserveStateOnRepayInternal(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_reserve][_user];

        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(_reserve, _user);

        //update the indexes
        reserves[_reserve].updateCumulativeIndexes();

        //compound the cumulated interest to the borrow balance and then subtracting the payback amount
        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _balanceIncrease,
                user.stableBorrowRate
            );
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _paybackAmountMinusFees,
                user.stableBorrowRate
            );
        } else {
            reserve.increaseTotalBorrowsVariable(_balanceIncrease);
            reserve.decreaseTotalBorrowsVariable(_paybackAmountMinusFees);
        }
    }

    /**
    * @dev updates the state of the user as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _originationFeeRepaid the fee on the amount that is being repaid
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _repaidWholeLoan true if the user is repaying the whole loan
    **/
    function updateUserStateOnRepayInternal(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _originationFeeRepaid,
        uint256 _balanceIncrease,
        bool _repaidWholeLoan
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        //update the user principal borrow balance, adding the cumulated interest and then subtracting the payback amount
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(
            _paybackAmountMinusFees
        );
        user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;

        //if the balance decrease is equal to the previous principal (user is repaying the whole loan)
        //and the rate mode is stable, we reset the interest rate mode of the user
        if (_repaidWholeLoan) {
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = 0;
        }
        user.originationFee = user.originationFee.sub(_originationFeeRepaid);

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

    }

    /**
    * @dev updates the state of the user as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is performing the rate swap
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the the principal amount borrowed by the user
    * @param _compoundedBorrowBalance the principal amount plus the accrued interest
    * @param _currentRateMode the rate mode at which the user borrowed
    **/
    function updateReserveStateOnSwapRateInternal(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _compoundedBorrowBalance,
        CoreLibrary.InterestRateMode _currentRateMode
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        //compounding reserve indexes
        reserve.updateCumulativeIndexes();

        if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {
            uint256 userCurrentStableRate = user.stableBorrowRate;

            //swap to variable
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _principalBorrowBalance,
                userCurrentStableRate
            ); //decreasing stable from old principal balance
            reserve.increaseTotalBorrowsVariable(_compoundedBorrowBalance); //increase variable borrows
        } else if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //swap to stable
            uint256 currentStableRate = reserve.currentStableBorrowRate;
            reserve.decreaseTotalBorrowsVariable(_principalBorrowBalance);
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _compoundedBorrowBalance,
                currentStableRate
            );

        } else {
            revert("Invalid rate mode received");
        }
    }

    /**
    * @dev updates the state of the user as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is performing the swap
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _currentRateMode the current rate mode of the user
    **/

    function updateUserStateOnSwapRateInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease,
        CoreLibrary.InterestRateMode _currentRateMode
    ) internal returns (CoreLibrary.InterestRateMode) {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        CoreLibrary.InterestRateMode newMode = CoreLibrary.InterestRateMode.NONE;

        if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //switch to stable
            newMode = CoreLibrary.InterestRateMode.STABLE;
            user.stableBorrowRate = reserve.currentStableBorrowRate;
            user.lastVariableBorrowCumulativeIndex = 0;
        } else if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {
            newMode = CoreLibrary.InterestRateMode.VARIABLE;
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        } else {
            revert("Invalid interest rate mode received");
        }
        //compounding cumulated interest
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);
        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

        return newMode;
    }

    /**
    * @dev updates the state of the principal reserve as a consequence of a liquidation action.
    * @param _principalReserve the address of the principal reserve that is being repaid
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updatePrincipalReserveStateOnLiquidationInternal(
        address _principalReserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_principalReserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_principalReserve];

        //update principal reserve data
        reserve.updateCumulativeIndexes();

        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(
            _principalReserve,
            _user
        );

        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            //increase the total borrows by the compounded interest
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _balanceIncrease,
                user.stableBorrowRate
            );

            //decrease by the actual amount to liquidate
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _amountToLiquidate,
                user.stableBorrowRate
            );

        } else {
            //increase the total borrows by the compounded interest
            reserve.increaseTotalBorrowsVariable(_balanceIncrease);

            //decrease by the actual amount to liquidate
            reserve.decreaseTotalBorrowsVariable(_amountToLiquidate);
        }

    }

    /**
    * @dev updates the state of the collateral reserve as a consequence of a liquidation action.
    * @param _collateralReserve the address of the collateral reserve that is being liquidated
    **/
    function updateCollateralReserveStateOnLiquidationInternal(
        address _collateralReserve
    ) internal {
        //update collateral reserve
        reserves[_collateralReserve].updateCumulativeIndexes();

    }

    /**
    * @dev updates the state of the user being liquidated as a consequence of a liquidation action.
    * @param _reserve the address of the principal reserve that is being repaid
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _feeLiquidated the amount of origination fee being liquidated
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/
    function updateUserStateOnLiquidationInternal(
        address _reserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _feeLiquidated,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        //first increase by the compounded interest, then decrease by the liquidated amount
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(
            _amountToLiquidate
        );

        if (
            getUserCurrentBorrowRateMode(_reserve, _user) == CoreLibrary.InterestRateMode.VARIABLE
        ) {
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        }

        if(_feeLiquidated > 0){
            user.originationFee = user.originationFee.sub(_feeLiquidated);
        }

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);
    }

    /**
    * @dev updates the state of the reserve as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateReserveStateOnRebalanceInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        reserve.updateCumulativeIndexes();

        reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
            _balanceIncrease,
            user.stableBorrowRate
        );

    }

    /**
    * @dev updates the state of the user as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateUserStateOnRebalanceInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);
        user.stableBorrowRate = reserve.currentStableBorrowRate;

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);
    }

    /**
    * @dev updates the state of the user as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _amountBorrowed the accrued interest on the borrowed amount
    **/
    function updateReserveTotalBorrowsByRateModeInternal(
        address _reserve,
        address _user,
        uint256 _principalBalance,
        uint256 _balanceIncrease,
        uint256 _amountBorrowed,
        CoreLibrary.InterestRateMode _newBorrowRateMode
    ) internal {
        CoreLibrary.InterestRateMode previousRateMode = getUserCurrentBorrowRateMode(
            _reserve,
            _user
        );
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        if (previousRateMode == CoreLibrary.InterestRateMode.STABLE) {
            CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _principalBalance,
                user.stableBorrowRate
            );
        } else if (previousRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            reserve.decreaseTotalBorrowsVariable(_principalBalance);
        }

        uint256 newPrincipalAmount = _principalBalance.add(_balanceIncrease).add(_amountBorrowed);
        if (_newBorrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                newPrincipalAmount,
                reserve.currentStableBorrowRate
            );
        } else if (_newBorrowRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            reserve.increaseTotalBorrowsVariable(newPrincipalAmount);
        } else {
            revert("Invalid new borrow rate mode");
        }
    }

    /**
    * @dev Updates the reserve current stable borrow rate Rf, the current variable borrow rate Rv and the current liquidity rate Rl.
    * Also updates the lastUpdateTimestamp value. Please refer to the whitepaper for further information.
    * @param _reserve the address of the reserve to be updated
    * @param _liquidityAdded the amount of liquidity added to the protocol (deposit or repay) in the previous action
    * @param _liquidityTaken the amount of liquidity taken from the protocol (redeem or borrow)
    **/

    function updateReserveInterestRatesAndTimestampInternal(
        address _reserve,
        uint256 _liquidityAdded,
        uint256 _liquidityTaken
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        (uint256 newLiquidityRate, uint256 newStableRate, uint256 newVariableRate) = IReserveInterestRateStrategy(
            reserve
            .interestRateStrategyAddress
        )
        .calculateInterestRates(
            _reserve,
            getReserveAvailableLiquidity(_reserve).add(_liquidityAdded).sub(_liquidityTaken),
            reserve.totalBorrowsStable,
            reserve.totalBorrowsVariable,
            reserve.currentAverageStableBorrowRate
        );

        reserve.currentLiquidityRate = newLiquidityRate;
        reserve.currentStableBorrowRate = newStableRate;
        reserve.currentVariableBorrowRate = newVariableRate;

        //solium-disable-next-line
        reserve.lastUpdateTimestamp = uint40(block.timestamp);

        emit ReserveUpdated(
            _reserve,
            newLiquidityRate,
            newStableRate,
            newVariableRate,
            reserve.lastLiquidityCumulativeIndex,
            reserve.lastVariableBorrowCumulativeIndex
        );
    }

    /**
    * @dev transfers to the protocol fees of a flashloan to the fees collection address
    * @param _token the address of the token being transferred
    * @param _amount the amount being transferred
    **/

    function transferFlashLoanProtocolFeeInternal(address _token, uint256 _amount) internal {
        address payable receiver = address(uint160(addressesProvider.getTokenDistributor()));

        if (_token != EthAddressLib.ethAddress()) {
            ERC20(_token).safeTransfer(receiver, _amount);
        } else {
            receiver.transfer(_amount);
        }
    }

    /**
    * @dev updates the internal configuration of the core
    **/
    function refreshConfigInternal() internal {
        lendingPoolAddress = addressesProvider.getLendingPool();
    }

    /**
    * @dev adds a reserve to the array of the reserves address
    **/
    function addReserveToListInternal(address _reserve) internal {
        bool reserveAlreadyAdded = false;
        for (uint256 i = 0; i < reservesList.length; i++)
            if (reservesList[i] == _reserve) {
                reserveAlreadyAdded = true;
            }
        if (!reserveAlreadyAdded) reservesList.push(_reserve);
    }

}
.]

###

[2024-01-09 04:32:00 INFO] **[Seminar Conclusion]**:

 ###

[2024-01-09 04:32:00 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 3

[2024-01-09 04:32:00 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | pragma solidity ^0.5.0; import "openzeppelin-solidity/contracts/math/SafeMath.sol"; import "openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol"; import "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol"; import "openzeppelin-solidity/contracts/utils/Address.sol"; import "../libraries/openzeppelin-upgradeability/VersionedInitializable.sol"; import "../libraries/CoreLibrary.sol"; import "../configuration/LendingPoolAddressesProvider.sol"; import "../interfaces/ILendingRateOracle.sol"; import "../interfaces/IReserveInterestRateStrategy.sol"; import "../libraries/WadRayMath.sol"; import "../tokenization/AToken.sol"; import "../libraries/EthAddressLib.sol"; / * @title LendingPoolCore contract * @author Aave * @notice Holds the state of the lending pool and all the funds deposited * @dev NOTE: The core does not enforce security checks on the update of the state * (eg, updateStateOnBorrow() does not enforce that borrowed is enabled on the reserve). * The check that an action can be performed is a duty of the overlying LendingPool contract. / contract LendingPoolCore is VersionedInitializable {     using SafeMath for uint256;     using WadRayMath for uint256;     using CoreLibrary for CoreLibrary.ReserveData;     using CoreLibrary for CoreLibrary.UserReserveData;     using SafeERC20 for ERC20;     using Address for address payable; /** * @dev Emitted when the state of a reserve is updated * @param reserve the address of the reserve * @param liquidityRate the new liquidity rate * @param stableBorrowRate the new stable borrow rate * @param variableBorrowRate the new variable borrow rate * @param liquidityIndex the new liquidity index * @param variableBorrowIndex the new variable borrow index **/ event ReserveUpdated(     address indexed reserve,     uint256 liquidityRate,     uint256 stableBorrowRate,     uint256 variableBorrowRate,     uint256 liquidityIndex,     uint256 variableBorrowIndex );  address public lendingPoolAddress;  LendingPoolAddressesProvider public addressesProvider;  /** * @dev only lending pools can use functions affected by this modifier **/ modifier onlyLendingPool {     require(lendingPoolAddress == msg.sender, "The caller must be a lending pool contract");     _; }  /** * @dev only lending pools configurator can use functions affected by this modifier **/ modifier onlyLendingPoolConfigurator {     require(         addressesProvider.getLendingPoolConfigurator() == msg.sender,         "The caller must be a lending pool configurator contract"     );     _; }  mapping(address =&gt; CoreLibrary.ReserveData) internal reserves; mapping(address =&gt; mapping(address =&gt; CoreLibrary.UserReserveData)) internal usersReserveData;  address[] public reservesList;  uint256 public constant CORE_REVISION = 0x4;  /** * @dev returns the revision number of the contract **/ function getRevision() internal pure returns (uint256) {     return CORE_REVISION; }  /** * @dev initializes the Core contract, invoked upon registration on the AddressesProvider * @param _addressesProvider the addressesProvider contract **/  function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {     addressesProvider = _addressesProvider;     refreshConfigInternal(); }  /** * @dev updates the state of the core as a result of a deposit action * @param _reserve the address of the reserve in which the deposit is happening * @param _user the address of the the user depositing * @param _amount the amount being deposited * @param _isFirstDeposit true if the user is depositing for the first time **/  function updateStateOnDeposit(     address _reserve,     address _user,     uint256 _amount,     bool _isFirstDeposit ) external onlyLendingPool {     reserves[_reserve].updateCumulativeIndexes();     updateReserveInterestRatesAndTimestampInternal(_reserve, _amount, 0);      if (_isFirstDeposit) {         //if this is the first deposit of the user, we configure the deposit as enabled to be used as collateral         setUserUseReserveAsCollateral(_reserve, _user, true);     } }  /** * @dev updates the state of the core as a result of a redeem action * @param _reserve the address of the reserve in which the redeem is happening * @param _user the address of the the user redeeming * @param _amountRedeemed the amount being redeemed * @param _userRedeemedEverything true if the user is redeeming everything **/ function updateStateOnRedeem(     address _reserve,     address _user,     uint256 _amountRedeemed,     bool _userRedeemedEverything ) external onlyLendingPool {     //compound liquidity and variable borrow interests     reserves[_reserve].updateCumulativeIndexes();     updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountRedeemed);      //if user redeemed everything the useReserveAsCollateral flag is reset     if (_userRedeemedEverything) {         setUserUseReserveAsCollateral(_reserve, _user, false);     } }  /** * @dev updates the state of the core as a result of a flashloan action * @param _reserve the address of the reserve in which the flashloan is happening * @param _income the income of the protocol as a result of the action **/ function updateStateOnFlashLoan(     address _reserve,     uint256 _availableLiquidityBefore,     uint256 _income,     uint256 _protocolFee ) external onlyLendingPool {     transferFlashLoanProtocolFeeInternal(_reserve, _protocolFee);      //compounding the cumulated interest     reserves[_reserve].updateCumulativeIndexes();      uint256 totalLiquidityBefore = _availableLiquidityBefore.add(         getReserveTotalBorrows(_reserve)     );      //compounding the received fee into the reserve     reserves[_reserve].cumulateToLiquidityIndex(totalLiquidityBefore, _income);      //refresh interest rates     updateReserveInterestRatesAndTimestampInternal(_reserve, _income, 0); }  /** * @dev updates the state of the core as a consequence of a borrow action. * @param _reserve the address of the reserve on which the user is borrowing * @param _user the address of the borrower * @param _amountBorrowed the new amount borrowed * @param _borrowFee the fee on the amount borrowed * @param _rateMode the borrow rate mode (stable, variable) * @return the new borrow rate for the user **/ function updateStateOnBorrow(     address _reserve,     address _user,     uint256 _amountBorrowed,     uint256 _borrowFee,     CoreLibrary.InterestRateMode _rateMode ) external onlyLendingPool returns (uint256, uint256) {     // getting the previous borrow data of the user     (uint256 principalBorrowBalance, , uint256 balanceIncrease) = getUserBorrowBalances(         _reserve,         _user     );      updateReserveStateOnBorrowInternal(         _reserve,         _user,         principalBorrowBalance,         balanceIncrease,         _amountBorrowed,         _rateMode     );      updateUserStateOnBorrowInternal(         _reserve,         _user,         _amountBorrowed,         balanceIncrease,         _borrowFee,         _rateMode     );      updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountBorrowed);      return (getUserCurrentBorrowRate(_reserve, _user), balanceIncrease); }  /** * @dev updates the state of the core as a consequence of a repay action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _paybackAmountMinusFees the amount being paid back minus fees * @param _originationFeeRepaid the fee on the amount that is being repaid * @param _balanceIncrease the accrued interest on the borrowed amount * @param _repaidWholeLoan true if the user is repaying the whole loan **/  function updateStateOnRepay(     address _reserve,     address _user,     uint256 _paybackAmountMinusFees,     uint256 _originationFeeRepaid,     uint256 _balanceIncrease,     bool _repaidWholeLoan ) external onlyLendingPool {     updateReserveStateOnRepayInternal(         _reserve,         _user,         _paybackAmountMinusFees,         _balanceIncrease     );     updateUserStateOnRepayInternal(         _reserve,         _user,         _paybackAmountMinusFees,         _originationFeeRepaid,         _balanceIncrease,         _repaidWholeLoan     );      updateReserveInterestRatesAndTimestampInternal(_reserve, _paybackAmountMinusFees, 0); }  /** * @dev updates the state of the core as a consequence of a swap rate action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _principalBorrowBalance the amount borrowed by the user * @param _compoundedBorrowBalance the amount borrowed plus accrued interest * @param _balanceIncrease the accrued interest on the borrowed amount * @param _currentRateMode the current interest rate mode for the user **/ function updateStateOnSwapRate(     address _reserve,     address _user,     uint256 _principalBorrowBalance,     uint256 _compoundedBorrowBalance,     uint256 _balanceIncrease,     CoreLibrary.InterestRateMode _currentRateMode ) external onlyLendingPool returns (CoreLibrary.InterestRateMode, uint256) {     updateReserveStateOnSwapRateInternal(         _reserve,         _user,         _principalBorrowBalance,         _compoundedBorrowBalance,         _currentRateMode     );      CoreLibrary.InterestRateMode newRateMode = updateUserStateOnSwapRateInternal(         _reserve,         _user,         _balanceIncrease,         _currentRateMode     );      updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);      return (newRateMode, getUserCurrentBorrowRate(_reserve, _user)); }  /** * @dev updates the state of the core as a consequence of a liquidation action. * @param _principalReserve the address of the principal reserve that is being repaid * @param _collateralReserve the address of the collateral reserve that is being liquidated * @param _user the address of the borrower * @param _amountToLiquidate the amount being repaid by the liquidator * @param _collateralToLiquidate the amount of collateral being liquidated * @param _feeLiquidated the amount of origination fee being liquidated * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus * @param _balanceIncrease the accrued interest on the borrowed amount * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise **/ function updateStateOnLiquidation(     address _principalReserve,     address _collateralReserve,     address _user,     uint256 _amountToLiquidate,     uint256 _collateralToLiquidate,     uint256 _feeLiquidated,     uint256 _liquidatedCollateralForFee,     uint256 _balanceIncrease,     bool _liquidatorReceivesAToken ) external onlyLendingPool {     updatePrincipalReserveStateOnLiquidationInternal(         _principalReserve,         _user,         _amountToLiquidate,         _balanceIncrease     );      updateCollateralReserveStateOnLiquidationInternal(         _collateralReserve     );      updateUserStateOnLiquidationInternal(         _principalReserve,         _user,         _amountToLiquidate,         _feeLiquidated,         _balanceIncrease     );      updateReserveInterestRatesAndTimestampInternal(_principalReserve, _amountToLiquidate, 0);      if (!_liquidatorReceivesAToken) {         updateReserveInterestRatesAndTimestampInternal(             _collateralReserve,             0,             _collateralToLiquidate.add(_liquidatedCollateralForFee)         );     }  }  /** * @dev updates the state of the core as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount * @return the new stable rate for the user **/ function updateStateOnRebalance(address _reserve, address _user, uint256 _balanceIncrease) external onlyLendingPool returns (uint256) {     updateReserveStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);      //update user data and rebalance the rate     updateUserStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);     updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);     return usersReserveData[_user][_reserve].stableBorrowRate; }  /** * @dev enables or disables a reserve as collateral * @param _reserve the address of the principal reserve where the user deposited * @param _user the address of the depositor * @param _useAsCollateral true if the depositor wants to use the reserve as collateral **/ function setUserUseReserveAsCollateral(address _reserve, address _user, bool _useAsCollateral) public onlyLendingPool {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     user.useAsCollateral = _useAsCollateral; }  /** * @notice ETH/token transfer functions **/  /** * @dev fallback function enforces that the caller is a contract, to support flashloan transfers **/ function() external payable {     //only contracts can send ETH to the core     require(msg.sender.isContract(), "Only contracts can send ether to the Lending pool core");  }  /** * @dev transfers to the user a specific amount from the reserve. * @param _reserve the address of the reserve where the transfer is happening * @param _user the address of the user receiving the transfer * @param _amount the amount being transferred **/ function transferToUser(address _reserve, address payable _user, uint256 _amount) external onlyLendingPool {     if (_reserve != EthAddressLib.ethAddress()) {         ERC20(_reserve).safeTransfer(_user, _amount);     } else {         //solium-disable-next-line         (bool result, ) = _user.call.value(_amount).gas(50000)("");         require(result, "Transfer of ETH failed");     } }  /** * @dev transfers the protocol fees to the fees collection address * @param _token the address of the token being transferred * @param _user the address of the user from where the transfer is happening * @param _amount the amount being transferred * @param _destination the fee receiver address **/  function transferToFeeCollectionAddress(     address _token,     address _user,     uint256 _amount,     address _destination ) external payable onlyLendingPool {     address payable feeAddress = address(uint160(_destination)); //cast the address to payable      if (_token != EthAddressLib.ethAddress()) {         require(             msg.value == 0,             "User is sending ETH along with the ERC20 transfer. Check the value attribute of the transaction"         );         ERC20(_token).safeTransferFrom(_user, feeAddress, _amount);     } else {         require(msg.value &gt;= _amount, "The amount and the value sent to deposit do not match");         //solium-disable-next-line         (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");         require(result, "Transfer of ETH failed");     } }  /** * @dev transfers the fees to the fees collection address in the case of liquidation * @param _token the address of the token being transferred * @param _amount the amount being transferred * @param _destination the fee receiver address **/ function liquidateFee(     address _token,     uint256 _amount,     address _destination ) external payable onlyLendingPool {     address payable feeAddress = address(uint160(_destination)); //cast the address to payable     require(         msg.value == 0,         "Fee liquidation does not require any transfer of value"     );      if (_token != EthAddressLib.ethAddress()) {         ERC20(_token).safeTransfer(feeAddress, _amount);     } else {         //solium-disable-next-line         (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");         require(result, "Transfer of ETH failed");     } }  /** * @dev transfers an amount from a user to the destination reserve * @param _reserve the address of the reserve where the amount is being transferred * @param _user the address of the user from where the transfer is happening * @param _amount the amount being transferred **/ function transferToReserve(address _reserve, address payable _user, uint256 _amount) external payable onlyLendingPool {     if (_reserve != EthAddressLib.ethAddress()) {         require(msg.value == 0, "User is sending ETH along with the ERC20 transfer.");         ERC20(_reserve).safeTransferFrom(_user, address(this), _amount);      } else {         require(msg.value &gt;= _amount, "The amount and the value sent to deposit do not match");          if (msg.value &gt; _amount) {             //send back excess ETH             uint256 excessAmount = msg.value.sub(_amount);             //solium-disable-next-line             (bool result, ) = _user.call.value(excessAmount).gas(50000)("");             require(result, "Transfer of ETH failed");         }     } }  /** * @notice data access functions **/  /** * @dev returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral) * needed to calculate the global account data in the LendingPoolDataProvider * @param _reserve the address of the reserve * @param _user the address of the user * @return the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not **/ function getUserBasicReserveData(address _reserve, address _user) external view returns (uint256, uint256, uint256, bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      uint256 underlyingBalance = getUserUnderlyingAssetBalance(_reserve, _user);      if (user.principalBorrowBalance == 0) {         return (underlyingBalance, 0, 0, user.useAsCollateral);     }      return (     underlyingBalance,     user.getCompoundedBorrowBalance(reserve),     user.originationFee,     user.useAsCollateral     ); }  /** * @dev checks if a user is allowed to borrow at a stable rate * @param _reserve the reserve address * @param _user the user * @param _amount the amount the the user wants to borrow * @return true if the user is allowed to borrow at a stable rate, false otherwise **/  function isUserAllowedToBorrowAtStable(address _reserve, address _user, uint256 _amount) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      if (!reserve.isStableBorrowRateEnabled) return false;      return     !user.useAsCollateral ||     !reserve.usageAsCollateralEnabled ||     _amount &gt; getUserUnderlyingAssetBalance(_reserve, _user); }  /** * @dev gets the underlying asset balance of a user based on the corresponding aToken balance. * @param _reserve the reserve address * @param _user the user address * @return the underlying deposit balance of the user **/  function getUserUnderlyingAssetBalance(address _reserve, address _user) public view returns (uint256) {     AToken aToken = AToken(reserves[_reserve].aTokenAddress);     return aToken.balanceOf(_user);  }  /** * @dev gets the interest rate strategy contract address for the reserve * @param _reserve the reserve address * @return the address of the interest rate strategy contract **/ function getReserveInterestRateStrategyAddress(address _reserve) public view returns (address) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.interestRateStrategyAddress; }  /** * @dev gets the aToken contract address for the reserve * @param _reserve the reserve address * @return the address of the aToken contract **/  function getReserveATokenAddress(address _reserve) public view returns (address) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.aTokenAddress; }  /** * @dev gets the available liquidity in the reserve. The available liquidity is the balance of the core contract * @param _reserve the reserve address * @return the available liquidity **/ function getReserveAvailableLiquidity(address _reserve) public view returns (uint256) {     uint256 balance = 0;      if (_reserve == EthAddressLib.ethAddress()) {         balance = address(this).balance;     } else {         balance = IERC20(_reserve).balanceOf(address(this));     }     return balance; }  /** * @dev gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows * @param _reserve the reserve address * @return the total liquidity **/ function getReserveTotalLiquidity(address _reserve) public view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return getReserveAvailableLiquidity(_reserve).add(reserve.getTotalBorrows()); }  /** * @dev gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there * there has been 100% income. * @param _reserve the reserve address * @return the reserve normalized income **/ function getReserveNormalizedIncome(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.getNormalizedIncome(); }  /** * @dev gets the reserve total borrows * @param _reserve the reserve address * @return the total borrows (stable + variable) **/ function getReserveTotalBorrows(address _reserve) public view returns (uint256) {     return reserves[_reserve].getTotalBorrows(); }  /** * @dev gets the reserve total borrows stable * @param _reserve the reserve address * @return the total borrows stable **/ function getReserveTotalBorrowsStable(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.totalBorrowsStable; }  /** * @dev gets the reserve total borrows variable * @param _reserve the reserve address * @return the total borrows variable **/  function getReserveTotalBorrowsVariable(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.totalBorrowsVariable; }  /** * @dev gets the reserve liquidation threshold * @param _reserve the reserve address * @return the reserve liquidation threshold **/  function getReserveLiquidationThreshold(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.liquidationThreshold; }  /** * @dev gets the reserve liquidation bonus * @param _reserve the reserve address * @return the reserve liquidation bonus **/  function getReserveLiquidationBonus(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.liquidationBonus; }  /** * @dev gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty * @param _reserve the reserve address * @return the reserve current variable borrow rate **/  function getReserveCurrentVariableBorrowRate(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      if (reserve.currentVariableBorrowRate == 0) {         return         IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)         .getBaseVariableBorrowRate();     }     return reserve.currentVariableBorrowRate; }  /** * @dev gets the reserve current stable borrow rate. Is the market rate if the reserve is empty * @param _reserve the reserve address * @return the reserve current stable borrow rate **/  function getReserveCurrentStableBorrowRate(address _reserve) public view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     ILendingRateOracle oracle = ILendingRateOracle(addressesProvider.getLendingRateOracle());      if (reserve.currentStableBorrowRate == 0) {         //no stable rate borrows yet         return oracle.getMarketBorrowRate(_reserve);     }      return reserve.currentStableBorrowRate; }  /** * @dev gets the reserve average stable borrow rate. The average stable rate is the weighted average * of all the loans taken at stable rate. * @param _reserve the reserve address * @return the reserve current average borrow rate **/ function getReserveCurrentAverageStableBorrowRate(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.currentAverageStableBorrowRate; }  /** * @dev gets the reserve liquidity rate * @param _reserve the reserve address * @return the reserve liquidity rate **/ function getReserveCurrentLiquidityRate(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.currentLiquidityRate; }  /** * @dev gets the reserve liquidity cumulative index * @param _reserve the reserve address * @return the reserve liquidity cumulative index **/ function getReserveLiquidityCumulativeIndex(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.lastLiquidityCumulativeIndex; }  /** * @dev gets the reserve variable borrow index * @param _reserve the reserve address * @return the reserve variable borrow index **/ function getReserveVariableBorrowsCumulativeIndex(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.lastVariableBorrowCumulativeIndex; }  /** * @dev this function aggregates the configuration parameters of the reserve. * It's used in the LendingPoolDataProvider specifically to save gas, and avoid * multiple external contract calls to fetch the same data. * @param _reserve the reserve address * @return the reserve decimals * @return the base ltv as collateral * @return the liquidation threshold * @return if the reserve is used as collateral or not **/ function getReserveConfiguration(address _reserve) external view returns (uint256, uint256, uint256, bool) {     uint256 decimals;     uint256 baseLTVasCollateral;     uint256 liquidationThreshold;     bool usageAsCollateralEnabled;      CoreLibrary.ReserveData storage reserve = reserves[_reserve];     decimals = reserve.decimals;     baseLTVasCollateral = reserve.baseLTVasCollateral;     liquidationThreshold = reserve.liquidationThreshold;     usageAsCollateralEnabled = reserve.usageAsCollateralEnabled;      return (decimals, baseLTVasCollateral, liquidationThreshold, usageAsCollateralEnabled); }  /** * @dev returns the decimals of the reserve * @param _reserve the reserve address * @return the reserve decimals **/ function getReserveDecimals(address _reserve) external view returns (uint256) {     return reserves[_reserve].decimals; }  /** * @dev returns true if the reserve is enabled for borrowing * @param _reserve the reserve address * @return true if the reserve is enabled for borrowing, false otherwise **/  function isReserveBorrowingEnabled(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.borrowingEnabled; }  /** * @dev returns true if the reserve is enabled as collateral * @param _reserve the reserve address * @return true if the reserve is enabled as collateral, false otherwise **/  function isReserveUsageAsCollateralEnabled(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.usageAsCollateralEnabled; }  /** * @dev returns true if the stable rate is enabled on reserve * @param _reserve the reserve address * @return true if the stable rate is enabled on reserve, false otherwise **/ function getReserveIsStableBorrowRateEnabled(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.isStableBorrowRateEnabled; }  /** * @dev returns true if the reserve is active * @param _reserve the reserve address * @return true if the reserve is active, false otherwise **/ function getReserveIsActive(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.isActive; }  /** * @notice returns if a reserve is freezed * @param _reserve the reserve for which the information is needed * @return true if the reserve is freezed, false otherwise **/  function getReserveIsFreezed(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.isFreezed; }  /** * @notice returns the timestamp of the last action on the reserve * @param _reserve the reserve for which the information is needed * @return the last updated timestamp of the reserve **/  function getReserveLastUpdate(address _reserve) external view returns (uint40 timestamp) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     timestamp = reserve.lastUpdateTimestamp; }  /** * @dev returns the utilization rate U of a specific reserve * @param _reserve the reserve for which the information is needed * @return the utilization rate in ray **/  function getReserveUtilizationRate(address _reserve) public view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      uint256 totalBorrows = reserve.getTotalBorrows();      if (totalBorrows == 0) {         return 0;     }      uint256 availableLiquidity = getReserveAvailableLiquidity(_reserve);      return totalBorrows.rayDiv(availableLiquidity.add(totalBorrows)); }  /** * @return the array of reserves configured on the core **/ function getReserves() external view returns (address[] memory) {     return reservesList; }  /** * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return true if the user has chosen to use the reserve as collateral, false otherwise **/ function isUserUseReserveAsCollateralEnabled(address _reserve, address _user) external view returns (bool) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.useAsCollateral; }  /** * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the origination fee for the user **/ function getUserOriginationFee(address _reserve, address _user) external view returns (uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.originationFee; }  /** * @dev users with no loans in progress have NONE as borrow rate mode * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the borrow rate mode for the user, **/  function getUserCurrentBorrowRateMode(address _reserve, address _user) public view returns (CoreLibrary.InterestRateMode) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      if (user.principalBorrowBalance == 0) {         return CoreLibrary.InterestRateMode.NONE;     }      return     user.stableBorrowRate &gt; 0     ? CoreLibrary.InterestRateMode.STABLE     : CoreLibrary.InterestRateMode.VARIABLE; }  /** * @dev gets the current borrow rate of the user * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the borrow rate for the user, **/ function getUserCurrentBorrowRate(address _reserve, address _user) internal view returns (uint256) {     CoreLibrary.InterestRateMode rateMode = getUserCurrentBorrowRateMode(_reserve, _user);      if (rateMode == CoreLibrary.InterestRateMode.NONE) {         return 0;     }      return     rateMode == CoreLibrary.InterestRateMode.STABLE     ? usersReserveData[_user][_reserve].stableBorrowRate     : reserves[_reserve].currentVariableBorrowRate; }  /** * @dev the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the user stable rate **/ function getUserCurrentStableBorrowRate(address _reserve, address _user) external view returns (uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.stableBorrowRate; }  /** * @dev calculates and returns the borrow balances of the user * @param _reserve the address of the reserve * @param _user the address of the user * @return the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance **/  function getUserBorrowBalances(address _reserve, address _user) public view returns (uint256, uint256, uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     if (user.principalBorrowBalance == 0) {         return (0, 0, 0);     }      uint256 principal = user.principalBorrowBalance;     uint256 compoundedBalance = CoreLibrary.getCompoundedBorrowBalance(         user,         reserves[_reserve]     );     return (principal, compoundedBalance, compoundedBalance.sub(principal)); }  /** * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the variable borrow index for the user **/  function getUserVariableBorrowCumulativeIndex(address _reserve, address _user) external view returns (uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.lastVariableBorrowCumulativeIndex; }  /** * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the variable borrow index for the user **/  function getUserLastUpdate(address _reserve, address _user) external view returns (uint256 timestamp) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     timestamp = user.lastUpdateTimestamp; }  /** * @dev updates the lending pool core configuration **/ function refreshConfiguration() external onlyLendingPoolConfigurator {     refreshConfigInternal(); }  /** * @dev initializes a reserve * @param _reserve the address of the reserve * @param _aTokenAddress the address of the overlying aToken contract * @param _decimals the decimals of the reserve currency * @param _interestRateStrategyAddress the address of the interest rate strategy contract **/ function initReserve(     address _reserve,     address _aTokenAddress,     uint256 _decimals,     address _interestRateStrategyAddress ) external onlyLendingPoolConfigurator {     reserves[_reserve].init(_aTokenAddress, _decimals, _interestRateStrategyAddress);     addReserveToListInternal(_reserve);  }    /** * @dev removes the last added reserve in the reservesList array * @param _reserveToRemove the address of the reserve **/ function removeLastAddedReserve(address _reserveToRemove) external onlyLendingPoolConfigurator {      address lastReserve = reservesList[reservesList.length-1];      require(lastReserve == _reserveToRemove, "Reserve being removed is different than the reserve requested");      //as we can't check if totalLiquidity is 0 (since the reserve added might not be an ERC20) we at least check that there is nothing borrowed     require(getReserveTotalBorrows(lastReserve) == 0, "Cannot remove a reserve with liquidity deposited");      reserves[lastReserve].isActive = false;     reserves[lastReserve].aTokenAddress = address(0);     reserves[lastReserve].decimals = 0;     reserves[lastReserve].lastLiquidityCumulativeIndex = 0;     reserves[lastReserve].lastVariableBorrowCumulativeIndex = 0;     reserves[lastReserve].borrowingEnabled = false;     reserves[lastReserve].usageAsCollateralEnabled = false;     reserves[lastReserve].baseLTVasCollateral = 0;     reserves[lastReserve].liquidationThreshold = 0;     reserves[lastReserve].liquidationBonus = 0;     reserves[lastReserve].interestRateStrategyAddress = address(0);      reservesList.pop(); }  /** * @dev updates the address of the interest rate strategy contract * @param _reserve the address of the reserve * @param _rateStrategyAddress the address of the interest rate strategy contract **/  function setReserveInterestRateStrategyAddress(address _reserve, address _rateStrategyAddress) external onlyLendingPoolConfigurator {     reserves[_reserve].interestRateStrategyAddress = _rateStrategyAddress; }  /** * @dev enables borrowing on a reserve. Also sets the stable rate borrowing * @param _reserve the address of the reserve * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise **/  function enableBorrowingOnReserve(address _reserve, bool _stableBorrowRateEnabled) external onlyLendingPoolConfigurator {     reserves[_reserve].enableBorrowing(_stableBorrowRateEnabled); }  /** * @dev disables borrowing on a reserve * @param _reserve the address of the reserve **/  function disableBorrowingOnReserve(address _reserve) external onlyLendingPoolConfigurator {     reserves[_reserve].disableBorrowing(); }  /** * @dev enables a reserve to be used as collateral * @param _reserve the address of the reserve **/ function enableReserveAsCollateral(     address _reserve,     uint256 _baseLTVasCollateral,     uint256 _liquidationThreshold,     uint256 _liquidationBonus ) external onlyLendingPoolConfigurator {     reserves[_reserve].enableAsCollateral(         _baseLTVasCollateral,         _liquidationThreshold,         _liquidationBonus     ); }  /** * @dev disables a reserve to be used as collateral * @param _reserve the address of the reserve **/ function disableReserveAsCollateral(address _reserve) external onlyLendingPoolConfigurator {     reserves[_reserve].disableAsCollateral(); }  /** * @dev enable the stable borrow rate mode on a reserve * @param _reserve the address of the reserve **/ function enableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isStableBorrowRateEnabled = true; }  /** * @dev disable the stable borrow rate mode on a reserve * @param _reserve the address of the reserve **/ function disableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isStableBorrowRateEnabled = false; }  /** * @dev activates a reserve * @param _reserve the address of the reserve **/ function activateReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      require(         reserve.lastLiquidityCumulativeIndex &gt; 0 &amp;&amp;         reserve.lastVariableBorrowCumulativeIndex &gt; 0,         "Reserve has not been initialized yet"     );     reserve.isActive = true; }  /** * @dev deactivates a reserve * @param _reserve the address of the reserve **/ function deactivateReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isActive = false; }  /** * @notice allows the configurator to freeze the reserve. * A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance. * @param _reserve the address of the reserve **/ function freezeReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isFreezed = true; }  /** * @notice allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed. * @param _reserve the address of the reserve **/ function unfreezeReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isFreezed = false; }  /** * @notice allows the configurator to update the loan to value of a reserve * @param _reserve the address of the reserve * @param _ltv the new loan to value **/ function setReserveBaseLTVasCollateral(address _reserve, uint256 _ltv) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.baseLTVasCollateral = _ltv; }  /** * @notice allows the configurator to update the liquidation threshold of a reserve * @param _reserve the address of the reserve * @param _threshold the new liquidation threshold **/ function setReserveLiquidationThreshold(address _reserve, uint256 _threshold) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.liquidationThreshold = _threshold; }  /** * @notice allows the configurator to update the liquidation bonus of a reserve * @param _reserve the address of the reserve * @param _bonus the new liquidation bonus **/ function setReserveLiquidationBonus(address _reserve, uint256 _bonus) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.liquidationBonus = _bonus; }  /** * @notice allows the configurator to update the reserve decimals * @param _reserve the address of the reserve * @param _decimals the decimals of the reserve **/ function setReserveDecimals(address _reserve, uint256 _decimals) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.decimals = _decimals; }  /** * @notice internal functions **/  /** * @dev updates the state of a reserve as a consequence of a borrow action. * @param _reserve the address of the reserve on which the user is borrowing * @param _user the address of the borrower * @param _principalBorrowBalance the previous borrow balance of the borrower before the action * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount * @param _amountBorrowed the new amount borrowed * @param _rateMode the borrow rate mode (stable, variable) **/  function updateReserveStateOnBorrowInternal(     address _reserve,     address _user,     uint256 _principalBorrowBalance,     uint256 _balanceIncrease,     uint256 _amountBorrowed,     CoreLibrary.InterestRateMode _rateMode ) internal {     reserves[_reserve].updateCumulativeIndexes();      //increasing reserve total borrows to account for the new borrow balance of the user     //NOTE: Depending on the previous borrow mode, the borrows might need to be switched from variable to stable or vice versa      updateReserveTotalBorrowsByRateModeInternal(         _reserve,         _user,         _principalBorrowBalance,         _balanceIncrease,         _amountBorrowed,         _rateMode     ); }  /** * @dev updates the state of a user as a consequence of a borrow action. * @param _reserve the address of the reserve on which the user is borrowing * @param _user the address of the borrower * @param _amountBorrowed the amount borrowed * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount * @param _rateMode the borrow rate mode (stable, variable) * @return the final borrow rate for the user. Emitted by the borrow() event **/  function updateUserStateOnBorrowInternal(     address _reserve,     address _user,     uint256 _amountBorrowed,     uint256 _balanceIncrease,     uint256 _fee,     CoreLibrary.InterestRateMode _rateMode ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      if (_rateMode == CoreLibrary.InterestRateMode.STABLE) {         //stable         //reset the user variable index, and update the stable rate         user.stableBorrowRate = reserve.currentStableBorrowRate;         user.lastVariableBorrowCumulativeIndex = 0;     } else if (_rateMode == CoreLibrary.InterestRateMode.VARIABLE) {         //variable         //reset the user stable rate, and store the new borrow index         user.stableBorrowRate = 0;         user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;     } else {         revert("Invalid borrow rate mode");     }     //increase the principal borrows and the origination fee     user.principalBorrowBalance = user.principalBorrowBalance.add(_amountBorrowed).add(         _balanceIncrease     );     user.originationFee = user.originationFee.add(_fee);      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp);  }  /** * @dev updates the state of the reserve as a consequence of a repay action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _paybackAmountMinusFees the amount being paid back minus fees * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updateReserveStateOnRepayInternal(     address _reserve,     address _user,     uint256 _paybackAmountMinusFees,     uint256 _balanceIncrease ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_reserve][_user];      CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(_reserve, _user);      //update the indexes     reserves[_reserve].updateCumulativeIndexes();      //compound the cumulated interest to the borrow balance and then subtracting the payback amount     if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             _balanceIncrease,             user.stableBorrowRate         );         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _paybackAmountMinusFees,             user.stableBorrowRate         );     } else {         reserve.increaseTotalBorrowsVariable(_balanceIncrease);         reserve.decreaseTotalBorrowsVariable(_paybackAmountMinusFees);     } }  /** * @dev updates the state of the user as a consequence of a repay action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _paybackAmountMinusFees the amount being paid back minus fees * @param _originationFeeRepaid the fee on the amount that is being repaid * @param _balanceIncrease the accrued interest on the borrowed amount * @param _repaidWholeLoan true if the user is repaying the whole loan **/ function updateUserStateOnRepayInternal(     address _reserve,     address _user,     uint256 _paybackAmountMinusFees,     uint256 _originationFeeRepaid,     uint256 _balanceIncrease,     bool _repaidWholeLoan ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      //update the user principal borrow balance, adding the cumulated interest and then subtracting the payback amount     user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(         _paybackAmountMinusFees     );     user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;      //if the balance decrease is equal to the previous principal (user is repaying the whole loan)     //and the rate mode is stable, we reset the interest rate mode of the user     if (_repaidWholeLoan) {         user.stableBorrowRate = 0;         user.lastVariableBorrowCumulativeIndex = 0;     }     user.originationFee = user.originationFee.sub(_originationFeeRepaid);      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp);  }  /** * @dev updates the state of the user as a consequence of a swap rate action. * @param _reserve the address of the reserve on which the user is performing the rate swap * @param _user the address of the borrower * @param _principalBorrowBalance the the principal amount borrowed by the user * @param _compoundedBorrowBalance the principal amount plus the accrued interest * @param _currentRateMode the rate mode at which the user borrowed **/ function updateReserveStateOnSwapRateInternal(     address _reserve,     address _user,     uint256 _principalBorrowBalance,     uint256 _compoundedBorrowBalance,     CoreLibrary.InterestRateMode _currentRateMode ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      //compounding reserve indexes     reserve.updateCumulativeIndexes();      if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {         uint256 userCurrentStableRate = user.stableBorrowRate;          //swap to variable         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _principalBorrowBalance,             userCurrentStableRate         ); //decreasing stable from old principal balance         reserve.increaseTotalBorrowsVariable(_compoundedBorrowBalance); //increase variable borrows     } else if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         //swap to stable         uint256 currentStableRate = reserve.currentStableBorrowRate;         reserve.decreaseTotalBorrowsVariable(_principalBorrowBalance);         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             _compoundedBorrowBalance,             currentStableRate         );      } else {         revert("Invalid rate mode received");     } }  /** * @dev updates the state of the user as a consequence of a swap rate action. * @param _reserve the address of the reserve on which the user is performing the swap * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount * @param _currentRateMode the current rate mode of the user **/  function updateUserStateOnSwapRateInternal(     address _reserve,     address _user,     uint256 _balanceIncrease,     CoreLibrary.InterestRateMode _currentRateMode ) internal returns (CoreLibrary.InterestRateMode) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      CoreLibrary.InterestRateMode newMode = CoreLibrary.InterestRateMode.NONE;      if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         //switch to stable         newMode = CoreLibrary.InterestRateMode.STABLE;         user.stableBorrowRate = reserve.currentStableBorrowRate;         user.lastVariableBorrowCumulativeIndex = 0;     } else if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {         newMode = CoreLibrary.InterestRateMode.VARIABLE;         user.stableBorrowRate = 0;         user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;     } else {         revert("Invalid interest rate mode received");     }     //compounding cumulated interest     user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);     //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp);      return newMode; }  /** * @dev updates the state of the principal reserve as a consequence of a liquidation action. * @param _principalReserve the address of the principal reserve that is being repaid * @param _user the address of the borrower * @param _amountToLiquidate the amount being repaid by the liquidator * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updatePrincipalReserveStateOnLiquidationInternal(     address _principalReserve,     address _user,     uint256 _amountToLiquidate,     uint256 _balanceIncrease ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_principalReserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_principalReserve];      //update principal reserve data     reserve.updateCumulativeIndexes();      CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(         _principalReserve,         _user     );      if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {         //increase the total borrows by the compounded interest         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             _balanceIncrease,             user.stableBorrowRate         );          //decrease by the actual amount to liquidate         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _amountToLiquidate,             user.stableBorrowRate         );      } else {         //increase the total borrows by the compounded interest         reserve.increaseTotalBorrowsVariable(_balanceIncrease);          //decrease by the actual amount to liquidate         reserve.decreaseTotalBorrowsVariable(_amountToLiquidate);     }  }  /** * @dev updates the state of the collateral reserve as a consequence of a liquidation action. * @param _collateralReserve the address of the collateral reserve that is being liquidated **/ function updateCollateralReserveStateOnLiquidationInternal(     address _collateralReserve ) internal {     //update collateral reserve     reserves[_collateralReserve].updateCumulativeIndexes();  }  /** * @dev updates the state of the user being liquidated as a consequence of a liquidation action. * @param _reserve the address of the principal reserve that is being repaid * @param _user the address of the borrower * @param _amountToLiquidate the amount being repaid by the liquidator * @param _feeLiquidated the amount of origination fee being liquidated * @param _balanceIncrease the accrued interest on the borrowed amount **/ function updateUserStateOnLiquidationInternal(     address _reserve,     address _user,     uint256 _amountToLiquidate,     uint256 _feeLiquidated,     uint256 _balanceIncrease ) internal {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     //first increase by the compounded interest, then decrease by the liquidated amount     user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(         _amountToLiquidate     );      if (         getUserCurrentBorrowRateMode(_reserve, _user) == CoreLibrary.InterestRateMode.VARIABLE     ) {         user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;     }      if(_feeLiquidated &gt; 0){         user.originationFee = user.originationFee.sub(_feeLiquidated);     }      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp); }  /** * @dev updates the state of the reserve as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updateReserveStateOnRebalanceInternal(     address _reserve,     address _user,     uint256 _balanceIncrease ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      reserve.updateCumulativeIndexes();      reserve.increaseTotalBorrowsStableAndUpdateAverageRate(         _balanceIncrease,         user.stableBorrowRate     );  }  /** * @dev updates the state of the user as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updateUserStateOnRebalanceInternal(     address _reserve,     address _user,     uint256 _balanceIncrease ) internal {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);     user.stableBorrowRate = reserve.currentStableBorrowRate;      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp); }  /** * @dev updates the state of the user as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount * @param _amountBorrowed the accrued interest on the borrowed amount **/ function updateReserveTotalBorrowsByRateModeInternal(     address _reserve,     address _user,     uint256 _principalBalance,     uint256 _balanceIncrease,     uint256 _amountBorrowed,     CoreLibrary.InterestRateMode _newBorrowRateMode ) internal {     CoreLibrary.InterestRateMode previousRateMode = getUserCurrentBorrowRateMode(         _reserve,         _user     );     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      if (previousRateMode == CoreLibrary.InterestRateMode.STABLE) {         CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _principalBalance,             user.stableBorrowRate         );     } else if (previousRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         reserve.decreaseTotalBorrowsVariable(_principalBalance);     }      uint256 newPrincipalAmount = _principalBalance.add(_balanceIncrease).add(_amountBorrowed);     if (_newBorrowRateMode == CoreLibrary.InterestRateMode.STABLE) {         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             newPrincipalAmount,             reserve.currentStableBorrowRate         );     } else if (_newBorrowRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         reserve.increaseTotalBorrowsVariable(newPrincipalAmount);     } else {         revert("Invalid new borrow rate mode");     } }  /** * @dev Updates the reserve current stable borrow rate Rf, the current variable borrow rate Rv and the current liquidity rate Rl. * Also updates the lastUpdateTimestamp value. Please refer to the whitepaper for further information. * @param _reserve the address of the reserve to be updated * @param _liquidityAdded the amount of liquidity added to the protocol (deposit or repay) in the previous action * @param _liquidityTaken the amount of liquidity taken from the protocol (redeem or borrow) **/  function updateReserveInterestRatesAndTimestampInternal(     address _reserve,     uint256 _liquidityAdded,     uint256 _liquidityTaken ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     (uint256 newLiquidityRate, uint256 newStableRate, uint256 newVariableRate) = IReserveInterestRateStrategy(         reserve         .interestRateStrategyAddress     )     .calculateInterestRates(         _reserve,         getReserveAvailableLiquidity(_reserve).add(_liquidityAdded).sub(_liquidityTaken),         reserve.totalBorrowsStable,         reserve.totalBorrowsVariable,         reserve.currentAverageStableBorrowRate     );      reserve.currentLiquidityRate = newLiquidityRate;     reserve.currentStableBorrowRate = newStableRate;     reserve.currentVariableBorrowRate = newVariableRate;      //solium-disable-next-line     reserve.lastUpdateTimestamp = uint40(block.timestamp);      emit ReserveUpdated(         _reserve,         newLiquidityRate,         newStableRate,         newVariableRate,         reserve.lastLiquidityCumulativeIndex,         reserve.lastVariableBorrowCumulativeIndex     ); }  /** * @dev transfers to the protocol fees of a flashloan to the fees collection address * @param _token the address of the token being transferred * @param _amount the amount being transferred **/  function transferFlashLoanProtocolFeeInternal(address _token, uint256 _amount) internal {     address payable receiver = address(uint160(addressesProvider.getTokenDistributor()));      if (_token != EthAddressLib.ethAddress()) {         ERC20(_token).safeTransfer(receiver, _amount);     } else {         receiver.transfer(_amount);     } }  /** * @dev updates the internal configuration of the core **/ function refreshConfigInternal() internal {     lendingPoolAddress = addressesProvider.getLendingPool(); }  /** * @dev adds a reserve to the array of the reserves address **/ function addReserveToListInternal(address _reserve) internal {     bool reserveAlreadyAdded = false;     for (uint256 i = 0; i &lt; reservesList.length; i++)         if (reservesList[i] == _reserve) {             reserveAlreadyAdded = true;         }     if (!reserveAlreadyAdded) reservesList.push(_reserve); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 04:32:00 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | pragma solidity ^0.5.0; import "openzeppelin-solidity/contracts/math/SafeMath.sol"; import "openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol"; import "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol"; import "openzeppelin-solidity/contracts/utils/Address.sol"; import "../libraries/openzeppelin-upgradeability/VersionedInitializable.sol"; import "../libraries/CoreLibrary.sol"; import "../configuration/LendingPoolAddressesProvider.sol"; import "../interfaces/ILendingRateOracle.sol"; import "../interfaces/IReserveInterestRateStrategy.sol"; import "../libraries/WadRayMath.sol"; import "../tokenization/AToken.sol"; import "../libraries/EthAddressLib.sol"; / * @title LendingPoolCore contract * @author Aave * @notice Holds the state of the lending pool and all the funds deposited * @dev NOTE: The core does not enforce security checks on the update of the state * (eg, updateStateOnBorrow() does not enforce that borrowed is enabled on the reserve). * The check that an action can be performed is a duty of the overlying LendingPool contract. / contract LendingPoolCore is VersionedInitializable {     using SafeMath for uint256;     using WadRayMath for uint256;     using CoreLibrary for CoreLibrary.ReserveData;     using CoreLibrary for CoreLibrary.UserReserveData;     using SafeERC20 for ERC20;     using Address for address payable; /** * @dev Emitted when the state of a reserve is updated * @param reserve the address of the reserve * @param liquidityRate the new liquidity rate * @param stableBorrowRate the new stable borrow rate * @param variableBorrowRate the new variable borrow rate * @param liquidityIndex the new liquidity index * @param variableBorrowIndex the new variable borrow index **/ event ReserveUpdated(     address indexed reserve,     uint256 liquidityRate,     uint256 stableBorrowRate,     uint256 variableBorrowRate,     uint256 liquidityIndex,     uint256 variableBorrowIndex );  address public lendingPoolAddress;  LendingPoolAddressesProvider public addressesProvider;  /** * @dev only lending pools can use functions affected by this modifier **/ modifier onlyLendingPool {     require(lendingPoolAddress == msg.sender, "The caller must be a lending pool contract");     _; }  /** * @dev only lending pools configurator can use functions affected by this modifier **/ modifier onlyLendingPoolConfigurator {     require(         addressesProvider.getLendingPoolConfigurator() == msg.sender,         "The caller must be a lending pool configurator contract"     );     _; }  mapping(address =&gt; CoreLibrary.ReserveData) internal reserves; mapping(address =&gt; mapping(address =&gt; CoreLibrary.UserReserveData)) internal usersReserveData;  address[] public reservesList;  uint256 public constant CORE_REVISION = 0x4;  /** * @dev returns the revision number of the contract **/ function getRevision() internal pure returns (uint256) {     return CORE_REVISION; }  /** * @dev initializes the Core contract, invoked upon registration on the AddressesProvider * @param _addressesProvider the addressesProvider contract **/  function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {     addressesProvider = _addressesProvider;     refreshConfigInternal(); }  /** * @dev updates the state of the core as a result of a deposit action * @param _reserve the address of the reserve in which the deposit is happening * @param _user the address of the the user depositing * @param _amount the amount being deposited * @param _isFirstDeposit true if the user is depositing for the first time **/  function updateStateOnDeposit(     address _reserve,     address _user,     uint256 _amount,     bool _isFirstDeposit ) external onlyLendingPool {     reserves[_reserve].updateCumulativeIndexes();     updateReserveInterestRatesAndTimestampInternal(_reserve, _amount, 0);      if (_isFirstDeposit) {         //if this is the first deposit of the user, we configure the deposit as enabled to be used as collateral         setUserUseReserveAsCollateral(_reserve, _user, true);     } }  /** * @dev updates the state of the core as a result of a redeem action * @param _reserve the address of the reserve in which the redeem is happening * @param _user the address of the the user redeeming * @param _amountRedeemed the amount being redeemed * @param _userRedeemedEverything true if the user is redeeming everything **/ function updateStateOnRedeem(     address _reserve,     address _user,     uint256 _amountRedeemed,     bool _userRedeemedEverything ) external onlyLendingPool {     //compound liquidity and variable borrow interests     reserves[_reserve].updateCumulativeIndexes();     updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountRedeemed);      //if user redeemed everything the useReserveAsCollateral flag is reset     if (_userRedeemedEverything) {         setUserUseReserveAsCollateral(_reserve, _user, false);     } }  /** * @dev updates the state of the core as a result of a flashloan action * @param _reserve the address of the reserve in which the flashloan is happening * @param _income the income of the protocol as a result of the action **/ function updateStateOnFlashLoan(     address _reserve,     uint256 _availableLiquidityBefore,     uint256 _income,     uint256 _protocolFee ) external onlyLendingPool {     transferFlashLoanProtocolFeeInternal(_reserve, _protocolFee);      //compounding the cumulated interest     reserves[_reserve].updateCumulativeIndexes();      uint256 totalLiquidityBefore = _availableLiquidityBefore.add(         getReserveTotalBorrows(_reserve)     );      //compounding the received fee into the reserve     reserves[_reserve].cumulateToLiquidityIndex(totalLiquidityBefore, _income);      //refresh interest rates     updateReserveInterestRatesAndTimestampInternal(_reserve, _income, 0); }  /** * @dev updates the state of the core as a consequence of a borrow action. * @param _reserve the address of the reserve on which the user is borrowing * @param _user the address of the borrower * @param _amountBorrowed the new amount borrowed * @param _borrowFee the fee on the amount borrowed * @param _rateMode the borrow rate mode (stable, variable) * @return the new borrow rate for the user **/ function updateStateOnBorrow(     address _reserve,     address _user,     uint256 _amountBorrowed,     uint256 _borrowFee,     CoreLibrary.InterestRateMode _rateMode ) external onlyLendingPool returns (uint256, uint256) {     // getting the previous borrow data of the user     (uint256 principalBorrowBalance, , uint256 balanceIncrease) = getUserBorrowBalances(         _reserve,         _user     );      updateReserveStateOnBorrowInternal(         _reserve,         _user,         principalBorrowBalance,         balanceIncrease,         _amountBorrowed,         _rateMode     );      updateUserStateOnBorrowInternal(         _reserve,         _user,         _amountBorrowed,         balanceIncrease,         _borrowFee,         _rateMode     );      updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountBorrowed);      return (getUserCurrentBorrowRate(_reserve, _user), balanceIncrease); }  /** * @dev updates the state of the core as a consequence of a repay action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _paybackAmountMinusFees the amount being paid back minus fees * @param _originationFeeRepaid the fee on the amount that is being repaid * @param _balanceIncrease the accrued interest on the borrowed amount * @param _repaidWholeLoan true if the user is repaying the whole loan **/  function updateStateOnRepay(     address _reserve,     address _user,     uint256 _paybackAmountMinusFees,     uint256 _originationFeeRepaid,     uint256 _balanceIncrease,     bool _repaidWholeLoan ) external onlyLendingPool {     updateReserveStateOnRepayInternal(         _reserve,         _user,         _paybackAmountMinusFees,         _balanceIncrease     );     updateUserStateOnRepayInternal(         _reserve,         _user,         _paybackAmountMinusFees,         _originationFeeRepaid,         _balanceIncrease,         _repaidWholeLoan     );      updateReserveInterestRatesAndTimestampInternal(_reserve, _paybackAmountMinusFees, 0); }  /** * @dev updates the state of the core as a consequence of a swap rate action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _principalBorrowBalance the amount borrowed by the user * @param _compoundedBorrowBalance the amount borrowed plus accrued interest * @param _balanceIncrease the accrued interest on the borrowed amount * @param _currentRateMode the current interest rate mode for the user **/ function updateStateOnSwapRate(     address _reserve,     address _user,     uint256 _principalBorrowBalance,     uint256 _compoundedBorrowBalance,     uint256 _balanceIncrease,     CoreLibrary.InterestRateMode _currentRateMode ) external onlyLendingPool returns (CoreLibrary.InterestRateMode, uint256) {     updateReserveStateOnSwapRateInternal(         _reserve,         _user,         _principalBorrowBalance,         _compoundedBorrowBalance,         _currentRateMode     );      CoreLibrary.InterestRateMode newRateMode = updateUserStateOnSwapRateInternal(         _reserve,         _user,         _balanceIncrease,         _currentRateMode     );      updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);      return (newRateMode, getUserCurrentBorrowRate(_reserve, _user)); }  /** * @dev updates the state of the core as a consequence of a liquidation action. * @param _principalReserve the address of the principal reserve that is being repaid * @param _collateralReserve the address of the collateral reserve that is being liquidated * @param _user the address of the borrower * @param _amountToLiquidate the amount being repaid by the liquidator * @param _collateralToLiquidate the amount of collateral being liquidated * @param _feeLiquidated the amount of origination fee being liquidated * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus * @param _balanceIncrease the accrued interest on the borrowed amount * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise **/ function updateStateOnLiquidation(     address _principalReserve,     address _collateralReserve,     address _user,     uint256 _amountToLiquidate,     uint256 _collateralToLiquidate,     uint256 _feeLiquidated,     uint256 _liquidatedCollateralForFee,     uint256 _balanceIncrease,     bool _liquidatorReceivesAToken ) external onlyLendingPool {     updatePrincipalReserveStateOnLiquidationInternal(         _principalReserve,         _user,         _amountToLiquidate,         _balanceIncrease     );      updateCollateralReserveStateOnLiquidationInternal(         _collateralReserve     );      updateUserStateOnLiquidationInternal(         _principalReserve,         _user,         _amountToLiquidate,         _feeLiquidated,         _balanceIncrease     );      updateReserveInterestRatesAndTimestampInternal(_principalReserve, _amountToLiquidate, 0);      if (!_liquidatorReceivesAToken) {         updateReserveInterestRatesAndTimestampInternal(             _collateralReserve,             0,             _collateralToLiquidate.add(_liquidatedCollateralForFee)         );     }  }  /** * @dev updates the state of the core as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount * @return the new stable rate for the user **/ function updateStateOnRebalance(address _reserve, address _user, uint256 _balanceIncrease) external onlyLendingPool returns (uint256) {     updateReserveStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);      //update user data and rebalance the rate     updateUserStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);     updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);     return usersReserveData[_user][_reserve].stableBorrowRate; }  /** * @dev enables or disables a reserve as collateral * @param _reserve the address of the principal reserve where the user deposited * @param _user the address of the depositor * @param _useAsCollateral true if the depositor wants to use the reserve as collateral **/ function setUserUseReserveAsCollateral(address _reserve, address _user, bool _useAsCollateral) public onlyLendingPool {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     user.useAsCollateral = _useAsCollateral; }  /** * @notice ETH/token transfer functions **/  /** * @dev fallback function enforces that the caller is a contract, to support flashloan transfers **/ function() external payable {     //only contracts can send ETH to the core     require(msg.sender.isContract(), "Only contracts can send ether to the Lending pool core");  }  /** * @dev transfers to the user a specific amount from the reserve. * @param _reserve the address of the reserve where the transfer is happening * @param _user the address of the user receiving the transfer * @param _amount the amount being transferred **/ function transferToUser(address _reserve, address payable _user, uint256 _amount) external onlyLendingPool {     if (_reserve != EthAddressLib.ethAddress()) {         ERC20(_reserve).safeTransfer(_user, _amount);     } else {         //solium-disable-next-line         (bool result, ) = _user.call.value(_amount).gas(50000)("");         require(result, "Transfer of ETH failed");     } }  /** * @dev transfers the protocol fees to the fees collection address * @param _token the address of the token being transferred * @param _user the address of the user from where the transfer is happening * @param _amount the amount being transferred * @param _destination the fee receiver address **/  function transferToFeeCollectionAddress(     address _token,     address _user,     uint256 _amount,     address _destination ) external payable onlyLendingPool {     address payable feeAddress = address(uint160(_destination)); //cast the address to payable      if (_token != EthAddressLib.ethAddress()) {         require(             msg.value == 0,             "User is sending ETH along with the ERC20 transfer. Check the value attribute of the transaction"         );         ERC20(_token).safeTransferFrom(_user, feeAddress, _amount);     } else {         require(msg.value &gt;= _amount, "The amount and the value sent to deposit do not match");         //solium-disable-next-line         (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");         require(result, "Transfer of ETH failed");     } }  /** * @dev transfers the fees to the fees collection address in the case of liquidation * @param _token the address of the token being transferred * @param _amount the amount being transferred * @param _destination the fee receiver address **/ function liquidateFee(     address _token,     uint256 _amount,     address _destination ) external payable onlyLendingPool {     address payable feeAddress = address(uint160(_destination)); //cast the address to payable     require(         msg.value == 0,         "Fee liquidation does not require any transfer of value"     );      if (_token != EthAddressLib.ethAddress()) {         ERC20(_token).safeTransfer(feeAddress, _amount);     } else {         //solium-disable-next-line         (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");         require(result, "Transfer of ETH failed");     } }  /** * @dev transfers an amount from a user to the destination reserve * @param _reserve the address of the reserve where the amount is being transferred * @param _user the address of the user from where the transfer is happening * @param _amount the amount being transferred **/ function transferToReserve(address _reserve, address payable _user, uint256 _amount) external payable onlyLendingPool {     if (_reserve != EthAddressLib.ethAddress()) {         require(msg.value == 0, "User is sending ETH along with the ERC20 transfer.");         ERC20(_reserve).safeTransferFrom(_user, address(this), _amount);      } else {         require(msg.value &gt;= _amount, "The amount and the value sent to deposit do not match");          if (msg.value &gt; _amount) {             //send back excess ETH             uint256 excessAmount = msg.value.sub(_amount);             //solium-disable-next-line             (bool result, ) = _user.call.value(excessAmount).gas(50000)("");             require(result, "Transfer of ETH failed");         }     } }  /** * @notice data access functions **/  /** * @dev returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral) * needed to calculate the global account data in the LendingPoolDataProvider * @param _reserve the address of the reserve * @param _user the address of the user * @return the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not **/ function getUserBasicReserveData(address _reserve, address _user) external view returns (uint256, uint256, uint256, bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      uint256 underlyingBalance = getUserUnderlyingAssetBalance(_reserve, _user);      if (user.principalBorrowBalance == 0) {         return (underlyingBalance, 0, 0, user.useAsCollateral);     }      return (     underlyingBalance,     user.getCompoundedBorrowBalance(reserve),     user.originationFee,     user.useAsCollateral     ); }  /** * @dev checks if a user is allowed to borrow at a stable rate * @param _reserve the reserve address * @param _user the user * @param _amount the amount the the user wants to borrow * @return true if the user is allowed to borrow at a stable rate, false otherwise **/  function isUserAllowedToBorrowAtStable(address _reserve, address _user, uint256 _amount) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      if (!reserve.isStableBorrowRateEnabled) return false;      return     !user.useAsCollateral ||     !reserve.usageAsCollateralEnabled ||     _amount &gt; getUserUnderlyingAssetBalance(_reserve, _user); }  /** * @dev gets the underlying asset balance of a user based on the corresponding aToken balance. * @param _reserve the reserve address * @param _user the user address * @return the underlying deposit balance of the user **/  function getUserUnderlyingAssetBalance(address _reserve, address _user) public view returns (uint256) {     AToken aToken = AToken(reserves[_reserve].aTokenAddress);     return aToken.balanceOf(_user);  }  /** * @dev gets the interest rate strategy contract address for the reserve * @param _reserve the reserve address * @return the address of the interest rate strategy contract **/ function getReserveInterestRateStrategyAddress(address _reserve) public view returns (address) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.interestRateStrategyAddress; }  /** * @dev gets the aToken contract address for the reserve * @param _reserve the reserve address * @return the address of the aToken contract **/  function getReserveATokenAddress(address _reserve) public view returns (address) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.aTokenAddress; }  /** * @dev gets the available liquidity in the reserve. The available liquidity is the balance of the core contract * @param _reserve the reserve address * @return the available liquidity **/ function getReserveAvailableLiquidity(address _reserve) public view returns (uint256) {     uint256 balance = 0;      if (_reserve == EthAddressLib.ethAddress()) {         balance = address(this).balance;     } else {         balance = IERC20(_reserve).balanceOf(address(this));     }     return balance; }  /** * @dev gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows * @param _reserve the reserve address * @return the total liquidity **/ function getReserveTotalLiquidity(address _reserve) public view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return getReserveAvailableLiquidity(_reserve).add(reserve.getTotalBorrows()); }  /** * @dev gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there * there has been 100% income. * @param _reserve the reserve address * @return the reserve normalized income **/ function getReserveNormalizedIncome(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.getNormalizedIncome(); }  /** * @dev gets the reserve total borrows * @param _reserve the reserve address * @return the total borrows (stable + variable) **/ function getReserveTotalBorrows(address _reserve) public view returns (uint256) {     return reserves[_reserve].getTotalBorrows(); }  /** * @dev gets the reserve total borrows stable * @param _reserve the reserve address * @return the total borrows stable **/ function getReserveTotalBorrowsStable(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.totalBorrowsStable; }  /** * @dev gets the reserve total borrows variable * @param _reserve the reserve address * @return the total borrows variable **/  function getReserveTotalBorrowsVariable(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.totalBorrowsVariable; }  /** * @dev gets the reserve liquidation threshold * @param _reserve the reserve address * @return the reserve liquidation threshold **/  function getReserveLiquidationThreshold(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.liquidationThreshold; }  /** * @dev gets the reserve liquidation bonus * @param _reserve the reserve address * @return the reserve liquidation bonus **/  function getReserveLiquidationBonus(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.liquidationBonus; }  /** * @dev gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty * @param _reserve the reserve address * @return the reserve current variable borrow rate **/  function getReserveCurrentVariableBorrowRate(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      if (reserve.currentVariableBorrowRate == 0) {         return         IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)         .getBaseVariableBorrowRate();     }     return reserve.currentVariableBorrowRate; }  /** * @dev gets the reserve current stable borrow rate. Is the market rate if the reserve is empty * @param _reserve the reserve address * @return the reserve current stable borrow rate **/  function getReserveCurrentStableBorrowRate(address _reserve) public view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     ILendingRateOracle oracle = ILendingRateOracle(addressesProvider.getLendingRateOracle());      if (reserve.currentStableBorrowRate == 0) {         //no stable rate borrows yet         return oracle.getMarketBorrowRate(_reserve);     }      return reserve.currentStableBorrowRate; }  /** * @dev gets the reserve average stable borrow rate. The average stable rate is the weighted average * of all the loans taken at stable rate. * @param _reserve the reserve address * @return the reserve current average borrow rate **/ function getReserveCurrentAverageStableBorrowRate(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.currentAverageStableBorrowRate; }  /** * @dev gets the reserve liquidity rate * @param _reserve the reserve address * @return the reserve liquidity rate **/ function getReserveCurrentLiquidityRate(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.currentLiquidityRate; }  /** * @dev gets the reserve liquidity cumulative index * @param _reserve the reserve address * @return the reserve liquidity cumulative index **/ function getReserveLiquidityCumulativeIndex(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.lastLiquidityCumulativeIndex; }  /** * @dev gets the reserve variable borrow index * @param _reserve the reserve address * @return the reserve variable borrow index **/ function getReserveVariableBorrowsCumulativeIndex(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.lastVariableBorrowCumulativeIndex; }  /** * @dev this function aggregates the configuration parameters of the reserve. * It's used in the LendingPoolDataProvider specifically to save gas, and avoid * multiple external contract calls to fetch the same data. * @param _reserve the reserve address * @return the reserve decimals * @return the base ltv as collateral * @return the liquidation threshold * @return if the reserve is used as collateral or not **/ function getReserveConfiguration(address _reserve) external view returns (uint256, uint256, uint256, bool) {     uint256 decimals;     uint256 baseLTVasCollateral;     uint256 liquidationThreshold;     bool usageAsCollateralEnabled;      CoreLibrary.ReserveData storage reserve = reserves[_reserve];     decimals = reserve.decimals;     baseLTVasCollateral = reserve.baseLTVasCollateral;     liquidationThreshold = reserve.liquidationThreshold;     usageAsCollateralEnabled = reserve.usageAsCollateralEnabled;      return (decimals, baseLTVasCollateral, liquidationThreshold, usageAsCollateralEnabled); }  /** * @dev returns the decimals of the reserve * @param _reserve the reserve address * @return the reserve decimals **/ function getReserveDecimals(address _reserve) external view returns (uint256) {     return reserves[_reserve].decimals; }  /** * @dev returns true if the reserve is enabled for borrowing * @param _reserve the reserve address * @return true if the reserve is enabled for borrowing, false otherwise **/  function isReserveBorrowingEnabled(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.borrowingEnabled; }  /** * @dev returns true if the reserve is enabled as collateral * @param _reserve the reserve address * @return true if the reserve is enabled as collateral, false otherwise **/  function isReserveUsageAsCollateralEnabled(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.usageAsCollateralEnabled; }  /** * @dev returns true if the stable rate is enabled on reserve * @param _reserve the reserve address * @return true if the stable rate is enabled on reserve, false otherwise **/ function getReserveIsStableBorrowRateEnabled(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.isStableBorrowRateEnabled; }  /** * @dev returns true if the reserve is active * @param _reserve the reserve address * @return true if the reserve is active, false otherwise **/ function getReserveIsActive(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.isActive; }  /** * @notice returns if a reserve is freezed * @param _reserve the reserve for which the information is needed * @return true if the reserve is freezed, false otherwise **/  function getReserveIsFreezed(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.isFreezed; }  /** * @notice returns the timestamp of the last action on the reserve * @param _reserve the reserve for which the information is needed * @return the last updated timestamp of the reserve **/  function getReserveLastUpdate(address _reserve) external view returns (uint40 timestamp) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     timestamp = reserve.lastUpdateTimestamp; }  /** * @dev returns the utilization rate U of a specific reserve * @param _reserve the reserve for which the information is needed * @return the utilization rate in ray **/  function getReserveUtilizationRate(address _reserve) public view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      uint256 totalBorrows = reserve.getTotalBorrows();      if (totalBorrows == 0) {         return 0;     }      uint256 availableLiquidity = getReserveAvailableLiquidity(_reserve);      return totalBorrows.rayDiv(availableLiquidity.add(totalBorrows)); }  /** * @return the array of reserves configured on the core **/ function getReserves() external view returns (address[] memory) {     return reservesList; }  /** * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return true if the user has chosen to use the reserve as collateral, false otherwise **/ function isUserUseReserveAsCollateralEnabled(address _reserve, address _user) external view returns (bool) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.useAsCollateral; }  /** * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the origination fee for the user **/ function getUserOriginationFee(address _reserve, address _user) external view returns (uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.originationFee; }  /** * @dev users with no loans in progress have NONE as borrow rate mode * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the borrow rate mode for the user, **/  function getUserCurrentBorrowRateMode(address _reserve, address _user) public view returns (CoreLibrary.InterestRateMode) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      if (user.principalBorrowBalance == 0) {         return CoreLibrary.InterestRateMode.NONE;     }      return     user.stableBorrowRate &gt; 0     ? CoreLibrary.InterestRateMode.STABLE     : CoreLibrary.InterestRateMode.VARIABLE; }  /** * @dev gets the current borrow rate of the user * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the borrow rate for the user, **/ function getUserCurrentBorrowRate(address _reserve, address _user) internal view returns (uint256) {     CoreLibrary.InterestRateMode rateMode = getUserCurrentBorrowRateMode(_reserve, _user);      if (rateMode == CoreLibrary.InterestRateMode.NONE) {         return 0;     }      return     rateMode == CoreLibrary.InterestRateMode.STABLE     ? usersReserveData[_user][_reserve].stableBorrowRate     : reserves[_reserve].currentVariableBorrowRate; }  /** * @dev the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the user stable rate **/ function getUserCurrentStableBorrowRate(address _reserve, address _user) external view returns (uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.stableBorrowRate; }  /** * @dev calculates and returns the borrow balances of the user * @param _reserve the address of the reserve * @param _user the address of the user * @return the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance **/  function getUserBorrowBalances(address _reserve, address _user) public view returns (uint256, uint256, uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     if (user.principalBorrowBalance == 0) {         return (0, 0, 0);     }      uint256 principal = user.principalBorrowBalance;     uint256 compoundedBalance = CoreLibrary.getCompoundedBorrowBalance(         user,         reserves[_reserve]     );     return (principal, compoundedBalance, compoundedBalance.sub(principal)); }  /** * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the variable borrow index for the user **/  function getUserVariableBorrowCumulativeIndex(address _reserve, address _user) external view returns (uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.lastVariableBorrowCumulativeIndex; }  /** * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the variable borrow index for the user **/  function getUserLastUpdate(address _reserve, address _user) external view returns (uint256 timestamp) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     timestamp = user.lastUpdateTimestamp; }  /** * @dev updates the lending pool core configuration **/ function refreshConfiguration() external onlyLendingPoolConfigurator {     refreshConfigInternal(); }  /** * @dev initializes a reserve * @param _reserve the address of the reserve * @param _aTokenAddress the address of the overlying aToken contract * @param _decimals the decimals of the reserve currency * @param _interestRateStrategyAddress the address of the interest rate strategy contract **/ function initReserve(     address _reserve,     address _aTokenAddress,     uint256 _decimals,     address _interestRateStrategyAddress ) external onlyLendingPoolConfigurator {     reserves[_reserve].init(_aTokenAddress, _decimals, _interestRateStrategyAddress);     addReserveToListInternal(_reserve);  }    /** * @dev removes the last added reserve in the reservesList array * @param _reserveToRemove the address of the reserve **/ function removeLastAddedReserve(address _reserveToRemove) external onlyLendingPoolConfigurator {      address lastReserve = reservesList[reservesList.length-1];      require(lastReserve == _reserveToRemove, "Reserve being removed is different than the reserve requested");      //as we can't check if totalLiquidity is 0 (since the reserve added might not be an ERC20) we at least check that there is nothing borrowed     require(getReserveTotalBorrows(lastReserve) == 0, "Cannot remove a reserve with liquidity deposited");      reserves[lastReserve].isActive = false;     reserves[lastReserve].aTokenAddress = address(0);     reserves[lastReserve].decimals = 0;     reserves[lastReserve].lastLiquidityCumulativeIndex = 0;     reserves[lastReserve].lastVariableBorrowCumulativeIndex = 0;     reserves[lastReserve].borrowingEnabled = false;     reserves[lastReserve].usageAsCollateralEnabled = false;     reserves[lastReserve].baseLTVasCollateral = 0;     reserves[lastReserve].liquidationThreshold = 0;     reserves[lastReserve].liquidationBonus = 0;     reserves[lastReserve].interestRateStrategyAddress = address(0);      reservesList.pop(); }  /** * @dev updates the address of the interest rate strategy contract * @param _reserve the address of the reserve * @param _rateStrategyAddress the address of the interest rate strategy contract **/  function setReserveInterestRateStrategyAddress(address _reserve, address _rateStrategyAddress) external onlyLendingPoolConfigurator {     reserves[_reserve].interestRateStrategyAddress = _rateStrategyAddress; }  /** * @dev enables borrowing on a reserve. Also sets the stable rate borrowing * @param _reserve the address of the reserve * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise **/  function enableBorrowingOnReserve(address _reserve, bool _stableBorrowRateEnabled) external onlyLendingPoolConfigurator {     reserves[_reserve].enableBorrowing(_stableBorrowRateEnabled); }  /** * @dev disables borrowing on a reserve * @param _reserve the address of the reserve **/  function disableBorrowingOnReserve(address _reserve) external onlyLendingPoolConfigurator {     reserves[_reserve].disableBorrowing(); }  /** * @dev enables a reserve to be used as collateral * @param _reserve the address of the reserve **/ function enableReserveAsCollateral(     address _reserve,     uint256 _baseLTVasCollateral,     uint256 _liquidationThreshold,     uint256 _liquidationBonus ) external onlyLendingPoolConfigurator {     reserves[_reserve].enableAsCollateral(         _baseLTVasCollateral,         _liquidationThreshold,         _liquidationBonus     ); }  /** * @dev disables a reserve to be used as collateral * @param _reserve the address of the reserve **/ function disableReserveAsCollateral(address _reserve) external onlyLendingPoolConfigurator {     reserves[_reserve].disableAsCollateral(); }  /** * @dev enable the stable borrow rate mode on a reserve * @param _reserve the address of the reserve **/ function enableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isStableBorrowRateEnabled = true; }  /** * @dev disable the stable borrow rate mode on a reserve * @param _reserve the address of the reserve **/ function disableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isStableBorrowRateEnabled = false; }  /** * @dev activates a reserve * @param _reserve the address of the reserve **/ function activateReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      require(         reserve.lastLiquidityCumulativeIndex &gt; 0 &amp;&amp;         reserve.lastVariableBorrowCumulativeIndex &gt; 0,         "Reserve has not been initialized yet"     );     reserve.isActive = true; }  /** * @dev deactivates a reserve * @param _reserve the address of the reserve **/ function deactivateReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isActive = false; }  /** * @notice allows the configurator to freeze the reserve. * A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance. * @param _reserve the address of the reserve **/ function freezeReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isFreezed = true; }  /** * @notice allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed. * @param _reserve the address of the reserve **/ function unfreezeReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isFreezed = false; }  /** * @notice allows the configurator to update the loan to value of a reserve * @param _reserve the address of the reserve * @param _ltv the new loan to value **/ function setReserveBaseLTVasCollateral(address _reserve, uint256 _ltv) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.baseLTVasCollateral = _ltv; }  /** * @notice allows the configurator to update the liquidation threshold of a reserve * @param _reserve the address of the reserve * @param _threshold the new liquidation threshold **/ function setReserveLiquidationThreshold(address _reserve, uint256 _threshold) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.liquidationThreshold = _threshold; }  /** * @notice allows the configurator to update the liquidation bonus of a reserve * @param _reserve the address of the reserve * @param _bonus the new liquidation bonus **/ function setReserveLiquidationBonus(address _reserve, uint256 _bonus) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.liquidationBonus = _bonus; }  /** * @notice allows the configurator to update the reserve decimals * @param _reserve the address of the reserve * @param _decimals the decimals of the reserve **/ function setReserveDecimals(address _reserve, uint256 _decimals) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.decimals = _decimals; }  /** * @notice internal functions **/  /** * @dev updates the state of a reserve as a consequence of a borrow action. * @param _reserve the address of the reserve on which the user is borrowing * @param _user the address of the borrower * @param _principalBorrowBalance the previous borrow balance of the borrower before the action * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount * @param _amountBorrowed the new amount borrowed * @param _rateMode the borrow rate mode (stable, variable) **/  function updateReserveStateOnBorrowInternal(     address _reserve,     address _user,     uint256 _principalBorrowBalance,     uint256 _balanceIncrease,     uint256 _amountBorrowed,     CoreLibrary.InterestRateMode _rateMode ) internal {     reserves[_reserve].updateCumulativeIndexes();      //increasing reserve total borrows to account for the new borrow balance of the user     //NOTE: Depending on the previous borrow mode, the borrows might need to be switched from variable to stable or vice versa      updateReserveTotalBorrowsByRateModeInternal(         _reserve,         _user,         _principalBorrowBalance,         _balanceIncrease,         _amountBorrowed,         _rateMode     ); }  /** * @dev updates the state of a user as a consequence of a borrow action. * @param _reserve the address of the reserve on which the user is borrowing * @param _user the address of the borrower * @param _amountBorrowed the amount borrowed * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount * @param _rateMode the borrow rate mode (stable, variable) * @return the final borrow rate for the user. Emitted by the borrow() event **/  function updateUserStateOnBorrowInternal(     address _reserve,     address _user,     uint256 _amountBorrowed,     uint256 _balanceIncrease,     uint256 _fee,     CoreLibrary.InterestRateMode _rateMode ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      if (_rateMode == CoreLibrary.InterestRateMode.STABLE) {         //stable         //reset the user variable index, and update the stable rate         user.stableBorrowRate = reserve.currentStableBorrowRate;         user.lastVariableBorrowCumulativeIndex = 0;     } else if (_rateMode == CoreLibrary.InterestRateMode.VARIABLE) {         //variable         //reset the user stable rate, and store the new borrow index         user.stableBorrowRate = 0;         user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;     } else {         revert("Invalid borrow rate mode");     }     //increase the principal borrows and the origination fee     user.principalBorrowBalance = user.principalBorrowBalance.add(_amountBorrowed).add(         _balanceIncrease     );     user.originationFee = user.originationFee.add(_fee);      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp);  }  /** * @dev updates the state of the reserve as a consequence of a repay action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _paybackAmountMinusFees the amount being paid back minus fees * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updateReserveStateOnRepayInternal(     address _reserve,     address _user,     uint256 _paybackAmountMinusFees,     uint256 _balanceIncrease ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_reserve][_user];      CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(_reserve, _user);      //update the indexes     reserves[_reserve].updateCumulativeIndexes();      //compound the cumulated interest to the borrow balance and then subtracting the payback amount     if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             _balanceIncrease,             user.stableBorrowRate         );         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _paybackAmountMinusFees,             user.stableBorrowRate         );     } else {         reserve.increaseTotalBorrowsVariable(_balanceIncrease);         reserve.decreaseTotalBorrowsVariable(_paybackAmountMinusFees);     } }  /** * @dev updates the state of the user as a consequence of a repay action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _paybackAmountMinusFees the amount being paid back minus fees * @param _originationFeeRepaid the fee on the amount that is being repaid * @param _balanceIncrease the accrued interest on the borrowed amount * @param _repaidWholeLoan true if the user is repaying the whole loan **/ function updateUserStateOnRepayInternal(     address _reserve,     address _user,     uint256 _paybackAmountMinusFees,     uint256 _originationFeeRepaid,     uint256 _balanceIncrease,     bool _repaidWholeLoan ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      //update the user principal borrow balance, adding the cumulated interest and then subtracting the payback amount     user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(         _paybackAmountMinusFees     );     user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;      //if the balance decrease is equal to the previous principal (user is repaying the whole loan)     //and the rate mode is stable, we reset the interest rate mode of the user     if (_repaidWholeLoan) {         user.stableBorrowRate = 0;         user.lastVariableBorrowCumulativeIndex = 0;     }     user.originationFee = user.originationFee.sub(_originationFeeRepaid);      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp);  }  /** * @dev updates the state of the user as a consequence of a swap rate action. * @param _reserve the address of the reserve on which the user is performing the rate swap * @param _user the address of the borrower * @param _principalBorrowBalance the the principal amount borrowed by the user * @param _compoundedBorrowBalance the principal amount plus the accrued interest * @param _currentRateMode the rate mode at which the user borrowed **/ function updateReserveStateOnSwapRateInternal(     address _reserve,     address _user,     uint256 _principalBorrowBalance,     uint256 _compoundedBorrowBalance,     CoreLibrary.InterestRateMode _currentRateMode ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      //compounding reserve indexes     reserve.updateCumulativeIndexes();      if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {         uint256 userCurrentStableRate = user.stableBorrowRate;          //swap to variable         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _principalBorrowBalance,             userCurrentStableRate         ); //decreasing stable from old principal balance         reserve.increaseTotalBorrowsVariable(_compoundedBorrowBalance); //increase variable borrows     } else if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         //swap to stable         uint256 currentStableRate = reserve.currentStableBorrowRate;         reserve.decreaseTotalBorrowsVariable(_principalBorrowBalance);         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             _compoundedBorrowBalance,             currentStableRate         );      } else {         revert("Invalid rate mode received");     } }  /** * @dev updates the state of the user as a consequence of a swap rate action. * @param _reserve the address of the reserve on which the user is performing the swap * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount * @param _currentRateMode the current rate mode of the user **/  function updateUserStateOnSwapRateInternal(     address _reserve,     address _user,     uint256 _balanceIncrease,     CoreLibrary.InterestRateMode _currentRateMode ) internal returns (CoreLibrary.InterestRateMode) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      CoreLibrary.InterestRateMode newMode = CoreLibrary.InterestRateMode.NONE;      if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         //switch to stable         newMode = CoreLibrary.InterestRateMode.STABLE;         user.stableBorrowRate = reserve.currentStableBorrowRate;         user.lastVariableBorrowCumulativeIndex = 0;     } else if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {         newMode = CoreLibrary.InterestRateMode.VARIABLE;         user.stableBorrowRate = 0;         user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;     } else {         revert("Invalid interest rate mode received");     }     //compounding cumulated interest     user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);     //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp);      return newMode; }  /** * @dev updates the state of the principal reserve as a consequence of a liquidation action. * @param _principalReserve the address of the principal reserve that is being repaid * @param _user the address of the borrower * @param _amountToLiquidate the amount being repaid by the liquidator * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updatePrincipalReserveStateOnLiquidationInternal(     address _principalReserve,     address _user,     uint256 _amountToLiquidate,     uint256 _balanceIncrease ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_principalReserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_principalReserve];      //update principal reserve data     reserve.updateCumulativeIndexes();      CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(         _principalReserve,         _user     );      if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {         //increase the total borrows by the compounded interest         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             _balanceIncrease,             user.stableBorrowRate         );          //decrease by the actual amount to liquidate         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _amountToLiquidate,             user.stableBorrowRate         );      } else {         //increase the total borrows by the compounded interest         reserve.increaseTotalBorrowsVariable(_balanceIncrease);          //decrease by the actual amount to liquidate         reserve.decreaseTotalBorrowsVariable(_amountToLiquidate);     }  }  /** * @dev updates the state of the collateral reserve as a consequence of a liquidation action. * @param _collateralReserve the address of the collateral reserve that is being liquidated **/ function updateCollateralReserveStateOnLiquidationInternal(     address _collateralReserve ) internal {     //update collateral reserve     reserves[_collateralReserve].updateCumulativeIndexes();  }  /** * @dev updates the state of the user being liquidated as a consequence of a liquidation action. * @param _reserve the address of the principal reserve that is being repaid * @param _user the address of the borrower * @param _amountToLiquidate the amount being repaid by the liquidator * @param _feeLiquidated the amount of origination fee being liquidated * @param _balanceIncrease the accrued interest on the borrowed amount **/ function updateUserStateOnLiquidationInternal(     address _reserve,     address _user,     uint256 _amountToLiquidate,     uint256 _feeLiquidated,     uint256 _balanceIncrease ) internal {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     //first increase by the compounded interest, then decrease by the liquidated amount     user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(         _amountToLiquidate     );      if (         getUserCurrentBorrowRateMode(_reserve, _user) == CoreLibrary.InterestRateMode.VARIABLE     ) {         user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;     }      if(_feeLiquidated &gt; 0){         user.originationFee = user.originationFee.sub(_feeLiquidated);     }      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp); }  /** * @dev updates the state of the reserve as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updateReserveStateOnRebalanceInternal(     address _reserve,     address _user,     uint256 _balanceIncrease ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      reserve.updateCumulativeIndexes();      reserve.increaseTotalBorrowsStableAndUpdateAverageRate(         _balanceIncrease,         user.stableBorrowRate     );  }  /** * @dev updates the state of the user as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updateUserStateOnRebalanceInternal(     address _reserve,     address _user,     uint256 _balanceIncrease ) internal {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);     user.stableBorrowRate = reserve.currentStableBorrowRate;      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp); }  /** * @dev updates the state of the user as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount * @param _amountBorrowed the accrued interest on the borrowed amount **/ function updateReserveTotalBorrowsByRateModeInternal(     address _reserve,     address _user,     uint256 _principalBalance,     uint256 _balanceIncrease,     uint256 _amountBorrowed,     CoreLibrary.InterestRateMode _newBorrowRateMode ) internal {     CoreLibrary.InterestRateMode previousRateMode = getUserCurrentBorrowRateMode(         _reserve,         _user     );     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      if (previousRateMode == CoreLibrary.InterestRateMode.STABLE) {         CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _principalBalance,             user.stableBorrowRate         );     } else if (previousRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         reserve.decreaseTotalBorrowsVariable(_principalBalance);     }      uint256 newPrincipalAmount = _principalBalance.add(_balanceIncrease).add(_amountBorrowed);     if (_newBorrowRateMode == CoreLibrary.InterestRateMode.STABLE) {         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             newPrincipalAmount,             reserve.currentStableBorrowRate         );     } else if (_newBorrowRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         reserve.increaseTotalBorrowsVariable(newPrincipalAmount);     } else {         revert("Invalid new borrow rate mode");     } }  /** * @dev Updates the reserve current stable borrow rate Rf, the current variable borrow rate Rv and the current liquidity rate Rl. * Also updates the lastUpdateTimestamp value. Please refer to the whitepaper for further information. * @param _reserve the address of the reserve to be updated * @param _liquidityAdded the amount of liquidity added to the protocol (deposit or repay) in the previous action * @param _liquidityTaken the amount of liquidity taken from the protocol (redeem or borrow) **/  function updateReserveInterestRatesAndTimestampInternal(     address _reserve,     uint256 _liquidityAdded,     uint256 _liquidityTaken ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     (uint256 newLiquidityRate, uint256 newStableRate, uint256 newVariableRate) = IReserveInterestRateStrategy(         reserve         .interestRateStrategyAddress     )     .calculateInterestRates(         _reserve,         getReserveAvailableLiquidity(_reserve).add(_liquidityAdded).sub(_liquidityTaken),         reserve.totalBorrowsStable,         reserve.totalBorrowsVariable,         reserve.currentAverageStableBorrowRate     );      reserve.currentLiquidityRate = newLiquidityRate;     reserve.currentStableBorrowRate = newStableRate;     reserve.currentVariableBorrowRate = newVariableRate;      //solium-disable-next-line     reserve.lastUpdateTimestamp = uint40(block.timestamp);      emit ReserveUpdated(         _reserve,         newLiquidityRate,         newStableRate,         newVariableRate,         reserve.lastLiquidityCumulativeIndex,         reserve.lastVariableBorrowCumulativeIndex     ); }  /** * @dev transfers to the protocol fees of a flashloan to the fees collection address * @param _token the address of the token being transferred * @param _amount the amount being transferred **/  function transferFlashLoanProtocolFeeInternal(address _token, uint256 _amount) internal {     address payable receiver = address(uint160(addressesProvider.getTokenDistributor()));      if (_token != EthAddressLib.ethAddress()) {         ERC20(_token).safeTransfer(receiver, _amount);     } else {         receiver.transfer(_amount);     } }  /** * @dev updates the internal configuration of the core **/ function refreshConfigInternal() internal {     lendingPoolAddress = addressesProvider.getLendingPool(); }  /** * @dev adds a reserve to the array of the reserves address **/ function addReserveToListInternal(address _reserve) internal {     bool reserveAlreadyAdded = false;     for (uint256 i = 0; i &lt; reservesList.length; i++)         if (reservesList[i] == _reserve) {             reserveAlreadyAdded = true;         }     if (!reserveAlreadyAdded) reservesList.push(_reserve); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 04:32:00 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: pragma solidity ^0.5.0;

import "openzeppelin-solidity/contracts/math/SafeMath.sol";
import "openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol";
import "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol";
import "openzeppelin-solidity/contracts/utils/Address.sol";
import "../libraries/openzeppelin-upgradeability/VersionedInitializable.sol";

import "../libraries/CoreLibrary.sol";
import "../configuration/LendingPoolAddressesProvider.sol";
import "../interfaces/ILendingRateOracle.sol";
import "../interfaces/IReserveInterestRateStrategy.sol";
import "../libraries/WadRayMath.sol";
import "../tokenization/AToken.sol";
import "../libraries/EthAddressLib.sol";

/**
* @title LendingPoolCore contract
* @author Aave
* @notice Holds the state of the lending pool and all the funds deposited
* @dev NOTE: The core does not enforce security checks on the update of the state
* (eg, updateStateOnBorrow() does not enforce that borrowed is enabled on the reserve).
* The check that an action can be performed is a duty of the overlying LendingPool contract.
**/

contract LendingPoolCore is VersionedInitializable {
    using SafeMath for uint256;
    using WadRayMath for uint256;
    using CoreLibrary for CoreLibrary.ReserveData;
    using CoreLibrary for CoreLibrary.UserReserveData;
    using SafeERC20 for ERC20;
    using Address for address payable;

    /**
    * @dev Emitted when the state of a reserve is updated
    * @param reserve the address of the reserve
    * @param liquidityRate the new liquidity rate
    * @param stableBorrowRate the new stable borrow rate
    * @param variableBorrowRate the new variable borrow rate
    * @param liquidityIndex the new liquidity index
    * @param variableBorrowIndex the new variable borrow index
    **/
    event ReserveUpdated(
        address indexed reserve,
        uint256 liquidityRate,
        uint256 stableBorrowRate,
        uint256 variableBorrowRate,
        uint256 liquidityIndex,
        uint256 variableBorrowIndex
    );

    address public lendingPoolAddress;

    LendingPoolAddressesProvider public addressesProvider;

    /**
    * @dev only lending pools can use functions affected by this modifier
    **/
    modifier onlyLendingPool {
        require(lendingPoolAddress == msg.sender, "The caller must be a lending pool contract");
        _;
    }

    /**
    * @dev only lending pools configurator can use functions affected by this modifier
    **/
    modifier onlyLendingPoolConfigurator {
        require(
            addressesProvider.getLendingPoolConfigurator() == msg.sender,
            "The caller must be a lending pool configurator contract"
        );
        _;
    }

    mapping(address => CoreLibrary.ReserveData) internal reserves;
    mapping(address => mapping(address => CoreLibrary.UserReserveData)) internal usersReserveData;

    address[] public reservesList;

    uint256 public constant CORE_REVISION = 0x4;

    /**
    * @dev returns the revision number of the contract
    **/
    function getRevision() internal pure returns (uint256) {
        return CORE_REVISION;
    }

    /**
    * @dev initializes the Core contract, invoked upon registration on the AddressesProvider
    * @param _addressesProvider the addressesProvider contract
    **/

    function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {
        addressesProvider = _addressesProvider;
        refreshConfigInternal();
    }

    /**
    * @dev updates the state of the core as a result of a deposit action
    * @param _reserve the address of the reserve in which the deposit is happening
    * @param _user the address of the the user depositing
    * @param _amount the amount being deposited
    * @param _isFirstDeposit true if the user is depositing for the first time
    **/

    function updateStateOnDeposit(
        address _reserve,
        address _user,
        uint256 _amount,
        bool _isFirstDeposit
    ) external onlyLendingPool {
        reserves[_reserve].updateCumulativeIndexes();
        updateReserveInterestRatesAndTimestampInternal(_reserve, _amount, 0);

        if (_isFirstDeposit) {
            //if this is the first deposit of the user, we configure the deposit as enabled to be used as collateral
            setUserUseReserveAsCollateral(_reserve, _user, true);
        }
    }

    /**
    * @dev updates the state of the core as a result of a redeem action
    * @param _reserve the address of the reserve in which the redeem is happening
    * @param _user the address of the the user redeeming
    * @param _amountRedeemed the amount being redeemed
    * @param _userRedeemedEverything true if the user is redeeming everything
    **/
    function updateStateOnRedeem(
        address _reserve,
        address _user,
        uint256 _amountRedeemed,
        bool _userRedeemedEverything
    ) external onlyLendingPool {
        //compound liquidity and variable borrow interests
        reserves[_reserve].updateCumulativeIndexes();
        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountRedeemed);

        //if user redeemed everything the useReserveAsCollateral flag is reset
        if (_userRedeemedEverything) {
            setUserUseReserveAsCollateral(_reserve, _user, false);
        }
    }

    /**
    * @dev updates the state of the core as a result of a flashloan action
    * @param _reserve the address of the reserve in which the flashloan is happening
    * @param _income the income of the protocol as a result of the action
    **/
    function updateStateOnFlashLoan(
        address _reserve,
        uint256 _availableLiquidityBefore,
        uint256 _income,
        uint256 _protocolFee
    ) external onlyLendingPool {
        transferFlashLoanProtocolFeeInternal(_reserve, _protocolFee);

        //compounding the cumulated interest
        reserves[_reserve].updateCumulativeIndexes();

        uint256 totalLiquidityBefore = _availableLiquidityBefore.add(
            getReserveTotalBorrows(_reserve)
        );

        //compounding the received fee into the reserve
        reserves[_reserve].cumulateToLiquidityIndex(totalLiquidityBefore, _income);

        //refresh interest rates
        updateReserveInterestRatesAndTimestampInternal(_reserve, _income, 0);
    }

    /**
    * @dev updates the state of the core as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _amountBorrowed the new amount borrowed
    * @param _borrowFee the fee on the amount borrowed
    * @param _rateMode the borrow rate mode (stable, variable)
    * @return the new borrow rate for the user
    **/
    function updateStateOnBorrow(
        address _reserve,
        address _user,
        uint256 _amountBorrowed,
        uint256 _borrowFee,
        CoreLibrary.InterestRateMode _rateMode
    ) external onlyLendingPool returns (uint256, uint256) {
        // getting the previous borrow data of the user
        (uint256 principalBorrowBalance, , uint256 balanceIncrease) = getUserBorrowBalances(
            _reserve,
            _user
        );

        updateReserveStateOnBorrowInternal(
            _reserve,
            _user,
            principalBorrowBalance,
            balanceIncrease,
            _amountBorrowed,
            _rateMode
        );

        updateUserStateOnBorrowInternal(
            _reserve,
            _user,
            _amountBorrowed,
            balanceIncrease,
            _borrowFee,
            _rateMode
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountBorrowed);

        return (getUserCurrentBorrowRate(_reserve, _user), balanceIncrease);
    }

    /**
    * @dev updates the state of the core as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _originationFeeRepaid the fee on the amount that is being repaid
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _repaidWholeLoan true if the user is repaying the whole loan
    **/

    function updateStateOnRepay(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _originationFeeRepaid,
        uint256 _balanceIncrease,
        bool _repaidWholeLoan
    ) external onlyLendingPool {
        updateReserveStateOnRepayInternal(
            _reserve,
            _user,
            _paybackAmountMinusFees,
            _balanceIncrease
        );
        updateUserStateOnRepayInternal(
            _reserve,
            _user,
            _paybackAmountMinusFees,
            _originationFeeRepaid,
            _balanceIncrease,
            _repaidWholeLoan
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, _paybackAmountMinusFees, 0);
    }

    /**
    * @dev updates the state of the core as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the amount borrowed by the user
    * @param _compoundedBorrowBalance the amount borrowed plus accrued interest
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _currentRateMode the current interest rate mode for the user
    **/
    function updateStateOnSwapRate(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _compoundedBorrowBalance,
        uint256 _balanceIncrease,
        CoreLibrary.InterestRateMode _currentRateMode
    ) external onlyLendingPool returns (CoreLibrary.InterestRateMode, uint256) {
        updateReserveStateOnSwapRateInternal(
            _reserve,
            _user,
            _principalBorrowBalance,
            _compoundedBorrowBalance,
            _currentRateMode
        );

        CoreLibrary.InterestRateMode newRateMode = updateUserStateOnSwapRateInternal(
            _reserve,
            _user,
            _balanceIncrease,
            _currentRateMode
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);

        return (newRateMode, getUserCurrentBorrowRate(_reserve, _user));
    }

    /**
    * @dev updates the state of the core as a consequence of a liquidation action.
    * @param _principalReserve the address of the principal reserve that is being repaid
    * @param _collateralReserve the address of the collateral reserve that is being liquidated
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _collateralToLiquidate the amount of collateral being liquidated
    * @param _feeLiquidated the amount of origination fee being liquidated
    * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise
    **/
    function updateStateOnLiquidation(
        address _principalReserve,
        address _collateralReserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _collateralToLiquidate,
        uint256 _feeLiquidated,
        uint256 _liquidatedCollateralForFee,
        uint256 _balanceIncrease,
        bool _liquidatorReceivesAToken
    ) external onlyLendingPool {
        updatePrincipalReserveStateOnLiquidationInternal(
            _principalReserve,
            _user,
            _amountToLiquidate,
            _balanceIncrease
        );

        updateCollateralReserveStateOnLiquidationInternal(
            _collateralReserve
        );

        updateUserStateOnLiquidationInternal(
            _principalReserve,
            _user,
            _amountToLiquidate,
            _feeLiquidated,
            _balanceIncrease
        );

        updateReserveInterestRatesAndTimestampInternal(_principalReserve, _amountToLiquidate, 0);

        if (!_liquidatorReceivesAToken) {
            updateReserveInterestRatesAndTimestampInternal(
                _collateralReserve,
                0,
                _collateralToLiquidate.add(_liquidatedCollateralForFee)
            );
        }

    }

    /**
    * @dev updates the state of the core as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @return the new stable rate for the user
    **/
    function updateStateOnRebalance(address _reserve, address _user, uint256 _balanceIncrease)
    external
    onlyLendingPool
    returns (uint256)
    {
        updateReserveStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);

        //update user data and rebalance the rate
        updateUserStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);
        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);
        return usersReserveData[_user][_reserve].stableBorrowRate;
    }

    /**
    * @dev enables or disables a reserve as collateral
    * @param _reserve the address of the principal reserve where the user deposited
    * @param _user the address of the depositor
    * @param _useAsCollateral true if the depositor wants to use the reserve as collateral
    **/
    function setUserUseReserveAsCollateral(address _reserve, address _user, bool _useAsCollateral)
    public
    onlyLendingPool
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        user.useAsCollateral = _useAsCollateral;
    }

    /**
    * @notice ETH/token transfer functions
    **/

    /**
    * @dev fallback function enforces that the caller is a contract, to support flashloan transfers
    **/
    function() external payable {
        //only contracts can send ETH to the core
        require(msg.sender.isContract(), "Only contracts can send ether to the Lending pool core");

    }

    /**
    * @dev transfers to the user a specific amount from the reserve.
    * @param _reserve the address of the reserve where the transfer is happening
    * @param _user the address of the user receiving the transfer
    * @param _amount the amount being transferred
    **/
    function transferToUser(address _reserve, address payable _user, uint256 _amount)
    external
    onlyLendingPool
    {
        if (_reserve != EthAddressLib.ethAddress()) {
            ERC20(_reserve).safeTransfer(_user, _amount);
        } else {
            //solium-disable-next-line
            (bool result, ) = _user.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers the protocol fees to the fees collection address
    * @param _token the address of the token being transferred
    * @param _user the address of the user from where the transfer is happening
    * @param _amount the amount being transferred
    * @param _destination the fee receiver address
    **/

    function transferToFeeCollectionAddress(
        address _token,
        address _user,
        uint256 _amount,
        address _destination
    ) external payable onlyLendingPool {
        address payable feeAddress = address(uint160(_destination)); //cast the address to payable

        if (_token != EthAddressLib.ethAddress()) {
            require(
                msg.value == 0,
                "User is sending ETH along with the ERC20 transfer. Check the value attribute of the transaction"
            );
            ERC20(_token).safeTransferFrom(_user, feeAddress, _amount);
        } else {
            require(msg.value >= _amount, "The amount and the value sent to deposit do not match");
            //solium-disable-next-line
            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers the fees to the fees collection address in the case of liquidation
    * @param _token the address of the token being transferred
    * @param _amount the amount being transferred
    * @param _destination the fee receiver address
    **/
    function liquidateFee(
        address _token,
        uint256 _amount,
        address _destination
    ) external payable onlyLendingPool {
        address payable feeAddress = address(uint160(_destination)); //cast the address to payable
        require(
            msg.value == 0,
            "Fee liquidation does not require any transfer of value"
        );

        if (_token != EthAddressLib.ethAddress()) {
            ERC20(_token).safeTransfer(feeAddress, _amount);
        } else {
            //solium-disable-next-line
            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers an amount from a user to the destination reserve
    * @param _reserve the address of the reserve where the amount is being transferred
    * @param _user the address of the user from where the transfer is happening
    * @param _amount the amount being transferred
    **/
    function transferToReserve(address _reserve, address payable _user, uint256 _amount)
    external
    payable
    onlyLendingPool
    {
        if (_reserve != EthAddressLib.ethAddress()) {
            require(msg.value == 0, "User is sending ETH along with the ERC20 transfer.");
            ERC20(_reserve).safeTransferFrom(_user, address(this), _amount);

        } else {
            require(msg.value >= _amount, "The amount and the value sent to deposit do not match");

            if (msg.value > _amount) {
                //send back excess ETH
                uint256 excessAmount = msg.value.sub(_amount);
                //solium-disable-next-line
                (bool result, ) = _user.call.value(excessAmount).gas(50000)("");
                require(result, "Transfer of ETH failed");
            }
        }
    }

    /**
    * @notice data access functions
    **/

    /**
    * @dev returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral)
    * needed to calculate the global account data in the LendingPoolDataProvider
    * @param _reserve the address of the reserve
    * @param _user the address of the user
    * @return the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not
    **/
    function getUserBasicReserveData(address _reserve, address _user)
    external
    view
    returns (uint256, uint256, uint256, bool)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        uint256 underlyingBalance = getUserUnderlyingAssetBalance(_reserve, _user);

        if (user.principalBorrowBalance == 0) {
            return (underlyingBalance, 0, 0, user.useAsCollateral);
        }

        return (
        underlyingBalance,
        user.getCompoundedBorrowBalance(reserve),
        user.originationFee,
        user.useAsCollateral
        );
    }

    /**
    * @dev checks if a user is allowed to borrow at a stable rate
    * @param _reserve the reserve address
    * @param _user the user
    * @param _amount the amount the the user wants to borrow
    * @return true if the user is allowed to borrow at a stable rate, false otherwise
    **/

    function isUserAllowedToBorrowAtStable(address _reserve, address _user, uint256 _amount)
    external
    view
    returns (bool)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (!reserve.isStableBorrowRateEnabled) return false;

        return
        !user.useAsCollateral ||
        !reserve.usageAsCollateralEnabled ||
        _amount > getUserUnderlyingAssetBalance(_reserve, _user);
    }

    /**
    * @dev gets the underlying asset balance of a user based on the corresponding aToken balance.
    * @param _reserve the reserve address
    * @param _user the user address
    * @return the underlying deposit balance of the user
    **/

    function getUserUnderlyingAssetBalance(address _reserve, address _user)
    public
    view
    returns (uint256)
    {
        AToken aToken = AToken(reserves[_reserve].aTokenAddress);
        return aToken.balanceOf(_user);

    }

    /**
    * @dev gets the interest rate strategy contract address for the reserve
    * @param _reserve the reserve address
    * @return the address of the interest rate strategy contract
    **/
    function getReserveInterestRateStrategyAddress(address _reserve) public view returns (address) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.interestRateStrategyAddress;
    }

    /**
    * @dev gets the aToken contract address for the reserve
    * @param _reserve the reserve address
    * @return the address of the aToken contract
    **/

    function getReserveATokenAddress(address _reserve) public view returns (address) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.aTokenAddress;
    }

    /**
    * @dev gets the available liquidity in the reserve. The available liquidity is the balance of the core contract
    * @param _reserve the reserve address
    * @return the available liquidity
    **/
    function getReserveAvailableLiquidity(address _reserve) public view returns (uint256) {
        uint256 balance = 0;

        if (_reserve == EthAddressLib.ethAddress()) {
            balance = address(this).balance;
        } else {
            balance = IERC20(_reserve).balanceOf(address(this));
        }
        return balance;
    }

    /**
    * @dev gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows
    * @param _reserve the reserve address
    * @return the total liquidity
    **/
    function getReserveTotalLiquidity(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return getReserveAvailableLiquidity(_reserve).add(reserve.getTotalBorrows());
    }

    /**
    * @dev gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there
    * there has been 100% income.
    * @param _reserve the reserve address
    * @return the reserve normalized income
    **/
    function getReserveNormalizedIncome(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.getNormalizedIncome();
    }

    /**
    * @dev gets the reserve total borrows
    * @param _reserve the reserve address
    * @return the total borrows (stable + variable)
    **/
    function getReserveTotalBorrows(address _reserve) public view returns (uint256) {
        return reserves[_reserve].getTotalBorrows();
    }

    /**
    * @dev gets the reserve total borrows stable
    * @param _reserve the reserve address
    * @return the total borrows stable
    **/
    function getReserveTotalBorrowsStable(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.totalBorrowsStable;
    }

    /**
    * @dev gets the reserve total borrows variable
    * @param _reserve the reserve address
    * @return the total borrows variable
    **/

    function getReserveTotalBorrowsVariable(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.totalBorrowsVariable;
    }

    /**
    * @dev gets the reserve liquidation threshold
    * @param _reserve the reserve address
    * @return the reserve liquidation threshold
    **/

    function getReserveLiquidationThreshold(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.liquidationThreshold;
    }

    /**
    * @dev gets the reserve liquidation bonus
    * @param _reserve the reserve address
    * @return the reserve liquidation bonus
    **/

    function getReserveLiquidationBonus(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.liquidationBonus;
    }

    /**
    * @dev gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty
    * @param _reserve the reserve address
    * @return the reserve current variable borrow rate
    **/

    function getReserveCurrentVariableBorrowRate(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        if (reserve.currentVariableBorrowRate == 0) {
            return
            IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)
            .getBaseVariableBorrowRate();
        }
        return reserve.currentVariableBorrowRate;
    }

    /**
    * @dev gets the reserve current stable borrow rate. Is the market rate if the reserve is empty
    * @param _reserve the reserve address
    * @return the reserve current stable borrow rate
    **/

    function getReserveCurrentStableBorrowRate(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        ILendingRateOracle oracle = ILendingRateOracle(addressesProvider.getLendingRateOracle());

        if (reserve.currentStableBorrowRate == 0) {
            //no stable rate borrows yet
            return oracle.getMarketBorrowRate(_reserve);
        }

        return reserve.currentStableBorrowRate;
    }

    /**
    * @dev gets the reserve average stable borrow rate. The average stable rate is the weighted average
    * of all the loans taken at stable rate.
    * @param _reserve the reserve address
    * @return the reserve current average borrow rate
    **/
    function getReserveCurrentAverageStableBorrowRate(address _reserve)
    external
    view
    returns (uint256)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.currentAverageStableBorrowRate;
    }

    /**
    * @dev gets the reserve liquidity rate
    * @param _reserve the reserve address
    * @return the reserve liquidity rate
    **/
    function getReserveCurrentLiquidityRate(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.currentLiquidityRate;
    }

    /**
    * @dev gets the reserve liquidity cumulative index
    * @param _reserve the reserve address
    * @return the reserve liquidity cumulative index
    **/
    function getReserveLiquidityCumulativeIndex(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.lastLiquidityCumulativeIndex;
    }

    /**
    * @dev gets the reserve variable borrow index
    * @param _reserve the reserve address
    * @return the reserve variable borrow index
    **/
    function getReserveVariableBorrowsCumulativeIndex(address _reserve)
    external
    view
    returns (uint256)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.lastVariableBorrowCumulativeIndex;
    }

    /**
    * @dev this function aggregates the configuration parameters of the reserve.
    * It's used in the LendingPoolDataProvider specifically to save gas, and avoid
    * multiple external contract calls to fetch the same data.
    * @param _reserve the reserve address
    * @return the reserve decimals
    * @return the base ltv as collateral
    * @return the liquidation threshold
    * @return if the reserve is used as collateral or not
    **/
    function getReserveConfiguration(address _reserve)
    external
    view
    returns (uint256, uint256, uint256, bool)
    {
        uint256 decimals;
        uint256 baseLTVasCollateral;
        uint256 liquidationThreshold;
        bool usageAsCollateralEnabled;

        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        decimals = reserve.decimals;
        baseLTVasCollateral = reserve.baseLTVasCollateral;
        liquidationThreshold = reserve.liquidationThreshold;
        usageAsCollateralEnabled = reserve.usageAsCollateralEnabled;

        return (decimals, baseLTVasCollateral, liquidationThreshold, usageAsCollateralEnabled);
    }

    /**
    * @dev returns the decimals of the reserve
    * @param _reserve the reserve address
    * @return the reserve decimals
    **/
    function getReserveDecimals(address _reserve) external view returns (uint256) {
        return reserves[_reserve].decimals;
    }

    /**
    * @dev returns true if the reserve is enabled for borrowing
    * @param _reserve the reserve address
    * @return true if the reserve is enabled for borrowing, false otherwise
    **/

    function isReserveBorrowingEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.borrowingEnabled;
    }

    /**
    * @dev returns true if the reserve is enabled as collateral
    * @param _reserve the reserve address
    * @return true if the reserve is enabled as collateral, false otherwise
    **/

    function isReserveUsageAsCollateralEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.usageAsCollateralEnabled;
    }

    /**
    * @dev returns true if the stable rate is enabled on reserve
    * @param _reserve the reserve address
    * @return true if the stable rate is enabled on reserve, false otherwise
    **/
    function getReserveIsStableBorrowRateEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isStableBorrowRateEnabled;
    }

    /**
    * @dev returns true if the reserve is active
    * @param _reserve the reserve address
    * @return true if the reserve is active, false otherwise
    **/
    function getReserveIsActive(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isActive;
    }

    /**
    * @notice returns if a reserve is freezed
    * @param _reserve the reserve for which the information is needed
    * @return true if the reserve is freezed, false otherwise
    **/

    function getReserveIsFreezed(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isFreezed;
    }

    /**
    * @notice returns the timestamp of the last action on the reserve
    * @param _reserve the reserve for which the information is needed
    * @return the last updated timestamp of the reserve
    **/

    function getReserveLastUpdate(address _reserve) external view returns (uint40 timestamp) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        timestamp = reserve.lastUpdateTimestamp;
    }

    /**
    * @dev returns the utilization rate U of a specific reserve
    * @param _reserve the reserve for which the information is needed
    * @return the utilization rate in ray
    **/

    function getReserveUtilizationRate(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        uint256 totalBorrows = reserve.getTotalBorrows();

        if (totalBorrows == 0) {
            return 0;
        }

        uint256 availableLiquidity = getReserveAvailableLiquidity(_reserve);

        return totalBorrows.rayDiv(availableLiquidity.add(totalBorrows));
    }

    /**
    * @return the array of reserves configured on the core
    **/
    function getReserves() external view returns (address[] memory) {
        return reservesList;
    }

    /**
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return true if the user has chosen to use the reserve as collateral, false otherwise
    **/
    function isUserUseReserveAsCollateralEnabled(address _reserve, address _user)
    external
    view
    returns (bool)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.useAsCollateral;
    }

    /**
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the origination fee for the user
    **/
    function getUserOriginationFee(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.originationFee;
    }

    /**
    * @dev users with no loans in progress have NONE as borrow rate mode
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the borrow rate mode for the user,
    **/

    function getUserCurrentBorrowRateMode(address _reserve, address _user)
    public
    view
    returns (CoreLibrary.InterestRateMode)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (user.principalBorrowBalance == 0) {
            return CoreLibrary.InterestRateMode.NONE;
        }

        return
        user.stableBorrowRate > 0
        ? CoreLibrary.InterestRateMode.STABLE
        : CoreLibrary.InterestRateMode.VARIABLE;
    }

    /**
    * @dev gets the current borrow rate of the user
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the borrow rate for the user,
    **/
    function getUserCurrentBorrowRate(address _reserve, address _user)
    internal
    view
    returns (uint256)
    {
        CoreLibrary.InterestRateMode rateMode = getUserCurrentBorrowRateMode(_reserve, _user);

        if (rateMode == CoreLibrary.InterestRateMode.NONE) {
            return 0;
        }

        return
        rateMode == CoreLibrary.InterestRateMode.STABLE
        ? usersReserveData[_user][_reserve].stableBorrowRate
        : reserves[_reserve].currentVariableBorrowRate;
    }

    /**
    * @dev the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the user stable rate
    **/
    function getUserCurrentStableBorrowRate(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.stableBorrowRate;
    }

    /**
    * @dev calculates and returns the borrow balances of the user
    * @param _reserve the address of the reserve
    * @param _user the address of the user
    * @return the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance
    **/

    function getUserBorrowBalances(address _reserve, address _user)
    public
    view
    returns (uint256, uint256, uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        if (user.principalBorrowBalance == 0) {
            return (0, 0, 0);
        }

        uint256 principal = user.principalBorrowBalance;
        uint256 compoundedBalance = CoreLibrary.getCompoundedBorrowBalance(
            user,
            reserves[_reserve]
        );
        return (principal, compoundedBalance, compoundedBalance.sub(principal));
    }

    /**
    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the variable borrow index for the user
    **/

    function getUserVariableBorrowCumulativeIndex(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.lastVariableBorrowCumulativeIndex;
    }

    /**
    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the variable borrow index for the user
    **/

    function getUserLastUpdate(address _reserve, address _user)
    external
    view
    returns (uint256 timestamp)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        timestamp = user.lastUpdateTimestamp;
    }

    /**
    * @dev updates the lending pool core configuration
    **/
    function refreshConfiguration() external onlyLendingPoolConfigurator {
        refreshConfigInternal();
    }

    /**
    * @dev initializes a reserve
    * @param _reserve the address of the reserve
    * @param _aTokenAddress the address of the overlying aToken contract
    * @param _decimals the decimals of the reserve currency
    * @param _interestRateStrategyAddress the address of the interest rate strategy contract
    **/
    function initReserve(
        address _reserve,
        address _aTokenAddress,
        uint256 _decimals,
        address _interestRateStrategyAddress
    ) external onlyLendingPoolConfigurator {
        reserves[_reserve].init(_aTokenAddress, _decimals, _interestRateStrategyAddress);
        addReserveToListInternal(_reserve);

    }



    /**
    * @dev removes the last added reserve in the reservesList array
    * @param _reserveToRemove the address of the reserve
    **/
    function removeLastAddedReserve(address _reserveToRemove)
    external onlyLendingPoolConfigurator {

        address lastReserve = reservesList[reservesList.length-1];

        require(lastReserve == _reserveToRemove, "Reserve being removed is different than the reserve requested");

        //as we can't check if totalLiquidity is 0 (since the reserve added might not be an ERC20) we at least check that there is nothing borrowed
        require(getReserveTotalBorrows(lastReserve) == 0, "Cannot remove a reserve with liquidity deposited");

        reserves[lastReserve].isActive = false;
        reserves[lastReserve].aTokenAddress = address(0);
        reserves[lastReserve].decimals = 0;
        reserves[lastReserve].lastLiquidityCumulativeIndex = 0;
        reserves[lastReserve].lastVariableBorrowCumulativeIndex = 0;
        reserves[lastReserve].borrowingEnabled = false;
        reserves[lastReserve].usageAsCollateralEnabled = false;
        reserves[lastReserve].baseLTVasCollateral = 0;
        reserves[lastReserve].liquidationThreshold = 0;
        reserves[lastReserve].liquidationBonus = 0;
        reserves[lastReserve].interestRateStrategyAddress = address(0);

        reservesList.pop();
    }

    /**
    * @dev updates the address of the interest rate strategy contract
    * @param _reserve the address of the reserve
    * @param _rateStrategyAddress the address of the interest rate strategy contract
    **/

    function setReserveInterestRateStrategyAddress(address _reserve, address _rateStrategyAddress)
    external
    onlyLendingPoolConfigurator
    {
        reserves[_reserve].interestRateStrategyAddress = _rateStrategyAddress;
    }

    /**
    * @dev enables borrowing on a reserve. Also sets the stable rate borrowing
    * @param _reserve the address of the reserve
    * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise
    **/

    function enableBorrowingOnReserve(address _reserve, bool _stableBorrowRateEnabled)
    external
    onlyLendingPoolConfigurator
    {
        reserves[_reserve].enableBorrowing(_stableBorrowRateEnabled);
    }

    /**
    * @dev disables borrowing on a reserve
    * @param _reserve the address of the reserve
    **/

    function disableBorrowingOnReserve(address _reserve) external onlyLendingPoolConfigurator {
        reserves[_reserve].disableBorrowing();
    }

    /**
    * @dev enables a reserve to be used as collateral
    * @param _reserve the address of the reserve
    **/
    function enableReserveAsCollateral(
        address _reserve,
        uint256 _baseLTVasCollateral,
        uint256 _liquidationThreshold,
        uint256 _liquidationBonus
    ) external onlyLendingPoolConfigurator {
        reserves[_reserve].enableAsCollateral(
            _baseLTVasCollateral,
            _liquidationThreshold,
            _liquidationBonus
        );
    }

    /**
    * @dev disables a reserve to be used as collateral
    * @param _reserve the address of the reserve
    **/
    function disableReserveAsCollateral(address _reserve) external onlyLendingPoolConfigurator {
        reserves[_reserve].disableAsCollateral();
    }

    /**
    * @dev enable the stable borrow rate mode on a reserve
    * @param _reserve the address of the reserve
    **/
    function enableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isStableBorrowRateEnabled = true;
    }

    /**
    * @dev disable the stable borrow rate mode on a reserve
    * @param _reserve the address of the reserve
    **/
    function disableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isStableBorrowRateEnabled = false;
    }

    /**
    * @dev activates a reserve
    * @param _reserve the address of the reserve
    **/
    function activateReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        require(
            reserve.lastLiquidityCumulativeIndex > 0 &&
            reserve.lastVariableBorrowCumulativeIndex > 0,
            "Reserve has not been initialized yet"
        );
        reserve.isActive = true;
    }

    /**
    * @dev deactivates a reserve
    * @param _reserve the address of the reserve
    **/
    function deactivateReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isActive = false;
    }

    /**
    * @notice allows the configurator to freeze the reserve.
    * A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance.
    * @param _reserve the address of the reserve
    **/
    function freezeReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isFreezed = true;
    }

    /**
    * @notice allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed.
    * @param _reserve the address of the reserve
    **/
    function unfreezeReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isFreezed = false;
    }

    /**
    * @notice allows the configurator to update the loan to value of a reserve
    * @param _reserve the address of the reserve
    * @param _ltv the new loan to value
    **/
    function setReserveBaseLTVasCollateral(address _reserve, uint256 _ltv)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.baseLTVasCollateral = _ltv;
    }

    /**
    * @notice allows the configurator to update the liquidation threshold of a reserve
    * @param _reserve the address of the reserve
    * @param _threshold the new liquidation threshold
    **/
    function setReserveLiquidationThreshold(address _reserve, uint256 _threshold)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.liquidationThreshold = _threshold;
    }

    /**
    * @notice allows the configurator to update the liquidation bonus of a reserve
    * @param _reserve the address of the reserve
    * @param _bonus the new liquidation bonus
    **/
    function setReserveLiquidationBonus(address _reserve, uint256 _bonus)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.liquidationBonus = _bonus;
    }

    /**
    * @notice allows the configurator to update the reserve decimals
    * @param _reserve the address of the reserve
    * @param _decimals the decimals of the reserve
    **/
    function setReserveDecimals(address _reserve, uint256 _decimals)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.decimals = _decimals;
    }

    /**
    * @notice internal functions
    **/

    /**
    * @dev updates the state of a reserve as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the previous borrow balance of the borrower before the action
    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount
    * @param _amountBorrowed the new amount borrowed
    * @param _rateMode the borrow rate mode (stable, variable)
    **/

    function updateReserveStateOnBorrowInternal(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _balanceIncrease,
        uint256 _amountBorrowed,
        CoreLibrary.InterestRateMode _rateMode
    ) internal {
        reserves[_reserve].updateCumulativeIndexes();

        //increasing reserve total borrows to account for the new borrow balance of the user
        //NOTE: Depending on the previous borrow mode, the borrows might need to be switched from variable to stable or vice versa

        updateReserveTotalBorrowsByRateModeInternal(
            _reserve,
            _user,
            _principalBorrowBalance,
            _balanceIncrease,
            _amountBorrowed,
            _rateMode
        );
    }

    /**
    * @dev updates the state of a user as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _amountBorrowed the amount borrowed
    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount
    * @param _rateMode the borrow rate mode (stable, variable)
    * @return the final borrow rate for the user. Emitted by the borrow() event
    **/

    function updateUserStateOnBorrowInternal(
        address _reserve,
        address _user,
        uint256 _amountBorrowed,
        uint256 _balanceIncrease,
        uint256 _fee,
        CoreLibrary.InterestRateMode _rateMode
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (_rateMode == CoreLibrary.InterestRateMode.STABLE) {
            //stable
            //reset the user variable index, and update the stable rate
            user.stableBorrowRate = reserve.currentStableBorrowRate;
            user.lastVariableBorrowCumulativeIndex = 0;
        } else if (_rateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //variable
            //reset the user stable rate, and store the new borrow index
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        } else {
            revert("Invalid borrow rate mode");
        }
        //increase the principal borrows and the origination fee
        user.principalBorrowBalance = user.principalBorrowBalance.add(_amountBorrowed).add(
            _balanceIncrease
        );
        user.originationFee = user.originationFee.add(_fee);

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

    }

    /**
    * @dev updates the state of the reserve as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateReserveStateOnRepayInternal(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_reserve][_user];

        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(_reserve, _user);

        //update the indexes
        reserves[_reserve].updateCumulativeIndexes();

        //compound the cumulated interest to the borrow balance and then subtracting the payback amount
        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _balanceIncrease,
                user.stableBorrowRate
            );
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _paybackAmountMinusFees,
                user.stableBorrowRate
            );
        } else {
            reserve.increaseTotalBorrowsVariable(_balanceIncrease);
            reserve.decreaseTotalBorrowsVariable(_paybackAmountMinusFees);
        }
    }

    /**
    * @dev updates the state of the user as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _originationFeeRepaid the fee on the amount that is being repaid
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _repaidWholeLoan true if the user is repaying the whole loan
    **/
    function updateUserStateOnRepayInternal(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _originationFeeRepaid,
        uint256 _balanceIncrease,
        bool _repaidWholeLoan
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        //update the user principal borrow balance, adding the cumulated interest and then subtracting the payback amount
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(
            _paybackAmountMinusFees
        );
        user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;

        //if the balance decrease is equal to the previous principal (user is repaying the whole loan)
        //and the rate mode is stable, we reset the interest rate mode of the user
        if (_repaidWholeLoan) {
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = 0;
        }
        user.originationFee = user.originationFee.sub(_originationFeeRepaid);

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

    }

    /**
    * @dev updates the state of the user as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is performing the rate swap
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the the principal amount borrowed by the user
    * @param _compoundedBorrowBalance the principal amount plus the accrued interest
    * @param _currentRateMode the rate mode at which the user borrowed
    **/
    function updateReserveStateOnSwapRateInternal(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _compoundedBorrowBalance,
        CoreLibrary.InterestRateMode _currentRateMode
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        //compounding reserve indexes
        reserve.updateCumulativeIndexes();

        if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {
            uint256 userCurrentStableRate = user.stableBorrowRate;

            //swap to variable
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _principalBorrowBalance,
                userCurrentStableRate
            ); //decreasing stable from old principal balance
            reserve.increaseTotalBorrowsVariable(_compoundedBorrowBalance); //increase variable borrows
        } else if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //swap to stable
            uint256 currentStableRate = reserve.currentStableBorrowRate;
            reserve.decreaseTotalBorrowsVariable(_principalBorrowBalance);
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _compoundedBorrowBalance,
                currentStableRate
            );

        } else {
            revert("Invalid rate mode received");
        }
    }

    /**
    * @dev updates the state of the user as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is performing the swap
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _currentRateMode the current rate mode of the user
    **/

    function updateUserStateOnSwapRateInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease,
        CoreLibrary.InterestRateMode _currentRateMode
    ) internal returns (CoreLibrary.InterestRateMode) {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        CoreLibrary.InterestRateMode newMode = CoreLibrary.InterestRateMode.NONE;

        if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //switch to stable
            newMode = CoreLibrary.InterestRateMode.STABLE;
            user.stableBorrowRate = reserve.currentStableBorrowRate;
            user.lastVariableBorrowCumulativeIndex = 0;
        } else if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {
            newMode = CoreLibrary.InterestRateMode.VARIABLE;
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        } else {
            revert("Invalid interest rate mode received");
        }
        //compounding cumulated interest
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);
        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

        return newMode;
    }

    /**
    * @dev updates the state of the principal reserve as a consequence of a liquidation action.
    * @param _principalReserve the address of the principal reserve that is being repaid
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updatePrincipalReserveStateOnLiquidationInternal(
        address _principalReserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_principalReserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_principalReserve];

        //update principal reserve data
        reserve.updateCumulativeIndexes();

        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(
            _principalReserve,
            _user
        );

        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            //increase the total borrows by the compounded interest
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _balanceIncrease,
                user.stableBorrowRate
            );

            //decrease by the actual amount to liquidate
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _amountToLiquidate,
                user.stableBorrowRate
            );

        } else {
            //increase the total borrows by the compounded interest
            reserve.increaseTotalBorrowsVariable(_balanceIncrease);

            //decrease by the actual amount to liquidate
            reserve.decreaseTotalBorrowsVariable(_amountToLiquidate);
        }

    }

    /**
    * @dev updates the state of the collateral reserve as a consequence of a liquidation action.
    * @param _collateralReserve the address of the collateral reserve that is being liquidated
    **/
    function updateCollateralReserveStateOnLiquidationInternal(
        address _collateralReserve
    ) internal {
        //update collateral reserve
        reserves[_collateralReserve].updateCumulativeIndexes();

    }

    /**
    * @dev updates the state of the user being liquidated as a consequence of a liquidation action.
    * @param _reserve the address of the principal reserve that is being repaid
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _feeLiquidated the amount of origination fee being liquidated
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/
    function updateUserStateOnLiquidationInternal(
        address _reserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _feeLiquidated,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        //first increase by the compounded interest, then decrease by the liquidated amount
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(
            _amountToLiquidate
        );

        if (
            getUserCurrentBorrowRateMode(_reserve, _user) == CoreLibrary.InterestRateMode.VARIABLE
        ) {
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        }

        if(_feeLiquidated > 0){
            user.originationFee = user.originationFee.sub(_feeLiquidated);
        }

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);
    }

    /**
    * @dev updates the state of the reserve as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateReserveStateOnRebalanceInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        reserve.updateCumulativeIndexes();

        reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
            _balanceIncrease,
            user.stableBorrowRate
        );

    }

    /**
    * @dev updates the state of the user as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateUserStateOnRebalanceInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);
        user.stableBorrowRate = reserve.currentStableBorrowRate;

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);
    }

    /**
    * @dev updates the state of the user as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _amountBorrowed the accrued interest on the borrowed amount
    **/
    function updateReserveTotalBorrowsByRateModeInternal(
        address _reserve,
        address _user,
        uint256 _principalBalance,
        uint256 _balanceIncrease,
        uint256 _amountBorrowed,
        CoreLibrary.InterestRateMode _newBorrowRateMode
    ) internal {
        CoreLibrary.InterestRateMode previousRateMode = getUserCurrentBorrowRateMode(
            _reserve,
            _user
        );
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        if (previousRateMode == CoreLibrary.InterestRateMode.STABLE) {
            CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _principalBalance,
                user.stableBorrowRate
            );
        } else if (previousRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            reserve.decreaseTotalBorrowsVariable(_principalBalance);
        }

        uint256 newPrincipalAmount = _principalBalance.add(_balanceIncrease).add(_amountBorrowed);
        if (_newBorrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                newPrincipalAmount,
                reserve.currentStableBorrowRate
            );
        } else if (_newBorrowRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            reserve.increaseTotalBorrowsVariable(newPrincipalAmount);
        } else {
            revert("Invalid new borrow rate mode");
        }
    }

    /**
    * @dev Updates the reserve current stable borrow rate Rf, the current variable borrow rate Rv and the current liquidity rate Rl.
    * Also updates the lastUpdateTimestamp value. Please refer to the whitepaper for further information.
    * @param _reserve the address of the reserve to be updated
    * @param _liquidityAdded the amount of liquidity added to the protocol (deposit or repay) in the previous action
    * @param _liquidityTaken the amount of liquidity taken from the protocol (redeem or borrow)
    **/

    function updateReserveInterestRatesAndTimestampInternal(
        address _reserve,
        uint256 _liquidityAdded,
        uint256 _liquidityTaken
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        (uint256 newLiquidityRate, uint256 newStableRate, uint256 newVariableRate) = IReserveInterestRateStrategy(
            reserve
            .interestRateStrategyAddress
        )
        .calculateInterestRates(
            _reserve,
            getReserveAvailableLiquidity(_reserve).add(_liquidityAdded).sub(_liquidityTaken),
            reserve.totalBorrowsStable,
            reserve.totalBorrowsVariable,
            reserve.currentAverageStableBorrowRate
        );

        reserve.currentLiquidityRate = newLiquidityRate;
        reserve.currentStableBorrowRate = newStableRate;
        reserve.currentVariableBorrowRate = newVariableRate;

        //solium-disable-next-line
        reserve.lastUpdateTimestamp = uint40(block.timestamp);

        emit ReserveUpdated(
            _reserve,
            newLiquidityRate,
            newStableRate,
            newVariableRate,
            reserve.lastLiquidityCumulativeIndex,
            reserve.lastVariableBorrowCumulativeIndex
        );
    }

    /**
    * @dev transfers to the protocol fees of a flashloan to the fees collection address
    * @param _token the address of the token being transferred
    * @param _amount the amount being transferred
    **/

    function transferFlashLoanProtocolFeeInternal(address _token, uint256 _amount) internal {
        address payable receiver = address(uint160(addressesProvider.getTokenDistributor()));

        if (_token != EthAddressLib.ethAddress()) {
            ERC20(_token).safeTransfer(receiver, _amount);
        } else {
            receiver.transfer(_amount);
        }
    }

    /**
    * @dev updates the internal configuration of the core
    **/
    function refreshConfigInternal() internal {
        lendingPoolAddress = addressesProvider.getLendingPool();
    }

    /**
    * @dev adds a reserve to the array of the reserves address
    **/
    function addReserveToListInternal(address _reserve) internal {
        bool reserveAlreadyAdded = false;
        for (uint256 i = 0; i < reservesList.length; i++)
            if (reservesList[i] == _reserve) {
                reserveAlreadyAdded = true;
            }
        if (!reserveAlreadyAdded) reservesList.push(_reserve);
    }

}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-01-09 04:32:12 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 04:32:12 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 14469
completion_tokens: 762
total_tokens: 15231
cost: $-1.000000


[2024-01-09 04:32:12 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: pragma solidity ^0.5.0;

import "openzeppelin-solidity/contracts/math/SafeMath.sol";
import "openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol";
import "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol";
import "openzeppelin-solidity/contracts/utils/Address.sol";
import "../libraries/openzeppelin-upgradeability/VersionedInitializable.sol";

import "../libraries/CoreLibrary.sol";
import "../configuration/LendingPoolAddressesProvider.sol";
import "../interfaces/ILendingRateOracle.sol";
import "../interfaces/IReserveInterestRateStrategy.sol";
import "../libraries/WadRayMath.sol";
import "../tokenization/AToken.sol";
import "../libraries/EthAddressLib.sol";

/**
* @title LendingPoolCore contract
* @author Aave
* @notice Holds the state of the lending pool and all the funds deposited
* @dev NOTE: The core does not enforce security checks on the update of the state
* (eg, updateStateOnBorrow() does not enforce that borrowed is enabled on the reserve).
* The check that an action can be performed is a duty of the overlying LendingPool contract.
**/

contract LendingPoolCore is VersionedInitializable {
    using SafeMath for uint256;
    using WadRayMath for uint256;
    using CoreLibrary for CoreLibrary.ReserveData;
    using CoreLibrary for CoreLibrary.UserReserveData;
    using SafeERC20 for ERC20;
    using Address for address payable;

    /**
    * @dev Emitted when the state of a reserve is updated
    * @param reserve the address of the reserve
    * @param liquidityRate the new liquidity rate
    * @param stableBorrowRate the new stable borrow rate
    * @param variableBorrowRate the new variable borrow rate
    * @param liquidityIndex the new liquidity index
    * @param variableBorrowIndex the new variable borrow index
    **/
    event ReserveUpdated(
        address indexed reserve,
        uint256 liquidityRate,
        uint256 stableBorrowRate,
        uint256 variableBorrowRate,
        uint256 liquidityIndex,
        uint256 variableBorrowIndex
    );

    address public lendingPoolAddress;

    LendingPoolAddressesProvider public addressesProvider;

    /**
    * @dev only lending pools can use functions affected by this modifier
    **/
    modifier onlyLendingPool {
        require(lendingPoolAddress == msg.sender, "The caller must be a lending pool contract");
        _;
    }

    /**
    * @dev only lending pools configurator can use functions affected by this modifier
    **/
    modifier onlyLendingPoolConfigurator {
        require(
            addressesProvider.getLendingPoolConfigurator() == msg.sender,
            "The caller must be a lending pool configurator contract"
        );
        _;
    }

    mapping(address => CoreLibrary.ReserveData) internal reserves;
    mapping(address => mapping(address => CoreLibrary.UserReserveData)) internal usersReserveData;

    address[] public reservesList;

    uint256 public constant CORE_REVISION = 0x4;

    /**
    * @dev returns the revision number of the contract
    **/
    function getRevision() internal pure returns (uint256) {
        return CORE_REVISION;
    }

    /**
    * @dev initializes the Core contract, invoked upon registration on the AddressesProvider
    * @param _addressesProvider the addressesProvider contract
    **/

    function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {
        addressesProvider = _addressesProvider;
        refreshConfigInternal();
    }

    /**
    * @dev updates the state of the core as a result of a deposit action
    * @param _reserve the address of the reserve in which the deposit is happening
    * @param _user the address of the the user depositing
    * @param _amount the amount being deposited
    * @param _isFirstDeposit true if the user is depositing for the first time
    **/

    function updateStateOnDeposit(
        address _reserve,
        address _user,
        uint256 _amount,
        bool _isFirstDeposit
    ) external onlyLendingPool {
        reserves[_reserve].updateCumulativeIndexes();
        updateReserveInterestRatesAndTimestampInternal(_reserve, _amount, 0);

        if (_isFirstDeposit) {
            //if this is the first deposit of the user, we configure the deposit as enabled to be used as collateral
            setUserUseReserveAsCollateral(_reserve, _user, true);
        }
    }

    /**
    * @dev updates the state of the core as a result of a redeem action
    * @param _reserve the address of the reserve in which the redeem is happening
    * @param _user the address of the the user redeeming
    * @param _amountRedeemed the amount being redeemed
    * @param _userRedeemedEverything true if the user is redeeming everything
    **/
    function updateStateOnRedeem(
        address _reserve,
        address _user,
        uint256 _amountRedeemed,
        bool _userRedeemedEverything
    ) external onlyLendingPool {
        //compound liquidity and variable borrow interests
        reserves[_reserve].updateCumulativeIndexes();
        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountRedeemed);

        //if user redeemed everything the useReserveAsCollateral flag is reset
        if (_userRedeemedEverything) {
            setUserUseReserveAsCollateral(_reserve, _user, false);
        }
    }

    /**
    * @dev updates the state of the core as a result of a flashloan action
    * @param _reserve the address of the reserve in which the flashloan is happening
    * @param _income the income of the protocol as a result of the action
    **/
    function updateStateOnFlashLoan(
        address _reserve,
        uint256 _availableLiquidityBefore,
        uint256 _income,
        uint256 _protocolFee
    ) external onlyLendingPool {
        transferFlashLoanProtocolFeeInternal(_reserve, _protocolFee);

        //compounding the cumulated interest
        reserves[_reserve].updateCumulativeIndexes();

        uint256 totalLiquidityBefore = _availableLiquidityBefore.add(
            getReserveTotalBorrows(_reserve)
        );

        //compounding the received fee into the reserve
        reserves[_reserve].cumulateToLiquidityIndex(totalLiquidityBefore, _income);

        //refresh interest rates
        updateReserveInterestRatesAndTimestampInternal(_reserve, _income, 0);
    }

    /**
    * @dev updates the state of the core as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _amountBorrowed the new amount borrowed
    * @param _borrowFee the fee on the amount borrowed
    * @param _rateMode the borrow rate mode (stable, variable)
    * @return the new borrow rate for the user
    **/
    function updateStateOnBorrow(
        address _reserve,
        address _user,
        uint256 _amountBorrowed,
        uint256 _borrowFee,
        CoreLibrary.InterestRateMode _rateMode
    ) external onlyLendingPool returns (uint256, uint256) {
        // getting the previous borrow data of the user
        (uint256 principalBorrowBalance, , uint256 balanceIncrease) = getUserBorrowBalances(
            _reserve,
            _user
        );

        updateReserveStateOnBorrowInternal(
            _reserve,
            _user,
            principalBorrowBalance,
            balanceIncrease,
            _amountBorrowed,
            _rateMode
        );

        updateUserStateOnBorrowInternal(
            _reserve,
            _user,
            _amountBorrowed,
            balanceIncrease,
            _borrowFee,
            _rateMode
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountBorrowed);

        return (getUserCurrentBorrowRate(_reserve, _user), balanceIncrease);
    }

    /**
    * @dev updates the state of the core as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _originationFeeRepaid the fee on the amount that is being repaid
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _repaidWholeLoan true if the user is repaying the whole loan
    **/

    function updateStateOnRepay(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _originationFeeRepaid,
        uint256 _balanceIncrease,
        bool _repaidWholeLoan
    ) external onlyLendingPool {
        updateReserveStateOnRepayInternal(
            _reserve,
            _user,
            _paybackAmountMinusFees,
            _balanceIncrease
        );
        updateUserStateOnRepayInternal(
            _reserve,
            _user,
            _paybackAmountMinusFees,
            _originationFeeRepaid,
            _balanceIncrease,
            _repaidWholeLoan
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, _paybackAmountMinusFees, 0);
    }

    /**
    * @dev updates the state of the core as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the amount borrowed by the user
    * @param _compoundedBorrowBalance the amount borrowed plus accrued interest
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _currentRateMode the current interest rate mode for the user
    **/
    function updateStateOnSwapRate(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _compoundedBorrowBalance,
        uint256 _balanceIncrease,
        CoreLibrary.InterestRateMode _currentRateMode
    ) external onlyLendingPool returns (CoreLibrary.InterestRateMode, uint256) {
        updateReserveStateOnSwapRateInternal(
            _reserve,
            _user,
            _principalBorrowBalance,
            _compoundedBorrowBalance,
            _currentRateMode
        );

        CoreLibrary.InterestRateMode newRateMode = updateUserStateOnSwapRateInternal(
            _reserve,
            _user,
            _balanceIncrease,
            _currentRateMode
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);

        return (newRateMode, getUserCurrentBorrowRate(_reserve, _user));
    }

    /**
    * @dev updates the state of the core as a consequence of a liquidation action.
    * @param _principalReserve the address of the principal reserve that is being repaid
    * @param _collateralReserve the address of the collateral reserve that is being liquidated
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _collateralToLiquidate the amount of collateral being liquidated
    * @param _feeLiquidated the amount of origination fee being liquidated
    * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise
    **/
    function updateStateOnLiquidation(
        address _principalReserve,
        address _collateralReserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _collateralToLiquidate,
        uint256 _feeLiquidated,
        uint256 _liquidatedCollateralForFee,
        uint256 _balanceIncrease,
        bool _liquidatorReceivesAToken
    ) external onlyLendingPool {
        updatePrincipalReserveStateOnLiquidationInternal(
            _principalReserve,
            _user,
            _amountToLiquidate,
            _balanceIncrease
        );

        updateCollateralReserveStateOnLiquidationInternal(
            _collateralReserve
        );

        updateUserStateOnLiquidationInternal(
            _principalReserve,
            _user,
            _amountToLiquidate,
            _feeLiquidated,
            _balanceIncrease
        );

        updateReserveInterestRatesAndTimestampInternal(_principalReserve, _amountToLiquidate, 0);

        if (!_liquidatorReceivesAToken) {
            updateReserveInterestRatesAndTimestampInternal(
                _collateralReserve,
                0,
                _collateralToLiquidate.add(_liquidatedCollateralForFee)
            );
        }

    }

    /**
    * @dev updates the state of the core as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @return the new stable rate for the user
    **/
    function updateStateOnRebalance(address _reserve, address _user, uint256 _balanceIncrease)
    external
    onlyLendingPool
    returns (uint256)
    {
        updateReserveStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);

        //update user data and rebalance the rate
        updateUserStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);
        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);
        return usersReserveData[_user][_reserve].stableBorrowRate;
    }

    /**
    * @dev enables or disables a reserve as collateral
    * @param _reserve the address of the principal reserve where the user deposited
    * @param _user the address of the depositor
    * @param _useAsCollateral true if the depositor wants to use the reserve as collateral
    **/
    function setUserUseReserveAsCollateral(address _reserve, address _user, bool _useAsCollateral)
    public
    onlyLendingPool
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        user.useAsCollateral = _useAsCollateral;
    }

    /**
    * @notice ETH/token transfer functions
    **/

    /**
    * @dev fallback function enforces that the caller is a contract, to support flashloan transfers
    **/
    function() external payable {
        //only contracts can send ETH to the core
        require(msg.sender.isContract(), "Only contracts can send ether to the Lending pool core");

    }

    /**
    * @dev transfers to the user a specific amount from the reserve.
    * @param _reserve the address of the reserve where the transfer is happening
    * @param _user the address of the user receiving the transfer
    * @param _amount the amount being transferred
    **/
    function transferToUser(address _reserve, address payable _user, uint256 _amount)
    external
    onlyLendingPool
    {
        if (_reserve != EthAddressLib.ethAddress()) {
            ERC20(_reserve).safeTransfer(_user, _amount);
        } else {
            //solium-disable-next-line
            (bool result, ) = _user.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers the protocol fees to the fees collection address
    * @param _token the address of the token being transferred
    * @param _user the address of the user from where the transfer is happening
    * @param _amount the amount being transferred
    * @param _destination the fee receiver address
    **/

    function transferToFeeCollectionAddress(
        address _token,
        address _user,
        uint256 _amount,
        address _destination
    ) external payable onlyLendingPool {
        address payable feeAddress = address(uint160(_destination)); //cast the address to payable

        if (_token != EthAddressLib.ethAddress()) {
            require(
                msg.value == 0,
                "User is sending ETH along with the ERC20 transfer. Check the value attribute of the transaction"
            );
            ERC20(_token).safeTransferFrom(_user, feeAddress, _amount);
        } else {
            require(msg.value >= _amount, "The amount and the value sent to deposit do not match");
            //solium-disable-next-line
            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers the fees to the fees collection address in the case of liquidation
    * @param _token the address of the token being transferred
    * @param _amount the amount being transferred
    * @param _destination the fee receiver address
    **/
    function liquidateFee(
        address _token,
        uint256 _amount,
        address _destination
    ) external payable onlyLendingPool {
        address payable feeAddress = address(uint160(_destination)); //cast the address to payable
        require(
            msg.value == 0,
            "Fee liquidation does not require any transfer of value"
        );

        if (_token != EthAddressLib.ethAddress()) {
            ERC20(_token).safeTransfer(feeAddress, _amount);
        } else {
            //solium-disable-next-line
            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers an amount from a user to the destination reserve
    * @param _reserve the address of the reserve where the amount is being transferred
    * @param _user the address of the user from where the transfer is happening
    * @param _amount the amount being transferred
    **/
    function transferToReserve(address _reserve, address payable _user, uint256 _amount)
    external
    payable
    onlyLendingPool
    {
        if (_reserve != EthAddressLib.ethAddress()) {
            require(msg.value == 0, "User is sending ETH along with the ERC20 transfer.");
            ERC20(_reserve).safeTransferFrom(_user, address(this), _amount);

        } else {
            require(msg.value >= _amount, "The amount and the value sent to deposit do not match");

            if (msg.value > _amount) {
                //send back excess ETH
                uint256 excessAmount = msg.value.sub(_amount);
                //solium-disable-next-line
                (bool result, ) = _user.call.value(excessAmount).gas(50000)("");
                require(result, "Transfer of ETH failed");
            }
        }
    }

    /**
    * @notice data access functions
    **/

    /**
    * @dev returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral)
    * needed to calculate the global account data in the LendingPoolDataProvider
    * @param _reserve the address of the reserve
    * @param _user the address of the user
    * @return the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not
    **/
    function getUserBasicReserveData(address _reserve, address _user)
    external
    view
    returns (uint256, uint256, uint256, bool)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        uint256 underlyingBalance = getUserUnderlyingAssetBalance(_reserve, _user);

        if (user.principalBorrowBalance == 0) {
            return (underlyingBalance, 0, 0, user.useAsCollateral);
        }

        return (
        underlyingBalance,
        user.getCompoundedBorrowBalance(reserve),
        user.originationFee,
        user.useAsCollateral
        );
    }

    /**
    * @dev checks if a user is allowed to borrow at a stable rate
    * @param _reserve the reserve address
    * @param _user the user
    * @param _amount the amount the the user wants to borrow
    * @return true if the user is allowed to borrow at a stable rate, false otherwise
    **/

    function isUserAllowedToBorrowAtStable(address _reserve, address _user, uint256 _amount)
    external
    view
    returns (bool)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (!reserve.isStableBorrowRateEnabled) return false;

        return
        !user.useAsCollateral ||
        !reserve.usageAsCollateralEnabled ||
        _amount > getUserUnderlyingAssetBalance(_reserve, _user);
    }

    /**
    * @dev gets the underlying asset balance of a user based on the corresponding aToken balance.
    * @param _reserve the reserve address
    * @param _user the user address
    * @return the underlying deposit balance of the user
    **/

    function getUserUnderlyingAssetBalance(address _reserve, address _user)
    public
    view
    returns (uint256)
    {
        AToken aToken = AToken(reserves[_reserve].aTokenAddress);
        return aToken.balanceOf(_user);

    }

    /**
    * @dev gets the interest rate strategy contract address for the reserve
    * @param _reserve the reserve address
    * @return the address of the interest rate strategy contract
    **/
    function getReserveInterestRateStrategyAddress(address _reserve) public view returns (address) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.interestRateStrategyAddress;
    }

    /**
    * @dev gets the aToken contract address for the reserve
    * @param _reserve the reserve address
    * @return the address of the aToken contract
    **/

    function getReserveATokenAddress(address _reserve) public view returns (address) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.aTokenAddress;
    }

    /**
    * @dev gets the available liquidity in the reserve. The available liquidity is the balance of the core contract
    * @param _reserve the reserve address
    * @return the available liquidity
    **/
    function getReserveAvailableLiquidity(address _reserve) public view returns (uint256) {
        uint256 balance = 0;

        if (_reserve == EthAddressLib.ethAddress()) {
            balance = address(this).balance;
        } else {
            balance = IERC20(_reserve).balanceOf(address(this));
        }
        return balance;
    }

    /**
    * @dev gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows
    * @param _reserve the reserve address
    * @return the total liquidity
    **/
    function getReserveTotalLiquidity(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return getReserveAvailableLiquidity(_reserve).add(reserve.getTotalBorrows());
    }

    /**
    * @dev gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there
    * there has been 100% income.
    * @param _reserve the reserve address
    * @return the reserve normalized income
    **/
    function getReserveNormalizedIncome(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.getNormalizedIncome();
    }

    /**
    * @dev gets the reserve total borrows
    * @param _reserve the reserve address
    * @return the total borrows (stable + variable)
    **/
    function getReserveTotalBorrows(address _reserve) public view returns (uint256) {
        return reserves[_reserve].getTotalBorrows();
    }

    /**
    * @dev gets the reserve total borrows stable
    * @param _reserve the reserve address
    * @return the total borrows stable
    **/
    function getReserveTotalBorrowsStable(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.totalBorrowsStable;
    }

    /**
    * @dev gets the reserve total borrows variable
    * @param _reserve the reserve address
    * @return the total borrows variable
    **/

    function getReserveTotalBorrowsVariable(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.totalBorrowsVariable;
    }

    /**
    * @dev gets the reserve liquidation threshold
    * @param _reserve the reserve address
    * @return the reserve liquidation threshold
    **/

    function getReserveLiquidationThreshold(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.liquidationThreshold;
    }

    /**
    * @dev gets the reserve liquidation bonus
    * @param _reserve the reserve address
    * @return the reserve liquidation bonus
    **/

    function getReserveLiquidationBonus(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.liquidationBonus;
    }

    /**
    * @dev gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty
    * @param _reserve the reserve address
    * @return the reserve current variable borrow rate
    **/

    function getReserveCurrentVariableBorrowRate(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        if (reserve.currentVariableBorrowRate == 0) {
            return
            IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)
            .getBaseVariableBorrowRate();
        }
        return reserve.currentVariableBorrowRate;
    }

    /**
    * @dev gets the reserve current stable borrow rate. Is the market rate if the reserve is empty
    * @param _reserve the reserve address
    * @return the reserve current stable borrow rate
    **/

    function getReserveCurrentStableBorrowRate(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        ILendingRateOracle oracle = ILendingRateOracle(addressesProvider.getLendingRateOracle());

        if (reserve.currentStableBorrowRate == 0) {
            //no stable rate borrows yet
            return oracle.getMarketBorrowRate(_reserve);
        }

        return reserve.currentStableBorrowRate;
    }

    /**
    * @dev gets the reserve average stable borrow rate. The average stable rate is the weighted average
    * of all the loans taken at stable rate.
    * @param _reserve the reserve address
    * @return the reserve current average borrow rate
    **/
    function getReserveCurrentAverageStableBorrowRate(address _reserve)
    external
    view
    returns (uint256)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.currentAverageStableBorrowRate;
    }

    /**
    * @dev gets the reserve liquidity rate
    * @param _reserve the reserve address
    * @return the reserve liquidity rate
    **/
    function getReserveCurrentLiquidityRate(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.currentLiquidityRate;
    }

    /**
    * @dev gets the reserve liquidity cumulative index
    * @param _reserve the reserve address
    * @return the reserve liquidity cumulative index
    **/
    function getReserveLiquidityCumulativeIndex(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.lastLiquidityCumulativeIndex;
    }

    /**
    * @dev gets the reserve variable borrow index
    * @param _reserve the reserve address
    * @return the reserve variable borrow index
    **/
    function getReserveVariableBorrowsCumulativeIndex(address _reserve)
    external
    view
    returns (uint256)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.lastVariableBorrowCumulativeIndex;
    }

    /**
    * @dev this function aggregates the configuration parameters of the reserve.
    * It's used in the LendingPoolDataProvider specifically to save gas, and avoid
    * multiple external contract calls to fetch the same data.
    * @param _reserve the reserve address
    * @return the reserve decimals
    * @return the base ltv as collateral
    * @return the liquidation threshold
    * @return if the reserve is used as collateral or not
    **/
    function getReserveConfiguration(address _reserve)
    external
    view
    returns (uint256, uint256, uint256, bool)
    {
        uint256 decimals;
        uint256 baseLTVasCollateral;
        uint256 liquidationThreshold;
        bool usageAsCollateralEnabled;

        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        decimals = reserve.decimals;
        baseLTVasCollateral = reserve.baseLTVasCollateral;
        liquidationThreshold = reserve.liquidationThreshold;
        usageAsCollateralEnabled = reserve.usageAsCollateralEnabled;

        return (decimals, baseLTVasCollateral, liquidationThreshold, usageAsCollateralEnabled);
    }

    /**
    * @dev returns the decimals of the reserve
    * @param _reserve the reserve address
    * @return the reserve decimals
    **/
    function getReserveDecimals(address _reserve) external view returns (uint256) {
        return reserves[_reserve].decimals;
    }

    /**
    * @dev returns true if the reserve is enabled for borrowing
    * @param _reserve the reserve address
    * @return true if the reserve is enabled for borrowing, false otherwise
    **/

    function isReserveBorrowingEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.borrowingEnabled;
    }

    /**
    * @dev returns true if the reserve is enabled as collateral
    * @param _reserve the reserve address
    * @return true if the reserve is enabled as collateral, false otherwise
    **/

    function isReserveUsageAsCollateralEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.usageAsCollateralEnabled;
    }

    /**
    * @dev returns true if the stable rate is enabled on reserve
    * @param _reserve the reserve address
    * @return true if the stable rate is enabled on reserve, false otherwise
    **/
    function getReserveIsStableBorrowRateEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isStableBorrowRateEnabled;
    }

    /**
    * @dev returns true if the reserve is active
    * @param _reserve the reserve address
    * @return true if the reserve is active, false otherwise
    **/
    function getReserveIsActive(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isActive;
    }

    /**
    * @notice returns if a reserve is freezed
    * @param _reserve the reserve for which the information is needed
    * @return true if the reserve is freezed, false otherwise
    **/

    function getReserveIsFreezed(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isFreezed;
    }

    /**
    * @notice returns the timestamp of the last action on the reserve
    * @param _reserve the reserve for which the information is needed
    * @return the last updated timestamp of the reserve
    **/

    function getReserveLastUpdate(address _reserve) external view returns (uint40 timestamp) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        timestamp = reserve.lastUpdateTimestamp;
    }

    /**
    * @dev returns the utilization rate U of a specific reserve
    * @param _reserve the reserve for which the information is needed
    * @return the utilization rate in ray
    **/

    function getReserveUtilizationRate(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        uint256 totalBorrows = reserve.getTotalBorrows();

        if (totalBorrows == 0) {
            return 0;
        }

        uint256 availableLiquidity = getReserveAvailableLiquidity(_reserve);

        return totalBorrows.rayDiv(availableLiquidity.add(totalBorrows));
    }

    /**
    * @return the array of reserves configured on the core
    **/
    function getReserves() external view returns (address[] memory) {
        return reservesList;
    }

    /**
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return true if the user has chosen to use the reserve as collateral, false otherwise
    **/
    function isUserUseReserveAsCollateralEnabled(address _reserve, address _user)
    external
    view
    returns (bool)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.useAsCollateral;
    }

    /**
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the origination fee for the user
    **/
    function getUserOriginationFee(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.originationFee;
    }

    /**
    * @dev users with no loans in progress have NONE as borrow rate mode
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the borrow rate mode for the user,
    **/

    function getUserCurrentBorrowRateMode(address _reserve, address _user)
    public
    view
    returns (CoreLibrary.InterestRateMode)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (user.principalBorrowBalance == 0) {
            return CoreLibrary.InterestRateMode.NONE;
        }

        return
        user.stableBorrowRate > 0
        ? CoreLibrary.InterestRateMode.STABLE
        : CoreLibrary.InterestRateMode.VARIABLE;
    }

    /**
    * @dev gets the current borrow rate of the user
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the borrow rate for the user,
    **/
    function getUserCurrentBorrowRate(address _reserve, address _user)
    internal
    view
    returns (uint256)
    {
        CoreLibrary.InterestRateMode rateMode = getUserCurrentBorrowRateMode(_reserve, _user);

        if (rateMode == CoreLibrary.InterestRateMode.NONE) {
            return 0;
        }

        return
        rateMode == CoreLibrary.InterestRateMode.STABLE
        ? usersReserveData[_user][_reserve].stableBorrowRate
        : reserves[_reserve].currentVariableBorrowRate;
    }

    /**
    * @dev the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the user stable rate
    **/
    function getUserCurrentStableBorrowRate(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.stableBorrowRate;
    }

    /**
    * @dev calculates and returns the borrow balances of the user
    * @param _reserve the address of the reserve
    * @param _user the address of the user
    * @return the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance
    **/

    function getUserBorrowBalances(address _reserve, address _user)
    public
    view
    returns (uint256, uint256, uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        if (user.principalBorrowBalance == 0) {
            return (0, 0, 0);
        }

        uint256 principal = user.principalBorrowBalance;
        uint256 compoundedBalance = CoreLibrary.getCompoundedBorrowBalance(
            user,
            reserves[_reserve]
        );
        return (principal, compoundedBalance, compoundedBalance.sub(principal));
    }

    /**
    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the variable borrow index for the user
    **/

    function getUserVariableBorrowCumulativeIndex(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.lastVariableBorrowCumulativeIndex;
    }

    /**
    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the variable borrow index for the user
    **/

    function getUserLastUpdate(address _reserve, address _user)
    external
    view
    returns (uint256 timestamp)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        timestamp = user.lastUpdateTimestamp;
    }

    /**
    * @dev updates the lending pool core configuration
    **/
    function refreshConfiguration() external onlyLendingPoolConfigurator {
        refreshConfigInternal();
    }

    /**
    * @dev initializes a reserve
    * @param _reserve the address of the reserve
    * @param _aTokenAddress the address of the overlying aToken contract
    * @param _decimals the decimals of the reserve currency
    * @param _interestRateStrategyAddress the address of the interest rate strategy contract
    **/
    function initReserve(
        address _reserve,
        address _aTokenAddress,
        uint256 _decimals,
        address _interestRateStrategyAddress
    ) external onlyLendingPoolConfigurator {
        reserves[_reserve].init(_aTokenAddress, _decimals, _interestRateStrategyAddress);
        addReserveToListInternal(_reserve);

    }



    /**
    * @dev removes the last added reserve in the reservesList array
    * @param _reserveToRemove the address of the reserve
    **/
    function removeLastAddedReserve(address _reserveToRemove)
    external onlyLendingPoolConfigurator {

        address lastReserve = reservesList[reservesList.length-1];

        require(lastReserve == _reserveToRemove, "Reserve being removed is different than the reserve requested");

        //as we can't check if totalLiquidity is 0 (since the reserve added might not be an ERC20) we at least check that there is nothing borrowed
        require(getReserveTotalBorrows(lastReserve) == 0, "Cannot remove a reserve with liquidity deposited");

        reserves[lastReserve].isActive = false;
        reserves[lastReserve].aTokenAddress = address(0);
        reserves[lastReserve].decimals = 0;
        reserves[lastReserve].lastLiquidityCumulativeIndex = 0;
        reserves[lastReserve].lastVariableBorrowCumulativeIndex = 0;
        reserves[lastReserve].borrowingEnabled = false;
        reserves[lastReserve].usageAsCollateralEnabled = false;
        reserves[lastReserve].baseLTVasCollateral = 0;
        reserves[lastReserve].liquidationThreshold = 0;
        reserves[lastReserve].liquidationBonus = 0;
        reserves[lastReserve].interestRateStrategyAddress = address(0);

        reservesList.pop();
    }

    /**
    * @dev updates the address of the interest rate strategy contract
    * @param _reserve the address of the reserve
    * @param _rateStrategyAddress the address of the interest rate strategy contract
    **/

    function setReserveInterestRateStrategyAddress(address _reserve, address _rateStrategyAddress)
    external
    onlyLendingPoolConfigurator
    {
        reserves[_reserve].interestRateStrategyAddress = _rateStrategyAddress;
    }

    /**
    * @dev enables borrowing on a reserve. Also sets the stable rate borrowing
    * @param _reserve the address of the reserve
    * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise
    **/

    function enableBorrowingOnReserve(address _reserve, bool _stableBorrowRateEnabled)
    external
    onlyLendingPoolConfigurator
    {
        reserves[_reserve].enableBorrowing(_stableBorrowRateEnabled);
    }

    /**
    * @dev disables borrowing on a reserve
    * @param _reserve the address of the reserve
    **/

    function disableBorrowingOnReserve(address _reserve) external onlyLendingPoolConfigurator {
        reserves[_reserve].disableBorrowing();
    }

    /**
    * @dev enables a reserve to be used as collateral
    * @param _reserve the address of the reserve
    **/
    function enableReserveAsCollateral(
        address _reserve,
        uint256 _baseLTVasCollateral,
        uint256 _liquidationThreshold,
        uint256 _liquidationBonus
    ) external onlyLendingPoolConfigurator {
        reserves[_reserve].enableAsCollateral(
            _baseLTVasCollateral,
            _liquidationThreshold,
            _liquidationBonus
        );
    }

    /**
    * @dev disables a reserve to be used as collateral
    * @param _reserve the address of the reserve
    **/
    function disableReserveAsCollateral(address _reserve) external onlyLendingPoolConfigurator {
        reserves[_reserve].disableAsCollateral();
    }

    /**
    * @dev enable the stable borrow rate mode on a reserve
    * @param _reserve the address of the reserve
    **/
    function enableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isStableBorrowRateEnabled = true;
    }

    /**
    * @dev disable the stable borrow rate mode on a reserve
    * @param _reserve the address of the reserve
    **/
    function disableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isStableBorrowRateEnabled = false;
    }

    /**
    * @dev activates a reserve
    * @param _reserve the address of the reserve
    **/
    function activateReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        require(
            reserve.lastLiquidityCumulativeIndex > 0 &&
            reserve.lastVariableBorrowCumulativeIndex > 0,
            "Reserve has not been initialized yet"
        );
        reserve.isActive = true;
    }

    /**
    * @dev deactivates a reserve
    * @param _reserve the address of the reserve
    **/
    function deactivateReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isActive = false;
    }

    /**
    * @notice allows the configurator to freeze the reserve.
    * A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance.
    * @param _reserve the address of the reserve
    **/
    function freezeReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isFreezed = true;
    }

    /**
    * @notice allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed.
    * @param _reserve the address of the reserve
    **/
    function unfreezeReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isFreezed = false;
    }

    /**
    * @notice allows the configurator to update the loan to value of a reserve
    * @param _reserve the address of the reserve
    * @param _ltv the new loan to value
    **/
    function setReserveBaseLTVasCollateral(address _reserve, uint256 _ltv)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.baseLTVasCollateral = _ltv;
    }

    /**
    * @notice allows the configurator to update the liquidation threshold of a reserve
    * @param _reserve the address of the reserve
    * @param _threshold the new liquidation threshold
    **/
    function setReserveLiquidationThreshold(address _reserve, uint256 _threshold)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.liquidationThreshold = _threshold;
    }

    /**
    * @notice allows the configurator to update the liquidation bonus of a reserve
    * @param _reserve the address of the reserve
    * @param _bonus the new liquidation bonus
    **/
    function setReserveLiquidationBonus(address _reserve, uint256 _bonus)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.liquidationBonus = _bonus;
    }

    /**
    * @notice allows the configurator to update the reserve decimals
    * @param _reserve the address of the reserve
    * @param _decimals the decimals of the reserve
    **/
    function setReserveDecimals(address _reserve, uint256 _decimals)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.decimals = _decimals;
    }

    /**
    * @notice internal functions
    **/

    /**
    * @dev updates the state of a reserve as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the previous borrow balance of the borrower before the action
    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount
    * @param _amountBorrowed the new amount borrowed
    * @param _rateMode the borrow rate mode (stable, variable)
    **/

    function updateReserveStateOnBorrowInternal(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _balanceIncrease,
        uint256 _amountBorrowed,
        CoreLibrary.InterestRateMode _rateMode
    ) internal {
        reserves[_reserve].updateCumulativeIndexes();

        //increasing reserve total borrows to account for the new borrow balance of the user
        //NOTE: Depending on the previous borrow mode, the borrows might need to be switched from variable to stable or vice versa

        updateReserveTotalBorrowsByRateModeInternal(
            _reserve,
            _user,
            _principalBorrowBalance,
            _balanceIncrease,
            _amountBorrowed,
            _rateMode
        );
    }

    /**
    * @dev updates the state of a user as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _amountBorrowed the amount borrowed
    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount
    * @param _rateMode the borrow rate mode (stable, variable)
    * @return the final borrow rate for the user. Emitted by the borrow() event
    **/

    function updateUserStateOnBorrowInternal(
        address _reserve,
        address _user,
        uint256 _amountBorrowed,
        uint256 _balanceIncrease,
        uint256 _fee,
        CoreLibrary.InterestRateMode _rateMode
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (_rateMode == CoreLibrary.InterestRateMode.STABLE) {
            //stable
            //reset the user variable index, and update the stable rate
            user.stableBorrowRate = reserve.currentStableBorrowRate;
            user.lastVariableBorrowCumulativeIndex = 0;
        } else if (_rateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //variable
            //reset the user stable rate, and store the new borrow index
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        } else {
            revert("Invalid borrow rate mode");
        }
        //increase the principal borrows and the origination fee
        user.principalBorrowBalance = user.principalBorrowBalance.add(_amountBorrowed).add(
            _balanceIncrease
        );
        user.originationFee = user.originationFee.add(_fee);

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

    }

    /**
    * @dev updates the state of the reserve as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateReserveStateOnRepayInternal(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_reserve][_user];

        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(_reserve, _user);

        //update the indexes
        reserves[_reserve].updateCumulativeIndexes();

        //compound the cumulated interest to the borrow balance and then subtracting the payback amount
        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _balanceIncrease,
                user.stableBorrowRate
            );
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _paybackAmountMinusFees,
                user.stableBorrowRate
            );
        } else {
            reserve.increaseTotalBorrowsVariable(_balanceIncrease);
            reserve.decreaseTotalBorrowsVariable(_paybackAmountMinusFees);
        }
    }

    /**
    * @dev updates the state of the user as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _originationFeeRepaid the fee on the amount that is being repaid
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _repaidWholeLoan true if the user is repaying the whole loan
    **/
    function updateUserStateOnRepayInternal(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _originationFeeRepaid,
        uint256 _balanceIncrease,
        bool _repaidWholeLoan
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        //update the user principal borrow balance, adding the cumulated interest and then subtracting the payback amount
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(
            _paybackAmountMinusFees
        );
        user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;

        //if the balance decrease is equal to the previous principal (user is repaying the whole loan)
        //and the rate mode is stable, we reset the interest rate mode of the user
        if (_repaidWholeLoan) {
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = 0;
        }
        user.originationFee = user.originationFee.sub(_originationFeeRepaid);

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

    }

    /**
    * @dev updates the state of the user as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is performing the rate swap
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the the principal amount borrowed by the user
    * @param _compoundedBorrowBalance the principal amount plus the accrued interest
    * @param _currentRateMode the rate mode at which the user borrowed
    **/
    function updateReserveStateOnSwapRateInternal(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _compoundedBorrowBalance,
        CoreLibrary.InterestRateMode _currentRateMode
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        //compounding reserve indexes
        reserve.updateCumulativeIndexes();

        if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {
            uint256 userCurrentStableRate = user.stableBorrowRate;

            //swap to variable
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _principalBorrowBalance,
                userCurrentStableRate
            ); //decreasing stable from old principal balance
            reserve.increaseTotalBorrowsVariable(_compoundedBorrowBalance); //increase variable borrows
        } else if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //swap to stable
            uint256 currentStableRate = reserve.currentStableBorrowRate;
            reserve.decreaseTotalBorrowsVariable(_principalBorrowBalance);
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _compoundedBorrowBalance,
                currentStableRate
            );

        } else {
            revert("Invalid rate mode received");
        }
    }

    /**
    * @dev updates the state of the user as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is performing the swap
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _currentRateMode the current rate mode of the user
    **/

    function updateUserStateOnSwapRateInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease,
        CoreLibrary.InterestRateMode _currentRateMode
    ) internal returns (CoreLibrary.InterestRateMode) {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        CoreLibrary.InterestRateMode newMode = CoreLibrary.InterestRateMode.NONE;

        if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //switch to stable
            newMode = CoreLibrary.InterestRateMode.STABLE;
            user.stableBorrowRate = reserve.currentStableBorrowRate;
            user.lastVariableBorrowCumulativeIndex = 0;
        } else if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {
            newMode = CoreLibrary.InterestRateMode.VARIABLE;
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        } else {
            revert("Invalid interest rate mode received");
        }
        //compounding cumulated interest
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);
        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

        return newMode;
    }

    /**
    * @dev updates the state of the principal reserve as a consequence of a liquidation action.
    * @param _principalReserve the address of the principal reserve that is being repaid
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updatePrincipalReserveStateOnLiquidationInternal(
        address _principalReserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_principalReserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_principalReserve];

        //update principal reserve data
        reserve.updateCumulativeIndexes();

        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(
            _principalReserve,
            _user
        );

        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            //increase the total borrows by the compounded interest
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _balanceIncrease,
                user.stableBorrowRate
            );

            //decrease by the actual amount to liquidate
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _amountToLiquidate,
                user.stableBorrowRate
            );

        } else {
            //increase the total borrows by the compounded interest
            reserve.increaseTotalBorrowsVariable(_balanceIncrease);

            //decrease by the actual amount to liquidate
            reserve.decreaseTotalBorrowsVariable(_amountToLiquidate);
        }

    }

    /**
    * @dev updates the state of the collateral reserve as a consequence of a liquidation action.
    * @param _collateralReserve the address of the collateral reserve that is being liquidated
    **/
    function updateCollateralReserveStateOnLiquidationInternal(
        address _collateralReserve
    ) internal {
        //update collateral reserve
        reserves[_collateralReserve].updateCumulativeIndexes();

    }

    /**
    * @dev updates the state of the user being liquidated as a consequence of a liquidation action.
    * @param _reserve the address of the principal reserve that is being repaid
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _feeLiquidated the amount of origination fee being liquidated
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/
    function updateUserStateOnLiquidationInternal(
        address _reserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _feeLiquidated,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        //first increase by the compounded interest, then decrease by the liquidated amount
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(
            _amountToLiquidate
        );

        if (
            getUserCurrentBorrowRateMode(_reserve, _user) == CoreLibrary.InterestRateMode.VARIABLE
        ) {
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        }

        if(_feeLiquidated > 0){
            user.originationFee = user.originationFee.sub(_feeLiquidated);
        }

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);
    }

    /**
    * @dev updates the state of the reserve as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateReserveStateOnRebalanceInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        reserve.updateCumulativeIndexes();

        reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
            _balanceIncrease,
            user.stableBorrowRate
        );

    }

    /**
    * @dev updates the state of the user as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateUserStateOnRebalanceInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);
        user.stableBorrowRate = reserve.currentStableBorrowRate;

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);
    }

    /**
    * @dev updates the state of the user as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _amountBorrowed the accrued interest on the borrowed amount
    **/
    function updateReserveTotalBorrowsByRateModeInternal(
        address _reserve,
        address _user,
        uint256 _principalBalance,
        uint256 _balanceIncrease,
        uint256 _amountBorrowed,
        CoreLibrary.InterestRateMode _newBorrowRateMode
    ) internal {
        CoreLibrary.InterestRateMode previousRateMode = getUserCurrentBorrowRateMode(
            _reserve,
            _user
        );
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        if (previousRateMode == CoreLibrary.InterestRateMode.STABLE) {
            CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _principalBalance,
                user.stableBorrowRate
            );
        } else if (previousRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            reserve.decreaseTotalBorrowsVariable(_principalBalance);
        }

        uint256 newPrincipalAmount = _principalBalance.add(_balanceIncrease).add(_amountBorrowed);
        if (_newBorrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                newPrincipalAmount,
                reserve.currentStableBorrowRate
            );
        } else if (_newBorrowRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            reserve.increaseTotalBorrowsVariable(newPrincipalAmount);
        } else {
            revert("Invalid new borrow rate mode");
        }
    }

    /**
    * @dev Updates the reserve current stable borrow rate Rf, the current variable borrow rate Rv and the current liquidity rate Rl.
    * Also updates the lastUpdateTimestamp value. Please refer to the whitepaper for further information.
    * @param _reserve the address of the reserve to be updated
    * @param _liquidityAdded the amount of liquidity added to the protocol (deposit or repay) in the previous action
    * @param _liquidityTaken the amount of liquidity taken from the protocol (redeem or borrow)
    **/

    function updateReserveInterestRatesAndTimestampInternal(
        address _reserve,
        uint256 _liquidityAdded,
        uint256 _liquidityTaken
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        (uint256 newLiquidityRate, uint256 newStableRate, uint256 newVariableRate) = IReserveInterestRateStrategy(
            reserve
            .interestRateStrategyAddress
        )
        .calculateInterestRates(
            _reserve,
            getReserveAvailableLiquidity(_reserve).add(_liquidityAdded).sub(_liquidityTaken),
            reserve.totalBorrowsStable,
            reserve.totalBorrowsVariable,
            reserve.currentAverageStableBorrowRate
        );

        reserve.currentLiquidityRate = newLiquidityRate;
        reserve.currentStableBorrowRate = newStableRate;
        reserve.currentVariableBorrowRate = newVariableRate;

        //solium-disable-next-line
        reserve.lastUpdateTimestamp = uint40(block.timestamp);

        emit ReserveUpdated(
            _reserve,
            newLiquidityRate,
            newStableRate,
            newVariableRate,
            reserve.lastLiquidityCumulativeIndex,
            reserve.lastVariableBorrowCumulativeIndex
        );
    }

    /**
    * @dev transfers to the protocol fees of a flashloan to the fees collection address
    * @param _token the address of the token being transferred
    * @param _amount the amount being transferred
    **/

    function transferFlashLoanProtocolFeeInternal(address _token, uint256 _amount) internal {
        address payable receiver = address(uint160(addressesProvider.getTokenDistributor()));

        if (_token != EthAddressLib.ethAddress()) {
            ERC20(_token).safeTransfer(receiver, _amount);
        } else {
            receiver.transfer(_amount);
        }
    }

    /**
    * @dev updates the internal configuration of the core
    **/
    function refreshConfigInternal() internal {
        lendingPoolAddress = addressesProvider.getLendingPool();
    }

    /**
    * @dev adds a reserve to the array of the reserves address
    **/
    function addReserveToListInternal(address _reserve) internal {
        bool reserveAlreadyAdded = false;
        for (uint256 i = 0; i < reservesList.length; i++)
            if (reservesList[i] == _reserve) {
                reserveAlreadyAdded = true;
            }
        if (!reserveAlreadyAdded) reservesList.push(_reserve);
    }

}
.]

Based on the provided smart contract code for the `LendingPoolCore` contract, here is a succinct summary of the identified security vulnerabilities:

### Summary of Security Vulnerabilities:

1. **Lack of Input Validation**:
   - Several functions do not validate input parameters thoroughly, which could lead to unexpected behavior or state changes. For example, functions like `transferToUser`, `transferToFeeCollectionAddress`, and `transferToReserve` do not check if the `_amount` is greater than zero.

2. **Reentrancy Risks**:
   - The contract allows for external calls (e.g., transferring ETH or tokens) without proper reentrancy guards. This can lead to reentrancy attacks, especially in functions that modify state after external calls, such as `transferToUser` and `transferToReserve`.

3. **Missing Event Emissions**:
   - Certain state-changing functions do not emit events, which can hinder tracking and auditing of contract interactions. For example, functions like `setUserUseReserveAsCollateral` and `updateStateOnDeposit` should emit events to log significant state changes.

4. **Gas Limit Issues**:
   - The use of `.call.value()` with a fixed gas limit (e.g., `gas(50000)`) may lead to failures if the gas limit is exceeded. This could affect the transfer functions that rely on external contracts.

5. **Potential Integer Overflow/Underflow**:
   - Although the contract uses `SafeMath`, there are instances where operations could still lead to unexpected results if not properly handled, especially in complex calculations involving user balances and interest rates.

6. **Access Control Weaknesses**:
   - The `onlyLendingPool` and `onlyLendingPoolConfigurator` modifiers are used to restrict access, but there could be scenarios where unauthorized contracts could gain access if the lending pool address is compromised.

7. **Improper Handling of ETH Transfers**:
   - The fallback function only allows contracts to send ETH, which may lead to issues if a user mistakenly sends ETH directly to the contract. This could result in lost funds.

8. **Lack of Upgradeability Checks**:
   - The contract does not implement checks for upgradeability or versioning, which could lead to issues if the contract is upgraded without proper migration of state or logic.

### Comprehensive Analysis Report:

The `LendingPoolCore` contract is a critical component of a lending protocol, managing deposits, borrows, and interest rates. While it incorporates several best practices, such as using `SafeMath` and modular design, it also presents multiple security vulnerabilities that could be exploited.

The lack of input validation and reentrancy protections are particularly concerning, as they could lead to significant financial losses. Additionally, missing event emissions hinder transparency and auditability, making it difficult to trace actions taken on the contract.

The potential for integer overflow/underflow, despite the use of `SafeMath`, indicates that careful attention must be paid to arithmetic operations. Furthermore, access control weaknesses could allow unauthorized access to sensitive functions, posing a risk to the integrity of the lending pool.

To mitigate these vulnerabilities, it is recommended to implement the following measures:
- Introduce comprehensive input validation across all functions.
- Implement reentrancy guards in functions that involve external calls.
- Ensure that all state-changing functions emit relevant events.
- Review and adjust gas limits for external calls to prevent failures.
- Conduct thorough testing and audits to identify and resolve any potential integer overflow/underflow issues.
- Strengthen access control mechanisms to ensure only authorized contracts can interact with sensitive functions.
- Consider implementing upgradeability patterns to facilitate future enhancements without compromising security.

By addressing these vulnerabilities, the contract can enhance its security posture and protect users' funds more effectively.

[2024-01-09 04:32:12 INFO] **[Seminar Conclusion]**:

 Based on the provided smart contract code for the `LendingPoolCore` contract, here is a succinct summary of the identified security vulnerabilities:

### Summary of Security Vulnerabilities:

1. **Lack of Input Validation**:
   - Several functions do not validate input parameters thoroughly, which could lead to unexpected behavior or state changes. For example, functions like `transferToUser`, `transferToFeeCollectionAddress`, and `transferToReserve` do not check if the `_amount` is greater than zero.

2. **Reentrancy Risks**:
   - The contract allows for external calls (e.g., transferring ETH or tokens) without proper reentrancy guards. This can lead to reentrancy attacks, especially in functions that modify state after external calls, such as `transferToUser` and `transferToReserve`.

3. **Missing Event Emissions**:
   - Certain state-changing functions do not emit events, which can hinder tracking and auditing of contract interactions. For example, functions like `setUserUseReserveAsCollateral` and `updateStateOnDeposit` should emit events to log significant state changes.

4. **Gas Limit Issues**:
   - The use of `.call.value()` with a fixed gas limit (e.g., `gas(50000)`) may lead to failures if the gas limit is exceeded. This could affect the transfer functions that rely on external contracts.

5. **Potential Integer Overflow/Underflow**:
   - Although the contract uses `SafeMath`, there are instances where operations could still lead to unexpected results if not properly handled, especially in complex calculations involving user balances and interest rates.

6. **Access Control Weaknesses**:
   - The `onlyLendingPool` and `onlyLendingPoolConfigurator` modifiers are used to restrict access, but there could be scenarios where unauthorized contracts could gain access if the lending pool address is compromised.

7. **Improper Handling of ETH Transfers**:
   - The fallback function only allows contracts to send ETH, which may lead to issues if a user mistakenly sends ETH directly to the contract. This could result in lost funds.

8. **Lack of Upgradeability Checks**:
   - The contract does not implement checks for upgradeability or versioning, which could lead to issues if the contract is upgraded without proper migration of state or logic.

### Comprehensive Analysis Report:

The `LendingPoolCore` contract is a critical component of a lending protocol, managing deposits, borrows, and interest rates. While it incorporates several best practices, such as using `SafeMath` and modular design, it also presents multiple security vulnerabilities that could be exploited.

The lack of input validation and reentrancy protections are particularly concerning, as they could lead to significant financial losses. Additionally, missing event emissions hinder transparency and auditability, making it difficult to trace actions taken on the contract.

The potential for integer overflow/underflow, despite the use of `SafeMath`, indicates that careful attention must be paid to arithmetic operations. Furthermore, access control weaknesses could allow unauthorized access to sensitive functions, posing a risk to the integrity of the lending pool.

To mitigate these vulnerabilities, it is recommended to implement the following measures:
- Introduce comprehensive input validation across all functions.
- Implement reentrancy guards in functions that involve external calls.
- Ensure that all state-changing functions emit relevant events.
- Review and adjust gas limits for external calls to prevent failures.
- Conduct thorough testing and audits to identify and resolve any potential integer overflow/underflow issues.
- Strengthen access control mechanisms to ensure only authorized contracts can interact with sensitive functions.
- Consider implementing upgradeability patterns to facilitate future enhancements without compromising security.

By addressing these vulnerabilities, the contract can enhance its security posture and protect users' funds more effectively.

[2024-01-09 04:32:16 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | pragma solidity ^0.5.0; import "openzeppelin-solidity/contracts/math/SafeMath.sol"; import "openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol"; import "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol"; import "openzeppelin-solidity/contracts/utils/Address.sol"; import "../libraries/openzeppelin-upgradeability/VersionedInitializable.sol"; import "../libraries/CoreLibrary.sol"; import "../configuration/LendingPoolAddressesProvider.sol"; import "../interfaces/ILendingRateOracle.sol"; import "../interfaces/IReserveInterestRateStrategy.sol"; import "../libraries/WadRayMath.sol"; import "../tokenization/AToken.sol"; import "../libraries/EthAddressLib.sol"; / * @title LendingPoolCore contract * @author Aave * @notice Holds the state of the lending pool and all the funds deposited * @dev NOTE: The core does not enforce security checks on the update of the state * (eg, updateStateOnBorrow() does not enforce that borrowed is enabled on the reserve). * The check that an action can be performed is a duty of the overlying LendingPool contract. / contract LendingPoolCore is VersionedInitializable {     using SafeMath for uint256;     using WadRayMath for uint256;     using CoreLibrary for CoreLibrary.ReserveData;     using CoreLibrary for CoreLibrary.UserReserveData;     using SafeERC20 for ERC20;     using Address for address payable; /** * @dev Emitted when the state of a reserve is updated * @param reserve the address of the reserve * @param liquidityRate the new liquidity rate * @param stableBorrowRate the new stable borrow rate * @param variableBorrowRate the new variable borrow rate * @param liquidityIndex the new liquidity index * @param variableBorrowIndex the new variable borrow index **/ event ReserveUpdated(     address indexed reserve,     uint256 liquidityRate,     uint256 stableBorrowRate,     uint256 variableBorrowRate,     uint256 liquidityIndex,     uint256 variableBorrowIndex );  address public lendingPoolAddress;  LendingPoolAddressesProvider public addressesProvider;  /** * @dev only lending pools can use functions affected by this modifier **/ modifier onlyLendingPool {     require(lendingPoolAddress == msg.sender, "The caller must be a lending pool contract");     _; }  /** * @dev only lending pools configurator can use functions affected by this modifier **/ modifier onlyLendingPoolConfigurator {     require(         addressesProvider.getLendingPoolConfigurator() == msg.sender,         "The caller must be a lending pool configurator contract"     );     _; }  mapping(address =&gt; CoreLibrary.ReserveData) internal reserves; mapping(address =&gt; mapping(address =&gt; CoreLibrary.UserReserveData)) internal usersReserveData;  address[] public reservesList;  uint256 public constant CORE_REVISION = 0x4;  /** * @dev returns the revision number of the contract **/ function getRevision() internal pure returns (uint256) {     return CORE_REVISION; }  /** * @dev initializes the Core contract, invoked upon registration on the AddressesProvider * @param _addressesProvider the addressesProvider contract **/  function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {     addressesProvider = _addressesProvider;     refreshConfigInternal(); }  /** * @dev updates the state of the core as a result of a deposit action * @param _reserve the address of the reserve in which the deposit is happening * @param _user the address of the the user depositing * @param _amount the amount being deposited * @param _isFirstDeposit true if the user is depositing for the first time **/  function updateStateOnDeposit(     address _reserve,     address _user,     uint256 _amount,     bool _isFirstDeposit ) external onlyLendingPool {     reserves[_reserve].updateCumulativeIndexes();     updateReserveInterestRatesAndTimestampInternal(_reserve, _amount, 0);      if (_isFirstDeposit) {         //if this is the first deposit of the user, we configure the deposit as enabled to be used as collateral         setUserUseReserveAsCollateral(_reserve, _user, true);     } }  /** * @dev updates the state of the core as a result of a redeem action * @param _reserve the address of the reserve in which the redeem is happening * @param _user the address of the the user redeeming * @param _amountRedeemed the amount being redeemed * @param _userRedeemedEverything true if the user is redeeming everything **/ function updateStateOnRedeem(     address _reserve,     address _user,     uint256 _amountRedeemed,     bool _userRedeemedEverything ) external onlyLendingPool {     //compound liquidity and variable borrow interests     reserves[_reserve].updateCumulativeIndexes();     updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountRedeemed);      //if user redeemed everything the useReserveAsCollateral flag is reset     if (_userRedeemedEverything) {         setUserUseReserveAsCollateral(_reserve, _user, false);     } }  /** * @dev updates the state of the core as a result of a flashloan action * @param _reserve the address of the reserve in which the flashloan is happening * @param _income the income of the protocol as a result of the action **/ function updateStateOnFlashLoan(     address _reserve,     uint256 _availableLiquidityBefore,     uint256 _income,     uint256 _protocolFee ) external onlyLendingPool {     transferFlashLoanProtocolFeeInternal(_reserve, _protocolFee);      //compounding the cumulated interest     reserves[_reserve].updateCumulativeIndexes();      uint256 totalLiquidityBefore = _availableLiquidityBefore.add(         getReserveTotalBorrows(_reserve)     );      //compounding the received fee into the reserve     reserves[_reserve].cumulateToLiquidityIndex(totalLiquidityBefore, _income);      //refresh interest rates     updateReserveInterestRatesAndTimestampInternal(_reserve, _income, 0); }  /** * @dev updates the state of the core as a consequence of a borrow action. * @param _reserve the address of the reserve on which the user is borrowing * @param _user the address of the borrower * @param _amountBorrowed the new amount borrowed * @param _borrowFee the fee on the amount borrowed * @param _rateMode the borrow rate mode (stable, variable) * @return the new borrow rate for the user **/ function updateStateOnBorrow(     address _reserve,     address _user,     uint256 _amountBorrowed,     uint256 _borrowFee,     CoreLibrary.InterestRateMode _rateMode ) external onlyLendingPool returns (uint256, uint256) {     // getting the previous borrow data of the user     (uint256 principalBorrowBalance, , uint256 balanceIncrease) = getUserBorrowBalances(         _reserve,         _user     );      updateReserveStateOnBorrowInternal(         _reserve,         _user,         principalBorrowBalance,         balanceIncrease,         _amountBorrowed,         _rateMode     );      updateUserStateOnBorrowInternal(         _reserve,         _user,         _amountBorrowed,         balanceIncrease,         _borrowFee,         _rateMode     );      updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountBorrowed);      return (getUserCurrentBorrowRate(_reserve, _user), balanceIncrease); }  /** * @dev updates the state of the core as a consequence of a repay action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _paybackAmountMinusFees the amount being paid back minus fees * @param _originationFeeRepaid the fee on the amount that is being repaid * @param _balanceIncrease the accrued interest on the borrowed amount * @param _repaidWholeLoan true if the user is repaying the whole loan **/  function updateStateOnRepay(     address _reserve,     address _user,     uint256 _paybackAmountMinusFees,     uint256 _originationFeeRepaid,     uint256 _balanceIncrease,     bool _repaidWholeLoan ) external onlyLendingPool {     updateReserveStateOnRepayInternal(         _reserve,         _user,         _paybackAmountMinusFees,         _balanceIncrease     );     updateUserStateOnRepayInternal(         _reserve,         _user,         _paybackAmountMinusFees,         _originationFeeRepaid,         _balanceIncrease,         _repaidWholeLoan     );      updateReserveInterestRatesAndTimestampInternal(_reserve, _paybackAmountMinusFees, 0); }  /** * @dev updates the state of the core as a consequence of a swap rate action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _principalBorrowBalance the amount borrowed by the user * @param _compoundedBorrowBalance the amount borrowed plus accrued interest * @param _balanceIncrease the accrued interest on the borrowed amount * @param _currentRateMode the current interest rate mode for the user **/ function updateStateOnSwapRate(     address _reserve,     address _user,     uint256 _principalBorrowBalance,     uint256 _compoundedBorrowBalance,     uint256 _balanceIncrease,     CoreLibrary.InterestRateMode _currentRateMode ) external onlyLendingPool returns (CoreLibrary.InterestRateMode, uint256) {     updateReserveStateOnSwapRateInternal(         _reserve,         _user,         _principalBorrowBalance,         _compoundedBorrowBalance,         _currentRateMode     );      CoreLibrary.InterestRateMode newRateMode = updateUserStateOnSwapRateInternal(         _reserve,         _user,         _balanceIncrease,         _currentRateMode     );      updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);      return (newRateMode, getUserCurrentBorrowRate(_reserve, _user)); }  /** * @dev updates the state of the core as a consequence of a liquidation action. * @param _principalReserve the address of the principal reserve that is being repaid * @param _collateralReserve the address of the collateral reserve that is being liquidated * @param _user the address of the borrower * @param _amountToLiquidate the amount being repaid by the liquidator * @param _collateralToLiquidate the amount of collateral being liquidated * @param _feeLiquidated the amount of origination fee being liquidated * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus * @param _balanceIncrease the accrued interest on the borrowed amount * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise **/ function updateStateOnLiquidation(     address _principalReserve,     address _collateralReserve,     address _user,     uint256 _amountToLiquidate,     uint256 _collateralToLiquidate,     uint256 _feeLiquidated,     uint256 _liquidatedCollateralForFee,     uint256 _balanceIncrease,     bool _liquidatorReceivesAToken ) external onlyLendingPool {     updatePrincipalReserveStateOnLiquidationInternal(         _principalReserve,         _user,         _amountToLiquidate,         _balanceIncrease     );      updateCollateralReserveStateOnLiquidationInternal(         _collateralReserve     );      updateUserStateOnLiquidationInternal(         _principalReserve,         _user,         _amountToLiquidate,         _feeLiquidated,         _balanceIncrease     );      updateReserveInterestRatesAndTimestampInternal(_principalReserve, _amountToLiquidate, 0);      if (!_liquidatorReceivesAToken) {         updateReserveInterestRatesAndTimestampInternal(             _collateralReserve,             0,             _collateralToLiquidate.add(_liquidatedCollateralForFee)         );     }  }  /** * @dev updates the state of the core as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount * @return the new stable rate for the user **/ function updateStateOnRebalance(address _reserve, address _user, uint256 _balanceIncrease) external onlyLendingPool returns (uint256) {     updateReserveStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);      //update user data and rebalance the rate     updateUserStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);     updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);     return usersReserveData[_user][_reserve].stableBorrowRate; }  /** * @dev enables or disables a reserve as collateral * @param _reserve the address of the principal reserve where the user deposited * @param _user the address of the depositor * @param _useAsCollateral true if the depositor wants to use the reserve as collateral **/ function setUserUseReserveAsCollateral(address _reserve, address _user, bool _useAsCollateral) public onlyLendingPool {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     user.useAsCollateral = _useAsCollateral; }  /** * @notice ETH/token transfer functions **/  /** * @dev fallback function enforces that the caller is a contract, to support flashloan transfers **/ function() external payable {     //only contracts can send ETH to the core     require(msg.sender.isContract(), "Only contracts can send ether to the Lending pool core");  }  /** * @dev transfers to the user a specific amount from the reserve. * @param _reserve the address of the reserve where the transfer is happening * @param _user the address of the user receiving the transfer * @param _amount the amount being transferred **/ function transferToUser(address _reserve, address payable _user, uint256 _amount) external onlyLendingPool {     if (_reserve != EthAddressLib.ethAddress()) {         ERC20(_reserve).safeTransfer(_user, _amount);     } else {         //solium-disable-next-line         (bool result, ) = _user.call.value(_amount).gas(50000)("");         require(result, "Transfer of ETH failed");     } }  /** * @dev transfers the protocol fees to the fees collection address * @param _token the address of the token being transferred * @param _user the address of the user from where the transfer is happening * @param _amount the amount being transferred * @param _destination the fee receiver address **/  function transferToFeeCollectionAddress(     address _token,     address _user,     uint256 _amount,     address _destination ) external payable onlyLendingPool {     address payable feeAddress = address(uint160(_destination)); //cast the address to payable      if (_token != EthAddressLib.ethAddress()) {         require(             msg.value == 0,             "User is sending ETH along with the ERC20 transfer. Check the value attribute of the transaction"         );         ERC20(_token).safeTransferFrom(_user, feeAddress, _amount);     } else {         require(msg.value &gt;= _amount, "The amount and the value sent to deposit do not match");         //solium-disable-next-line         (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");         require(result, "Transfer of ETH failed");     } }  /** * @dev transfers the fees to the fees collection address in the case of liquidation * @param _token the address of the token being transferred * @param _amount the amount being transferred * @param _destination the fee receiver address **/ function liquidateFee(     address _token,     uint256 _amount,     address _destination ) external payable onlyLendingPool {     address payable feeAddress = address(uint160(_destination)); //cast the address to payable     require(         msg.value == 0,         "Fee liquidation does not require any transfer of value"     );      if (_token != EthAddressLib.ethAddress()) {         ERC20(_token).safeTransfer(feeAddress, _amount);     } else {         //solium-disable-next-line         (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");         require(result, "Transfer of ETH failed");     } }  /** * @dev transfers an amount from a user to the destination reserve * @param _reserve the address of the reserve where the amount is being transferred * @param _user the address of the user from where the transfer is happening * @param _amount the amount being transferred **/ function transferToReserve(address _reserve, address payable _user, uint256 _amount) external payable onlyLendingPool {     if (_reserve != EthAddressLib.ethAddress()) {         require(msg.value == 0, "User is sending ETH along with the ERC20 transfer.");         ERC20(_reserve).safeTransferFrom(_user, address(this), _amount);      } else {         require(msg.value &gt;= _amount, "The amount and the value sent to deposit do not match");          if (msg.value &gt; _amount) {             //send back excess ETH             uint256 excessAmount = msg.value.sub(_amount);             //solium-disable-next-line             (bool result, ) = _user.call.value(excessAmount).gas(50000)("");             require(result, "Transfer of ETH failed");         }     } }  /** * @notice data access functions **/  /** * @dev returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral) * needed to calculate the global account data in the LendingPoolDataProvider * @param _reserve the address of the reserve * @param _user the address of the user * @return the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not **/ function getUserBasicReserveData(address _reserve, address _user) external view returns (uint256, uint256, uint256, bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      uint256 underlyingBalance = getUserUnderlyingAssetBalance(_reserve, _user);      if (user.principalBorrowBalance == 0) {         return (underlyingBalance, 0, 0, user.useAsCollateral);     }      return (     underlyingBalance,     user.getCompoundedBorrowBalance(reserve),     user.originationFee,     user.useAsCollateral     ); }  /** * @dev checks if a user is allowed to borrow at a stable rate * @param _reserve the reserve address * @param _user the user * @param _amount the amount the the user wants to borrow * @return true if the user is allowed to borrow at a stable rate, false otherwise **/  function isUserAllowedToBorrowAtStable(address _reserve, address _user, uint256 _amount) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      if (!reserve.isStableBorrowRateEnabled) return false;      return     !user.useAsCollateral ||     !reserve.usageAsCollateralEnabled ||     _amount &gt; getUserUnderlyingAssetBalance(_reserve, _user); }  /** * @dev gets the underlying asset balance of a user based on the corresponding aToken balance. * @param _reserve the reserve address * @param _user the user address * @return the underlying deposit balance of the user **/  function getUserUnderlyingAssetBalance(address _reserve, address _user) public view returns (uint256) {     AToken aToken = AToken(reserves[_reserve].aTokenAddress);     return aToken.balanceOf(_user);  }  /** * @dev gets the interest rate strategy contract address for the reserve * @param _reserve the reserve address * @return the address of the interest rate strategy contract **/ function getReserveInterestRateStrategyAddress(address _reserve) public view returns (address) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.interestRateStrategyAddress; }  /** * @dev gets the aToken contract address for the reserve * @param _reserve the reserve address * @return the address of the aToken contract **/  function getReserveATokenAddress(address _reserve) public view returns (address) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.aTokenAddress; }  /** * @dev gets the available liquidity in the reserve. The available liquidity is the balance of the core contract * @param _reserve the reserve address * @return the available liquidity **/ function getReserveAvailableLiquidity(address _reserve) public view returns (uint256) {     uint256 balance = 0;      if (_reserve == EthAddressLib.ethAddress()) {         balance = address(this).balance;     } else {         balance = IERC20(_reserve).balanceOf(address(this));     }     return balance; }  /** * @dev gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows * @param _reserve the reserve address * @return the total liquidity **/ function getReserveTotalLiquidity(address _reserve) public view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return getReserveAvailableLiquidity(_reserve).add(reserve.getTotalBorrows()); }  /** * @dev gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there * there has been 100% income. * @param _reserve the reserve address * @return the reserve normalized income **/ function getReserveNormalizedIncome(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.getNormalizedIncome(); }  /** * @dev gets the reserve total borrows * @param _reserve the reserve address * @return the total borrows (stable + variable) **/ function getReserveTotalBorrows(address _reserve) public view returns (uint256) {     return reserves[_reserve].getTotalBorrows(); }  /** * @dev gets the reserve total borrows stable * @param _reserve the reserve address * @return the total borrows stable **/ function getReserveTotalBorrowsStable(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.totalBorrowsStable; }  /** * @dev gets the reserve total borrows variable * @param _reserve the reserve address * @return the total borrows variable **/  function getReserveTotalBorrowsVariable(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.totalBorrowsVariable; }  /** * @dev gets the reserve liquidation threshold * @param _reserve the reserve address * @return the reserve liquidation threshold **/  function getReserveLiquidationThreshold(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.liquidationThreshold; }  /** * @dev gets the reserve liquidation bonus * @param _reserve the reserve address * @return the reserve liquidation bonus **/  function getReserveLiquidationBonus(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.liquidationBonus; }  /** * @dev gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty * @param _reserve the reserve address * @return the reserve current variable borrow rate **/  function getReserveCurrentVariableBorrowRate(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      if (reserve.currentVariableBorrowRate == 0) {         return         IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)         .getBaseVariableBorrowRate();     }     return reserve.currentVariableBorrowRate; }  /** * @dev gets the reserve current stable borrow rate. Is the market rate if the reserve is empty * @param _reserve the reserve address * @return the reserve current stable borrow rate **/  function getReserveCurrentStableBorrowRate(address _reserve) public view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     ILendingRateOracle oracle = ILendingRateOracle(addressesProvider.getLendingRateOracle());      if (reserve.currentStableBorrowRate == 0) {         //no stable rate borrows yet         return oracle.getMarketBorrowRate(_reserve);     }      return reserve.currentStableBorrowRate; }  /** * @dev gets the reserve average stable borrow rate. The average stable rate is the weighted average * of all the loans taken at stable rate. * @param _reserve the reserve address * @return the reserve current average borrow rate **/ function getReserveCurrentAverageStableBorrowRate(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.currentAverageStableBorrowRate; }  /** * @dev gets the reserve liquidity rate * @param _reserve the reserve address * @return the reserve liquidity rate **/ function getReserveCurrentLiquidityRate(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.currentLiquidityRate; }  /** * @dev gets the reserve liquidity cumulative index * @param _reserve the reserve address * @return the reserve liquidity cumulative index **/ function getReserveLiquidityCumulativeIndex(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.lastLiquidityCumulativeIndex; }  /** * @dev gets the reserve variable borrow index * @param _reserve the reserve address * @return the reserve variable borrow index **/ function getReserveVariableBorrowsCumulativeIndex(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.lastVariableBorrowCumulativeIndex; }  /** * @dev this function aggregates the configuration parameters of the reserve. * It's used in the LendingPoolDataProvider specifically to save gas, and avoid * multiple external contract calls to fetch the same data. * @param _reserve the reserve address * @return the reserve decimals * @return the base ltv as collateral * @return the liquidation threshold * @return if the reserve is used as collateral or not **/ function getReserveConfiguration(address _reserve) external view returns (uint256, uint256, uint256, bool) {     uint256 decimals;     uint256 baseLTVasCollateral;     uint256 liquidationThreshold;     bool usageAsCollateralEnabled;      CoreLibrary.ReserveData storage reserve = reserves[_reserve];     decimals = reserve.decimals;     baseLTVasCollateral = reserve.baseLTVasCollateral;     liquidationThreshold = reserve.liquidationThreshold;     usageAsCollateralEnabled = reserve.usageAsCollateralEnabled;      return (decimals, baseLTVasCollateral, liquidationThreshold, usageAsCollateralEnabled); }  /** * @dev returns the decimals of the reserve * @param _reserve the reserve address * @return the reserve decimals **/ function getReserveDecimals(address _reserve) external view returns (uint256) {     return reserves[_reserve].decimals; }  /** * @dev returns true if the reserve is enabled for borrowing * @param _reserve the reserve address * @return true if the reserve is enabled for borrowing, false otherwise **/  function isReserveBorrowingEnabled(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.borrowingEnabled; }  /** * @dev returns true if the reserve is enabled as collateral * @param _reserve the reserve address * @return true if the reserve is enabled as collateral, false otherwise **/  function isReserveUsageAsCollateralEnabled(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.usageAsCollateralEnabled; }  /** * @dev returns true if the stable rate is enabled on reserve * @param _reserve the reserve address * @return true if the stable rate is enabled on reserve, false otherwise **/ function getReserveIsStableBorrowRateEnabled(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.isStableBorrowRateEnabled; }  /** * @dev returns true if the reserve is active * @param _reserve the reserve address * @return true if the reserve is active, false otherwise **/ function getReserveIsActive(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.isActive; }  /** * @notice returns if a reserve is freezed * @param _reserve the reserve for which the information is needed * @return true if the reserve is freezed, false otherwise **/  function getReserveIsFreezed(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.isFreezed; }  /** * @notice returns the timestamp of the last action on the reserve * @param _reserve the reserve for which the information is needed * @return the last updated timestamp of the reserve **/  function getReserveLastUpdate(address _reserve) external view returns (uint40 timestamp) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     timestamp = reserve.lastUpdateTimestamp; }  /** * @dev returns the utilization rate U of a specific reserve * @param _reserve the reserve for which the information is needed * @return the utilization rate in ray **/  function getReserveUtilizationRate(address _reserve) public view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      uint256 totalBorrows = reserve.getTotalBorrows();      if (totalBorrows == 0) {         return 0;     }      uint256 availableLiquidity = getReserveAvailableLiquidity(_reserve);      return totalBorrows.rayDiv(availableLiquidity.add(totalBorrows)); }  /** * @return the array of reserves configured on the core **/ function getReserves() external view returns (address[] memory) {     return reservesList; }  /** * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return true if the user has chosen to use the reserve as collateral, false otherwise **/ function isUserUseReserveAsCollateralEnabled(address _reserve, address _user) external view returns (bool) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.useAsCollateral; }  /** * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the origination fee for the user **/ function getUserOriginationFee(address _reserve, address _user) external view returns (uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.originationFee; }  /** * @dev users with no loans in progress have NONE as borrow rate mode * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the borrow rate mode for the user, **/  function getUserCurrentBorrowRateMode(address _reserve, address _user) public view returns (CoreLibrary.InterestRateMode) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      if (user.principalBorrowBalance == 0) {         return CoreLibrary.InterestRateMode.NONE;     }      return     user.stableBorrowRate &gt; 0     ? CoreLibrary.InterestRateMode.STABLE     : CoreLibrary.InterestRateMode.VARIABLE; }  /** * @dev gets the current borrow rate of the user * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the borrow rate for the user, **/ function getUserCurrentBorrowRate(address _reserve, address _user) internal view returns (uint256) {     CoreLibrary.InterestRateMode rateMode = getUserCurrentBorrowRateMode(_reserve, _user);      if (rateMode == CoreLibrary.InterestRateMode.NONE) {         return 0;     }      return     rateMode == CoreLibrary.InterestRateMode.STABLE     ? usersReserveData[_user][_reserve].stableBorrowRate     : reserves[_reserve].currentVariableBorrowRate; }  /** * @dev the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the user stable rate **/ function getUserCurrentStableBorrowRate(address _reserve, address _user) external view returns (uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.stableBorrowRate; }  /** * @dev calculates and returns the borrow balances of the user * @param _reserve the address of the reserve * @param _user the address of the user * @return the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance **/  function getUserBorrowBalances(address _reserve, address _user) public view returns (uint256, uint256, uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     if (user.principalBorrowBalance == 0) {         return (0, 0, 0);     }      uint256 principal = user.principalBorrowBalance;     uint256 compoundedBalance = CoreLibrary.getCompoundedBorrowBalance(         user,         reserves[_reserve]     );     return (principal, compoundedBalance, compoundedBalance.sub(principal)); }  /** * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the variable borrow index for the user **/  function getUserVariableBorrowCumulativeIndex(address _reserve, address _user) external view returns (uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.lastVariableBorrowCumulativeIndex; }  /** * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the variable borrow index for the user **/  function getUserLastUpdate(address _reserve, address _user) external view returns (uint256 timestamp) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     timestamp = user.lastUpdateTimestamp; }  /** * @dev updates the lending pool core configuration **/ function refreshConfiguration() external onlyLendingPoolConfigurator {     refreshConfigInternal(); }  /** * @dev initializes a reserve * @param _reserve the address of the reserve * @param _aTokenAddress the address of the overlying aToken contract * @param _decimals the decimals of the reserve currency * @param _interestRateStrategyAddress the address of the interest rate strategy contract **/ function initReserve(     address _reserve,     address _aTokenAddress,     uint256 _decimals,     address _interestRateStrategyAddress ) external onlyLendingPoolConfigurator {     reserves[_reserve].init(_aTokenAddress, _decimals, _interestRateStrategyAddress);     addReserveToListInternal(_reserve);  }    /** * @dev removes the last added reserve in the reservesList array * @param _reserveToRemove the address of the reserve **/ function removeLastAddedReserve(address _reserveToRemove) external onlyLendingPoolConfigurator {      address lastReserve = reservesList[reservesList.length-1];      require(lastReserve == _reserveToRemove, "Reserve being removed is different than the reserve requested");      //as we can't check if totalLiquidity is 0 (since the reserve added might not be an ERC20) we at least check that there is nothing borrowed     require(getReserveTotalBorrows(lastReserve) == 0, "Cannot remove a reserve with liquidity deposited");      reserves[lastReserve].isActive = false;     reserves[lastReserve].aTokenAddress = address(0);     reserves[lastReserve].decimals = 0;     reserves[lastReserve].lastLiquidityCumulativeIndex = 0;     reserves[lastReserve].lastVariableBorrowCumulativeIndex = 0;     reserves[lastReserve].borrowingEnabled = false;     reserves[lastReserve].usageAsCollateralEnabled = false;     reserves[lastReserve].baseLTVasCollateral = 0;     reserves[lastReserve].liquidationThreshold = 0;     reserves[lastReserve].liquidationBonus = 0;     reserves[lastReserve].interestRateStrategyAddress = address(0);      reservesList.pop(); }  /** * @dev updates the address of the interest rate strategy contract * @param _reserve the address of the reserve * @param _rateStrategyAddress the address of the interest rate strategy contract **/  function setReserveInterestRateStrategyAddress(address _reserve, address _rateStrategyAddress) external onlyLendingPoolConfigurator {     reserves[_reserve].interestRateStrategyAddress = _rateStrategyAddress; }  /** * @dev enables borrowing on a reserve. Also sets the stable rate borrowing * @param _reserve the address of the reserve * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise **/  function enableBorrowingOnReserve(address _reserve, bool _stableBorrowRateEnabled) external onlyLendingPoolConfigurator {     reserves[_reserve].enableBorrowing(_stableBorrowRateEnabled); }  /** * @dev disables borrowing on a reserve * @param _reserve the address of the reserve **/  function disableBorrowingOnReserve(address _reserve) external onlyLendingPoolConfigurator {     reserves[_reserve].disableBorrowing(); }  /** * @dev enables a reserve to be used as collateral * @param _reserve the address of the reserve **/ function enableReserveAsCollateral(     address _reserve,     uint256 _baseLTVasCollateral,     uint256 _liquidationThreshold,     uint256 _liquidationBonus ) external onlyLendingPoolConfigurator {     reserves[_reserve].enableAsCollateral(         _baseLTVasCollateral,         _liquidationThreshold,         _liquidationBonus     ); }  /** * @dev disables a reserve to be used as collateral * @param _reserve the address of the reserve **/ function disableReserveAsCollateral(address _reserve) external onlyLendingPoolConfigurator {     reserves[_reserve].disableAsCollateral(); }  /** * @dev enable the stable borrow rate mode on a reserve * @param _reserve the address of the reserve **/ function enableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isStableBorrowRateEnabled = true; }  /** * @dev disable the stable borrow rate mode on a reserve * @param _reserve the address of the reserve **/ function disableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isStableBorrowRateEnabled = false; }  /** * @dev activates a reserve * @param _reserve the address of the reserve **/ function activateReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      require(         reserve.lastLiquidityCumulativeIndex &gt; 0 &amp;&amp;         reserve.lastVariableBorrowCumulativeIndex &gt; 0,         "Reserve has not been initialized yet"     );     reserve.isActive = true; }  /** * @dev deactivates a reserve * @param _reserve the address of the reserve **/ function deactivateReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isActive = false; }  /** * @notice allows the configurator to freeze the reserve. * A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance. * @param _reserve the address of the reserve **/ function freezeReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isFreezed = true; }  /** * @notice allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed. * @param _reserve the address of the reserve **/ function unfreezeReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isFreezed = false; }  /** * @notice allows the configurator to update the loan to value of a reserve * @param _reserve the address of the reserve * @param _ltv the new loan to value **/ function setReserveBaseLTVasCollateral(address _reserve, uint256 _ltv) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.baseLTVasCollateral = _ltv; }  /** * @notice allows the configurator to update the liquidation threshold of a reserve * @param _reserve the address of the reserve * @param _threshold the new liquidation threshold **/ function setReserveLiquidationThreshold(address _reserve, uint256 _threshold) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.liquidationThreshold = _threshold; }  /** * @notice allows the configurator to update the liquidation bonus of a reserve * @param _reserve the address of the reserve * @param _bonus the new liquidation bonus **/ function setReserveLiquidationBonus(address _reserve, uint256 _bonus) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.liquidationBonus = _bonus; }  /** * @notice allows the configurator to update the reserve decimals * @param _reserve the address of the reserve * @param _decimals the decimals of the reserve **/ function setReserveDecimals(address _reserve, uint256 _decimals) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.decimals = _decimals; }  /** * @notice internal functions **/  /** * @dev updates the state of a reserve as a consequence of a borrow action. * @param _reserve the address of the reserve on which the user is borrowing * @param _user the address of the borrower * @param _principalBorrowBalance the previous borrow balance of the borrower before the action * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount * @param _amountBorrowed the new amount borrowed * @param _rateMode the borrow rate mode (stable, variable) **/  function updateReserveStateOnBorrowInternal(     address _reserve,     address _user,     uint256 _principalBorrowBalance,     uint256 _balanceIncrease,     uint256 _amountBorrowed,     CoreLibrary.InterestRateMode _rateMode ) internal {     reserves[_reserve].updateCumulativeIndexes();      //increasing reserve total borrows to account for the new borrow balance of the user     //NOTE: Depending on the previous borrow mode, the borrows might need to be switched from variable to stable or vice versa      updateReserveTotalBorrowsByRateModeInternal(         _reserve,         _user,         _principalBorrowBalance,         _balanceIncrease,         _amountBorrowed,         _rateMode     ); }  /** * @dev updates the state of a user as a consequence of a borrow action. * @param _reserve the address of the reserve on which the user is borrowing * @param _user the address of the borrower * @param _amountBorrowed the amount borrowed * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount * @param _rateMode the borrow rate mode (stable, variable) * @return the final borrow rate for the user. Emitted by the borrow() event **/  function updateUserStateOnBorrowInternal(     address _reserve,     address _user,     uint256 _amountBorrowed,     uint256 _balanceIncrease,     uint256 _fee,     CoreLibrary.InterestRateMode _rateMode ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      if (_rateMode == CoreLibrary.InterestRateMode.STABLE) {         //stable         //reset the user variable index, and update the stable rate         user.stableBorrowRate = reserve.currentStableBorrowRate;         user.lastVariableBorrowCumulativeIndex = 0;     } else if (_rateMode == CoreLibrary.InterestRateMode.VARIABLE) {         //variable         //reset the user stable rate, and store the new borrow index         user.stableBorrowRate = 0;         user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;     } else {         revert("Invalid borrow rate mode");     }     //increase the principal borrows and the origination fee     user.principalBorrowBalance = user.principalBorrowBalance.add(_amountBorrowed).add(         _balanceIncrease     );     user.originationFee = user.originationFee.add(_fee);      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp);  }  /** * @dev updates the state of the reserve as a consequence of a repay action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _paybackAmountMinusFees the amount being paid back minus fees * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updateReserveStateOnRepayInternal(     address _reserve,     address _user,     uint256 _paybackAmountMinusFees,     uint256 _balanceIncrease ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_reserve][_user];      CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(_reserve, _user);      //update the indexes     reserves[_reserve].updateCumulativeIndexes();      //compound the cumulated interest to the borrow balance and then subtracting the payback amount     if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             _balanceIncrease,             user.stableBorrowRate         );         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _paybackAmountMinusFees,             user.stableBorrowRate         );     } else {         reserve.increaseTotalBorrowsVariable(_balanceIncrease);         reserve.decreaseTotalBorrowsVariable(_paybackAmountMinusFees);     } }  /** * @dev updates the state of the user as a consequence of a repay action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _paybackAmountMinusFees the amount being paid back minus fees * @param _originationFeeRepaid the fee on the amount that is being repaid * @param _balanceIncrease the accrued interest on the borrowed amount * @param _repaidWholeLoan true if the user is repaying the whole loan **/ function updateUserStateOnRepayInternal(     address _reserve,     address _user,     uint256 _paybackAmountMinusFees,     uint256 _originationFeeRepaid,     uint256 _balanceIncrease,     bool _repaidWholeLoan ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      //update the user principal borrow balance, adding the cumulated interest and then subtracting the payback amount     user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(         _paybackAmountMinusFees     );     user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;      //if the balance decrease is equal to the previous principal (user is repaying the whole loan)     //and the rate mode is stable, we reset the interest rate mode of the user     if (_repaidWholeLoan) {         user.stableBorrowRate = 0;         user.lastVariableBorrowCumulativeIndex = 0;     }     user.originationFee = user.originationFee.sub(_originationFeeRepaid);      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp);  }  /** * @dev updates the state of the user as a consequence of a swap rate action. * @param _reserve the address of the reserve on which the user is performing the rate swap * @param _user the address of the borrower * @param _principalBorrowBalance the the principal amount borrowed by the user * @param _compoundedBorrowBalance the principal amount plus the accrued interest * @param _currentRateMode the rate mode at which the user borrowed **/ function updateReserveStateOnSwapRateInternal(     address _reserve,     address _user,     uint256 _principalBorrowBalance,     uint256 _compoundedBorrowBalance,     CoreLibrary.InterestRateMode _currentRateMode ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      //compounding reserve indexes     reserve.updateCumulativeIndexes();      if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {         uint256 userCurrentStableRate = user.stableBorrowRate;          //swap to variable         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _principalBorrowBalance,             userCurrentStableRate         ); //decreasing stable from old principal balance         reserve.increaseTotalBorrowsVariable(_compoundedBorrowBalance); //increase variable borrows     } else if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         //swap to stable         uint256 currentStableRate = reserve.currentStableBorrowRate;         reserve.decreaseTotalBorrowsVariable(_principalBorrowBalance);         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             _compoundedBorrowBalance,             currentStableRate         );      } else {         revert("Invalid rate mode received");     } }  /** * @dev updates the state of the user as a consequence of a swap rate action. * @param _reserve the address of the reserve on which the user is performing the swap * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount * @param _currentRateMode the current rate mode of the user **/  function updateUserStateOnSwapRateInternal(     address _reserve,     address _user,     uint256 _balanceIncrease,     CoreLibrary.InterestRateMode _currentRateMode ) internal returns (CoreLibrary.InterestRateMode) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      CoreLibrary.InterestRateMode newMode = CoreLibrary.InterestRateMode.NONE;      if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         //switch to stable         newMode = CoreLibrary.InterestRateMode.STABLE;         user.stableBorrowRate = reserve.currentStableBorrowRate;         user.lastVariableBorrowCumulativeIndex = 0;     } else if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {         newMode = CoreLibrary.InterestRateMode.VARIABLE;         user.stableBorrowRate = 0;         user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;     } else {         revert("Invalid interest rate mode received");     }     //compounding cumulated interest     user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);     //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp);      return newMode; }  /** * @dev updates the state of the principal reserve as a consequence of a liquidation action. * @param _principalReserve the address of the principal reserve that is being repaid * @param _user the address of the borrower * @param _amountToLiquidate the amount being repaid by the liquidator * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updatePrincipalReserveStateOnLiquidationInternal(     address _principalReserve,     address _user,     uint256 _amountToLiquidate,     uint256 _balanceIncrease ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_principalReserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_principalReserve];      //update principal reserve data     reserve.updateCumulativeIndexes();      CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(         _principalReserve,         _user     );      if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {         //increase the total borrows by the compounded interest         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             _balanceIncrease,             user.stableBorrowRate         );          //decrease by the actual amount to liquidate         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _amountToLiquidate,             user.stableBorrowRate         );      } else {         //increase the total borrows by the compounded interest         reserve.increaseTotalBorrowsVariable(_balanceIncrease);          //decrease by the actual amount to liquidate         reserve.decreaseTotalBorrowsVariable(_amountToLiquidate);     }  }  /** * @dev updates the state of the collateral reserve as a consequence of a liquidation action. * @param _collateralReserve the address of the collateral reserve that is being liquidated **/ function updateCollateralReserveStateOnLiquidationInternal(     address _collateralReserve ) internal {     //update collateral reserve     reserves[_collateralReserve].updateCumulativeIndexes();  }  /** * @dev updates the state of the user being liquidated as a consequence of a liquidation action. * @param _reserve the address of the principal reserve that is being repaid * @param _user the address of the borrower * @param _amountToLiquidate the amount being repaid by the liquidator * @param _feeLiquidated the amount of origination fee being liquidated * @param _balanceIncrease the accrued interest on the borrowed amount **/ function updateUserStateOnLiquidationInternal(     address _reserve,     address _user,     uint256 _amountToLiquidate,     uint256 _feeLiquidated,     uint256 _balanceIncrease ) internal {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     //first increase by the compounded interest, then decrease by the liquidated amount     user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(         _amountToLiquidate     );      if (         getUserCurrentBorrowRateMode(_reserve, _user) == CoreLibrary.InterestRateMode.VARIABLE     ) {         user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;     }      if(_feeLiquidated &gt; 0){         user.originationFee = user.originationFee.sub(_feeLiquidated);     }      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp); }  /** * @dev updates the state of the reserve as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updateReserveStateOnRebalanceInternal(     address _reserve,     address _user,     uint256 _balanceIncrease ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      reserve.updateCumulativeIndexes();      reserve.increaseTotalBorrowsStableAndUpdateAverageRate(         _balanceIncrease,         user.stableBorrowRate     );  }  /** * @dev updates the state of the user as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updateUserStateOnRebalanceInternal(     address _reserve,     address _user,     uint256 _balanceIncrease ) internal {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);     user.stableBorrowRate = reserve.currentStableBorrowRate;      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp); }  /** * @dev updates the state of the user as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount * @param _amountBorrowed the accrued interest on the borrowed amount **/ function updateReserveTotalBorrowsByRateModeInternal(     address _reserve,     address _user,     uint256 _principalBalance,     uint256 _balanceIncrease,     uint256 _amountBorrowed,     CoreLibrary.InterestRateMode _newBorrowRateMode ) internal {     CoreLibrary.InterestRateMode previousRateMode = getUserCurrentBorrowRateMode(         _reserve,         _user     );     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      if (previousRateMode == CoreLibrary.InterestRateMode.STABLE) {         CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _principalBalance,             user.stableBorrowRate         );     } else if (previousRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         reserve.decreaseTotalBorrowsVariable(_principalBalance);     }      uint256 newPrincipalAmount = _principalBalance.add(_balanceIncrease).add(_amountBorrowed);     if (_newBorrowRateMode == CoreLibrary.InterestRateMode.STABLE) {         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             newPrincipalAmount,             reserve.currentStableBorrowRate         );     } else if (_newBorrowRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         reserve.increaseTotalBorrowsVariable(newPrincipalAmount);     } else {         revert("Invalid new borrow rate mode");     } }  /** * @dev Updates the reserve current stable borrow rate Rf, the current variable borrow rate Rv and the current liquidity rate Rl. * Also updates the lastUpdateTimestamp value. Please refer to the whitepaper for further information. * @param _reserve the address of the reserve to be updated * @param _liquidityAdded the amount of liquidity added to the protocol (deposit or repay) in the previous action * @param _liquidityTaken the amount of liquidity taken from the protocol (redeem or borrow) **/  function updateReserveInterestRatesAndTimestampInternal(     address _reserve,     uint256 _liquidityAdded,     uint256 _liquidityTaken ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     (uint256 newLiquidityRate, uint256 newStableRate, uint256 newVariableRate) = IReserveInterestRateStrategy(         reserve         .interestRateStrategyAddress     )     .calculateInterestRates(         _reserve,         getReserveAvailableLiquidity(_reserve).add(_liquidityAdded).sub(_liquidityTaken),         reserve.totalBorrowsStable,         reserve.totalBorrowsVariable,         reserve.currentAverageStableBorrowRate     );      reserve.currentLiquidityRate = newLiquidityRate;     reserve.currentStableBorrowRate = newStableRate;     reserve.currentVariableBorrowRate = newVariableRate;      //solium-disable-next-line     reserve.lastUpdateTimestamp = uint40(block.timestamp);      emit ReserveUpdated(         _reserve,         newLiquidityRate,         newStableRate,         newVariableRate,         reserve.lastLiquidityCumulativeIndex,         reserve.lastVariableBorrowCumulativeIndex     ); }  /** * @dev transfers to the protocol fees of a flashloan to the fees collection address * @param _token the address of the token being transferred * @param _amount the amount being transferred **/  function transferFlashLoanProtocolFeeInternal(address _token, uint256 _amount) internal {     address payable receiver = address(uint160(addressesProvider.getTokenDistributor()));      if (_token != EthAddressLib.ethAddress()) {         ERC20(_token).safeTransfer(receiver, _amount);     } else {         receiver.transfer(_amount);     } }  /** * @dev updates the internal configuration of the core **/ function refreshConfigInternal() internal {     lendingPoolAddress = addressesProvider.getLendingPool(); }  /** * @dev adds a reserve to the array of the reserves address **/ function addReserveToListInternal(address _reserve) internal {     bool reserveAlreadyAdded = false;     for (uint256 i = 0; i &lt; reservesList.length; i++)         if (reservesList[i] == _reserve) {             reserveAlreadyAdded = true;         }     if (!reserveAlreadyAdded) reservesList.push(_reserve); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Below are the details of our target smart contract codes and their associated test reports: Task: "{task}". Existing Test Reports: "{test_reports}" Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings. |
| **phase_name** | TestBugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': 'pragma solidity ^0.5.0;\n\nimport "openzeppelin-solidity/contracts/math/SafeMath.sol";\nimport "openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol";\nimport "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol";\nimport "openzeppelin-solidity/contracts/utils/Address.sol";\nimport "../libraries/openzeppelin-upgradeability/VersionedInitializable.sol";\n\nimport "../libraries/CoreLibrary.sol";\nimport "../configuration/LendingPoolAddressesProvider.sol";\nimport "../interfaces/ILendingRateOracle.sol";\nimport "../interfaces/IReserveInterestRateStrategy.sol";\nimport "../libraries/WadRayMath.sol";\nimport "../tokenization/AToken.sol";\nimport "../libraries/EthAddressLib.sol";\n\n/\n @title LendingPoolCore contract\n @author Aave\n @notice Holds the state of the lending pool and all the funds deposited\n @dev NOTE: The core does not enforce security checks on the update of the state\n (eg, updateStateOnBorrow() does not enforce that borrowed is enabled on the reserve).\n The check that an action can be performed is a duty of the overlying LendingPool contract.\n/\n\ncontract LendingPoolCore is VersionedInitializable {\n    using SafeMath for uint256;\n    using WadRayMath for uint256;\n    using CoreLibrary for CoreLibrary.ReserveData;\n    using CoreLibrary for CoreLibrary.UserReserveData;\n    using SafeERC20 for ERC20;\n    using Address for address payable;\n\n    /\n    * @dev Emitted when the state of a reserve is updated\n    * @param reserve the address of the reserve\n    * @param liquidityRate the new liquidity rate\n    * @param stableBorrowRate the new stable borrow rate\n    * @param variableBorrowRate the new variable borrow rate\n    * @param liquidityIndex the new liquidity index\n    * @param variableBorrowIndex the new variable borrow index\n    /\n    event ReserveUpdated(\n        address indexed reserve,\n        uint256 liquidityRate,\n        uint256 stableBorrowRate,\n        uint256 variableBorrowRate,\n        uint256 liquidityIndex,\n        uint256 variableBorrowIndex\n    );\n\n    address public lendingPoolAddress;\n\n    LendingPoolAddressesProvider public addressesProvider;\n\n    /\n    * @dev only lending pools can use functions affected by this modifier\n    /\n    modifier onlyLendingPool {\n        require(lendingPoolAddress == msg.sender, "The caller must be a lending pool contract");\n        ;\n    }\n\n    /\n    * @dev only lending pools configurator can use functions affected by this modifier\n    /\n    modifier onlyLendingPoolConfigurator {\n        require(\n            addressesProvider.getLendingPoolConfigurator() == msg.sender,\n            "The caller must be a lending pool configurator contract"\n        );\n        ;\n    }\n\n    mapping(address =&gt; CoreLibrary.ReserveData) internal reserves;\n    mapping(address =&gt; mapping(address =&gt; CoreLibrary.UserReserveData)) internal usersReserveData;\n\n    address[] public reservesList;\n\n    uint256 public constant CORE_REVISION = 0x4;\n\n    /\n    * @dev returns the revision number of the contract\n    /\n    function getRevision() internal pure returns (uint256) {\n        return CORE_REVISION;\n    }\n\n    /\n    * @dev initializes the Core contract, invoked upon registration on the AddressesProvider\n    * @param _addressesProvider the addressesProvider contract\n    /\n\n    function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {\n        addressesProvider = _addressesProvider;\n        refreshConfigInternal();\n    }\n\n    /\n    * @dev updates the state of the core as a result of a deposit action\n    * @param _reserve the address of the reserve in which the deposit is happening\n    * @param _user the address of the the user depositing\n    * @param _amount the amount being deposited\n    * @param _isFirstDeposit true if the user is depositing for the first time\n    /\n\n    function updateStateOnDeposit(\n        address _reserve,\n        address _user,\n        uint256 _amount,\n        bool _isFirstDeposit\n    ) external onlyLendingPool {\n        reserves[_reserve].updateCumulativeIndexes();\n        updateReserveInterestRatesAndTimestampInternal(_reserve, _amount, 0);\n\n        if (_isFirstDeposit) {\n            //if this is the first deposit of the user, we configure the deposit as enabled to be used as collateral\n            setUserUseReserveAsCollateral(_reserve, _user, true);\n        }\n    }\n\n    /\n    * @dev updates the state of the core as a result of a redeem action\n    * @param _reserve the address of the reserve in which the redeem is happening\n    * @param _user the address of the the user redeeming\n    * @param _amountRedeemed the amount being redeemed\n    * @param _userRedeemedEverything true if the user is redeeming everything\n    /\n    function updateStateOnRedeem(\n        address _reserve,\n        address _user,\n        uint256 _amountRedeemed,\n        bool _userRedeemedEverything\n    ) external onlyLendingPool {\n        //compound liquidity and variable borrow interests\n        reserves[_reserve].updateCumulativeIndexes();\n        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountRedeemed);\n\n        //if user redeemed everything the useReserveAsCollateral flag is reset\n        if (_userRedeemedEverything) {\n            setUserUseReserveAsCollateral(_reserve, _user, false);\n        }\n    }\n\n    /\n    * @dev updates the state of the core as a result of a flashloan action\n    * @param _reserve the address of the reserve in which the flashloan is happening\n    * @param _income the income of the protocol as a result of the action\n    /\n    function updateStateOnFlashLoan(\n        address _reserve,\n        uint256 _availableLiquidityBefore,\n        uint256 _income,\n        uint256 _protocolFee\n    ) external onlyLendingPool {\n        transferFlashLoanProtocolFeeInternal(_reserve, _protocolFee);\n\n        //compounding the cumulated interest\n        reserves[_reserve].updateCumulativeIndexes();\n\n        uint256 totalLiquidityBefore = _availableLiquidityBefore.add(\n            getReserveTotalBorrows(_reserve)\n        );\n\n        //compounding the received fee into the reserve\n        reserves[_reserve].cumulateToLiquidityIndex(totalLiquidityBefore, _income);\n\n        //refresh interest rates\n        updateReserveInterestRatesAndTimestampInternal(_reserve, _income, 0);\n    }\n\n    /\n    * @dev updates the state of the core as a consequence of a borrow action.\n    * @param _reserve the address of the reserve on which the user is borrowing\n    * @param _user the address of the borrower\n    * @param _amountBorrowed the new amount borrowed\n    * @param _borrowFee the fee on the amount borrowed\n    * @param _rateMode the borrow rate mode (stable, variable)\n    * @return the new borrow rate for the user\n    /\n    function updateStateOnBorrow(\n        address _reserve,\n        address _user,\n        uint256 _amountBorrowed,\n        uint256 _borrowFee,\n        CoreLibrary.InterestRateMode _rateMode\n    ) external onlyLendingPool returns (uint256, uint256) {\n        // getting the previous borrow data of the user\n        (uint256 principalBorrowBalance, , uint256 balanceIncrease) = getUserBorrowBalances(\n            _reserve,\n            _user\n        );\n\n        updateReserveStateOnBorrowInternal(\n            _reserve,\n            _user,\n            principalBorrowBalance,\n            balanceIncrease,\n            _amountBorrowed,\n            _rateMode\n        );\n\n        updateUserStateOnBorrowInternal(\n            _reserve,\n            _user,\n            _amountBorrowed,\n            balanceIncrease,\n            _borrowFee,\n            _rateMode\n        );\n\n        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountBorrowed);\n\n        return (getUserCurrentBorrowRate(_reserve, _user), balanceIncrease);\n    }\n\n    /\n    * @dev updates the state of the core as a consequence of a repay action.\n    * @param _reserve the address of the reserve on which the user is repaying\n    * @param _user the address of the borrower\n    * @param _paybackAmountMinusFees the amount being paid back minus fees\n    * @param _originationFeeRepaid the fee on the amount that is being repaid\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    * @param _repaidWholeLoan true if the user is repaying the whole loan\n    /\n\n    function updateStateOnRepay(\n        address _reserve,\n        address _user,\n        uint256 _paybackAmountMinusFees,\n        uint256 _originationFeeRepaid,\n        uint256 _balanceIncrease,\n        bool _repaidWholeLoan\n    ) external onlyLendingPool {\n        updateReserveStateOnRepayInternal(\n            _reserve,\n            _user,\n            _paybackAmountMinusFees,\n            _balanceIncrease\n        );\n        updateUserStateOnRepayInternal(\n            _reserve,\n            _user,\n            _paybackAmountMinusFees,\n            _originationFeeRepaid,\n            _balanceIncrease,\n            _repaidWholeLoan\n        );\n\n        updateReserveInterestRatesAndTimestampInternal(_reserve, _paybackAmountMinusFees, 0);\n    }\n\n    /\n    * @dev updates the state of the core as a consequence of a swap rate action.\n    * @param _reserve the address of the reserve on which the user is repaying\n    * @param _user the address of the borrower\n    * @param _principalBorrowBalance the amount borrowed by the user\n    * @param _compoundedBorrowBalance the amount borrowed plus accrued interest\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    * @param _currentRateMode the current interest rate mode for the user\n    /\n    function updateStateOnSwapRate(\n        address _reserve,\n        address _user,\n        uint256 _principalBorrowBalance,\n        uint256 _compoundedBorrowBalance,\n        uint256 _balanceIncrease,\n        CoreLibrary.InterestRateMode _currentRateMode\n    ) external onlyLendingPool returns (CoreLibrary.InterestRateMode, uint256) {\n        updateReserveStateOnSwapRateInternal(\n            _reserve,\n            _user,\n            _principalBorrowBalance,\n            _compoundedBorrowBalance,\n            _currentRateMode\n        );\n\n        CoreLibrary.InterestRateMode newRateMode = updateUserStateOnSwapRateInternal(\n            _reserve,\n            _user,\n            _balanceIncrease,\n            _currentRateMode\n        );\n\n        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);\n\n        return (newRateMode, getUserCurrentBorrowRate(_reserve, _user));\n    }\n\n    /\n    * @dev updates the state of the core as a consequence of a liquidation action.\n    * @param _principalReserve the address of the principal reserve that is being repaid\n    * @param _collateralReserve the address of the collateral reserve that is being liquidated\n    * @param _user the address of the borrower\n    * @param _amountToLiquidate the amount being repaid by the liquidator\n    * @param _collateralToLiquidate the amount of collateral being liquidated\n    * @param _feeLiquidated the amount of origination fee being liquidated\n    * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise\n    /\n    function updateStateOnLiquidation(\n        address _principalReserve,\n        address _collateralReserve,\n        address _user,\n        uint256 _amountToLiquidate,\n        uint256 _collateralToLiquidate,\n        uint256 _feeLiquidated,\n        uint256 _liquidatedCollateralForFee,\n        uint256 _balanceIncrease,\n        bool _liquidatorReceivesAToken\n    ) external onlyLendingPool {\n        updatePrincipalReserveStateOnLiquidationInternal(\n            _principalReserve,\n            _user,\n            _amountToLiquidate,\n            _balanceIncrease\n        );\n\n        updateCollateralReserveStateOnLiquidationInternal(\n            _collateralReserve\n        );\n\n        updateUserStateOnLiquidationInternal(\n            _principalReserve,\n            _user,\n            _amountToLiquidate,\n            _feeLiquidated,\n            _balanceIncrease\n        );\n\n        updateReserveInterestRatesAndTimestampInternal(_principalReserve, _amountToLiquidate, 0);\n\n        if (!_liquidatorReceivesAToken) {\n            updateReserveInterestRatesAndTimestampInternal(\n                _collateralReserve,\n                0,\n                _collateralToLiquidate.add(_liquidatedCollateralForFee)\n            );\n        }\n\n    }\n\n    /\n    * @dev updates the state of the core as a consequence of a stable rate rebalance\n    * @param _reserve the address of the principal reserve where the user borrowed\n    * @param _user the address of the borrower\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    * @return the new stable rate for the user\n    /\n    function updateStateOnRebalance(address _reserve, address _user, uint256 _balanceIncrease)\n    external\n    onlyLendingPool\n    returns (uint256)\n    {\n        updateReserveStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);\n\n        //update user data and rebalance the rate\n        updateUserStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);\n        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);\n        return usersReserveData[_user][_reserve].stableBorrowRate;\n    }\n\n    /\n    * @dev enables or disables a reserve as collateral\n    * @param _reserve the address of the principal reserve where the user deposited\n    * @param _user the address of the depositor\n    * @param _useAsCollateral true if the depositor wants to use the reserve as collateral\n    /\n    function setUserUseReserveAsCollateral(address _reserve, address _user, bool _useAsCollateral)\n    public\n    onlyLendingPool\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        user.useAsCollateral = _useAsCollateral;\n    }\n\n    /\n    * @notice ETH/token transfer functions\n    /\n\n    /\n    * @dev fallback function enforces that the caller is a contract, to support flashloan transfers\n    /\n    function() external payable {\n        //only contracts can send ETH to the core\n        require(msg.sender.isContract(), "Only contracts can send ether to the Lending pool core");\n\n    }\n\n    /\n    * @dev transfers to the user a specific amount from the reserve.\n    * @param _reserve the address of the reserve where the transfer is happening\n    * @param _user the address of the user receiving the transfer\n    * @param _amount the amount being transferred\n    /\n    function transferToUser(address _reserve, address payable _user, uint256 _amount)\n    external\n    onlyLendingPool\n    {\n        if (_reserve != EthAddressLib.ethAddress()) {\n            ERC20(_reserve).safeTransfer(_user, _amount);\n        } else {\n            //solium-disable-next-line\n            (bool result, ) = _user.call.value(_amount).gas(50000)("");\n            require(result, "Transfer of ETH failed");\n        }\n    }\n\n    /\n    * @dev transfers the protocol fees to the fees collection address\n    * @param _token the address of the token being transferred\n    * @param _user the address of the user from where the transfer is happening\n    * @param _amount the amount being transferred\n    * @param _destination the fee receiver address\n    /\n\n    function transferToFeeCollectionAddress(\n        address _token,\n        address _user,\n        uint256 _amount,\n        address _destination\n    ) external payable onlyLendingPool {\n        address payable feeAddress = address(uint160(_destination)); //cast the address to payable\n\n        if (_token != EthAddressLib.ethAddress()) {\n            require(\n                msg.value == 0,\n                "User is sending ETH along with the ERC20 transfer. Check the value attribute of the transaction"\n            );\n            ERC20(_token).safeTransferFrom(_user, feeAddress, _amount);\n        } else {\n            require(msg.value &gt;= _amount, "The amount and the value sent to deposit do not match");\n            //solium-disable-next-line\n            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");\n            require(result, "Transfer of ETH failed");\n        }\n    }\n\n    /\n    * @dev transfers the fees to the fees collection address in the case of liquidation\n    * @param _token the address of the token being transferred\n    * @param _amount the amount being transferred\n    * @param _destination the fee receiver address\n    /\n    function liquidateFee(\n        address _token,\n        uint256 _amount,\n        address _destination\n    ) external payable onlyLendingPool {\n        address payable feeAddress = address(uint160(_destination)); //cast the address to payable\n        require(\n            msg.value == 0,\n            "Fee liquidation does not require any transfer of value"\n        );\n\n        if (_token != EthAddressLib.ethAddress()) {\n            ERC20(_token).safeTransfer(feeAddress, _amount);\n        } else {\n            //solium-disable-next-line\n            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");\n            require(result, "Transfer of ETH failed");\n        }\n    }\n\n    /\n    * @dev transfers an amount from a user to the destination reserve\n    * @param _reserve the address of the reserve where the amount is being transferred\n    * @param _user the address of the user from where the transfer is happening\n    * @param _amount the amount being transferred\n    /\n    function transferToReserve(address _reserve, address payable _user, uint256 _amount)\n    external\n    payable\n    onlyLendingPool\n    {\n        if (_reserve != EthAddressLib.ethAddress()) {\n            require(msg.value == 0, "User is sending ETH along with the ERC20 transfer.");\n            ERC20(_reserve).safeTransferFrom(_user, address(this), _amount);\n\n        } else {\n            require(msg.value &gt;= _amount, "The amount and the value sent to deposit do not match");\n\n            if (msg.value &gt; _amount) {\n                //send back excess ETH\n                uint256 excessAmount = msg.value.sub(_amount);\n                //solium-disable-next-line\n                (bool result, ) = _user.call.value(excessAmount).gas(50000)("");\n                require(result, "Transfer of ETH failed");\n            }\n        }\n    }\n\n    /\n    * @notice data access functions\n    /\n\n    /\n    * @dev returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral)\n    * needed to calculate the global account data in the LendingPoolDataProvider\n    * @param _reserve the address of the reserve\n    * @param _user the address of the user\n    * @return the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not\n    /\n    function getUserBasicReserveData(address _reserve, address _user)\n    external\n    view\n    returns (uint256, uint256, uint256, bool)\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n\n        uint256 underlyingBalance = getUserUnderlyingAssetBalance(_reserve, _user);\n\n        if (user.principalBorrowBalance == 0) {\n            return (underlyingBalance, 0, 0, user.useAsCollateral);\n        }\n\n        return (\n        underlyingBalance,\n        user.getCompoundedBorrowBalance(reserve),\n        user.originationFee,\n        user.useAsCollateral\n        );\n    }\n\n    /\n    * @dev checks if a user is allowed to borrow at a stable rate\n    * @param _reserve the reserve address\n    * @param _user the user\n    * @param _amount the amount the the user wants to borrow\n    * @return true if the user is allowed to borrow at a stable rate, false otherwise\n    /\n\n    function isUserAllowedToBorrowAtStable(address _reserve, address _user, uint256 _amount)\n    external\n    view\n    returns (bool)\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n\n        if (!reserve.isStableBorrowRateEnabled) return false;\n\n        return\n        !user.useAsCollateral ||\n        !reserve.usageAsCollateralEnabled ||\n        _amount &gt; getUserUnderlyingAssetBalance(_reserve, _user);\n    }\n\n    /\n    * @dev gets the underlying asset balance of a user based on the corresponding aToken balance.\n    * @param _reserve the reserve address\n    * @param _user the user address\n    * @return the underlying deposit balance of the user\n    /\n\n    function getUserUnderlyingAssetBalance(address _reserve, address _user)\n    public\n    view\n    returns (uint256)\n    {\n        AToken aToken = AToken(reserves[_reserve].aTokenAddress);\n        return aToken.balanceOf(_user);\n\n    }\n\n    /\n    * @dev gets the interest rate strategy contract address for the reserve\n    * @param _reserve the reserve address\n    * @return the address of the interest rate strategy contract\n    /\n    function getReserveInterestRateStrategyAddress(address _reserve) public view returns (address) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.interestRateStrategyAddress;\n    }\n\n    /\n    * @dev gets the aToken contract address for the reserve\n    * @param _reserve the reserve address\n    * @return the address of the aToken contract\n    /\n\n    function getReserveATokenAddress(address _reserve) public view returns (address) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.aTokenAddress;\n    }\n\n    /\n    * @dev gets the available liquidity in the reserve. The available liquidity is the balance of the core contract\n    * @param _reserve the reserve address\n    * @return the available liquidity\n    /\n    function getReserveAvailableLiquidity(address _reserve) public view returns (uint256) {\n        uint256 balance = 0;\n\n        if (_reserve == EthAddressLib.ethAddress()) {\n            balance = address(this).balance;\n        } else {\n            balance = IERC20(_reserve).balanceOf(address(this));\n        }\n        return balance;\n    }\n\n    /\n    * @dev gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows\n    * @param _reserve the reserve address\n    * @return the total liquidity\n    /\n    function getReserveTotalLiquidity(address _reserve) public view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return getReserveAvailableLiquidity(_reserve).add(reserve.getTotalBorrows());\n    }\n\n    /\n    * @dev gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there\n    * there has been 100% income.\n    * @param _reserve the reserve address\n    * @return the reserve normalized income\n    /\n    function getReserveNormalizedIncome(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.getNormalizedIncome();\n    }\n\n    /\n    * @dev gets the reserve total borrows\n    * @param _reserve the reserve address\n    * @return the total borrows (stable + variable)\n    /\n    function getReserveTotalBorrows(address _reserve) public view returns (uint256) {\n        return reserves[_reserve].getTotalBorrows();\n    }\n\n    /\n    * @dev gets the reserve total borrows stable\n    * @param _reserve the reserve address\n    * @return the total borrows stable\n    /\n    function getReserveTotalBorrowsStable(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.totalBorrowsStable;\n    }\n\n    /\n    * @dev gets the reserve total borrows variable\n    * @param _reserve the reserve address\n    * @return the total borrows variable\n    /\n\n    function getReserveTotalBorrowsVariable(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.totalBorrowsVariable;\n    }\n\n    /\n    * @dev gets the reserve liquidation threshold\n    * @param _reserve the reserve address\n    * @return the reserve liquidation threshold\n    /\n\n    function getReserveLiquidationThreshold(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.liquidationThreshold;\n    }\n\n    /\n    * @dev gets the reserve liquidation bonus\n    * @param _reserve the reserve address\n    * @return the reserve liquidation bonus\n    /\n\n    function getReserveLiquidationBonus(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.liquidationBonus;\n    }\n\n    /\n    * @dev gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty\n    * @param _reserve the reserve address\n    * @return the reserve current variable borrow rate\n    /\n\n    function getReserveCurrentVariableBorrowRate(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n\n        if (reserve.currentVariableBorrowRate == 0) {\n            return\n            IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)\n            .getBaseVariableBorrowRate();\n        }\n        return reserve.currentVariableBorrowRate;\n    }\n\n    /\n    * @dev gets the reserve current stable borrow rate. Is the market rate if the reserve is empty\n    * @param _reserve the reserve address\n    * @return the reserve current stable borrow rate\n    /\n\n    function getReserveCurrentStableBorrowRate(address _reserve) public view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        ILendingRateOracle oracle = ILendingRateOracle(addressesProvider.getLendingRateOracle());\n\n        if (reserve.currentStableBorrowRate == 0) {\n            //no stable rate borrows yet\n            return oracle.getMarketBorrowRate(_reserve);\n        }\n\n        return reserve.currentStableBorrowRate;\n    }\n\n    /\n    * @dev gets the reserve average stable borrow rate. The average stable rate is the weighted average\n    * of all the loans taken at stable rate.\n    * @param _reserve the reserve address\n    * @return the reserve current average borrow rate\n    /\n    function getReserveCurrentAverageStableBorrowRate(address _reserve)\n    external\n    view\n    returns (uint256)\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.currentAverageStableBorrowRate;\n    }\n\n    /\n    * @dev gets the reserve liquidity rate\n    * @param _reserve the reserve address\n    * @return the reserve liquidity rate\n    /\n    function getReserveCurrentLiquidityRate(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.currentLiquidityRate;\n    }\n\n    /\n    * @dev gets the reserve liquidity cumulative index\n    * @param _reserve the reserve address\n    * @return the reserve liquidity cumulative index\n    /\n    function getReserveLiquidityCumulativeIndex(address _reserve) external view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.lastLiquidityCumulativeIndex;\n    }\n\n    /\n    * @dev gets the reserve variable borrow index\n    * @param _reserve the reserve address\n    * @return the reserve variable borrow index\n    /\n    function getReserveVariableBorrowsCumulativeIndex(address _reserve)\n    external\n    view\n    returns (uint256)\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.lastVariableBorrowCumulativeIndex;\n    }\n\n    /\n    * @dev this function aggregates the configuration parameters of the reserve.\n    * It\'s used in the LendingPoolDataProvider specifically to save gas, and avoid\n    * multiple external contract calls to fetch the same data.\n    * @param _reserve the reserve address\n    * @return the reserve decimals\n    * @return the base ltv as collateral\n    * @return the liquidation threshold\n    * @return if the reserve is used as collateral or not\n    /\n    function getReserveConfiguration(address _reserve)\n    external\n    view\n    returns (uint256, uint256, uint256, bool)\n    {\n        uint256 decimals;\n        uint256 baseLTVasCollateral;\n        uint256 liquidationThreshold;\n        bool usageAsCollateralEnabled;\n\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        decimals = reserve.decimals;\n        baseLTVasCollateral = reserve.baseLTVasCollateral;\n        liquidationThreshold = reserve.liquidationThreshold;\n        usageAsCollateralEnabled = reserve.usageAsCollateralEnabled;\n\n        return (decimals, baseLTVasCollateral, liquidationThreshold, usageAsCollateralEnabled);\n    }\n\n    /\n    * @dev returns the decimals of the reserve\n    * @param _reserve the reserve address\n    * @return the reserve decimals\n    /\n    function getReserveDecimals(address _reserve) external view returns (uint256) {\n        return reserves[_reserve].decimals;\n    }\n\n    /\n    * @dev returns true if the reserve is enabled for borrowing\n    * @param _reserve the reserve address\n    * @return true if the reserve is enabled for borrowing, false otherwise\n    /\n\n    function isReserveBorrowingEnabled(address _reserve) external view returns (bool) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.borrowingEnabled;\n    }\n\n    /\n    * @dev returns true if the reserve is enabled as collateral\n    * @param _reserve the reserve address\n    * @return true if the reserve is enabled as collateral, false otherwise\n    /\n\n    function isReserveUsageAsCollateralEnabled(address _reserve) external view returns (bool) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.usageAsCollateralEnabled;\n    }\n\n    /\n    * @dev returns true if the stable rate is enabled on reserve\n    * @param _reserve the reserve address\n    * @return true if the stable rate is enabled on reserve, false otherwise\n    /\n    function getReserveIsStableBorrowRateEnabled(address _reserve) external view returns (bool) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.isStableBorrowRateEnabled;\n    }\n\n    /\n    * @dev returns true if the reserve is active\n    * @param _reserve the reserve address\n    * @return true if the reserve is active, false otherwise\n    /\n    function getReserveIsActive(address _reserve) external view returns (bool) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.isActive;\n    }\n\n    /\n    * @notice returns if a reserve is freezed\n    * @param _reserve the reserve for which the information is needed\n    * @return true if the reserve is freezed, false otherwise\n    /\n\n    function getReserveIsFreezed(address _reserve) external view returns (bool) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        return reserve.isFreezed;\n    }\n\n    /\n    * @notice returns the timestamp of the last action on the reserve\n    * @param _reserve the reserve for which the information is needed\n    * @return the last updated timestamp of the reserve\n    /\n\n    function getReserveLastUpdate(address _reserve) external view returns (uint40 timestamp) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        timestamp = reserve.lastUpdateTimestamp;\n    }\n\n    /\n    * @dev returns the utilization rate U of a specific reserve\n    * @param _reserve the reserve for which the information is needed\n    * @return the utilization rate in ray\n    /\n\n    function getReserveUtilizationRate(address _reserve) public view returns (uint256) {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n\n        uint256 totalBorrows = reserve.getTotalBorrows();\n\n        if (totalBorrows == 0) {\n            return 0;\n        }\n\n        uint256 availableLiquidity = getReserveAvailableLiquidity(_reserve);\n\n        return totalBorrows.rayDiv(availableLiquidity.add(totalBorrows));\n    }\n\n    /\n    * @return the array of reserves configured on the core\n    /\n    function getReserves() external view returns (address[] memory) {\n        return reservesList;\n    }\n\n    /\n    * @param _reserve the address of the reserve for which the information is needed\n    * @param _user the address of the user for which the information is needed\n    * @return true if the user has chosen to use the reserve as collateral, false otherwise\n    /\n    function isUserUseReserveAsCollateralEnabled(address _reserve, address _user)\n    external\n    view\n    returns (bool)\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        return user.useAsCollateral;\n    }\n\n    /\n    * @param _reserve the address of the reserve for which the information is needed\n    * @param _user the address of the user for which the information is needed\n    * @return the origination fee for the user\n    /\n    function getUserOriginationFee(address _reserve, address _user)\n    external\n    view\n    returns (uint256)\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        return user.originationFee;\n    }\n\n    /\n    * @dev users with no loans in progress have NONE as borrow rate mode\n    * @param _reserve the address of the reserve for which the information is needed\n    * @param _user the address of the user for which the information is needed\n    * @return the borrow rate mode for the user,\n    /\n\n    function getUserCurrentBorrowRateMode(address _reserve, address _user)\n    public\n    view\n    returns (CoreLibrary.InterestRateMode)\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n\n        if (user.principalBorrowBalance == 0) {\n            return CoreLibrary.InterestRateMode.NONE;\n        }\n\n        return\n        user.stableBorrowRate &gt; 0\n        ? CoreLibrary.InterestRateMode.STABLE\n        : CoreLibrary.InterestRateMode.VARIABLE;\n    }\n\n    /\n    * @dev gets the current borrow rate of the user\n    * @param _reserve the address of the reserve for which the information is needed\n    * @param _user the address of the user for which the information is needed\n    * @return the borrow rate for the user,\n    /\n    function getUserCurrentBorrowRate(address _reserve, address _user)\n    internal\n    view\n    returns (uint256)\n    {\n        CoreLibrary.InterestRateMode rateMode = getUserCurrentBorrowRateMode(_reserve, _user);\n\n        if (rateMode == CoreLibrary.InterestRateMode.NONE) {\n            return 0;\n        }\n\n        return\n        rateMode == CoreLibrary.InterestRateMode.STABLE\n        ? usersReserveData[_user][_reserve].stableBorrowRate\n        : reserves[_reserve].currentVariableBorrowRate;\n    }\n\n    /\n    * @dev the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all\n    * @param _reserve the address of the reserve for which the information is needed\n    * @param _user the address of the user for which the information is needed\n    * @return the user stable rate\n    /\n    function getUserCurrentStableBorrowRate(address _reserve, address _user)\n    external\n    view\n    returns (uint256)\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        return user.stableBorrowRate;\n    }\n\n    /\n    * @dev calculates and returns the borrow balances of the user\n    * @param _reserve the address of the reserve\n    * @param _user the address of the user\n    * @return the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance\n    /\n\n    function getUserBorrowBalances(address _reserve, address _user)\n    public\n    view\n    returns (uint256, uint256, uint256)\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        if (user.principalBorrowBalance == 0) {\n            return (0, 0, 0);\n        }\n\n        uint256 principal = user.principalBorrowBalance;\n        uint256 compoundedBalance = CoreLibrary.getCompoundedBorrowBalance(\n            user,\n            reserves[_reserve]\n        );\n        return (principal, compoundedBalance, compoundedBalance.sub(principal));\n    }\n\n    /\n    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable\n    * @param _reserve the address of the reserve for which the information is needed\n    * @param _user the address of the user for which the information is needed\n    * @return the variable borrow index for the user\n    /\n\n    function getUserVariableBorrowCumulativeIndex(address _reserve, address _user)\n    external\n    view\n    returns (uint256)\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        return user.lastVariableBorrowCumulativeIndex;\n    }\n\n    /\n    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable\n    * @param _reserve the address of the reserve for which the information is needed\n    * @param _user the address of the user for which the information is needed\n    * @return the variable borrow index for the user\n    /\n\n    function getUserLastUpdate(address _reserve, address _user)\n    external\n    view\n    returns (uint256 timestamp)\n    {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        timestamp = user.lastUpdateTimestamp;\n    }\n\n    /\n    * @dev updates the lending pool core configuration\n    /\n    function refreshConfiguration() external onlyLendingPoolConfigurator {\n        refreshConfigInternal();\n    }\n\n    /\n    * @dev initializes a reserve\n    * @param _reserve the address of the reserve\n    * @param _aTokenAddress the address of the overlying aToken contract\n    * @param _decimals the decimals of the reserve currency\n    * @param _interestRateStrategyAddress the address of the interest rate strategy contract\n    /\n    function initReserve(\n        address _reserve,\n        address _aTokenAddress,\n        uint256 _decimals,\n        address _interestRateStrategyAddress\n    ) external onlyLendingPoolConfigurator {\n        reserves[_reserve].init(_aTokenAddress, _decimals, _interestRateStrategyAddress);\n        addReserveToListInternal(_reserve);\n\n    }\n\n\n\n    /\n    * @dev removes the last added reserve in the reservesList array\n    * @param _reserveToRemove the address of the reserve\n    /\n    function removeLastAddedReserve(address _reserveToRemove)\n    external onlyLendingPoolConfigurator {\n\n        address lastReserve = reservesList[reservesList.length-1];\n\n        require(lastReserve == _reserveToRemove, "Reserve being removed is different than the reserve requested");\n\n        //as we can\'t check if totalLiquidity is 0 (since the reserve added might not be an ERC20) we at least check that there is nothing borrowed\n        require(getReserveTotalBorrows(lastReserve) == 0, "Cannot remove a reserve with liquidity deposited");\n\n        reserves[lastReserve].isActive = false;\n        reserves[lastReserve].aTokenAddress = address(0);\n        reserves[lastReserve].decimals = 0;\n        reserves[lastReserve].lastLiquidityCumulativeIndex = 0;\n        reserves[lastReserve].lastVariableBorrowCumulativeIndex = 0;\n        reserves[lastReserve].borrowingEnabled = false;\n        reserves[lastReserve].usageAsCollateralEnabled = false;\n        reserves[lastReserve].baseLTVasCollateral = 0;\n        reserves[lastReserve].liquidationThreshold = 0;\n        reserves[lastReserve].liquidationBonus = 0;\n        reserves[lastReserve].interestRateStrategyAddress = address(0);\n\n        reservesList.pop();\n    }\n\n    /\n    * @dev updates the address of the interest rate strategy contract\n    * @param _reserve the address of the reserve\n    * @param _rateStrategyAddress the address of the interest rate strategy contract\n    /\n\n    function setReserveInterestRateStrategyAddress(address _reserve, address _rateStrategyAddress)\n    external\n    onlyLendingPoolConfigurator\n    {\n        reserves[_reserve].interestRateStrategyAddress = _rateStrategyAddress;\n    }\n\n    /\n    * @dev enables borrowing on a reserve. Also sets the stable rate borrowing\n    * @param _reserve the address of the reserve\n    * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise\n    /\n\n    function enableBorrowingOnReserve(address _reserve, bool _stableBorrowRateEnabled)\n    external\n    onlyLendingPoolConfigurator\n    {\n        reserves[_reserve].enableBorrowing(_stableBorrowRateEnabled);\n    }\n\n    /\n    * @dev disables borrowing on a reserve\n    * @param _reserve the address of the reserve\n    /\n\n    function disableBorrowingOnReserve(address _reserve) external onlyLendingPoolConfigurator {\n        reserves[_reserve].disableBorrowing();\n    }\n\n    /\n    * @dev enables a reserve to be used as collateral\n    * @param _reserve the address of the reserve\n    /\n    function enableReserveAsCollateral(\n        address _reserve,\n        uint256 _baseLTVasCollateral,\n        uint256 _liquidationThreshold,\n        uint256 _liquidationBonus\n    ) external onlyLendingPoolConfigurator {\n        reserves[_reserve].enableAsCollateral(\n            _baseLTVasCollateral,\n            _liquidationThreshold,\n            _liquidationBonus\n        );\n    }\n\n    /\n    * @dev disables a reserve to be used as collateral\n    * @param _reserve the address of the reserve\n    /\n    function disableReserveAsCollateral(address _reserve) external onlyLendingPoolConfigurator {\n        reserves[_reserve].disableAsCollateral();\n    }\n\n    /\n    * @dev enable the stable borrow rate mode on a reserve\n    * @param _reserve the address of the reserve\n    /\n    function enableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.isStableBorrowRateEnabled = true;\n    }\n\n    /\n    * @dev disable the stable borrow rate mode on a reserve\n    * @param _reserve the address of the reserve\n    /\n    function disableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.isStableBorrowRateEnabled = false;\n    }\n\n    /\n    * @dev activates a reserve\n    * @param _reserve the address of the reserve\n    /\n    function activateReserve(address _reserve) external onlyLendingPoolConfigurator {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n\n        require(\n            reserve.lastLiquidityCumulativeIndex &gt; 0 &amp;&amp;\n            reserve.lastVariableBorrowCumulativeIndex &gt; 0,\n            "Reserve has not been initialized yet"\n        );\n        reserve.isActive = true;\n    }\n\n    /\n    * @dev deactivates a reserve\n    * @param _reserve the address of the reserve\n    /\n    function deactivateReserve(address _reserve) external onlyLendingPoolConfigurator {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.isActive = false;\n    }\n\n    /\n    * @notice allows the configurator to freeze the reserve.\n    * A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance.\n    * @param _reserve the address of the reserve\n    /\n    function freezeReserve(address _reserve) external onlyLendingPoolConfigurator {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.isFreezed = true;\n    }\n\n    /\n    * @notice allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed.\n    * @param _reserve the address of the reserve\n    /\n    function unfreezeReserve(address _reserve) external onlyLendingPoolConfigurator {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.isFreezed = false;\n    }\n\n    /\n    * @notice allows the configurator to update the loan to value of a reserve\n    * @param _reserve the address of the reserve\n    * @param _ltv the new loan to value\n    /\n    function setReserveBaseLTVasCollateral(address _reserve, uint256 _ltv)\n    external\n    onlyLendingPoolConfigurator\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.baseLTVasCollateral = _ltv;\n    }\n\n    /\n    * @notice allows the configurator to update the liquidation threshold of a reserve\n    * @param _reserve the address of the reserve\n    * @param _threshold the new liquidation threshold\n    /\n    function setReserveLiquidationThreshold(address _reserve, uint256 _threshold)\n    external\n    onlyLendingPoolConfigurator\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.liquidationThreshold = _threshold;\n    }\n\n    /\n    * @notice allows the configurator to update the liquidation bonus of a reserve\n    * @param _reserve the address of the reserve\n    * @param _bonus the new liquidation bonus\n    /\n    function setReserveLiquidationBonus(address _reserve, uint256 _bonus)\n    external\n    onlyLendingPoolConfigurator\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.liquidationBonus = _bonus;\n    }\n\n    /\n    * @notice allows the configurator to update the reserve decimals\n    * @param _reserve the address of the reserve\n    * @param _decimals the decimals of the reserve\n    /\n    function setReserveDecimals(address _reserve, uint256 _decimals)\n    external\n    onlyLendingPoolConfigurator\n    {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        reserve.decimals = _decimals;\n    }\n\n    /\n    * @notice internal functions\n    /\n\n    /\n    * @dev updates the state of a reserve as a consequence of a borrow action.\n    * @param _reserve the address of the reserve on which the user is borrowing\n    * @param _user the address of the borrower\n    * @param _principalBorrowBalance the previous borrow balance of the borrower before the action\n    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount\n    * @param _amountBorrowed the new amount borrowed\n    * @param _rateMode the borrow rate mode (stable, variable)\n    /\n\n    function updateReserveStateOnBorrowInternal(\n        address _reserve,\n        address _user,\n        uint256 _principalBorrowBalance,\n        uint256 _balanceIncrease,\n        uint256 _amountBorrowed,\n        CoreLibrary.InterestRateMode _rateMode\n    ) internal {\n        reserves[_reserve].updateCumulativeIndexes();\n\n        //increasing reserve total borrows to account for the new borrow balance of the user\n        //NOTE: Depending on the previous borrow mode, the borrows might need to be switched from variable to stable or vice versa\n\n        updateReserveTotalBorrowsByRateModeInternal(\n            _reserve,\n            _user,\n            _principalBorrowBalance,\n            _balanceIncrease,\n            _amountBorrowed,\n            _rateMode\n        );\n    }\n\n    /\n    * @dev updates the state of a user as a consequence of a borrow action.\n    * @param _reserve the address of the reserve on which the user is borrowing\n    * @param _user the address of the borrower\n    * @param _amountBorrowed the amount borrowed\n    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount\n    * @param _rateMode the borrow rate mode (stable, variable)\n    * @return the final borrow rate for the user. Emitted by the borrow() event\n    /\n\n    function updateUserStateOnBorrowInternal(\n        address _reserve,\n        address _user,\n        uint256 _amountBorrowed,\n        uint256 _balanceIncrease,\n        uint256 _fee,\n        CoreLibrary.InterestRateMode _rateMode\n    ) internal {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n\n        if (_rateMode == CoreLibrary.InterestRateMode.STABLE) {\n            //stable\n            //reset the user variable index, and update the stable rate\n            user.stableBorrowRate = reserve.currentStableBorrowRate;\n            user.lastVariableBorrowCumulativeIndex = 0;\n        } else if (_rateMode == CoreLibrary.InterestRateMode.VARIABLE) {\n            //variable\n            //reset the user stable rate, and store the new borrow index\n            user.stableBorrowRate = 0;\n            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;\n        } else {\n            revert("Invalid borrow rate mode");\n        }\n        //increase the principal borrows and the origination fee\n        user.principalBorrowBalance = user.principalBorrowBalance.add(_amountBorrowed).add(\n            _balanceIncrease\n        );\n        user.originationFee = user.originationFee.add(_fee);\n\n        //solium-disable-next-line\n        user.lastUpdateTimestamp = uint40(block.timestamp);\n\n    }\n\n    /\n    * @dev updates the state of the reserve as a consequence of a repay action.\n    * @param _reserve the address of the reserve on which the user is repaying\n    * @param _user the address of the borrower\n    * @param _paybackAmountMinusFees the amount being paid back minus fees\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    /\n\n    function updateReserveStateOnRepayInternal(\n        address _reserve,\n        address _user,\n        uint256 _paybackAmountMinusFees,\n        uint256 _balanceIncrease\n    ) internal {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_reserve][_user];\n\n        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(_reserve, _user);\n\n        //update the indexes\n        reserves[_reserve].updateCumulativeIndexes();\n\n        //compound the cumulated interest to the borrow balance and then subtracting the payback amount\n        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {\n            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(\n                _balanceIncrease,\n                user.stableBorrowRate\n            );\n            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(\n                _paybackAmountMinusFees,\n                user.stableBorrowRate\n            );\n        } else {\n            reserve.increaseTotalBorrowsVariable(_balanceIncrease);\n            reserve.decreaseTotalBorrowsVariable(_paybackAmountMinusFees);\n        }\n    }\n\n    /\n    * @dev updates the state of the user as a consequence of a repay action.\n    * @param _reserve the address of the reserve on which the user is repaying\n    * @param _user the address of the borrower\n    * @param _paybackAmountMinusFees the amount being paid back minus fees\n    * @param _originationFeeRepaid the fee on the amount that is being repaid\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    * @param _repaidWholeLoan true if the user is repaying the whole loan\n    /\n    function updateUserStateOnRepayInternal(\n        address _reserve,\n        address _user,\n        uint256 _paybackAmountMinusFees,\n        uint256 _originationFeeRepaid,\n        uint256 _balanceIncrease,\n        bool _repaidWholeLoan\n    ) internal {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n\n        //update the user principal borrow balance, adding the cumulated interest and then subtracting the payback amount\n        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(\n            _paybackAmountMinusFees\n        );\n        user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;\n\n        //if the balance decrease is equal to the previous principal (user is repaying the whole loan)\n        //and the rate mode is stable, we reset the interest rate mode of the user\n        if (_repaidWholeLoan) {\n            user.stableBorrowRate = 0;\n            user.lastVariableBorrowCumulativeIndex = 0;\n        }\n        user.originationFee = user.originationFee.sub(_originationFeeRepaid);\n\n        //solium-disable-next-line\n        user.lastUpdateTimestamp = uint40(block.timestamp);\n\n    }\n\n    /\n    * @dev updates the state of the user as a consequence of a swap rate action.\n    * @param _reserve the address of the reserve on which the user is performing the rate swap\n    * @param _user the address of the borrower\n    * @param _principalBorrowBalance the the principal amount borrowed by the user\n    * @param _compoundedBorrowBalance the principal amount plus the accrued interest\n    * @param _currentRateMode the rate mode at which the user borrowed\n    /\n    function updateReserveStateOnSwapRateInternal(\n        address _reserve,\n        address _user,\n        uint256 _principalBorrowBalance,\n        uint256 _compoundedBorrowBalance,\n        CoreLibrary.InterestRateMode _currentRateMode\n    ) internal {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n\n        //compounding reserve indexes\n        reserve.updateCumulativeIndexes();\n\n        if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {\n            uint256 userCurrentStableRate = user.stableBorrowRate;\n\n            //swap to variable\n            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(\n                _principalBorrowBalance,\n                userCurrentStableRate\n            ); //decreasing stable from old principal balance\n            reserve.increaseTotalBorrowsVariable(_compoundedBorrowBalance); //increase variable borrows\n        } else if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {\n            //swap to stable\n            uint256 currentStableRate = reserve.currentStableBorrowRate;\n            reserve.decreaseTotalBorrowsVariable(_principalBorrowBalance);\n            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(\n                _compoundedBorrowBalance,\n                currentStableRate\n            );\n\n        } else {\n            revert("Invalid rate mode received");\n        }\n    }\n\n    /\n    * @dev updates the state of the user as a consequence of a swap rate action.\n    * @param _reserve the address of the reserve on which the user is performing the swap\n    * @param _user the address of the borrower\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    * @param _currentRateMode the current rate mode of the user\n    /\n\n    function updateUserStateOnSwapRateInternal(\n        address _reserve,\n        address _user,\n        uint256 _balanceIncrease,\n        CoreLibrary.InterestRateMode _currentRateMode\n    ) internal returns (CoreLibrary.InterestRateMode) {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n\n        CoreLibrary.InterestRateMode newMode = CoreLibrary.InterestRateMode.NONE;\n\n        if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {\n            //switch to stable\n            newMode = CoreLibrary.InterestRateMode.STABLE;\n            user.stableBorrowRate = reserve.currentStableBorrowRate;\n            user.lastVariableBorrowCumulativeIndex = 0;\n        } else if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {\n            newMode = CoreLibrary.InterestRateMode.VARIABLE;\n            user.stableBorrowRate = 0;\n            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;\n        } else {\n            revert("Invalid interest rate mode received");\n        }\n        //compounding cumulated interest\n        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);\n        //solium-disable-next-line\n        user.lastUpdateTimestamp = uint40(block.timestamp);\n\n        return newMode;\n    }\n\n    /\n    * @dev updates the state of the principal reserve as a consequence of a liquidation action.\n    * @param _principalReserve the address of the principal reserve that is being repaid\n    * @param _user the address of the borrower\n    * @param _amountToLiquidate the amount being repaid by the liquidator\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    /\n\n    function updatePrincipalReserveStateOnLiquidationInternal(\n        address _principalReserve,\n        address _user,\n        uint256 _amountToLiquidate,\n        uint256 _balanceIncrease\n    ) internal {\n        CoreLibrary.ReserveData storage reserve = reserves[_principalReserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_principalReserve];\n\n        //update principal reserve data\n        reserve.updateCumulativeIndexes();\n\n        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(\n            _principalReserve,\n            _user\n        );\n\n        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {\n            //increase the total borrows by the compounded interest\n            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(\n                _balanceIncrease,\n                user.stableBorrowRate\n            );\n\n            //decrease by the actual amount to liquidate\n            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(\n                _amountToLiquidate,\n                user.stableBorrowRate\n            );\n\n        } else {\n            //increase the total borrows by the compounded interest\n            reserve.increaseTotalBorrowsVariable(_balanceIncrease);\n\n            //decrease by the actual amount to liquidate\n            reserve.decreaseTotalBorrowsVariable(_amountToLiquidate);\n        }\n\n    }\n\n    /\n    * @dev updates the state of the collateral reserve as a consequence of a liquidation action.\n    * @param _collateralReserve the address of the collateral reserve that is being liquidated\n    /\n    function updateCollateralReserveStateOnLiquidationInternal(\n        address _collateralReserve\n    ) internal {\n        //update collateral reserve\n        reserves[_collateralReserve].updateCumulativeIndexes();\n\n    }\n\n    /\n    * @dev updates the state of the user being liquidated as a consequence of a liquidation action.\n    * @param _reserve the address of the principal reserve that is being repaid\n    * @param _user the address of the borrower\n    * @param _amountToLiquidate the amount being repaid by the liquidator\n    * @param _feeLiquidated the amount of origination fee being liquidated\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    /\n    function updateUserStateOnLiquidationInternal(\n        address _reserve,\n        address _user,\n        uint256 _amountToLiquidate,\n        uint256 _feeLiquidated,\n        uint256 _balanceIncrease\n    ) internal {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        //first increase by the compounded interest, then decrease by the liquidated amount\n        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(\n            _amountToLiquidate\n        );\n\n        if (\n            getUserCurrentBorrowRateMode(_reserve, _user) == CoreLibrary.InterestRateMode.VARIABLE\n        ) {\n            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;\n        }\n\n        if(_feeLiquidated &gt; 0){\n            user.originationFee = user.originationFee.sub(_feeLiquidated);\n        }\n\n        //solium-disable-next-line\n        user.lastUpdateTimestamp = uint40(block.timestamp);\n    }\n\n    /\n    * @dev updates the state of the reserve as a consequence of a stable rate rebalance\n    * @param _reserve the address of the principal reserve where the user borrowed\n    * @param _user the address of the borrower\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    /\n\n    function updateReserveStateOnRebalanceInternal(\n        address _reserve,\n        address _user,\n        uint256 _balanceIncrease\n    ) internal {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n\n        reserve.updateCumulativeIndexes();\n\n        reserve.increaseTotalBorrowsStableAndUpdateAverageRate(\n            _balanceIncrease,\n            user.stableBorrowRate\n        );\n\n    }\n\n    /\n    * @dev updates the state of the user as a consequence of a stable rate rebalance\n    * @param _reserve the address of the principal reserve where the user borrowed\n    * @param _user the address of the borrower\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    /\n\n    function updateUserStateOnRebalanceInternal(\n        address _reserve,\n        address _user,\n        uint256 _balanceIncrease\n    ) internal {\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n\n        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);\n        user.stableBorrowRate = reserve.currentStableBorrowRate;\n\n        //solium-disable-next-line\n        user.lastUpdateTimestamp = uint40(block.timestamp);\n    }\n\n    /\n    * @dev updates the state of the user as a consequence of a stable rate rebalance\n    * @param _reserve the address of the principal reserve where the user borrowed\n    * @param _user the address of the borrower\n    * @param _balanceIncrease the accrued interest on the borrowed amount\n    * @param _amountBorrowed the accrued interest on the borrowed amount\n    /\n    function updateReserveTotalBorrowsByRateModeInternal(\n        address _reserve,\n        address _user,\n        uint256 _principalBalance,\n        uint256 _balanceIncrease,\n        uint256 _amountBorrowed,\n        CoreLibrary.InterestRateMode _newBorrowRateMode\n    ) internal {\n        CoreLibrary.InterestRateMode previousRateMode = getUserCurrentBorrowRateMode(\n            _reserve,\n            _user\n        );\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n\n        if (previousRateMode == CoreLibrary.InterestRateMode.STABLE) {\n            CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(\n                _principalBalance,\n                user.stableBorrowRate\n            );\n        } else if (previousRateMode == CoreLibrary.InterestRateMode.VARIABLE) {\n            reserve.decreaseTotalBorrowsVariable(_principalBalance);\n        }\n\n        uint256 newPrincipalAmount = _principalBalance.add(_balanceIncrease).add(_amountBorrowed);\n        if (_newBorrowRateMode == CoreLibrary.InterestRateMode.STABLE) {\n            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(\n                newPrincipalAmount,\n                reserve.currentStableBorrowRate\n            );\n        } else if (_newBorrowRateMode == CoreLibrary.InterestRateMode.VARIABLE) {\n            reserve.increaseTotalBorrowsVariable(newPrincipalAmount);\n        } else {\n            revert("Invalid new borrow rate mode");\n        }\n    }\n\n    /\n    * @dev Updates the reserve current stable borrow rate Rf, the current variable borrow rate Rv and the current liquidity rate Rl.\n    * Also updates the lastUpdateTimestamp value. Please refer to the whitepaper for further information.\n    * @param _reserve the address of the reserve to be updated\n    * @param _liquidityAdded the amount of liquidity added to the protocol (deposit or repay) in the previous action\n    * @param _liquidityTaken the amount of liquidity taken from the protocol (redeem or borrow)\n    /\n\n    function updateReserveInterestRatesAndTimestampInternal(\n        address _reserve,\n        uint256 _liquidityAdded,\n        uint256 _liquidityTaken\n    ) internal {\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n        (uint256 newLiquidityRate, uint256 newStableRate, uint256 newVariableRate) = IReserveInterestRateStrategy(\n            reserve\n            .interestRateStrategyAddress\n        )\n        .calculateInterestRates(\n            _reserve,\n            getReserveAvailableLiquidity(_reserve).add(_liquidityAdded).sub(_liquidityTaken),\n            reserve.totalBorrowsStable,\n            reserve.totalBorrowsVariable,\n            reserve.currentAverageStableBorrowRate\n        );\n\n        reserve.currentLiquidityRate = newLiquidityRate;\n        reserve.currentStableBorrowRate = newStableRate;\n        reserve.currentVariableBorrowRate = newVariableRate;\n\n        //solium-disable-next-line\n        reserve.lastUpdateTimestamp = uint40(block.timestamp);\n\n        emit ReserveUpdated(\n            _reserve,\n            newLiquidityRate,\n            newStableRate,\n            newVariableRate,\n            reserve.lastLiquidityCumulativeIndex,\n            reserve.lastVariableBorrowCumulativeIndex\n        );\n    }\n\n    /\n    * @dev transfers to the protocol fees of a flashloan to the fees collection address\n    * @param _token the address of the token being transferred\n    * @param _amount the amount being transferred\n    /\n\n    function transferFlashLoanProtocolFeeInternal(address _token, uint256 _amount) internal {\n        address payable receiver = address(uint160(addressesProvider.getTokenDistributor()));\n\n        if (_token != EthAddressLib.ethAddress()) {\n            ERC20(_token).safeTransfer(receiver, _amount);\n        } else {\n            receiver.transfer(_amount);\n        }\n    }\n\n    /\n    * @dev updates the internal configuration of the core\n    /\n    function refreshConfigInternal() internal {\n        lendingPoolAddress = addressesProvider.getLendingPool();\n    }\n\n    /\n    * @dev adds a reserve to the array of the reserves address\n    /\n    function addReserveToListInternal(address _reserve) internal {\n        bool reserveAlreadyAdded = false;\n        for (uint256 i = 0; i &lt; reservesList.length; i++)\n            if (reservesList[i] == _reserve) {\n                reserveAlreadyAdded = true;\n            }\n        if (!reserveAlreadyAdded) reservesList.push(_reserve);\n    }\n\n}\n', 'ideas': ' Security', 'test_reports': 'The software run successfully without errors.', 'exist_bugs_flag': False} |

[2024-01-09 04:32:16 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | pragma solidity ^0.5.0; import "openzeppelin-solidity/contracts/math/SafeMath.sol"; import "openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol"; import "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol"; import "openzeppelin-solidity/contracts/utils/Address.sol"; import "../libraries/openzeppelin-upgradeability/VersionedInitializable.sol"; import "../libraries/CoreLibrary.sol"; import "../configuration/LendingPoolAddressesProvider.sol"; import "../interfaces/ILendingRateOracle.sol"; import "../interfaces/IReserveInterestRateStrategy.sol"; import "../libraries/WadRayMath.sol"; import "../tokenization/AToken.sol"; import "../libraries/EthAddressLib.sol"; / * @title LendingPoolCore contract * @author Aave * @notice Holds the state of the lending pool and all the funds deposited * @dev NOTE: The core does not enforce security checks on the update of the state * (eg, updateStateOnBorrow() does not enforce that borrowed is enabled on the reserve). * The check that an action can be performed is a duty of the overlying LendingPool contract. / contract LendingPoolCore is VersionedInitializable {     using SafeMath for uint256;     using WadRayMath for uint256;     using CoreLibrary for CoreLibrary.ReserveData;     using CoreLibrary for CoreLibrary.UserReserveData;     using SafeERC20 for ERC20;     using Address for address payable; /** * @dev Emitted when the state of a reserve is updated * @param reserve the address of the reserve * @param liquidityRate the new liquidity rate * @param stableBorrowRate the new stable borrow rate * @param variableBorrowRate the new variable borrow rate * @param liquidityIndex the new liquidity index * @param variableBorrowIndex the new variable borrow index **/ event ReserveUpdated(     address indexed reserve,     uint256 liquidityRate,     uint256 stableBorrowRate,     uint256 variableBorrowRate,     uint256 liquidityIndex,     uint256 variableBorrowIndex );  address public lendingPoolAddress;  LendingPoolAddressesProvider public addressesProvider;  /** * @dev only lending pools can use functions affected by this modifier **/ modifier onlyLendingPool {     require(lendingPoolAddress == msg.sender, "The caller must be a lending pool contract");     _; }  /** * @dev only lending pools configurator can use functions affected by this modifier **/ modifier onlyLendingPoolConfigurator {     require(         addressesProvider.getLendingPoolConfigurator() == msg.sender,         "The caller must be a lending pool configurator contract"     );     _; }  mapping(address =&gt; CoreLibrary.ReserveData) internal reserves; mapping(address =&gt; mapping(address =&gt; CoreLibrary.UserReserveData)) internal usersReserveData;  address[] public reservesList;  uint256 public constant CORE_REVISION = 0x4;  /** * @dev returns the revision number of the contract **/ function getRevision() internal pure returns (uint256) {     return CORE_REVISION; }  /** * @dev initializes the Core contract, invoked upon registration on the AddressesProvider * @param _addressesProvider the addressesProvider contract **/  function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {     addressesProvider = _addressesProvider;     refreshConfigInternal(); }  /** * @dev updates the state of the core as a result of a deposit action * @param _reserve the address of the reserve in which the deposit is happening * @param _user the address of the the user depositing * @param _amount the amount being deposited * @param _isFirstDeposit true if the user is depositing for the first time **/  function updateStateOnDeposit(     address _reserve,     address _user,     uint256 _amount,     bool _isFirstDeposit ) external onlyLendingPool {     reserves[_reserve].updateCumulativeIndexes();     updateReserveInterestRatesAndTimestampInternal(_reserve, _amount, 0);      if (_isFirstDeposit) {         //if this is the first deposit of the user, we configure the deposit as enabled to be used as collateral         setUserUseReserveAsCollateral(_reserve, _user, true);     } }  /** * @dev updates the state of the core as a result of a redeem action * @param _reserve the address of the reserve in which the redeem is happening * @param _user the address of the the user redeeming * @param _amountRedeemed the amount being redeemed * @param _userRedeemedEverything true if the user is redeeming everything **/ function updateStateOnRedeem(     address _reserve,     address _user,     uint256 _amountRedeemed,     bool _userRedeemedEverything ) external onlyLendingPool {     //compound liquidity and variable borrow interests     reserves[_reserve].updateCumulativeIndexes();     updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountRedeemed);      //if user redeemed everything the useReserveAsCollateral flag is reset     if (_userRedeemedEverything) {         setUserUseReserveAsCollateral(_reserve, _user, false);     } }  /** * @dev updates the state of the core as a result of a flashloan action * @param _reserve the address of the reserve in which the flashloan is happening * @param _income the income of the protocol as a result of the action **/ function updateStateOnFlashLoan(     address _reserve,     uint256 _availableLiquidityBefore,     uint256 _income,     uint256 _protocolFee ) external onlyLendingPool {     transferFlashLoanProtocolFeeInternal(_reserve, _protocolFee);      //compounding the cumulated interest     reserves[_reserve].updateCumulativeIndexes();      uint256 totalLiquidityBefore = _availableLiquidityBefore.add(         getReserveTotalBorrows(_reserve)     );      //compounding the received fee into the reserve     reserves[_reserve].cumulateToLiquidityIndex(totalLiquidityBefore, _income);      //refresh interest rates     updateReserveInterestRatesAndTimestampInternal(_reserve, _income, 0); }  /** * @dev updates the state of the core as a consequence of a borrow action. * @param _reserve the address of the reserve on which the user is borrowing * @param _user the address of the borrower * @param _amountBorrowed the new amount borrowed * @param _borrowFee the fee on the amount borrowed * @param _rateMode the borrow rate mode (stable, variable) * @return the new borrow rate for the user **/ function updateStateOnBorrow(     address _reserve,     address _user,     uint256 _amountBorrowed,     uint256 _borrowFee,     CoreLibrary.InterestRateMode _rateMode ) external onlyLendingPool returns (uint256, uint256) {     // getting the previous borrow data of the user     (uint256 principalBorrowBalance, , uint256 balanceIncrease) = getUserBorrowBalances(         _reserve,         _user     );      updateReserveStateOnBorrowInternal(         _reserve,         _user,         principalBorrowBalance,         balanceIncrease,         _amountBorrowed,         _rateMode     );      updateUserStateOnBorrowInternal(         _reserve,         _user,         _amountBorrowed,         balanceIncrease,         _borrowFee,         _rateMode     );      updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountBorrowed);      return (getUserCurrentBorrowRate(_reserve, _user), balanceIncrease); }  /** * @dev updates the state of the core as a consequence of a repay action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _paybackAmountMinusFees the amount being paid back minus fees * @param _originationFeeRepaid the fee on the amount that is being repaid * @param _balanceIncrease the accrued interest on the borrowed amount * @param _repaidWholeLoan true if the user is repaying the whole loan **/  function updateStateOnRepay(     address _reserve,     address _user,     uint256 _paybackAmountMinusFees,     uint256 _originationFeeRepaid,     uint256 _balanceIncrease,     bool _repaidWholeLoan ) external onlyLendingPool {     updateReserveStateOnRepayInternal(         _reserve,         _user,         _paybackAmountMinusFees,         _balanceIncrease     );     updateUserStateOnRepayInternal(         _reserve,         _user,         _paybackAmountMinusFees,         _originationFeeRepaid,         _balanceIncrease,         _repaidWholeLoan     );      updateReserveInterestRatesAndTimestampInternal(_reserve, _paybackAmountMinusFees, 0); }  /** * @dev updates the state of the core as a consequence of a swap rate action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _principalBorrowBalance the amount borrowed by the user * @param _compoundedBorrowBalance the amount borrowed plus accrued interest * @param _balanceIncrease the accrued interest on the borrowed amount * @param _currentRateMode the current interest rate mode for the user **/ function updateStateOnSwapRate(     address _reserve,     address _user,     uint256 _principalBorrowBalance,     uint256 _compoundedBorrowBalance,     uint256 _balanceIncrease,     CoreLibrary.InterestRateMode _currentRateMode ) external onlyLendingPool returns (CoreLibrary.InterestRateMode, uint256) {     updateReserveStateOnSwapRateInternal(         _reserve,         _user,         _principalBorrowBalance,         _compoundedBorrowBalance,         _currentRateMode     );      CoreLibrary.InterestRateMode newRateMode = updateUserStateOnSwapRateInternal(         _reserve,         _user,         _balanceIncrease,         _currentRateMode     );      updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);      return (newRateMode, getUserCurrentBorrowRate(_reserve, _user)); }  /** * @dev updates the state of the core as a consequence of a liquidation action. * @param _principalReserve the address of the principal reserve that is being repaid * @param _collateralReserve the address of the collateral reserve that is being liquidated * @param _user the address of the borrower * @param _amountToLiquidate the amount being repaid by the liquidator * @param _collateralToLiquidate the amount of collateral being liquidated * @param _feeLiquidated the amount of origination fee being liquidated * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus * @param _balanceIncrease the accrued interest on the borrowed amount * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise **/ function updateStateOnLiquidation(     address _principalReserve,     address _collateralReserve,     address _user,     uint256 _amountToLiquidate,     uint256 _collateralToLiquidate,     uint256 _feeLiquidated,     uint256 _liquidatedCollateralForFee,     uint256 _balanceIncrease,     bool _liquidatorReceivesAToken ) external onlyLendingPool {     updatePrincipalReserveStateOnLiquidationInternal(         _principalReserve,         _user,         _amountToLiquidate,         _balanceIncrease     );      updateCollateralReserveStateOnLiquidationInternal(         _collateralReserve     );      updateUserStateOnLiquidationInternal(         _principalReserve,         _user,         _amountToLiquidate,         _feeLiquidated,         _balanceIncrease     );      updateReserveInterestRatesAndTimestampInternal(_principalReserve, _amountToLiquidate, 0);      if (!_liquidatorReceivesAToken) {         updateReserveInterestRatesAndTimestampInternal(             _collateralReserve,             0,             _collateralToLiquidate.add(_liquidatedCollateralForFee)         );     }  }  /** * @dev updates the state of the core as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount * @return the new stable rate for the user **/ function updateStateOnRebalance(address _reserve, address _user, uint256 _balanceIncrease) external onlyLendingPool returns (uint256) {     updateReserveStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);      //update user data and rebalance the rate     updateUserStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);     updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);     return usersReserveData[_user][_reserve].stableBorrowRate; }  /** * @dev enables or disables a reserve as collateral * @param _reserve the address of the principal reserve where the user deposited * @param _user the address of the depositor * @param _useAsCollateral true if the depositor wants to use the reserve as collateral **/ function setUserUseReserveAsCollateral(address _reserve, address _user, bool _useAsCollateral) public onlyLendingPool {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     user.useAsCollateral = _useAsCollateral; }  /** * @notice ETH/token transfer functions **/  /** * @dev fallback function enforces that the caller is a contract, to support flashloan transfers **/ function() external payable {     //only contracts can send ETH to the core     require(msg.sender.isContract(), "Only contracts can send ether to the Lending pool core");  }  /** * @dev transfers to the user a specific amount from the reserve. * @param _reserve the address of the reserve where the transfer is happening * @param _user the address of the user receiving the transfer * @param _amount the amount being transferred **/ function transferToUser(address _reserve, address payable _user, uint256 _amount) external onlyLendingPool {     if (_reserve != EthAddressLib.ethAddress()) {         ERC20(_reserve).safeTransfer(_user, _amount);     } else {         //solium-disable-next-line         (bool result, ) = _user.call.value(_amount).gas(50000)("");         require(result, "Transfer of ETH failed");     } }  /** * @dev transfers the protocol fees to the fees collection address * @param _token the address of the token being transferred * @param _user the address of the user from where the transfer is happening * @param _amount the amount being transferred * @param _destination the fee receiver address **/  function transferToFeeCollectionAddress(     address _token,     address _user,     uint256 _amount,     address _destination ) external payable onlyLendingPool {     address payable feeAddress = address(uint160(_destination)); //cast the address to payable      if (_token != EthAddressLib.ethAddress()) {         require(             msg.value == 0,             "User is sending ETH along with the ERC20 transfer. Check the value attribute of the transaction"         );         ERC20(_token).safeTransferFrom(_user, feeAddress, _amount);     } else {         require(msg.value &gt;= _amount, "The amount and the value sent to deposit do not match");         //solium-disable-next-line         (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");         require(result, "Transfer of ETH failed");     } }  /** * @dev transfers the fees to the fees collection address in the case of liquidation * @param _token the address of the token being transferred * @param _amount the amount being transferred * @param _destination the fee receiver address **/ function liquidateFee(     address _token,     uint256 _amount,     address _destination ) external payable onlyLendingPool {     address payable feeAddress = address(uint160(_destination)); //cast the address to payable     require(         msg.value == 0,         "Fee liquidation does not require any transfer of value"     );      if (_token != EthAddressLib.ethAddress()) {         ERC20(_token).safeTransfer(feeAddress, _amount);     } else {         //solium-disable-next-line         (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");         require(result, "Transfer of ETH failed");     } }  /** * @dev transfers an amount from a user to the destination reserve * @param _reserve the address of the reserve where the amount is being transferred * @param _user the address of the user from where the transfer is happening * @param _amount the amount being transferred **/ function transferToReserve(address _reserve, address payable _user, uint256 _amount) external payable onlyLendingPool {     if (_reserve != EthAddressLib.ethAddress()) {         require(msg.value == 0, "User is sending ETH along with the ERC20 transfer.");         ERC20(_reserve).safeTransferFrom(_user, address(this), _amount);      } else {         require(msg.value &gt;= _amount, "The amount and the value sent to deposit do not match");          if (msg.value &gt; _amount) {             //send back excess ETH             uint256 excessAmount = msg.value.sub(_amount);             //solium-disable-next-line             (bool result, ) = _user.call.value(excessAmount).gas(50000)("");             require(result, "Transfer of ETH failed");         }     } }  /** * @notice data access functions **/  /** * @dev returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral) * needed to calculate the global account data in the LendingPoolDataProvider * @param _reserve the address of the reserve * @param _user the address of the user * @return the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not **/ function getUserBasicReserveData(address _reserve, address _user) external view returns (uint256, uint256, uint256, bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      uint256 underlyingBalance = getUserUnderlyingAssetBalance(_reserve, _user);      if (user.principalBorrowBalance == 0) {         return (underlyingBalance, 0, 0, user.useAsCollateral);     }      return (     underlyingBalance,     user.getCompoundedBorrowBalance(reserve),     user.originationFee,     user.useAsCollateral     ); }  /** * @dev checks if a user is allowed to borrow at a stable rate * @param _reserve the reserve address * @param _user the user * @param _amount the amount the the user wants to borrow * @return true if the user is allowed to borrow at a stable rate, false otherwise **/  function isUserAllowedToBorrowAtStable(address _reserve, address _user, uint256 _amount) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      if (!reserve.isStableBorrowRateEnabled) return false;      return     !user.useAsCollateral ||     !reserve.usageAsCollateralEnabled ||     _amount &gt; getUserUnderlyingAssetBalance(_reserve, _user); }  /** * @dev gets the underlying asset balance of a user based on the corresponding aToken balance. * @param _reserve the reserve address * @param _user the user address * @return the underlying deposit balance of the user **/  function getUserUnderlyingAssetBalance(address _reserve, address _user) public view returns (uint256) {     AToken aToken = AToken(reserves[_reserve].aTokenAddress);     return aToken.balanceOf(_user);  }  /** * @dev gets the interest rate strategy contract address for the reserve * @param _reserve the reserve address * @return the address of the interest rate strategy contract **/ function getReserveInterestRateStrategyAddress(address _reserve) public view returns (address) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.interestRateStrategyAddress; }  /** * @dev gets the aToken contract address for the reserve * @param _reserve the reserve address * @return the address of the aToken contract **/  function getReserveATokenAddress(address _reserve) public view returns (address) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.aTokenAddress; }  /** * @dev gets the available liquidity in the reserve. The available liquidity is the balance of the core contract * @param _reserve the reserve address * @return the available liquidity **/ function getReserveAvailableLiquidity(address _reserve) public view returns (uint256) {     uint256 balance = 0;      if (_reserve == EthAddressLib.ethAddress()) {         balance = address(this).balance;     } else {         balance = IERC20(_reserve).balanceOf(address(this));     }     return balance; }  /** * @dev gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows * @param _reserve the reserve address * @return the total liquidity **/ function getReserveTotalLiquidity(address _reserve) public view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return getReserveAvailableLiquidity(_reserve).add(reserve.getTotalBorrows()); }  /** * @dev gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there * there has been 100% income. * @param _reserve the reserve address * @return the reserve normalized income **/ function getReserveNormalizedIncome(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.getNormalizedIncome(); }  /** * @dev gets the reserve total borrows * @param _reserve the reserve address * @return the total borrows (stable + variable) **/ function getReserveTotalBorrows(address _reserve) public view returns (uint256) {     return reserves[_reserve].getTotalBorrows(); }  /** * @dev gets the reserve total borrows stable * @param _reserve the reserve address * @return the total borrows stable **/ function getReserveTotalBorrowsStable(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.totalBorrowsStable; }  /** * @dev gets the reserve total borrows variable * @param _reserve the reserve address * @return the total borrows variable **/  function getReserveTotalBorrowsVariable(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.totalBorrowsVariable; }  /** * @dev gets the reserve liquidation threshold * @param _reserve the reserve address * @return the reserve liquidation threshold **/  function getReserveLiquidationThreshold(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.liquidationThreshold; }  /** * @dev gets the reserve liquidation bonus * @param _reserve the reserve address * @return the reserve liquidation bonus **/  function getReserveLiquidationBonus(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.liquidationBonus; }  /** * @dev gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty * @param _reserve the reserve address * @return the reserve current variable borrow rate **/  function getReserveCurrentVariableBorrowRate(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      if (reserve.currentVariableBorrowRate == 0) {         return         IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)         .getBaseVariableBorrowRate();     }     return reserve.currentVariableBorrowRate; }  /** * @dev gets the reserve current stable borrow rate. Is the market rate if the reserve is empty * @param _reserve the reserve address * @return the reserve current stable borrow rate **/  function getReserveCurrentStableBorrowRate(address _reserve) public view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     ILendingRateOracle oracle = ILendingRateOracle(addressesProvider.getLendingRateOracle());      if (reserve.currentStableBorrowRate == 0) {         //no stable rate borrows yet         return oracle.getMarketBorrowRate(_reserve);     }      return reserve.currentStableBorrowRate; }  /** * @dev gets the reserve average stable borrow rate. The average stable rate is the weighted average * of all the loans taken at stable rate. * @param _reserve the reserve address * @return the reserve current average borrow rate **/ function getReserveCurrentAverageStableBorrowRate(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.currentAverageStableBorrowRate; }  /** * @dev gets the reserve liquidity rate * @param _reserve the reserve address * @return the reserve liquidity rate **/ function getReserveCurrentLiquidityRate(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.currentLiquidityRate; }  /** * @dev gets the reserve liquidity cumulative index * @param _reserve the reserve address * @return the reserve liquidity cumulative index **/ function getReserveLiquidityCumulativeIndex(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.lastLiquidityCumulativeIndex; }  /** * @dev gets the reserve variable borrow index * @param _reserve the reserve address * @return the reserve variable borrow index **/ function getReserveVariableBorrowsCumulativeIndex(address _reserve) external view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.lastVariableBorrowCumulativeIndex; }  /** * @dev this function aggregates the configuration parameters of the reserve. * It's used in the LendingPoolDataProvider specifically to save gas, and avoid * multiple external contract calls to fetch the same data. * @param _reserve the reserve address * @return the reserve decimals * @return the base ltv as collateral * @return the liquidation threshold * @return if the reserve is used as collateral or not **/ function getReserveConfiguration(address _reserve) external view returns (uint256, uint256, uint256, bool) {     uint256 decimals;     uint256 baseLTVasCollateral;     uint256 liquidationThreshold;     bool usageAsCollateralEnabled;      CoreLibrary.ReserveData storage reserve = reserves[_reserve];     decimals = reserve.decimals;     baseLTVasCollateral = reserve.baseLTVasCollateral;     liquidationThreshold = reserve.liquidationThreshold;     usageAsCollateralEnabled = reserve.usageAsCollateralEnabled;      return (decimals, baseLTVasCollateral, liquidationThreshold, usageAsCollateralEnabled); }  /** * @dev returns the decimals of the reserve * @param _reserve the reserve address * @return the reserve decimals **/ function getReserveDecimals(address _reserve) external view returns (uint256) {     return reserves[_reserve].decimals; }  /** * @dev returns true if the reserve is enabled for borrowing * @param _reserve the reserve address * @return true if the reserve is enabled for borrowing, false otherwise **/  function isReserveBorrowingEnabled(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.borrowingEnabled; }  /** * @dev returns true if the reserve is enabled as collateral * @param _reserve the reserve address * @return true if the reserve is enabled as collateral, false otherwise **/  function isReserveUsageAsCollateralEnabled(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.usageAsCollateralEnabled; }  /** * @dev returns true if the stable rate is enabled on reserve * @param _reserve the reserve address * @return true if the stable rate is enabled on reserve, false otherwise **/ function getReserveIsStableBorrowRateEnabled(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.isStableBorrowRateEnabled; }  /** * @dev returns true if the reserve is active * @param _reserve the reserve address * @return true if the reserve is active, false otherwise **/ function getReserveIsActive(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.isActive; }  /** * @notice returns if a reserve is freezed * @param _reserve the reserve for which the information is needed * @return true if the reserve is freezed, false otherwise **/  function getReserveIsFreezed(address _reserve) external view returns (bool) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     return reserve.isFreezed; }  /** * @notice returns the timestamp of the last action on the reserve * @param _reserve the reserve for which the information is needed * @return the last updated timestamp of the reserve **/  function getReserveLastUpdate(address _reserve) external view returns (uint40 timestamp) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     timestamp = reserve.lastUpdateTimestamp; }  /** * @dev returns the utilization rate U of a specific reserve * @param _reserve the reserve for which the information is needed * @return the utilization rate in ray **/  function getReserveUtilizationRate(address _reserve) public view returns (uint256) {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      uint256 totalBorrows = reserve.getTotalBorrows();      if (totalBorrows == 0) {         return 0;     }      uint256 availableLiquidity = getReserveAvailableLiquidity(_reserve);      return totalBorrows.rayDiv(availableLiquidity.add(totalBorrows)); }  /** * @return the array of reserves configured on the core **/ function getReserves() external view returns (address[] memory) {     return reservesList; }  /** * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return true if the user has chosen to use the reserve as collateral, false otherwise **/ function isUserUseReserveAsCollateralEnabled(address _reserve, address _user) external view returns (bool) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.useAsCollateral; }  /** * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the origination fee for the user **/ function getUserOriginationFee(address _reserve, address _user) external view returns (uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.originationFee; }  /** * @dev users with no loans in progress have NONE as borrow rate mode * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the borrow rate mode for the user, **/  function getUserCurrentBorrowRateMode(address _reserve, address _user) public view returns (CoreLibrary.InterestRateMode) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      if (user.principalBorrowBalance == 0) {         return CoreLibrary.InterestRateMode.NONE;     }      return     user.stableBorrowRate &gt; 0     ? CoreLibrary.InterestRateMode.STABLE     : CoreLibrary.InterestRateMode.VARIABLE; }  /** * @dev gets the current borrow rate of the user * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the borrow rate for the user, **/ function getUserCurrentBorrowRate(address _reserve, address _user) internal view returns (uint256) {     CoreLibrary.InterestRateMode rateMode = getUserCurrentBorrowRateMode(_reserve, _user);      if (rateMode == CoreLibrary.InterestRateMode.NONE) {         return 0;     }      return     rateMode == CoreLibrary.InterestRateMode.STABLE     ? usersReserveData[_user][_reserve].stableBorrowRate     : reserves[_reserve].currentVariableBorrowRate; }  /** * @dev the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the user stable rate **/ function getUserCurrentStableBorrowRate(address _reserve, address _user) external view returns (uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.stableBorrowRate; }  /** * @dev calculates and returns the borrow balances of the user * @param _reserve the address of the reserve * @param _user the address of the user * @return the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance **/  function getUserBorrowBalances(address _reserve, address _user) public view returns (uint256, uint256, uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     if (user.principalBorrowBalance == 0) {         return (0, 0, 0);     }      uint256 principal = user.principalBorrowBalance;     uint256 compoundedBalance = CoreLibrary.getCompoundedBorrowBalance(         user,         reserves[_reserve]     );     return (principal, compoundedBalance, compoundedBalance.sub(principal)); }  /** * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the variable borrow index for the user **/  function getUserVariableBorrowCumulativeIndex(address _reserve, address _user) external view returns (uint256) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     return user.lastVariableBorrowCumulativeIndex; }  /** * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable * @param _reserve the address of the reserve for which the information is needed * @param _user the address of the user for which the information is needed * @return the variable borrow index for the user **/  function getUserLastUpdate(address _reserve, address _user) external view returns (uint256 timestamp) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     timestamp = user.lastUpdateTimestamp; }  /** * @dev updates the lending pool core configuration **/ function refreshConfiguration() external onlyLendingPoolConfigurator {     refreshConfigInternal(); }  /** * @dev initializes a reserve * @param _reserve the address of the reserve * @param _aTokenAddress the address of the overlying aToken contract * @param _decimals the decimals of the reserve currency * @param _interestRateStrategyAddress the address of the interest rate strategy contract **/ function initReserve(     address _reserve,     address _aTokenAddress,     uint256 _decimals,     address _interestRateStrategyAddress ) external onlyLendingPoolConfigurator {     reserves[_reserve].init(_aTokenAddress, _decimals, _interestRateStrategyAddress);     addReserveToListInternal(_reserve);  }    /** * @dev removes the last added reserve in the reservesList array * @param _reserveToRemove the address of the reserve **/ function removeLastAddedReserve(address _reserveToRemove) external onlyLendingPoolConfigurator {      address lastReserve = reservesList[reservesList.length-1];      require(lastReserve == _reserveToRemove, "Reserve being removed is different than the reserve requested");      //as we can't check if totalLiquidity is 0 (since the reserve added might not be an ERC20) we at least check that there is nothing borrowed     require(getReserveTotalBorrows(lastReserve) == 0, "Cannot remove a reserve with liquidity deposited");      reserves[lastReserve].isActive = false;     reserves[lastReserve].aTokenAddress = address(0);     reserves[lastReserve].decimals = 0;     reserves[lastReserve].lastLiquidityCumulativeIndex = 0;     reserves[lastReserve].lastVariableBorrowCumulativeIndex = 0;     reserves[lastReserve].borrowingEnabled = false;     reserves[lastReserve].usageAsCollateralEnabled = false;     reserves[lastReserve].baseLTVasCollateral = 0;     reserves[lastReserve].liquidationThreshold = 0;     reserves[lastReserve].liquidationBonus = 0;     reserves[lastReserve].interestRateStrategyAddress = address(0);      reservesList.pop(); }  /** * @dev updates the address of the interest rate strategy contract * @param _reserve the address of the reserve * @param _rateStrategyAddress the address of the interest rate strategy contract **/  function setReserveInterestRateStrategyAddress(address _reserve, address _rateStrategyAddress) external onlyLendingPoolConfigurator {     reserves[_reserve].interestRateStrategyAddress = _rateStrategyAddress; }  /** * @dev enables borrowing on a reserve. Also sets the stable rate borrowing * @param _reserve the address of the reserve * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise **/  function enableBorrowingOnReserve(address _reserve, bool _stableBorrowRateEnabled) external onlyLendingPoolConfigurator {     reserves[_reserve].enableBorrowing(_stableBorrowRateEnabled); }  /** * @dev disables borrowing on a reserve * @param _reserve the address of the reserve **/  function disableBorrowingOnReserve(address _reserve) external onlyLendingPoolConfigurator {     reserves[_reserve].disableBorrowing(); }  /** * @dev enables a reserve to be used as collateral * @param _reserve the address of the reserve **/ function enableReserveAsCollateral(     address _reserve,     uint256 _baseLTVasCollateral,     uint256 _liquidationThreshold,     uint256 _liquidationBonus ) external onlyLendingPoolConfigurator {     reserves[_reserve].enableAsCollateral(         _baseLTVasCollateral,         _liquidationThreshold,         _liquidationBonus     ); }  /** * @dev disables a reserve to be used as collateral * @param _reserve the address of the reserve **/ function disableReserveAsCollateral(address _reserve) external onlyLendingPoolConfigurator {     reserves[_reserve].disableAsCollateral(); }  /** * @dev enable the stable borrow rate mode on a reserve * @param _reserve the address of the reserve **/ function enableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isStableBorrowRateEnabled = true; }  /** * @dev disable the stable borrow rate mode on a reserve * @param _reserve the address of the reserve **/ function disableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isStableBorrowRateEnabled = false; }  /** * @dev activates a reserve * @param _reserve the address of the reserve **/ function activateReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      require(         reserve.lastLiquidityCumulativeIndex &gt; 0 &amp;&amp;         reserve.lastVariableBorrowCumulativeIndex &gt; 0,         "Reserve has not been initialized yet"     );     reserve.isActive = true; }  /** * @dev deactivates a reserve * @param _reserve the address of the reserve **/ function deactivateReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isActive = false; }  /** * @notice allows the configurator to freeze the reserve. * A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance. * @param _reserve the address of the reserve **/ function freezeReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isFreezed = true; }  /** * @notice allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed. * @param _reserve the address of the reserve **/ function unfreezeReserve(address _reserve) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.isFreezed = false; }  /** * @notice allows the configurator to update the loan to value of a reserve * @param _reserve the address of the reserve * @param _ltv the new loan to value **/ function setReserveBaseLTVasCollateral(address _reserve, uint256 _ltv) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.baseLTVasCollateral = _ltv; }  /** * @notice allows the configurator to update the liquidation threshold of a reserve * @param _reserve the address of the reserve * @param _threshold the new liquidation threshold **/ function setReserveLiquidationThreshold(address _reserve, uint256 _threshold) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.liquidationThreshold = _threshold; }  /** * @notice allows the configurator to update the liquidation bonus of a reserve * @param _reserve the address of the reserve * @param _bonus the new liquidation bonus **/ function setReserveLiquidationBonus(address _reserve, uint256 _bonus) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.liquidationBonus = _bonus; }  /** * @notice allows the configurator to update the reserve decimals * @param _reserve the address of the reserve * @param _decimals the decimals of the reserve **/ function setReserveDecimals(address _reserve, uint256 _decimals) external onlyLendingPoolConfigurator {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     reserve.decimals = _decimals; }  /** * @notice internal functions **/  /** * @dev updates the state of a reserve as a consequence of a borrow action. * @param _reserve the address of the reserve on which the user is borrowing * @param _user the address of the borrower * @param _principalBorrowBalance the previous borrow balance of the borrower before the action * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount * @param _amountBorrowed the new amount borrowed * @param _rateMode the borrow rate mode (stable, variable) **/  function updateReserveStateOnBorrowInternal(     address _reserve,     address _user,     uint256 _principalBorrowBalance,     uint256 _balanceIncrease,     uint256 _amountBorrowed,     CoreLibrary.InterestRateMode _rateMode ) internal {     reserves[_reserve].updateCumulativeIndexes();      //increasing reserve total borrows to account for the new borrow balance of the user     //NOTE: Depending on the previous borrow mode, the borrows might need to be switched from variable to stable or vice versa      updateReserveTotalBorrowsByRateModeInternal(         _reserve,         _user,         _principalBorrowBalance,         _balanceIncrease,         _amountBorrowed,         _rateMode     ); }  /** * @dev updates the state of a user as a consequence of a borrow action. * @param _reserve the address of the reserve on which the user is borrowing * @param _user the address of the borrower * @param _amountBorrowed the amount borrowed * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount * @param _rateMode the borrow rate mode (stable, variable) * @return the final borrow rate for the user. Emitted by the borrow() event **/  function updateUserStateOnBorrowInternal(     address _reserve,     address _user,     uint256 _amountBorrowed,     uint256 _balanceIncrease,     uint256 _fee,     CoreLibrary.InterestRateMode _rateMode ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      if (_rateMode == CoreLibrary.InterestRateMode.STABLE) {         //stable         //reset the user variable index, and update the stable rate         user.stableBorrowRate = reserve.currentStableBorrowRate;         user.lastVariableBorrowCumulativeIndex = 0;     } else if (_rateMode == CoreLibrary.InterestRateMode.VARIABLE) {         //variable         //reset the user stable rate, and store the new borrow index         user.stableBorrowRate = 0;         user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;     } else {         revert("Invalid borrow rate mode");     }     //increase the principal borrows and the origination fee     user.principalBorrowBalance = user.principalBorrowBalance.add(_amountBorrowed).add(         _balanceIncrease     );     user.originationFee = user.originationFee.add(_fee);      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp);  }  /** * @dev updates the state of the reserve as a consequence of a repay action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _paybackAmountMinusFees the amount being paid back minus fees * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updateReserveStateOnRepayInternal(     address _reserve,     address _user,     uint256 _paybackAmountMinusFees,     uint256 _balanceIncrease ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_reserve][_user];      CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(_reserve, _user);      //update the indexes     reserves[_reserve].updateCumulativeIndexes();      //compound the cumulated interest to the borrow balance and then subtracting the payback amount     if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             _balanceIncrease,             user.stableBorrowRate         );         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _paybackAmountMinusFees,             user.stableBorrowRate         );     } else {         reserve.increaseTotalBorrowsVariable(_balanceIncrease);         reserve.decreaseTotalBorrowsVariable(_paybackAmountMinusFees);     } }  /** * @dev updates the state of the user as a consequence of a repay action. * @param _reserve the address of the reserve on which the user is repaying * @param _user the address of the borrower * @param _paybackAmountMinusFees the amount being paid back minus fees * @param _originationFeeRepaid the fee on the amount that is being repaid * @param _balanceIncrease the accrued interest on the borrowed amount * @param _repaidWholeLoan true if the user is repaying the whole loan **/ function updateUserStateOnRepayInternal(     address _reserve,     address _user,     uint256 _paybackAmountMinusFees,     uint256 _originationFeeRepaid,     uint256 _balanceIncrease,     bool _repaidWholeLoan ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      //update the user principal borrow balance, adding the cumulated interest and then subtracting the payback amount     user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(         _paybackAmountMinusFees     );     user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;      //if the balance decrease is equal to the previous principal (user is repaying the whole loan)     //and the rate mode is stable, we reset the interest rate mode of the user     if (_repaidWholeLoan) {         user.stableBorrowRate = 0;         user.lastVariableBorrowCumulativeIndex = 0;     }     user.originationFee = user.originationFee.sub(_originationFeeRepaid);      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp);  }  /** * @dev updates the state of the user as a consequence of a swap rate action. * @param _reserve the address of the reserve on which the user is performing the rate swap * @param _user the address of the borrower * @param _principalBorrowBalance the the principal amount borrowed by the user * @param _compoundedBorrowBalance the principal amount plus the accrued interest * @param _currentRateMode the rate mode at which the user borrowed **/ function updateReserveStateOnSwapRateInternal(     address _reserve,     address _user,     uint256 _principalBorrowBalance,     uint256 _compoundedBorrowBalance,     CoreLibrary.InterestRateMode _currentRateMode ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      //compounding reserve indexes     reserve.updateCumulativeIndexes();      if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {         uint256 userCurrentStableRate = user.stableBorrowRate;          //swap to variable         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _principalBorrowBalance,             userCurrentStableRate         ); //decreasing stable from old principal balance         reserve.increaseTotalBorrowsVariable(_compoundedBorrowBalance); //increase variable borrows     } else if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         //swap to stable         uint256 currentStableRate = reserve.currentStableBorrowRate;         reserve.decreaseTotalBorrowsVariable(_principalBorrowBalance);         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             _compoundedBorrowBalance,             currentStableRate         );      } else {         revert("Invalid rate mode received");     } }  /** * @dev updates the state of the user as a consequence of a swap rate action. * @param _reserve the address of the reserve on which the user is performing the swap * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount * @param _currentRateMode the current rate mode of the user **/  function updateUserStateOnSwapRateInternal(     address _reserve,     address _user,     uint256 _balanceIncrease,     CoreLibrary.InterestRateMode _currentRateMode ) internal returns (CoreLibrary.InterestRateMode) {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      CoreLibrary.InterestRateMode newMode = CoreLibrary.InterestRateMode.NONE;      if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         //switch to stable         newMode = CoreLibrary.InterestRateMode.STABLE;         user.stableBorrowRate = reserve.currentStableBorrowRate;         user.lastVariableBorrowCumulativeIndex = 0;     } else if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {         newMode = CoreLibrary.InterestRateMode.VARIABLE;         user.stableBorrowRate = 0;         user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;     } else {         revert("Invalid interest rate mode received");     }     //compounding cumulated interest     user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);     //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp);      return newMode; }  /** * @dev updates the state of the principal reserve as a consequence of a liquidation action. * @param _principalReserve the address of the principal reserve that is being repaid * @param _user the address of the borrower * @param _amountToLiquidate the amount being repaid by the liquidator * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updatePrincipalReserveStateOnLiquidationInternal(     address _principalReserve,     address _user,     uint256 _amountToLiquidate,     uint256 _balanceIncrease ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_principalReserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_principalReserve];      //update principal reserve data     reserve.updateCumulativeIndexes();      CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(         _principalReserve,         _user     );      if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {         //increase the total borrows by the compounded interest         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             _balanceIncrease,             user.stableBorrowRate         );          //decrease by the actual amount to liquidate         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _amountToLiquidate,             user.stableBorrowRate         );      } else {         //increase the total borrows by the compounded interest         reserve.increaseTotalBorrowsVariable(_balanceIncrease);          //decrease by the actual amount to liquidate         reserve.decreaseTotalBorrowsVariable(_amountToLiquidate);     }  }  /** * @dev updates the state of the collateral reserve as a consequence of a liquidation action. * @param _collateralReserve the address of the collateral reserve that is being liquidated **/ function updateCollateralReserveStateOnLiquidationInternal(     address _collateralReserve ) internal {     //update collateral reserve     reserves[_collateralReserve].updateCumulativeIndexes();  }  /** * @dev updates the state of the user being liquidated as a consequence of a liquidation action. * @param _reserve the address of the principal reserve that is being repaid * @param _user the address of the borrower * @param _amountToLiquidate the amount being repaid by the liquidator * @param _feeLiquidated the amount of origination fee being liquidated * @param _balanceIncrease the accrued interest on the borrowed amount **/ function updateUserStateOnLiquidationInternal(     address _reserve,     address _user,     uint256 _amountToLiquidate,     uint256 _feeLiquidated,     uint256 _balanceIncrease ) internal {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     //first increase by the compounded interest, then decrease by the liquidated amount     user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(         _amountToLiquidate     );      if (         getUserCurrentBorrowRateMode(_reserve, _user) == CoreLibrary.InterestRateMode.VARIABLE     ) {         user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;     }      if(_feeLiquidated &gt; 0){         user.originationFee = user.originationFee.sub(_feeLiquidated);     }      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp); }  /** * @dev updates the state of the reserve as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updateReserveStateOnRebalanceInternal(     address _reserve,     address _user,     uint256 _balanceIncrease ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];      reserve.updateCumulativeIndexes();      reserve.increaseTotalBorrowsStableAndUpdateAverageRate(         _balanceIncrease,         user.stableBorrowRate     );  }  /** * @dev updates the state of the user as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount **/  function updateUserStateOnRebalanceInternal(     address _reserve,     address _user,     uint256 _balanceIncrease ) internal {     CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);     user.stableBorrowRate = reserve.currentStableBorrowRate;      //solium-disable-next-line     user.lastUpdateTimestamp = uint40(block.timestamp); }  /** * @dev updates the state of the user as a consequence of a stable rate rebalance * @param _reserve the address of the principal reserve where the user borrowed * @param _user the address of the borrower * @param _balanceIncrease the accrued interest on the borrowed amount * @param _amountBorrowed the accrued interest on the borrowed amount **/ function updateReserveTotalBorrowsByRateModeInternal(     address _reserve,     address _user,     uint256 _principalBalance,     uint256 _balanceIncrease,     uint256 _amountBorrowed,     CoreLibrary.InterestRateMode _newBorrowRateMode ) internal {     CoreLibrary.InterestRateMode previousRateMode = getUserCurrentBorrowRateMode(         _reserve,         _user     );     CoreLibrary.ReserveData storage reserve = reserves[_reserve];      if (previousRateMode == CoreLibrary.InterestRateMode.STABLE) {         CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];         reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(             _principalBalance,             user.stableBorrowRate         );     } else if (previousRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         reserve.decreaseTotalBorrowsVariable(_principalBalance);     }      uint256 newPrincipalAmount = _principalBalance.add(_balanceIncrease).add(_amountBorrowed);     if (_newBorrowRateMode == CoreLibrary.InterestRateMode.STABLE) {         reserve.increaseTotalBorrowsStableAndUpdateAverageRate(             newPrincipalAmount,             reserve.currentStableBorrowRate         );     } else if (_newBorrowRateMode == CoreLibrary.InterestRateMode.VARIABLE) {         reserve.increaseTotalBorrowsVariable(newPrincipalAmount);     } else {         revert("Invalid new borrow rate mode");     } }  /** * @dev Updates the reserve current stable borrow rate Rf, the current variable borrow rate Rv and the current liquidity rate Rl. * Also updates the lastUpdateTimestamp value. Please refer to the whitepaper for further information. * @param _reserve the address of the reserve to be updated * @param _liquidityAdded the amount of liquidity added to the protocol (deposit or repay) in the previous action * @param _liquidityTaken the amount of liquidity taken from the protocol (redeem or borrow) **/  function updateReserveInterestRatesAndTimestampInternal(     address _reserve,     uint256 _liquidityAdded,     uint256 _liquidityTaken ) internal {     CoreLibrary.ReserveData storage reserve = reserves[_reserve];     (uint256 newLiquidityRate, uint256 newStableRate, uint256 newVariableRate) = IReserveInterestRateStrategy(         reserve         .interestRateStrategyAddress     )     .calculateInterestRates(         _reserve,         getReserveAvailableLiquidity(_reserve).add(_liquidityAdded).sub(_liquidityTaken),         reserve.totalBorrowsStable,         reserve.totalBorrowsVariable,         reserve.currentAverageStableBorrowRate     );      reserve.currentLiquidityRate = newLiquidityRate;     reserve.currentStableBorrowRate = newStableRate;     reserve.currentVariableBorrowRate = newVariableRate;      //solium-disable-next-line     reserve.lastUpdateTimestamp = uint40(block.timestamp);      emit ReserveUpdated(         _reserve,         newLiquidityRate,         newStableRate,         newVariableRate,         reserve.lastLiquidityCumulativeIndex,         reserve.lastVariableBorrowCumulativeIndex     ); }  /** * @dev transfers to the protocol fees of a flashloan to the fees collection address * @param _token the address of the token being transferred * @param _amount the amount being transferred **/  function transferFlashLoanProtocolFeeInternal(address _token, uint256 _amount) internal {     address payable receiver = address(uint160(addressesProvider.getTokenDistributor()));      if (_token != EthAddressLib.ethAddress()) {         ERC20(_token).safeTransfer(receiver, _amount);     } else {         receiver.transfer(_amount);     } }  /** * @dev updates the internal configuration of the core **/ function refreshConfigInternal() internal {     lendingPoolAddress = addressesProvider.getLendingPool(); }  /** * @dev adds a reserve to the array of the reserves address **/ function addReserveToListInternal(address _reserve) internal {     bool reserveAlreadyAdded = false;     for (uint256 i = 0; i &lt; reservesList.length; i++)         if (reservesList[i] == _reserve) {             reserveAlreadyAdded = true;         }     if (!reserveAlreadyAdded) reservesList.push(_reserve); }  } |
| **with_task_specify** | False |
| **memory** | None |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 04:32:16 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures
Here is a new customer's task: pragma solidity ^0.5.0;

import "openzeppelin-solidity/contracts/math/SafeMath.sol";
import "openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol";
import "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol";
import "openzeppelin-solidity/contracts/utils/Address.sol";
import "../libraries/openzeppelin-upgradeability/VersionedInitializable.sol";

import "../libraries/CoreLibrary.sol";
import "../configuration/LendingPoolAddressesProvider.sol";
import "../interfaces/ILendingRateOracle.sol";
import "../interfaces/IReserveInterestRateStrategy.sol";
import "../libraries/WadRayMath.sol";
import "../tokenization/AToken.sol";
import "../libraries/EthAddressLib.sol";

/**
* @title LendingPoolCore contract
* @author Aave
* @notice Holds the state of the lending pool and all the funds deposited
* @dev NOTE: The core does not enforce security checks on the update of the state
* (eg, updateStateOnBorrow() does not enforce that borrowed is enabled on the reserve).
* The check that an action can be performed is a duty of the overlying LendingPool contract.
**/

contract LendingPoolCore is VersionedInitializable {
    using SafeMath for uint256;
    using WadRayMath for uint256;
    using CoreLibrary for CoreLibrary.ReserveData;
    using CoreLibrary for CoreLibrary.UserReserveData;
    using SafeERC20 for ERC20;
    using Address for address payable;

    /**
    * @dev Emitted when the state of a reserve is updated
    * @param reserve the address of the reserve
    * @param liquidityRate the new liquidity rate
    * @param stableBorrowRate the new stable borrow rate
    * @param variableBorrowRate the new variable borrow rate
    * @param liquidityIndex the new liquidity index
    * @param variableBorrowIndex the new variable borrow index
    **/
    event ReserveUpdated(
        address indexed reserve,
        uint256 liquidityRate,
        uint256 stableBorrowRate,
        uint256 variableBorrowRate,
        uint256 liquidityIndex,
        uint256 variableBorrowIndex
    );

    address public lendingPoolAddress;

    LendingPoolAddressesProvider public addressesProvider;

    /**
    * @dev only lending pools can use functions affected by this modifier
    **/
    modifier onlyLendingPool {
        require(lendingPoolAddress == msg.sender, "The caller must be a lending pool contract");
        _;
    }

    /**
    * @dev only lending pools configurator can use functions affected by this modifier
    **/
    modifier onlyLendingPoolConfigurator {
        require(
            addressesProvider.getLendingPoolConfigurator() == msg.sender,
            "The caller must be a lending pool configurator contract"
        );
        _;
    }

    mapping(address => CoreLibrary.ReserveData) internal reserves;
    mapping(address => mapping(address => CoreLibrary.UserReserveData)) internal usersReserveData;

    address[] public reservesList;

    uint256 public constant CORE_REVISION = 0x4;

    /**
    * @dev returns the revision number of the contract
    **/
    function getRevision() internal pure returns (uint256) {
        return CORE_REVISION;
    }

    /**
    * @dev initializes the Core contract, invoked upon registration on the AddressesProvider
    * @param _addressesProvider the addressesProvider contract
    **/

    function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {
        addressesProvider = _addressesProvider;
        refreshConfigInternal();
    }

    /**
    * @dev updates the state of the core as a result of a deposit action
    * @param _reserve the address of the reserve in which the deposit is happening
    * @param _user the address of the the user depositing
    * @param _amount the amount being deposited
    * @param _isFirstDeposit true if the user is depositing for the first time
    **/

    function updateStateOnDeposit(
        address _reserve,
        address _user,
        uint256 _amount,
        bool _isFirstDeposit
    ) external onlyLendingPool {
        reserves[_reserve].updateCumulativeIndexes();
        updateReserveInterestRatesAndTimestampInternal(_reserve, _amount, 0);

        if (_isFirstDeposit) {
            //if this is the first deposit of the user, we configure the deposit as enabled to be used as collateral
            setUserUseReserveAsCollateral(_reserve, _user, true);
        }
    }

    /**
    * @dev updates the state of the core as a result of a redeem action
    * @param _reserve the address of the reserve in which the redeem is happening
    * @param _user the address of the the user redeeming
    * @param _amountRedeemed the amount being redeemed
    * @param _userRedeemedEverything true if the user is redeeming everything
    **/
    function updateStateOnRedeem(
        address _reserve,
        address _user,
        uint256 _amountRedeemed,
        bool _userRedeemedEverything
    ) external onlyLendingPool {
        //compound liquidity and variable borrow interests
        reserves[_reserve].updateCumulativeIndexes();
        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountRedeemed);

        //if user redeemed everything the useReserveAsCollateral flag is reset
        if (_userRedeemedEverything) {
            setUserUseReserveAsCollateral(_reserve, _user, false);
        }
    }

    /**
    * @dev updates the state of the core as a result of a flashloan action
    * @param _reserve the address of the reserve in which the flashloan is happening
    * @param _income the income of the protocol as a result of the action
    **/
    function updateStateOnFlashLoan(
        address _reserve,
        uint256 _availableLiquidityBefore,
        uint256 _income,
        uint256 _protocolFee
    ) external onlyLendingPool {
        transferFlashLoanProtocolFeeInternal(_reserve, _protocolFee);

        //compounding the cumulated interest
        reserves[_reserve].updateCumulativeIndexes();

        uint256 totalLiquidityBefore = _availableLiquidityBefore.add(
            getReserveTotalBorrows(_reserve)
        );

        //compounding the received fee into the reserve
        reserves[_reserve].cumulateToLiquidityIndex(totalLiquidityBefore, _income);

        //refresh interest rates
        updateReserveInterestRatesAndTimestampInternal(_reserve, _income, 0);
    }

    /**
    * @dev updates the state of the core as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _amountBorrowed the new amount borrowed
    * @param _borrowFee the fee on the amount borrowed
    * @param _rateMode the borrow rate mode (stable, variable)
    * @return the new borrow rate for the user
    **/
    function updateStateOnBorrow(
        address _reserve,
        address _user,
        uint256 _amountBorrowed,
        uint256 _borrowFee,
        CoreLibrary.InterestRateMode _rateMode
    ) external onlyLendingPool returns (uint256, uint256) {
        // getting the previous borrow data of the user
        (uint256 principalBorrowBalance, , uint256 balanceIncrease) = getUserBorrowBalances(
            _reserve,
            _user
        );

        updateReserveStateOnBorrowInternal(
            _reserve,
            _user,
            principalBorrowBalance,
            balanceIncrease,
            _amountBorrowed,
            _rateMode
        );

        updateUserStateOnBorrowInternal(
            _reserve,
            _user,
            _amountBorrowed,
            balanceIncrease,
            _borrowFee,
            _rateMode
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountBorrowed);

        return (getUserCurrentBorrowRate(_reserve, _user), balanceIncrease);
    }

    /**
    * @dev updates the state of the core as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _originationFeeRepaid the fee on the amount that is being repaid
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _repaidWholeLoan true if the user is repaying the whole loan
    **/

    function updateStateOnRepay(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _originationFeeRepaid,
        uint256 _balanceIncrease,
        bool _repaidWholeLoan
    ) external onlyLendingPool {
        updateReserveStateOnRepayInternal(
            _reserve,
            _user,
            _paybackAmountMinusFees,
            _balanceIncrease
        );
        updateUserStateOnRepayInternal(
            _reserve,
            _user,
            _paybackAmountMinusFees,
            _originationFeeRepaid,
            _balanceIncrease,
            _repaidWholeLoan
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, _paybackAmountMinusFees, 0);
    }

    /**
    * @dev updates the state of the core as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the amount borrowed by the user
    * @param _compoundedBorrowBalance the amount borrowed plus accrued interest
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _currentRateMode the current interest rate mode for the user
    **/
    function updateStateOnSwapRate(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _compoundedBorrowBalance,
        uint256 _balanceIncrease,
        CoreLibrary.InterestRateMode _currentRateMode
    ) external onlyLendingPool returns (CoreLibrary.InterestRateMode, uint256) {
        updateReserveStateOnSwapRateInternal(
            _reserve,
            _user,
            _principalBorrowBalance,
            _compoundedBorrowBalance,
            _currentRateMode
        );

        CoreLibrary.InterestRateMode newRateMode = updateUserStateOnSwapRateInternal(
            _reserve,
            _user,
            _balanceIncrease,
            _currentRateMode
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);

        return (newRateMode, getUserCurrentBorrowRate(_reserve, _user));
    }

    /**
    * @dev updates the state of the core as a consequence of a liquidation action.
    * @param _principalReserve the address of the principal reserve that is being repaid
    * @param _collateralReserve the address of the collateral reserve that is being liquidated
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _collateralToLiquidate the amount of collateral being liquidated
    * @param _feeLiquidated the amount of origination fee being liquidated
    * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise
    **/
    function updateStateOnLiquidation(
        address _principalReserve,
        address _collateralReserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _collateralToLiquidate,
        uint256 _feeLiquidated,
        uint256 _liquidatedCollateralForFee,
        uint256 _balanceIncrease,
        bool _liquidatorReceivesAToken
    ) external onlyLendingPool {
        updatePrincipalReserveStateOnLiquidationInternal(
            _principalReserve,
            _user,
            _amountToLiquidate,
            _balanceIncrease
        );

        updateCollateralReserveStateOnLiquidationInternal(
            _collateralReserve
        );

        updateUserStateOnLiquidationInternal(
            _principalReserve,
            _user,
            _amountToLiquidate,
            _feeLiquidated,
            _balanceIncrease
        );

        updateReserveInterestRatesAndTimestampInternal(_principalReserve, _amountToLiquidate, 0);

        if (!_liquidatorReceivesAToken) {
            updateReserveInterestRatesAndTimestampInternal(
                _collateralReserve,
                0,
                _collateralToLiquidate.add(_liquidatedCollateralForFee)
            );
        }

    }

    /**
    * @dev updates the state of the core as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @return the new stable rate for the user
    **/
    function updateStateOnRebalance(address _reserve, address _user, uint256 _balanceIncrease)
    external
    onlyLendingPool
    returns (uint256)
    {
        updateReserveStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);

        //update user data and rebalance the rate
        updateUserStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);
        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);
        return usersReserveData[_user][_reserve].stableBorrowRate;
    }

    /**
    * @dev enables or disables a reserve as collateral
    * @param _reserve the address of the principal reserve where the user deposited
    * @param _user the address of the depositor
    * @param _useAsCollateral true if the depositor wants to use the reserve as collateral
    **/
    function setUserUseReserveAsCollateral(address _reserve, address _user, bool _useAsCollateral)
    public
    onlyLendingPool
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        user.useAsCollateral = _useAsCollateral;
    }

    /**
    * @notice ETH/token transfer functions
    **/

    /**
    * @dev fallback function enforces that the caller is a contract, to support flashloan transfers
    **/
    function() external payable {
        //only contracts can send ETH to the core
        require(msg.sender.isContract(), "Only contracts can send ether to the Lending pool core");

    }

    /**
    * @dev transfers to the user a specific amount from the reserve.
    * @param _reserve the address of the reserve where the transfer is happening
    * @param _user the address of the user receiving the transfer
    * @param _amount the amount being transferred
    **/
    function transferToUser(address _reserve, address payable _user, uint256 _amount)
    external
    onlyLendingPool
    {
        if (_reserve != EthAddressLib.ethAddress()) {
            ERC20(_reserve).safeTransfer(_user, _amount);
        } else {
            //solium-disable-next-line
            (bool result, ) = _user.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers the protocol fees to the fees collection address
    * @param _token the address of the token being transferred
    * @param _user the address of the user from where the transfer is happening
    * @param _amount the amount being transferred
    * @param _destination the fee receiver address
    **/

    function transferToFeeCollectionAddress(
        address _token,
        address _user,
        uint256 _amount,
        address _destination
    ) external payable onlyLendingPool {
        address payable feeAddress = address(uint160(_destination)); //cast the address to payable

        if (_token != EthAddressLib.ethAddress()) {
            require(
                msg.value == 0,
                "User is sending ETH along with the ERC20 transfer. Check the value attribute of the transaction"
            );
            ERC20(_token).safeTransferFrom(_user, feeAddress, _amount);
        } else {
            require(msg.value >= _amount, "The amount and the value sent to deposit do not match");
            //solium-disable-next-line
            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers the fees to the fees collection address in the case of liquidation
    * @param _token the address of the token being transferred
    * @param _amount the amount being transferred
    * @param _destination the fee receiver address
    **/
    function liquidateFee(
        address _token,
        uint256 _amount,
        address _destination
    ) external payable onlyLendingPool {
        address payable feeAddress = address(uint160(_destination)); //cast the address to payable
        require(
            msg.value == 0,
            "Fee liquidation does not require any transfer of value"
        );

        if (_token != EthAddressLib.ethAddress()) {
            ERC20(_token).safeTransfer(feeAddress, _amount);
        } else {
            //solium-disable-next-line
            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers an amount from a user to the destination reserve
    * @param _reserve the address of the reserve where the amount is being transferred
    * @param _user the address of the user from where the transfer is happening
    * @param _amount the amount being transferred
    **/
    function transferToReserve(address _reserve, address payable _user, uint256 _amount)
    external
    payable
    onlyLendingPool
    {
        if (_reserve != EthAddressLib.ethAddress()) {
            require(msg.value == 0, "User is sending ETH along with the ERC20 transfer.");
            ERC20(_reserve).safeTransferFrom(_user, address(this), _amount);

        } else {
            require(msg.value >= _amount, "The amount and the value sent to deposit do not match");

            if (msg.value > _amount) {
                //send back excess ETH
                uint256 excessAmount = msg.value.sub(_amount);
                //solium-disable-next-line
                (bool result, ) = _user.call.value(excessAmount).gas(50000)("");
                require(result, "Transfer of ETH failed");
            }
        }
    }

    /**
    * @notice data access functions
    **/

    /**
    * @dev returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral)
    * needed to calculate the global account data in the LendingPoolDataProvider
    * @param _reserve the address of the reserve
    * @param _user the address of the user
    * @return the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not
    **/
    function getUserBasicReserveData(address _reserve, address _user)
    external
    view
    returns (uint256, uint256, uint256, bool)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        uint256 underlyingBalance = getUserUnderlyingAssetBalance(_reserve, _user);

        if (user.principalBorrowBalance == 0) {
            return (underlyingBalance, 0, 0, user.useAsCollateral);
        }

        return (
        underlyingBalance,
        user.getCompoundedBorrowBalance(reserve),
        user.originationFee,
        user.useAsCollateral
        );
    }

    /**
    * @dev checks if a user is allowed to borrow at a stable rate
    * @param _reserve the reserve address
    * @param _user the user
    * @param _amount the amount the the user wants to borrow
    * @return true if the user is allowed to borrow at a stable rate, false otherwise
    **/

    function isUserAllowedToBorrowAtStable(address _reserve, address _user, uint256 _amount)
    external
    view
    returns (bool)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (!reserve.isStableBorrowRateEnabled) return false;

        return
        !user.useAsCollateral ||
        !reserve.usageAsCollateralEnabled ||
        _amount > getUserUnderlyingAssetBalance(_reserve, _user);
    }

    /**
    * @dev gets the underlying asset balance of a user based on the corresponding aToken balance.
    * @param _reserve the reserve address
    * @param _user the user address
    * @return the underlying deposit balance of the user
    **/

    function getUserUnderlyingAssetBalance(address _reserve, address _user)
    public
    view
    returns (uint256)
    {
        AToken aToken = AToken(reserves[_reserve].aTokenAddress);
        return aToken.balanceOf(_user);

    }

    /**
    * @dev gets the interest rate strategy contract address for the reserve
    * @param _reserve the reserve address
    * @return the address of the interest rate strategy contract
    **/
    function getReserveInterestRateStrategyAddress(address _reserve) public view returns (address) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.interestRateStrategyAddress;
    }

    /**
    * @dev gets the aToken contract address for the reserve
    * @param _reserve the reserve address
    * @return the address of the aToken contract
    **/

    function getReserveATokenAddress(address _reserve) public view returns (address) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.aTokenAddress;
    }

    /**
    * @dev gets the available liquidity in the reserve. The available liquidity is the balance of the core contract
    * @param _reserve the reserve address
    * @return the available liquidity
    **/
    function getReserveAvailableLiquidity(address _reserve) public view returns (uint256) {
        uint256 balance = 0;

        if (_reserve == EthAddressLib.ethAddress()) {
            balance = address(this).balance;
        } else {
            balance = IERC20(_reserve).balanceOf(address(this));
        }
        return balance;
    }

    /**
    * @dev gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows
    * @param _reserve the reserve address
    * @return the total liquidity
    **/
    function getReserveTotalLiquidity(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return getReserveAvailableLiquidity(_reserve).add(reserve.getTotalBorrows());
    }

    /**
    * @dev gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there
    * there has been 100% income.
    * @param _reserve the reserve address
    * @return the reserve normalized income
    **/
    function getReserveNormalizedIncome(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.getNormalizedIncome();
    }

    /**
    * @dev gets the reserve total borrows
    * @param _reserve the reserve address
    * @return the total borrows (stable + variable)
    **/
    function getReserveTotalBorrows(address _reserve) public view returns (uint256) {
        return reserves[_reserve].getTotalBorrows();
    }

    /**
    * @dev gets the reserve total borrows stable
    * @param _reserve the reserve address
    * @return the total borrows stable
    **/
    function getReserveTotalBorrowsStable(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.totalBorrowsStable;
    }

    /**
    * @dev gets the reserve total borrows variable
    * @param _reserve the reserve address
    * @return the total borrows variable
    **/

    function getReserveTotalBorrowsVariable(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.totalBorrowsVariable;
    }

    /**
    * @dev gets the reserve liquidation threshold
    * @param _reserve the reserve address
    * @return the reserve liquidation threshold
    **/

    function getReserveLiquidationThreshold(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.liquidationThreshold;
    }

    /**
    * @dev gets the reserve liquidation bonus
    * @param _reserve the reserve address
    * @return the reserve liquidation bonus
    **/

    function getReserveLiquidationBonus(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.liquidationBonus;
    }

    /**
    * @dev gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty
    * @param _reserve the reserve address
    * @return the reserve current variable borrow rate
    **/

    function getReserveCurrentVariableBorrowRate(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        if (reserve.currentVariableBorrowRate == 0) {
            return
            IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)
            .getBaseVariableBorrowRate();
        }
        return reserve.currentVariableBorrowRate;
    }

    /**
    * @dev gets the reserve current stable borrow rate. Is the market rate if the reserve is empty
    * @param _reserve the reserve address
    * @return the reserve current stable borrow rate
    **/

    function getReserveCurrentStableBorrowRate(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        ILendingRateOracle oracle = ILendingRateOracle(addressesProvider.getLendingRateOracle());

        if (reserve.currentStableBorrowRate == 0) {
            //no stable rate borrows yet
            return oracle.getMarketBorrowRate(_reserve);
        }

        return reserve.currentStableBorrowRate;
    }

    /**
    * @dev gets the reserve average stable borrow rate. The average stable rate is the weighted average
    * of all the loans taken at stable rate.
    * @param _reserve the reserve address
    * @return the reserve current average borrow rate
    **/
    function getReserveCurrentAverageStableBorrowRate(address _reserve)
    external
    view
    returns (uint256)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.currentAverageStableBorrowRate;
    }

    /**
    * @dev gets the reserve liquidity rate
    * @param _reserve the reserve address
    * @return the reserve liquidity rate
    **/
    function getReserveCurrentLiquidityRate(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.currentLiquidityRate;
    }

    /**
    * @dev gets the reserve liquidity cumulative index
    * @param _reserve the reserve address
    * @return the reserve liquidity cumulative index
    **/
    function getReserveLiquidityCumulativeIndex(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.lastLiquidityCumulativeIndex;
    }

    /**
    * @dev gets the reserve variable borrow index
    * @param _reserve the reserve address
    * @return the reserve variable borrow index
    **/
    function getReserveVariableBorrowsCumulativeIndex(address _reserve)
    external
    view
    returns (uint256)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.lastVariableBorrowCumulativeIndex;
    }

    /**
    * @dev this function aggregates the configuration parameters of the reserve.
    * It's used in the LendingPoolDataProvider specifically to save gas, and avoid
    * multiple external contract calls to fetch the same data.
    * @param _reserve the reserve address
    * @return the reserve decimals
    * @return the base ltv as collateral
    * @return the liquidation threshold
    * @return if the reserve is used as collateral or not
    **/
    function getReserveConfiguration(address _reserve)
    external
    view
    returns (uint256, uint256, uint256, bool)
    {
        uint256 decimals;
        uint256 baseLTVasCollateral;
        uint256 liquidationThreshold;
        bool usageAsCollateralEnabled;

        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        decimals = reserve.decimals;
        baseLTVasCollateral = reserve.baseLTVasCollateral;
        liquidationThreshold = reserve.liquidationThreshold;
        usageAsCollateralEnabled = reserve.usageAsCollateralEnabled;

        return (decimals, baseLTVasCollateral, liquidationThreshold, usageAsCollateralEnabled);
    }

    /**
    * @dev returns the decimals of the reserve
    * @param _reserve the reserve address
    * @return the reserve decimals
    **/
    function getReserveDecimals(address _reserve) external view returns (uint256) {
        return reserves[_reserve].decimals;
    }

    /**
    * @dev returns true if the reserve is enabled for borrowing
    * @param _reserve the reserve address
    * @return true if the reserve is enabled for borrowing, false otherwise
    **/

    function isReserveBorrowingEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.borrowingEnabled;
    }

    /**
    * @dev returns true if the reserve is enabled as collateral
    * @param _reserve the reserve address
    * @return true if the reserve is enabled as collateral, false otherwise
    **/

    function isReserveUsageAsCollateralEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.usageAsCollateralEnabled;
    }

    /**
    * @dev returns true if the stable rate is enabled on reserve
    * @param _reserve the reserve address
    * @return true if the stable rate is enabled on reserve, false otherwise
    **/
    function getReserveIsStableBorrowRateEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isStableBorrowRateEnabled;
    }

    /**
    * @dev returns true if the reserve is active
    * @param _reserve the reserve address
    * @return true if the reserve is active, false otherwise
    **/
    function getReserveIsActive(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isActive;
    }

    /**
    * @notice returns if a reserve is freezed
    * @param _reserve the reserve for which the information is needed
    * @return true if the reserve is freezed, false otherwise
    **/

    function getReserveIsFreezed(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isFreezed;
    }

    /**
    * @notice returns the timestamp of the last action on the reserve
    * @param _reserve the reserve for which the information is needed
    * @return the last updated timestamp of the reserve
    **/

    function getReserveLastUpdate(address _reserve) external view returns (uint40 timestamp) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        timestamp = reserve.lastUpdateTimestamp;
    }

    /**
    * @dev returns the utilization rate U of a specific reserve
    * @param _reserve the reserve for which the information is needed
    * @return the utilization rate in ray
    **/

    function getReserveUtilizationRate(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        uint256 totalBorrows = reserve.getTotalBorrows();

        if (totalBorrows == 0) {
            return 0;
        }

        uint256 availableLiquidity = getReserveAvailableLiquidity(_reserve);

        return totalBorrows.rayDiv(availableLiquidity.add(totalBorrows));
    }

    /**
    * @return the array of reserves configured on the core
    **/
    function getReserves() external view returns (address[] memory) {
        return reservesList;
    }

    /**
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return true if the user has chosen to use the reserve as collateral, false otherwise
    **/
    function isUserUseReserveAsCollateralEnabled(address _reserve, address _user)
    external
    view
    returns (bool)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.useAsCollateral;
    }

    /**
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the origination fee for the user
    **/
    function getUserOriginationFee(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.originationFee;
    }

    /**
    * @dev users with no loans in progress have NONE as borrow rate mode
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the borrow rate mode for the user,
    **/

    function getUserCurrentBorrowRateMode(address _reserve, address _user)
    public
    view
    returns (CoreLibrary.InterestRateMode)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (user.principalBorrowBalance == 0) {
            return CoreLibrary.InterestRateMode.NONE;
        }

        return
        user.stableBorrowRate > 0
        ? CoreLibrary.InterestRateMode.STABLE
        : CoreLibrary.InterestRateMode.VARIABLE;
    }

    /**
    * @dev gets the current borrow rate of the user
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the borrow rate for the user,
    **/
    function getUserCurrentBorrowRate(address _reserve, address _user)
    internal
    view
    returns (uint256)
    {
        CoreLibrary.InterestRateMode rateMode = getUserCurrentBorrowRateMode(_reserve, _user);

        if (rateMode == CoreLibrary.InterestRateMode.NONE) {
            return 0;
        }

        return
        rateMode == CoreLibrary.InterestRateMode.STABLE
        ? usersReserveData[_user][_reserve].stableBorrowRate
        : reserves[_reserve].currentVariableBorrowRate;
    }

    /**
    * @dev the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the user stable rate
    **/
    function getUserCurrentStableBorrowRate(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.stableBorrowRate;
    }

    /**
    * @dev calculates and returns the borrow balances of the user
    * @param _reserve the address of the reserve
    * @param _user the address of the user
    * @return the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance
    **/

    function getUserBorrowBalances(address _reserve, address _user)
    public
    view
    returns (uint256, uint256, uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        if (user.principalBorrowBalance == 0) {
            return (0, 0, 0);
        }

        uint256 principal = user.principalBorrowBalance;
        uint256 compoundedBalance = CoreLibrary.getCompoundedBorrowBalance(
            user,
            reserves[_reserve]
        );
        return (principal, compoundedBalance, compoundedBalance.sub(principal));
    }

    /**
    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the variable borrow index for the user
    **/

    function getUserVariableBorrowCumulativeIndex(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.lastVariableBorrowCumulativeIndex;
    }

    /**
    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the variable borrow index for the user
    **/

    function getUserLastUpdate(address _reserve, address _user)
    external
    view
    returns (uint256 timestamp)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        timestamp = user.lastUpdateTimestamp;
    }

    /**
    * @dev updates the lending pool core configuration
    **/
    function refreshConfiguration() external onlyLendingPoolConfigurator {
        refreshConfigInternal();
    }

    /**
    * @dev initializes a reserve
    * @param _reserve the address of the reserve
    * @param _aTokenAddress the address of the overlying aToken contract
    * @param _decimals the decimals of the reserve currency
    * @param _interestRateStrategyAddress the address of the interest rate strategy contract
    **/
    function initReserve(
        address _reserve,
        address _aTokenAddress,
        uint256 _decimals,
        address _interestRateStrategyAddress
    ) external onlyLendingPoolConfigurator {
        reserves[_reserve].init(_aTokenAddress, _decimals, _interestRateStrategyAddress);
        addReserveToListInternal(_reserve);

    }



    /**
    * @dev removes the last added reserve in the reservesList array
    * @param _reserveToRemove the address of the reserve
    **/
    function removeLastAddedReserve(address _reserveToRemove)
    external onlyLendingPoolConfigurator {

        address lastReserve = reservesList[reservesList.length-1];

        require(lastReserve == _reserveToRemove, "Reserve being removed is different than the reserve requested");

        //as we can't check if totalLiquidity is 0 (since the reserve added might not be an ERC20) we at least check that there is nothing borrowed
        require(getReserveTotalBorrows(lastReserve) == 0, "Cannot remove a reserve with liquidity deposited");

        reserves[lastReserve].isActive = false;
        reserves[lastReserve].aTokenAddress = address(0);
        reserves[lastReserve].decimals = 0;
        reserves[lastReserve].lastLiquidityCumulativeIndex = 0;
        reserves[lastReserve].lastVariableBorrowCumulativeIndex = 0;
        reserves[lastReserve].borrowingEnabled = false;
        reserves[lastReserve].usageAsCollateralEnabled = false;
        reserves[lastReserve].baseLTVasCollateral = 0;
        reserves[lastReserve].liquidationThreshold = 0;
        reserves[lastReserve].liquidationBonus = 0;
        reserves[lastReserve].interestRateStrategyAddress = address(0);

        reservesList.pop();
    }

    /**
    * @dev updates the address of the interest rate strategy contract
    * @param _reserve the address of the reserve
    * @param _rateStrategyAddress the address of the interest rate strategy contract
    **/

    function setReserveInterestRateStrategyAddress(address _reserve, address _rateStrategyAddress)
    external
    onlyLendingPoolConfigurator
    {
        reserves[_reserve].interestRateStrategyAddress = _rateStrategyAddress;
    }

    /**
    * @dev enables borrowing on a reserve. Also sets the stable rate borrowing
    * @param _reserve the address of the reserve
    * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise
    **/

    function enableBorrowingOnReserve(address _reserve, bool _stableBorrowRateEnabled)
    external
    onlyLendingPoolConfigurator
    {
        reserves[_reserve].enableBorrowing(_stableBorrowRateEnabled);
    }

    /**
    * @dev disables borrowing on a reserve
    * @param _reserve the address of the reserve
    **/

    function disableBorrowingOnReserve(address _reserve) external onlyLendingPoolConfigurator {
        reserves[_reserve].disableBorrowing();
    }

    /**
    * @dev enables a reserve to be used as collateral
    * @param _reserve the address of the reserve
    **/
    function enableReserveAsCollateral(
        address _reserve,
        uint256 _baseLTVasCollateral,
        uint256 _liquidationThreshold,
        uint256 _liquidationBonus
    ) external onlyLendingPoolConfigurator {
        reserves[_reserve].enableAsCollateral(
            _baseLTVasCollateral,
            _liquidationThreshold,
            _liquidationBonus
        );
    }

    /**
    * @dev disables a reserve to be used as collateral
    * @param _reserve the address of the reserve
    **/
    function disableReserveAsCollateral(address _reserve) external onlyLendingPoolConfigurator {
        reserves[_reserve].disableAsCollateral();
    }

    /**
    * @dev enable the stable borrow rate mode on a reserve
    * @param _reserve the address of the reserve
    **/
    function enableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isStableBorrowRateEnabled = true;
    }

    /**
    * @dev disable the stable borrow rate mode on a reserve
    * @param _reserve the address of the reserve
    **/
    function disableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isStableBorrowRateEnabled = false;
    }

    /**
    * @dev activates a reserve
    * @param _reserve the address of the reserve
    **/
    function activateReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        require(
            reserve.lastLiquidityCumulativeIndex > 0 &&
            reserve.lastVariableBorrowCumulativeIndex > 0,
            "Reserve has not been initialized yet"
        );
        reserve.isActive = true;
    }

    /**
    * @dev deactivates a reserve
    * @param _reserve the address of the reserve
    **/
    function deactivateReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isActive = false;
    }

    /**
    * @notice allows the configurator to freeze the reserve.
    * A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance.
    * @param _reserve the address of the reserve
    **/
    function freezeReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isFreezed = true;
    }

    /**
    * @notice allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed.
    * @param _reserve the address of the reserve
    **/
    function unfreezeReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isFreezed = false;
    }

    /**
    * @notice allows the configurator to update the loan to value of a reserve
    * @param _reserve the address of the reserve
    * @param _ltv the new loan to value
    **/
    function setReserveBaseLTVasCollateral(address _reserve, uint256 _ltv)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.baseLTVasCollateral = _ltv;
    }

    /**
    * @notice allows the configurator to update the liquidation threshold of a reserve
    * @param _reserve the address of the reserve
    * @param _threshold the new liquidation threshold
    **/
    function setReserveLiquidationThreshold(address _reserve, uint256 _threshold)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.liquidationThreshold = _threshold;
    }

    /**
    * @notice allows the configurator to update the liquidation bonus of a reserve
    * @param _reserve the address of the reserve
    * @param _bonus the new liquidation bonus
    **/
    function setReserveLiquidationBonus(address _reserve, uint256 _bonus)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.liquidationBonus = _bonus;
    }

    /**
    * @notice allows the configurator to update the reserve decimals
    * @param _reserve the address of the reserve
    * @param _decimals the decimals of the reserve
    **/
    function setReserveDecimals(address _reserve, uint256 _decimals)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.decimals = _decimals;
    }

    /**
    * @notice internal functions
    **/

    /**
    * @dev updates the state of a reserve as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the previous borrow balance of the borrower before the action
    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount
    * @param _amountBorrowed the new amount borrowed
    * @param _rateMode the borrow rate mode (stable, variable)
    **/

    function updateReserveStateOnBorrowInternal(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _balanceIncrease,
        uint256 _amountBorrowed,
        CoreLibrary.InterestRateMode _rateMode
    ) internal {
        reserves[_reserve].updateCumulativeIndexes();

        //increasing reserve total borrows to account for the new borrow balance of the user
        //NOTE: Depending on the previous borrow mode, the borrows might need to be switched from variable to stable or vice versa

        updateReserveTotalBorrowsByRateModeInternal(
            _reserve,
            _user,
            _principalBorrowBalance,
            _balanceIncrease,
            _amountBorrowed,
            _rateMode
        );
    }

    /**
    * @dev updates the state of a user as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _amountBorrowed the amount borrowed
    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount
    * @param _rateMode the borrow rate mode (stable, variable)
    * @return the final borrow rate for the user. Emitted by the borrow() event
    **/

    function updateUserStateOnBorrowInternal(
        address _reserve,
        address _user,
        uint256 _amountBorrowed,
        uint256 _balanceIncrease,
        uint256 _fee,
        CoreLibrary.InterestRateMode _rateMode
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (_rateMode == CoreLibrary.InterestRateMode.STABLE) {
            //stable
            //reset the user variable index, and update the stable rate
            user.stableBorrowRate = reserve.currentStableBorrowRate;
            user.lastVariableBorrowCumulativeIndex = 0;
        } else if (_rateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //variable
            //reset the user stable rate, and store the new borrow index
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        } else {
            revert("Invalid borrow rate mode");
        }
        //increase the principal borrows and the origination fee
        user.principalBorrowBalance = user.principalBorrowBalance.add(_amountBorrowed).add(
            _balanceIncrease
        );
        user.originationFee = user.originationFee.add(_fee);

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

    }

    /**
    * @dev updates the state of the reserve as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateReserveStateOnRepayInternal(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_reserve][_user];

        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(_reserve, _user);

        //update the indexes
        reserves[_reserve].updateCumulativeIndexes();

        //compound the cumulated interest to the borrow balance and then subtracting the payback amount
        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _balanceIncrease,
                user.stableBorrowRate
            );
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _paybackAmountMinusFees,
                user.stableBorrowRate
            );
        } else {
            reserve.increaseTotalBorrowsVariable(_balanceIncrease);
            reserve.decreaseTotalBorrowsVariable(_paybackAmountMinusFees);
        }
    }

    /**
    * @dev updates the state of the user as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _originationFeeRepaid the fee on the amount that is being repaid
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _repaidWholeLoan true if the user is repaying the whole loan
    **/
    function updateUserStateOnRepayInternal(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _originationFeeRepaid,
        uint256 _balanceIncrease,
        bool _repaidWholeLoan
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        //update the user principal borrow balance, adding the cumulated interest and then subtracting the payback amount
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(
            _paybackAmountMinusFees
        );
        user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;

        //if the balance decrease is equal to the previous principal (user is repaying the whole loan)
        //and the rate mode is stable, we reset the interest rate mode of the user
        if (_repaidWholeLoan) {
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = 0;
        }
        user.originationFee = user.originationFee.sub(_originationFeeRepaid);

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

    }

    /**
    * @dev updates the state of the user as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is performing the rate swap
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the the principal amount borrowed by the user
    * @param _compoundedBorrowBalance the principal amount plus the accrued interest
    * @param _currentRateMode the rate mode at which the user borrowed
    **/
    function updateReserveStateOnSwapRateInternal(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _compoundedBorrowBalance,
        CoreLibrary.InterestRateMode _currentRateMode
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        //compounding reserve indexes
        reserve.updateCumulativeIndexes();

        if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {
            uint256 userCurrentStableRate = user.stableBorrowRate;

            //swap to variable
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _principalBorrowBalance,
                userCurrentStableRate
            ); //decreasing stable from old principal balance
            reserve.increaseTotalBorrowsVariable(_compoundedBorrowBalance); //increase variable borrows
        } else if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //swap to stable
            uint256 currentStableRate = reserve.currentStableBorrowRate;
            reserve.decreaseTotalBorrowsVariable(_principalBorrowBalance);
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _compoundedBorrowBalance,
                currentStableRate
            );

        } else {
            revert("Invalid rate mode received");
        }
    }

    /**
    * @dev updates the state of the user as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is performing the swap
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _currentRateMode the current rate mode of the user
    **/

    function updateUserStateOnSwapRateInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease,
        CoreLibrary.InterestRateMode _currentRateMode
    ) internal returns (CoreLibrary.InterestRateMode) {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        CoreLibrary.InterestRateMode newMode = CoreLibrary.InterestRateMode.NONE;

        if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //switch to stable
            newMode = CoreLibrary.InterestRateMode.STABLE;
            user.stableBorrowRate = reserve.currentStableBorrowRate;
            user.lastVariableBorrowCumulativeIndex = 0;
        } else if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {
            newMode = CoreLibrary.InterestRateMode.VARIABLE;
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        } else {
            revert("Invalid interest rate mode received");
        }
        //compounding cumulated interest
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);
        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

        return newMode;
    }

    /**
    * @dev updates the state of the principal reserve as a consequence of a liquidation action.
    * @param _principalReserve the address of the principal reserve that is being repaid
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updatePrincipalReserveStateOnLiquidationInternal(
        address _principalReserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_principalReserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_principalReserve];

        //update principal reserve data
        reserve.updateCumulativeIndexes();

        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(
            _principalReserve,
            _user
        );

        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            //increase the total borrows by the compounded interest
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _balanceIncrease,
                user.stableBorrowRate
            );

            //decrease by the actual amount to liquidate
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _amountToLiquidate,
                user.stableBorrowRate
            );

        } else {
            //increase the total borrows by the compounded interest
            reserve.increaseTotalBorrowsVariable(_balanceIncrease);

            //decrease by the actual amount to liquidate
            reserve.decreaseTotalBorrowsVariable(_amountToLiquidate);
        }

    }

    /**
    * @dev updates the state of the collateral reserve as a consequence of a liquidation action.
    * @param _collateralReserve the address of the collateral reserve that is being liquidated
    **/
    function updateCollateralReserveStateOnLiquidationInternal(
        address _collateralReserve
    ) internal {
        //update collateral reserve
        reserves[_collateralReserve].updateCumulativeIndexes();

    }

    /**
    * @dev updates the state of the user being liquidated as a consequence of a liquidation action.
    * @param _reserve the address of the principal reserve that is being repaid
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _feeLiquidated the amount of origination fee being liquidated
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/
    function updateUserStateOnLiquidationInternal(
        address _reserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _feeLiquidated,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        //first increase by the compounded interest, then decrease by the liquidated amount
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(
            _amountToLiquidate
        );

        if (
            getUserCurrentBorrowRateMode(_reserve, _user) == CoreLibrary.InterestRateMode.VARIABLE
        ) {
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        }

        if(_feeLiquidated > 0){
            user.originationFee = user.originationFee.sub(_feeLiquidated);
        }

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);
    }

    /**
    * @dev updates the state of the reserve as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateReserveStateOnRebalanceInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        reserve.updateCumulativeIndexes();

        reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
            _balanceIncrease,
            user.stableBorrowRate
        );

    }

    /**
    * @dev updates the state of the user as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateUserStateOnRebalanceInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);
        user.stableBorrowRate = reserve.currentStableBorrowRate;

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);
    }

    /**
    * @dev updates the state of the user as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _amountBorrowed the accrued interest on the borrowed amount
    **/
    function updateReserveTotalBorrowsByRateModeInternal(
        address _reserve,
        address _user,
        uint256 _principalBalance,
        uint256 _balanceIncrease,
        uint256 _amountBorrowed,
        CoreLibrary.InterestRateMode _newBorrowRateMode
    ) internal {
        CoreLibrary.InterestRateMode previousRateMode = getUserCurrentBorrowRateMode(
            _reserve,
            _user
        );
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        if (previousRateMode == CoreLibrary.InterestRateMode.STABLE) {
            CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _principalBalance,
                user.stableBorrowRate
            );
        } else if (previousRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            reserve.decreaseTotalBorrowsVariable(_principalBalance);
        }

        uint256 newPrincipalAmount = _principalBalance.add(_balanceIncrease).add(_amountBorrowed);
        if (_newBorrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                newPrincipalAmount,
                reserve.currentStableBorrowRate
            );
        } else if (_newBorrowRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            reserve.increaseTotalBorrowsVariable(newPrincipalAmount);
        } else {
            revert("Invalid new borrow rate mode");
        }
    }

    /**
    * @dev Updates the reserve current stable borrow rate Rf, the current variable borrow rate Rv and the current liquidity rate Rl.
    * Also updates the lastUpdateTimestamp value. Please refer to the whitepaper for further information.
    * @param _reserve the address of the reserve to be updated
    * @param _liquidityAdded the amount of liquidity added to the protocol (deposit or repay) in the previous action
    * @param _liquidityTaken the amount of liquidity taken from the protocol (redeem or borrow)
    **/

    function updateReserveInterestRatesAndTimestampInternal(
        address _reserve,
        uint256 _liquidityAdded,
        uint256 _liquidityTaken
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        (uint256 newLiquidityRate, uint256 newStableRate, uint256 newVariableRate) = IReserveInterestRateStrategy(
            reserve
            .interestRateStrategyAddress
        )
        .calculateInterestRates(
            _reserve,
            getReserveAvailableLiquidity(_reserve).add(_liquidityAdded).sub(_liquidityTaken),
            reserve.totalBorrowsStable,
            reserve.totalBorrowsVariable,
            reserve.currentAverageStableBorrowRate
        );

        reserve.currentLiquidityRate = newLiquidityRate;
        reserve.currentStableBorrowRate = newStableRate;
        reserve.currentVariableBorrowRate = newVariableRate;

        //solium-disable-next-line
        reserve.lastUpdateTimestamp = uint40(block.timestamp);

        emit ReserveUpdated(
            _reserve,
            newLiquidityRate,
            newStableRate,
            newVariableRate,
            reserve.lastLiquidityCumulativeIndex,
            reserve.lastVariableBorrowCumulativeIndex
        );
    }

    /**
    * @dev transfers to the protocol fees of a flashloan to the fees collection address
    * @param _token the address of the token being transferred
    * @param _amount the amount being transferred
    **/

    function transferFlashLoanProtocolFeeInternal(address _token, uint256 _amount) internal {
        address payable receiver = address(uint160(addressesProvider.getTokenDistributor()));

        if (_token != EthAddressLib.ethAddress()) {
            ERC20(_token).safeTransfer(receiver, _amount);
        } else {
            receiver.transfer(_amount);
        }
    }

    /**
    * @dev updates the internal configuration of the core
    **/
    function refreshConfigInternal() internal {
        lendingPoolAddress = addressesProvider.getLendingPool();
    }

    /**
    * @dev adds a reserve to the array of the reserves address
    **/
    function addReserveToListInternal(address _reserve) internal {
        bool reserveAlreadyAdded = false;
        for (uint256 i = 0; i < reservesList.length; i++)
            if (reservesList[i] == _reserve) {
                reserveAlreadyAdded = true;
            }
        if (!reserveAlreadyAdded) reservesList.push(_reserve);
    }

}
.]

Below are the details of our target smart contract codes and their associated test reports:

Task: "pragma solidity ^0.5.0;

import "openzeppelin-solidity/contracts/math/SafeMath.sol";
import "openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol";
import "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol";
import "openzeppelin-solidity/contracts/utils/Address.sol";
import "../libraries/openzeppelin-upgradeability/VersionedInitializable.sol";

import "../libraries/CoreLibrary.sol";
import "../configuration/LendingPoolAddressesProvider.sol";
import "../interfaces/ILendingRateOracle.sol";
import "../interfaces/IReserveInterestRateStrategy.sol";
import "../libraries/WadRayMath.sol";
import "../tokenization/AToken.sol";
import "../libraries/EthAddressLib.sol";

/**
* @title LendingPoolCore contract
* @author Aave
* @notice Holds the state of the lending pool and all the funds deposited
* @dev NOTE: The core does not enforce security checks on the update of the state
* (eg, updateStateOnBorrow() does not enforce that borrowed is enabled on the reserve).
* The check that an action can be performed is a duty of the overlying LendingPool contract.
**/

contract LendingPoolCore is VersionedInitializable {
    using SafeMath for uint256;
    using WadRayMath for uint256;
    using CoreLibrary for CoreLibrary.ReserveData;
    using CoreLibrary for CoreLibrary.UserReserveData;
    using SafeERC20 for ERC20;
    using Address for address payable;

    /**
    * @dev Emitted when the state of a reserve is updated
    * @param reserve the address of the reserve
    * @param liquidityRate the new liquidity rate
    * @param stableBorrowRate the new stable borrow rate
    * @param variableBorrowRate the new variable borrow rate
    * @param liquidityIndex the new liquidity index
    * @param variableBorrowIndex the new variable borrow index
    **/
    event ReserveUpdated(
        address indexed reserve,
        uint256 liquidityRate,
        uint256 stableBorrowRate,
        uint256 variableBorrowRate,
        uint256 liquidityIndex,
        uint256 variableBorrowIndex
    );

    address public lendingPoolAddress;

    LendingPoolAddressesProvider public addressesProvider;

    /**
    * @dev only lending pools can use functions affected by this modifier
    **/
    modifier onlyLendingPool {
        require(lendingPoolAddress == msg.sender, "The caller must be a lending pool contract");
        _;
    }

    /**
    * @dev only lending pools configurator can use functions affected by this modifier
    **/
    modifier onlyLendingPoolConfigurator {
        require(
            addressesProvider.getLendingPoolConfigurator() == msg.sender,
            "The caller must be a lending pool configurator contract"
        );
        _;
    }

    mapping(address => CoreLibrary.ReserveData) internal reserves;
    mapping(address => mapping(address => CoreLibrary.UserReserveData)) internal usersReserveData;

    address[] public reservesList;

    uint256 public constant CORE_REVISION = 0x4;

    /**
    * @dev returns the revision number of the contract
    **/
    function getRevision() internal pure returns (uint256) {
        return CORE_REVISION;
    }

    /**
    * @dev initializes the Core contract, invoked upon registration on the AddressesProvider
    * @param _addressesProvider the addressesProvider contract
    **/

    function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {
        addressesProvider = _addressesProvider;
        refreshConfigInternal();
    }

    /**
    * @dev updates the state of the core as a result of a deposit action
    * @param _reserve the address of the reserve in which the deposit is happening
    * @param _user the address of the the user depositing
    * @param _amount the amount being deposited
    * @param _isFirstDeposit true if the user is depositing for the first time
    **/

    function updateStateOnDeposit(
        address _reserve,
        address _user,
        uint256 _amount,
        bool _isFirstDeposit
    ) external onlyLendingPool {
        reserves[_reserve].updateCumulativeIndexes();
        updateReserveInterestRatesAndTimestampInternal(_reserve, _amount, 0);

        if (_isFirstDeposit) {
            //if this is the first deposit of the user, we configure the deposit as enabled to be used as collateral
            setUserUseReserveAsCollateral(_reserve, _user, true);
        }
    }

    /**
    * @dev updates the state of the core as a result of a redeem action
    * @param _reserve the address of the reserve in which the redeem is happening
    * @param _user the address of the the user redeeming
    * @param _amountRedeemed the amount being redeemed
    * @param _userRedeemedEverything true if the user is redeeming everything
    **/
    function updateStateOnRedeem(
        address _reserve,
        address _user,
        uint256 _amountRedeemed,
        bool _userRedeemedEverything
    ) external onlyLendingPool {
        //compound liquidity and variable borrow interests
        reserves[_reserve].updateCumulativeIndexes();
        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountRedeemed);

        //if user redeemed everything the useReserveAsCollateral flag is reset
        if (_userRedeemedEverything) {
            setUserUseReserveAsCollateral(_reserve, _user, false);
        }
    }

    /**
    * @dev updates the state of the core as a result of a flashloan action
    * @param _reserve the address of the reserve in which the flashloan is happening
    * @param _income the income of the protocol as a result of the action
    **/
    function updateStateOnFlashLoan(
        address _reserve,
        uint256 _availableLiquidityBefore,
        uint256 _income,
        uint256 _protocolFee
    ) external onlyLendingPool {
        transferFlashLoanProtocolFeeInternal(_reserve, _protocolFee);

        //compounding the cumulated interest
        reserves[_reserve].updateCumulativeIndexes();

        uint256 totalLiquidityBefore = _availableLiquidityBefore.add(
            getReserveTotalBorrows(_reserve)
        );

        //compounding the received fee into the reserve
        reserves[_reserve].cumulateToLiquidityIndex(totalLiquidityBefore, _income);

        //refresh interest rates
        updateReserveInterestRatesAndTimestampInternal(_reserve, _income, 0);
    }

    /**
    * @dev updates the state of the core as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _amountBorrowed the new amount borrowed
    * @param _borrowFee the fee on the amount borrowed
    * @param _rateMode the borrow rate mode (stable, variable)
    * @return the new borrow rate for the user
    **/
    function updateStateOnBorrow(
        address _reserve,
        address _user,
        uint256 _amountBorrowed,
        uint256 _borrowFee,
        CoreLibrary.InterestRateMode _rateMode
    ) external onlyLendingPool returns (uint256, uint256) {
        // getting the previous borrow data of the user
        (uint256 principalBorrowBalance, , uint256 balanceIncrease) = getUserBorrowBalances(
            _reserve,
            _user
        );

        updateReserveStateOnBorrowInternal(
            _reserve,
            _user,
            principalBorrowBalance,
            balanceIncrease,
            _amountBorrowed,
            _rateMode
        );

        updateUserStateOnBorrowInternal(
            _reserve,
            _user,
            _amountBorrowed,
            balanceIncrease,
            _borrowFee,
            _rateMode
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountBorrowed);

        return (getUserCurrentBorrowRate(_reserve, _user), balanceIncrease);
    }

    /**
    * @dev updates the state of the core as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _originationFeeRepaid the fee on the amount that is being repaid
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _repaidWholeLoan true if the user is repaying the whole loan
    **/

    function updateStateOnRepay(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _originationFeeRepaid,
        uint256 _balanceIncrease,
        bool _repaidWholeLoan
    ) external onlyLendingPool {
        updateReserveStateOnRepayInternal(
            _reserve,
            _user,
            _paybackAmountMinusFees,
            _balanceIncrease
        );
        updateUserStateOnRepayInternal(
            _reserve,
            _user,
            _paybackAmountMinusFees,
            _originationFeeRepaid,
            _balanceIncrease,
            _repaidWholeLoan
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, _paybackAmountMinusFees, 0);
    }

    /**
    * @dev updates the state of the core as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the amount borrowed by the user
    * @param _compoundedBorrowBalance the amount borrowed plus accrued interest
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _currentRateMode the current interest rate mode for the user
    **/
    function updateStateOnSwapRate(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _compoundedBorrowBalance,
        uint256 _balanceIncrease,
        CoreLibrary.InterestRateMode _currentRateMode
    ) external onlyLendingPool returns (CoreLibrary.InterestRateMode, uint256) {
        updateReserveStateOnSwapRateInternal(
            _reserve,
            _user,
            _principalBorrowBalance,
            _compoundedBorrowBalance,
            _currentRateMode
        );

        CoreLibrary.InterestRateMode newRateMode = updateUserStateOnSwapRateInternal(
            _reserve,
            _user,
            _balanceIncrease,
            _currentRateMode
        );

        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);

        return (newRateMode, getUserCurrentBorrowRate(_reserve, _user));
    }

    /**
    * @dev updates the state of the core as a consequence of a liquidation action.
    * @param _principalReserve the address of the principal reserve that is being repaid
    * @param _collateralReserve the address of the collateral reserve that is being liquidated
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _collateralToLiquidate the amount of collateral being liquidated
    * @param _feeLiquidated the amount of origination fee being liquidated
    * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise
    **/
    function updateStateOnLiquidation(
        address _principalReserve,
        address _collateralReserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _collateralToLiquidate,
        uint256 _feeLiquidated,
        uint256 _liquidatedCollateralForFee,
        uint256 _balanceIncrease,
        bool _liquidatorReceivesAToken
    ) external onlyLendingPool {
        updatePrincipalReserveStateOnLiquidationInternal(
            _principalReserve,
            _user,
            _amountToLiquidate,
            _balanceIncrease
        );

        updateCollateralReserveStateOnLiquidationInternal(
            _collateralReserve
        );

        updateUserStateOnLiquidationInternal(
            _principalReserve,
            _user,
            _amountToLiquidate,
            _feeLiquidated,
            _balanceIncrease
        );

        updateReserveInterestRatesAndTimestampInternal(_principalReserve, _amountToLiquidate, 0);

        if (!_liquidatorReceivesAToken) {
            updateReserveInterestRatesAndTimestampInternal(
                _collateralReserve,
                0,
                _collateralToLiquidate.add(_liquidatedCollateralForFee)
            );
        }

    }

    /**
    * @dev updates the state of the core as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @return the new stable rate for the user
    **/
    function updateStateOnRebalance(address _reserve, address _user, uint256 _balanceIncrease)
    external
    onlyLendingPool
    returns (uint256)
    {
        updateReserveStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);

        //update user data and rebalance the rate
        updateUserStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);
        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);
        return usersReserveData[_user][_reserve].stableBorrowRate;
    }

    /**
    * @dev enables or disables a reserve as collateral
    * @param _reserve the address of the principal reserve where the user deposited
    * @param _user the address of the depositor
    * @param _useAsCollateral true if the depositor wants to use the reserve as collateral
    **/
    function setUserUseReserveAsCollateral(address _reserve, address _user, bool _useAsCollateral)
    public
    onlyLendingPool
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        user.useAsCollateral = _useAsCollateral;
    }

    /**
    * @notice ETH/token transfer functions
    **/

    /**
    * @dev fallback function enforces that the caller is a contract, to support flashloan transfers
    **/
    function() external payable {
        //only contracts can send ETH to the core
        require(msg.sender.isContract(), "Only contracts can send ether to the Lending pool core");

    }

    /**
    * @dev transfers to the user a specific amount from the reserve.
    * @param _reserve the address of the reserve where the transfer is happening
    * @param _user the address of the user receiving the transfer
    * @param _amount the amount being transferred
    **/
    function transferToUser(address _reserve, address payable _user, uint256 _amount)
    external
    onlyLendingPool
    {
        if (_reserve != EthAddressLib.ethAddress()) {
            ERC20(_reserve).safeTransfer(_user, _amount);
        } else {
            //solium-disable-next-line
            (bool result, ) = _user.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers the protocol fees to the fees collection address
    * @param _token the address of the token being transferred
    * @param _user the address of the user from where the transfer is happening
    * @param _amount the amount being transferred
    * @param _destination the fee receiver address
    **/

    function transferToFeeCollectionAddress(
        address _token,
        address _user,
        uint256 _amount,
        address _destination
    ) external payable onlyLendingPool {
        address payable feeAddress = address(uint160(_destination)); //cast the address to payable

        if (_token != EthAddressLib.ethAddress()) {
            require(
                msg.value == 0,
                "User is sending ETH along with the ERC20 transfer. Check the value attribute of the transaction"
            );
            ERC20(_token).safeTransferFrom(_user, feeAddress, _amount);
        } else {
            require(msg.value >= _amount, "The amount and the value sent to deposit do not match");
            //solium-disable-next-line
            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers the fees to the fees collection address in the case of liquidation
    * @param _token the address of the token being transferred
    * @param _amount the amount being transferred
    * @param _destination the fee receiver address
    **/
    function liquidateFee(
        address _token,
        uint256 _amount,
        address _destination
    ) external payable onlyLendingPool {
        address payable feeAddress = address(uint160(_destination)); //cast the address to payable
        require(
            msg.value == 0,
            "Fee liquidation does not require any transfer of value"
        );

        if (_token != EthAddressLib.ethAddress()) {
            ERC20(_token).safeTransfer(feeAddress, _amount);
        } else {
            //solium-disable-next-line
            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");
            require(result, "Transfer of ETH failed");
        }
    }

    /**
    * @dev transfers an amount from a user to the destination reserve
    * @param _reserve the address of the reserve where the amount is being transferred
    * @param _user the address of the user from where the transfer is happening
    * @param _amount the amount being transferred
    **/
    function transferToReserve(address _reserve, address payable _user, uint256 _amount)
    external
    payable
    onlyLendingPool
    {
        if (_reserve != EthAddressLib.ethAddress()) {
            require(msg.value == 0, "User is sending ETH along with the ERC20 transfer.");
            ERC20(_reserve).safeTransferFrom(_user, address(this), _amount);

        } else {
            require(msg.value >= _amount, "The amount and the value sent to deposit do not match");

            if (msg.value > _amount) {
                //send back excess ETH
                uint256 excessAmount = msg.value.sub(_amount);
                //solium-disable-next-line
                (bool result, ) = _user.call.value(excessAmount).gas(50000)("");
                require(result, "Transfer of ETH failed");
            }
        }
    }

    /**
    * @notice data access functions
    **/

    /**
    * @dev returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral)
    * needed to calculate the global account data in the LendingPoolDataProvider
    * @param _reserve the address of the reserve
    * @param _user the address of the user
    * @return the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not
    **/
    function getUserBasicReserveData(address _reserve, address _user)
    external
    view
    returns (uint256, uint256, uint256, bool)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        uint256 underlyingBalance = getUserUnderlyingAssetBalance(_reserve, _user);

        if (user.principalBorrowBalance == 0) {
            return (underlyingBalance, 0, 0, user.useAsCollateral);
        }

        return (
        underlyingBalance,
        user.getCompoundedBorrowBalance(reserve),
        user.originationFee,
        user.useAsCollateral
        );
    }

    /**
    * @dev checks if a user is allowed to borrow at a stable rate
    * @param _reserve the reserve address
    * @param _user the user
    * @param _amount the amount the the user wants to borrow
    * @return true if the user is allowed to borrow at a stable rate, false otherwise
    **/

    function isUserAllowedToBorrowAtStable(address _reserve, address _user, uint256 _amount)
    external
    view
    returns (bool)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (!reserve.isStableBorrowRateEnabled) return false;

        return
        !user.useAsCollateral ||
        !reserve.usageAsCollateralEnabled ||
        _amount > getUserUnderlyingAssetBalance(_reserve, _user);
    }

    /**
    * @dev gets the underlying asset balance of a user based on the corresponding aToken balance.
    * @param _reserve the reserve address
    * @param _user the user address
    * @return the underlying deposit balance of the user
    **/

    function getUserUnderlyingAssetBalance(address _reserve, address _user)
    public
    view
    returns (uint256)
    {
        AToken aToken = AToken(reserves[_reserve].aTokenAddress);
        return aToken.balanceOf(_user);

    }

    /**
    * @dev gets the interest rate strategy contract address for the reserve
    * @param _reserve the reserve address
    * @return the address of the interest rate strategy contract
    **/
    function getReserveInterestRateStrategyAddress(address _reserve) public view returns (address) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.interestRateStrategyAddress;
    }

    /**
    * @dev gets the aToken contract address for the reserve
    * @param _reserve the reserve address
    * @return the address of the aToken contract
    **/

    function getReserveATokenAddress(address _reserve) public view returns (address) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.aTokenAddress;
    }

    /**
    * @dev gets the available liquidity in the reserve. The available liquidity is the balance of the core contract
    * @param _reserve the reserve address
    * @return the available liquidity
    **/
    function getReserveAvailableLiquidity(address _reserve) public view returns (uint256) {
        uint256 balance = 0;

        if (_reserve == EthAddressLib.ethAddress()) {
            balance = address(this).balance;
        } else {
            balance = IERC20(_reserve).balanceOf(address(this));
        }
        return balance;
    }

    /**
    * @dev gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows
    * @param _reserve the reserve address
    * @return the total liquidity
    **/
    function getReserveTotalLiquidity(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return getReserveAvailableLiquidity(_reserve).add(reserve.getTotalBorrows());
    }

    /**
    * @dev gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there
    * there has been 100% income.
    * @param _reserve the reserve address
    * @return the reserve normalized income
    **/
    function getReserveNormalizedIncome(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.getNormalizedIncome();
    }

    /**
    * @dev gets the reserve total borrows
    * @param _reserve the reserve address
    * @return the total borrows (stable + variable)
    **/
    function getReserveTotalBorrows(address _reserve) public view returns (uint256) {
        return reserves[_reserve].getTotalBorrows();
    }

    /**
    * @dev gets the reserve total borrows stable
    * @param _reserve the reserve address
    * @return the total borrows stable
    **/
    function getReserveTotalBorrowsStable(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.totalBorrowsStable;
    }

    /**
    * @dev gets the reserve total borrows variable
    * @param _reserve the reserve address
    * @return the total borrows variable
    **/

    function getReserveTotalBorrowsVariable(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.totalBorrowsVariable;
    }

    /**
    * @dev gets the reserve liquidation threshold
    * @param _reserve the reserve address
    * @return the reserve liquidation threshold
    **/

    function getReserveLiquidationThreshold(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.liquidationThreshold;
    }

    /**
    * @dev gets the reserve liquidation bonus
    * @param _reserve the reserve address
    * @return the reserve liquidation bonus
    **/

    function getReserveLiquidationBonus(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.liquidationBonus;
    }

    /**
    * @dev gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty
    * @param _reserve the reserve address
    * @return the reserve current variable borrow rate
    **/

    function getReserveCurrentVariableBorrowRate(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        if (reserve.currentVariableBorrowRate == 0) {
            return
            IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)
            .getBaseVariableBorrowRate();
        }
        return reserve.currentVariableBorrowRate;
    }

    /**
    * @dev gets the reserve current stable borrow rate. Is the market rate if the reserve is empty
    * @param _reserve the reserve address
    * @return the reserve current stable borrow rate
    **/

    function getReserveCurrentStableBorrowRate(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        ILendingRateOracle oracle = ILendingRateOracle(addressesProvider.getLendingRateOracle());

        if (reserve.currentStableBorrowRate == 0) {
            //no stable rate borrows yet
            return oracle.getMarketBorrowRate(_reserve);
        }

        return reserve.currentStableBorrowRate;
    }

    /**
    * @dev gets the reserve average stable borrow rate. The average stable rate is the weighted average
    * of all the loans taken at stable rate.
    * @param _reserve the reserve address
    * @return the reserve current average borrow rate
    **/
    function getReserveCurrentAverageStableBorrowRate(address _reserve)
    external
    view
    returns (uint256)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.currentAverageStableBorrowRate;
    }

    /**
    * @dev gets the reserve liquidity rate
    * @param _reserve the reserve address
    * @return the reserve liquidity rate
    **/
    function getReserveCurrentLiquidityRate(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.currentLiquidityRate;
    }

    /**
    * @dev gets the reserve liquidity cumulative index
    * @param _reserve the reserve address
    * @return the reserve liquidity cumulative index
    **/
    function getReserveLiquidityCumulativeIndex(address _reserve) external view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.lastLiquidityCumulativeIndex;
    }

    /**
    * @dev gets the reserve variable borrow index
    * @param _reserve the reserve address
    * @return the reserve variable borrow index
    **/
    function getReserveVariableBorrowsCumulativeIndex(address _reserve)
    external
    view
    returns (uint256)
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.lastVariableBorrowCumulativeIndex;
    }

    /**
    * @dev this function aggregates the configuration parameters of the reserve.
    * It's used in the LendingPoolDataProvider specifically to save gas, and avoid
    * multiple external contract calls to fetch the same data.
    * @param _reserve the reserve address
    * @return the reserve decimals
    * @return the base ltv as collateral
    * @return the liquidation threshold
    * @return if the reserve is used as collateral or not
    **/
    function getReserveConfiguration(address _reserve)
    external
    view
    returns (uint256, uint256, uint256, bool)
    {
        uint256 decimals;
        uint256 baseLTVasCollateral;
        uint256 liquidationThreshold;
        bool usageAsCollateralEnabled;

        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        decimals = reserve.decimals;
        baseLTVasCollateral = reserve.baseLTVasCollateral;
        liquidationThreshold = reserve.liquidationThreshold;
        usageAsCollateralEnabled = reserve.usageAsCollateralEnabled;

        return (decimals, baseLTVasCollateral, liquidationThreshold, usageAsCollateralEnabled);
    }

    /**
    * @dev returns the decimals of the reserve
    * @param _reserve the reserve address
    * @return the reserve decimals
    **/
    function getReserveDecimals(address _reserve) external view returns (uint256) {
        return reserves[_reserve].decimals;
    }

    /**
    * @dev returns true if the reserve is enabled for borrowing
    * @param _reserve the reserve address
    * @return true if the reserve is enabled for borrowing, false otherwise
    **/

    function isReserveBorrowingEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.borrowingEnabled;
    }

    /**
    * @dev returns true if the reserve is enabled as collateral
    * @param _reserve the reserve address
    * @return true if the reserve is enabled as collateral, false otherwise
    **/

    function isReserveUsageAsCollateralEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.usageAsCollateralEnabled;
    }

    /**
    * @dev returns true if the stable rate is enabled on reserve
    * @param _reserve the reserve address
    * @return true if the stable rate is enabled on reserve, false otherwise
    **/
    function getReserveIsStableBorrowRateEnabled(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isStableBorrowRateEnabled;
    }

    /**
    * @dev returns true if the reserve is active
    * @param _reserve the reserve address
    * @return true if the reserve is active, false otherwise
    **/
    function getReserveIsActive(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isActive;
    }

    /**
    * @notice returns if a reserve is freezed
    * @param _reserve the reserve for which the information is needed
    * @return true if the reserve is freezed, false otherwise
    **/

    function getReserveIsFreezed(address _reserve) external view returns (bool) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        return reserve.isFreezed;
    }

    /**
    * @notice returns the timestamp of the last action on the reserve
    * @param _reserve the reserve for which the information is needed
    * @return the last updated timestamp of the reserve
    **/

    function getReserveLastUpdate(address _reserve) external view returns (uint40 timestamp) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        timestamp = reserve.lastUpdateTimestamp;
    }

    /**
    * @dev returns the utilization rate U of a specific reserve
    * @param _reserve the reserve for which the information is needed
    * @return the utilization rate in ray
    **/

    function getReserveUtilizationRate(address _reserve) public view returns (uint256) {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        uint256 totalBorrows = reserve.getTotalBorrows();

        if (totalBorrows == 0) {
            return 0;
        }

        uint256 availableLiquidity = getReserveAvailableLiquidity(_reserve);

        return totalBorrows.rayDiv(availableLiquidity.add(totalBorrows));
    }

    /**
    * @return the array of reserves configured on the core
    **/
    function getReserves() external view returns (address[] memory) {
        return reservesList;
    }

    /**
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return true if the user has chosen to use the reserve as collateral, false otherwise
    **/
    function isUserUseReserveAsCollateralEnabled(address _reserve, address _user)
    external
    view
    returns (bool)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.useAsCollateral;
    }

    /**
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the origination fee for the user
    **/
    function getUserOriginationFee(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.originationFee;
    }

    /**
    * @dev users with no loans in progress have NONE as borrow rate mode
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the borrow rate mode for the user,
    **/

    function getUserCurrentBorrowRateMode(address _reserve, address _user)
    public
    view
    returns (CoreLibrary.InterestRateMode)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (user.principalBorrowBalance == 0) {
            return CoreLibrary.InterestRateMode.NONE;
        }

        return
        user.stableBorrowRate > 0
        ? CoreLibrary.InterestRateMode.STABLE
        : CoreLibrary.InterestRateMode.VARIABLE;
    }

    /**
    * @dev gets the current borrow rate of the user
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the borrow rate for the user,
    **/
    function getUserCurrentBorrowRate(address _reserve, address _user)
    internal
    view
    returns (uint256)
    {
        CoreLibrary.InterestRateMode rateMode = getUserCurrentBorrowRateMode(_reserve, _user);

        if (rateMode == CoreLibrary.InterestRateMode.NONE) {
            return 0;
        }

        return
        rateMode == CoreLibrary.InterestRateMode.STABLE
        ? usersReserveData[_user][_reserve].stableBorrowRate
        : reserves[_reserve].currentVariableBorrowRate;
    }

    /**
    * @dev the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the user stable rate
    **/
    function getUserCurrentStableBorrowRate(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.stableBorrowRate;
    }

    /**
    * @dev calculates and returns the borrow balances of the user
    * @param _reserve the address of the reserve
    * @param _user the address of the user
    * @return the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance
    **/

    function getUserBorrowBalances(address _reserve, address _user)
    public
    view
    returns (uint256, uint256, uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        if (user.principalBorrowBalance == 0) {
            return (0, 0, 0);
        }

        uint256 principal = user.principalBorrowBalance;
        uint256 compoundedBalance = CoreLibrary.getCompoundedBorrowBalance(
            user,
            reserves[_reserve]
        );
        return (principal, compoundedBalance, compoundedBalance.sub(principal));
    }

    /**
    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the variable borrow index for the user
    **/

    function getUserVariableBorrowCumulativeIndex(address _reserve, address _user)
    external
    view
    returns (uint256)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        return user.lastVariableBorrowCumulativeIndex;
    }

    /**
    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
    * @param _reserve the address of the reserve for which the information is needed
    * @param _user the address of the user for which the information is needed
    * @return the variable borrow index for the user
    **/

    function getUserLastUpdate(address _reserve, address _user)
    external
    view
    returns (uint256 timestamp)
    {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        timestamp = user.lastUpdateTimestamp;
    }

    /**
    * @dev updates the lending pool core configuration
    **/
    function refreshConfiguration() external onlyLendingPoolConfigurator {
        refreshConfigInternal();
    }

    /**
    * @dev initializes a reserve
    * @param _reserve the address of the reserve
    * @param _aTokenAddress the address of the overlying aToken contract
    * @param _decimals the decimals of the reserve currency
    * @param _interestRateStrategyAddress the address of the interest rate strategy contract
    **/
    function initReserve(
        address _reserve,
        address _aTokenAddress,
        uint256 _decimals,
        address _interestRateStrategyAddress
    ) external onlyLendingPoolConfigurator {
        reserves[_reserve].init(_aTokenAddress, _decimals, _interestRateStrategyAddress);
        addReserveToListInternal(_reserve);

    }



    /**
    * @dev removes the last added reserve in the reservesList array
    * @param _reserveToRemove the address of the reserve
    **/
    function removeLastAddedReserve(address _reserveToRemove)
    external onlyLendingPoolConfigurator {

        address lastReserve = reservesList[reservesList.length-1];

        require(lastReserve == _reserveToRemove, "Reserve being removed is different than the reserve requested");

        //as we can't check if totalLiquidity is 0 (since the reserve added might not be an ERC20) we at least check that there is nothing borrowed
        require(getReserveTotalBorrows(lastReserve) == 0, "Cannot remove a reserve with liquidity deposited");

        reserves[lastReserve].isActive = false;
        reserves[lastReserve].aTokenAddress = address(0);
        reserves[lastReserve].decimals = 0;
        reserves[lastReserve].lastLiquidityCumulativeIndex = 0;
        reserves[lastReserve].lastVariableBorrowCumulativeIndex = 0;
        reserves[lastReserve].borrowingEnabled = false;
        reserves[lastReserve].usageAsCollateralEnabled = false;
        reserves[lastReserve].baseLTVasCollateral = 0;
        reserves[lastReserve].liquidationThreshold = 0;
        reserves[lastReserve].liquidationBonus = 0;
        reserves[lastReserve].interestRateStrategyAddress = address(0);

        reservesList.pop();
    }

    /**
    * @dev updates the address of the interest rate strategy contract
    * @param _reserve the address of the reserve
    * @param _rateStrategyAddress the address of the interest rate strategy contract
    **/

    function setReserveInterestRateStrategyAddress(address _reserve, address _rateStrategyAddress)
    external
    onlyLendingPoolConfigurator
    {
        reserves[_reserve].interestRateStrategyAddress = _rateStrategyAddress;
    }

    /**
    * @dev enables borrowing on a reserve. Also sets the stable rate borrowing
    * @param _reserve the address of the reserve
    * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise
    **/

    function enableBorrowingOnReserve(address _reserve, bool _stableBorrowRateEnabled)
    external
    onlyLendingPoolConfigurator
    {
        reserves[_reserve].enableBorrowing(_stableBorrowRateEnabled);
    }

    /**
    * @dev disables borrowing on a reserve
    * @param _reserve the address of the reserve
    **/

    function disableBorrowingOnReserve(address _reserve) external onlyLendingPoolConfigurator {
        reserves[_reserve].disableBorrowing();
    }

    /**
    * @dev enables a reserve to be used as collateral
    * @param _reserve the address of the reserve
    **/
    function enableReserveAsCollateral(
        address _reserve,
        uint256 _baseLTVasCollateral,
        uint256 _liquidationThreshold,
        uint256 _liquidationBonus
    ) external onlyLendingPoolConfigurator {
        reserves[_reserve].enableAsCollateral(
            _baseLTVasCollateral,
            _liquidationThreshold,
            _liquidationBonus
        );
    }

    /**
    * @dev disables a reserve to be used as collateral
    * @param _reserve the address of the reserve
    **/
    function disableReserveAsCollateral(address _reserve) external onlyLendingPoolConfigurator {
        reserves[_reserve].disableAsCollateral();
    }

    /**
    * @dev enable the stable borrow rate mode on a reserve
    * @param _reserve the address of the reserve
    **/
    function enableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isStableBorrowRateEnabled = true;
    }

    /**
    * @dev disable the stable borrow rate mode on a reserve
    * @param _reserve the address of the reserve
    **/
    function disableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isStableBorrowRateEnabled = false;
    }

    /**
    * @dev activates a reserve
    * @param _reserve the address of the reserve
    **/
    function activateReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        require(
            reserve.lastLiquidityCumulativeIndex > 0 &&
            reserve.lastVariableBorrowCumulativeIndex > 0,
            "Reserve has not been initialized yet"
        );
        reserve.isActive = true;
    }

    /**
    * @dev deactivates a reserve
    * @param _reserve the address of the reserve
    **/
    function deactivateReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isActive = false;
    }

    /**
    * @notice allows the configurator to freeze the reserve.
    * A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance.
    * @param _reserve the address of the reserve
    **/
    function freezeReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isFreezed = true;
    }

    /**
    * @notice allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed.
    * @param _reserve the address of the reserve
    **/
    function unfreezeReserve(address _reserve) external onlyLendingPoolConfigurator {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.isFreezed = false;
    }

    /**
    * @notice allows the configurator to update the loan to value of a reserve
    * @param _reserve the address of the reserve
    * @param _ltv the new loan to value
    **/
    function setReserveBaseLTVasCollateral(address _reserve, uint256 _ltv)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.baseLTVasCollateral = _ltv;
    }

    /**
    * @notice allows the configurator to update the liquidation threshold of a reserve
    * @param _reserve the address of the reserve
    * @param _threshold the new liquidation threshold
    **/
    function setReserveLiquidationThreshold(address _reserve, uint256 _threshold)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.liquidationThreshold = _threshold;
    }

    /**
    * @notice allows the configurator to update the liquidation bonus of a reserve
    * @param _reserve the address of the reserve
    * @param _bonus the new liquidation bonus
    **/
    function setReserveLiquidationBonus(address _reserve, uint256 _bonus)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.liquidationBonus = _bonus;
    }

    /**
    * @notice allows the configurator to update the reserve decimals
    * @param _reserve the address of the reserve
    * @param _decimals the decimals of the reserve
    **/
    function setReserveDecimals(address _reserve, uint256 _decimals)
    external
    onlyLendingPoolConfigurator
    {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        reserve.decimals = _decimals;
    }

    /**
    * @notice internal functions
    **/

    /**
    * @dev updates the state of a reserve as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the previous borrow balance of the borrower before the action
    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount
    * @param _amountBorrowed the new amount borrowed
    * @param _rateMode the borrow rate mode (stable, variable)
    **/

    function updateReserveStateOnBorrowInternal(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _balanceIncrease,
        uint256 _amountBorrowed,
        CoreLibrary.InterestRateMode _rateMode
    ) internal {
        reserves[_reserve].updateCumulativeIndexes();

        //increasing reserve total borrows to account for the new borrow balance of the user
        //NOTE: Depending on the previous borrow mode, the borrows might need to be switched from variable to stable or vice versa

        updateReserveTotalBorrowsByRateModeInternal(
            _reserve,
            _user,
            _principalBorrowBalance,
            _balanceIncrease,
            _amountBorrowed,
            _rateMode
        );
    }

    /**
    * @dev updates the state of a user as a consequence of a borrow action.
    * @param _reserve the address of the reserve on which the user is borrowing
    * @param _user the address of the borrower
    * @param _amountBorrowed the amount borrowed
    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount
    * @param _rateMode the borrow rate mode (stable, variable)
    * @return the final borrow rate for the user. Emitted by the borrow() event
    **/

    function updateUserStateOnBorrowInternal(
        address _reserve,
        address _user,
        uint256 _amountBorrowed,
        uint256 _balanceIncrease,
        uint256 _fee,
        CoreLibrary.InterestRateMode _rateMode
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        if (_rateMode == CoreLibrary.InterestRateMode.STABLE) {
            //stable
            //reset the user variable index, and update the stable rate
            user.stableBorrowRate = reserve.currentStableBorrowRate;
            user.lastVariableBorrowCumulativeIndex = 0;
        } else if (_rateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //variable
            //reset the user stable rate, and store the new borrow index
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        } else {
            revert("Invalid borrow rate mode");
        }
        //increase the principal borrows and the origination fee
        user.principalBorrowBalance = user.principalBorrowBalance.add(_amountBorrowed).add(
            _balanceIncrease
        );
        user.originationFee = user.originationFee.add(_fee);

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

    }

    /**
    * @dev updates the state of the reserve as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateReserveStateOnRepayInternal(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_reserve][_user];

        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(_reserve, _user);

        //update the indexes
        reserves[_reserve].updateCumulativeIndexes();

        //compound the cumulated interest to the borrow balance and then subtracting the payback amount
        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _balanceIncrease,
                user.stableBorrowRate
            );
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _paybackAmountMinusFees,
                user.stableBorrowRate
            );
        } else {
            reserve.increaseTotalBorrowsVariable(_balanceIncrease);
            reserve.decreaseTotalBorrowsVariable(_paybackAmountMinusFees);
        }
    }

    /**
    * @dev updates the state of the user as a consequence of a repay action.
    * @param _reserve the address of the reserve on which the user is repaying
    * @param _user the address of the borrower
    * @param _paybackAmountMinusFees the amount being paid back minus fees
    * @param _originationFeeRepaid the fee on the amount that is being repaid
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _repaidWholeLoan true if the user is repaying the whole loan
    **/
    function updateUserStateOnRepayInternal(
        address _reserve,
        address _user,
        uint256 _paybackAmountMinusFees,
        uint256 _originationFeeRepaid,
        uint256 _balanceIncrease,
        bool _repaidWholeLoan
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        //update the user principal borrow balance, adding the cumulated interest and then subtracting the payback amount
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(
            _paybackAmountMinusFees
        );
        user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;

        //if the balance decrease is equal to the previous principal (user is repaying the whole loan)
        //and the rate mode is stable, we reset the interest rate mode of the user
        if (_repaidWholeLoan) {
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = 0;
        }
        user.originationFee = user.originationFee.sub(_originationFeeRepaid);

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

    }

    /**
    * @dev updates the state of the user as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is performing the rate swap
    * @param _user the address of the borrower
    * @param _principalBorrowBalance the the principal amount borrowed by the user
    * @param _compoundedBorrowBalance the principal amount plus the accrued interest
    * @param _currentRateMode the rate mode at which the user borrowed
    **/
    function updateReserveStateOnSwapRateInternal(
        address _reserve,
        address _user,
        uint256 _principalBorrowBalance,
        uint256 _compoundedBorrowBalance,
        CoreLibrary.InterestRateMode _currentRateMode
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        //compounding reserve indexes
        reserve.updateCumulativeIndexes();

        if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {
            uint256 userCurrentStableRate = user.stableBorrowRate;

            //swap to variable
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _principalBorrowBalance,
                userCurrentStableRate
            ); //decreasing stable from old principal balance
            reserve.increaseTotalBorrowsVariable(_compoundedBorrowBalance); //increase variable borrows
        } else if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //swap to stable
            uint256 currentStableRate = reserve.currentStableBorrowRate;
            reserve.decreaseTotalBorrowsVariable(_principalBorrowBalance);
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _compoundedBorrowBalance,
                currentStableRate
            );

        } else {
            revert("Invalid rate mode received");
        }
    }

    /**
    * @dev updates the state of the user as a consequence of a swap rate action.
    * @param _reserve the address of the reserve on which the user is performing the swap
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _currentRateMode the current rate mode of the user
    **/

    function updateUserStateOnSwapRateInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease,
        CoreLibrary.InterestRateMode _currentRateMode
    ) internal returns (CoreLibrary.InterestRateMode) {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        CoreLibrary.InterestRateMode newMode = CoreLibrary.InterestRateMode.NONE;

        if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            //switch to stable
            newMode = CoreLibrary.InterestRateMode.STABLE;
            user.stableBorrowRate = reserve.currentStableBorrowRate;
            user.lastVariableBorrowCumulativeIndex = 0;
        } else if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {
            newMode = CoreLibrary.InterestRateMode.VARIABLE;
            user.stableBorrowRate = 0;
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        } else {
            revert("Invalid interest rate mode received");
        }
        //compounding cumulated interest
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);
        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);

        return newMode;
    }

    /**
    * @dev updates the state of the principal reserve as a consequence of a liquidation action.
    * @param _principalReserve the address of the principal reserve that is being repaid
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updatePrincipalReserveStateOnLiquidationInternal(
        address _principalReserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_principalReserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_principalReserve];

        //update principal reserve data
        reserve.updateCumulativeIndexes();

        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(
            _principalReserve,
            _user
        );

        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            //increase the total borrows by the compounded interest
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                _balanceIncrease,
                user.stableBorrowRate
            );

            //decrease by the actual amount to liquidate
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _amountToLiquidate,
                user.stableBorrowRate
            );

        } else {
            //increase the total borrows by the compounded interest
            reserve.increaseTotalBorrowsVariable(_balanceIncrease);

            //decrease by the actual amount to liquidate
            reserve.decreaseTotalBorrowsVariable(_amountToLiquidate);
        }

    }

    /**
    * @dev updates the state of the collateral reserve as a consequence of a liquidation action.
    * @param _collateralReserve the address of the collateral reserve that is being liquidated
    **/
    function updateCollateralReserveStateOnLiquidationInternal(
        address _collateralReserve
    ) internal {
        //update collateral reserve
        reserves[_collateralReserve].updateCumulativeIndexes();

    }

    /**
    * @dev updates the state of the user being liquidated as a consequence of a liquidation action.
    * @param _reserve the address of the principal reserve that is being repaid
    * @param _user the address of the borrower
    * @param _amountToLiquidate the amount being repaid by the liquidator
    * @param _feeLiquidated the amount of origination fee being liquidated
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/
    function updateUserStateOnLiquidationInternal(
        address _reserve,
        address _user,
        uint256 _amountToLiquidate,
        uint256 _feeLiquidated,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        //first increase by the compounded interest, then decrease by the liquidated amount
        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(
            _amountToLiquidate
        );

        if (
            getUserCurrentBorrowRateMode(_reserve, _user) == CoreLibrary.InterestRateMode.VARIABLE
        ) {
            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;
        }

        if(_feeLiquidated > 0){
            user.originationFee = user.originationFee.sub(_feeLiquidated);
        }

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);
    }

    /**
    * @dev updates the state of the reserve as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateReserveStateOnRebalanceInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];

        reserve.updateCumulativeIndexes();

        reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
            _balanceIncrease,
            user.stableBorrowRate
        );

    }

    /**
    * @dev updates the state of the user as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    **/

    function updateUserStateOnRebalanceInternal(
        address _reserve,
        address _user,
        uint256 _balanceIncrease
    ) internal {
        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);
        user.stableBorrowRate = reserve.currentStableBorrowRate;

        //solium-disable-next-line
        user.lastUpdateTimestamp = uint40(block.timestamp);
    }

    /**
    * @dev updates the state of the user as a consequence of a stable rate rebalance
    * @param _reserve the address of the principal reserve where the user borrowed
    * @param _user the address of the borrower
    * @param _balanceIncrease the accrued interest on the borrowed amount
    * @param _amountBorrowed the accrued interest on the borrowed amount
    **/
    function updateReserveTotalBorrowsByRateModeInternal(
        address _reserve,
        address _user,
        uint256 _principalBalance,
        uint256 _balanceIncrease,
        uint256 _amountBorrowed,
        CoreLibrary.InterestRateMode _newBorrowRateMode
    ) internal {
        CoreLibrary.InterestRateMode previousRateMode = getUserCurrentBorrowRateMode(
            _reserve,
            _user
        );
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];

        if (previousRateMode == CoreLibrary.InterestRateMode.STABLE) {
            CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];
            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(
                _principalBalance,
                user.stableBorrowRate
            );
        } else if (previousRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            reserve.decreaseTotalBorrowsVariable(_principalBalance);
        }

        uint256 newPrincipalAmount = _principalBalance.add(_balanceIncrease).add(_amountBorrowed);
        if (_newBorrowRateMode == CoreLibrary.InterestRateMode.STABLE) {
            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(
                newPrincipalAmount,
                reserve.currentStableBorrowRate
            );
        } else if (_newBorrowRateMode == CoreLibrary.InterestRateMode.VARIABLE) {
            reserve.increaseTotalBorrowsVariable(newPrincipalAmount);
        } else {
            revert("Invalid new borrow rate mode");
        }
    }

    /**
    * @dev Updates the reserve current stable borrow rate Rf, the current variable borrow rate Rv and the current liquidity rate Rl.
    * Also updates the lastUpdateTimestamp value. Please refer to the whitepaper for further information.
    * @param _reserve the address of the reserve to be updated
    * @param _liquidityAdded the amount of liquidity added to the protocol (deposit or repay) in the previous action
    * @param _liquidityTaken the amount of liquidity taken from the protocol (redeem or borrow)
    **/

    function updateReserveInterestRatesAndTimestampInternal(
        address _reserve,
        uint256 _liquidityAdded,
        uint256 _liquidityTaken
    ) internal {
        CoreLibrary.ReserveData storage reserve = reserves[_reserve];
        (uint256 newLiquidityRate, uint256 newStableRate, uint256 newVariableRate) = IReserveInterestRateStrategy(
            reserve
            .interestRateStrategyAddress
        )
        .calculateInterestRates(
            _reserve,
            getReserveAvailableLiquidity(_reserve).add(_liquidityAdded).sub(_liquidityTaken),
            reserve.totalBorrowsStable,
            reserve.totalBorrowsVariable,
            reserve.currentAverageStableBorrowRate
        );

        reserve.currentLiquidityRate = newLiquidityRate;
        reserve.currentStableBorrowRate = newStableRate;
        reserve.currentVariableBorrowRate = newVariableRate;

        //solium-disable-next-line
        reserve.lastUpdateTimestamp = uint40(block.timestamp);

        emit ReserveUpdated(
            _reserve,
            newLiquidityRate,
            newStableRate,
            newVariableRate,
            reserve.lastLiquidityCumulativeIndex,
            reserve.lastVariableBorrowCumulativeIndex
        );
    }

    /**
    * @dev transfers to the protocol fees of a flashloan to the fees collection address
    * @param _token the address of the token being transferred
    * @param _amount the amount being transferred
    **/

    function transferFlashLoanProtocolFeeInternal(address _token, uint256 _amount) internal {
        address payable receiver = address(uint160(addressesProvider.getTokenDistributor()));

        if (_token != EthAddressLib.ethAddress()) {
            ERC20(_token).safeTransfer(receiver, _amount);
        } else {
            receiver.transfer(_amount);
        }
    }

    /**
    * @dev updates the internal configuration of the core
    **/
    function refreshConfigInternal() internal {
        lendingPoolAddress = addressesProvider.getLendingPool();
    }

    /**
    * @dev adds a reserve to the array of the reserves address
    **/
    function addReserveToListInternal(address _reserve) internal {
        bool reserveAlreadyAdded = false;
        for (uint256 i = 0; i < reservesList.length; i++)
            if (reservesList[i] == _reserve) {
                reserveAlreadyAdded = true;
            }
        if (!reserveAlreadyAdded) reservesList.push(_reserve);
    }

}
".

Existing Test Reports:

"The software run successfully without errors."

Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings.

