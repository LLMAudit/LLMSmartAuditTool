[2024-01-09 05:31:10 INFO] **[Preprocessing]**

**ChatDev Starts** (20240901053110)

**Timestamp**: 20240901053110

**config_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/ChatChainConfig.json

**config_phase_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/PhaseConfig.json

**config_role_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/RoleConfig.json

**task_prompt**: /*
    Copyright 2020 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";
import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";
import { SignedSafeMath } from "@openzeppelin/contracts/math/SignedSafeMath.sol";

import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";
import { IController } from "../../interfaces/IController.sol";
import { INAVIssuanceHook } from "../../interfaces/INAVIssuanceHook.sol";
import { Invoke } from "../lib/Invoke.sol";
import { ISetToken } from "../../interfaces/ISetToken.sol";
import { IWETH } from "../../interfaces/external/IWETH.sol";
import { ModuleBase } from "../lib/ModuleBase.sol";
import { Position } from "../lib/Position.sol";
import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";
import { ResourceIdentifier } from "../lib/ResourceIdentifier.sol";


/**
 * @title NavIssuanceModule
 * @author Set Protocol
 *
 * Module that enables issuance and redemption with any valid ERC20 token or ETH if allowed by the manager. Sender receives
 * a proportional amount of SetTokens on issuance or ERC20 token on redemption based on the calculated net asset value using
 * oracle prices. Manager is able to enforce a premium / discount on issuance / redemption to avoid arbitrage and front
 * running when relying on oracle prices. Managers can charge a fee (denominated in reserve asset).
 */
contract NavIssuanceModule is ModuleBase, ReentrancyGuard {
    using AddressArrayUtils for address[];
    using Invoke for ISetToken;
    using Position for ISetToken;
    using PreciseUnitMath for uint256;
    using PreciseUnitMath for int256;
    using ResourceIdentifier for IController;
    using SafeMath for uint256;
    using SafeCast for int256;
    using SafeCast for uint256;
    using SignedSafeMath for int256;

    /* ============ Events ============ */

    event SetTokenNAVIssued(
        ISetToken indexed _setToken,
        address _issuer,
        address _to,
        address _reserveAsset,
        address _hookContract,
        uint256 _setTokenQuantity,
        uint256 _managerFee,
        uint256 _premium
    );

    event SetTokenNAVRedeemed(
        ISetToken indexed _setToken,
        address _redeemer,
        address _to,
        address _reserveAsset,
        address _hookContract,
        uint256 _setTokenQuantity,
        uint256 _managerFee,
        uint256 _premium
    );

    event ReserveAssetAdded(
        ISetToken indexed _setToken,
        address _newReserveAsset
    );

    event ReserveAssetRemoved(
        ISetToken indexed _setToken,
        address _removedReserveAsset
    );

    event PremiumEdited(
        ISetToken indexed _setToken,
        uint256 _newPremium
    );

    event ManagerFeeEdited(
        ISetToken indexed _setToken,
        uint256 _newManagerFee,
        uint256 _index
    );

    event FeeRecipientEdited(
        ISetToken indexed _setToken,
        address _feeRecipient
    );

    /* ============ Structs ============ */

    struct NAVIssuanceSettings {
        INAVIssuanceHook managerIssuanceHook;      // Issuance hook configurations
        INAVIssuanceHook managerRedemptionHook;    // Redemption hook configurations
        address[] reserveAssets;                       // Allowed reserve assets - Must have a price enabled with the price oracle
        address feeRecipient;                          // Manager fee recipient
        uint256[2] managerFees;                        // Manager fees. 0 index is issue and 1 index is redeem fee (0.01% = 1e14, 1% = 1e16)
        uint256 maxManagerFee;                         // Maximum fee manager is allowed to set for issue and redeem
        uint256 premiumPercentage;                     // Premium percentage (0.01% = 1e14, 1% = 1e16). This premium is a buffer around oracle
                                                       // prices paid by user to the SetToken, which prevents arbitrage and oracle front running
        uint256 maxPremiumPercentage;                  // Maximum premium percentage manager is allowed to set (configured by manager)
        uint256 minSetTokenSupply;                     // Minimum SetToken supply required for issuance and redemption
                                                       // to prevent dramatic inflationary changes to the SetToken's position multiplier
    }

    struct ActionInfo {
        uint256 preFeeReserveQuantity;                 // Reserve value before fees; During issuance, represents raw quantity
                                                       // During redeem, represents post-premium value
        uint256 protocolFees;                          // Total protocol fees (direct + manager revenue share)
        uint256 managerFee;                            // Total manager fee paid in reserve asset
        uint256 netFlowQuantity;                       // When issuing, quantity of reserve asset sent to SetToken
                                                       // When redeeming, quantity of reserve asset sent to redeemer
        uint256 setTokenQuantity;                      // When issuing, quantity of SetTokens minted to mintee
                                                       // When redeeming, quantity of SetToken redeemed
        uint256 previousSetTokenSupply;                // SetToken supply prior to issue/redeem action
        uint256 newSetTokenSupply;                     // SetToken supply after issue/redeem action
        int256 newPositionMultiplier;                  // SetToken position multiplier after issue/redeem
        uint256 newReservePositionUnit;                // SetToken reserve asset position unit after issue/redeem
    }

    /* ============ State Variables ============ */

    // Wrapped ETH address
    IWETH public immutable weth;

    // Mapping of SetToken to NAV issuance settings struct
    mapping(ISetToken => NAVIssuanceSettings) public navIssuanceSettings;

    // Mapping to efficiently check a SetToken's reserve asset validity
    // SetToken => reserveAsset => isReserveAsset
    mapping(ISetToken => mapping(address => bool)) public isReserveAsset;

    /* ============ Constants ============ */

    // 0 index stores the manager fee in managerFees array, percentage charged on issue (denominated in reserve asset)
    uint256 constant internal MANAGER_ISSUE_FEE_INDEX = 0;

    // 1 index stores the manager fee percentage in managerFees array, charged on redeem
    uint256 constant internal MANAGER_REDEEM_FEE_INDEX = 1;

    // 0 index stores the manager revenue share protocol fee % on the controller, charged in the issuance function
    uint256 constant internal PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX = 0;

    // 1 index stores the manager revenue share protocol fee % on the controller, charged in the redeem function
    uint256 constant internal PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX = 1;

    // 2 index stores the direct protocol fee % on the controller, charged in the issuance function
    uint256 constant internal PROTOCOL_ISSUE_DIRECT_FEE_INDEX = 2;

    // 3 index stores the direct protocol fee % on the controller, charged in the redeem function
    uint256 constant internal PROTOCOL_REDEEM_DIRECT_FEE_INDEX = 3;

    /* ============ Constructor ============ */

    /**
     * @param _controller               Address of controller contract
     * @param _weth                     Address of wrapped eth
     */
    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {
        weth = _weth;
    }

    /* ============ External Functions ============ */

    /**
     * Deposits the allowed reserve asset into the SetToken and mints the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _reserveAsset                 Address of the reserve asset to issue with
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance
     * @param _to                           Address to mint SetToken to
     */
    function issue(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity,
        uint256 _minSetTokenReceiveQuantity,
        address _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, _reserveAsset, _reserveAssetQuantity);

        _callPreIssueHooks(_setToken, _reserveAsset, _reserveAssetQuantity, msg.sender, _to);

        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, _reserveAsset, _reserveAssetQuantity);

        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);

        _transferCollateralAndHandleFees(_setToken, IERC20(_reserveAsset), issueInfo);

        _handleIssueStateUpdates(_setToken, _reserveAsset, _to, issueInfo);
    }

    /**
     * Wraps ETH and deposits WETH if allowed into the SetToken and mints the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance
     * @param _to                           Address to mint SetToken to
     */
    function issueWithEther(
        ISetToken _setToken,
        uint256 _minSetTokenReceiveQuantity,
        address _to
    )
        external
        payable
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        weth.deposit{ value: msg.value }();

        _validateCommon(_setToken, address(weth), msg.value);

        _callPreIssueHooks(_setToken, address(weth), msg.value, msg.sender, _to);

        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, address(weth), msg.value);

        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);

        _transferWETHAndHandleFees(_setToken, issueInfo);

        _handleIssueStateUpdates(_setToken, address(weth), _to, issueInfo);
    }

    /**
     * Redeems a SetToken into a valid reserve asset representing the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address. Only valid if there are available reserve units on the SetToken.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _reserveAsset                 Address of the reserve asset to redeem with
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive
     * @param _to                           Address to redeem reserve asset to
     */
    function redeem(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity,
        uint256 _minReserveReceiveQuantity,
        address _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, _reserveAsset, _setTokenQuantity);

        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);

        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, _reserveAsset, _setTokenQuantity);

        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);

        _setToken.burn(msg.sender, _setTokenQuantity);

        // Instruct the SetToken to transfer the reserve asset back to the user
        _setToken.strictInvokeTransfer(
            _reserveAsset,
            _to,
            redeemInfo.netFlowQuantity
        );

        _handleRedemptionFees(_setToken, _reserveAsset, redeemInfo);

        _handleRedeemStateUpdates(_setToken, _reserveAsset, _to, redeemInfo);
    }

    /**
     * Redeems a SetToken into Ether (if WETH is valid) representing the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address. Only valid if there are available WETH units on the SetToken.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive
     * @param _to                           Address to redeem reserve asset to
     */
    function redeemIntoEther(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        uint256 _minReserveReceiveQuantity,
        address payable _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, address(weth), _setTokenQuantity);

        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);

        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, address(weth), _setTokenQuantity);

        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);

        _setToken.burn(msg.sender, _setTokenQuantity);

        // Instruct the SetToken to transfer WETH from SetToken to module
        _setToken.strictInvokeTransfer(
            address(weth),
            address(this),
            redeemInfo.netFlowQuantity
        );

        weth.withdraw(redeemInfo.netFlowQuantity);

        _to.transfer(redeemInfo.netFlowQuantity);

        _handleRedemptionFees(_setToken, address(weth), redeemInfo);

        _handleRedeemStateUpdates(_setToken, address(weth), _to, redeemInfo);
    }

    /**
     * SET MANAGER ONLY. Add an allowed reserve asset
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset to add
     */
    function addReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {
        require(!isReserveAsset[_setToken][_reserveAsset], "Reserve asset already exists");

        navIssuanceSettings[_setToken].reserveAssets.push(_reserveAsset);
        isReserveAsset[_setToken][_reserveAsset] = true;

        emit ReserveAssetAdded(_setToken, _reserveAsset);
    }

    /**
     * SET MANAGER ONLY. Remove a reserve asset
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset to remove
     */
    function removeReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {
        require(isReserveAsset[_setToken][_reserveAsset], "Reserve asset does not exist");

        navIssuanceSettings[_setToken].reserveAssets = navIssuanceSettings[_setToken].reserveAssets.remove(_reserveAsset);
        delete isReserveAsset[_setToken][_reserveAsset];

        emit ReserveAssetRemoved(_setToken, _reserveAsset);
    }

    /**
     * SET MANAGER ONLY. Edit the premium percentage
     *
     * @param _setToken                     Instance of the SetToken
     * @param _premiumPercentage            Premium percentage in 10e16 (e.g. 10e16 = 1%)
     */
    function editPremium(ISetToken _setToken, uint256 _premiumPercentage) external onlyManagerAndValidSet(_setToken) {
        require(_premiumPercentage <= navIssuanceSettings[_setToken].maxPremiumPercentage, "Premium must be less than maximum allowed");

        navIssuanceSettings[_setToken].premiumPercentage = _premiumPercentage;

        emit PremiumEdited(_setToken, _premiumPercentage);
    }

    /**
     * SET MANAGER ONLY. Edit manager fee
     *
     * @param _setToken                     Instance of the SetToken
     * @param _managerFeePercentage         Manager fee percentage in 10e16 (e.g. 10e16 = 1%)
     * @param _managerFeeIndex              Manager fee index. 0 index is issue fee, 1 index is redeem fee
     */
    function editManagerFee(
        ISetToken _setToken,
        uint256 _managerFeePercentage,
        uint256 _managerFeeIndex
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        require(_managerFeePercentage <= navIssuanceSettings[_setToken].maxManagerFee, "Manager fee must be less than maximum allowed");

        navIssuanceSettings[_setToken].managerFees[_managerFeeIndex] = _managerFeePercentage;

        emit ManagerFeeEdited(_setToken, _managerFeePercentage, _managerFeeIndex);
    }

    /**
     * SET MANAGER ONLY. Edit the manager fee recipient
     *
     * @param _setToken                     Instance of the SetToken
     * @param _managerFeeRecipient          Manager fee recipient
     */
    function editFeeRecipient(ISetToken _setToken, address _managerFeeRecipient) external onlyManagerAndValidSet(_setToken) {
        require(_managerFeeRecipient != address(0), "Fee recipient must not be 0 address");

        navIssuanceSettings[_setToken].feeRecipient = _managerFeeRecipient;

        emit FeeRecipientEdited(_setToken, _managerFeeRecipient);
    }

    /**
     * SET MANAGER ONLY. Initializes this module to the SetToken with hooks, allowed reserve assets,
     * fees and issuance premium. Only callable by the SetToken's manager. Hook addresses are optional.
     * Address(0) means that no hook will be called.
     *
     * @param _setToken                     Instance of the SetToken to issue
     * @param _navIssuanceSettings          NAVIssuanceSettings struct defining parameters
     */
    function initialize(
        ISetToken _setToken,
        NAVIssuanceSettings memory _navIssuanceSettings
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        require(_navIssuanceSettings.reserveAssets.length > 0, "Reserve assets must be greater than 0");
        require(_navIssuanceSettings.maxManagerFee < PreciseUnitMath.preciseUnit(), "Max manager fee must be less than 100%");
        require(_navIssuanceSettings.maxPremiumPercentage < PreciseUnitMath.preciseUnit(), "Max premium percentage must be less than 100%");
        require(_navIssuanceSettings.managerFees[0] <= _navIssuanceSettings.maxManagerFee, "Manager issue fee must be less than max");
        require(_navIssuanceSettings.managerFees[1] <= _navIssuanceSettings.maxManagerFee, "Manager redeem fee must be less than max");
        require(_navIssuanceSettings.premiumPercentage <= _navIssuanceSettings.maxPremiumPercentage, "Premium must be less than max");
        require(_navIssuanceSettings.feeRecipient != address(0), "Fee Recipient must be non-zero address.");
        // Initial mint of Set cannot use NAVIssuance since minSetTokenSupply must be > 0
        require(_navIssuanceSettings.minSetTokenSupply > 0, "Min SetToken supply must be greater than 0");

        for (uint256 i = 0; i < _navIssuanceSettings.reserveAssets.length; i++) {
            require(!isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]], "Reserve assets must be unique");
            isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]] = true;
        }

        navIssuanceSettings[_setToken] = _navIssuanceSettings;

        _setToken.initializeModule();
    }

    /**
     * Removes this module from the SetToken, via call by the SetToken. Issuance settings and
     * reserve asset states are deleted.
     */
    function removeModule() external override {
        ISetToken setToken = ISetToken(msg.sender);
        for (uint256 i = 0; i < navIssuanceSettings[setToken].reserveAssets.length; i++) {
            delete isReserveAsset[setToken][navIssuanceSettings[setToken].reserveAssets[i]];
        }

        delete navIssuanceSettings[setToken];
    }

    receive() external payable {}

    /* ============ External Getter Functions ============ */

    function getReserveAssets(ISetToken _setToken) external view returns (address[] memory) {
        return navIssuanceSettings[_setToken].reserveAssets;
    }

    function getIssuePremium(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (uint256)
    {
        return _getIssuePremium(_setToken, _reserveAsset, _reserveAssetQuantity);
    }

    function getRedeemPremium(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (uint256)
    {
        return _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);
    }

    function getManagerFee(ISetToken _setToken, uint256 _managerFeeIndex) external view returns (uint256) {
        return navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];
    }

    /**
     * Get the expected SetTokens minted to recipient on issuance
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     *
     * @return  uint256                     Expected SetTokens to be minted to recipient
     */
    function getExpectedSetTokenIssueQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (uint256)
    {
        (,, uint256 netReserveFlow) = _getFees(
            _setToken,
            _reserveAssetQuantity,
            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,
            MANAGER_ISSUE_FEE_INDEX
        );

        uint256 setTotalSupply = _setToken.totalSupply();

        return _getSetTokenMintQuantity(
            _setToken,
            _reserveAsset,
            netReserveFlow,
            setTotalSupply
        );
    }

    /**
     * Get the expected reserve asset to be redeemed
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     *
     * @return  uint256                     Expected reserve asset quantity redeemed
     */
    function getExpectedReserveRedeemQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (uint256)
    {
        uint256 preFeeReserveQuantity = _getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

        (,, uint256 netReserveFlows) = _getFees(
            _setToken,
            preFeeReserveQuantity,
            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
            MANAGER_REDEEM_FEE_INDEX
        );

        return netReserveFlows;
    }

    /**
     * Checks if issue is valid
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     *
     * @return  bool                        Returns true if issue is valid
     */
    function isIssueValid(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (bool)
    {
        uint256 setTotalSupply = _setToken.totalSupply();

    return _reserveAssetQuantity != 0
            && isReserveAsset[_setToken][_reserveAsset]
            && setTotalSupply >= navIssuanceSettings[_setToken].minSetTokenSupply;
    }

    /**
     * Checks if redeem is valid
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     *
     * @return  bool                        Returns true if redeem is valid
     */
    function isRedeemValid(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (bool)
    {
        uint256 setTotalSupply = _setToken.totalSupply();

        if (
            _setTokenQuantity == 0
            || !isReserveAsset[_setToken][_reserveAsset]
            || setTotalSupply < navIssuanceSettings[_setToken].minSetTokenSupply.add(_setTokenQuantity)
        ) {
            return false;
        } else {
            uint256 totalRedeemValue =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

            (,, uint256 expectedRedeemQuantity) = _getFees(
                _setToken,
                totalRedeemValue,
                PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
                PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
                MANAGER_REDEEM_FEE_INDEX
            );

            uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();

            return existingUnit.preciseMul(setTotalSupply) >= expectedRedeemQuantity;
        }
    }

    /* ============ Internal Functions ============ */

    function _validateCommon(ISetToken _setToken, address _reserveAsset, uint256 _quantity) internal view {
        require(_quantity > 0, "Quantity must be > 0");
        require(isReserveAsset[_setToken][_reserveAsset], "Must be valid reserve asset");
    }

    function _validateIssuanceInfo(ISetToken _setToken, uint256 _minSetTokenReceiveQuantity, ActionInfo memory _issueInfo) internal view {
        // Check that total supply is greater than min supply needed for issuance
        // Note: A min supply amount is needed to avoid division by 0 when SetToken supply is 0
        require(
            _issueInfo.previousSetTokenSupply >= navIssuanceSettings[_setToken].minSetTokenSupply,
            "Supply must be greater than minimum to enable issuance"
        );

        require(_issueInfo.setTokenQuantity >= _minSetTokenReceiveQuantity, "Must be greater than min SetToken");
    }

    function _validateRedemptionInfo(
        ISetToken _setToken,
        uint256 _minReserveReceiveQuantity,
        ActionInfo memory _redeemInfo
    )
        internal
        view
    {
        // Check that new supply is more than min supply needed for redemption
        // Note: A min supply amount is needed to avoid division by 0 when redeeming SetToken to 0
        require(
            _redeemInfo.newSetTokenSupply >= navIssuanceSettings[_setToken].minSetTokenSupply,
            "Supply must be greater than minimum to enable redemption"
        );

        require(_redeemInfo.netFlowQuantity >= _minReserveReceiveQuantity, "Must be greater than min receive reserve quantity");
    }

    function _createIssuanceInfo(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        internal
        view
        returns (ActionInfo memory)
    {
        ActionInfo memory issueInfo;

        issueInfo.previousSetTokenSupply = _setToken.totalSupply();

        issueInfo.preFeeReserveQuantity = _reserveAssetQuantity;

        (issueInfo.protocolFees, issueInfo.managerFee, issueInfo.netFlowQuantity) = _getFees(
            _setToken,
            issueInfo.preFeeReserveQuantity,
            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,
            MANAGER_ISSUE_FEE_INDEX
        );

        issueInfo.setTokenQuantity = _getSetTokenMintQuantity(
            _setToken,
            _reserveAsset,
            issueInfo.netFlowQuantity,
            issueInfo.previousSetTokenSupply
        );

        (issueInfo.newSetTokenSupply, issueInfo.newPositionMultiplier) = _getIssuePositionMultiplier(_setToken, issueInfo);

        issueInfo.newReservePositionUnit = _getIssuePositionUnit(_setToken, _reserveAsset, issueInfo);

        return issueInfo;
    }

    function _createRedemptionInfo(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        internal
        view
        returns (ActionInfo memory)
    {
        ActionInfo memory redeemInfo;

        redeemInfo.setTokenQuantity = _setTokenQuantity;

        redeemInfo.preFeeReserveQuantity =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

        (redeemInfo.protocolFees, redeemInfo.managerFee, redeemInfo.netFlowQuantity) = _getFees(
            _setToken,
            redeemInfo.preFeeReserveQuantity,
            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
            MANAGER_REDEEM_FEE_INDEX
        );

        redeemInfo.previousSetTokenSupply = _setToken.totalSupply();

        (redeemInfo.newSetTokenSupply, redeemInfo.newPositionMultiplier) = _getRedeemPositionMultiplier(_setToken, _setTokenQuantity, redeemInfo);

        redeemInfo.newReservePositionUnit = _getRedeemPositionUnit(_setToken, _reserveAsset, redeemInfo);

        return redeemInfo;
    }

    /**
     * Transfer reserve asset from user to SetToken and fees from user to appropriate fee recipients
     */
    function _transferCollateralAndHandleFees(ISetToken _setToken, IERC20 _reserveAsset, ActionInfo memory _issueInfo) internal {
        transferFrom(_reserveAsset, msg.sender, address(_setToken), _issueInfo.netFlowQuantity);

        if (_issueInfo.protocolFees > 0) {
            transferFrom(_reserveAsset, msg.sender, controller.feeRecipient(), _issueInfo.protocolFees);
        }

        if (_issueInfo.managerFee > 0) {
            transferFrom(_reserveAsset, msg.sender, navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);
        }
    }


    /**
      * Transfer WETH from module to SetToken and fees from module to appropriate fee recipients
     */
    function _transferWETHAndHandleFees(ISetToken _setToken, ActionInfo memory _issueInfo) internal {
        weth.transfer(address(_setToken), _issueInfo.netFlowQuantity);

        if (_issueInfo.protocolFees > 0) {
            weth.transfer(controller.feeRecipient(), _issueInfo.protocolFees);
        }

        if (_issueInfo.managerFee > 0) {
            weth.transfer(navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);
        }
    }

    function _handleIssueStateUpdates(
        ISetToken _setToken,
        address _reserveAsset,
        address _to,
        ActionInfo memory _issueInfo
    )
        internal
    {
        _setToken.editPositionMultiplier(_issueInfo.newPositionMultiplier);

        _setToken.editDefaultPosition(_reserveAsset, _issueInfo.newReservePositionUnit);

        _setToken.mint(_to, _issueInfo.setTokenQuantity);

        emit SetTokenNAVIssued(
            _setToken,
            msg.sender,
            _to,
            _reserveAsset,
            address(navIssuanceSettings[_setToken].managerIssuanceHook),
            _issueInfo.setTokenQuantity,
            _issueInfo.managerFee,
            _issueInfo.protocolFees
        );
    }

    function _handleRedeemStateUpdates(
        ISetToken _setToken,
        address _reserveAsset,
        address _to,
        ActionInfo memory _redeemInfo
    )
        internal
    {
        _setToken.editPositionMultiplier(_redeemInfo.newPositionMultiplier);

        _setToken.editDefaultPosition(_reserveAsset, _redeemInfo.newReservePositionUnit);

        emit SetTokenNAVRedeemed(
            _setToken,
            msg.sender,
            _to,
            _reserveAsset,
            address(navIssuanceSettings[_setToken].managerRedemptionHook),
            _redeemInfo.setTokenQuantity,
            _redeemInfo.managerFee,
            _redeemInfo.protocolFees
        );
    }

    function _handleRedemptionFees(ISetToken _setToken, address _reserveAsset, ActionInfo memory _redeemInfo) internal {
        // Instruct the SetToken to transfer protocol fee to fee recipient if there is a fee
        payProtocolFeeFromSetToken(_setToken, _reserveAsset, _redeemInfo.protocolFees);

        // Instruct the SetToken to transfer manager fee to manager fee recipient if there is a fee
        if (_redeemInfo.managerFee > 0) {
            _setToken.strictInvokeTransfer(
                _reserveAsset,
                navIssuanceSettings[_setToken].feeRecipient,
                _redeemInfo.managerFee
            );
        }
    }

    /**
     * Returns the issue premium percentage. Virtual function that can be overridden in future versions of the module
     * and can contain arbitrary logic to calculate the issuance premium.
     */
    function _getIssuePremium(
        ISetToken _setToken,
        address /* _reserveAsset */,
        uint256 /* _reserveAssetQuantity */
    )
        virtual
        internal
        view
        returns (uint256)
    {
        return navIssuanceSettings[_setToken].premiumPercentage;
    }

    /**
     * Returns the redeem premium percentage. Virtual function that can be overridden in future versions of the module
     * and can contain arbitrary logic to calculate the redemption premium.
     */
    function _getRedeemPremium(
        ISetToken _setToken,
        address /* _reserveAsset */,
        uint256 /* _setTokenQuantity */
    )
        virtual
        internal
        view
        returns (uint256)
    {
        return navIssuanceSettings[_setToken].premiumPercentage;
    }

    /**
     * Returns the fees attributed to the manager and the protocol. The fees are calculated as follows:
     *
     * ManagerFee = (manager fee % - % to protocol) * reserveAssetQuantity
     * Protocol Fee = (% manager fee share + direct fee %) * reserveAssetQuantity
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAssetQuantity         Quantity of reserve asset to calculate fees from
     * @param _protocolManagerFeeIndex      Index to pull rev share NAV Issuance fee from the Controller
     * @param _protocolDirectFeeIndex       Index to pull direct NAV issuance fee from the Controller
     * @param _managerFeeIndex              Index from NAVIssuanceSettings (0 = issue fee, 1 = redeem fee)
     *
     * @return  uint256                     Fees paid to the protocol in reserve asset
     * @return  uint256                     Fees paid to the manager in reserve asset
     * @return  uint256                     Net reserve to user net of fees
     */
    function _getFees(
        ISetToken _setToken,
        uint256 _reserveAssetQuantity,
        uint256 _protocolManagerFeeIndex,
        uint256 _protocolDirectFeeIndex,
        uint256 _managerFeeIndex
    )
        internal
        view
        returns (uint256, uint256, uint256)
    {
        (uint256 protocolFeePercentage, uint256 managerFeePercentage) = _getProtocolAndManagerFeePercentages(
            _setToken,
            _protocolManagerFeeIndex,
            _protocolDirectFeeIndex,
            _managerFeeIndex
        );

        // Calculate total notional fees
        uint256 protocolFees = protocolFeePercentage.preciseMul(_reserveAssetQuantity);
        uint256 managerFee = managerFeePercentage.preciseMul(_reserveAssetQuantity);

        uint256 netReserveFlow = _reserveAssetQuantity.sub(protocolFees).sub(managerFee);

        return (protocolFees, managerFee, netReserveFlow);
    }

    function _getProtocolAndManagerFeePercentages(
        ISetToken _setToken,
        uint256 _protocolManagerFeeIndex,
        uint256 _protocolDirectFeeIndex,
        uint256 _managerFeeIndex
    )
        internal
        view
        returns(uint256, uint256)
    {
        // Get protocol fee percentages
        uint256 protocolDirectFeePercent = controller.getModuleFee(address(this), _protocolDirectFeeIndex);
        uint256 protocolManagerShareFeePercent = controller.getModuleFee(address(this), _protocolManagerFeeIndex);
        uint256 managerFeePercent = navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];

        // Calculate revenue share split percentage
        uint256 protocolRevenueSharePercentage = protocolManagerShareFeePercent.preciseMul(managerFeePercent);
        uint256 managerRevenueSharePercentage = managerFeePercent.sub(protocolRevenueSharePercentage);
        uint256 totalProtocolFeePercentage = protocolRevenueSharePercentage.add(protocolDirectFeePercent);

        return (totalProtocolFeePercentage, managerRevenueSharePercentage);
    }

    function _getSetTokenMintQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _netReserveFlows,            // Value of reserve asset net of fees
        uint256 _setTotalSupply
    )
        internal
        view
        returns (uint256)
    {
        uint256 premiumPercentage = _getIssuePremium(_setToken, _reserveAsset, _netReserveFlows);
        uint256 premiumValue = _netReserveFlows.preciseMul(premiumPercentage);

        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (1e18)
        // Reverts if price is not found
        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);

        // Get reserve asset decimals
        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();
        uint256 normalizedTotalReserveQuantityNetFees = _netReserveFlows.preciseDiv(10 ** reserveAssetDecimals);
        uint256 normalizedTotalReserveQuantityNetFeesAndPremium = _netReserveFlows.sub(premiumValue).preciseDiv(10 ** reserveAssetDecimals);

        // Calculate SetTokens to mint to issuer
        uint256 denominator = _setTotalSupply.preciseMul(setTokenValuation).add(normalizedTotalReserveQuantityNetFees).sub(normalizedTotalReserveQuantityNetFeesAndPremium);
        return normalizedTotalReserveQuantityNetFeesAndPremium.preciseMul(_setTotalSupply).preciseDiv(denominator);
    }

    function _getRedeemReserveQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        internal
        view
        returns (uint256)
    {
        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (10e18)
        // Reverts if price is not found
        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);

        uint256 totalRedeemValueInPreciseUnits = _setTokenQuantity.preciseMul(setTokenValuation);
        // Get reserve asset decimals
        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();
        uint256 prePremiumReserveQuantity = totalRedeemValueInPreciseUnits.preciseMul(10 ** reserveAssetDecimals);

        uint256 premiumPercentage = _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);
        uint256 premiumQuantity = prePremiumReserveQuantity.preciseMulCeil(premiumPercentage);

        return prePremiumReserveQuantity.sub(premiumQuantity);
    }

    /**
     * The new position multiplier is calculated as follows:
     * inflationPercentage = (newSupply - oldSupply) / newSupply
     * newMultiplier = (1 - inflationPercentage) * positionMultiplier
     */
    function _getIssuePositionMultiplier(
        ISetToken _setToken,
        ActionInfo memory _issueInfo
    )
        internal
        view
        returns (uint256, int256)
    {
        // Calculate inflation and new position multiplier. Note: Round inflation up in order to round position multiplier down
        uint256 newTotalSupply = _issueInfo.setTokenQuantity.add(_issueInfo.previousSetTokenSupply);
        int256 newPositionMultiplier = _setToken.positionMultiplier()
            .mul(_issueInfo.previousSetTokenSupply.toInt256())
            .div(newTotalSupply.toInt256());

        return (newTotalSupply, newPositionMultiplier);
    }

    /**
     * Calculate deflation and new position multiplier. Note: Round deflation down in order to round position multiplier down
     *
     * The new position multiplier is calculated as follows:
     * deflationPercentage = (oldSupply - newSupply) / newSupply
     * newMultiplier = (1 + deflationPercentage) * positionMultiplier
     */
    function _getRedeemPositionMultiplier(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        ActionInfo memory _redeemInfo
    )
        internal
        view
        returns (uint256, int256)
    {
        uint256 newTotalSupply = _redeemInfo.previousSetTokenSupply.sub(_setTokenQuantity);
        int256 newPositionMultiplier = _setToken.positionMultiplier()
            .mul(_redeemInfo.previousSetTokenSupply.toInt256())
            .div(newTotalSupply.toInt256());

        return (newTotalSupply, newPositionMultiplier);
    }

    /**
     * The new position reserve asset unit is calculated as follows:
     * totalReserve = (oldUnit * oldSetTokenSupply) + reserveQuantity
     * newUnit = totalReserve / newSetTokenSupply
     */
    function _getIssuePositionUnit(
        ISetToken _setToken,
        address _reserveAsset,
        ActionInfo memory _issueInfo
    )
        internal
        view
        returns (uint256)
    {
        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();
        uint256 totalReserve = existingUnit
            .preciseMul(_issueInfo.previousSetTokenSupply)
            .add(_issueInfo.netFlowQuantity);

        return totalReserve.preciseDiv(_issueInfo.newSetTokenSupply);
    }

    /**
     * The new position reserve asset unit is calculated as follows:
     * totalReserve = (oldUnit * oldSetTokenSupply) - reserveQuantityToSendOut
     * newUnit = totalReserve / newSetTokenSupply
     */
    function _getRedeemPositionUnit(
        ISetToken _setToken,
        address _reserveAsset,
        ActionInfo memory _redeemInfo
    )
        internal
        view
        returns (uint256)
    {
        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();
        uint256 totalExistingUnits = existingUnit.preciseMul(_redeemInfo.previousSetTokenSupply);

        uint256 outflow = _redeemInfo.netFlowQuantity.add(_redeemInfo.protocolFees).add(_redeemInfo.managerFee);

        // Require withdrawable quantity is greater than existing collateral
        require(totalExistingUnits >= outflow, "Must be greater than total available collateral");

        return totalExistingUnits.sub(outflow).preciseDiv(_redeemInfo.newSetTokenSupply);
    }

    /**
     * If a pre-issue hook has been configured, call the external-protocol contract. Pre-issue hook logic
     * can contain arbitrary logic including validations, external function calls, etc.
     */
    function _callPreIssueHooks(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity,
        address _caller,
        address _to
    )
        internal
    {
        INAVIssuanceHook preIssueHook = navIssuanceSettings[_setToken].managerIssuanceHook;
        if (address(preIssueHook) != address(0)) {
            preIssueHook.invokePreIssueHook(_setToken, _reserveAsset, _reserveAssetQuantity, _caller, _to);
        }
    }

    /**
     * If a pre-redeem hook has been configured, call the external-protocol contract.
     */
    function _callPreRedeemHooks(ISetToken _setToken, uint256 _setQuantity, address _caller, address _to) internal {
        INAVIssuanceHook preRedeemHook = navIssuanceSettings[_setToken].managerRedemptionHook;
        if (address(preRedeemHook) != address(0)) {
            preRedeemHook.invokePreRedeemHook(_setToken, _setQuantity, _caller, _to);
        }
    }
}

**project_name**: RealWorld_BA_124_NAVIssuanceModule

**Log File**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/WareHouse/RealWorld_BA_124_NAVIssuanceModule_RealWord_20240901053110.log

**ChatDevConfig**:
ChatEnvConfig.with_memory: False
ChatEnvConfig.clear_structure: True
ChatEnvConfig.git_management: False
ChatEnvConfig.gui_design: True
ChatEnvConfig.incremental_develop: False
ChatEnvConfig.background_prompt: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.


**ChatGPTConfig**:
ChatGPTConfig(temperature=0.2, top_p=1.0, n=1, stream=False, stop=None, max_tokens=None, presence_penalty=0.0, frequency_penalty=0.0, logit_bias={}, user='')



[2024-01-09 05:31:11 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /*     Copyright 2020 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol"; import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol"; import { SignedSafeMath } from "@openzeppelin/contracts/math/SignedSafeMath.sol"; import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol"; import { IController } from "../../interfaces/IController.sol"; import { INAVIssuanceHook } from "../../interfaces/INAVIssuanceHook.sol"; import { Invoke } from "../lib/Invoke.sol"; import { ISetToken } from "../../interfaces/ISetToken.sol"; import { IWETH } from "../../interfaces/external/IWETH.sol"; import { ModuleBase } from "../lib/ModuleBase.sol"; import { Position } from "../lib/Position.sol"; import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol"; import { ResourceIdentifier } from "../lib/ResourceIdentifier.sol"; /*  * @title NavIssuanceModule  * @author Set Protocol  *  * Module that enables issuance and redemption with any valid ERC20 token or ETH if allowed by the manager. Sender receives  * a proportional amount of SetTokens on issuance or ERC20 token on redemption based on the calculated net asset value using  * oracle prices. Manager is able to enforce a premium / discount on issuance / redemption to avoid arbitrage and front  * running when relying on oracle prices. Managers can charge a fee (denominated in reserve asset).  / contract NavIssuanceModule is ModuleBase, ReentrancyGuard {     using AddressArrayUtils for address[];     using Invoke for ISetToken;     using Position for ISetToken;     using PreciseUnitMath for uint256;     using PreciseUnitMath for int256;     using ResourceIdentifier for IController;     using SafeMath for uint256;     using SafeCast for int256;     using SafeCast for uint256;     using SignedSafeMath for int256; /* ============ Events ============ */  event SetTokenNAVIssued(     ISetToken indexed _setToken,     address _issuer,     address _to,     address _reserveAsset,     address _hookContract,     uint256 _setTokenQuantity,     uint256 _managerFee,     uint256 _premium );  event SetTokenNAVRedeemed(     ISetToken indexed _setToken,     address _redeemer,     address _to,     address _reserveAsset,     address _hookContract,     uint256 _setTokenQuantity,     uint256 _managerFee,     uint256 _premium );  event ReserveAssetAdded(     ISetToken indexed _setToken,     address _newReserveAsset );  event ReserveAssetRemoved(     ISetToken indexed _setToken,     address _removedReserveAsset );  event PremiumEdited(     ISetToken indexed _setToken,     uint256 _newPremium );  event ManagerFeeEdited(     ISetToken indexed _setToken,     uint256 _newManagerFee,     uint256 _index );  event FeeRecipientEdited(     ISetToken indexed _setToken,     address _feeRecipient );  /* ============ Structs ============ */  struct NAVIssuanceSettings {     INAVIssuanceHook managerIssuanceHook;      // Issuance hook configurations     INAVIssuanceHook managerRedemptionHook;    // Redemption hook configurations     address[] reserveAssets;                       // Allowed reserve assets - Must have a price enabled with the price oracle     address feeRecipient;                          // Manager fee recipient     uint256[2] managerFees;                        // Manager fees. 0 index is issue and 1 index is redeem fee (0.01% = 1e14, 1% = 1e16)     uint256 maxManagerFee;                         // Maximum fee manager is allowed to set for issue and redeem     uint256 premiumPercentage;                     // Premium percentage (0.01% = 1e14, 1% = 1e16). This premium is a buffer around oracle                                                    // prices paid by user to the SetToken, which prevents arbitrage and oracle front running     uint256 maxPremiumPercentage;                  // Maximum premium percentage manager is allowed to set (configured by manager)     uint256 minSetTokenSupply;                     // Minimum SetToken supply required for issuance and redemption                                                    // to prevent dramatic inflationary changes to the SetToken's position multiplier }  struct ActionInfo {     uint256 preFeeReserveQuantity;                 // Reserve value before fees; During issuance, represents raw quantity                                                    // During redeem, represents post-premium value     uint256 protocolFees;                          // Total protocol fees (direct + manager revenue share)     uint256 managerFee;                            // Total manager fee paid in reserve asset     uint256 netFlowQuantity;                       // When issuing, quantity of reserve asset sent to SetToken                                                    // When redeeming, quantity of reserve asset sent to redeemer     uint256 setTokenQuantity;                      // When issuing, quantity of SetTokens minted to mintee                                                    // When redeeming, quantity of SetToken redeemed     uint256 previousSetTokenSupply;                // SetToken supply prior to issue/redeem action     uint256 newSetTokenSupply;                     // SetToken supply after issue/redeem action     int256 newPositionMultiplier;                  // SetToken position multiplier after issue/redeem     uint256 newReservePositionUnit;                // SetToken reserve asset position unit after issue/redeem }  /* ============ State Variables ============ */  // Wrapped ETH address IWETH public immutable weth;  // Mapping of SetToken to NAV issuance settings struct mapping(ISetToken =&gt; NAVIssuanceSettings) public navIssuanceSettings;  // Mapping to efficiently check a SetToken's reserve asset validity // SetToken =&gt; reserveAsset =&gt; isReserveAsset mapping(ISetToken =&gt; mapping(address =&gt; bool)) public isReserveAsset;  /* ============ Constants ============ */  // 0 index stores the manager fee in managerFees array, percentage charged on issue (denominated in reserve asset) uint256 constant internal MANAGER_ISSUE_FEE_INDEX = 0;  // 1 index stores the manager fee percentage in managerFees array, charged on redeem uint256 constant internal MANAGER_REDEEM_FEE_INDEX = 1;  // 0 index stores the manager revenue share protocol fee % on the controller, charged in the issuance function uint256 constant internal PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX = 0;  // 1 index stores the manager revenue share protocol fee % on the controller, charged in the redeem function uint256 constant internal PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX = 1;  // 2 index stores the direct protocol fee % on the controller, charged in the issuance function uint256 constant internal PROTOCOL_ISSUE_DIRECT_FEE_INDEX = 2;  // 3 index stores the direct protocol fee % on the controller, charged in the redeem function uint256 constant internal PROTOCOL_REDEEM_DIRECT_FEE_INDEX = 3;  /* ============ Constructor ============ */  /**  * @param _controller               Address of controller contract  * @param _weth                     Address of wrapped eth  */ constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {     weth = _weth; }  /* ============ External Functions ============ */  /**  * Deposits the allowed reserve asset into the SetToken and mints the appropriate % of Net Asset Value of the SetToken  * to the specified _to address.  *  * @param _setToken                     Instance of the SetToken contract  * @param _reserveAsset                 Address of the reserve asset to issue with  * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with  * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance  * @param _to                           Address to mint SetToken to  */ function issue(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity,     uint256 _minSetTokenReceiveQuantity,     address _to )     external     nonReentrant     onlyValidAndInitializedSet(_setToken) {     _validateCommon(_setToken, _reserveAsset, _reserveAssetQuantity);      _callPreIssueHooks(_setToken, _reserveAsset, _reserveAssetQuantity, msg.sender, _to);      ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, _reserveAsset, _reserveAssetQuantity);      _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);      _transferCollateralAndHandleFees(_setToken, IERC20(_reserveAsset), issueInfo);      _handleIssueStateUpdates(_setToken, _reserveAsset, _to, issueInfo); }  /**  * Wraps ETH and deposits WETH if allowed into the SetToken and mints the appropriate % of Net Asset Value of the SetToken  * to the specified _to address.  *  * @param _setToken                     Instance of the SetToken contract  * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance  * @param _to                           Address to mint SetToken to  */ function issueWithEther(     ISetToken _setToken,     uint256 _minSetTokenReceiveQuantity,     address _to )     external     payable     nonReentrant     onlyValidAndInitializedSet(_setToken) {     weth.deposit{ value: msg.value }();      _validateCommon(_setToken, address(weth), msg.value);      _callPreIssueHooks(_setToken, address(weth), msg.value, msg.sender, _to);      ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, address(weth), msg.value);      _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);      _transferWETHAndHandleFees(_setToken, issueInfo);      _handleIssueStateUpdates(_setToken, address(weth), _to, issueInfo); }  /**  * Redeems a SetToken into a valid reserve asset representing the appropriate % of Net Asset Value of the SetToken  * to the specified _to address. Only valid if there are available reserve units on the SetToken.  *  * @param _setToken                     Instance of the SetToken contract  * @param _reserveAsset                 Address of the reserve asset to redeem with  * @param _setTokenQuantity             Quantity of SetTokens to redeem  * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive  * @param _to                           Address to redeem reserve asset to  */ function redeem(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity,     uint256 _minReserveReceiveQuantity,     address _to )     external     nonReentrant     onlyValidAndInitializedSet(_setToken) {     _validateCommon(_setToken, _reserveAsset, _setTokenQuantity);      _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);      ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, _reserveAsset, _setTokenQuantity);      _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);      _setToken.burn(msg.sender, _setTokenQuantity);      // Instruct the SetToken to transfer the reserve asset back to the user     _setToken.strictInvokeTransfer(         _reserveAsset,         _to,         redeemInfo.netFlowQuantity     );      _handleRedemptionFees(_setToken, _reserveAsset, redeemInfo);      _handleRedeemStateUpdates(_setToken, _reserveAsset, _to, redeemInfo); }  /**  * Redeems a SetToken into Ether (if WETH is valid) representing the appropriate % of Net Asset Value of the SetToken  * to the specified _to address. Only valid if there are available WETH units on the SetToken.  *  * @param _setToken                     Instance of the SetToken contract  * @param _setTokenQuantity             Quantity of SetTokens to redeem  * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive  * @param _to                           Address to redeem reserve asset to  */ function redeemIntoEther(     ISetToken _setToken,     uint256 _setTokenQuantity,     uint256 _minReserveReceiveQuantity,     address payable _to )     external     nonReentrant     onlyValidAndInitializedSet(_setToken) {     _validateCommon(_setToken, address(weth), _setTokenQuantity);      _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);      ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, address(weth), _setTokenQuantity);      _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);      _setToken.burn(msg.sender, _setTokenQuantity);      // Instruct the SetToken to transfer WETH from SetToken to module     _setToken.strictInvokeTransfer(         address(weth),         address(this),         redeemInfo.netFlowQuantity     );      weth.withdraw(redeemInfo.netFlowQuantity);      _to.transfer(redeemInfo.netFlowQuantity);      _handleRedemptionFees(_setToken, address(weth), redeemInfo);      _handleRedeemStateUpdates(_setToken, address(weth), _to, redeemInfo); }  /**  * SET MANAGER ONLY. Add an allowed reserve asset  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset to add  */ function addReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {     require(!isReserveAsset[_setToken][_reserveAsset], "Reserve asset already exists");      navIssuanceSettings[_setToken].reserveAssets.push(_reserveAsset);     isReserveAsset[_setToken][_reserveAsset] = true;      emit ReserveAssetAdded(_setToken, _reserveAsset); }  /**  * SET MANAGER ONLY. Remove a reserve asset  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset to remove  */ function removeReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {     require(isReserveAsset[_setToken][_reserveAsset], "Reserve asset does not exist");      navIssuanceSettings[_setToken].reserveAssets = navIssuanceSettings[_setToken].reserveAssets.remove(_reserveAsset);     delete isReserveAsset[_setToken][_reserveAsset];      emit ReserveAssetRemoved(_setToken, _reserveAsset); }  /**  * SET MANAGER ONLY. Edit the premium percentage  *  * @param _setToken                     Instance of the SetToken  * @param _premiumPercentage            Premium percentage in 10e16 (e.g. 10e16 = 1%)  */ function editPremium(ISetToken _setToken, uint256 _premiumPercentage) external onlyManagerAndValidSet(_setToken) {     require(_premiumPercentage &lt;= navIssuanceSettings[_setToken].maxPremiumPercentage, "Premium must be less than maximum allowed");      navIssuanceSettings[_setToken].premiumPercentage = _premiumPercentage;      emit PremiumEdited(_setToken, _premiumPercentage); }  /**  * SET MANAGER ONLY. Edit manager fee  *  * @param _setToken                     Instance of the SetToken  * @param _managerFeePercentage         Manager fee percentage in 10e16 (e.g. 10e16 = 1%)  * @param _managerFeeIndex              Manager fee index. 0 index is issue fee, 1 index is redeem fee  */ function editManagerFee(     ISetToken _setToken,     uint256 _managerFeePercentage,     uint256 _managerFeeIndex )     external     onlyManagerAndValidSet(_setToken) {     require(_managerFeePercentage &lt;= navIssuanceSettings[_setToken].maxManagerFee, "Manager fee must be less than maximum allowed");      navIssuanceSettings[_setToken].managerFees[_managerFeeIndex] = _managerFeePercentage;      emit ManagerFeeEdited(_setToken, _managerFeePercentage, _managerFeeIndex); }  /**  * SET MANAGER ONLY. Edit the manager fee recipient  *  * @param _setToken                     Instance of the SetToken  * @param _managerFeeRecipient          Manager fee recipient  */ function editFeeRecipient(ISetToken _setToken, address _managerFeeRecipient) external onlyManagerAndValidSet(_setToken) {     require(_managerFeeRecipient != address(0), "Fee recipient must not be 0 address");      navIssuanceSettings[_setToken].feeRecipient = _managerFeeRecipient;      emit FeeRecipientEdited(_setToken, _managerFeeRecipient); }  /**  * SET MANAGER ONLY. Initializes this module to the SetToken with hooks, allowed reserve assets,  * fees and issuance premium. Only callable by the SetToken's manager. Hook addresses are optional.  * Address(0) means that no hook will be called.  *  * @param _setToken                     Instance of the SetToken to issue  * @param _navIssuanceSettings          NAVIssuanceSettings struct defining parameters  */ function initialize(     ISetToken _setToken,     NAVIssuanceSettings memory _navIssuanceSettings )     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     require(_navIssuanceSettings.reserveAssets.length &gt; 0, "Reserve assets must be greater than 0");     require(_navIssuanceSettings.maxManagerFee &lt; PreciseUnitMath.preciseUnit(), "Max manager fee must be less than 100%");     require(_navIssuanceSettings.maxPremiumPercentage &lt; PreciseUnitMath.preciseUnit(), "Max premium percentage must be less than 100%");     require(_navIssuanceSettings.managerFees[0] &lt;= _navIssuanceSettings.maxManagerFee, "Manager issue fee must be less than max");     require(_navIssuanceSettings.managerFees[1] &lt;= _navIssuanceSettings.maxManagerFee, "Manager redeem fee must be less than max");     require(_navIssuanceSettings.premiumPercentage &lt;= _navIssuanceSettings.maxPremiumPercentage, "Premium must be less than max");     require(_navIssuanceSettings.feeRecipient != address(0), "Fee Recipient must be non-zero address.");     // Initial mint of Set cannot use NAVIssuance since minSetTokenSupply must be &gt; 0     require(_navIssuanceSettings.minSetTokenSupply &gt; 0, "Min SetToken supply must be greater than 0");      for (uint256 i = 0; i &lt; _navIssuanceSettings.reserveAssets.length; i++) {         require(!isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]], "Reserve assets must be unique");         isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]] = true;     }      navIssuanceSettings[_setToken] = _navIssuanceSettings;      _setToken.initializeModule(); }  /**  * Removes this module from the SetToken, via call by the SetToken. Issuance settings and  * reserve asset states are deleted.  */ function removeModule() external override {     ISetToken setToken = ISetToken(msg.sender);     for (uint256 i = 0; i &lt; navIssuanceSettings[setToken].reserveAssets.length; i++) {         delete isReserveAsset[setToken][navIssuanceSettings[setToken].reserveAssets[i]];     }      delete navIssuanceSettings[setToken]; }  receive() external payable {}  /* ============ External Getter Functions ============ */  function getReserveAssets(ISetToken _setToken) external view returns (address[] memory) {     return navIssuanceSettings[_setToken].reserveAssets; }  function getIssuePremium(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     external     view     returns (uint256) {     return _getIssuePremium(_setToken, _reserveAsset, _reserveAssetQuantity); }  function getRedeemPremium(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     external     view     returns (uint256) {     return _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity); }  function getManagerFee(ISetToken _setToken, uint256 _managerFeeIndex) external view returns (uint256) {     return navIssuanceSettings[_setToken].managerFees[_managerFeeIndex]; }  /**  * Get the expected SetTokens minted to recipient on issuance  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with  *  * @return  uint256                     Expected SetTokens to be minted to recipient  */ function getExpectedSetTokenIssueQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     external     view     returns (uint256) {     (,, uint256 netReserveFlow) = _getFees(         _setToken,         _reserveAssetQuantity,         PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_ISSUE_DIRECT_FEE_INDEX,         MANAGER_ISSUE_FEE_INDEX     );      uint256 setTotalSupply = _setToken.totalSupply();      return _getSetTokenMintQuantity(         _setToken,         _reserveAsset,         netReserveFlow,         setTotalSupply     ); }  /**  * Get the expected reserve asset to be redeemed  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _setTokenQuantity             Quantity of SetTokens to redeem  *  * @return  uint256                     Expected reserve asset quantity redeemed  */ function getExpectedReserveRedeemQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     external     view     returns (uint256) {     uint256 preFeeReserveQuantity = _getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);      (,, uint256 netReserveFlows) = _getFees(         _setToken,         preFeeReserveQuantity,         PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_REDEEM_DIRECT_FEE_INDEX,         MANAGER_REDEEM_FEE_INDEX     );      return netReserveFlows; }  /**  * Checks if issue is valid  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with  *  * @return  bool                        Returns true if issue is valid  */ function isIssueValid(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     external     view     returns (bool) {     uint256 setTotalSupply = _setToken.totalSupply();  return _reserveAssetQuantity != 0         &amp;&amp; isReserveAsset[_setToken][_reserveAsset]         &amp;&amp; setTotalSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply; }  /**  * Checks if redeem is valid  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _setTokenQuantity             Quantity of SetTokens to redeem  *  * @return  bool                        Returns true if redeem is valid  */ function isRedeemValid(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     external     view     returns (bool) {     uint256 setTotalSupply = _setToken.totalSupply();      if (         _setTokenQuantity == 0         || !isReserveAsset[_setToken][_reserveAsset]         || setTotalSupply &lt; navIssuanceSettings[_setToken].minSetTokenSupply.add(_setTokenQuantity)     ) {         return false;     } else {         uint256 totalRedeemValue =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);          (,, uint256 expectedRedeemQuantity) = _getFees(             _setToken,             totalRedeemValue,             PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,             PROTOCOL_REDEEM_DIRECT_FEE_INDEX,             MANAGER_REDEEM_FEE_INDEX         );          uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();          return existingUnit.preciseMul(setTotalSupply) &gt;= expectedRedeemQuantity;     } }  /* ============ Internal Functions ============ */  function _validateCommon(ISetToken _setToken, address _reserveAsset, uint256 _quantity) internal view {     require(_quantity &gt; 0, "Quantity must be &gt; 0");     require(isReserveAsset[_setToken][_reserveAsset], "Must be valid reserve asset"); }  function _validateIssuanceInfo(ISetToken _setToken, uint256 _minSetTokenReceiveQuantity, ActionInfo memory _issueInfo) internal view {     // Check that total supply is greater than min supply needed for issuance     // Note: A min supply amount is needed to avoid division by 0 when SetToken supply is 0     require(         _issueInfo.previousSetTokenSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply,         "Supply must be greater than minimum to enable issuance"     );      require(_issueInfo.setTokenQuantity &gt;= _minSetTokenReceiveQuantity, "Must be greater than min SetToken"); }  function _validateRedemptionInfo(     ISetToken _setToken,     uint256 _minReserveReceiveQuantity,     ActionInfo memory _redeemInfo )     internal     view {     // Check that new supply is more than min supply needed for redemption     // Note: A min supply amount is needed to avoid division by 0 when redeeming SetToken to 0     require(         _redeemInfo.newSetTokenSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply,         "Supply must be greater than minimum to enable redemption"     );      require(_redeemInfo.netFlowQuantity &gt;= _minReserveReceiveQuantity, "Must be greater than min receive reserve quantity"); }  function _createIssuanceInfo(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     internal     view     returns (ActionInfo memory) {     ActionInfo memory issueInfo;      issueInfo.previousSetTokenSupply = _setToken.totalSupply();      issueInfo.preFeeReserveQuantity = _reserveAssetQuantity;      (issueInfo.protocolFees, issueInfo.managerFee, issueInfo.netFlowQuantity) = _getFees(         _setToken,         issueInfo.preFeeReserveQuantity,         PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_ISSUE_DIRECT_FEE_INDEX,         MANAGER_ISSUE_FEE_INDEX     );      issueInfo.setTokenQuantity = _getSetTokenMintQuantity(         _setToken,         _reserveAsset,         issueInfo.netFlowQuantity,         issueInfo.previousSetTokenSupply     );      (issueInfo.newSetTokenSupply, issueInfo.newPositionMultiplier) = _getIssuePositionMultiplier(_setToken, issueInfo);      issueInfo.newReservePositionUnit = _getIssuePositionUnit(_setToken, _reserveAsset, issueInfo);      return issueInfo; }  function _createRedemptionInfo(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     internal     view     returns (ActionInfo memory) {     ActionInfo memory redeemInfo;      redeemInfo.setTokenQuantity = _setTokenQuantity;      redeemInfo.preFeeReserveQuantity =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);      (redeemInfo.protocolFees, redeemInfo.managerFee, redeemInfo.netFlowQuantity) = _getFees(         _setToken,         redeemInfo.preFeeReserveQuantity,         PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_REDEEM_DIRECT_FEE_INDEX,         MANAGER_REDEEM_FEE_INDEX     );      redeemInfo.previousSetTokenSupply = _setToken.totalSupply();      (redeemInfo.newSetTokenSupply, redeemInfo.newPositionMultiplier) = _getRedeemPositionMultiplier(_setToken, _setTokenQuantity, redeemInfo);      redeemInfo.newReservePositionUnit = _getRedeemPositionUnit(_setToken, _reserveAsset, redeemInfo);      return redeemInfo; }  /**  * Transfer reserve asset from user to SetToken and fees from user to appropriate fee recipients  */ function _transferCollateralAndHandleFees(ISetToken _setToken, IERC20 _reserveAsset, ActionInfo memory _issueInfo) internal {     transferFrom(_reserveAsset, msg.sender, address(_setToken), _issueInfo.netFlowQuantity);      if (_issueInfo.protocolFees &gt; 0) {         transferFrom(_reserveAsset, msg.sender, controller.feeRecipient(), _issueInfo.protocolFees);     }      if (_issueInfo.managerFee &gt; 0) {         transferFrom(_reserveAsset, msg.sender, navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);     } }   /**   * Transfer WETH from module to SetToken and fees from module to appropriate fee recipients  */ function _transferWETHAndHandleFees(ISetToken _setToken, ActionInfo memory _issueInfo) internal {     weth.transfer(address(_setToken), _issueInfo.netFlowQuantity);      if (_issueInfo.protocolFees &gt; 0) {         weth.transfer(controller.feeRecipient(), _issueInfo.protocolFees);     }      if (_issueInfo.managerFee &gt; 0) {         weth.transfer(navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);     } }  function _handleIssueStateUpdates(     ISetToken _setToken,     address _reserveAsset,     address _to,     ActionInfo memory _issueInfo )     internal {     _setToken.editPositionMultiplier(_issueInfo.newPositionMultiplier);      _setToken.editDefaultPosition(_reserveAsset, _issueInfo.newReservePositionUnit);      _setToken.mint(_to, _issueInfo.setTokenQuantity);      emit SetTokenNAVIssued(         _setToken,         msg.sender,         _to,         _reserveAsset,         address(navIssuanceSettings[_setToken].managerIssuanceHook),         _issueInfo.setTokenQuantity,         _issueInfo.managerFee,         _issueInfo.protocolFees     ); }  function _handleRedeemStateUpdates(     ISetToken _setToken,     address _reserveAsset,     address _to,     ActionInfo memory _redeemInfo )     internal {     _setToken.editPositionMultiplier(_redeemInfo.newPositionMultiplier);      _setToken.editDefaultPosition(_reserveAsset, _redeemInfo.newReservePositionUnit);      emit SetTokenNAVRedeemed(         _setToken,         msg.sender,         _to,         _reserveAsset,         address(navIssuanceSettings[_setToken].managerRedemptionHook),         _redeemInfo.setTokenQuantity,         _redeemInfo.managerFee,         _redeemInfo.protocolFees     ); }  function _handleRedemptionFees(ISetToken _setToken, address _reserveAsset, ActionInfo memory _redeemInfo) internal {     // Instruct the SetToken to transfer protocol fee to fee recipient if there is a fee     payProtocolFeeFromSetToken(_setToken, _reserveAsset, _redeemInfo.protocolFees);      // Instruct the SetToken to transfer manager fee to manager fee recipient if there is a fee     if (_redeemInfo.managerFee &gt; 0) {         _setToken.strictInvokeTransfer(             _reserveAsset,             navIssuanceSettings[_setToken].feeRecipient,             _redeemInfo.managerFee         );     } }  /**  * Returns the issue premium percentage. Virtual function that can be overridden in future versions of the module  * and can contain arbitrary logic to calculate the issuance premium.  */ function _getIssuePremium(     ISetToken _setToken,     address /* _reserveAsset */,     uint256 /* _reserveAssetQuantity */ )     virtual     internal     view     returns (uint256) {     return navIssuanceSettings[_setToken].premiumPercentage; }  /**  * Returns the redeem premium percentage. Virtual function that can be overridden in future versions of the module  * and can contain arbitrary logic to calculate the redemption premium.  */ function _getRedeemPremium(     ISetToken _setToken,     address /* _reserveAsset */,     uint256 /* _setTokenQuantity */ )     virtual     internal     view     returns (uint256) {     return navIssuanceSettings[_setToken].premiumPercentage; }  /**  * Returns the fees attributed to the manager and the protocol. The fees are calculated as follows:  *  * ManagerFee = (manager fee % - % to protocol) * reserveAssetQuantity  * Protocol Fee = (% manager fee share + direct fee %) * reserveAssetQuantity  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAssetQuantity         Quantity of reserve asset to calculate fees from  * @param _protocolManagerFeeIndex      Index to pull rev share NAV Issuance fee from the Controller  * @param _protocolDirectFeeIndex       Index to pull direct NAV issuance fee from the Controller  * @param _managerFeeIndex              Index from NAVIssuanceSettings (0 = issue fee, 1 = redeem fee)  *  * @return  uint256                     Fees paid to the protocol in reserve asset  * @return  uint256                     Fees paid to the manager in reserve asset  * @return  uint256                     Net reserve to user net of fees  */ function _getFees(     ISetToken _setToken,     uint256 _reserveAssetQuantity,     uint256 _protocolManagerFeeIndex,     uint256 _protocolDirectFeeIndex,     uint256 _managerFeeIndex )     internal     view     returns (uint256, uint256, uint256) {     (uint256 protocolFeePercentage, uint256 managerFeePercentage) = _getProtocolAndManagerFeePercentages(         _setToken,         _protocolManagerFeeIndex,         _protocolDirectFeeIndex,         _managerFeeIndex     );      // Calculate total notional fees     uint256 protocolFees = protocolFeePercentage.preciseMul(_reserveAssetQuantity);     uint256 managerFee = managerFeePercentage.preciseMul(_reserveAssetQuantity);      uint256 netReserveFlow = _reserveAssetQuantity.sub(protocolFees).sub(managerFee);      return (protocolFees, managerFee, netReserveFlow); }  function _getProtocolAndManagerFeePercentages(     ISetToken _setToken,     uint256 _protocolManagerFeeIndex,     uint256 _protocolDirectFeeIndex,     uint256 _managerFeeIndex )     internal     view     returns(uint256, uint256) {     // Get protocol fee percentages     uint256 protocolDirectFeePercent = controller.getModuleFee(address(this), _protocolDirectFeeIndex);     uint256 protocolManagerShareFeePercent = controller.getModuleFee(address(this), _protocolManagerFeeIndex);     uint256 managerFeePercent = navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];      // Calculate revenue share split percentage     uint256 protocolRevenueSharePercentage = protocolManagerShareFeePercent.preciseMul(managerFeePercent);     uint256 managerRevenueSharePercentage = managerFeePercent.sub(protocolRevenueSharePercentage);     uint256 totalProtocolFeePercentage = protocolRevenueSharePercentage.add(protocolDirectFeePercent);      return (totalProtocolFeePercentage, managerRevenueSharePercentage); }  function _getSetTokenMintQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _netReserveFlows,            // Value of reserve asset net of fees     uint256 _setTotalSupply )     internal     view     returns (uint256) {     uint256 premiumPercentage = _getIssuePremium(_setToken, _reserveAsset, _netReserveFlows);     uint256 premiumValue = _netReserveFlows.preciseMul(premiumPercentage);      // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (1e18)     // Reverts if price is not found     uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);      // Get reserve asset decimals     uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();     uint256 normalizedTotalReserveQuantityNetFees = _netReserveFlows.preciseDiv(10 ** reserveAssetDecimals);     uint256 normalizedTotalReserveQuantityNetFeesAndPremium = _netReserveFlows.sub(premiumValue).preciseDiv(10 ** reserveAssetDecimals);      // Calculate SetTokens to mint to issuer     uint256 denominator = _setTotalSupply.preciseMul(setTokenValuation).add(normalizedTotalReserveQuantityNetFees).sub(normalizedTotalReserveQuantityNetFeesAndPremium);     return normalizedTotalReserveQuantityNetFeesAndPremium.preciseMul(_setTotalSupply).preciseDiv(denominator); }  function _getRedeemReserveQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     internal     view     returns (uint256) {     // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (10e18)     // Reverts if price is not found     uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);      uint256 totalRedeemValueInPreciseUnits = _setTokenQuantity.preciseMul(setTokenValuation);     // Get reserve asset decimals     uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();     uint256 prePremiumReserveQuantity = totalRedeemValueInPreciseUnits.preciseMul(10 ** reserveAssetDecimals);      uint256 premiumPercentage = _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);     uint256 premiumQuantity = prePremiumReserveQuantity.preciseMulCeil(premiumPercentage);      return prePremiumReserveQuantity.sub(premiumQuantity); }  /**  * The new position multiplier is calculated as follows:  * inflationPercentage = (newSupply - oldSupply) / newSupply  * newMultiplier = (1 - inflationPercentage) * positionMultiplier  */ function _getIssuePositionMultiplier(     ISetToken _setToken,     ActionInfo memory _issueInfo )     internal     view     returns (uint256, int256) {     // Calculate inflation and new position multiplier. Note: Round inflation up in order to round position multiplier down     uint256 newTotalSupply = _issueInfo.setTokenQuantity.add(_issueInfo.previousSetTokenSupply);     int256 newPositionMultiplier = _setToken.positionMultiplier()         .mul(_issueInfo.previousSetTokenSupply.toInt256())         .div(newTotalSupply.toInt256());      return (newTotalSupply, newPositionMultiplier); }  /**  * Calculate deflation and new position multiplier. Note: Round deflation down in order to round position multiplier down  *  * The new position multiplier is calculated as follows:  * deflationPercentage = (oldSupply - newSupply) / newSupply  * newMultiplier = (1 + deflationPercentage) * positionMultiplier  */ function _getRedeemPositionMultiplier(     ISetToken _setToken,     uint256 _setTokenQuantity,     ActionInfo memory _redeemInfo )     internal     view     returns (uint256, int256) {     uint256 newTotalSupply = _redeemInfo.previousSetTokenSupply.sub(_setTokenQuantity);     int256 newPositionMultiplier = _setToken.positionMultiplier()         .mul(_redeemInfo.previousSetTokenSupply.toInt256())         .div(newTotalSupply.toInt256());      return (newTotalSupply, newPositionMultiplier); }  /**  * The new position reserve asset unit is calculated as follows:  * totalReserve = (oldUnit * oldSetTokenSupply) + reserveQuantity  * newUnit = totalReserve / newSetTokenSupply  */ function _getIssuePositionUnit(     ISetToken _setToken,     address _reserveAsset,     ActionInfo memory _issueInfo )     internal     view     returns (uint256) {     uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();     uint256 totalReserve = existingUnit         .preciseMul(_issueInfo.previousSetTokenSupply)         .add(_issueInfo.netFlowQuantity);      return totalReserve.preciseDiv(_issueInfo.newSetTokenSupply); }  /**  * The new position reserve asset unit is calculated as follows:  * totalReserve = (oldUnit * oldSetTokenSupply) - reserveQuantityToSendOut  * newUnit = totalReserve / newSetTokenSupply  */ function _getRedeemPositionUnit(     ISetToken _setToken,     address _reserveAsset,     ActionInfo memory _redeemInfo )     internal     view     returns (uint256) {     uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();     uint256 totalExistingUnits = existingUnit.preciseMul(_redeemInfo.previousSetTokenSupply);      uint256 outflow = _redeemInfo.netFlowQuantity.add(_redeemInfo.protocolFees).add(_redeemInfo.managerFee);      // Require withdrawable quantity is greater than existing collateral     require(totalExistingUnits &gt;= outflow, "Must be greater than total available collateral");      return totalExistingUnits.sub(outflow).preciseDiv(_redeemInfo.newSetTokenSupply); }  /**  * If a pre-issue hook has been configured, call the external-protocol contract. Pre-issue hook logic  * can contain arbitrary logic including validations, external function calls, etc.  */ function _callPreIssueHooks(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity,     address _caller,     address _to )     internal {     INAVIssuanceHook preIssueHook = navIssuanceSettings[_setToken].managerIssuanceHook;     if (address(preIssueHook) != address(0)) {         preIssueHook.invokePreIssueHook(_setToken, _reserveAsset, _reserveAssetQuantity, _caller, _to);     } }  /**  * If a pre-redeem hook has been configured, call the external-protocol contract.  */ function _callPreRedeemHooks(ISetToken _setToken, uint256 _setQuantity, address _caller, address _to) internal {     INAVIssuanceHook preRedeemHook = navIssuanceSettings[_setToken].managerRedemptionHook;     if (address(preRedeemHook) != address(0)) {         preRedeemHook.invokePreRedeemHook(_setToken, _setQuantity, _caller, _to);     } }  } |
| **need_reflect** | True |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **phase_prompt** | We excel in generating innovative approaches and enhancements for Solidity smart contract code. Here's a Solidity contract provided by the user: "{task}". As the {assistant_role}, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user. Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions". |
| **phase_name** | ContractAnalysis |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': '/\n    Copyright 2020 Set Labs Inc.\n\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n/\n\npragma solidity 0.6.10;\npragma experimental "ABIEncoderV2";\n\nimport { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";\nimport { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";\nimport { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";\nimport { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";\nimport { SignedSafeMath } from "@openzeppelin/contracts/math/SignedSafeMath.sol";\n\nimport { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";\nimport { IController } from "../../interfaces/IController.sol";\nimport { INAVIssuanceHook } from "../../interfaces/INAVIssuanceHook.sol";\nimport { Invoke } from "../lib/Invoke.sol";\nimport { ISetToken } from "../../interfaces/ISetToken.sol";\nimport { IWETH } from "../../interfaces/external/IWETH.sol";\nimport { ModuleBase } from "../lib/ModuleBase.sol";\nimport { Position } from "../lib/Position.sol";\nimport { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";\nimport { ResourceIdentifier } from "../lib/ResourceIdentifier.sol";\n\n\n/\n * @title NavIssuanceModule\n * @author Set Protocol\n \n * Module that enables issuance and redemption with any valid ERC20 token or ETH if allowed by the manager. Sender receives\n * a proportional amount of SetTokens on issuance or ERC20 token on redemption based on the calculated net asset value using\n * oracle prices. Manager is able to enforce a premium / discount on issuance / redemption to avoid arbitrage and front\n * running when relying on oracle prices. Managers can charge a fee (denominated in reserve asset).\n /\ncontract NavIssuanceModule is ModuleBase, ReentrancyGuard {\n    using AddressArrayUtils for address[];\n    using Invoke for ISetToken;\n    using Position for ISetToken;\n    using PreciseUnitMath for uint256;\n    using PreciseUnitMath for int256;\n    using ResourceIdentifier for IController;\n    using SafeMath for uint256;\n    using SafeCast for int256;\n    using SafeCast for uint256;\n    using SignedSafeMath for int256;\n\n    / ============ Events ============ /\n\n    event SetTokenNAVIssued(\n        ISetToken indexed _setToken,\n        address _issuer,\n        address _to,\n        address _reserveAsset,\n        address _hookContract,\n        uint256 _setTokenQuantity,\n        uint256 _managerFee,\n        uint256 _premium\n    );\n\n    event SetTokenNAVRedeemed(\n        ISetToken indexed _setToken,\n        address _redeemer,\n        address _to,\n        address _reserveAsset,\n        address _hookContract,\n        uint256 _setTokenQuantity,\n        uint256 _managerFee,\n        uint256 _premium\n    );\n\n    event ReserveAssetAdded(\n        ISetToken indexed _setToken,\n        address _newReserveAsset\n    );\n\n    event ReserveAssetRemoved(\n        ISetToken indexed _setToken,\n        address _removedReserveAsset\n    );\n\n    event PremiumEdited(\n        ISetToken indexed _setToken,\n        uint256 _newPremium\n    );\n\n    event ManagerFeeEdited(\n        ISetToken indexed _setToken,\n        uint256 _newManagerFee,\n        uint256 _index\n    );\n\n    event FeeRecipientEdited(\n        ISetToken indexed _setToken,\n        address _feeRecipient\n    );\n\n    / ============ Structs ============ /\n\n    struct NAVIssuanceSettings {\n        INAVIssuanceHook managerIssuanceHook;      // Issuance hook configurations\n        INAVIssuanceHook managerRedemptionHook;    // Redemption hook configurations\n        address[] reserveAssets;                       // Allowed reserve assets - Must have a price enabled with the price oracle\n        address feeRecipient;                          // Manager fee recipient\n        uint256[2] managerFees;                        // Manager fees. 0 index is issue and 1 index is redeem fee (0.01% = 1e14, 1% = 1e16)\n        uint256 maxManagerFee;                         // Maximum fee manager is allowed to set for issue and redeem\n        uint256 premiumPercentage;                     // Premium percentage (0.01% = 1e14, 1% = 1e16). This premium is a buffer around oracle\n                                                       // prices paid by user to the SetToken, which prevents arbitrage and oracle front running\n        uint256 maxPremiumPercentage;                  // Maximum premium percentage manager is allowed to set (configured by manager)\n        uint256 minSetTokenSupply;                     // Minimum SetToken supply required for issuance and redemption\n                                                       // to prevent dramatic inflationary changes to the SetToken\'s position multiplier\n    }\n\n    struct ActionInfo {\n        uint256 preFeeReserveQuantity;                 // Reserve value before fees; During issuance, represents raw quantity\n                                                       // During redeem, represents post-premium value\n        uint256 protocolFees;                          // Total protocol fees (direct + manager revenue share)\n        uint256 managerFee;                            // Total manager fee paid in reserve asset\n        uint256 netFlowQuantity;                       // When issuing, quantity of reserve asset sent to SetToken\n                                                       // When redeeming, quantity of reserve asset sent to redeemer\n        uint256 setTokenQuantity;                      // When issuing, quantity of SetTokens minted to mintee\n                                                       // When redeeming, quantity of SetToken redeemed\n        uint256 previousSetTokenSupply;                // SetToken supply prior to issue/redeem action\n        uint256 newSetTokenSupply;                     // SetToken supply after issue/redeem action\n        int256 newPositionMultiplier;                  // SetToken position multiplier after issue/redeem\n        uint256 newReservePositionUnit;                // SetToken reserve asset position unit after issue/redeem\n    }\n\n    / ============ State Variables ============ /\n\n    // Wrapped ETH address\n    IWETH public immutable weth;\n\n    // Mapping of SetToken to NAV issuance settings struct\n    mapping(ISetToken =&gt; NAVIssuanceSettings) public navIssuanceSettings;\n\n    // Mapping to efficiently check a SetToken\'s reserve asset validity\n    // SetToken =&gt; reserveAsset =&gt; isReserveAsset\n    mapping(ISetToken =&gt; mapping(address =&gt; bool)) public isReserveAsset;\n\n    / ============ Constants ============ /\n\n    // 0 index stores the manager fee in managerFees array, percentage charged on issue (denominated in reserve asset)\n    uint256 constant internal MANAGER_ISSUE_FEE_INDEX = 0;\n\n    // 1 index stores the manager fee percentage in managerFees array, charged on redeem\n    uint256 constant internal MANAGER_REDEEM_FEE_INDEX = 1;\n\n    // 0 index stores the manager revenue share protocol fee % on the controller, charged in the issuance function\n    uint256 constant internal PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX = 0;\n\n    // 1 index stores the manager revenue share protocol fee % on the controller, charged in the redeem function\n    uint256 constant internal PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX = 1;\n\n    // 2 index stores the direct protocol fee % on the controller, charged in the issuance function\n    uint256 constant internal PROTOCOL_ISSUE_DIRECT_FEE_INDEX = 2;\n\n    // 3 index stores the direct protocol fee % on the controller, charged in the redeem function\n    uint256 constant internal PROTOCOL_REDEEM_DIRECT_FEE_INDEX = 3;\n\n    / ============ Constructor ============ /\n\n    /\n     * @param _controller               Address of controller contract\n     * @param _weth                     Address of wrapped eth\n     /\n    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {\n        weth = _weth;\n    }\n\n    / ============ External Functions ============ /\n\n    /\n     * Deposits the allowed reserve asset into the SetToken and mints the appropriate % of Net Asset Value of the SetToken\n     * to the specified _to address.\n     \n     * @param _setToken                     Instance of the SetToken contract\n     * @param _reserveAsset                 Address of the reserve asset to issue with\n     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with\n     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance\n     * @param _to                           Address to mint SetToken to\n     /\n    function issue(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _reserveAssetQuantity,\n        uint256 _minSetTokenReceiveQuantity,\n        address _to\n    )\n        external\n        nonReentrant\n        onlyValidAndInitializedSet(_setToken)\n    {\n        _validateCommon(_setToken, _reserveAsset, _reserveAssetQuantity);\n\n        _callPreIssueHooks(_setToken, _reserveAsset, _reserveAssetQuantity, msg.sender, _to);\n\n        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, _reserveAsset, _reserveAssetQuantity);\n\n        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);\n\n        _transferCollateralAndHandleFees(_setToken, IERC20(_reserveAsset), issueInfo);\n\n        _handleIssueStateUpdates(_setToken, _reserveAsset, _to, issueInfo);\n    }\n\n    /\n     * Wraps ETH and deposits WETH if allowed into the SetToken and mints the appropriate % of Net Asset Value of the SetToken\n     * to the specified _to address.\n     \n     * @param _setToken                     Instance of the SetToken contract\n     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance\n     * @param _to                           Address to mint SetToken to\n     /\n    function issueWithEther(\n        ISetToken _setToken,\n        uint256 _minSetTokenReceiveQuantity,\n        address _to\n    )\n        external\n        payable\n        nonReentrant\n        onlyValidAndInitializedSet(_setToken)\n    {\n        weth.deposit{ value: msg.value }();\n\n        _validateCommon(_setToken, address(weth), msg.value);\n\n        _callPreIssueHooks(_setToken, address(weth), msg.value, msg.sender, _to);\n\n        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, address(weth), msg.value);\n\n        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);\n\n        _transferWETHAndHandleFees(_setToken, issueInfo);\n\n        _handleIssueStateUpdates(_setToken, address(weth), _to, issueInfo);\n    }\n\n    /\n     * Redeems a SetToken into a valid reserve asset representing the appropriate % of Net Asset Value of the SetToken\n     * to the specified _to address. Only valid if there are available reserve units on the SetToken.\n     \n     * @param _setToken                     Instance of the SetToken contract\n     * @param _reserveAsset                 Address of the reserve asset to redeem with\n     * @param _setTokenQuantity             Quantity of SetTokens to redeem\n     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive\n     * @param _to                           Address to redeem reserve asset to\n     /\n    function redeem(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _setTokenQuantity,\n        uint256 _minReserveReceiveQuantity,\n        address _to\n    )\n        external\n        nonReentrant\n        onlyValidAndInitializedSet(_setToken)\n    {\n        _validateCommon(_setToken, _reserveAsset, _setTokenQuantity);\n\n        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);\n\n        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, _reserveAsset, _setTokenQuantity);\n\n        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);\n\n        _setToken.burn(msg.sender, _setTokenQuantity);\n\n        // Instruct the SetToken to transfer the reserve asset back to the user\n        _setToken.strictInvokeTransfer(\n            _reserveAsset,\n            _to,\n            redeemInfo.netFlowQuantity\n        );\n\n        _handleRedemptionFees(_setToken, _reserveAsset, redeemInfo);\n\n        _handleRedeemStateUpdates(_setToken, _reserveAsset, _to, redeemInfo);\n    }\n\n    /\n     * Redeems a SetToken into Ether (if WETH is valid) representing the appropriate % of Net Asset Value of the SetToken\n     * to the specified _to address. Only valid if there are available WETH units on the SetToken.\n     \n     * @param _setToken                     Instance of the SetToken contract\n     * @param _setTokenQuantity             Quantity of SetTokens to redeem\n     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive\n     * @param _to                           Address to redeem reserve asset to\n     /\n    function redeemIntoEther(\n        ISetToken _setToken,\n        uint256 _setTokenQuantity,\n        uint256 _minReserveReceiveQuantity,\n        address payable _to\n    )\n        external\n        nonReentrant\n        onlyValidAndInitializedSet(_setToken)\n    {\n        _validateCommon(_setToken, address(weth), _setTokenQuantity);\n\n        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);\n\n        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, address(weth), _setTokenQuantity);\n\n        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);\n\n        _setToken.burn(msg.sender, _setTokenQuantity);\n\n        // Instruct the SetToken to transfer WETH from SetToken to module\n        _setToken.strictInvokeTransfer(\n            address(weth),\n            address(this),\n            redeemInfo.netFlowQuantity\n        );\n\n        weth.withdraw(redeemInfo.netFlowQuantity);\n\n        _to.transfer(redeemInfo.netFlowQuantity);\n\n        _handleRedemptionFees(_setToken, address(weth), redeemInfo);\n\n        _handleRedeemStateUpdates(_setToken, address(weth), _to, redeemInfo);\n    }\n\n    /\n     * SET MANAGER ONLY. Add an allowed reserve asset\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _reserveAsset                 Address of the reserve asset to add\n     /\n    function addReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {\n        require(!isReserveAsset[_setToken][_reserveAsset], "Reserve asset already exists");\n\n        navIssuanceSettings[_setToken].reserveAssets.push(_reserveAsset);\n        isReserveAsset[_setToken][_reserveAsset] = true;\n\n        emit ReserveAssetAdded(_setToken, _reserveAsset);\n    }\n\n    /\n     * SET MANAGER ONLY. Remove a reserve asset\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _reserveAsset                 Address of the reserve asset to remove\n     /\n    function removeReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {\n        require(isReserveAsset[_setToken][_reserveAsset], "Reserve asset does not exist");\n\n        navIssuanceSettings[_setToken].reserveAssets = navIssuanceSettings[_setToken].reserveAssets.remove(_reserveAsset);\n        delete isReserveAsset[_setToken][_reserveAsset];\n\n        emit ReserveAssetRemoved(_setToken, _reserveAsset);\n    }\n\n    /\n     * SET MANAGER ONLY. Edit the premium percentage\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _premiumPercentage            Premium percentage in 10e16 (e.g. 10e16 = 1%)\n     /\n    function editPremium(ISetToken _setToken, uint256 _premiumPercentage) external onlyManagerAndValidSet(_setToken) {\n        require(_premiumPercentage &lt;= navIssuanceSettings[_setToken].maxPremiumPercentage, "Premium must be less than maximum allowed");\n\n        navIssuanceSettings[_setToken].premiumPercentage = _premiumPercentage;\n\n        emit PremiumEdited(_setToken, _premiumPercentage);\n    }\n\n    /\n     * SET MANAGER ONLY. Edit manager fee\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _managerFeePercentage         Manager fee percentage in 10e16 (e.g. 10e16 = 1%)\n     * @param _managerFeeIndex              Manager fee index. 0 index is issue fee, 1 index is redeem fee\n     /\n    function editManagerFee(\n        ISetToken _setToken,\n        uint256 _managerFeePercentage,\n        uint256 _managerFeeIndex\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        require(_managerFeePercentage &lt;= navIssuanceSettings[_setToken].maxManagerFee, "Manager fee must be less than maximum allowed");\n\n        navIssuanceSettings[_setToken].managerFees[_managerFeeIndex] = _managerFeePercentage;\n\n        emit ManagerFeeEdited(_setToken, _managerFeePercentage, _managerFeeIndex);\n    }\n\n    /\n     * SET MANAGER ONLY. Edit the manager fee recipient\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _managerFeeRecipient          Manager fee recipient\n     /\n    function editFeeRecipient(ISetToken _setToken, address _managerFeeRecipient) external onlyManagerAndValidSet(_setToken) {\n        require(_managerFeeRecipient != address(0), "Fee recipient must not be 0 address");\n\n        navIssuanceSettings[_setToken].feeRecipient = _managerFeeRecipient;\n\n        emit FeeRecipientEdited(_setToken, _managerFeeRecipient);\n    }\n\n    /\n     * SET MANAGER ONLY. Initializes this module to the SetToken with hooks, allowed reserve assets,\n     * fees and issuance premium. Only callable by the SetToken\'s manager. Hook addresses are optional.\n     * Address(0) means that no hook will be called.\n     \n     * @param _setToken                     Instance of the SetToken to issue\n     * @param _navIssuanceSettings          NAVIssuanceSettings struct defining parameters\n     /\n    function initialize(\n        ISetToken _setToken,\n        NAVIssuanceSettings memory _navIssuanceSettings\n    )\n        external\n        onlySetManager(_setToken, msg.sender)\n        onlyValidAndPendingSet(_setToken)\n    {\n        require(_navIssuanceSettings.reserveAssets.length &gt; 0, "Reserve assets must be greater than 0");\n        require(_navIssuanceSettings.maxManagerFee &lt; PreciseUnitMath.preciseUnit(), "Max manager fee must be less than 100%");\n        require(_navIssuanceSettings.maxPremiumPercentage &lt; PreciseUnitMath.preciseUnit(), "Max premium percentage must be less than 100%");\n        require(_navIssuanceSettings.managerFees[0] &lt;= _navIssuanceSettings.maxManagerFee, "Manager issue fee must be less than max");\n        require(_navIssuanceSettings.managerFees[1] &lt;= _navIssuanceSettings.maxManagerFee, "Manager redeem fee must be less than max");\n        require(_navIssuanceSettings.premiumPercentage &lt;= _navIssuanceSettings.maxPremiumPercentage, "Premium must be less than max");\n        require(_navIssuanceSettings.feeRecipient != address(0), "Fee Recipient must be non-zero address.");\n        // Initial mint of Set cannot use NAVIssuance since minSetTokenSupply must be &gt; 0\n        require(_navIssuanceSettings.minSetTokenSupply &gt; 0, "Min SetToken supply must be greater than 0");\n\n        for (uint256 i = 0; i &lt; _navIssuanceSettings.reserveAssets.length; i++) {\n            require(!isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]], "Reserve assets must be unique");\n            isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]] = true;\n        }\n\n        navIssuanceSettings[_setToken] = _navIssuanceSettings;\n\n        _setToken.initializeModule();\n    }\n\n    /\n     * Removes this module from the SetToken, via call by the SetToken. Issuance settings and\n     * reserve asset states are deleted.\n     /\n    function removeModule() external override {\n        ISetToken setToken = ISetToken(msg.sender);\n        for (uint256 i = 0; i &lt; navIssuanceSettings[setToken].reserveAssets.length; i++) {\n            delete isReserveAsset[setToken][navIssuanceSettings[setToken].reserveAssets[i]];\n        }\n\n        delete navIssuanceSettings[setToken];\n    }\n\n    receive() external payable {}\n\n    / ============ External Getter Functions ============ /\n\n    function getReserveAssets(ISetToken _setToken) external view returns (address[] memory) {\n        return navIssuanceSettings[_setToken].reserveAssets;\n    }\n\n    function getIssuePremium(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _reserveAssetQuantity\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getIssuePremium(_setToken, _reserveAsset, _reserveAssetQuantity);\n    }\n\n    function getRedeemPremium(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _setTokenQuantity\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);\n    }\n\n    function getManagerFee(ISetToken _setToken, uint256 _managerFeeIndex) external view returns (uint256) {\n        return navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];\n    }\n\n    /\n     * Get the expected SetTokens minted to recipient on issuance\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _reserveAsset                 Address of the reserve asset\n     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with\n     \n     * @return  uint256                     Expected SetTokens to be minted to recipient\n     */\n    function getExpectedSetTokenIssueQuantity(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _reserveAssetQuantity\n    )\n        external\n        view\n        returns (uint256)\n    {\n        (,, uint256 netReserveFlow) = _getFees(\n            _setToken,\n            _reserveAssetQuantity,\n            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,\n            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,\n            MANAGER_ISSUE_FEE_INDEX\n        );\n\n        uint256 setTotalSupply = _setToken.totalSupply();\n\n        return _getSetTokenMintQuantity(\n            _setToken,\n            _reserveAsset,\n            netReserveFlow,\n            setTotalSupply\n        );\n    }\n\n    /\n     * Get the expected reserve asset to be redeemed\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _reserveAsset                 Address of the reserve asset\n     * @param _setTokenQuantity             Quantity of SetTokens to redeem\n     \n     * @return  uint256                     Expected reserve asset quantity redeemed\n     /\n    function getExpectedReserveRedeemQuantity(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _setTokenQuantity\n    )\n        external\n        view\n        returns (uint256)\n    {\n        uint256 preFeeReserveQuantity = _getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);\n\n        (,, uint256 netReserveFlows) = _getFees(\n            _setToken,\n            preFeeReserveQuantity,\n            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,\n            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,\n            MANAGER_REDEEM_FEE_INDEX\n        );\n\n        return netReserveFlows;\n    }\n\n    /\n     * Checks if issue is valid\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _reserveAsset                 Address of the reserve asset\n     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with\n     \n     * @return  bool                        Returns true if issue is valid\n     /\n    function isIssueValid(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _reserveAssetQuantity\n    )\n        external\n        view\n        returns (bool)\n    {\n        uint256 setTotalSupply = _setToken.totalSupply();\n\n    return _reserveAssetQuantity != 0\n            &amp;&amp; isReserveAsset[_setToken][_reserveAsset]\n            &amp;&amp; setTotalSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply;\n    }\n\n    /\n     * Checks if redeem is valid\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _reserveAsset                 Address of the reserve asset\n     * @param _setTokenQuantity             Quantity of SetTokens to redeem\n     \n     * @return  bool                        Returns true if redeem is valid\n     /\n    function isRedeemValid(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _setTokenQuantity\n    )\n        external\n        view\n        returns (bool)\n    {\n        uint256 setTotalSupply = _setToken.totalSupply();\n\n        if (\n            _setTokenQuantity == 0\n            || !isReserveAsset[_setToken][_reserveAsset]\n            || setTotalSupply &lt; navIssuanceSettings[_setToken].minSetTokenSupply.add(_setTokenQuantity)\n        ) {\n            return false;\n        } else {\n            uint256 totalRedeemValue =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);\n\n            (,, uint256 expectedRedeemQuantity) = _getFees(\n                _setToken,\n                totalRedeemValue,\n                PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,\n                PROTOCOL_REDEEM_DIRECT_FEE_INDEX,\n                MANAGER_REDEEM_FEE_INDEX\n            );\n\n            uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();\n\n            return existingUnit.preciseMul(setTotalSupply) &gt;= expectedRedeemQuantity;\n        }\n    }\n\n    / ============ Internal Functions ============ */\n\n    function _validateCommon(ISetToken _setToken, address _reserveAsset, uint256 _quantity) internal view {\n        require(_quantity &gt; 0, "Quantity must be &gt; 0");\n        require(isReserveAsset[_setToken][_reserveAsset], "Must be valid reserve asset");\n    }\n\n    function _validateIssuanceInfo(ISetToken _setToken, uint256 _minSetTokenReceiveQuantity, ActionInfo memory _issueInfo) internal view {\n        // Check that total supply is greater than min supply needed for issuance\n        // Note: A min supply amount is needed to avoid division by 0 when SetToken supply is 0\n        require(\n            _issueInfo.previousSetTokenSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply,\n            "Supply must be greater than minimum to enable issuance"\n        );\n\n        require(_issueInfo.setTokenQuantity &gt;= _minSetTokenReceiveQuantity, "Must be greater than min SetToken");\n    }\n\n    function _validateRedemptionInfo(\n        ISetToken _setToken,\n        uint256 _minReserveReceiveQuantity,\n        ActionInfo memory _redeemInfo\n    )\n        internal\n        view\n    {\n        // Check that new supply is more than min supply needed for redemption\n        // Note: A min supply amount is needed to avoid division by 0 when redeeming SetToken to 0\n        require(\n            _redeemInfo.newSetTokenSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply,\n            "Supply must be greater than minimum to enable redemption"\n        );\n\n        require(_redeemInfo.netFlowQuantity &gt;= _minReserveReceiveQuantity, "Must be greater than min receive reserve quantity");\n    }\n\n    function _createIssuanceInfo(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _reserveAssetQuantity\n    )\n        internal\n        view\n        returns (ActionInfo memory)\n    {\n        ActionInfo memory issueInfo;\n\n        issueInfo.previousSetTokenSupply = _setToken.totalSupply();\n\n        issueInfo.preFeeReserveQuantity = _reserveAssetQuantity;\n\n        (issueInfo.protocolFees, issueInfo.managerFee, issueInfo.netFlowQuantity) = _getFees(\n            _setToken,\n            issueInfo.preFeeReserveQuantity,\n            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,\n            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,\n            MANAGER_ISSUE_FEE_INDEX\n        );\n\n        issueInfo.setTokenQuantity = _getSetTokenMintQuantity(\n            _setToken,\n            _reserveAsset,\n            issueInfo.netFlowQuantity,\n            issueInfo.previousSetTokenSupply\n        );\n\n        (issueInfo.newSetTokenSupply, issueInfo.newPositionMultiplier) = _getIssuePositionMultiplier(_setToken, issueInfo);\n\n        issueInfo.newReservePositionUnit = _getIssuePositionUnit(_setToken, _reserveAsset, issueInfo);\n\n        return issueInfo;\n    }\n\n    function _createRedemptionInfo(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _setTokenQuantity\n    )\n        internal\n        view\n        returns (ActionInfo memory)\n    {\n        ActionInfo memory redeemInfo;\n\n        redeemInfo.setTokenQuantity = _setTokenQuantity;\n\n        redeemInfo.preFeeReserveQuantity =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);\n\n        (redeemInfo.protocolFees, redeemInfo.managerFee, redeemInfo.netFlowQuantity) = _getFees(\n            _setToken,\n            redeemInfo.preFeeReserveQuantity,\n            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,\n            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,\n            MANAGER_REDEEM_FEE_INDEX\n        );\n\n        redeemInfo.previousSetTokenSupply = _setToken.totalSupply();\n\n        (redeemInfo.newSetTokenSupply, redeemInfo.newPositionMultiplier) = _getRedeemPositionMultiplier(_setToken, _setTokenQuantity, redeemInfo);\n\n        redeemInfo.newReservePositionUnit = _getRedeemPositionUnit(_setToken, _reserveAsset, redeemInfo);\n\n        return redeemInfo;\n    }\n\n    /\n     * Transfer reserve asset from user to SetToken and fees from user to appropriate fee recipients\n     /\n    function _transferCollateralAndHandleFees(ISetToken _setToken, IERC20 _reserveAsset, ActionInfo memory _issueInfo) internal {\n        transferFrom(_reserveAsset, msg.sender, address(_setToken), _issueInfo.netFlowQuantity);\n\n        if (_issueInfo.protocolFees &gt; 0) {\n            transferFrom(_reserveAsset, msg.sender, controller.feeRecipient(), _issueInfo.protocolFees);\n        }\n\n        if (_issueInfo.managerFee &gt; 0) {\n            transferFrom(_reserveAsset, msg.sender, navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);\n        }\n    }\n\n\n    /\n      * Transfer WETH from module to SetToken and fees from module to appropriate fee recipients\n     /\n    function _transferWETHAndHandleFees(ISetToken _setToken, ActionInfo memory _issueInfo) internal {\n        weth.transfer(address(_setToken), _issueInfo.netFlowQuantity);\n\n        if (_issueInfo.protocolFees &gt; 0) {\n            weth.transfer(controller.feeRecipient(), _issueInfo.protocolFees);\n        }\n\n        if (_issueInfo.managerFee &gt; 0) {\n            weth.transfer(navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);\n        }\n    }\n\n    function _handleIssueStateUpdates(\n        ISetToken _setToken,\n        address _reserveAsset,\n        address _to,\n        ActionInfo memory _issueInfo\n    )\n        internal\n    {\n        _setToken.editPositionMultiplier(_issueInfo.newPositionMultiplier);\n\n        _setToken.editDefaultPosition(_reserveAsset, _issueInfo.newReservePositionUnit);\n\n        _setToken.mint(_to, _issueInfo.setTokenQuantity);\n\n        emit SetTokenNAVIssued(\n            _setToken,\n            msg.sender,\n            _to,\n            _reserveAsset,\n            address(navIssuanceSettings[_setToken].managerIssuanceHook),\n            _issueInfo.setTokenQuantity,\n            _issueInfo.managerFee,\n            _issueInfo.protocolFees\n        );\n    }\n\n    function _handleRedeemStateUpdates(\n        ISetToken _setToken,\n        address _reserveAsset,\n        address _to,\n        ActionInfo memory _redeemInfo\n    )\n        internal\n    {\n        _setToken.editPositionMultiplier(_redeemInfo.newPositionMultiplier);\n\n        _setToken.editDefaultPosition(_reserveAsset, _redeemInfo.newReservePositionUnit);\n\n        emit SetTokenNAVRedeemed(\n            _setToken,\n            msg.sender,\n            _to,\n            _reserveAsset,\n            address(navIssuanceSettings[_setToken].managerRedemptionHook),\n            _redeemInfo.setTokenQuantity,\n            _redeemInfo.managerFee,\n            _redeemInfo.protocolFees\n        );\n    }\n\n    function _handleRedemptionFees(ISetToken _setToken, address _reserveAsset, ActionInfo memory _redeemInfo) internal {\n        // Instruct the SetToken to transfer protocol fee to fee recipient if there is a fee\n        payProtocolFeeFromSetToken(_setToken, _reserveAsset, _redeemInfo.protocolFees);\n\n        // Instruct the SetToken to transfer manager fee to manager fee recipient if there is a fee\n        if (_redeemInfo.managerFee &gt; 0) {\n            _setToken.strictInvokeTransfer(\n                _reserveAsset,\n                navIssuanceSettings[_setToken].feeRecipient,\n                _redeemInfo.managerFee\n            );\n        }\n    }\n\n    /\n     * Returns the issue premium percentage. Virtual function that can be overridden in future versions of the module\n     * and can contain arbitrary logic to calculate the issuance premium.\n     /\n    function _getIssuePremium(\n        ISetToken _setToken,\n        address / _reserveAsset /,\n        uint256 / _reserveAssetQuantity */\n    )\n        virtual\n        internal\n        view\n        returns (uint256)\n    {\n        return navIssuanceSettings[_setToken].premiumPercentage;\n    }\n\n    /\n     * Returns the redeem premium percentage. Virtual function that can be overridden in future versions of the module\n     * and can contain arbitrary logic to calculate the redemption premium.\n     /\n    function _getRedeemPremium(\n        ISetToken _setToken,\n        address / _reserveAsset /,\n        uint256 / _setTokenQuantity /\n    )\n        virtual\n        internal\n        view\n        returns (uint256)\n    {\n        return navIssuanceSettings[_setToken].premiumPercentage;\n    }\n\n    /\n     * Returns the fees attributed to the manager and the protocol. The fees are calculated as follows:\n     \n     * ManagerFee = (manager fee % - % to protocol) * reserveAssetQuantity\n     * Protocol Fee = (% manager fee share + direct fee %) * reserveAssetQuantity\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _reserveAssetQuantity         Quantity of reserve asset to calculate fees from\n     * @param _protocolManagerFeeIndex      Index to pull rev share NAV Issuance fee from the Controller\n     * @param _protocolDirectFeeIndex       Index to pull direct NAV issuance fee from the Controller\n     * @param _managerFeeIndex              Index from NAVIssuanceSettings (0 = issue fee, 1 = redeem fee)\n     \n     * @return  uint256                     Fees paid to the protocol in reserve asset\n     * @return  uint256                     Fees paid to the manager in reserve asset\n     * @return  uint256                     Net reserve to user net of fees\n     /\n    function _getFees(\n        ISetToken _setToken,\n        uint256 _reserveAssetQuantity,\n        uint256 _protocolManagerFeeIndex,\n        uint256 _protocolDirectFeeIndex,\n        uint256 _managerFeeIndex\n    )\n        internal\n        view\n        returns (uint256, uint256, uint256)\n    {\n        (uint256 protocolFeePercentage, uint256 managerFeePercentage) = _getProtocolAndManagerFeePercentages(\n            _setToken,\n            _protocolManagerFeeIndex,\n            _protocolDirectFeeIndex,\n            _managerFeeIndex\n        );\n\n        // Calculate total notional fees\n        uint256 protocolFees = protocolFeePercentage.preciseMul(_reserveAssetQuantity);\n        uint256 managerFee = managerFeePercentage.preciseMul(_reserveAssetQuantity);\n\n        uint256 netReserveFlow = _reserveAssetQuantity.sub(protocolFees).sub(managerFee);\n\n        return (protocolFees, managerFee, netReserveFlow);\n    }\n\n    function _getProtocolAndManagerFeePercentages(\n        ISetToken _setToken,\n        uint256 _protocolManagerFeeIndex,\n        uint256 _protocolDirectFeeIndex,\n        uint256 _managerFeeIndex\n    )\n        internal\n        view\n        returns(uint256, uint256)\n    {\n        // Get protocol fee percentages\n        uint256 protocolDirectFeePercent = controller.getModuleFee(address(this), _protocolDirectFeeIndex);\n        uint256 protocolManagerShareFeePercent = controller.getModuleFee(address(this), _protocolManagerFeeIndex);\n        uint256 managerFeePercent = navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];\n\n        // Calculate revenue share split percentage\n        uint256 protocolRevenueSharePercentage = protocolManagerShareFeePercent.preciseMul(managerFeePercent);\n        uint256 managerRevenueSharePercentage = managerFeePercent.sub(protocolRevenueSharePercentage);\n        uint256 totalProtocolFeePercentage = protocolRevenueSharePercentage.add(protocolDirectFeePercent);\n\n        return (totalProtocolFeePercentage, managerRevenueSharePercentage);\n    }\n\n    function _getSetTokenMintQuantity(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _netReserveFlows,            // Value of reserve asset net of fees\n        uint256 _setTotalSupply\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 premiumPercentage = _getIssuePremium(_setToken, _reserveAsset, _netReserveFlows);\n        uint256 premiumValue = _netReserveFlows.preciseMul(premiumPercentage);\n\n        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (1e18)\n        // Reverts if price is not found\n        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);\n\n        // Get reserve asset decimals\n        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();\n        uint256 normalizedTotalReserveQuantityNetFees = _netReserveFlows.preciseDiv(10 ** reserveAssetDecimals);\n        uint256 normalizedTotalReserveQuantityNetFeesAndPremium = _netReserveFlows.sub(premiumValue).preciseDiv(10 ** reserveAssetDecimals);\n\n        // Calculate SetTokens to mint to issuer\n        uint256 denominator = _setTotalSupply.preciseMul(setTokenValuation).add(normalizedTotalReserveQuantityNetFees).sub(normalizedTotalReserveQuantityNetFeesAndPremium);\n        return normalizedTotalReserveQuantityNetFeesAndPremium.preciseMul(_setTotalSupply).preciseDiv(denominator);\n    }\n\n    function _getRedeemReserveQuantity(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _setTokenQuantity\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (10e18)\n        // Reverts if price is not found\n        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);\n\n        uint256 totalRedeemValueInPreciseUnits = _setTokenQuantity.preciseMul(setTokenValuation);\n        // Get reserve asset decimals\n        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();\n        uint256 prePremiumReserveQuantity = totalRedeemValueInPreciseUnits.preciseMul(10 ** reserveAssetDecimals);\n\n        uint256 premiumPercentage = _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);\n        uint256 premiumQuantity = prePremiumReserveQuantity.preciseMulCeil(premiumPercentage);\n\n        return prePremiumReserveQuantity.sub(premiumQuantity);\n    }\n\n    /\n     * The new position multiplier is calculated as follows:\n     * inflationPercentage = (newSupply - oldSupply) / newSupply\n     * newMultiplier = (1 - inflationPercentage) * positionMultiplier\n     /\n    function _getIssuePositionMultiplier(\n        ISetToken _setToken,\n        ActionInfo memory _issueInfo\n    )\n        internal\n        view\n        returns (uint256, int256)\n    {\n        // Calculate inflation and new position multiplier. Note: Round inflation up in order to round position multiplier down\n        uint256 newTotalSupply = _issueInfo.setTokenQuantity.add(_issueInfo.previousSetTokenSupply);\n        int256 newPositionMultiplier = _setToken.positionMultiplier()\n            .mul(_issueInfo.previousSetTokenSupply.toInt256())\n            .div(newTotalSupply.toInt256());\n\n        return (newTotalSupply, newPositionMultiplier);\n    }\n\n    /\n     * Calculate deflation and new position multiplier. Note: Round deflation down in order to round position multiplier down\n     \n     * The new position multiplier is calculated as follows:\n     * deflationPercentage = (oldSupply - newSupply) / newSupply\n     * newMultiplier = (1 + deflationPercentage) * positionMultiplier\n     /\n    function _getRedeemPositionMultiplier(\n        ISetToken _setToken,\n        uint256 _setTokenQuantity,\n        ActionInfo memory _redeemInfo\n    )\n        internal\n        view\n        returns (uint256, int256)\n    {\n        uint256 newTotalSupply = _redeemInfo.previousSetTokenSupply.sub(_setTokenQuantity);\n        int256 newPositionMultiplier = _setToken.positionMultiplier()\n            .mul(_redeemInfo.previousSetTokenSupply.toInt256())\n            .div(newTotalSupply.toInt256());\n\n        return (newTotalSupply, newPositionMultiplier);\n    }\n\n    /\n     * The new position reserve asset unit is calculated as follows:\n     * totalReserve = (oldUnit * oldSetTokenSupply) + reserveQuantity\n     * newUnit = totalReserve / newSetTokenSupply\n     /\n    function _getIssuePositionUnit(\n        ISetToken _setToken,\n        address _reserveAsset,\n        ActionInfo memory _issueInfo\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();\n        uint256 totalReserve = existingUnit\n            .preciseMul(_issueInfo.previousSetTokenSupply)\n            .add(_issueInfo.netFlowQuantity);\n\n        return totalReserve.preciseDiv(_issueInfo.newSetTokenSupply);\n    }\n\n    /\n     * The new position reserve asset unit is calculated as follows:\n     * totalReserve = (oldUnit * oldSetTokenSupply) - reserveQuantityToSendOut\n     * newUnit = totalReserve / newSetTokenSupply\n     /\n    function _getRedeemPositionUnit(\n        ISetToken _setToken,\n        address _reserveAsset,\n        ActionInfo memory _redeemInfo\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();\n        uint256 totalExistingUnits = existingUnit.preciseMul(_redeemInfo.previousSetTokenSupply);\n\n        uint256 outflow = _redeemInfo.netFlowQuantity.add(_redeemInfo.protocolFees).add(_redeemInfo.managerFee);\n\n        // Require withdrawable quantity is greater than existing collateral\n        require(totalExistingUnits &gt;= outflow, "Must be greater than total available collateral");\n\n        return totalExistingUnits.sub(outflow).preciseDiv(_redeemInfo.newSetTokenSupply);\n    }\n\n    /\n     * If a pre-issue hook has been configured, call the external-protocol contract. Pre-issue hook logic\n     * can contain arbitrary logic including validations, external function calls, etc.\n     */\n    function _callPreIssueHooks(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _reserveAssetQuantity,\n        address _caller,\n        address _to\n    )\n        internal\n    {\n        INAVIssuanceHook preIssueHook = navIssuanceSettings[_setToken].managerIssuanceHook;\n        if (address(preIssueHook) != address(0)) {\n            preIssueHook.invokePreIssueHook(_setToken, _reserveAsset, _reserveAssetQuantity, _caller, _to);\n        }\n    }\n\n    /\n     * If a pre-redeem hook has been configured, call the external-protocol contract.\n     */\n    function _callPreRedeemHooks(ISetToken _setToken, uint256 _setQuantity, address _caller, address _to) internal {\n        INAVIssuanceHook preRedeemHook = navIssuanceSettings[_setToken].managerRedemptionHook;\n        if (address(preRedeemHook) != address(0)) {\n            preRedeemHook.invokePreRedeemHook(_setToken, _setQuantity, _caller, _to);\n        }\n    }\n}'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 05:31:11 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **task_prompt** | /*     Copyright 2020 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol"; import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol"; import { SignedSafeMath } from "@openzeppelin/contracts/math/SignedSafeMath.sol"; import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol"; import { IController } from "../../interfaces/IController.sol"; import { INAVIssuanceHook } from "../../interfaces/INAVIssuanceHook.sol"; import { Invoke } from "../lib/Invoke.sol"; import { ISetToken } from "../../interfaces/ISetToken.sol"; import { IWETH } from "../../interfaces/external/IWETH.sol"; import { ModuleBase } from "../lib/ModuleBase.sol"; import { Position } from "../lib/Position.sol"; import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol"; import { ResourceIdentifier } from "../lib/ResourceIdentifier.sol"; /*  * @title NavIssuanceModule  * @author Set Protocol  *  * Module that enables issuance and redemption with any valid ERC20 token or ETH if allowed by the manager. Sender receives  * a proportional amount of SetTokens on issuance or ERC20 token on redemption based on the calculated net asset value using  * oracle prices. Manager is able to enforce a premium / discount on issuance / redemption to avoid arbitrage and front  * running when relying on oracle prices. Managers can charge a fee (denominated in reserve asset).  / contract NavIssuanceModule is ModuleBase, ReentrancyGuard {     using AddressArrayUtils for address[];     using Invoke for ISetToken;     using Position for ISetToken;     using PreciseUnitMath for uint256;     using PreciseUnitMath for int256;     using ResourceIdentifier for IController;     using SafeMath for uint256;     using SafeCast for int256;     using SafeCast for uint256;     using SignedSafeMath for int256; /* ============ Events ============ */  event SetTokenNAVIssued(     ISetToken indexed _setToken,     address _issuer,     address _to,     address _reserveAsset,     address _hookContract,     uint256 _setTokenQuantity,     uint256 _managerFee,     uint256 _premium );  event SetTokenNAVRedeemed(     ISetToken indexed _setToken,     address _redeemer,     address _to,     address _reserveAsset,     address _hookContract,     uint256 _setTokenQuantity,     uint256 _managerFee,     uint256 _premium );  event ReserveAssetAdded(     ISetToken indexed _setToken,     address _newReserveAsset );  event ReserveAssetRemoved(     ISetToken indexed _setToken,     address _removedReserveAsset );  event PremiumEdited(     ISetToken indexed _setToken,     uint256 _newPremium );  event ManagerFeeEdited(     ISetToken indexed _setToken,     uint256 _newManagerFee,     uint256 _index );  event FeeRecipientEdited(     ISetToken indexed _setToken,     address _feeRecipient );  /* ============ Structs ============ */  struct NAVIssuanceSettings {     INAVIssuanceHook managerIssuanceHook;      // Issuance hook configurations     INAVIssuanceHook managerRedemptionHook;    // Redemption hook configurations     address[] reserveAssets;                       // Allowed reserve assets - Must have a price enabled with the price oracle     address feeRecipient;                          // Manager fee recipient     uint256[2] managerFees;                        // Manager fees. 0 index is issue and 1 index is redeem fee (0.01% = 1e14, 1% = 1e16)     uint256 maxManagerFee;                         // Maximum fee manager is allowed to set for issue and redeem     uint256 premiumPercentage;                     // Premium percentage (0.01% = 1e14, 1% = 1e16). This premium is a buffer around oracle                                                    // prices paid by user to the SetToken, which prevents arbitrage and oracle front running     uint256 maxPremiumPercentage;                  // Maximum premium percentage manager is allowed to set (configured by manager)     uint256 minSetTokenSupply;                     // Minimum SetToken supply required for issuance and redemption                                                    // to prevent dramatic inflationary changes to the SetToken's position multiplier }  struct ActionInfo {     uint256 preFeeReserveQuantity;                 // Reserve value before fees; During issuance, represents raw quantity                                                    // During redeem, represents post-premium value     uint256 protocolFees;                          // Total protocol fees (direct + manager revenue share)     uint256 managerFee;                            // Total manager fee paid in reserve asset     uint256 netFlowQuantity;                       // When issuing, quantity of reserve asset sent to SetToken                                                    // When redeeming, quantity of reserve asset sent to redeemer     uint256 setTokenQuantity;                      // When issuing, quantity of SetTokens minted to mintee                                                    // When redeeming, quantity of SetToken redeemed     uint256 previousSetTokenSupply;                // SetToken supply prior to issue/redeem action     uint256 newSetTokenSupply;                     // SetToken supply after issue/redeem action     int256 newPositionMultiplier;                  // SetToken position multiplier after issue/redeem     uint256 newReservePositionUnit;                // SetToken reserve asset position unit after issue/redeem }  /* ============ State Variables ============ */  // Wrapped ETH address IWETH public immutable weth;  // Mapping of SetToken to NAV issuance settings struct mapping(ISetToken =&gt; NAVIssuanceSettings) public navIssuanceSettings;  // Mapping to efficiently check a SetToken's reserve asset validity // SetToken =&gt; reserveAsset =&gt; isReserveAsset mapping(ISetToken =&gt; mapping(address =&gt; bool)) public isReserveAsset;  /* ============ Constants ============ */  // 0 index stores the manager fee in managerFees array, percentage charged on issue (denominated in reserve asset) uint256 constant internal MANAGER_ISSUE_FEE_INDEX = 0;  // 1 index stores the manager fee percentage in managerFees array, charged on redeem uint256 constant internal MANAGER_REDEEM_FEE_INDEX = 1;  // 0 index stores the manager revenue share protocol fee % on the controller, charged in the issuance function uint256 constant internal PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX = 0;  // 1 index stores the manager revenue share protocol fee % on the controller, charged in the redeem function uint256 constant internal PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX = 1;  // 2 index stores the direct protocol fee % on the controller, charged in the issuance function uint256 constant internal PROTOCOL_ISSUE_DIRECT_FEE_INDEX = 2;  // 3 index stores the direct protocol fee % on the controller, charged in the redeem function uint256 constant internal PROTOCOL_REDEEM_DIRECT_FEE_INDEX = 3;  /* ============ Constructor ============ */  /**  * @param _controller               Address of controller contract  * @param _weth                     Address of wrapped eth  */ constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {     weth = _weth; }  /* ============ External Functions ============ */  /**  * Deposits the allowed reserve asset into the SetToken and mints the appropriate % of Net Asset Value of the SetToken  * to the specified _to address.  *  * @param _setToken                     Instance of the SetToken contract  * @param _reserveAsset                 Address of the reserve asset to issue with  * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with  * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance  * @param _to                           Address to mint SetToken to  */ function issue(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity,     uint256 _minSetTokenReceiveQuantity,     address _to )     external     nonReentrant     onlyValidAndInitializedSet(_setToken) {     _validateCommon(_setToken, _reserveAsset, _reserveAssetQuantity);      _callPreIssueHooks(_setToken, _reserveAsset, _reserveAssetQuantity, msg.sender, _to);      ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, _reserveAsset, _reserveAssetQuantity);      _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);      _transferCollateralAndHandleFees(_setToken, IERC20(_reserveAsset), issueInfo);      _handleIssueStateUpdates(_setToken, _reserveAsset, _to, issueInfo); }  /**  * Wraps ETH and deposits WETH if allowed into the SetToken and mints the appropriate % of Net Asset Value of the SetToken  * to the specified _to address.  *  * @param _setToken                     Instance of the SetToken contract  * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance  * @param _to                           Address to mint SetToken to  */ function issueWithEther(     ISetToken _setToken,     uint256 _minSetTokenReceiveQuantity,     address _to )     external     payable     nonReentrant     onlyValidAndInitializedSet(_setToken) {     weth.deposit{ value: msg.value }();      _validateCommon(_setToken, address(weth), msg.value);      _callPreIssueHooks(_setToken, address(weth), msg.value, msg.sender, _to);      ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, address(weth), msg.value);      _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);      _transferWETHAndHandleFees(_setToken, issueInfo);      _handleIssueStateUpdates(_setToken, address(weth), _to, issueInfo); }  /**  * Redeems a SetToken into a valid reserve asset representing the appropriate % of Net Asset Value of the SetToken  * to the specified _to address. Only valid if there are available reserve units on the SetToken.  *  * @param _setToken                     Instance of the SetToken contract  * @param _reserveAsset                 Address of the reserve asset to redeem with  * @param _setTokenQuantity             Quantity of SetTokens to redeem  * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive  * @param _to                           Address to redeem reserve asset to  */ function redeem(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity,     uint256 _minReserveReceiveQuantity,     address _to )     external     nonReentrant     onlyValidAndInitializedSet(_setToken) {     _validateCommon(_setToken, _reserveAsset, _setTokenQuantity);      _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);      ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, _reserveAsset, _setTokenQuantity);      _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);      _setToken.burn(msg.sender, _setTokenQuantity);      // Instruct the SetToken to transfer the reserve asset back to the user     _setToken.strictInvokeTransfer(         _reserveAsset,         _to,         redeemInfo.netFlowQuantity     );      _handleRedemptionFees(_setToken, _reserveAsset, redeemInfo);      _handleRedeemStateUpdates(_setToken, _reserveAsset, _to, redeemInfo); }  /**  * Redeems a SetToken into Ether (if WETH is valid) representing the appropriate % of Net Asset Value of the SetToken  * to the specified _to address. Only valid if there are available WETH units on the SetToken.  *  * @param _setToken                     Instance of the SetToken contract  * @param _setTokenQuantity             Quantity of SetTokens to redeem  * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive  * @param _to                           Address to redeem reserve asset to  */ function redeemIntoEther(     ISetToken _setToken,     uint256 _setTokenQuantity,     uint256 _minReserveReceiveQuantity,     address payable _to )     external     nonReentrant     onlyValidAndInitializedSet(_setToken) {     _validateCommon(_setToken, address(weth), _setTokenQuantity);      _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);      ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, address(weth), _setTokenQuantity);      _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);      _setToken.burn(msg.sender, _setTokenQuantity);      // Instruct the SetToken to transfer WETH from SetToken to module     _setToken.strictInvokeTransfer(         address(weth),         address(this),         redeemInfo.netFlowQuantity     );      weth.withdraw(redeemInfo.netFlowQuantity);      _to.transfer(redeemInfo.netFlowQuantity);      _handleRedemptionFees(_setToken, address(weth), redeemInfo);      _handleRedeemStateUpdates(_setToken, address(weth), _to, redeemInfo); }  /**  * SET MANAGER ONLY. Add an allowed reserve asset  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset to add  */ function addReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {     require(!isReserveAsset[_setToken][_reserveAsset], "Reserve asset already exists");      navIssuanceSettings[_setToken].reserveAssets.push(_reserveAsset);     isReserveAsset[_setToken][_reserveAsset] = true;      emit ReserveAssetAdded(_setToken, _reserveAsset); }  /**  * SET MANAGER ONLY. Remove a reserve asset  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset to remove  */ function removeReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {     require(isReserveAsset[_setToken][_reserveAsset], "Reserve asset does not exist");      navIssuanceSettings[_setToken].reserveAssets = navIssuanceSettings[_setToken].reserveAssets.remove(_reserveAsset);     delete isReserveAsset[_setToken][_reserveAsset];      emit ReserveAssetRemoved(_setToken, _reserveAsset); }  /**  * SET MANAGER ONLY. Edit the premium percentage  *  * @param _setToken                     Instance of the SetToken  * @param _premiumPercentage            Premium percentage in 10e16 (e.g. 10e16 = 1%)  */ function editPremium(ISetToken _setToken, uint256 _premiumPercentage) external onlyManagerAndValidSet(_setToken) {     require(_premiumPercentage &lt;= navIssuanceSettings[_setToken].maxPremiumPercentage, "Premium must be less than maximum allowed");      navIssuanceSettings[_setToken].premiumPercentage = _premiumPercentage;      emit PremiumEdited(_setToken, _premiumPercentage); }  /**  * SET MANAGER ONLY. Edit manager fee  *  * @param _setToken                     Instance of the SetToken  * @param _managerFeePercentage         Manager fee percentage in 10e16 (e.g. 10e16 = 1%)  * @param _managerFeeIndex              Manager fee index. 0 index is issue fee, 1 index is redeem fee  */ function editManagerFee(     ISetToken _setToken,     uint256 _managerFeePercentage,     uint256 _managerFeeIndex )     external     onlyManagerAndValidSet(_setToken) {     require(_managerFeePercentage &lt;= navIssuanceSettings[_setToken].maxManagerFee, "Manager fee must be less than maximum allowed");      navIssuanceSettings[_setToken].managerFees[_managerFeeIndex] = _managerFeePercentage;      emit ManagerFeeEdited(_setToken, _managerFeePercentage, _managerFeeIndex); }  /**  * SET MANAGER ONLY. Edit the manager fee recipient  *  * @param _setToken                     Instance of the SetToken  * @param _managerFeeRecipient          Manager fee recipient  */ function editFeeRecipient(ISetToken _setToken, address _managerFeeRecipient) external onlyManagerAndValidSet(_setToken) {     require(_managerFeeRecipient != address(0), "Fee recipient must not be 0 address");      navIssuanceSettings[_setToken].feeRecipient = _managerFeeRecipient;      emit FeeRecipientEdited(_setToken, _managerFeeRecipient); }  /**  * SET MANAGER ONLY. Initializes this module to the SetToken with hooks, allowed reserve assets,  * fees and issuance premium. Only callable by the SetToken's manager. Hook addresses are optional.  * Address(0) means that no hook will be called.  *  * @param _setToken                     Instance of the SetToken to issue  * @param _navIssuanceSettings          NAVIssuanceSettings struct defining parameters  */ function initialize(     ISetToken _setToken,     NAVIssuanceSettings memory _navIssuanceSettings )     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     require(_navIssuanceSettings.reserveAssets.length &gt; 0, "Reserve assets must be greater than 0");     require(_navIssuanceSettings.maxManagerFee &lt; PreciseUnitMath.preciseUnit(), "Max manager fee must be less than 100%");     require(_navIssuanceSettings.maxPremiumPercentage &lt; PreciseUnitMath.preciseUnit(), "Max premium percentage must be less than 100%");     require(_navIssuanceSettings.managerFees[0] &lt;= _navIssuanceSettings.maxManagerFee, "Manager issue fee must be less than max");     require(_navIssuanceSettings.managerFees[1] &lt;= _navIssuanceSettings.maxManagerFee, "Manager redeem fee must be less than max");     require(_navIssuanceSettings.premiumPercentage &lt;= _navIssuanceSettings.maxPremiumPercentage, "Premium must be less than max");     require(_navIssuanceSettings.feeRecipient != address(0), "Fee Recipient must be non-zero address.");     // Initial mint of Set cannot use NAVIssuance since minSetTokenSupply must be &gt; 0     require(_navIssuanceSettings.minSetTokenSupply &gt; 0, "Min SetToken supply must be greater than 0");      for (uint256 i = 0; i &lt; _navIssuanceSettings.reserveAssets.length; i++) {         require(!isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]], "Reserve assets must be unique");         isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]] = true;     }      navIssuanceSettings[_setToken] = _navIssuanceSettings;      _setToken.initializeModule(); }  /**  * Removes this module from the SetToken, via call by the SetToken. Issuance settings and  * reserve asset states are deleted.  */ function removeModule() external override {     ISetToken setToken = ISetToken(msg.sender);     for (uint256 i = 0; i &lt; navIssuanceSettings[setToken].reserveAssets.length; i++) {         delete isReserveAsset[setToken][navIssuanceSettings[setToken].reserveAssets[i]];     }      delete navIssuanceSettings[setToken]; }  receive() external payable {}  /* ============ External Getter Functions ============ */  function getReserveAssets(ISetToken _setToken) external view returns (address[] memory) {     return navIssuanceSettings[_setToken].reserveAssets; }  function getIssuePremium(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     external     view     returns (uint256) {     return _getIssuePremium(_setToken, _reserveAsset, _reserveAssetQuantity); }  function getRedeemPremium(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     external     view     returns (uint256) {     return _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity); }  function getManagerFee(ISetToken _setToken, uint256 _managerFeeIndex) external view returns (uint256) {     return navIssuanceSettings[_setToken].managerFees[_managerFeeIndex]; }  /**  * Get the expected SetTokens minted to recipient on issuance  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with  *  * @return  uint256                     Expected SetTokens to be minted to recipient  */ function getExpectedSetTokenIssueQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     external     view     returns (uint256) {     (,, uint256 netReserveFlow) = _getFees(         _setToken,         _reserveAssetQuantity,         PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_ISSUE_DIRECT_FEE_INDEX,         MANAGER_ISSUE_FEE_INDEX     );      uint256 setTotalSupply = _setToken.totalSupply();      return _getSetTokenMintQuantity(         _setToken,         _reserveAsset,         netReserveFlow,         setTotalSupply     ); }  /**  * Get the expected reserve asset to be redeemed  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _setTokenQuantity             Quantity of SetTokens to redeem  *  * @return  uint256                     Expected reserve asset quantity redeemed  */ function getExpectedReserveRedeemQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     external     view     returns (uint256) {     uint256 preFeeReserveQuantity = _getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);      (,, uint256 netReserveFlows) = _getFees(         _setToken,         preFeeReserveQuantity,         PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_REDEEM_DIRECT_FEE_INDEX,         MANAGER_REDEEM_FEE_INDEX     );      return netReserveFlows; }  /**  * Checks if issue is valid  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with  *  * @return  bool                        Returns true if issue is valid  */ function isIssueValid(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     external     view     returns (bool) {     uint256 setTotalSupply = _setToken.totalSupply();  return _reserveAssetQuantity != 0         &amp;&amp; isReserveAsset[_setToken][_reserveAsset]         &amp;&amp; setTotalSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply; }  /**  * Checks if redeem is valid  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _setTokenQuantity             Quantity of SetTokens to redeem  *  * @return  bool                        Returns true if redeem is valid  */ function isRedeemValid(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     external     view     returns (bool) {     uint256 setTotalSupply = _setToken.totalSupply();      if (         _setTokenQuantity == 0         || !isReserveAsset[_setToken][_reserveAsset]         || setTotalSupply &lt; navIssuanceSettings[_setToken].minSetTokenSupply.add(_setTokenQuantity)     ) {         return false;     } else {         uint256 totalRedeemValue =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);          (,, uint256 expectedRedeemQuantity) = _getFees(             _setToken,             totalRedeemValue,             PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,             PROTOCOL_REDEEM_DIRECT_FEE_INDEX,             MANAGER_REDEEM_FEE_INDEX         );          uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();          return existingUnit.preciseMul(setTotalSupply) &gt;= expectedRedeemQuantity;     } }  /* ============ Internal Functions ============ */  function _validateCommon(ISetToken _setToken, address _reserveAsset, uint256 _quantity) internal view {     require(_quantity &gt; 0, "Quantity must be &gt; 0");     require(isReserveAsset[_setToken][_reserveAsset], "Must be valid reserve asset"); }  function _validateIssuanceInfo(ISetToken _setToken, uint256 _minSetTokenReceiveQuantity, ActionInfo memory _issueInfo) internal view {     // Check that total supply is greater than min supply needed for issuance     // Note: A min supply amount is needed to avoid division by 0 when SetToken supply is 0     require(         _issueInfo.previousSetTokenSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply,         "Supply must be greater than minimum to enable issuance"     );      require(_issueInfo.setTokenQuantity &gt;= _minSetTokenReceiveQuantity, "Must be greater than min SetToken"); }  function _validateRedemptionInfo(     ISetToken _setToken,     uint256 _minReserveReceiveQuantity,     ActionInfo memory _redeemInfo )     internal     view {     // Check that new supply is more than min supply needed for redemption     // Note: A min supply amount is needed to avoid division by 0 when redeeming SetToken to 0     require(         _redeemInfo.newSetTokenSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply,         "Supply must be greater than minimum to enable redemption"     );      require(_redeemInfo.netFlowQuantity &gt;= _minReserveReceiveQuantity, "Must be greater than min receive reserve quantity"); }  function _createIssuanceInfo(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     internal     view     returns (ActionInfo memory) {     ActionInfo memory issueInfo;      issueInfo.previousSetTokenSupply = _setToken.totalSupply();      issueInfo.preFeeReserveQuantity = _reserveAssetQuantity;      (issueInfo.protocolFees, issueInfo.managerFee, issueInfo.netFlowQuantity) = _getFees(         _setToken,         issueInfo.preFeeReserveQuantity,         PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_ISSUE_DIRECT_FEE_INDEX,         MANAGER_ISSUE_FEE_INDEX     );      issueInfo.setTokenQuantity = _getSetTokenMintQuantity(         _setToken,         _reserveAsset,         issueInfo.netFlowQuantity,         issueInfo.previousSetTokenSupply     );      (issueInfo.newSetTokenSupply, issueInfo.newPositionMultiplier) = _getIssuePositionMultiplier(_setToken, issueInfo);      issueInfo.newReservePositionUnit = _getIssuePositionUnit(_setToken, _reserveAsset, issueInfo);      return issueInfo; }  function _createRedemptionInfo(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     internal     view     returns (ActionInfo memory) {     ActionInfo memory redeemInfo;      redeemInfo.setTokenQuantity = _setTokenQuantity;      redeemInfo.preFeeReserveQuantity =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);      (redeemInfo.protocolFees, redeemInfo.managerFee, redeemInfo.netFlowQuantity) = _getFees(         _setToken,         redeemInfo.preFeeReserveQuantity,         PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_REDEEM_DIRECT_FEE_INDEX,         MANAGER_REDEEM_FEE_INDEX     );      redeemInfo.previousSetTokenSupply = _setToken.totalSupply();      (redeemInfo.newSetTokenSupply, redeemInfo.newPositionMultiplier) = _getRedeemPositionMultiplier(_setToken, _setTokenQuantity, redeemInfo);      redeemInfo.newReservePositionUnit = _getRedeemPositionUnit(_setToken, _reserveAsset, redeemInfo);      return redeemInfo; }  /**  * Transfer reserve asset from user to SetToken and fees from user to appropriate fee recipients  */ function _transferCollateralAndHandleFees(ISetToken _setToken, IERC20 _reserveAsset, ActionInfo memory _issueInfo) internal {     transferFrom(_reserveAsset, msg.sender, address(_setToken), _issueInfo.netFlowQuantity);      if (_issueInfo.protocolFees &gt; 0) {         transferFrom(_reserveAsset, msg.sender, controller.feeRecipient(), _issueInfo.protocolFees);     }      if (_issueInfo.managerFee &gt; 0) {         transferFrom(_reserveAsset, msg.sender, navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);     } }   /**   * Transfer WETH from module to SetToken and fees from module to appropriate fee recipients  */ function _transferWETHAndHandleFees(ISetToken _setToken, ActionInfo memory _issueInfo) internal {     weth.transfer(address(_setToken), _issueInfo.netFlowQuantity);      if (_issueInfo.protocolFees &gt; 0) {         weth.transfer(controller.feeRecipient(), _issueInfo.protocolFees);     }      if (_issueInfo.managerFee &gt; 0) {         weth.transfer(navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);     } }  function _handleIssueStateUpdates(     ISetToken _setToken,     address _reserveAsset,     address _to,     ActionInfo memory _issueInfo )     internal {     _setToken.editPositionMultiplier(_issueInfo.newPositionMultiplier);      _setToken.editDefaultPosition(_reserveAsset, _issueInfo.newReservePositionUnit);      _setToken.mint(_to, _issueInfo.setTokenQuantity);      emit SetTokenNAVIssued(         _setToken,         msg.sender,         _to,         _reserveAsset,         address(navIssuanceSettings[_setToken].managerIssuanceHook),         _issueInfo.setTokenQuantity,         _issueInfo.managerFee,         _issueInfo.protocolFees     ); }  function _handleRedeemStateUpdates(     ISetToken _setToken,     address _reserveAsset,     address _to,     ActionInfo memory _redeemInfo )     internal {     _setToken.editPositionMultiplier(_redeemInfo.newPositionMultiplier);      _setToken.editDefaultPosition(_reserveAsset, _redeemInfo.newReservePositionUnit);      emit SetTokenNAVRedeemed(         _setToken,         msg.sender,         _to,         _reserveAsset,         address(navIssuanceSettings[_setToken].managerRedemptionHook),         _redeemInfo.setTokenQuantity,         _redeemInfo.managerFee,         _redeemInfo.protocolFees     ); }  function _handleRedemptionFees(ISetToken _setToken, address _reserveAsset, ActionInfo memory _redeemInfo) internal {     // Instruct the SetToken to transfer protocol fee to fee recipient if there is a fee     payProtocolFeeFromSetToken(_setToken, _reserveAsset, _redeemInfo.protocolFees);      // Instruct the SetToken to transfer manager fee to manager fee recipient if there is a fee     if (_redeemInfo.managerFee &gt; 0) {         _setToken.strictInvokeTransfer(             _reserveAsset,             navIssuanceSettings[_setToken].feeRecipient,             _redeemInfo.managerFee         );     } }  /**  * Returns the issue premium percentage. Virtual function that can be overridden in future versions of the module  * and can contain arbitrary logic to calculate the issuance premium.  */ function _getIssuePremium(     ISetToken _setToken,     address /* _reserveAsset */,     uint256 /* _reserveAssetQuantity */ )     virtual     internal     view     returns (uint256) {     return navIssuanceSettings[_setToken].premiumPercentage; }  /**  * Returns the redeem premium percentage. Virtual function that can be overridden in future versions of the module  * and can contain arbitrary logic to calculate the redemption premium.  */ function _getRedeemPremium(     ISetToken _setToken,     address /* _reserveAsset */,     uint256 /* _setTokenQuantity */ )     virtual     internal     view     returns (uint256) {     return navIssuanceSettings[_setToken].premiumPercentage; }  /**  * Returns the fees attributed to the manager and the protocol. The fees are calculated as follows:  *  * ManagerFee = (manager fee % - % to protocol) * reserveAssetQuantity  * Protocol Fee = (% manager fee share + direct fee %) * reserveAssetQuantity  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAssetQuantity         Quantity of reserve asset to calculate fees from  * @param _protocolManagerFeeIndex      Index to pull rev share NAV Issuance fee from the Controller  * @param _protocolDirectFeeIndex       Index to pull direct NAV issuance fee from the Controller  * @param _managerFeeIndex              Index from NAVIssuanceSettings (0 = issue fee, 1 = redeem fee)  *  * @return  uint256                     Fees paid to the protocol in reserve asset  * @return  uint256                     Fees paid to the manager in reserve asset  * @return  uint256                     Net reserve to user net of fees  */ function _getFees(     ISetToken _setToken,     uint256 _reserveAssetQuantity,     uint256 _protocolManagerFeeIndex,     uint256 _protocolDirectFeeIndex,     uint256 _managerFeeIndex )     internal     view     returns (uint256, uint256, uint256) {     (uint256 protocolFeePercentage, uint256 managerFeePercentage) = _getProtocolAndManagerFeePercentages(         _setToken,         _protocolManagerFeeIndex,         _protocolDirectFeeIndex,         _managerFeeIndex     );      // Calculate total notional fees     uint256 protocolFees = protocolFeePercentage.preciseMul(_reserveAssetQuantity);     uint256 managerFee = managerFeePercentage.preciseMul(_reserveAssetQuantity);      uint256 netReserveFlow = _reserveAssetQuantity.sub(protocolFees).sub(managerFee);      return (protocolFees, managerFee, netReserveFlow); }  function _getProtocolAndManagerFeePercentages(     ISetToken _setToken,     uint256 _protocolManagerFeeIndex,     uint256 _protocolDirectFeeIndex,     uint256 _managerFeeIndex )     internal     view     returns(uint256, uint256) {     // Get protocol fee percentages     uint256 protocolDirectFeePercent = controller.getModuleFee(address(this), _protocolDirectFeeIndex);     uint256 protocolManagerShareFeePercent = controller.getModuleFee(address(this), _protocolManagerFeeIndex);     uint256 managerFeePercent = navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];      // Calculate revenue share split percentage     uint256 protocolRevenueSharePercentage = protocolManagerShareFeePercent.preciseMul(managerFeePercent);     uint256 managerRevenueSharePercentage = managerFeePercent.sub(protocolRevenueSharePercentage);     uint256 totalProtocolFeePercentage = protocolRevenueSharePercentage.add(protocolDirectFeePercent);      return (totalProtocolFeePercentage, managerRevenueSharePercentage); }  function _getSetTokenMintQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _netReserveFlows,            // Value of reserve asset net of fees     uint256 _setTotalSupply )     internal     view     returns (uint256) {     uint256 premiumPercentage = _getIssuePremium(_setToken, _reserveAsset, _netReserveFlows);     uint256 premiumValue = _netReserveFlows.preciseMul(premiumPercentage);      // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (1e18)     // Reverts if price is not found     uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);      // Get reserve asset decimals     uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();     uint256 normalizedTotalReserveQuantityNetFees = _netReserveFlows.preciseDiv(10 ** reserveAssetDecimals);     uint256 normalizedTotalReserveQuantityNetFeesAndPremium = _netReserveFlows.sub(premiumValue).preciseDiv(10 ** reserveAssetDecimals);      // Calculate SetTokens to mint to issuer     uint256 denominator = _setTotalSupply.preciseMul(setTokenValuation).add(normalizedTotalReserveQuantityNetFees).sub(normalizedTotalReserveQuantityNetFeesAndPremium);     return normalizedTotalReserveQuantityNetFeesAndPremium.preciseMul(_setTotalSupply).preciseDiv(denominator); }  function _getRedeemReserveQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     internal     view     returns (uint256) {     // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (10e18)     // Reverts if price is not found     uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);      uint256 totalRedeemValueInPreciseUnits = _setTokenQuantity.preciseMul(setTokenValuation);     // Get reserve asset decimals     uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();     uint256 prePremiumReserveQuantity = totalRedeemValueInPreciseUnits.preciseMul(10 ** reserveAssetDecimals);      uint256 premiumPercentage = _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);     uint256 premiumQuantity = prePremiumReserveQuantity.preciseMulCeil(premiumPercentage);      return prePremiumReserveQuantity.sub(premiumQuantity); }  /**  * The new position multiplier is calculated as follows:  * inflationPercentage = (newSupply - oldSupply) / newSupply  * newMultiplier = (1 - inflationPercentage) * positionMultiplier  */ function _getIssuePositionMultiplier(     ISetToken _setToken,     ActionInfo memory _issueInfo )     internal     view     returns (uint256, int256) {     // Calculate inflation and new position multiplier. Note: Round inflation up in order to round position multiplier down     uint256 newTotalSupply = _issueInfo.setTokenQuantity.add(_issueInfo.previousSetTokenSupply);     int256 newPositionMultiplier = _setToken.positionMultiplier()         .mul(_issueInfo.previousSetTokenSupply.toInt256())         .div(newTotalSupply.toInt256());      return (newTotalSupply, newPositionMultiplier); }  /**  * Calculate deflation and new position multiplier. Note: Round deflation down in order to round position multiplier down  *  * The new position multiplier is calculated as follows:  * deflationPercentage = (oldSupply - newSupply) / newSupply  * newMultiplier = (1 + deflationPercentage) * positionMultiplier  */ function _getRedeemPositionMultiplier(     ISetToken _setToken,     uint256 _setTokenQuantity,     ActionInfo memory _redeemInfo )     internal     view     returns (uint256, int256) {     uint256 newTotalSupply = _redeemInfo.previousSetTokenSupply.sub(_setTokenQuantity);     int256 newPositionMultiplier = _setToken.positionMultiplier()         .mul(_redeemInfo.previousSetTokenSupply.toInt256())         .div(newTotalSupply.toInt256());      return (newTotalSupply, newPositionMultiplier); }  /**  * The new position reserve asset unit is calculated as follows:  * totalReserve = (oldUnit * oldSetTokenSupply) + reserveQuantity  * newUnit = totalReserve / newSetTokenSupply  */ function _getIssuePositionUnit(     ISetToken _setToken,     address _reserveAsset,     ActionInfo memory _issueInfo )     internal     view     returns (uint256) {     uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();     uint256 totalReserve = existingUnit         .preciseMul(_issueInfo.previousSetTokenSupply)         .add(_issueInfo.netFlowQuantity);      return totalReserve.preciseDiv(_issueInfo.newSetTokenSupply); }  /**  * The new position reserve asset unit is calculated as follows:  * totalReserve = (oldUnit * oldSetTokenSupply) - reserveQuantityToSendOut  * newUnit = totalReserve / newSetTokenSupply  */ function _getRedeemPositionUnit(     ISetToken _setToken,     address _reserveAsset,     ActionInfo memory _redeemInfo )     internal     view     returns (uint256) {     uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();     uint256 totalExistingUnits = existingUnit.preciseMul(_redeemInfo.previousSetTokenSupply);      uint256 outflow = _redeemInfo.netFlowQuantity.add(_redeemInfo.protocolFees).add(_redeemInfo.managerFee);      // Require withdrawable quantity is greater than existing collateral     require(totalExistingUnits &gt;= outflow, "Must be greater than total available collateral");      return totalExistingUnits.sub(outflow).preciseDiv(_redeemInfo.newSetTokenSupply); }  /**  * If a pre-issue hook has been configured, call the external-protocol contract. Pre-issue hook logic  * can contain arbitrary logic including validations, external function calls, etc.  */ function _callPreIssueHooks(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity,     address _caller,     address _to )     internal {     INAVIssuanceHook preIssueHook = navIssuanceSettings[_setToken].managerIssuanceHook;     if (address(preIssueHook) != address(0)) {         preIssueHook.invokePreIssueHook(_setToken, _reserveAsset, _reserveAssetQuantity, _caller, _to);     } }  /**  * If a pre-redeem hook has been configured, call the external-protocol contract.  */ function _callPreRedeemHooks(ISetToken _setToken, uint256 _setQuantity, address _caller, address _to) internal {     INAVIssuanceHook preRedeemHook = navIssuanceSettings[_setToken].managerRedemptionHook;     if (address(preRedeemHook) != address(0)) {         preRedeemHook.invokePreRedeemHook(_setToken, _setQuantity, _caller, _to);     } }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 05:31:11 INFO] Chief Executive Officer: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: /*
    Copyright 2020 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";
import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";
import { SignedSafeMath } from "@openzeppelin/contracts/math/SignedSafeMath.sol";

import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";
import { IController } from "../../interfaces/IController.sol";
import { INAVIssuanceHook } from "../../interfaces/INAVIssuanceHook.sol";
import { Invoke } from "../lib/Invoke.sol";
import { ISetToken } from "../../interfaces/ISetToken.sol";
import { IWETH } from "../../interfaces/external/IWETH.sol";
import { ModuleBase } from "../lib/ModuleBase.sol";
import { Position } from "../lib/Position.sol";
import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";
import { ResourceIdentifier } from "../lib/ResourceIdentifier.sol";


/**
 * @title NavIssuanceModule
 * @author Set Protocol
 *
 * Module that enables issuance and redemption with any valid ERC20 token or ETH if allowed by the manager. Sender receives
 * a proportional amount of SetTokens on issuance or ERC20 token on redemption based on the calculated net asset value using
 * oracle prices. Manager is able to enforce a premium / discount on issuance / redemption to avoid arbitrage and front
 * running when relying on oracle prices. Managers can charge a fee (denominated in reserve asset).
 */
contract NavIssuanceModule is ModuleBase, ReentrancyGuard {
    using AddressArrayUtils for address[];
    using Invoke for ISetToken;
    using Position for ISetToken;
    using PreciseUnitMath for uint256;
    using PreciseUnitMath for int256;
    using ResourceIdentifier for IController;
    using SafeMath for uint256;
    using SafeCast for int256;
    using SafeCast for uint256;
    using SignedSafeMath for int256;

    /* ============ Events ============ */

    event SetTokenNAVIssued(
        ISetToken indexed _setToken,
        address _issuer,
        address _to,
        address _reserveAsset,
        address _hookContract,
        uint256 _setTokenQuantity,
        uint256 _managerFee,
        uint256 _premium
    );

    event SetTokenNAVRedeemed(
        ISetToken indexed _setToken,
        address _redeemer,
        address _to,
        address _reserveAsset,
        address _hookContract,
        uint256 _setTokenQuantity,
        uint256 _managerFee,
        uint256 _premium
    );

    event ReserveAssetAdded(
        ISetToken indexed _setToken,
        address _newReserveAsset
    );

    event ReserveAssetRemoved(
        ISetToken indexed _setToken,
        address _removedReserveAsset
    );

    event PremiumEdited(
        ISetToken indexed _setToken,
        uint256 _newPremium
    );

    event ManagerFeeEdited(
        ISetToken indexed _setToken,
        uint256 _newManagerFee,
        uint256 _index
    );

    event FeeRecipientEdited(
        ISetToken indexed _setToken,
        address _feeRecipient
    );

    /* ============ Structs ============ */

    struct NAVIssuanceSettings {
        INAVIssuanceHook managerIssuanceHook;      // Issuance hook configurations
        INAVIssuanceHook managerRedemptionHook;    // Redemption hook configurations
        address[] reserveAssets;                       // Allowed reserve assets - Must have a price enabled with the price oracle
        address feeRecipient;                          // Manager fee recipient
        uint256[2] managerFees;                        // Manager fees. 0 index is issue and 1 index is redeem fee (0.01% = 1e14, 1% = 1e16)
        uint256 maxManagerFee;                         // Maximum fee manager is allowed to set for issue and redeem
        uint256 premiumPercentage;                     // Premium percentage (0.01% = 1e14, 1% = 1e16). This premium is a buffer around oracle
                                                       // prices paid by user to the SetToken, which prevents arbitrage and oracle front running
        uint256 maxPremiumPercentage;                  // Maximum premium percentage manager is allowed to set (configured by manager)
        uint256 minSetTokenSupply;                     // Minimum SetToken supply required for issuance and redemption
                                                       // to prevent dramatic inflationary changes to the SetToken's position multiplier
    }

    struct ActionInfo {
        uint256 preFeeReserveQuantity;                 // Reserve value before fees; During issuance, represents raw quantity
                                                       // During redeem, represents post-premium value
        uint256 protocolFees;                          // Total protocol fees (direct + manager revenue share)
        uint256 managerFee;                            // Total manager fee paid in reserve asset
        uint256 netFlowQuantity;                       // When issuing, quantity of reserve asset sent to SetToken
                                                       // When redeeming, quantity of reserve asset sent to redeemer
        uint256 setTokenQuantity;                      // When issuing, quantity of SetTokens minted to mintee
                                                       // When redeeming, quantity of SetToken redeemed
        uint256 previousSetTokenSupply;                // SetToken supply prior to issue/redeem action
        uint256 newSetTokenSupply;                     // SetToken supply after issue/redeem action
        int256 newPositionMultiplier;                  // SetToken position multiplier after issue/redeem
        uint256 newReservePositionUnit;                // SetToken reserve asset position unit after issue/redeem
    }

    /* ============ State Variables ============ */

    // Wrapped ETH address
    IWETH public immutable weth;

    // Mapping of SetToken to NAV issuance settings struct
    mapping(ISetToken => NAVIssuanceSettings) public navIssuanceSettings;

    // Mapping to efficiently check a SetToken's reserve asset validity
    // SetToken => reserveAsset => isReserveAsset
    mapping(ISetToken => mapping(address => bool)) public isReserveAsset;

    /* ============ Constants ============ */

    // 0 index stores the manager fee in managerFees array, percentage charged on issue (denominated in reserve asset)
    uint256 constant internal MANAGER_ISSUE_FEE_INDEX = 0;

    // 1 index stores the manager fee percentage in managerFees array, charged on redeem
    uint256 constant internal MANAGER_REDEEM_FEE_INDEX = 1;

    // 0 index stores the manager revenue share protocol fee % on the controller, charged in the issuance function
    uint256 constant internal PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX = 0;

    // 1 index stores the manager revenue share protocol fee % on the controller, charged in the redeem function
    uint256 constant internal PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX = 1;

    // 2 index stores the direct protocol fee % on the controller, charged in the issuance function
    uint256 constant internal PROTOCOL_ISSUE_DIRECT_FEE_INDEX = 2;

    // 3 index stores the direct protocol fee % on the controller, charged in the redeem function
    uint256 constant internal PROTOCOL_REDEEM_DIRECT_FEE_INDEX = 3;

    /* ============ Constructor ============ */

    /**
     * @param _controller               Address of controller contract
     * @param _weth                     Address of wrapped eth
     */
    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {
        weth = _weth;
    }

    /* ============ External Functions ============ */

    /**
     * Deposits the allowed reserve asset into the SetToken and mints the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _reserveAsset                 Address of the reserve asset to issue with
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance
     * @param _to                           Address to mint SetToken to
     */
    function issue(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity,
        uint256 _minSetTokenReceiveQuantity,
        address _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, _reserveAsset, _reserveAssetQuantity);

        _callPreIssueHooks(_setToken, _reserveAsset, _reserveAssetQuantity, msg.sender, _to);

        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, _reserveAsset, _reserveAssetQuantity);

        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);

        _transferCollateralAndHandleFees(_setToken, IERC20(_reserveAsset), issueInfo);

        _handleIssueStateUpdates(_setToken, _reserveAsset, _to, issueInfo);
    }

    /**
     * Wraps ETH and deposits WETH if allowed into the SetToken and mints the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance
     * @param _to                           Address to mint SetToken to
     */
    function issueWithEther(
        ISetToken _setToken,
        uint256 _minSetTokenReceiveQuantity,
        address _to
    )
        external
        payable
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        weth.deposit{ value: msg.value }();

        _validateCommon(_setToken, address(weth), msg.value);

        _callPreIssueHooks(_setToken, address(weth), msg.value, msg.sender, _to);

        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, address(weth), msg.value);

        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);

        _transferWETHAndHandleFees(_setToken, issueInfo);

        _handleIssueStateUpdates(_setToken, address(weth), _to, issueInfo);
    }

    /**
     * Redeems a SetToken into a valid reserve asset representing the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address. Only valid if there are available reserve units on the SetToken.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _reserveAsset                 Address of the reserve asset to redeem with
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive
     * @param _to                           Address to redeem reserve asset to
     */
    function redeem(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity,
        uint256 _minReserveReceiveQuantity,
        address _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, _reserveAsset, _setTokenQuantity);

        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);

        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, _reserveAsset, _setTokenQuantity);

        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);

        _setToken.burn(msg.sender, _setTokenQuantity);

        // Instruct the SetToken to transfer the reserve asset back to the user
        _setToken.strictInvokeTransfer(
            _reserveAsset,
            _to,
            redeemInfo.netFlowQuantity
        );

        _handleRedemptionFees(_setToken, _reserveAsset, redeemInfo);

        _handleRedeemStateUpdates(_setToken, _reserveAsset, _to, redeemInfo);
    }

    /**
     * Redeems a SetToken into Ether (if WETH is valid) representing the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address. Only valid if there are available WETH units on the SetToken.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive
     * @param _to                           Address to redeem reserve asset to
     */
    function redeemIntoEther(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        uint256 _minReserveReceiveQuantity,
        address payable _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, address(weth), _setTokenQuantity);

        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);

        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, address(weth), _setTokenQuantity);

        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);

        _setToken.burn(msg.sender, _setTokenQuantity);

        // Instruct the SetToken to transfer WETH from SetToken to module
        _setToken.strictInvokeTransfer(
            address(weth),
            address(this),
            redeemInfo.netFlowQuantity
        );

        weth.withdraw(redeemInfo.netFlowQuantity);

        _to.transfer(redeemInfo.netFlowQuantity);

        _handleRedemptionFees(_setToken, address(weth), redeemInfo);

        _handleRedeemStateUpdates(_setToken, address(weth), _to, redeemInfo);
    }

    /**
     * SET MANAGER ONLY. Add an allowed reserve asset
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset to add
     */
    function addReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {
        require(!isReserveAsset[_setToken][_reserveAsset], "Reserve asset already exists");

        navIssuanceSettings[_setToken].reserveAssets.push(_reserveAsset);
        isReserveAsset[_setToken][_reserveAsset] = true;

        emit ReserveAssetAdded(_setToken, _reserveAsset);
    }

    /**
     * SET MANAGER ONLY. Remove a reserve asset
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset to remove
     */
    function removeReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {
        require(isReserveAsset[_setToken][_reserveAsset], "Reserve asset does not exist");

        navIssuanceSettings[_setToken].reserveAssets = navIssuanceSettings[_setToken].reserveAssets.remove(_reserveAsset);
        delete isReserveAsset[_setToken][_reserveAsset];

        emit ReserveAssetRemoved(_setToken, _reserveAsset);
    }

    /**
     * SET MANAGER ONLY. Edit the premium percentage
     *
     * @param _setToken                     Instance of the SetToken
     * @param _premiumPercentage            Premium percentage in 10e16 (e.g. 10e16 = 1%)
     */
    function editPremium(ISetToken _setToken, uint256 _premiumPercentage) external onlyManagerAndValidSet(_setToken) {
        require(_premiumPercentage <= navIssuanceSettings[_setToken].maxPremiumPercentage, "Premium must be less than maximum allowed");

        navIssuanceSettings[_setToken].premiumPercentage = _premiumPercentage;

        emit PremiumEdited(_setToken, _premiumPercentage);
    }

    /**
     * SET MANAGER ONLY. Edit manager fee
     *
     * @param _setToken                     Instance of the SetToken
     * @param _managerFeePercentage         Manager fee percentage in 10e16 (e.g. 10e16 = 1%)
     * @param _managerFeeIndex              Manager fee index. 0 index is issue fee, 1 index is redeem fee
     */
    function editManagerFee(
        ISetToken _setToken,
        uint256 _managerFeePercentage,
        uint256 _managerFeeIndex
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        require(_managerFeePercentage <= navIssuanceSettings[_setToken].maxManagerFee, "Manager fee must be less than maximum allowed");

        navIssuanceSettings[_setToken].managerFees[_managerFeeIndex] = _managerFeePercentage;

        emit ManagerFeeEdited(_setToken, _managerFeePercentage, _managerFeeIndex);
    }

    /**
     * SET MANAGER ONLY. Edit the manager fee recipient
     *
     * @param _setToken                     Instance of the SetToken
     * @param _managerFeeRecipient          Manager fee recipient
     */
    function editFeeRecipient(ISetToken _setToken, address _managerFeeRecipient) external onlyManagerAndValidSet(_setToken) {
        require(_managerFeeRecipient != address(0), "Fee recipient must not be 0 address");

        navIssuanceSettings[_setToken].feeRecipient = _managerFeeRecipient;

        emit FeeRecipientEdited(_setToken, _managerFeeRecipient);
    }

    /**
     * SET MANAGER ONLY. Initializes this module to the SetToken with hooks, allowed reserve assets,
     * fees and issuance premium. Only callable by the SetToken's manager. Hook addresses are optional.
     * Address(0) means that no hook will be called.
     *
     * @param _setToken                     Instance of the SetToken to issue
     * @param _navIssuanceSettings          NAVIssuanceSettings struct defining parameters
     */
    function initialize(
        ISetToken _setToken,
        NAVIssuanceSettings memory _navIssuanceSettings
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        require(_navIssuanceSettings.reserveAssets.length > 0, "Reserve assets must be greater than 0");
        require(_navIssuanceSettings.maxManagerFee < PreciseUnitMath.preciseUnit(), "Max manager fee must be less than 100%");
        require(_navIssuanceSettings.maxPremiumPercentage < PreciseUnitMath.preciseUnit(), "Max premium percentage must be less than 100%");
        require(_navIssuanceSettings.managerFees[0] <= _navIssuanceSettings.maxManagerFee, "Manager issue fee must be less than max");
        require(_navIssuanceSettings.managerFees[1] <= _navIssuanceSettings.maxManagerFee, "Manager redeem fee must be less than max");
        require(_navIssuanceSettings.premiumPercentage <= _navIssuanceSettings.maxPremiumPercentage, "Premium must be less than max");
        require(_navIssuanceSettings.feeRecipient != address(0), "Fee Recipient must be non-zero address.");
        // Initial mint of Set cannot use NAVIssuance since minSetTokenSupply must be > 0
        require(_navIssuanceSettings.minSetTokenSupply > 0, "Min SetToken supply must be greater than 0");

        for (uint256 i = 0; i < _navIssuanceSettings.reserveAssets.length; i++) {
            require(!isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]], "Reserve assets must be unique");
            isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]] = true;
        }

        navIssuanceSettings[_setToken] = _navIssuanceSettings;

        _setToken.initializeModule();
    }

    /**
     * Removes this module from the SetToken, via call by the SetToken. Issuance settings and
     * reserve asset states are deleted.
     */
    function removeModule() external override {
        ISetToken setToken = ISetToken(msg.sender);
        for (uint256 i = 0; i < navIssuanceSettings[setToken].reserveAssets.length; i++) {
            delete isReserveAsset[setToken][navIssuanceSettings[setToken].reserveAssets[i]];
        }

        delete navIssuanceSettings[setToken];
    }

    receive() external payable {}

    /* ============ External Getter Functions ============ */

    function getReserveAssets(ISetToken _setToken) external view returns (address[] memory) {
        return navIssuanceSettings[_setToken].reserveAssets;
    }

    function getIssuePremium(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (uint256)
    {
        return _getIssuePremium(_setToken, _reserveAsset, _reserveAssetQuantity);
    }

    function getRedeemPremium(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (uint256)
    {
        return _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);
    }

    function getManagerFee(ISetToken _setToken, uint256 _managerFeeIndex) external view returns (uint256) {
        return navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];
    }

    /**
     * Get the expected SetTokens minted to recipient on issuance
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     *
     * @return  uint256                     Expected SetTokens to be minted to recipient
     */
    function getExpectedSetTokenIssueQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (uint256)
    {
        (,, uint256 netReserveFlow) = _getFees(
            _setToken,
            _reserveAssetQuantity,
            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,
            MANAGER_ISSUE_FEE_INDEX
        );

        uint256 setTotalSupply = _setToken.totalSupply();

        return _getSetTokenMintQuantity(
            _setToken,
            _reserveAsset,
            netReserveFlow,
            setTotalSupply
        );
    }

    /**
     * Get the expected reserve asset to be redeemed
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     *
     * @return  uint256                     Expected reserve asset quantity redeemed
     */
    function getExpectedReserveRedeemQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (uint256)
    {
        uint256 preFeeReserveQuantity = _getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

        (,, uint256 netReserveFlows) = _getFees(
            _setToken,
            preFeeReserveQuantity,
            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
            MANAGER_REDEEM_FEE_INDEX
        );

        return netReserveFlows;
    }

    /**
     * Checks if issue is valid
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     *
     * @return  bool                        Returns true if issue is valid
     */
    function isIssueValid(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (bool)
    {
        uint256 setTotalSupply = _setToken.totalSupply();

    return _reserveAssetQuantity != 0
            && isReserveAsset[_setToken][_reserveAsset]
            && setTotalSupply >= navIssuanceSettings[_setToken].minSetTokenSupply;
    }

    /**
     * Checks if redeem is valid
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     *
     * @return  bool                        Returns true if redeem is valid
     */
    function isRedeemValid(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (bool)
    {
        uint256 setTotalSupply = _setToken.totalSupply();

        if (
            _setTokenQuantity == 0
            || !isReserveAsset[_setToken][_reserveAsset]
            || setTotalSupply < navIssuanceSettings[_setToken].minSetTokenSupply.add(_setTokenQuantity)
        ) {
            return false;
        } else {
            uint256 totalRedeemValue =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

            (,, uint256 expectedRedeemQuantity) = _getFees(
                _setToken,
                totalRedeemValue,
                PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
                PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
                MANAGER_REDEEM_FEE_INDEX
            );

            uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();

            return existingUnit.preciseMul(setTotalSupply) >= expectedRedeemQuantity;
        }
    }

    /* ============ Internal Functions ============ */

    function _validateCommon(ISetToken _setToken, address _reserveAsset, uint256 _quantity) internal view {
        require(_quantity > 0, "Quantity must be > 0");
        require(isReserveAsset[_setToken][_reserveAsset], "Must be valid reserve asset");
    }

    function _validateIssuanceInfo(ISetToken _setToken, uint256 _minSetTokenReceiveQuantity, ActionInfo memory _issueInfo) internal view {
        // Check that total supply is greater than min supply needed for issuance
        // Note: A min supply amount is needed to avoid division by 0 when SetToken supply is 0
        require(
            _issueInfo.previousSetTokenSupply >= navIssuanceSettings[_setToken].minSetTokenSupply,
            "Supply must be greater than minimum to enable issuance"
        );

        require(_issueInfo.setTokenQuantity >= _minSetTokenReceiveQuantity, "Must be greater than min SetToken");
    }

    function _validateRedemptionInfo(
        ISetToken _setToken,
        uint256 _minReserveReceiveQuantity,
        ActionInfo memory _redeemInfo
    )
        internal
        view
    {
        // Check that new supply is more than min supply needed for redemption
        // Note: A min supply amount is needed to avoid division by 0 when redeeming SetToken to 0
        require(
            _redeemInfo.newSetTokenSupply >= navIssuanceSettings[_setToken].minSetTokenSupply,
            "Supply must be greater than minimum to enable redemption"
        );

        require(_redeemInfo.netFlowQuantity >= _minReserveReceiveQuantity, "Must be greater than min receive reserve quantity");
    }

    function _createIssuanceInfo(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        internal
        view
        returns (ActionInfo memory)
    {
        ActionInfo memory issueInfo;

        issueInfo.previousSetTokenSupply = _setToken.totalSupply();

        issueInfo.preFeeReserveQuantity = _reserveAssetQuantity;

        (issueInfo.protocolFees, issueInfo.managerFee, issueInfo.netFlowQuantity) = _getFees(
            _setToken,
            issueInfo.preFeeReserveQuantity,
            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,
            MANAGER_ISSUE_FEE_INDEX
        );

        issueInfo.setTokenQuantity = _getSetTokenMintQuantity(
            _setToken,
            _reserveAsset,
            issueInfo.netFlowQuantity,
            issueInfo.previousSetTokenSupply
        );

        (issueInfo.newSetTokenSupply, issueInfo.newPositionMultiplier) = _getIssuePositionMultiplier(_setToken, issueInfo);

        issueInfo.newReservePositionUnit = _getIssuePositionUnit(_setToken, _reserveAsset, issueInfo);

        return issueInfo;
    }

    function _createRedemptionInfo(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        internal
        view
        returns (ActionInfo memory)
    {
        ActionInfo memory redeemInfo;

        redeemInfo.setTokenQuantity = _setTokenQuantity;

        redeemInfo.preFeeReserveQuantity =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

        (redeemInfo.protocolFees, redeemInfo.managerFee, redeemInfo.netFlowQuantity) = _getFees(
            _setToken,
            redeemInfo.preFeeReserveQuantity,
            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
            MANAGER_REDEEM_FEE_INDEX
        );

        redeemInfo.previousSetTokenSupply = _setToken.totalSupply();

        (redeemInfo.newSetTokenSupply, redeemInfo.newPositionMultiplier) = _getRedeemPositionMultiplier(_setToken, _setTokenQuantity, redeemInfo);

        redeemInfo.newReservePositionUnit = _getRedeemPositionUnit(_setToken, _reserveAsset, redeemInfo);

        return redeemInfo;
    }

    /**
     * Transfer reserve asset from user to SetToken and fees from user to appropriate fee recipients
     */
    function _transferCollateralAndHandleFees(ISetToken _setToken, IERC20 _reserveAsset, ActionInfo memory _issueInfo) internal {
        transferFrom(_reserveAsset, msg.sender, address(_setToken), _issueInfo.netFlowQuantity);

        if (_issueInfo.protocolFees > 0) {
            transferFrom(_reserveAsset, msg.sender, controller.feeRecipient(), _issueInfo.protocolFees);
        }

        if (_issueInfo.managerFee > 0) {
            transferFrom(_reserveAsset, msg.sender, navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);
        }
    }


    /**
      * Transfer WETH from module to SetToken and fees from module to appropriate fee recipients
     */
    function _transferWETHAndHandleFees(ISetToken _setToken, ActionInfo memory _issueInfo) internal {
        weth.transfer(address(_setToken), _issueInfo.netFlowQuantity);

        if (_issueInfo.protocolFees > 0) {
            weth.transfer(controller.feeRecipient(), _issueInfo.protocolFees);
        }

        if (_issueInfo.managerFee > 0) {
            weth.transfer(navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);
        }
    }

    function _handleIssueStateUpdates(
        ISetToken _setToken,
        address _reserveAsset,
        address _to,
        ActionInfo memory _issueInfo
    )
        internal
    {
        _setToken.editPositionMultiplier(_issueInfo.newPositionMultiplier);

        _setToken.editDefaultPosition(_reserveAsset, _issueInfo.newReservePositionUnit);

        _setToken.mint(_to, _issueInfo.setTokenQuantity);

        emit SetTokenNAVIssued(
            _setToken,
            msg.sender,
            _to,
            _reserveAsset,
            address(navIssuanceSettings[_setToken].managerIssuanceHook),
            _issueInfo.setTokenQuantity,
            _issueInfo.managerFee,
            _issueInfo.protocolFees
        );
    }

    function _handleRedeemStateUpdates(
        ISetToken _setToken,
        address _reserveAsset,
        address _to,
        ActionInfo memory _redeemInfo
    )
        internal
    {
        _setToken.editPositionMultiplier(_redeemInfo.newPositionMultiplier);

        _setToken.editDefaultPosition(_reserveAsset, _redeemInfo.newReservePositionUnit);

        emit SetTokenNAVRedeemed(
            _setToken,
            msg.sender,
            _to,
            _reserveAsset,
            address(navIssuanceSettings[_setToken].managerRedemptionHook),
            _redeemInfo.setTokenQuantity,
            _redeemInfo.managerFee,
            _redeemInfo.protocolFees
        );
    }

    function _handleRedemptionFees(ISetToken _setToken, address _reserveAsset, ActionInfo memory _redeemInfo) internal {
        // Instruct the SetToken to transfer protocol fee to fee recipient if there is a fee
        payProtocolFeeFromSetToken(_setToken, _reserveAsset, _redeemInfo.protocolFees);

        // Instruct the SetToken to transfer manager fee to manager fee recipient if there is a fee
        if (_redeemInfo.managerFee > 0) {
            _setToken.strictInvokeTransfer(
                _reserveAsset,
                navIssuanceSettings[_setToken].feeRecipient,
                _redeemInfo.managerFee
            );
        }
    }

    /**
     * Returns the issue premium percentage. Virtual function that can be overridden in future versions of the module
     * and can contain arbitrary logic to calculate the issuance premium.
     */
    function _getIssuePremium(
        ISetToken _setToken,
        address /* _reserveAsset */,
        uint256 /* _reserveAssetQuantity */
    )
        virtual
        internal
        view
        returns (uint256)
    {
        return navIssuanceSettings[_setToken].premiumPercentage;
    }

    /**
     * Returns the redeem premium percentage. Virtual function that can be overridden in future versions of the module
     * and can contain arbitrary logic to calculate the redemption premium.
     */
    function _getRedeemPremium(
        ISetToken _setToken,
        address /* _reserveAsset */,
        uint256 /* _setTokenQuantity */
    )
        virtual
        internal
        view
        returns (uint256)
    {
        return navIssuanceSettings[_setToken].premiumPercentage;
    }

    /**
     * Returns the fees attributed to the manager and the protocol. The fees are calculated as follows:
     *
     * ManagerFee = (manager fee % - % to protocol) * reserveAssetQuantity
     * Protocol Fee = (% manager fee share + direct fee %) * reserveAssetQuantity
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAssetQuantity         Quantity of reserve asset to calculate fees from
     * @param _protocolManagerFeeIndex      Index to pull rev share NAV Issuance fee from the Controller
     * @param _protocolDirectFeeIndex       Index to pull direct NAV issuance fee from the Controller
     * @param _managerFeeIndex              Index from NAVIssuanceSettings (0 = issue fee, 1 = redeem fee)
     *
     * @return  uint256                     Fees paid to the protocol in reserve asset
     * @return  uint256                     Fees paid to the manager in reserve asset
     * @return  uint256                     Net reserve to user net of fees
     */
    function _getFees(
        ISetToken _setToken,
        uint256 _reserveAssetQuantity,
        uint256 _protocolManagerFeeIndex,
        uint256 _protocolDirectFeeIndex,
        uint256 _managerFeeIndex
    )
        internal
        view
        returns (uint256, uint256, uint256)
    {
        (uint256 protocolFeePercentage, uint256 managerFeePercentage) = _getProtocolAndManagerFeePercentages(
            _setToken,
            _protocolManagerFeeIndex,
            _protocolDirectFeeIndex,
            _managerFeeIndex
        );

        // Calculate total notional fees
        uint256 protocolFees = protocolFeePercentage.preciseMul(_reserveAssetQuantity);
        uint256 managerFee = managerFeePercentage.preciseMul(_reserveAssetQuantity);

        uint256 netReserveFlow = _reserveAssetQuantity.sub(protocolFees).sub(managerFee);

        return (protocolFees, managerFee, netReserveFlow);
    }

    function _getProtocolAndManagerFeePercentages(
        ISetToken _setToken,
        uint256 _protocolManagerFeeIndex,
        uint256 _protocolDirectFeeIndex,
        uint256 _managerFeeIndex
    )
        internal
        view
        returns(uint256, uint256)
    {
        // Get protocol fee percentages
        uint256 protocolDirectFeePercent = controller.getModuleFee(address(this), _protocolDirectFeeIndex);
        uint256 protocolManagerShareFeePercent = controller.getModuleFee(address(this), _protocolManagerFeeIndex);
        uint256 managerFeePercent = navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];

        // Calculate revenue share split percentage
        uint256 protocolRevenueSharePercentage = protocolManagerShareFeePercent.preciseMul(managerFeePercent);
        uint256 managerRevenueSharePercentage = managerFeePercent.sub(protocolRevenueSharePercentage);
        uint256 totalProtocolFeePercentage = protocolRevenueSharePercentage.add(protocolDirectFeePercent);

        return (totalProtocolFeePercentage, managerRevenueSharePercentage);
    }

    function _getSetTokenMintQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _netReserveFlows,            // Value of reserve asset net of fees
        uint256 _setTotalSupply
    )
        internal
        view
        returns (uint256)
    {
        uint256 premiumPercentage = _getIssuePremium(_setToken, _reserveAsset, _netReserveFlows);
        uint256 premiumValue = _netReserveFlows.preciseMul(premiumPercentage);

        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (1e18)
        // Reverts if price is not found
        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);

        // Get reserve asset decimals
        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();
        uint256 normalizedTotalReserveQuantityNetFees = _netReserveFlows.preciseDiv(10 ** reserveAssetDecimals);
        uint256 normalizedTotalReserveQuantityNetFeesAndPremium = _netReserveFlows.sub(premiumValue).preciseDiv(10 ** reserveAssetDecimals);

        // Calculate SetTokens to mint to issuer
        uint256 denominator = _setTotalSupply.preciseMul(setTokenValuation).add(normalizedTotalReserveQuantityNetFees).sub(normalizedTotalReserveQuantityNetFeesAndPremium);
        return normalizedTotalReserveQuantityNetFeesAndPremium.preciseMul(_setTotalSupply).preciseDiv(denominator);
    }

    function _getRedeemReserveQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        internal
        view
        returns (uint256)
    {
        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (10e18)
        // Reverts if price is not found
        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);

        uint256 totalRedeemValueInPreciseUnits = _setTokenQuantity.preciseMul(setTokenValuation);
        // Get reserve asset decimals
        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();
        uint256 prePremiumReserveQuantity = totalRedeemValueInPreciseUnits.preciseMul(10 ** reserveAssetDecimals);

        uint256 premiumPercentage = _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);
        uint256 premiumQuantity = prePremiumReserveQuantity.preciseMulCeil(premiumPercentage);

        return prePremiumReserveQuantity.sub(premiumQuantity);
    }

    /**
     * The new position multiplier is calculated as follows:
     * inflationPercentage = (newSupply - oldSupply) / newSupply
     * newMultiplier = (1 - inflationPercentage) * positionMultiplier
     */
    function _getIssuePositionMultiplier(
        ISetToken _setToken,
        ActionInfo memory _issueInfo
    )
        internal
        view
        returns (uint256, int256)
    {
        // Calculate inflation and new position multiplier. Note: Round inflation up in order to round position multiplier down
        uint256 newTotalSupply = _issueInfo.setTokenQuantity.add(_issueInfo.previousSetTokenSupply);
        int256 newPositionMultiplier = _setToken.positionMultiplier()
            .mul(_issueInfo.previousSetTokenSupply.toInt256())
            .div(newTotalSupply.toInt256());

        return (newTotalSupply, newPositionMultiplier);
    }

    /**
     * Calculate deflation and new position multiplier. Note: Round deflation down in order to round position multiplier down
     *
     * The new position multiplier is calculated as follows:
     * deflationPercentage = (oldSupply - newSupply) / newSupply
     * newMultiplier = (1 + deflationPercentage) * positionMultiplier
     */
    function _getRedeemPositionMultiplier(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        ActionInfo memory _redeemInfo
    )
        internal
        view
        returns (uint256, int256)
    {
        uint256 newTotalSupply = _redeemInfo.previousSetTokenSupply.sub(_setTokenQuantity);
        int256 newPositionMultiplier = _setToken.positionMultiplier()
            .mul(_redeemInfo.previousSetTokenSupply.toInt256())
            .div(newTotalSupply.toInt256());

        return (newTotalSupply, newPositionMultiplier);
    }

    /**
     * The new position reserve asset unit is calculated as follows:
     * totalReserve = (oldUnit * oldSetTokenSupply) + reserveQuantity
     * newUnit = totalReserve / newSetTokenSupply
     */
    function _getIssuePositionUnit(
        ISetToken _setToken,
        address _reserveAsset,
        ActionInfo memory _issueInfo
    )
        internal
        view
        returns (uint256)
    {
        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();
        uint256 totalReserve = existingUnit
            .preciseMul(_issueInfo.previousSetTokenSupply)
            .add(_issueInfo.netFlowQuantity);

        return totalReserve.preciseDiv(_issueInfo.newSetTokenSupply);
    }

    /**
     * The new position reserve asset unit is calculated as follows:
     * totalReserve = (oldUnit * oldSetTokenSupply) - reserveQuantityToSendOut
     * newUnit = totalReserve / newSetTokenSupply
     */
    function _getRedeemPositionUnit(
        ISetToken _setToken,
        address _reserveAsset,
        ActionInfo memory _redeemInfo
    )
        internal
        view
        returns (uint256)
    {
        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();
        uint256 totalExistingUnits = existingUnit.preciseMul(_redeemInfo.previousSetTokenSupply);

        uint256 outflow = _redeemInfo.netFlowQuantity.add(_redeemInfo.protocolFees).add(_redeemInfo.managerFee);

        // Require withdrawable quantity is greater than existing collateral
        require(totalExistingUnits >= outflow, "Must be greater than total available collateral");

        return totalExistingUnits.sub(outflow).preciseDiv(_redeemInfo.newSetTokenSupply);
    }

    /**
     * If a pre-issue hook has been configured, call the external-protocol contract. Pre-issue hook logic
     * can contain arbitrary logic including validations, external function calls, etc.
     */
    function _callPreIssueHooks(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity,
        address _caller,
        address _to
    )
        internal
    {
        INAVIssuanceHook preIssueHook = navIssuanceSettings[_setToken].managerIssuanceHook;
        if (address(preIssueHook) != address(0)) {
            preIssueHook.invokePreIssueHook(_setToken, _reserveAsset, _reserveAssetQuantity, _caller, _to);
        }
    }

    /**
     * If a pre-redeem hook has been configured, call the external-protocol contract.
     */
    function _callPreRedeemHooks(ISetToken _setToken, uint256 _setQuantity, address _caller, address _to) internal {
        INAVIssuanceHook preRedeemHook = navIssuanceSettings[_setToken].managerRedemptionHook;
        if (address(preRedeemHook) != address(0)) {
            preRedeemHook.invokePreRedeemHook(_setToken, _setQuantity, _caller, _to);
        }
    }
}.]

We excel in generating innovative approaches and enhancements for Solidity smart contract code.

Here's a Solidity contract provided by the user: "/*
    Copyright 2020 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";
import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";
import { SignedSafeMath } from "@openzeppelin/contracts/math/SignedSafeMath.sol";

import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";
import { IController } from "../../interfaces/IController.sol";
import { INAVIssuanceHook } from "../../interfaces/INAVIssuanceHook.sol";
import { Invoke } from "../lib/Invoke.sol";
import { ISetToken } from "../../interfaces/ISetToken.sol";
import { IWETH } from "../../interfaces/external/IWETH.sol";
import { ModuleBase } from "../lib/ModuleBase.sol";
import { Position } from "../lib/Position.sol";
import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";
import { ResourceIdentifier } from "../lib/ResourceIdentifier.sol";


/**
 * @title NavIssuanceModule
 * @author Set Protocol
 *
 * Module that enables issuance and redemption with any valid ERC20 token or ETH if allowed by the manager. Sender receives
 * a proportional amount of SetTokens on issuance or ERC20 token on redemption based on the calculated net asset value using
 * oracle prices. Manager is able to enforce a premium / discount on issuance / redemption to avoid arbitrage and front
 * running when relying on oracle prices. Managers can charge a fee (denominated in reserve asset).
 */
contract NavIssuanceModule is ModuleBase, ReentrancyGuard {
    using AddressArrayUtils for address[];
    using Invoke for ISetToken;
    using Position for ISetToken;
    using PreciseUnitMath for uint256;
    using PreciseUnitMath for int256;
    using ResourceIdentifier for IController;
    using SafeMath for uint256;
    using SafeCast for int256;
    using SafeCast for uint256;
    using SignedSafeMath for int256;

    /* ============ Events ============ */

    event SetTokenNAVIssued(
        ISetToken indexed _setToken,
        address _issuer,
        address _to,
        address _reserveAsset,
        address _hookContract,
        uint256 _setTokenQuantity,
        uint256 _managerFee,
        uint256 _premium
    );

    event SetTokenNAVRedeemed(
        ISetToken indexed _setToken,
        address _redeemer,
        address _to,
        address _reserveAsset,
        address _hookContract,
        uint256 _setTokenQuantity,
        uint256 _managerFee,
        uint256 _premium
    );

    event ReserveAssetAdded(
        ISetToken indexed _setToken,
        address _newReserveAsset
    );

    event ReserveAssetRemoved(
        ISetToken indexed _setToken,
        address _removedReserveAsset
    );

    event PremiumEdited(
        ISetToken indexed _setToken,
        uint256 _newPremium
    );

    event ManagerFeeEdited(
        ISetToken indexed _setToken,
        uint256 _newManagerFee,
        uint256 _index
    );

    event FeeRecipientEdited(
        ISetToken indexed _setToken,
        address _feeRecipient
    );

    /* ============ Structs ============ */

    struct NAVIssuanceSettings {
        INAVIssuanceHook managerIssuanceHook;      // Issuance hook configurations
        INAVIssuanceHook managerRedemptionHook;    // Redemption hook configurations
        address[] reserveAssets;                       // Allowed reserve assets - Must have a price enabled with the price oracle
        address feeRecipient;                          // Manager fee recipient
        uint256[2] managerFees;                        // Manager fees. 0 index is issue and 1 index is redeem fee (0.01% = 1e14, 1% = 1e16)
        uint256 maxManagerFee;                         // Maximum fee manager is allowed to set for issue and redeem
        uint256 premiumPercentage;                     // Premium percentage (0.01% = 1e14, 1% = 1e16). This premium is a buffer around oracle
                                                       // prices paid by user to the SetToken, which prevents arbitrage and oracle front running
        uint256 maxPremiumPercentage;                  // Maximum premium percentage manager is allowed to set (configured by manager)
        uint256 minSetTokenSupply;                     // Minimum SetToken supply required for issuance and redemption
                                                       // to prevent dramatic inflationary changes to the SetToken's position multiplier
    }

    struct ActionInfo {
        uint256 preFeeReserveQuantity;                 // Reserve value before fees; During issuance, represents raw quantity
                                                       // During redeem, represents post-premium value
        uint256 protocolFees;                          // Total protocol fees (direct + manager revenue share)
        uint256 managerFee;                            // Total manager fee paid in reserve asset
        uint256 netFlowQuantity;                       // When issuing, quantity of reserve asset sent to SetToken
                                                       // When redeeming, quantity of reserve asset sent to redeemer
        uint256 setTokenQuantity;                      // When issuing, quantity of SetTokens minted to mintee
                                                       // When redeeming, quantity of SetToken redeemed
        uint256 previousSetTokenSupply;                // SetToken supply prior to issue/redeem action
        uint256 newSetTokenSupply;                     // SetToken supply after issue/redeem action
        int256 newPositionMultiplier;                  // SetToken position multiplier after issue/redeem
        uint256 newReservePositionUnit;                // SetToken reserve asset position unit after issue/redeem
    }

    /* ============ State Variables ============ */

    // Wrapped ETH address
    IWETH public immutable weth;

    // Mapping of SetToken to NAV issuance settings struct
    mapping(ISetToken => NAVIssuanceSettings) public navIssuanceSettings;

    // Mapping to efficiently check a SetToken's reserve asset validity
    // SetToken => reserveAsset => isReserveAsset
    mapping(ISetToken => mapping(address => bool)) public isReserveAsset;

    /* ============ Constants ============ */

    // 0 index stores the manager fee in managerFees array, percentage charged on issue (denominated in reserve asset)
    uint256 constant internal MANAGER_ISSUE_FEE_INDEX = 0;

    // 1 index stores the manager fee percentage in managerFees array, charged on redeem
    uint256 constant internal MANAGER_REDEEM_FEE_INDEX = 1;

    // 0 index stores the manager revenue share protocol fee % on the controller, charged in the issuance function
    uint256 constant internal PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX = 0;

    // 1 index stores the manager revenue share protocol fee % on the controller, charged in the redeem function
    uint256 constant internal PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX = 1;

    // 2 index stores the direct protocol fee % on the controller, charged in the issuance function
    uint256 constant internal PROTOCOL_ISSUE_DIRECT_FEE_INDEX = 2;

    // 3 index stores the direct protocol fee % on the controller, charged in the redeem function
    uint256 constant internal PROTOCOL_REDEEM_DIRECT_FEE_INDEX = 3;

    /* ============ Constructor ============ */

    /**
     * @param _controller               Address of controller contract
     * @param _weth                     Address of wrapped eth
     */
    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {
        weth = _weth;
    }

    /* ============ External Functions ============ */

    /**
     * Deposits the allowed reserve asset into the SetToken and mints the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _reserveAsset                 Address of the reserve asset to issue with
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance
     * @param _to                           Address to mint SetToken to
     */
    function issue(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity,
        uint256 _minSetTokenReceiveQuantity,
        address _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, _reserveAsset, _reserveAssetQuantity);

        _callPreIssueHooks(_setToken, _reserveAsset, _reserveAssetQuantity, msg.sender, _to);

        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, _reserveAsset, _reserveAssetQuantity);

        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);

        _transferCollateralAndHandleFees(_setToken, IERC20(_reserveAsset), issueInfo);

        _handleIssueStateUpdates(_setToken, _reserveAsset, _to, issueInfo);
    }

    /**
     * Wraps ETH and deposits WETH if allowed into the SetToken and mints the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance
     * @param _to                           Address to mint SetToken to
     */
    function issueWithEther(
        ISetToken _setToken,
        uint256 _minSetTokenReceiveQuantity,
        address _to
    )
        external
        payable
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        weth.deposit{ value: msg.value }();

        _validateCommon(_setToken, address(weth), msg.value);

        _callPreIssueHooks(_setToken, address(weth), msg.value, msg.sender, _to);

        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, address(weth), msg.value);

        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);

        _transferWETHAndHandleFees(_setToken, issueInfo);

        _handleIssueStateUpdates(_setToken, address(weth), _to, issueInfo);
    }

    /**
     * Redeems a SetToken into a valid reserve asset representing the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address. Only valid if there are available reserve units on the SetToken.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _reserveAsset                 Address of the reserve asset to redeem with
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive
     * @param _to                           Address to redeem reserve asset to
     */
    function redeem(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity,
        uint256 _minReserveReceiveQuantity,
        address _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, _reserveAsset, _setTokenQuantity);

        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);

        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, _reserveAsset, _setTokenQuantity);

        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);

        _setToken.burn(msg.sender, _setTokenQuantity);

        // Instruct the SetToken to transfer the reserve asset back to the user
        _setToken.strictInvokeTransfer(
            _reserveAsset,
            _to,
            redeemInfo.netFlowQuantity
        );

        _handleRedemptionFees(_setToken, _reserveAsset, redeemInfo);

        _handleRedeemStateUpdates(_setToken, _reserveAsset, _to, redeemInfo);
    }

    /**
     * Redeems a SetToken into Ether (if WETH is valid) representing the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address. Only valid if there are available WETH units on the SetToken.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive
     * @param _to                           Address to redeem reserve asset to
     */
    function redeemIntoEther(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        uint256 _minReserveReceiveQuantity,
        address payable _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, address(weth), _setTokenQuantity);

        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);

        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, address(weth), _setTokenQuantity);

        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);

        _setToken.burn(msg.sender, _setTokenQuantity);

        // Instruct the SetToken to transfer WETH from SetToken to module
        _setToken.strictInvokeTransfer(
            address(weth),
            address(this),
            redeemInfo.netFlowQuantity
        );

        weth.withdraw(redeemInfo.netFlowQuantity);

        _to.transfer(redeemInfo.netFlowQuantity);

        _handleRedemptionFees(_setToken, address(weth), redeemInfo);

        _handleRedeemStateUpdates(_setToken, address(weth), _to, redeemInfo);
    }

    /**
     * SET MANAGER ONLY. Add an allowed reserve asset
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset to add
     */
    function addReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {
        require(!isReserveAsset[_setToken][_reserveAsset], "Reserve asset already exists");

        navIssuanceSettings[_setToken].reserveAssets.push(_reserveAsset);
        isReserveAsset[_setToken][_reserveAsset] = true;

        emit ReserveAssetAdded(_setToken, _reserveAsset);
    }

    /**
     * SET MANAGER ONLY. Remove a reserve asset
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset to remove
     */
    function removeReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {
        require(isReserveAsset[_setToken][_reserveAsset], "Reserve asset does not exist");

        navIssuanceSettings[_setToken].reserveAssets = navIssuanceSettings[_setToken].reserveAssets.remove(_reserveAsset);
        delete isReserveAsset[_setToken][_reserveAsset];

        emit ReserveAssetRemoved(_setToken, _reserveAsset);
    }

    /**
     * SET MANAGER ONLY. Edit the premium percentage
     *
     * @param _setToken                     Instance of the SetToken
     * @param _premiumPercentage            Premium percentage in 10e16 (e.g. 10e16 = 1%)
     */
    function editPremium(ISetToken _setToken, uint256 _premiumPercentage) external onlyManagerAndValidSet(_setToken) {
        require(_premiumPercentage <= navIssuanceSettings[_setToken].maxPremiumPercentage, "Premium must be less than maximum allowed");

        navIssuanceSettings[_setToken].premiumPercentage = _premiumPercentage;

        emit PremiumEdited(_setToken, _premiumPercentage);
    }

    /**
     * SET MANAGER ONLY. Edit manager fee
     *
     * @param _setToken                     Instance of the SetToken
     * @param _managerFeePercentage         Manager fee percentage in 10e16 (e.g. 10e16 = 1%)
     * @param _managerFeeIndex              Manager fee index. 0 index is issue fee, 1 index is redeem fee
     */
    function editManagerFee(
        ISetToken _setToken,
        uint256 _managerFeePercentage,
        uint256 _managerFeeIndex
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        require(_managerFeePercentage <= navIssuanceSettings[_setToken].maxManagerFee, "Manager fee must be less than maximum allowed");

        navIssuanceSettings[_setToken].managerFees[_managerFeeIndex] = _managerFeePercentage;

        emit ManagerFeeEdited(_setToken, _managerFeePercentage, _managerFeeIndex);
    }

    /**
     * SET MANAGER ONLY. Edit the manager fee recipient
     *
     * @param _setToken                     Instance of the SetToken
     * @param _managerFeeRecipient          Manager fee recipient
     */
    function editFeeRecipient(ISetToken _setToken, address _managerFeeRecipient) external onlyManagerAndValidSet(_setToken) {
        require(_managerFeeRecipient != address(0), "Fee recipient must not be 0 address");

        navIssuanceSettings[_setToken].feeRecipient = _managerFeeRecipient;

        emit FeeRecipientEdited(_setToken, _managerFeeRecipient);
    }

    /**
     * SET MANAGER ONLY. Initializes this module to the SetToken with hooks, allowed reserve assets,
     * fees and issuance premium. Only callable by the SetToken's manager. Hook addresses are optional.
     * Address(0) means that no hook will be called.
     *
     * @param _setToken                     Instance of the SetToken to issue
     * @param _navIssuanceSettings          NAVIssuanceSettings struct defining parameters
     */
    function initialize(
        ISetToken _setToken,
        NAVIssuanceSettings memory _navIssuanceSettings
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        require(_navIssuanceSettings.reserveAssets.length > 0, "Reserve assets must be greater than 0");
        require(_navIssuanceSettings.maxManagerFee < PreciseUnitMath.preciseUnit(), "Max manager fee must be less than 100%");
        require(_navIssuanceSettings.maxPremiumPercentage < PreciseUnitMath.preciseUnit(), "Max premium percentage must be less than 100%");
        require(_navIssuanceSettings.managerFees[0] <= _navIssuanceSettings.maxManagerFee, "Manager issue fee must be less than max");
        require(_navIssuanceSettings.managerFees[1] <= _navIssuanceSettings.maxManagerFee, "Manager redeem fee must be less than max");
        require(_navIssuanceSettings.premiumPercentage <= _navIssuanceSettings.maxPremiumPercentage, "Premium must be less than max");
        require(_navIssuanceSettings.feeRecipient != address(0), "Fee Recipient must be non-zero address.");
        // Initial mint of Set cannot use NAVIssuance since minSetTokenSupply must be > 0
        require(_navIssuanceSettings.minSetTokenSupply > 0, "Min SetToken supply must be greater than 0");

        for (uint256 i = 0; i < _navIssuanceSettings.reserveAssets.length; i++) {
            require(!isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]], "Reserve assets must be unique");
            isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]] = true;
        }

        navIssuanceSettings[_setToken] = _navIssuanceSettings;

        _setToken.initializeModule();
    }

    /**
     * Removes this module from the SetToken, via call by the SetToken. Issuance settings and
     * reserve asset states are deleted.
     */
    function removeModule() external override {
        ISetToken setToken = ISetToken(msg.sender);
        for (uint256 i = 0; i < navIssuanceSettings[setToken].reserveAssets.length; i++) {
            delete isReserveAsset[setToken][navIssuanceSettings[setToken].reserveAssets[i]];
        }

        delete navIssuanceSettings[setToken];
    }

    receive() external payable {}

    /* ============ External Getter Functions ============ */

    function getReserveAssets(ISetToken _setToken) external view returns (address[] memory) {
        return navIssuanceSettings[_setToken].reserveAssets;
    }

    function getIssuePremium(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (uint256)
    {
        return _getIssuePremium(_setToken, _reserveAsset, _reserveAssetQuantity);
    }

    function getRedeemPremium(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (uint256)
    {
        return _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);
    }

    function getManagerFee(ISetToken _setToken, uint256 _managerFeeIndex) external view returns (uint256) {
        return navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];
    }

    /**
     * Get the expected SetTokens minted to recipient on issuance
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     *
     * @return  uint256                     Expected SetTokens to be minted to recipient
     */
    function getExpectedSetTokenIssueQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (uint256)
    {
        (,, uint256 netReserveFlow) = _getFees(
            _setToken,
            _reserveAssetQuantity,
            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,
            MANAGER_ISSUE_FEE_INDEX
        );

        uint256 setTotalSupply = _setToken.totalSupply();

        return _getSetTokenMintQuantity(
            _setToken,
            _reserveAsset,
            netReserveFlow,
            setTotalSupply
        );
    }

    /**
     * Get the expected reserve asset to be redeemed
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     *
     * @return  uint256                     Expected reserve asset quantity redeemed
     */
    function getExpectedReserveRedeemQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (uint256)
    {
        uint256 preFeeReserveQuantity = _getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

        (,, uint256 netReserveFlows) = _getFees(
            _setToken,
            preFeeReserveQuantity,
            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
            MANAGER_REDEEM_FEE_INDEX
        );

        return netReserveFlows;
    }

    /**
     * Checks if issue is valid
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     *
     * @return  bool                        Returns true if issue is valid
     */
    function isIssueValid(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (bool)
    {
        uint256 setTotalSupply = _setToken.totalSupply();

    return _reserveAssetQuantity != 0
            && isReserveAsset[_setToken][_reserveAsset]
            && setTotalSupply >= navIssuanceSettings[_setToken].minSetTokenSupply;
    }

    /**
     * Checks if redeem is valid
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     *
     * @return  bool                        Returns true if redeem is valid
     */
    function isRedeemValid(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (bool)
    {
        uint256 setTotalSupply = _setToken.totalSupply();

        if (
            _setTokenQuantity == 0
            || !isReserveAsset[_setToken][_reserveAsset]
            || setTotalSupply < navIssuanceSettings[_setToken].minSetTokenSupply.add(_setTokenQuantity)
        ) {
            return false;
        } else {
            uint256 totalRedeemValue =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

            (,, uint256 expectedRedeemQuantity) = _getFees(
                _setToken,
                totalRedeemValue,
                PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
                PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
                MANAGER_REDEEM_FEE_INDEX
            );

            uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();

            return existingUnit.preciseMul(setTotalSupply) >= expectedRedeemQuantity;
        }
    }

    /* ============ Internal Functions ============ */

    function _validateCommon(ISetToken _setToken, address _reserveAsset, uint256 _quantity) internal view {
        require(_quantity > 0, "Quantity must be > 0");
        require(isReserveAsset[_setToken][_reserveAsset], "Must be valid reserve asset");
    }

    function _validateIssuanceInfo(ISetToken _setToken, uint256 _minSetTokenReceiveQuantity, ActionInfo memory _issueInfo) internal view {
        // Check that total supply is greater than min supply needed for issuance
        // Note: A min supply amount is needed to avoid division by 0 when SetToken supply is 0
        require(
            _issueInfo.previousSetTokenSupply >= navIssuanceSettings[_setToken].minSetTokenSupply,
            "Supply must be greater than minimum to enable issuance"
        );

        require(_issueInfo.setTokenQuantity >= _minSetTokenReceiveQuantity, "Must be greater than min SetToken");
    }

    function _validateRedemptionInfo(
        ISetToken _setToken,
        uint256 _minReserveReceiveQuantity,
        ActionInfo memory _redeemInfo
    )
        internal
        view
    {
        // Check that new supply is more than min supply needed for redemption
        // Note: A min supply amount is needed to avoid division by 0 when redeeming SetToken to 0
        require(
            _redeemInfo.newSetTokenSupply >= navIssuanceSettings[_setToken].minSetTokenSupply,
            "Supply must be greater than minimum to enable redemption"
        );

        require(_redeemInfo.netFlowQuantity >= _minReserveReceiveQuantity, "Must be greater than min receive reserve quantity");
    }

    function _createIssuanceInfo(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        internal
        view
        returns (ActionInfo memory)
    {
        ActionInfo memory issueInfo;

        issueInfo.previousSetTokenSupply = _setToken.totalSupply();

        issueInfo.preFeeReserveQuantity = _reserveAssetQuantity;

        (issueInfo.protocolFees, issueInfo.managerFee, issueInfo.netFlowQuantity) = _getFees(
            _setToken,
            issueInfo.preFeeReserveQuantity,
            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,
            MANAGER_ISSUE_FEE_INDEX
        );

        issueInfo.setTokenQuantity = _getSetTokenMintQuantity(
            _setToken,
            _reserveAsset,
            issueInfo.netFlowQuantity,
            issueInfo.previousSetTokenSupply
        );

        (issueInfo.newSetTokenSupply, issueInfo.newPositionMultiplier) = _getIssuePositionMultiplier(_setToken, issueInfo);

        issueInfo.newReservePositionUnit = _getIssuePositionUnit(_setToken, _reserveAsset, issueInfo);

        return issueInfo;
    }

    function _createRedemptionInfo(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        internal
        view
        returns (ActionInfo memory)
    {
        ActionInfo memory redeemInfo;

        redeemInfo.setTokenQuantity = _setTokenQuantity;

        redeemInfo.preFeeReserveQuantity =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

        (redeemInfo.protocolFees, redeemInfo.managerFee, redeemInfo.netFlowQuantity) = _getFees(
            _setToken,
            redeemInfo.preFeeReserveQuantity,
            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
            MANAGER_REDEEM_FEE_INDEX
        );

        redeemInfo.previousSetTokenSupply = _setToken.totalSupply();

        (redeemInfo.newSetTokenSupply, redeemInfo.newPositionMultiplier) = _getRedeemPositionMultiplier(_setToken, _setTokenQuantity, redeemInfo);

        redeemInfo.newReservePositionUnit = _getRedeemPositionUnit(_setToken, _reserveAsset, redeemInfo);

        return redeemInfo;
    }

    /**
     * Transfer reserve asset from user to SetToken and fees from user to appropriate fee recipients
     */
    function _transferCollateralAndHandleFees(ISetToken _setToken, IERC20 _reserveAsset, ActionInfo memory _issueInfo) internal {
        transferFrom(_reserveAsset, msg.sender, address(_setToken), _issueInfo.netFlowQuantity);

        if (_issueInfo.protocolFees > 0) {
            transferFrom(_reserveAsset, msg.sender, controller.feeRecipient(), _issueInfo.protocolFees);
        }

        if (_issueInfo.managerFee > 0) {
            transferFrom(_reserveAsset, msg.sender, navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);
        }
    }


    /**
      * Transfer WETH from module to SetToken and fees from module to appropriate fee recipients
     */
    function _transferWETHAndHandleFees(ISetToken _setToken, ActionInfo memory _issueInfo) internal {
        weth.transfer(address(_setToken), _issueInfo.netFlowQuantity);

        if (_issueInfo.protocolFees > 0) {
            weth.transfer(controller.feeRecipient(), _issueInfo.protocolFees);
        }

        if (_issueInfo.managerFee > 0) {
            weth.transfer(navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);
        }
    }

    function _handleIssueStateUpdates(
        ISetToken _setToken,
        address _reserveAsset,
        address _to,
        ActionInfo memory _issueInfo
    )
        internal
    {
        _setToken.editPositionMultiplier(_issueInfo.newPositionMultiplier);

        _setToken.editDefaultPosition(_reserveAsset, _issueInfo.newReservePositionUnit);

        _setToken.mint(_to, _issueInfo.setTokenQuantity);

        emit SetTokenNAVIssued(
            _setToken,
            msg.sender,
            _to,
            _reserveAsset,
            address(navIssuanceSettings[_setToken].managerIssuanceHook),
            _issueInfo.setTokenQuantity,
            _issueInfo.managerFee,
            _issueInfo.protocolFees
        );
    }

    function _handleRedeemStateUpdates(
        ISetToken _setToken,
        address _reserveAsset,
        address _to,
        ActionInfo memory _redeemInfo
    )
        internal
    {
        _setToken.editPositionMultiplier(_redeemInfo.newPositionMultiplier);

        _setToken.editDefaultPosition(_reserveAsset, _redeemInfo.newReservePositionUnit);

        emit SetTokenNAVRedeemed(
            _setToken,
            msg.sender,
            _to,
            _reserveAsset,
            address(navIssuanceSettings[_setToken].managerRedemptionHook),
            _redeemInfo.setTokenQuantity,
            _redeemInfo.managerFee,
            _redeemInfo.protocolFees
        );
    }

    function _handleRedemptionFees(ISetToken _setToken, address _reserveAsset, ActionInfo memory _redeemInfo) internal {
        // Instruct the SetToken to transfer protocol fee to fee recipient if there is a fee
        payProtocolFeeFromSetToken(_setToken, _reserveAsset, _redeemInfo.protocolFees);

        // Instruct the SetToken to transfer manager fee to manager fee recipient if there is a fee
        if (_redeemInfo.managerFee > 0) {
            _setToken.strictInvokeTransfer(
                _reserveAsset,
                navIssuanceSettings[_setToken].feeRecipient,
                _redeemInfo.managerFee
            );
        }
    }

    /**
     * Returns the issue premium percentage. Virtual function that can be overridden in future versions of the module
     * and can contain arbitrary logic to calculate the issuance premium.
     */
    function _getIssuePremium(
        ISetToken _setToken,
        address /* _reserveAsset */,
        uint256 /* _reserveAssetQuantity */
    )
        virtual
        internal
        view
        returns (uint256)
    {
        return navIssuanceSettings[_setToken].premiumPercentage;
    }

    /**
     * Returns the redeem premium percentage. Virtual function that can be overridden in future versions of the module
     * and can contain arbitrary logic to calculate the redemption premium.
     */
    function _getRedeemPremium(
        ISetToken _setToken,
        address /* _reserveAsset */,
        uint256 /* _setTokenQuantity */
    )
        virtual
        internal
        view
        returns (uint256)
    {
        return navIssuanceSettings[_setToken].premiumPercentage;
    }

    /**
     * Returns the fees attributed to the manager and the protocol. The fees are calculated as follows:
     *
     * ManagerFee = (manager fee % - % to protocol) * reserveAssetQuantity
     * Protocol Fee = (% manager fee share + direct fee %) * reserveAssetQuantity
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAssetQuantity         Quantity of reserve asset to calculate fees from
     * @param _protocolManagerFeeIndex      Index to pull rev share NAV Issuance fee from the Controller
     * @param _protocolDirectFeeIndex       Index to pull direct NAV issuance fee from the Controller
     * @param _managerFeeIndex              Index from NAVIssuanceSettings (0 = issue fee, 1 = redeem fee)
     *
     * @return  uint256                     Fees paid to the protocol in reserve asset
     * @return  uint256                     Fees paid to the manager in reserve asset
     * @return  uint256                     Net reserve to user net of fees
     */
    function _getFees(
        ISetToken _setToken,
        uint256 _reserveAssetQuantity,
        uint256 _protocolManagerFeeIndex,
        uint256 _protocolDirectFeeIndex,
        uint256 _managerFeeIndex
    )
        internal
        view
        returns (uint256, uint256, uint256)
    {
        (uint256 protocolFeePercentage, uint256 managerFeePercentage) = _getProtocolAndManagerFeePercentages(
            _setToken,
            _protocolManagerFeeIndex,
            _protocolDirectFeeIndex,
            _managerFeeIndex
        );

        // Calculate total notional fees
        uint256 protocolFees = protocolFeePercentage.preciseMul(_reserveAssetQuantity);
        uint256 managerFee = managerFeePercentage.preciseMul(_reserveAssetQuantity);

        uint256 netReserveFlow = _reserveAssetQuantity.sub(protocolFees).sub(managerFee);

        return (protocolFees, managerFee, netReserveFlow);
    }

    function _getProtocolAndManagerFeePercentages(
        ISetToken _setToken,
        uint256 _protocolManagerFeeIndex,
        uint256 _protocolDirectFeeIndex,
        uint256 _managerFeeIndex
    )
        internal
        view
        returns(uint256, uint256)
    {
        // Get protocol fee percentages
        uint256 protocolDirectFeePercent = controller.getModuleFee(address(this), _protocolDirectFeeIndex);
        uint256 protocolManagerShareFeePercent = controller.getModuleFee(address(this), _protocolManagerFeeIndex);
        uint256 managerFeePercent = navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];

        // Calculate revenue share split percentage
        uint256 protocolRevenueSharePercentage = protocolManagerShareFeePercent.preciseMul(managerFeePercent);
        uint256 managerRevenueSharePercentage = managerFeePercent.sub(protocolRevenueSharePercentage);
        uint256 totalProtocolFeePercentage = protocolRevenueSharePercentage.add(protocolDirectFeePercent);

        return (totalProtocolFeePercentage, managerRevenueSharePercentage);
    }

    function _getSetTokenMintQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _netReserveFlows,            // Value of reserve asset net of fees
        uint256 _setTotalSupply
    )
        internal
        view
        returns (uint256)
    {
        uint256 premiumPercentage = _getIssuePremium(_setToken, _reserveAsset, _netReserveFlows);
        uint256 premiumValue = _netReserveFlows.preciseMul(premiumPercentage);

        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (1e18)
        // Reverts if price is not found
        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);

        // Get reserve asset decimals
        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();
        uint256 normalizedTotalReserveQuantityNetFees = _netReserveFlows.preciseDiv(10 ** reserveAssetDecimals);
        uint256 normalizedTotalReserveQuantityNetFeesAndPremium = _netReserveFlows.sub(premiumValue).preciseDiv(10 ** reserveAssetDecimals);

        // Calculate SetTokens to mint to issuer
        uint256 denominator = _setTotalSupply.preciseMul(setTokenValuation).add(normalizedTotalReserveQuantityNetFees).sub(normalizedTotalReserveQuantityNetFeesAndPremium);
        return normalizedTotalReserveQuantityNetFeesAndPremium.preciseMul(_setTotalSupply).preciseDiv(denominator);
    }

    function _getRedeemReserveQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        internal
        view
        returns (uint256)
    {
        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (10e18)
        // Reverts if price is not found
        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);

        uint256 totalRedeemValueInPreciseUnits = _setTokenQuantity.preciseMul(setTokenValuation);
        // Get reserve asset decimals
        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();
        uint256 prePremiumReserveQuantity = totalRedeemValueInPreciseUnits.preciseMul(10 ** reserveAssetDecimals);

        uint256 premiumPercentage = _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);
        uint256 premiumQuantity = prePremiumReserveQuantity.preciseMulCeil(premiumPercentage);

        return prePremiumReserveQuantity.sub(premiumQuantity);
    }

    /**
     * The new position multiplier is calculated as follows:
     * inflationPercentage = (newSupply - oldSupply) / newSupply
     * newMultiplier = (1 - inflationPercentage) * positionMultiplier
     */
    function _getIssuePositionMultiplier(
        ISetToken _setToken,
        ActionInfo memory _issueInfo
    )
        internal
        view
        returns (uint256, int256)
    {
        // Calculate inflation and new position multiplier. Note: Round inflation up in order to round position multiplier down
        uint256 newTotalSupply = _issueInfo.setTokenQuantity.add(_issueInfo.previousSetTokenSupply);
        int256 newPositionMultiplier = _setToken.positionMultiplier()
            .mul(_issueInfo.previousSetTokenSupply.toInt256())
            .div(newTotalSupply.toInt256());

        return (newTotalSupply, newPositionMultiplier);
    }

    /**
     * Calculate deflation and new position multiplier. Note: Round deflation down in order to round position multiplier down
     *
     * The new position multiplier is calculated as follows:
     * deflationPercentage = (oldSupply - newSupply) / newSupply
     * newMultiplier = (1 + deflationPercentage) * positionMultiplier
     */
    function _getRedeemPositionMultiplier(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        ActionInfo memory _redeemInfo
    )
        internal
        view
        returns (uint256, int256)
    {
        uint256 newTotalSupply = _redeemInfo.previousSetTokenSupply.sub(_setTokenQuantity);
        int256 newPositionMultiplier = _setToken.positionMultiplier()
            .mul(_redeemInfo.previousSetTokenSupply.toInt256())
            .div(newTotalSupply.toInt256());

        return (newTotalSupply, newPositionMultiplier);
    }

    /**
     * The new position reserve asset unit is calculated as follows:
     * totalReserve = (oldUnit * oldSetTokenSupply) + reserveQuantity
     * newUnit = totalReserve / newSetTokenSupply
     */
    function _getIssuePositionUnit(
        ISetToken _setToken,
        address _reserveAsset,
        ActionInfo memory _issueInfo
    )
        internal
        view
        returns (uint256)
    {
        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();
        uint256 totalReserve = existingUnit
            .preciseMul(_issueInfo.previousSetTokenSupply)
            .add(_issueInfo.netFlowQuantity);

        return totalReserve.preciseDiv(_issueInfo.newSetTokenSupply);
    }

    /**
     * The new position reserve asset unit is calculated as follows:
     * totalReserve = (oldUnit * oldSetTokenSupply) - reserveQuantityToSendOut
     * newUnit = totalReserve / newSetTokenSupply
     */
    function _getRedeemPositionUnit(
        ISetToken _setToken,
        address _reserveAsset,
        ActionInfo memory _redeemInfo
    )
        internal
        view
        returns (uint256)
    {
        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();
        uint256 totalExistingUnits = existingUnit.preciseMul(_redeemInfo.previousSetTokenSupply);

        uint256 outflow = _redeemInfo.netFlowQuantity.add(_redeemInfo.protocolFees).add(_redeemInfo.managerFee);

        // Require withdrawable quantity is greater than existing collateral
        require(totalExistingUnits >= outflow, "Must be greater than total available collateral");

        return totalExistingUnits.sub(outflow).preciseDiv(_redeemInfo.newSetTokenSupply);
    }

    /**
     * If a pre-issue hook has been configured, call the external-protocol contract. Pre-issue hook logic
     * can contain arbitrary logic including validations, external function calls, etc.
     */
    function _callPreIssueHooks(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity,
        address _caller,
        address _to
    )
        internal
    {
        INAVIssuanceHook preIssueHook = navIssuanceSettings[_setToken].managerIssuanceHook;
        if (address(preIssueHook) != address(0)) {
            preIssueHook.invokePreIssueHook(_setToken, _reserveAsset, _reserveAssetQuantity, _caller, _to);
        }
    }

    /**
     * If a pre-redeem hook has been configured, call the external-protocol contract.
     */
    function _callPreRedeemHooks(ISetToken _setToken, uint256 _setQuantity, address _caller, address _to) internal {
        INAVIssuanceHook preRedeemHook = navIssuanceSettings[_setToken].managerRedemptionHook;
        if (address(preRedeemHook) != address(0)) {
            preRedeemHook.invokePreRedeemHook(_setToken, _setQuantity, _caller, _to);
        }
    }
}".

As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.

Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

[2024-01-09 05:31:14 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 05:31:14 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 19912
completion_tokens: 1
total_tokens: 19913
cost: $-1.000000


[2024-01-09 05:31:14 INFO] Security Analyst: **Security Analyst<->Chief Executive Officer on : ContractAnalysis, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: /*
    Copyright 2020 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";
import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";
import { SignedSafeMath } from "@openzeppelin/contracts/math/SignedSafeMath.sol";

import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";
import { IController } from "../../interfaces/IController.sol";
import { INAVIssuanceHook } from "../../interfaces/INAVIssuanceHook.sol";
import { Invoke } from "../lib/Invoke.sol";
import { ISetToken } from "../../interfaces/ISetToken.sol";
import { IWETH } from "../../interfaces/external/IWETH.sol";
import { ModuleBase } from "../lib/ModuleBase.sol";
import { Position } from "../lib/Position.sol";
import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";
import { ResourceIdentifier } from "../lib/ResourceIdentifier.sol";


/**
 * @title NavIssuanceModule
 * @author Set Protocol
 *
 * Module that enables issuance and redemption with any valid ERC20 token or ETH if allowed by the manager. Sender receives
 * a proportional amount of SetTokens on issuance or ERC20 token on redemption based on the calculated net asset value using
 * oracle prices. Manager is able to enforce a premium / discount on issuance / redemption to avoid arbitrage and front
 * running when relying on oracle prices. Managers can charge a fee (denominated in reserve asset).
 */
contract NavIssuanceModule is ModuleBase, ReentrancyGuard {
    using AddressArrayUtils for address[];
    using Invoke for ISetToken;
    using Position for ISetToken;
    using PreciseUnitMath for uint256;
    using PreciseUnitMath for int256;
    using ResourceIdentifier for IController;
    using SafeMath for uint256;
    using SafeCast for int256;
    using SafeCast for uint256;
    using SignedSafeMath for int256;

    /* ============ Events ============ */

    event SetTokenNAVIssued(
        ISetToken indexed _setToken,
        address _issuer,
        address _to,
        address _reserveAsset,
        address _hookContract,
        uint256 _setTokenQuantity,
        uint256 _managerFee,
        uint256 _premium
    );

    event SetTokenNAVRedeemed(
        ISetToken indexed _setToken,
        address _redeemer,
        address _to,
        address _reserveAsset,
        address _hookContract,
        uint256 _setTokenQuantity,
        uint256 _managerFee,
        uint256 _premium
    );

    event ReserveAssetAdded(
        ISetToken indexed _setToken,
        address _newReserveAsset
    );

    event ReserveAssetRemoved(
        ISetToken indexed _setToken,
        address _removedReserveAsset
    );

    event PremiumEdited(
        ISetToken indexed _setToken,
        uint256 _newPremium
    );

    event ManagerFeeEdited(
        ISetToken indexed _setToken,
        uint256 _newManagerFee,
        uint256 _index
    );

    event FeeRecipientEdited(
        ISetToken indexed _setToken,
        address _feeRecipient
    );

    /* ============ Structs ============ */

    struct NAVIssuanceSettings {
        INAVIssuanceHook managerIssuanceHook;      // Issuance hook configurations
        INAVIssuanceHook managerRedemptionHook;    // Redemption hook configurations
        address[] reserveAssets;                       // Allowed reserve assets - Must have a price enabled with the price oracle
        address feeRecipient;                          // Manager fee recipient
        uint256[2] managerFees;                        // Manager fees. 0 index is issue and 1 index is redeem fee (0.01% = 1e14, 1% = 1e16)
        uint256 maxManagerFee;                         // Maximum fee manager is allowed to set for issue and redeem
        uint256 premiumPercentage;                     // Premium percentage (0.01% = 1e14, 1% = 1e16). This premium is a buffer around oracle
                                                       // prices paid by user to the SetToken, which prevents arbitrage and oracle front running
        uint256 maxPremiumPercentage;                  // Maximum premium percentage manager is allowed to set (configured by manager)
        uint256 minSetTokenSupply;                     // Minimum SetToken supply required for issuance and redemption
                                                       // to prevent dramatic inflationary changes to the SetToken's position multiplier
    }

    struct ActionInfo {
        uint256 preFeeReserveQuantity;                 // Reserve value before fees; During issuance, represents raw quantity
                                                       // During redeem, represents post-premium value
        uint256 protocolFees;                          // Total protocol fees (direct + manager revenue share)
        uint256 managerFee;                            // Total manager fee paid in reserve asset
        uint256 netFlowQuantity;                       // When issuing, quantity of reserve asset sent to SetToken
                                                       // When redeeming, quantity of reserve asset sent to redeemer
        uint256 setTokenQuantity;                      // When issuing, quantity of SetTokens minted to mintee
                                                       // When redeeming, quantity of SetToken redeemed
        uint256 previousSetTokenSupply;                // SetToken supply prior to issue/redeem action
        uint256 newSetTokenSupply;                     // SetToken supply after issue/redeem action
        int256 newPositionMultiplier;                  // SetToken position multiplier after issue/redeem
        uint256 newReservePositionUnit;                // SetToken reserve asset position unit after issue/redeem
    }

    /* ============ State Variables ============ */

    // Wrapped ETH address
    IWETH public immutable weth;

    // Mapping of SetToken to NAV issuance settings struct
    mapping(ISetToken => NAVIssuanceSettings) public navIssuanceSettings;

    // Mapping to efficiently check a SetToken's reserve asset validity
    // SetToken => reserveAsset => isReserveAsset
    mapping(ISetToken => mapping(address => bool)) public isReserveAsset;

    /* ============ Constants ============ */

    // 0 index stores the manager fee in managerFees array, percentage charged on issue (denominated in reserve asset)
    uint256 constant internal MANAGER_ISSUE_FEE_INDEX = 0;

    // 1 index stores the manager fee percentage in managerFees array, charged on redeem
    uint256 constant internal MANAGER_REDEEM_FEE_INDEX = 1;

    // 0 index stores the manager revenue share protocol fee % on the controller, charged in the issuance function
    uint256 constant internal PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX = 0;

    // 1 index stores the manager revenue share protocol fee % on the controller, charged in the redeem function
    uint256 constant internal PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX = 1;

    // 2 index stores the direct protocol fee % on the controller, charged in the issuance function
    uint256 constant internal PROTOCOL_ISSUE_DIRECT_FEE_INDEX = 2;

    // 3 index stores the direct protocol fee % on the controller, charged in the redeem function
    uint256 constant internal PROTOCOL_REDEEM_DIRECT_FEE_INDEX = 3;

    /* ============ Constructor ============ */

    /**
     * @param _controller               Address of controller contract
     * @param _weth                     Address of wrapped eth
     */
    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {
        weth = _weth;
    }

    /* ============ External Functions ============ */

    /**
     * Deposits the allowed reserve asset into the SetToken and mints the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _reserveAsset                 Address of the reserve asset to issue with
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance
     * @param _to                           Address to mint SetToken to
     */
    function issue(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity,
        uint256 _minSetTokenReceiveQuantity,
        address _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, _reserveAsset, _reserveAssetQuantity);

        _callPreIssueHooks(_setToken, _reserveAsset, _reserveAssetQuantity, msg.sender, _to);

        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, _reserveAsset, _reserveAssetQuantity);

        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);

        _transferCollateralAndHandleFees(_setToken, IERC20(_reserveAsset), issueInfo);

        _handleIssueStateUpdates(_setToken, _reserveAsset, _to, issueInfo);
    }

    /**
     * Wraps ETH and deposits WETH if allowed into the SetToken and mints the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance
     * @param _to                           Address to mint SetToken to
     */
    function issueWithEther(
        ISetToken _setToken,
        uint256 _minSetTokenReceiveQuantity,
        address _to
    )
        external
        payable
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        weth.deposit{ value: msg.value }();

        _validateCommon(_setToken, address(weth), msg.value);

        _callPreIssueHooks(_setToken, address(weth), msg.value, msg.sender, _to);

        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, address(weth), msg.value);

        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);

        _transferWETHAndHandleFees(_setToken, issueInfo);

        _handleIssueStateUpdates(_setToken, address(weth), _to, issueInfo);
    }

    /**
     * Redeems a SetToken into a valid reserve asset representing the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address. Only valid if there are available reserve units on the SetToken.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _reserveAsset                 Address of the reserve asset to redeem with
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive
     * @param _to                           Address to redeem reserve asset to
     */
    function redeem(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity,
        uint256 _minReserveReceiveQuantity,
        address _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, _reserveAsset, _setTokenQuantity);

        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);

        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, _reserveAsset, _setTokenQuantity);

        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);

        _setToken.burn(msg.sender, _setTokenQuantity);

        // Instruct the SetToken to transfer the reserve asset back to the user
        _setToken.strictInvokeTransfer(
            _reserveAsset,
            _to,
            redeemInfo.netFlowQuantity
        );

        _handleRedemptionFees(_setToken, _reserveAsset, redeemInfo);

        _handleRedeemStateUpdates(_setToken, _reserveAsset, _to, redeemInfo);
    }

    /**
     * Redeems a SetToken into Ether (if WETH is valid) representing the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address. Only valid if there are available WETH units on the SetToken.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive
     * @param _to                           Address to redeem reserve asset to
     */
    function redeemIntoEther(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        uint256 _minReserveReceiveQuantity,
        address payable _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, address(weth), _setTokenQuantity);

        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);

        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, address(weth), _setTokenQuantity);

        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);

        _setToken.burn(msg.sender, _setTokenQuantity);

        // Instruct the SetToken to transfer WETH from SetToken to module
        _setToken.strictInvokeTransfer(
            address(weth),
            address(this),
            redeemInfo.netFlowQuantity
        );

        weth.withdraw(redeemInfo.netFlowQuantity);

        _to.transfer(redeemInfo.netFlowQuantity);

        _handleRedemptionFees(_setToken, address(weth), redeemInfo);

        _handleRedeemStateUpdates(_setToken, address(weth), _to, redeemInfo);
    }

    /**
     * SET MANAGER ONLY. Add an allowed reserve asset
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset to add
     */
    function addReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {
        require(!isReserveAsset[_setToken][_reserveAsset], "Reserve asset already exists");

        navIssuanceSettings[_setToken].reserveAssets.push(_reserveAsset);
        isReserveAsset[_setToken][_reserveAsset] = true;

        emit ReserveAssetAdded(_setToken, _reserveAsset);
    }

    /**
     * SET MANAGER ONLY. Remove a reserve asset
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset to remove
     */
    function removeReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {
        require(isReserveAsset[_setToken][_reserveAsset], "Reserve asset does not exist");

        navIssuanceSettings[_setToken].reserveAssets = navIssuanceSettings[_setToken].reserveAssets.remove(_reserveAsset);
        delete isReserveAsset[_setToken][_reserveAsset];

        emit ReserveAssetRemoved(_setToken, _reserveAsset);
    }

    /**
     * SET MANAGER ONLY. Edit the premium percentage
     *
     * @param _setToken                     Instance of the SetToken
     * @param _premiumPercentage            Premium percentage in 10e16 (e.g. 10e16 = 1%)
     */
    function editPremium(ISetToken _setToken, uint256 _premiumPercentage) external onlyManagerAndValidSet(_setToken) {
        require(_premiumPercentage <= navIssuanceSettings[_setToken].maxPremiumPercentage, "Premium must be less than maximum allowed");

        navIssuanceSettings[_setToken].premiumPercentage = _premiumPercentage;

        emit PremiumEdited(_setToken, _premiumPercentage);
    }

    /**
     * SET MANAGER ONLY. Edit manager fee
     *
     * @param _setToken                     Instance of the SetToken
     * @param _managerFeePercentage         Manager fee percentage in 10e16 (e.g. 10e16 = 1%)
     * @param _managerFeeIndex              Manager fee index. 0 index is issue fee, 1 index is redeem fee
     */
    function editManagerFee(
        ISetToken _setToken,
        uint256 _managerFeePercentage,
        uint256 _managerFeeIndex
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        require(_managerFeePercentage <= navIssuanceSettings[_setToken].maxManagerFee, "Manager fee must be less than maximum allowed");

        navIssuanceSettings[_setToken].managerFees[_managerFeeIndex] = _managerFeePercentage;

        emit ManagerFeeEdited(_setToken, _managerFeePercentage, _managerFeeIndex);
    }

    /**
     * SET MANAGER ONLY. Edit the manager fee recipient
     *
     * @param _setToken                     Instance of the SetToken
     * @param _managerFeeRecipient          Manager fee recipient
     */
    function editFeeRecipient(ISetToken _setToken, address _managerFeeRecipient) external onlyManagerAndValidSet(_setToken) {
        require(_managerFeeRecipient != address(0), "Fee recipient must not be 0 address");

        navIssuanceSettings[_setToken].feeRecipient = _managerFeeRecipient;

        emit FeeRecipientEdited(_setToken, _managerFeeRecipient);
    }

    /**
     * SET MANAGER ONLY. Initializes this module to the SetToken with hooks, allowed reserve assets,
     * fees and issuance premium. Only callable by the SetToken's manager. Hook addresses are optional.
     * Address(0) means that no hook will be called.
     *
     * @param _setToken                     Instance of the SetToken to issue
     * @param _navIssuanceSettings          NAVIssuanceSettings struct defining parameters
     */
    function initialize(
        ISetToken _setToken,
        NAVIssuanceSettings memory _navIssuanceSettings
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        require(_navIssuanceSettings.reserveAssets.length > 0, "Reserve assets must be greater than 0");
        require(_navIssuanceSettings.maxManagerFee < PreciseUnitMath.preciseUnit(), "Max manager fee must be less than 100%");
        require(_navIssuanceSettings.maxPremiumPercentage < PreciseUnitMath.preciseUnit(), "Max premium percentage must be less than 100%");
        require(_navIssuanceSettings.managerFees[0] <= _navIssuanceSettings.maxManagerFee, "Manager issue fee must be less than max");
        require(_navIssuanceSettings.managerFees[1] <= _navIssuanceSettings.maxManagerFee, "Manager redeem fee must be less than max");
        require(_navIssuanceSettings.premiumPercentage <= _navIssuanceSettings.maxPremiumPercentage, "Premium must be less than max");
        require(_navIssuanceSettings.feeRecipient != address(0), "Fee Recipient must be non-zero address.");
        // Initial mint of Set cannot use NAVIssuance since minSetTokenSupply must be > 0
        require(_navIssuanceSettings.minSetTokenSupply > 0, "Min SetToken supply must be greater than 0");

        for (uint256 i = 0; i < _navIssuanceSettings.reserveAssets.length; i++) {
            require(!isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]], "Reserve assets must be unique");
            isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]] = true;
        }

        navIssuanceSettings[_setToken] = _navIssuanceSettings;

        _setToken.initializeModule();
    }

    /**
     * Removes this module from the SetToken, via call by the SetToken. Issuance settings and
     * reserve asset states are deleted.
     */
    function removeModule() external override {
        ISetToken setToken = ISetToken(msg.sender);
        for (uint256 i = 0; i < navIssuanceSettings[setToken].reserveAssets.length; i++) {
            delete isReserveAsset[setToken][navIssuanceSettings[setToken].reserveAssets[i]];
        }

        delete navIssuanceSettings[setToken];
    }

    receive() external payable {}

    /* ============ External Getter Functions ============ */

    function getReserveAssets(ISetToken _setToken) external view returns (address[] memory) {
        return navIssuanceSettings[_setToken].reserveAssets;
    }

    function getIssuePremium(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (uint256)
    {
        return _getIssuePremium(_setToken, _reserveAsset, _reserveAssetQuantity);
    }

    function getRedeemPremium(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (uint256)
    {
        return _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);
    }

    function getManagerFee(ISetToken _setToken, uint256 _managerFeeIndex) external view returns (uint256) {
        return navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];
    }

    /**
     * Get the expected SetTokens minted to recipient on issuance
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     *
     * @return  uint256                     Expected SetTokens to be minted to recipient
     */
    function getExpectedSetTokenIssueQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (uint256)
    {
        (,, uint256 netReserveFlow) = _getFees(
            _setToken,
            _reserveAssetQuantity,
            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,
            MANAGER_ISSUE_FEE_INDEX
        );

        uint256 setTotalSupply = _setToken.totalSupply();

        return _getSetTokenMintQuantity(
            _setToken,
            _reserveAsset,
            netReserveFlow,
            setTotalSupply
        );
    }

    /**
     * Get the expected reserve asset to be redeemed
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     *
     * @return  uint256                     Expected reserve asset quantity redeemed
     */
    function getExpectedReserveRedeemQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (uint256)
    {
        uint256 preFeeReserveQuantity = _getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

        (,, uint256 netReserveFlows) = _getFees(
            _setToken,
            preFeeReserveQuantity,
            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
            MANAGER_REDEEM_FEE_INDEX
        );

        return netReserveFlows;
    }

    /**
     * Checks if issue is valid
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     *
     * @return  bool                        Returns true if issue is valid
     */
    function isIssueValid(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (bool)
    {
        uint256 setTotalSupply = _setToken.totalSupply();

    return _reserveAssetQuantity != 0
            && isReserveAsset[_setToken][_reserveAsset]
            && setTotalSupply >= navIssuanceSettings[_setToken].minSetTokenSupply;
    }

    /**
     * Checks if redeem is valid
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     *
     * @return  bool                        Returns true if redeem is valid
     */
    function isRedeemValid(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (bool)
    {
        uint256 setTotalSupply = _setToken.totalSupply();

        if (
            _setTokenQuantity == 0
            || !isReserveAsset[_setToken][_reserveAsset]
            || setTotalSupply < navIssuanceSettings[_setToken].minSetTokenSupply.add(_setTokenQuantity)
        ) {
            return false;
        } else {
            uint256 totalRedeemValue =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

            (,, uint256 expectedRedeemQuantity) = _getFees(
                _setToken,
                totalRedeemValue,
                PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
                PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
                MANAGER_REDEEM_FEE_INDEX
            );

            uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();

            return existingUnit.preciseMul(setTotalSupply) >= expectedRedeemQuantity;
        }
    }

    /* ============ Internal Functions ============ */

    function _validateCommon(ISetToken _setToken, address _reserveAsset, uint256 _quantity) internal view {
        require(_quantity > 0, "Quantity must be > 0");
        require(isReserveAsset[_setToken][_reserveAsset], "Must be valid reserve asset");
    }

    function _validateIssuanceInfo(ISetToken _setToken, uint256 _minSetTokenReceiveQuantity, ActionInfo memory _issueInfo) internal view {
        // Check that total supply is greater than min supply needed for issuance
        // Note: A min supply amount is needed to avoid division by 0 when SetToken supply is 0
        require(
            _issueInfo.previousSetTokenSupply >= navIssuanceSettings[_setToken].minSetTokenSupply,
            "Supply must be greater than minimum to enable issuance"
        );

        require(_issueInfo.setTokenQuantity >= _minSetTokenReceiveQuantity, "Must be greater than min SetToken");
    }

    function _validateRedemptionInfo(
        ISetToken _setToken,
        uint256 _minReserveReceiveQuantity,
        ActionInfo memory _redeemInfo
    )
        internal
        view
    {
        // Check that new supply is more than min supply needed for redemption
        // Note: A min supply amount is needed to avoid division by 0 when redeeming SetToken to 0
        require(
            _redeemInfo.newSetTokenSupply >= navIssuanceSettings[_setToken].minSetTokenSupply,
            "Supply must be greater than minimum to enable redemption"
        );

        require(_redeemInfo.netFlowQuantity >= _minReserveReceiveQuantity, "Must be greater than min receive reserve quantity");
    }

    function _createIssuanceInfo(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        internal
        view
        returns (ActionInfo memory)
    {
        ActionInfo memory issueInfo;

        issueInfo.previousSetTokenSupply = _setToken.totalSupply();

        issueInfo.preFeeReserveQuantity = _reserveAssetQuantity;

        (issueInfo.protocolFees, issueInfo.managerFee, issueInfo.netFlowQuantity) = _getFees(
            _setToken,
            issueInfo.preFeeReserveQuantity,
            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,
            MANAGER_ISSUE_FEE_INDEX
        );

        issueInfo.setTokenQuantity = _getSetTokenMintQuantity(
            _setToken,
            _reserveAsset,
            issueInfo.netFlowQuantity,
            issueInfo.previousSetTokenSupply
        );

        (issueInfo.newSetTokenSupply, issueInfo.newPositionMultiplier) = _getIssuePositionMultiplier(_setToken, issueInfo);

        issueInfo.newReservePositionUnit = _getIssuePositionUnit(_setToken, _reserveAsset, issueInfo);

        return issueInfo;
    }

    function _createRedemptionInfo(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        internal
        view
        returns (ActionInfo memory)
    {
        ActionInfo memory redeemInfo;

        redeemInfo.setTokenQuantity = _setTokenQuantity;

        redeemInfo.preFeeReserveQuantity =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

        (redeemInfo.protocolFees, redeemInfo.managerFee, redeemInfo.netFlowQuantity) = _getFees(
            _setToken,
            redeemInfo.preFeeReserveQuantity,
            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
            MANAGER_REDEEM_FEE_INDEX
        );

        redeemInfo.previousSetTokenSupply = _setToken.totalSupply();

        (redeemInfo.newSetTokenSupply, redeemInfo.newPositionMultiplier) = _getRedeemPositionMultiplier(_setToken, _setTokenQuantity, redeemInfo);

        redeemInfo.newReservePositionUnit = _getRedeemPositionUnit(_setToken, _reserveAsset, redeemInfo);

        return redeemInfo;
    }

    /**
     * Transfer reserve asset from user to SetToken and fees from user to appropriate fee recipients
     */
    function _transferCollateralAndHandleFees(ISetToken _setToken, IERC20 _reserveAsset, ActionInfo memory _issueInfo) internal {
        transferFrom(_reserveAsset, msg.sender, address(_setToken), _issueInfo.netFlowQuantity);

        if (_issueInfo.protocolFees > 0) {
            transferFrom(_reserveAsset, msg.sender, controller.feeRecipient(), _issueInfo.protocolFees);
        }

        if (_issueInfo.managerFee > 0) {
            transferFrom(_reserveAsset, msg.sender, navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);
        }
    }


    /**
      * Transfer WETH from module to SetToken and fees from module to appropriate fee recipients
     */
    function _transferWETHAndHandleFees(ISetToken _setToken, ActionInfo memory _issueInfo) internal {
        weth.transfer(address(_setToken), _issueInfo.netFlowQuantity);

        if (_issueInfo.protocolFees > 0) {
            weth.transfer(controller.feeRecipient(), _issueInfo.protocolFees);
        }

        if (_issueInfo.managerFee > 0) {
            weth.transfer(navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);
        }
    }

    function _handleIssueStateUpdates(
        ISetToken _setToken,
        address _reserveAsset,
        address _to,
        ActionInfo memory _issueInfo
    )
        internal
    {
        _setToken.editPositionMultiplier(_issueInfo.newPositionMultiplier);

        _setToken.editDefaultPosition(_reserveAsset, _issueInfo.newReservePositionUnit);

        _setToken.mint(_to, _issueInfo.setTokenQuantity);

        emit SetTokenNAVIssued(
            _setToken,
            msg.sender,
            _to,
            _reserveAsset,
            address(navIssuanceSettings[_setToken].managerIssuanceHook),
            _issueInfo.setTokenQuantity,
            _issueInfo.managerFee,
            _issueInfo.protocolFees
        );
    }

    function _handleRedeemStateUpdates(
        ISetToken _setToken,
        address _reserveAsset,
        address _to,
        ActionInfo memory _redeemInfo
    )
        internal
    {
        _setToken.editPositionMultiplier(_redeemInfo.newPositionMultiplier);

        _setToken.editDefaultPosition(_reserveAsset, _redeemInfo.newReservePositionUnit);

        emit SetTokenNAVRedeemed(
            _setToken,
            msg.sender,
            _to,
            _reserveAsset,
            address(navIssuanceSettings[_setToken].managerRedemptionHook),
            _redeemInfo.setTokenQuantity,
            _redeemInfo.managerFee,
            _redeemInfo.protocolFees
        );
    }

    function _handleRedemptionFees(ISetToken _setToken, address _reserveAsset, ActionInfo memory _redeemInfo) internal {
        // Instruct the SetToken to transfer protocol fee to fee recipient if there is a fee
        payProtocolFeeFromSetToken(_setToken, _reserveAsset, _redeemInfo.protocolFees);

        // Instruct the SetToken to transfer manager fee to manager fee recipient if there is a fee
        if (_redeemInfo.managerFee > 0) {
            _setToken.strictInvokeTransfer(
                _reserveAsset,
                navIssuanceSettings[_setToken].feeRecipient,
                _redeemInfo.managerFee
            );
        }
    }

    /**
     * Returns the issue premium percentage. Virtual function that can be overridden in future versions of the module
     * and can contain arbitrary logic to calculate the issuance premium.
     */
    function _getIssuePremium(
        ISetToken _setToken,
        address /* _reserveAsset */,
        uint256 /* _reserveAssetQuantity */
    )
        virtual
        internal
        view
        returns (uint256)
    {
        return navIssuanceSettings[_setToken].premiumPercentage;
    }

    /**
     * Returns the redeem premium percentage. Virtual function that can be overridden in future versions of the module
     * and can contain arbitrary logic to calculate the redemption premium.
     */
    function _getRedeemPremium(
        ISetToken _setToken,
        address /* _reserveAsset */,
        uint256 /* _setTokenQuantity */
    )
        virtual
        internal
        view
        returns (uint256)
    {
        return navIssuanceSettings[_setToken].premiumPercentage;
    }

    /**
     * Returns the fees attributed to the manager and the protocol. The fees are calculated as follows:
     *
     * ManagerFee = (manager fee % - % to protocol) * reserveAssetQuantity
     * Protocol Fee = (% manager fee share + direct fee %) * reserveAssetQuantity
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAssetQuantity         Quantity of reserve asset to calculate fees from
     * @param _protocolManagerFeeIndex      Index to pull rev share NAV Issuance fee from the Controller
     * @param _protocolDirectFeeIndex       Index to pull direct NAV issuance fee from the Controller
     * @param _managerFeeIndex              Index from NAVIssuanceSettings (0 = issue fee, 1 = redeem fee)
     *
     * @return  uint256                     Fees paid to the protocol in reserve asset
     * @return  uint256                     Fees paid to the manager in reserve asset
     * @return  uint256                     Net reserve to user net of fees
     */
    function _getFees(
        ISetToken _setToken,
        uint256 _reserveAssetQuantity,
        uint256 _protocolManagerFeeIndex,
        uint256 _protocolDirectFeeIndex,
        uint256 _managerFeeIndex
    )
        internal
        view
        returns (uint256, uint256, uint256)
    {
        (uint256 protocolFeePercentage, uint256 managerFeePercentage) = _getProtocolAndManagerFeePercentages(
            _setToken,
            _protocolManagerFeeIndex,
            _protocolDirectFeeIndex,
            _managerFeeIndex
        );

        // Calculate total notional fees
        uint256 protocolFees = protocolFeePercentage.preciseMul(_reserveAssetQuantity);
        uint256 managerFee = managerFeePercentage.preciseMul(_reserveAssetQuantity);

        uint256 netReserveFlow = _reserveAssetQuantity.sub(protocolFees).sub(managerFee);

        return (protocolFees, managerFee, netReserveFlow);
    }

    function _getProtocolAndManagerFeePercentages(
        ISetToken _setToken,
        uint256 _protocolManagerFeeIndex,
        uint256 _protocolDirectFeeIndex,
        uint256 _managerFeeIndex
    )
        internal
        view
        returns(uint256, uint256)
    {
        // Get protocol fee percentages
        uint256 protocolDirectFeePercent = controller.getModuleFee(address(this), _protocolDirectFeeIndex);
        uint256 protocolManagerShareFeePercent = controller.getModuleFee(address(this), _protocolManagerFeeIndex);
        uint256 managerFeePercent = navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];

        // Calculate revenue share split percentage
        uint256 protocolRevenueSharePercentage = protocolManagerShareFeePercent.preciseMul(managerFeePercent);
        uint256 managerRevenueSharePercentage = managerFeePercent.sub(protocolRevenueSharePercentage);
        uint256 totalProtocolFeePercentage = protocolRevenueSharePercentage.add(protocolDirectFeePercent);

        return (totalProtocolFeePercentage, managerRevenueSharePercentage);
    }

    function _getSetTokenMintQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _netReserveFlows,            // Value of reserve asset net of fees
        uint256 _setTotalSupply
    )
        internal
        view
        returns (uint256)
    {
        uint256 premiumPercentage = _getIssuePremium(_setToken, _reserveAsset, _netReserveFlows);
        uint256 premiumValue = _netReserveFlows.preciseMul(premiumPercentage);

        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (1e18)
        // Reverts if price is not found
        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);

        // Get reserve asset decimals
        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();
        uint256 normalizedTotalReserveQuantityNetFees = _netReserveFlows.preciseDiv(10 ** reserveAssetDecimals);
        uint256 normalizedTotalReserveQuantityNetFeesAndPremium = _netReserveFlows.sub(premiumValue).preciseDiv(10 ** reserveAssetDecimals);

        // Calculate SetTokens to mint to issuer
        uint256 denominator = _setTotalSupply.preciseMul(setTokenValuation).add(normalizedTotalReserveQuantityNetFees).sub(normalizedTotalReserveQuantityNetFeesAndPremium);
        return normalizedTotalReserveQuantityNetFeesAndPremium.preciseMul(_setTotalSupply).preciseDiv(denominator);
    }

    function _getRedeemReserveQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        internal
        view
        returns (uint256)
    {
        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (10e18)
        // Reverts if price is not found
        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);

        uint256 totalRedeemValueInPreciseUnits = _setTokenQuantity.preciseMul(setTokenValuation);
        // Get reserve asset decimals
        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();
        uint256 prePremiumReserveQuantity = totalRedeemValueInPreciseUnits.preciseMul(10 ** reserveAssetDecimals);

        uint256 premiumPercentage = _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);
        uint256 premiumQuantity = prePremiumReserveQuantity.preciseMulCeil(premiumPercentage);

        return prePremiumReserveQuantity.sub(premiumQuantity);
    }

    /**
     * The new position multiplier is calculated as follows:
     * inflationPercentage = (newSupply - oldSupply) / newSupply
     * newMultiplier = (1 - inflationPercentage) * positionMultiplier
     */
    function _getIssuePositionMultiplier(
        ISetToken _setToken,
        ActionInfo memory _issueInfo
    )
        internal
        view
        returns (uint256, int256)
    {
        // Calculate inflation and new position multiplier. Note: Round inflation up in order to round position multiplier down
        uint256 newTotalSupply = _issueInfo.setTokenQuantity.add(_issueInfo.previousSetTokenSupply);
        int256 newPositionMultiplier = _setToken.positionMultiplier()
            .mul(_issueInfo.previousSetTokenSupply.toInt256())
            .div(newTotalSupply.toInt256());

        return (newTotalSupply, newPositionMultiplier);
    }

    /**
     * Calculate deflation and new position multiplier. Note: Round deflation down in order to round position multiplier down
     *
     * The new position multiplier is calculated as follows:
     * deflationPercentage = (oldSupply - newSupply) / newSupply
     * newMultiplier = (1 + deflationPercentage) * positionMultiplier
     */
    function _getRedeemPositionMultiplier(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        ActionInfo memory _redeemInfo
    )
        internal
        view
        returns (uint256, int256)
    {
        uint256 newTotalSupply = _redeemInfo.previousSetTokenSupply.sub(_setTokenQuantity);
        int256 newPositionMultiplier = _setToken.positionMultiplier()
            .mul(_redeemInfo.previousSetTokenSupply.toInt256())
            .div(newTotalSupply.toInt256());

        return (newTotalSupply, newPositionMultiplier);
    }

    /**
     * The new position reserve asset unit is calculated as follows:
     * totalReserve = (oldUnit * oldSetTokenSupply) + reserveQuantity
     * newUnit = totalReserve / newSetTokenSupply
     */
    function _getIssuePositionUnit(
        ISetToken _setToken,
        address _reserveAsset,
        ActionInfo memory _issueInfo
    )
        internal
        view
        returns (uint256)
    {
        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();
        uint256 totalReserve = existingUnit
            .preciseMul(_issueInfo.previousSetTokenSupply)
            .add(_issueInfo.netFlowQuantity);

        return totalReserve.preciseDiv(_issueInfo.newSetTokenSupply);
    }

    /**
     * The new position reserve asset unit is calculated as follows:
     * totalReserve = (oldUnit * oldSetTokenSupply) - reserveQuantityToSendOut
     * newUnit = totalReserve / newSetTokenSupply
     */
    function _getRedeemPositionUnit(
        ISetToken _setToken,
        address _reserveAsset,
        ActionInfo memory _redeemInfo
    )
        internal
        view
        returns (uint256)
    {
        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();
        uint256 totalExistingUnits = existingUnit.preciseMul(_redeemInfo.previousSetTokenSupply);

        uint256 outflow = _redeemInfo.netFlowQuantity.add(_redeemInfo.protocolFees).add(_redeemInfo.managerFee);

        // Require withdrawable quantity is greater than existing collateral
        require(totalExistingUnits >= outflow, "Must be greater than total available collateral");

        return totalExistingUnits.sub(outflow).preciseDiv(_redeemInfo.newSetTokenSupply);
    }

    /**
     * If a pre-issue hook has been configured, call the external-protocol contract. Pre-issue hook logic
     * can contain arbitrary logic including validations, external function calls, etc.
     */
    function _callPreIssueHooks(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity,
        address _caller,
        address _to
    )
        internal
    {
        INAVIssuanceHook preIssueHook = navIssuanceSettings[_setToken].managerIssuanceHook;
        if (address(preIssueHook) != address(0)) {
            preIssueHook.invokePreIssueHook(_setToken, _reserveAsset, _reserveAssetQuantity, _caller, _to);
        }
    }

    /**
     * If a pre-redeem hook has been configured, call the external-protocol contract.
     */
    function _callPreRedeemHooks(ISetToken _setToken, uint256 _setQuantity, address _caller, address _to) internal {
        INAVIssuanceHook preRedeemHook = navIssuanceSettings[_setToken].managerRedemptionHook;
        if (address(preRedeemHook) != address(0)) {
            preRedeemHook.invokePreRedeemHook(_setToken, _setQuantity, _caller, _to);
        }
    }
}.]

Certainly

[2024-01-09 05:31:15 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /*     Copyright 2020 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol"; import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol"; import { SignedSafeMath } from "@openzeppelin/contracts/math/SignedSafeMath.sol"; import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol"; import { IController } from "../../interfaces/IController.sol"; import { INAVIssuanceHook } from "../../interfaces/INAVIssuanceHook.sol"; import { Invoke } from "../lib/Invoke.sol"; import { ISetToken } from "../../interfaces/ISetToken.sol"; import { IWETH } from "../../interfaces/external/IWETH.sol"; import { ModuleBase } from "../lib/ModuleBase.sol"; import { Position } from "../lib/Position.sol"; import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol"; import { ResourceIdentifier } from "../lib/ResourceIdentifier.sol"; /*  * @title NavIssuanceModule  * @author Set Protocol  *  * Module that enables issuance and redemption with any valid ERC20 token or ETH if allowed by the manager. Sender receives  * a proportional amount of SetTokens on issuance or ERC20 token on redemption based on the calculated net asset value using  * oracle prices. Manager is able to enforce a premium / discount on issuance / redemption to avoid arbitrage and front  * running when relying on oracle prices. Managers can charge a fee (denominated in reserve asset).  / contract NavIssuanceModule is ModuleBase, ReentrancyGuard {     using AddressArrayUtils for address[];     using Invoke for ISetToken;     using Position for ISetToken;     using PreciseUnitMath for uint256;     using PreciseUnitMath for int256;     using ResourceIdentifier for IController;     using SafeMath for uint256;     using SafeCast for int256;     using SafeCast for uint256;     using SignedSafeMath for int256; /* ============ Events ============ */  event SetTokenNAVIssued(     ISetToken indexed _setToken,     address _issuer,     address _to,     address _reserveAsset,     address _hookContract,     uint256 _setTokenQuantity,     uint256 _managerFee,     uint256 _premium );  event SetTokenNAVRedeemed(     ISetToken indexed _setToken,     address _redeemer,     address _to,     address _reserveAsset,     address _hookContract,     uint256 _setTokenQuantity,     uint256 _managerFee,     uint256 _premium );  event ReserveAssetAdded(     ISetToken indexed _setToken,     address _newReserveAsset );  event ReserveAssetRemoved(     ISetToken indexed _setToken,     address _removedReserveAsset );  event PremiumEdited(     ISetToken indexed _setToken,     uint256 _newPremium );  event ManagerFeeEdited(     ISetToken indexed _setToken,     uint256 _newManagerFee,     uint256 _index );  event FeeRecipientEdited(     ISetToken indexed _setToken,     address _feeRecipient );  /* ============ Structs ============ */  struct NAVIssuanceSettings {     INAVIssuanceHook managerIssuanceHook;      // Issuance hook configurations     INAVIssuanceHook managerRedemptionHook;    // Redemption hook configurations     address[] reserveAssets;                       // Allowed reserve assets - Must have a price enabled with the price oracle     address feeRecipient;                          // Manager fee recipient     uint256[2] managerFees;                        // Manager fees. 0 index is issue and 1 index is redeem fee (0.01% = 1e14, 1% = 1e16)     uint256 maxManagerFee;                         // Maximum fee manager is allowed to set for issue and redeem     uint256 premiumPercentage;                     // Premium percentage (0.01% = 1e14, 1% = 1e16). This premium is a buffer around oracle                                                    // prices paid by user to the SetToken, which prevents arbitrage and oracle front running     uint256 maxPremiumPercentage;                  // Maximum premium percentage manager is allowed to set (configured by manager)     uint256 minSetTokenSupply;                     // Minimum SetToken supply required for issuance and redemption                                                    // to prevent dramatic inflationary changes to the SetToken's position multiplier }  struct ActionInfo {     uint256 preFeeReserveQuantity;                 // Reserve value before fees; During issuance, represents raw quantity                                                    // During redeem, represents post-premium value     uint256 protocolFees;                          // Total protocol fees (direct + manager revenue share)     uint256 managerFee;                            // Total manager fee paid in reserve asset     uint256 netFlowQuantity;                       // When issuing, quantity of reserve asset sent to SetToken                                                    // When redeeming, quantity of reserve asset sent to redeemer     uint256 setTokenQuantity;                      // When issuing, quantity of SetTokens minted to mintee                                                    // When redeeming, quantity of SetToken redeemed     uint256 previousSetTokenSupply;                // SetToken supply prior to issue/redeem action     uint256 newSetTokenSupply;                     // SetToken supply after issue/redeem action     int256 newPositionMultiplier;                  // SetToken position multiplier after issue/redeem     uint256 newReservePositionUnit;                // SetToken reserve asset position unit after issue/redeem }  /* ============ State Variables ============ */  // Wrapped ETH address IWETH public immutable weth;  // Mapping of SetToken to NAV issuance settings struct mapping(ISetToken =&gt; NAVIssuanceSettings) public navIssuanceSettings;  // Mapping to efficiently check a SetToken's reserve asset validity // SetToken =&gt; reserveAsset =&gt; isReserveAsset mapping(ISetToken =&gt; mapping(address =&gt; bool)) public isReserveAsset;  /* ============ Constants ============ */  // 0 index stores the manager fee in managerFees array, percentage charged on issue (denominated in reserve asset) uint256 constant internal MANAGER_ISSUE_FEE_INDEX = 0;  // 1 index stores the manager fee percentage in managerFees array, charged on redeem uint256 constant internal MANAGER_REDEEM_FEE_INDEX = 1;  // 0 index stores the manager revenue share protocol fee % on the controller, charged in the issuance function uint256 constant internal PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX = 0;  // 1 index stores the manager revenue share protocol fee % on the controller, charged in the redeem function uint256 constant internal PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX = 1;  // 2 index stores the direct protocol fee % on the controller, charged in the issuance function uint256 constant internal PROTOCOL_ISSUE_DIRECT_FEE_INDEX = 2;  // 3 index stores the direct protocol fee % on the controller, charged in the redeem function uint256 constant internal PROTOCOL_REDEEM_DIRECT_FEE_INDEX = 3;  /* ============ Constructor ============ */  /**  * @param _controller               Address of controller contract  * @param _weth                     Address of wrapped eth  */ constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {     weth = _weth; }  /* ============ External Functions ============ */  /**  * Deposits the allowed reserve asset into the SetToken and mints the appropriate % of Net Asset Value of the SetToken  * to the specified _to address.  *  * @param _setToken                     Instance of the SetToken contract  * @param _reserveAsset                 Address of the reserve asset to issue with  * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with  * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance  * @param _to                           Address to mint SetToken to  */ function issue(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity,     uint256 _minSetTokenReceiveQuantity,     address _to )     external     nonReentrant     onlyValidAndInitializedSet(_setToken) {     _validateCommon(_setToken, _reserveAsset, _reserveAssetQuantity);      _callPreIssueHooks(_setToken, _reserveAsset, _reserveAssetQuantity, msg.sender, _to);      ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, _reserveAsset, _reserveAssetQuantity);      _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);      _transferCollateralAndHandleFees(_setToken, IERC20(_reserveAsset), issueInfo);      _handleIssueStateUpdates(_setToken, _reserveAsset, _to, issueInfo); }  /**  * Wraps ETH and deposits WETH if allowed into the SetToken and mints the appropriate % of Net Asset Value of the SetToken  * to the specified _to address.  *  * @param _setToken                     Instance of the SetToken contract  * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance  * @param _to                           Address to mint SetToken to  */ function issueWithEther(     ISetToken _setToken,     uint256 _minSetTokenReceiveQuantity,     address _to )     external     payable     nonReentrant     onlyValidAndInitializedSet(_setToken) {     weth.deposit{ value: msg.value }();      _validateCommon(_setToken, address(weth), msg.value);      _callPreIssueHooks(_setToken, address(weth), msg.value, msg.sender, _to);      ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, address(weth), msg.value);      _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);      _transferWETHAndHandleFees(_setToken, issueInfo);      _handleIssueStateUpdates(_setToken, address(weth), _to, issueInfo); }  /**  * Redeems a SetToken into a valid reserve asset representing the appropriate % of Net Asset Value of the SetToken  * to the specified _to address. Only valid if there are available reserve units on the SetToken.  *  * @param _setToken                     Instance of the SetToken contract  * @param _reserveAsset                 Address of the reserve asset to redeem with  * @param _setTokenQuantity             Quantity of SetTokens to redeem  * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive  * @param _to                           Address to redeem reserve asset to  */ function redeem(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity,     uint256 _minReserveReceiveQuantity,     address _to )     external     nonReentrant     onlyValidAndInitializedSet(_setToken) {     _validateCommon(_setToken, _reserveAsset, _setTokenQuantity);      _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);      ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, _reserveAsset, _setTokenQuantity);      _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);      _setToken.burn(msg.sender, _setTokenQuantity);      // Instruct the SetToken to transfer the reserve asset back to the user     _setToken.strictInvokeTransfer(         _reserveAsset,         _to,         redeemInfo.netFlowQuantity     );      _handleRedemptionFees(_setToken, _reserveAsset, redeemInfo);      _handleRedeemStateUpdates(_setToken, _reserveAsset, _to, redeemInfo); }  /**  * Redeems a SetToken into Ether (if WETH is valid) representing the appropriate % of Net Asset Value of the SetToken  * to the specified _to address. Only valid if there are available WETH units on the SetToken.  *  * @param _setToken                     Instance of the SetToken contract  * @param _setTokenQuantity             Quantity of SetTokens to redeem  * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive  * @param _to                           Address to redeem reserve asset to  */ function redeemIntoEther(     ISetToken _setToken,     uint256 _setTokenQuantity,     uint256 _minReserveReceiveQuantity,     address payable _to )     external     nonReentrant     onlyValidAndInitializedSet(_setToken) {     _validateCommon(_setToken, address(weth), _setTokenQuantity);      _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);      ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, address(weth), _setTokenQuantity);      _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);      _setToken.burn(msg.sender, _setTokenQuantity);      // Instruct the SetToken to transfer WETH from SetToken to module     _setToken.strictInvokeTransfer(         address(weth),         address(this),         redeemInfo.netFlowQuantity     );      weth.withdraw(redeemInfo.netFlowQuantity);      _to.transfer(redeemInfo.netFlowQuantity);      _handleRedemptionFees(_setToken, address(weth), redeemInfo);      _handleRedeemStateUpdates(_setToken, address(weth), _to, redeemInfo); }  /**  * SET MANAGER ONLY. Add an allowed reserve asset  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset to add  */ function addReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {     require(!isReserveAsset[_setToken][_reserveAsset], "Reserve asset already exists");      navIssuanceSettings[_setToken].reserveAssets.push(_reserveAsset);     isReserveAsset[_setToken][_reserveAsset] = true;      emit ReserveAssetAdded(_setToken, _reserveAsset); }  /**  * SET MANAGER ONLY. Remove a reserve asset  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset to remove  */ function removeReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {     require(isReserveAsset[_setToken][_reserveAsset], "Reserve asset does not exist");      navIssuanceSettings[_setToken].reserveAssets = navIssuanceSettings[_setToken].reserveAssets.remove(_reserveAsset);     delete isReserveAsset[_setToken][_reserveAsset];      emit ReserveAssetRemoved(_setToken, _reserveAsset); }  /**  * SET MANAGER ONLY. Edit the premium percentage  *  * @param _setToken                     Instance of the SetToken  * @param _premiumPercentage            Premium percentage in 10e16 (e.g. 10e16 = 1%)  */ function editPremium(ISetToken _setToken, uint256 _premiumPercentage) external onlyManagerAndValidSet(_setToken) {     require(_premiumPercentage &lt;= navIssuanceSettings[_setToken].maxPremiumPercentage, "Premium must be less than maximum allowed");      navIssuanceSettings[_setToken].premiumPercentage = _premiumPercentage;      emit PremiumEdited(_setToken, _premiumPercentage); }  /**  * SET MANAGER ONLY. Edit manager fee  *  * @param _setToken                     Instance of the SetToken  * @param _managerFeePercentage         Manager fee percentage in 10e16 (e.g. 10e16 = 1%)  * @param _managerFeeIndex              Manager fee index. 0 index is issue fee, 1 index is redeem fee  */ function editManagerFee(     ISetToken _setToken,     uint256 _managerFeePercentage,     uint256 _managerFeeIndex )     external     onlyManagerAndValidSet(_setToken) {     require(_managerFeePercentage &lt;= navIssuanceSettings[_setToken].maxManagerFee, "Manager fee must be less than maximum allowed");      navIssuanceSettings[_setToken].managerFees[_managerFeeIndex] = _managerFeePercentage;      emit ManagerFeeEdited(_setToken, _managerFeePercentage, _managerFeeIndex); }  /**  * SET MANAGER ONLY. Edit the manager fee recipient  *  * @param _setToken                     Instance of the SetToken  * @param _managerFeeRecipient          Manager fee recipient  */ function editFeeRecipient(ISetToken _setToken, address _managerFeeRecipient) external onlyManagerAndValidSet(_setToken) {     require(_managerFeeRecipient != address(0), "Fee recipient must not be 0 address");      navIssuanceSettings[_setToken].feeRecipient = _managerFeeRecipient;      emit FeeRecipientEdited(_setToken, _managerFeeRecipient); }  /**  * SET MANAGER ONLY. Initializes this module to the SetToken with hooks, allowed reserve assets,  * fees and issuance premium. Only callable by the SetToken's manager. Hook addresses are optional.  * Address(0) means that no hook will be called.  *  * @param _setToken                     Instance of the SetToken to issue  * @param _navIssuanceSettings          NAVIssuanceSettings struct defining parameters  */ function initialize(     ISetToken _setToken,     NAVIssuanceSettings memory _navIssuanceSettings )     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     require(_navIssuanceSettings.reserveAssets.length &gt; 0, "Reserve assets must be greater than 0");     require(_navIssuanceSettings.maxManagerFee &lt; PreciseUnitMath.preciseUnit(), "Max manager fee must be less than 100%");     require(_navIssuanceSettings.maxPremiumPercentage &lt; PreciseUnitMath.preciseUnit(), "Max premium percentage must be less than 100%");     require(_navIssuanceSettings.managerFees[0] &lt;= _navIssuanceSettings.maxManagerFee, "Manager issue fee must be less than max");     require(_navIssuanceSettings.managerFees[1] &lt;= _navIssuanceSettings.maxManagerFee, "Manager redeem fee must be less than max");     require(_navIssuanceSettings.premiumPercentage &lt;= _navIssuanceSettings.maxPremiumPercentage, "Premium must be less than max");     require(_navIssuanceSettings.feeRecipient != address(0), "Fee Recipient must be non-zero address.");     // Initial mint of Set cannot use NAVIssuance since minSetTokenSupply must be &gt; 0     require(_navIssuanceSettings.minSetTokenSupply &gt; 0, "Min SetToken supply must be greater than 0");      for (uint256 i = 0; i &lt; _navIssuanceSettings.reserveAssets.length; i++) {         require(!isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]], "Reserve assets must be unique");         isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]] = true;     }      navIssuanceSettings[_setToken] = _navIssuanceSettings;      _setToken.initializeModule(); }  /**  * Removes this module from the SetToken, via call by the SetToken. Issuance settings and  * reserve asset states are deleted.  */ function removeModule() external override {     ISetToken setToken = ISetToken(msg.sender);     for (uint256 i = 0; i &lt; navIssuanceSettings[setToken].reserveAssets.length; i++) {         delete isReserveAsset[setToken][navIssuanceSettings[setToken].reserveAssets[i]];     }      delete navIssuanceSettings[setToken]; }  receive() external payable {}  /* ============ External Getter Functions ============ */  function getReserveAssets(ISetToken _setToken) external view returns (address[] memory) {     return navIssuanceSettings[_setToken].reserveAssets; }  function getIssuePremium(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     external     view     returns (uint256) {     return _getIssuePremium(_setToken, _reserveAsset, _reserveAssetQuantity); }  function getRedeemPremium(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     external     view     returns (uint256) {     return _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity); }  function getManagerFee(ISetToken _setToken, uint256 _managerFeeIndex) external view returns (uint256) {     return navIssuanceSettings[_setToken].managerFees[_managerFeeIndex]; }  /**  * Get the expected SetTokens minted to recipient on issuance  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with  *  * @return  uint256                     Expected SetTokens to be minted to recipient  */ function getExpectedSetTokenIssueQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     external     view     returns (uint256) {     (,, uint256 netReserveFlow) = _getFees(         _setToken,         _reserveAssetQuantity,         PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_ISSUE_DIRECT_FEE_INDEX,         MANAGER_ISSUE_FEE_INDEX     );      uint256 setTotalSupply = _setToken.totalSupply();      return _getSetTokenMintQuantity(         _setToken,         _reserveAsset,         netReserveFlow,         setTotalSupply     ); }  /**  * Get the expected reserve asset to be redeemed  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _setTokenQuantity             Quantity of SetTokens to redeem  *  * @return  uint256                     Expected reserve asset quantity redeemed  */ function getExpectedReserveRedeemQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     external     view     returns (uint256) {     uint256 preFeeReserveQuantity = _getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);      (,, uint256 netReserveFlows) = _getFees(         _setToken,         preFeeReserveQuantity,         PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_REDEEM_DIRECT_FEE_INDEX,         MANAGER_REDEEM_FEE_INDEX     );      return netReserveFlows; }  /**  * Checks if issue is valid  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with  *  * @return  bool                        Returns true if issue is valid  */ function isIssueValid(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     external     view     returns (bool) {     uint256 setTotalSupply = _setToken.totalSupply();  return _reserveAssetQuantity != 0         &amp;&amp; isReserveAsset[_setToken][_reserveAsset]         &amp;&amp; setTotalSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply; }  /**  * Checks if redeem is valid  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _setTokenQuantity             Quantity of SetTokens to redeem  *  * @return  bool                        Returns true if redeem is valid  */ function isRedeemValid(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     external     view     returns (bool) {     uint256 setTotalSupply = _setToken.totalSupply();      if (         _setTokenQuantity == 0         || !isReserveAsset[_setToken][_reserveAsset]         || setTotalSupply &lt; navIssuanceSettings[_setToken].minSetTokenSupply.add(_setTokenQuantity)     ) {         return false;     } else {         uint256 totalRedeemValue =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);          (,, uint256 expectedRedeemQuantity) = _getFees(             _setToken,             totalRedeemValue,             PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,             PROTOCOL_REDEEM_DIRECT_FEE_INDEX,             MANAGER_REDEEM_FEE_INDEX         );          uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();          return existingUnit.preciseMul(setTotalSupply) &gt;= expectedRedeemQuantity;     } }  /* ============ Internal Functions ============ */  function _validateCommon(ISetToken _setToken, address _reserveAsset, uint256 _quantity) internal view {     require(_quantity &gt; 0, "Quantity must be &gt; 0");     require(isReserveAsset[_setToken][_reserveAsset], "Must be valid reserve asset"); }  function _validateIssuanceInfo(ISetToken _setToken, uint256 _minSetTokenReceiveQuantity, ActionInfo memory _issueInfo) internal view {     // Check that total supply is greater than min supply needed for issuance     // Note: A min supply amount is needed to avoid division by 0 when SetToken supply is 0     require(         _issueInfo.previousSetTokenSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply,         "Supply must be greater than minimum to enable issuance"     );      require(_issueInfo.setTokenQuantity &gt;= _minSetTokenReceiveQuantity, "Must be greater than min SetToken"); }  function _validateRedemptionInfo(     ISetToken _setToken,     uint256 _minReserveReceiveQuantity,     ActionInfo memory _redeemInfo )     internal     view {     // Check that new supply is more than min supply needed for redemption     // Note: A min supply amount is needed to avoid division by 0 when redeeming SetToken to 0     require(         _redeemInfo.newSetTokenSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply,         "Supply must be greater than minimum to enable redemption"     );      require(_redeemInfo.netFlowQuantity &gt;= _minReserveReceiveQuantity, "Must be greater than min receive reserve quantity"); }  function _createIssuanceInfo(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     internal     view     returns (ActionInfo memory) {     ActionInfo memory issueInfo;      issueInfo.previousSetTokenSupply = _setToken.totalSupply();      issueInfo.preFeeReserveQuantity = _reserveAssetQuantity;      (issueInfo.protocolFees, issueInfo.managerFee, issueInfo.netFlowQuantity) = _getFees(         _setToken,         issueInfo.preFeeReserveQuantity,         PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_ISSUE_DIRECT_FEE_INDEX,         MANAGER_ISSUE_FEE_INDEX     );      issueInfo.setTokenQuantity = _getSetTokenMintQuantity(         _setToken,         _reserveAsset,         issueInfo.netFlowQuantity,         issueInfo.previousSetTokenSupply     );      (issueInfo.newSetTokenSupply, issueInfo.newPositionMultiplier) = _getIssuePositionMultiplier(_setToken, issueInfo);      issueInfo.newReservePositionUnit = _getIssuePositionUnit(_setToken, _reserveAsset, issueInfo);      return issueInfo; }  function _createRedemptionInfo(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     internal     view     returns (ActionInfo memory) {     ActionInfo memory redeemInfo;      redeemInfo.setTokenQuantity = _setTokenQuantity;      redeemInfo.preFeeReserveQuantity =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);      (redeemInfo.protocolFees, redeemInfo.managerFee, redeemInfo.netFlowQuantity) = _getFees(         _setToken,         redeemInfo.preFeeReserveQuantity,         PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_REDEEM_DIRECT_FEE_INDEX,         MANAGER_REDEEM_FEE_INDEX     );      redeemInfo.previousSetTokenSupply = _setToken.totalSupply();      (redeemInfo.newSetTokenSupply, redeemInfo.newPositionMultiplier) = _getRedeemPositionMultiplier(_setToken, _setTokenQuantity, redeemInfo);      redeemInfo.newReservePositionUnit = _getRedeemPositionUnit(_setToken, _reserveAsset, redeemInfo);      return redeemInfo; }  /**  * Transfer reserve asset from user to SetToken and fees from user to appropriate fee recipients  */ function _transferCollateralAndHandleFees(ISetToken _setToken, IERC20 _reserveAsset, ActionInfo memory _issueInfo) internal {     transferFrom(_reserveAsset, msg.sender, address(_setToken), _issueInfo.netFlowQuantity);      if (_issueInfo.protocolFees &gt; 0) {         transferFrom(_reserveAsset, msg.sender, controller.feeRecipient(), _issueInfo.protocolFees);     }      if (_issueInfo.managerFee &gt; 0) {         transferFrom(_reserveAsset, msg.sender, navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);     } }   /**   * Transfer WETH from module to SetToken and fees from module to appropriate fee recipients  */ function _transferWETHAndHandleFees(ISetToken _setToken, ActionInfo memory _issueInfo) internal {     weth.transfer(address(_setToken), _issueInfo.netFlowQuantity);      if (_issueInfo.protocolFees &gt; 0) {         weth.transfer(controller.feeRecipient(), _issueInfo.protocolFees);     }      if (_issueInfo.managerFee &gt; 0) {         weth.transfer(navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);     } }  function _handleIssueStateUpdates(     ISetToken _setToken,     address _reserveAsset,     address _to,     ActionInfo memory _issueInfo )     internal {     _setToken.editPositionMultiplier(_issueInfo.newPositionMultiplier);      _setToken.editDefaultPosition(_reserveAsset, _issueInfo.newReservePositionUnit);      _setToken.mint(_to, _issueInfo.setTokenQuantity);      emit SetTokenNAVIssued(         _setToken,         msg.sender,         _to,         _reserveAsset,         address(navIssuanceSettings[_setToken].managerIssuanceHook),         _issueInfo.setTokenQuantity,         _issueInfo.managerFee,         _issueInfo.protocolFees     ); }  function _handleRedeemStateUpdates(     ISetToken _setToken,     address _reserveAsset,     address _to,     ActionInfo memory _redeemInfo )     internal {     _setToken.editPositionMultiplier(_redeemInfo.newPositionMultiplier);      _setToken.editDefaultPosition(_reserveAsset, _redeemInfo.newReservePositionUnit);      emit SetTokenNAVRedeemed(         _setToken,         msg.sender,         _to,         _reserveAsset,         address(navIssuanceSettings[_setToken].managerRedemptionHook),         _redeemInfo.setTokenQuantity,         _redeemInfo.managerFee,         _redeemInfo.protocolFees     ); }  function _handleRedemptionFees(ISetToken _setToken, address _reserveAsset, ActionInfo memory _redeemInfo) internal {     // Instruct the SetToken to transfer protocol fee to fee recipient if there is a fee     payProtocolFeeFromSetToken(_setToken, _reserveAsset, _redeemInfo.protocolFees);      // Instruct the SetToken to transfer manager fee to manager fee recipient if there is a fee     if (_redeemInfo.managerFee &gt; 0) {         _setToken.strictInvokeTransfer(             _reserveAsset,             navIssuanceSettings[_setToken].feeRecipient,             _redeemInfo.managerFee         );     } }  /**  * Returns the issue premium percentage. Virtual function that can be overridden in future versions of the module  * and can contain arbitrary logic to calculate the issuance premium.  */ function _getIssuePremium(     ISetToken _setToken,     address /* _reserveAsset */,     uint256 /* _reserveAssetQuantity */ )     virtual     internal     view     returns (uint256) {     return navIssuanceSettings[_setToken].premiumPercentage; }  /**  * Returns the redeem premium percentage. Virtual function that can be overridden in future versions of the module  * and can contain arbitrary logic to calculate the redemption premium.  */ function _getRedeemPremium(     ISetToken _setToken,     address /* _reserveAsset */,     uint256 /* _setTokenQuantity */ )     virtual     internal     view     returns (uint256) {     return navIssuanceSettings[_setToken].premiumPercentage; }  /**  * Returns the fees attributed to the manager and the protocol. The fees are calculated as follows:  *  * ManagerFee = (manager fee % - % to protocol) * reserveAssetQuantity  * Protocol Fee = (% manager fee share + direct fee %) * reserveAssetQuantity  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAssetQuantity         Quantity of reserve asset to calculate fees from  * @param _protocolManagerFeeIndex      Index to pull rev share NAV Issuance fee from the Controller  * @param _protocolDirectFeeIndex       Index to pull direct NAV issuance fee from the Controller  * @param _managerFeeIndex              Index from NAVIssuanceSettings (0 = issue fee, 1 = redeem fee)  *  * @return  uint256                     Fees paid to the protocol in reserve asset  * @return  uint256                     Fees paid to the manager in reserve asset  * @return  uint256                     Net reserve to user net of fees  */ function _getFees(     ISetToken _setToken,     uint256 _reserveAssetQuantity,     uint256 _protocolManagerFeeIndex,     uint256 _protocolDirectFeeIndex,     uint256 _managerFeeIndex )     internal     view     returns (uint256, uint256, uint256) {     (uint256 protocolFeePercentage, uint256 managerFeePercentage) = _getProtocolAndManagerFeePercentages(         _setToken,         _protocolManagerFeeIndex,         _protocolDirectFeeIndex,         _managerFeeIndex     );      // Calculate total notional fees     uint256 protocolFees = protocolFeePercentage.preciseMul(_reserveAssetQuantity);     uint256 managerFee = managerFeePercentage.preciseMul(_reserveAssetQuantity);      uint256 netReserveFlow = _reserveAssetQuantity.sub(protocolFees).sub(managerFee);      return (protocolFees, managerFee, netReserveFlow); }  function _getProtocolAndManagerFeePercentages(     ISetToken _setToken,     uint256 _protocolManagerFeeIndex,     uint256 _protocolDirectFeeIndex,     uint256 _managerFeeIndex )     internal     view     returns(uint256, uint256) {     // Get protocol fee percentages     uint256 protocolDirectFeePercent = controller.getModuleFee(address(this), _protocolDirectFeeIndex);     uint256 protocolManagerShareFeePercent = controller.getModuleFee(address(this), _protocolManagerFeeIndex);     uint256 managerFeePercent = navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];      // Calculate revenue share split percentage     uint256 protocolRevenueSharePercentage = protocolManagerShareFeePercent.preciseMul(managerFeePercent);     uint256 managerRevenueSharePercentage = managerFeePercent.sub(protocolRevenueSharePercentage);     uint256 totalProtocolFeePercentage = protocolRevenueSharePercentage.add(protocolDirectFeePercent);      return (totalProtocolFeePercentage, managerRevenueSharePercentage); }  function _getSetTokenMintQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _netReserveFlows,            // Value of reserve asset net of fees     uint256 _setTotalSupply )     internal     view     returns (uint256) {     uint256 premiumPercentage = _getIssuePremium(_setToken, _reserveAsset, _netReserveFlows);     uint256 premiumValue = _netReserveFlows.preciseMul(premiumPercentage);      // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (1e18)     // Reverts if price is not found     uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);      // Get reserve asset decimals     uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();     uint256 normalizedTotalReserveQuantityNetFees = _netReserveFlows.preciseDiv(10 ** reserveAssetDecimals);     uint256 normalizedTotalReserveQuantityNetFeesAndPremium = _netReserveFlows.sub(premiumValue).preciseDiv(10 ** reserveAssetDecimals);      // Calculate SetTokens to mint to issuer     uint256 denominator = _setTotalSupply.preciseMul(setTokenValuation).add(normalizedTotalReserveQuantityNetFees).sub(normalizedTotalReserveQuantityNetFeesAndPremium);     return normalizedTotalReserveQuantityNetFeesAndPremium.preciseMul(_setTotalSupply).preciseDiv(denominator); }  function _getRedeemReserveQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     internal     view     returns (uint256) {     // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (10e18)     // Reverts if price is not found     uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);      uint256 totalRedeemValueInPreciseUnits = _setTokenQuantity.preciseMul(setTokenValuation);     // Get reserve asset decimals     uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();     uint256 prePremiumReserveQuantity = totalRedeemValueInPreciseUnits.preciseMul(10 ** reserveAssetDecimals);      uint256 premiumPercentage = _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);     uint256 premiumQuantity = prePremiumReserveQuantity.preciseMulCeil(premiumPercentage);      return prePremiumReserveQuantity.sub(premiumQuantity); }  /**  * The new position multiplier is calculated as follows:  * inflationPercentage = (newSupply - oldSupply) / newSupply  * newMultiplier = (1 - inflationPercentage) * positionMultiplier  */ function _getIssuePositionMultiplier(     ISetToken _setToken,     ActionInfo memory _issueInfo )     internal     view     returns (uint256, int256) {     // Calculate inflation and new position multiplier. Note: Round inflation up in order to round position multiplier down     uint256 newTotalSupply = _issueInfo.setTokenQuantity.add(_issueInfo.previousSetTokenSupply);     int256 newPositionMultiplier = _setToken.positionMultiplier()         .mul(_issueInfo.previousSetTokenSupply.toInt256())         .div(newTotalSupply.toInt256());      return (newTotalSupply, newPositionMultiplier); }  /**  * Calculate deflation and new position multiplier. Note: Round deflation down in order to round position multiplier down  *  * The new position multiplier is calculated as follows:  * deflationPercentage = (oldSupply - newSupply) / newSupply  * newMultiplier = (1 + deflationPercentage) * positionMultiplier  */ function _getRedeemPositionMultiplier(     ISetToken _setToken,     uint256 _setTokenQuantity,     ActionInfo memory _redeemInfo )     internal     view     returns (uint256, int256) {     uint256 newTotalSupply = _redeemInfo.previousSetTokenSupply.sub(_setTokenQuantity);     int256 newPositionMultiplier = _setToken.positionMultiplier()         .mul(_redeemInfo.previousSetTokenSupply.toInt256())         .div(newTotalSupply.toInt256());      return (newTotalSupply, newPositionMultiplier); }  /**  * The new position reserve asset unit is calculated as follows:  * totalReserve = (oldUnit * oldSetTokenSupply) + reserveQuantity  * newUnit = totalReserve / newSetTokenSupply  */ function _getIssuePositionUnit(     ISetToken _setToken,     address _reserveAsset,     ActionInfo memory _issueInfo )     internal     view     returns (uint256) {     uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();     uint256 totalReserve = existingUnit         .preciseMul(_issueInfo.previousSetTokenSupply)         .add(_issueInfo.netFlowQuantity);      return totalReserve.preciseDiv(_issueInfo.newSetTokenSupply); }  /**  * The new position reserve asset unit is calculated as follows:  * totalReserve = (oldUnit * oldSetTokenSupply) - reserveQuantityToSendOut  * newUnit = totalReserve / newSetTokenSupply  */ function _getRedeemPositionUnit(     ISetToken _setToken,     address _reserveAsset,     ActionInfo memory _redeemInfo )     internal     view     returns (uint256) {     uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();     uint256 totalExistingUnits = existingUnit.preciseMul(_redeemInfo.previousSetTokenSupply);      uint256 outflow = _redeemInfo.netFlowQuantity.add(_redeemInfo.protocolFees).add(_redeemInfo.managerFee);      // Require withdrawable quantity is greater than existing collateral     require(totalExistingUnits &gt;= outflow, "Must be greater than total available collateral");      return totalExistingUnits.sub(outflow).preciseDiv(_redeemInfo.newSetTokenSupply); }  /**  * If a pre-issue hook has been configured, call the external-protocol contract. Pre-issue hook logic  * can contain arbitrary logic including validations, external function calls, etc.  */ function _callPreIssueHooks(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity,     address _caller,     address _to )     internal {     INAVIssuanceHook preIssueHook = navIssuanceSettings[_setToken].managerIssuanceHook;     if (address(preIssueHook) != address(0)) {         preIssueHook.invokePreIssueHook(_setToken, _reserveAsset, _reserveAssetQuantity, _caller, _to);     } }  /**  * If a pre-redeem hook has been configured, call the external-protocol contract.  */ function _callPreRedeemHooks(ISetToken _setToken, uint256 _setQuantity, address _caller, address _to) internal {     INAVIssuanceHook preRedeemHook = navIssuanceSettings[_setToken].managerRedemptionHook;     if (address(preRedeemHook) != address(0)) {         preRedeemHook.invokePreRedeemHook(_setToken, _setQuantity, _caller, _to);     } }  } |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **phase_prompt** | Here is a conversation between two roles: {conversations} {question} |
| **phase_name** | Reflection |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **placeholders** | {'conversations': 'Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.\nYou are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.\nYou can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites\nHere is a new customer\'s task: /\n    Copyright 2020 Set Labs Inc.\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n    SPDX-License-Identifier: Apache License, Version 2.0\n/\npragma solidity 0.6.10;\npragma experimental "ABIEncoderV2";\nimport { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";\nimport { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";\nimport { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";\nimport { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";\nimport { SignedSafeMath } from "@openzeppelin/contracts/math/SignedSafeMath.sol";\nimport { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";\nimport { IController } from "../../interfaces/IController.sol";\nimport { INAVIssuanceHook } from "../../interfaces/INAVIssuanceHook.sol";\nimport { Invoke } from "../lib/Invoke.sol";\nimport { ISetToken } from "../../interfaces/ISetToken.sol";\nimport { IWETH } from "../../interfaces/external/IWETH.sol";\nimport { ModuleBase } from "../lib/ModuleBase.sol";\nimport { Position } from "../lib/Position.sol";\nimport { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";\nimport { ResourceIdentifier } from "../lib/ResourceIdentifier.sol";\n\n/\n * @title NavIssuanceModule\n * @author Set Protocol\n \n * Module that enables issuance and redemption with any valid ERC20 token or ETH if allowed by the manager. Sender receives\n * a proportional amount of SetTokens on issuance or ERC20 token on redemption based on the calculated net asset value using\n * oracle prices. Manager is able to enforce a premium / discount on issuance / redemption to avoid arbitrage and front\n * running when relying on oracle prices. Managers can charge a fee (denominated in reserve asset).\n /\ncontract NavIssuanceModule is ModuleBase, ReentrancyGuard {\n    using AddressArrayUtils for address[];\n    using Invoke for ISetToken;\n    using Position for ISetToken;\n    using PreciseUnitMath for uint256;\n    using PreciseUnitMath for int256;\n    using ResourceIdentifier for IController;\n    using SafeMath for uint256;\n    using SafeCast for int256;\n    using SafeCast for uint256;\n    using SignedSafeMath for int256;\n    / ============ Events ============ /\n    event SetTokenNAVIssued(\n        ISetToken indexed _setToken,\n        address _issuer,\n        address _to,\n        address _reserveAsset,\n        address _hookContract,\n        uint256 _setTokenQuantity,\n        uint256 _managerFee,\n        uint256 _premium\n    );\n    event SetTokenNAVRedeemed(\n        ISetToken indexed _setToken,\n        address _redeemer,\n        address _to,\n        address _reserveAsset,\n        address _hookContract,\n        uint256 _setTokenQuantity,\n        uint256 _managerFee,\n        uint256 _premium\n    );\n    event ReserveAssetAdded(\n        ISetToken indexed _setToken,\n        address _newReserveAsset\n    );\n    event ReserveAssetRemoved(\n        ISetToken indexed _setToken,\n        address _removedReserveAsset\n    );\n    event PremiumEdited(\n        ISetToken indexed _setToken,\n        uint256 _newPremium\n    );\n    event ManagerFeeEdited(\n        ISetToken indexed _setToken,\n        uint256 _newManagerFee,\n        uint256 _index\n    );\n    event FeeRecipientEdited(\n        ISetToken indexed _setToken,\n        address _feeRecipient\n    );\n    / ============ Structs ============ /\n    struct NAVIssuanceSettings {\n        INAVIssuanceHook managerIssuanceHook;      // Issuance hook configurations\n        INAVIssuanceHook managerRedemptionHook;    // Redemption hook configurations\n        address[] reserveAssets;                       // Allowed reserve assets - Must have a price enabled with the price oracle\n        address feeRecipient;                          // Manager fee recipient\n        uint256[2] managerFees;                        // Manager fees. 0 index is issue and 1 index is redeem fee (0.01% = 1e14, 1% = 1e16)\n        uint256 maxManagerFee;                         // Maximum fee manager is allowed to set for issue and redeem\n        uint256 premiumPercentage;                     // Premium percentage (0.01% = 1e14, 1% = 1e16). This premium is a buffer around oracle\n                                                       // prices paid by user to the SetToken, which prevents arbitrage and oracle front running\n        uint256 maxPremiumPercentage;                  // Maximum premium percentage manager is allowed to set (configured by manager)\n        uint256 minSetTokenSupply;                     // Minimum SetToken supply required for issuance and redemption\n                                                       // to prevent dramatic inflationary changes to the SetToken\'s position multiplier\n    }\n    struct ActionInfo {\n        uint256 preFeeReserveQuantity;                 // Reserve value before fees; During issuance, represents raw quantity\n                                                       // During redeem, represents post-premium value\n        uint256 protocolFees;                          // Total protocol fees (direct + manager revenue share)\n        uint256 managerFee;                            // Total manager fee paid in reserve asset\n        uint256 netFlowQuantity;                       // When issuing, quantity of reserve asset sent to SetToken\n                                                       // When redeeming, quantity of reserve asset sent to redeemer\n        uint256 setTokenQuantity;                      // When issuing, quantity of SetTokens minted to mintee\n                                                       // When redeeming, quantity of SetToken redeemed\n        uint256 previousSetTokenSupply;                // SetToken supply prior to issue/redeem action\n        uint256 newSetTokenSupply;                     // SetToken supply after issue/redeem action\n        int256 newPositionMultiplier;                  // SetToken position multiplier after issue/redeem\n        uint256 newReservePositionUnit;                // SetToken reserve asset position unit after issue/redeem\n    }\n    / ============ State Variables ============ /\n    // Wrapped ETH address\n    IWETH public immutable weth;\n    // Mapping of SetToken to NAV issuance settings struct\n    mapping(ISetToken =&gt; NAVIssuanceSettings) public navIssuanceSettings;\n    // Mapping to efficiently check a SetToken\'s reserve asset validity\n    // SetToken =&gt; reserveAsset =&gt; isReserveAsset\n    mapping(ISetToken =&gt; mapping(address =&gt; bool)) public isReserveAsset;\n    / ============ Constants ============ /\n    // 0 index stores the manager fee in managerFees array, percentage charged on issue (denominated in reserve asset)\n    uint256 constant internal MANAGER_ISSUE_FEE_INDEX = 0;\n    // 1 index stores the manager fee percentage in managerFees array, charged on redeem\n    uint256 constant internal MANAGER_REDEEM_FEE_INDEX = 1;\n    // 0 index stores the manager revenue share protocol fee % on the controller, charged in the issuance function\n    uint256 constant internal PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX = 0;\n    // 1 index stores the manager revenue share protocol fee % on the controller, charged in the redeem function\n    uint256 constant internal PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX = 1;\n    // 2 index stores the direct protocol fee % on the controller, charged in the issuance function\n    uint256 constant internal PROTOCOL_ISSUE_DIRECT_FEE_INDEX = 2;\n    // 3 index stores the direct protocol fee % on the controller, charged in the redeem function\n    uint256 constant internal PROTOCOL_REDEEM_DIRECT_FEE_INDEX = 3;\n    / ============ Constructor ============ /\n    /\n     * @param _controller               Address of controller contract\n     * @param _weth                     Address of wrapped eth\n     /\n    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {\n        weth = _weth;\n    }\n    / ============ External Functions ============ /\n    /\n     * Deposits the allowed reserve asset into the SetToken and mints the appropriate % of Net Asset Value of the SetToken\n     * to the specified _to address.\n     \n     * @param _setToken                     Instance of the SetToken contract\n     * @param _reserveAsset                 Address of the reserve asset to issue with\n     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with\n     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance\n     * @param _to                           Address to mint SetToken to\n     /\n    function issue(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _reserveAssetQuantity,\n        uint256 _minSetTokenReceiveQuantity,\n        address _to\n    )\n        external\n        nonReentrant\n        onlyValidAndInitializedSet(_setToken)\n    {\n        _validateCommon(_setToken, _reserveAsset, _reserveAssetQuantity);\n        _callPreIssueHooks(_setToken, _reserveAsset, _reserveAssetQuantity, msg.sender, _to);\n        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, _reserveAsset, _reserveAssetQuantity);\n        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);\n        _transferCollateralAndHandleFees(_setToken, IERC20(_reserveAsset), issueInfo);\n        _handleIssueStateUpdates(_setToken, _reserveAsset, _to, issueInfo);\n    }\n    /\n     * Wraps ETH and deposits WETH if allowed into the SetToken and mints the appropriate % of Net Asset Value of the SetToken\n     * to the specified _to address.\n     \n     * @param _setToken                     Instance of the SetToken contract\n     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance\n     * @param _to                           Address to mint SetToken to\n     /\n    function issueWithEther(\n        ISetToken _setToken,\n        uint256 _minSetTokenReceiveQuantity,\n        address _to\n    )\n        external\n        payable\n        nonReentrant\n        onlyValidAndInitializedSet(_setToken)\n    {\n        weth.deposit{ value: msg.value }();\n        _validateCommon(_setToken, address(weth), msg.value);\n        _callPreIssueHooks(_setToken, address(weth), msg.value, msg.sender, _to);\n        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, address(weth), msg.value);\n        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);\n        _transferWETHAndHandleFees(_setToken, issueInfo);\n        _handleIssueStateUpdates(_setToken, address(weth), _to, issueInfo);\n    }\n    /\n     * Redeems a SetToken into a valid reserve asset representing the appropriate % of Net Asset Value of the SetToken\n     * to the specified _to address. Only valid if there are available reserve units on the SetToken.\n     \n     * @param _setToken                     Instance of the SetToken contract\n     * @param _reserveAsset                 Address of the reserve asset to redeem with\n     * @param _setTokenQuantity             Quantity of SetTokens to redeem\n     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive\n     * @param _to                           Address to redeem reserve asset to\n     /\n    function redeem(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _setTokenQuantity,\n        uint256 _minReserveReceiveQuantity,\n        address _to\n    )\n        external\n        nonReentrant\n        onlyValidAndInitializedSet(_setToken)\n    {\n        _validateCommon(_setToken, _reserveAsset, _setTokenQuantity);\n        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);\n        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, _reserveAsset, _setTokenQuantity);\n        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);\n        _setToken.burn(msg.sender, _setTokenQuantity);\n        // Instruct the SetToken to transfer the reserve asset back to the user\n        _setToken.strictInvokeTransfer(\n            _reserveAsset,\n            _to,\n            redeemInfo.netFlowQuantity\n        );\n        _handleRedemptionFees(_setToken, _reserveAsset, redeemInfo);\n        _handleRedeemStateUpdates(_setToken, _reserveAsset, _to, redeemInfo);\n    }\n    /\n     * Redeems a SetToken into Ether (if WETH is valid) representing the appropriate % of Net Asset Value of the SetToken\n     * to the specified _to address. Only valid if there are available WETH units on the SetToken.\n     \n     * @param _setToken                     Instance of the SetToken contract\n     * @param _setTokenQuantity             Quantity of SetTokens to redeem\n     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive\n     * @param _to                           Address to redeem reserve asset to\n     /\n    function redeemIntoEther(\n        ISetToken _setToken,\n        uint256 _setTokenQuantity,\n        uint256 _minReserveReceiveQuantity,\n        address payable _to\n    )\n        external\n        nonReentrant\n        onlyValidAndInitializedSet(_setToken)\n    {\n        _validateCommon(_setToken, address(weth), _setTokenQuantity);\n        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);\n        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, address(weth), _setTokenQuantity);\n        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);\n        _setToken.burn(msg.sender, _setTokenQuantity);\n        // Instruct the SetToken to transfer WETH from SetToken to module\n        _setToken.strictInvokeTransfer(\n            address(weth),\n            address(this),\n            redeemInfo.netFlowQuantity\n        );\n        weth.withdraw(redeemInfo.netFlowQuantity);\n        _to.transfer(redeemInfo.netFlowQuantity);\n        _handleRedemptionFees(_setToken, address(weth), redeemInfo);\n        _handleRedeemStateUpdates(_setToken, address(weth), _to, redeemInfo);\n    }\n    /\n     * SET MANAGER ONLY. Add an allowed reserve asset\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _reserveAsset                 Address of the reserve asset to add\n     /\n    function addReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {\n        require(!isReserveAsset[_setToken][_reserveAsset], "Reserve asset already exists");\n        navIssuanceSettings[_setToken].reserveAssets.push(_reserveAsset);\n        isReserveAsset[_setToken][_reserveAsset] = true;\n        emit ReserveAssetAdded(_setToken, _reserveAsset);\n    }\n    /\n     * SET MANAGER ONLY. Remove a reserve asset\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _reserveAsset                 Address of the reserve asset to remove\n     /\n    function removeReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {\n        require(isReserveAsset[_setToken][_reserveAsset], "Reserve asset does not exist");\n        navIssuanceSettings[_setToken].reserveAssets = navIssuanceSettings[_setToken].reserveAssets.remove(_reserveAsset);\n        delete isReserveAsset[_setToken][_reserveAsset];\n        emit ReserveAssetRemoved(_setToken, _reserveAsset);\n    }\n    /\n     * SET MANAGER ONLY. Edit the premium percentage\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _premiumPercentage            Premium percentage in 10e16 (e.g. 10e16 = 1%)\n     /\n    function editPremium(ISetToken _setToken, uint256 _premiumPercentage) external onlyManagerAndValidSet(_setToken) {\n        require(_premiumPercentage &lt;= navIssuanceSettings[_setToken].maxPremiumPercentage, "Premium must be less than maximum allowed");\n        navIssuanceSettings[_setToken].premiumPercentage = _premiumPercentage;\n        emit PremiumEdited(_setToken, _premiumPercentage);\n    }\n    /\n     * SET MANAGER ONLY. Edit manager fee\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _managerFeePercentage         Manager fee percentage in 10e16 (e.g. 10e16 = 1%)\n     * @param _managerFeeIndex              Manager fee index. 0 index is issue fee, 1 index is redeem fee\n     /\n    function editManagerFee(\n        ISetToken _setToken,\n        uint256 _managerFeePercentage,\n        uint256 _managerFeeIndex\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        require(_managerFeePercentage &lt;= navIssuanceSettings[_setToken].maxManagerFee, "Manager fee must be less than maximum allowed");\n        navIssuanceSettings[_setToken].managerFees[_managerFeeIndex] = _managerFeePercentage;\n        emit ManagerFeeEdited(_setToken, _managerFeePercentage, _managerFeeIndex);\n    }\n    /\n     * SET MANAGER ONLY. Edit the manager fee recipient\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _managerFeeRecipient          Manager fee recipient\n     /\n    function editFeeRecipient(ISetToken _setToken, address _managerFeeRecipient) external onlyManagerAndValidSet(_setToken) {\n        require(_managerFeeRecipient != address(0), "Fee recipient must not be 0 address");\n        navIssuanceSettings[_setToken].feeRecipient = _managerFeeRecipient;\n        emit FeeRecipientEdited(_setToken, _managerFeeRecipient);\n    }\n    /\n     * SET MANAGER ONLY. Initializes this module to the SetToken with hooks, allowed reserve assets,\n     * fees and issuance premium. Only callable by the SetToken\'s manager. Hook addresses are optional.\n     * Address(0) means that no hook will be called.\n     \n     * @param _setToken                     Instance of the SetToken to issue\n     * @param _navIssuanceSettings          NAVIssuanceSettings struct defining parameters\n     /\n    function initialize(\n        ISetToken _setToken,\n        NAVIssuanceSettings memory _navIssuanceSettings\n    )\n        external\n        onlySetManager(_setToken, msg.sender)\n        onlyValidAndPendingSet(_setToken)\n    {\n        require(_navIssuanceSettings.reserveAssets.length &gt; 0, "Reserve assets must be greater than 0");\n        require(_navIssuanceSettings.maxManagerFee &lt; PreciseUnitMath.preciseUnit(), "Max manager fee must be less than 100%");\n        require(_navIssuanceSettings.maxPremiumPercentage &lt; PreciseUnitMath.preciseUnit(), "Max premium percentage must be less than 100%");\n        require(_navIssuanceSettings.managerFees[0] &lt;= _navIssuanceSettings.maxManagerFee, "Manager issue fee must be less than max");\n        require(_navIssuanceSettings.managerFees[1] &lt;= _navIssuanceSettings.maxManagerFee, "Manager redeem fee must be less than max");\n        require(_navIssuanceSettings.premiumPercentage &lt;= _navIssuanceSettings.maxPremiumPercentage, "Premium must be less than max");\n        require(_navIssuanceSettings.feeRecipient != address(0), "Fee Recipient must be non-zero address.");\n        // Initial mint of Set cannot use NAVIssuance since minSetTokenSupply must be &gt; 0\n        require(_navIssuanceSettings.minSetTokenSupply &gt; 0, "Min SetToken supply must be greater than 0");\n        for (uint256 i = 0; i &lt; _navIssuanceSettings.reserveAssets.length; i++) {\n            require(!isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]], "Reserve assets must be unique");\n            isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]] = true;\n        }\n        navIssuanceSettings[_setToken] = _navIssuanceSettings;\n        _setToken.initializeModule();\n    }\n    /\n     * Removes this module from the SetToken, via call by the SetToken. Issuance settings and\n     * reserve asset states are deleted.\n     /\n    function removeModule() external override {\n        ISetToken setToken = ISetToken(msg.sender);\n        for (uint256 i = 0; i &lt; navIssuanceSettings[setToken].reserveAssets.length; i++) {\n            delete isReserveAsset[setToken][navIssuanceSettings[setToken].reserveAssets[i]];\n        }\n        delete navIssuanceSettings[setToken];\n    }\n    receive() external payable {}\n    / ============ External Getter Functions ============ /\n    function getReserveAssets(ISetToken _setToken) external view returns (address[] memory) {\n        return navIssuanceSettings[_setToken].reserveAssets;\n    }\n    function getIssuePremium(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _reserveAssetQuantity\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getIssuePremium(_setToken, _reserveAsset, _reserveAssetQuantity);\n    }\n    function getRedeemPremium(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _setTokenQuantity\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);\n    }\n    function getManagerFee(ISetToken _setToken, uint256 _managerFeeIndex) external view returns (uint256) {\n        return navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];\n    }\n    /\n     * Get the expected SetTokens minted to recipient on issuance\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _reserveAsset                 Address of the reserve asset\n     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with\n     \n     * @return  uint256                     Expected SetTokens to be minted to recipient\n     */\n    function getExpectedSetTokenIssueQuantity(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _reserveAssetQuantity\n    )\n        external\n        view\n        returns (uint256)\n    {\n        (,, uint256 netReserveFlow) = _getFees(\n            _setToken,\n            _reserveAssetQuantity,\n            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,\n            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,\n            MANAGER_ISSUE_FEE_INDEX\n        );\n        uint256 setTotalSupply = _setToken.totalSupply();\n        return _getSetTokenMintQuantity(\n            _setToken,\n            _reserveAsset,\n            netReserveFlow,\n            setTotalSupply\n        );\n    }\n    /\n     * Get the expected reserve asset to be redeemed\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _reserveAsset                 Address of the reserve asset\n     * @param _setTokenQuantity             Quantity of SetTokens to redeem\n     \n     * @return  uint256                     Expected reserve asset quantity redeemed\n     /\n    function getExpectedReserveRedeemQuantity(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _setTokenQuantity\n    )\n        external\n        view\n        returns (uint256)\n    {\n        uint256 preFeeReserveQuantity = _getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);\n        (,, uint256 netReserveFlows) = _getFees(\n            _setToken,\n            preFeeReserveQuantity,\n            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,\n            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,\n            MANAGER_REDEEM_FEE_INDEX\n        );\n        return netReserveFlows;\n    }\n    /\n     * Checks if issue is valid\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _reserveAsset                 Address of the reserve asset\n     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with\n     \n     * @return  bool                        Returns true if issue is valid\n     /\n    function isIssueValid(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _reserveAssetQuantity\n    )\n        external\n        view\n        returns (bool)\n    {\n        uint256 setTotalSupply = _setToken.totalSupply();\n    return _reserveAssetQuantity != 0\n            &amp;&amp; isReserveAsset[_setToken][_reserveAsset]\n            &amp;&amp; setTotalSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply;\n    }\n    /\n     * Checks if redeem is valid\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _reserveAsset                 Address of the reserve asset\n     * @param _setTokenQuantity             Quantity of SetTokens to redeem\n     \n     * @return  bool                        Returns true if redeem is valid\n     /\n    function isRedeemValid(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _setTokenQuantity\n    )\n        external\n        view\n        returns (bool)\n    {\n        uint256 setTotalSupply = _setToken.totalSupply();\n        if (\n            _setTokenQuantity == 0\n            || !isReserveAsset[_setToken][_reserveAsset]\n            || setTotalSupply &lt; navIssuanceSettings[_setToken].minSetTokenSupply.add(_setTokenQuantity)\n        ) {\n            return false;\n        } else {\n            uint256 totalRedeemValue =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);\n            (,, uint256 expectedRedeemQuantity) = _getFees(\n                _setToken,\n                totalRedeemValue,\n                PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,\n                PROTOCOL_REDEEM_DIRECT_FEE_INDEX,\n                MANAGER_REDEEM_FEE_INDEX\n            );\n            uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();\n            return existingUnit.preciseMul(setTotalSupply) &gt;= expectedRedeemQuantity;\n        }\n    }\n    / ============ Internal Functions ============ */\n    function _validateCommon(ISetToken _setToken, address _reserveAsset, uint256 _quantity) internal view {\n        require(_quantity &gt; 0, "Quantity must be &gt; 0");\n        require(isReserveAsset[_setToken][_reserveAsset], "Must be valid reserve asset");\n    }\n    function _validateIssuanceInfo(ISetToken _setToken, uint256 _minSetTokenReceiveQuantity, ActionInfo memory _issueInfo) internal view {\n        // Check that total supply is greater than min supply needed for issuance\n        // Note: A min supply amount is needed to avoid division by 0 when SetToken supply is 0\n        require(\n            _issueInfo.previousSetTokenSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply,\n            "Supply must be greater than minimum to enable issuance"\n        );\n        require(_issueInfo.setTokenQuantity &gt;= _minSetTokenReceiveQuantity, "Must be greater than min SetToken");\n    }\n    function _validateRedemptionInfo(\n        ISetToken _setToken,\n        uint256 _minReserveReceiveQuantity,\n        ActionInfo memory _redeemInfo\n    )\n        internal\n        view\n    {\n        // Check that new supply is more than min supply needed for redemption\n        // Note: A min supply amount is needed to avoid division by 0 when redeeming SetToken to 0\n        require(\n            _redeemInfo.newSetTokenSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply,\n            "Supply must be greater than minimum to enable redemption"\n        );\n        require(_redeemInfo.netFlowQuantity &gt;= _minReserveReceiveQuantity, "Must be greater than min receive reserve quantity");\n    }\n    function _createIssuanceInfo(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _reserveAssetQuantity\n    )\n        internal\n        view\n        returns (ActionInfo memory)\n    {\n        ActionInfo memory issueInfo;\n        issueInfo.previousSetTokenSupply = _setToken.totalSupply();\n        issueInfo.preFeeReserveQuantity = _reserveAssetQuantity;\n        (issueInfo.protocolFees, issueInfo.managerFee, issueInfo.netFlowQuantity) = _getFees(\n            _setToken,\n            issueInfo.preFeeReserveQuantity,\n            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,\n            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,\n            MANAGER_ISSUE_FEE_INDEX\n        );\n        issueInfo.setTokenQuantity = _getSetTokenMintQuantity(\n            _setToken,\n            _reserveAsset,\n            issueInfo.netFlowQuantity,\n            issueInfo.previousSetTokenSupply\n        );\n        (issueInfo.newSetTokenSupply, issueInfo.newPositionMultiplier) = _getIssuePositionMultiplier(_setToken, issueInfo);\n        issueInfo.newReservePositionUnit = _getIssuePositionUnit(_setToken, _reserveAsset, issueInfo);\n        return issueInfo;\n    }\n    function _createRedemptionInfo(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _setTokenQuantity\n    )\n        internal\n        view\n        returns (ActionInfo memory)\n    {\n        ActionInfo memory redeemInfo;\n        redeemInfo.setTokenQuantity = _setTokenQuantity;\n        redeemInfo.preFeeReserveQuantity =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);\n        (redeemInfo.protocolFees, redeemInfo.managerFee, redeemInfo.netFlowQuantity) = _getFees(\n            _setToken,\n            redeemInfo.preFeeReserveQuantity,\n            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,\n            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,\n            MANAGER_REDEEM_FEE_INDEX\n        );\n        redeemInfo.previousSetTokenSupply = _setToken.totalSupply();\n        (redeemInfo.newSetTokenSupply, redeemInfo.newPositionMultiplier) = _getRedeemPositionMultiplier(_setToken, _setTokenQuantity, redeemInfo);\n        redeemInfo.newReservePositionUnit = _getRedeemPositionUnit(_setToken, _reserveAsset, redeemInfo);\n        return redeemInfo;\n    }\n    /\n     * Transfer reserve asset from user to SetToken and fees from user to appropriate fee recipients\n     /\n    function _transferCollateralAndHandleFees(ISetToken _setToken, IERC20 _reserveAsset, ActionInfo memory _issueInfo) internal {\n        transferFrom(_reserveAsset, msg.sender, address(_setToken), _issueInfo.netFlowQuantity);\n        if (_issueInfo.protocolFees &gt; 0) {\n            transferFrom(_reserveAsset, msg.sender, controller.feeRecipient(), _issueInfo.protocolFees);\n        }\n        if (_issueInfo.managerFee &gt; 0) {\n            transferFrom(_reserveAsset, msg.sender, navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);\n        }\n    }\n\n    /\n      * Transfer WETH from module to SetToken and fees from module to appropriate fee recipients\n     /\n    function _transferWETHAndHandleFees(ISetToken _setToken, ActionInfo memory _issueInfo) internal {\n        weth.transfer(address(_setToken), _issueInfo.netFlowQuantity);\n        if (_issueInfo.protocolFees &gt; 0) {\n            weth.transfer(controller.feeRecipient(), _issueInfo.protocolFees);\n        }\n        if (_issueInfo.managerFee &gt; 0) {\n            weth.transfer(navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);\n        }\n    }\n    function _handleIssueStateUpdates(\n        ISetToken _setToken,\n        address _reserveAsset,\n        address _to,\n        ActionInfo memory _issueInfo\n    )\n        internal\n    {\n        _setToken.editPositionMultiplier(_issueInfo.newPositionMultiplier);\n        _setToken.editDefaultPosition(_reserveAsset, _issueInfo.newReservePositionUnit);\n        _setToken.mint(_to, _issueInfo.setTokenQuantity);\n        emit SetTokenNAVIssued(\n            _setToken,\n            msg.sender,\n            _to,\n            _reserveAsset,\n            address(navIssuanceSettings[_setToken].managerIssuanceHook),\n            _issueInfo.setTokenQuantity,\n            _issueInfo.managerFee,\n            _issueInfo.protocolFees\n        );\n    }\n    function _handleRedeemStateUpdates(\n        ISetToken _setToken,\n        address _reserveAsset,\n        address _to,\n        ActionInfo memory _redeemInfo\n    )\n        internal\n    {\n        _setToken.editPositionMultiplier(_redeemInfo.newPositionMultiplier);\n        _setToken.editDefaultPosition(_reserveAsset, _redeemInfo.newReservePositionUnit);\n        emit SetTokenNAVRedeemed(\n            _setToken,\n            msg.sender,\n            _to,\n            _reserveAsset,\n            address(navIssuanceSettings[_setToken].managerRedemptionHook),\n            _redeemInfo.setTokenQuantity,\n            _redeemInfo.managerFee,\n            _redeemInfo.protocolFees\n        );\n    }\n    function _handleRedemptionFees(ISetToken _setToken, address _reserveAsset, ActionInfo memory _redeemInfo) internal {\n        // Instruct the SetToken to transfer protocol fee to fee recipient if there is a fee\n        payProtocolFeeFromSetToken(_setToken, _reserveAsset, _redeemInfo.protocolFees);\n        // Instruct the SetToken to transfer manager fee to manager fee recipient if there is a fee\n        if (_redeemInfo.managerFee &gt; 0) {\n            _setToken.strictInvokeTransfer(\n                _reserveAsset,\n                navIssuanceSettings[_setToken].feeRecipient,\n                _redeemInfo.managerFee\n            );\n        }\n    }\n    /\n     * Returns the issue premium percentage. Virtual function that can be overridden in future versions of the module\n     * and can contain arbitrary logic to calculate the issuance premium.\n     /\n    function _getIssuePremium(\n        ISetToken _setToken,\n        address / _reserveAsset /,\n        uint256 / _reserveAssetQuantity */\n    )\n        virtual\n        internal\n        view\n        returns (uint256)\n    {\n        return navIssuanceSettings[_setToken].premiumPercentage;\n    }\n    /\n     * Returns the redeem premium percentage. Virtual function that can be overridden in future versions of the module\n     * and can contain arbitrary logic to calculate the redemption premium.\n     /\n    function _getRedeemPremium(\n        ISetToken _setToken,\n        address / _reserveAsset /,\n        uint256 / _setTokenQuantity /\n    )\n        virtual\n        internal\n        view\n        returns (uint256)\n    {\n        return navIssuanceSettings[_setToken].premiumPercentage;\n    }\n    /\n     * Returns the fees attributed to the manager and the protocol. The fees are calculated as follows:\n     \n     * ManagerFee = (manager fee % - % to protocol) * reserveAssetQuantity\n     * Protocol Fee = (% manager fee share + direct fee %) * reserveAssetQuantity\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _reserveAssetQuantity         Quantity of reserve asset to calculate fees from\n     * @param _protocolManagerFeeIndex      Index to pull rev share NAV Issuance fee from the Controller\n     * @param _protocolDirectFeeIndex       Index to pull direct NAV issuance fee from the Controller\n     * @param _managerFeeIndex              Index from NAVIssuanceSettings (0 = issue fee, 1 = redeem fee)\n     \n     * @return  uint256                     Fees paid to the protocol in reserve asset\n     * @return  uint256                     Fees paid to the manager in reserve asset\n     * @return  uint256                     Net reserve to user net of fees\n     /\n    function _getFees(\n        ISetToken _setToken,\n        uint256 _reserveAssetQuantity,\n        uint256 _protocolManagerFeeIndex,\n        uint256 _protocolDirectFeeIndex,\n        uint256 _managerFeeIndex\n    )\n        internal\n        view\n        returns (uint256, uint256, uint256)\n    {\n        (uint256 protocolFeePercentage, uint256 managerFeePercentage) = _getProtocolAndManagerFeePercentages(\n            _setToken,\n            _protocolManagerFeeIndex,\n            _protocolDirectFeeIndex,\n            _managerFeeIndex\n        );\n        // Calculate total notional fees\n        uint256 protocolFees = protocolFeePercentage.preciseMul(_reserveAssetQuantity);\n        uint256 managerFee = managerFeePercentage.preciseMul(_reserveAssetQuantity);\n        uint256 netReserveFlow = _reserveAssetQuantity.sub(protocolFees).sub(managerFee);\n        return (protocolFees, managerFee, netReserveFlow);\n    }\n    function _getProtocolAndManagerFeePercentages(\n        ISetToken _setToken,\n        uint256 _protocolManagerFeeIndex,\n        uint256 _protocolDirectFeeIndex,\n        uint256 _managerFeeIndex\n    )\n        internal\n        view\n        returns(uint256, uint256)\n    {\n        // Get protocol fee percentages\n        uint256 protocolDirectFeePercent = controller.getModuleFee(address(this), _protocolDirectFeeIndex);\n        uint256 protocolManagerShareFeePercent = controller.getModuleFee(address(this), _protocolManagerFeeIndex);\n        uint256 managerFeePercent = navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];\n        // Calculate revenue share split percentage\n        uint256 protocolRevenueSharePercentage = protocolManagerShareFeePercent.preciseMul(managerFeePercent);\n        uint256 managerRevenueSharePercentage = managerFeePercent.sub(protocolRevenueSharePercentage);\n        uint256 totalProtocolFeePercentage = protocolRevenueSharePercentage.add(protocolDirectFeePercent);\n        return (totalProtocolFeePercentage, managerRevenueSharePercentage);\n    }\n    function _getSetTokenMintQuantity(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _netReserveFlows,            // Value of reserve asset net of fees\n        uint256 _setTotalSupply\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 premiumPercentage = _getIssuePremium(_setToken, _reserveAsset, _netReserveFlows);\n        uint256 premiumValue = _netReserveFlows.preciseMul(premiumPercentage);\n        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (1e18)\n        // Reverts if price is not found\n        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);\n        // Get reserve asset decimals\n        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();\n        uint256 normalizedTotalReserveQuantityNetFees = _netReserveFlows.preciseDiv(10 ** reserveAssetDecimals);\n        uint256 normalizedTotalReserveQuantityNetFeesAndPremium = _netReserveFlows.sub(premiumValue).preciseDiv(10 ** reserveAssetDecimals);\n        // Calculate SetTokens to mint to issuer\n        uint256 denominator = _setTotalSupply.preciseMul(setTokenValuation).add(normalizedTotalReserveQuantityNetFees).sub(normalizedTotalReserveQuantityNetFeesAndPremium);\n        return normalizedTotalReserveQuantityNetFeesAndPremium.preciseMul(_setTotalSupply).preciseDiv(denominator);\n    }\n    function _getRedeemReserveQuantity(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _setTokenQuantity\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (10e18)\n        // Reverts if price is not found\n        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);\n        uint256 totalRedeemValueInPreciseUnits = _setTokenQuantity.preciseMul(setTokenValuation);\n        // Get reserve asset decimals\n        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();\n        uint256 prePremiumReserveQuantity = totalRedeemValueInPreciseUnits.preciseMul(10 ** reserveAssetDecimals);\n        uint256 premiumPercentage = _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);\n        uint256 premiumQuantity = prePremiumReserveQuantity.preciseMulCeil(premiumPercentage);\n        return prePremiumReserveQuantity.sub(premiumQuantity);\n    }\n    /\n     * The new position multiplier is calculated as follows:\n     * inflationPercentage = (newSupply - oldSupply) / newSupply\n     * newMultiplier = (1 - inflationPercentage) * positionMultiplier\n     /\n    function _getIssuePositionMultiplier(\n        ISetToken _setToken,\n        ActionInfo memory _issueInfo\n    )\n        internal\n        view\n        returns (uint256, int256)\n    {\n        // Calculate inflation and new position multiplier. Note: Round inflation up in order to round position multiplier down\n        uint256 newTotalSupply = _issueInfo.setTokenQuantity.add(_issueInfo.previousSetTokenSupply);\n        int256 newPositionMultiplier = _setToken.positionMultiplier()\n            .mul(_issueInfo.previousSetTokenSupply.toInt256())\n            .div(newTotalSupply.toInt256());\n        return (newTotalSupply, newPositionMultiplier);\n    }\n    /\n     * Calculate deflation and new position multiplier. Note: Round deflation down in order to round position multiplier down\n     \n     * The new position multiplier is calculated as follows:\n     * deflationPercentage = (oldSupply - newSupply) / newSupply\n     * newMultiplier = (1 + deflationPercentage) * positionMultiplier\n     /\n    function _getRedeemPositionMultiplier(\n        ISetToken _setToken,\n        uint256 _setTokenQuantity,\n        ActionInfo memory _redeemInfo\n    )\n        internal\n        view\n        returns (uint256, int256)\n    {\n        uint256 newTotalSupply = _redeemInfo.previousSetTokenSupply.sub(_setTokenQuantity);\n        int256 newPositionMultiplier = _setToken.positionMultiplier()\n            .mul(_redeemInfo.previousSetTokenSupply.toInt256())\n            .div(newTotalSupply.toInt256());\n        return (newTotalSupply, newPositionMultiplier);\n    }\n    /\n     * The new position reserve asset unit is calculated as follows:\n     * totalReserve = (oldUnit * oldSetTokenSupply) + reserveQuantity\n     * newUnit = totalReserve / newSetTokenSupply\n     /\n    function _getIssuePositionUnit(\n        ISetToken _setToken,\n        address _reserveAsset,\n        ActionInfo memory _issueInfo\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();\n        uint256 totalReserve = existingUnit\n            .preciseMul(_issueInfo.previousSetTokenSupply)\n            .add(_issueInfo.netFlowQuantity);\n        return totalReserve.preciseDiv(_issueInfo.newSetTokenSupply);\n    }\n    /\n     * The new position reserve asset unit is calculated as follows:\n     * totalReserve = (oldUnit * oldSetTokenSupply) - reserveQuantityToSendOut\n     * newUnit = totalReserve / newSetTokenSupply\n     /\n    function _getRedeemPositionUnit(\n        ISetToken _setToken,\n        address _reserveAsset,\n        ActionInfo memory _redeemInfo\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();\n        uint256 totalExistingUnits = existingUnit.preciseMul(_redeemInfo.previousSetTokenSupply);\n        uint256 outflow = _redeemInfo.netFlowQuantity.add(_redeemInfo.protocolFees).add(_redeemInfo.managerFee);\n        // Require withdrawable quantity is greater than existing collateral\n        require(totalExistingUnits &gt;= outflow, "Must be greater than total available collateral");\n        return totalExistingUnits.sub(outflow).preciseDiv(_redeemInfo.newSetTokenSupply);\n    }\n    /\n     * If a pre-issue hook has been configured, call the external-protocol contract. Pre-issue hook logic\n     * can contain arbitrary logic including validations, external function calls, etc.\n     */\n    function _callPreIssueHooks(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _reserveAssetQuantity,\n        address _caller,\n        address _to\n    )\n        internal\n    {\n        INAVIssuanceHook preIssueHook = navIssuanceSettings[_setToken].managerIssuanceHook;\n        if (address(preIssueHook) != address(0)) {\n            preIssueHook.invokePreIssueHook(_setToken, _reserveAsset, _reserveAssetQuantity, _caller, _to);\n        }\n    }\n    /\n     * If a pre-redeem hook has been configured, call the external-protocol contract.\n     /\n    function _callPreRedeemHooks(ISetToken _setToken, uint256 _setQuantity, address _caller, address _to) internal {\n        INAVIssuanceHook preRedeemHook = navIssuanceSettings[_setToken].managerRedemptionHook;\n        if (address(preRedeemHook) != address(0)) {\n            preRedeemHook.invokePreRedeemHook(_setToken, _setQuantity, _caller, _to);\n        }\n    }\n}.\n\nChief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.\nHere\'s a Solidity contract provided by the user: "/\n    Copyright 2020 Set Labs Inc.\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n    SPDX-License-Identifier: Apache License, Version 2.0\n/\npragma solidity 0.6.10;\npragma experimental "ABIEncoderV2";\nimport { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";\nimport { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";\nimport { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";\nimport { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";\nimport { SignedSafeMath } from "@openzeppelin/contracts/math/SignedSafeMath.sol";\nimport { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";\nimport { IController } from "../../interfaces/IController.sol";\nimport { INAVIssuanceHook } from "../../interfaces/INAVIssuanceHook.sol";\nimport { Invoke } from "../lib/Invoke.sol";\nimport { ISetToken } from "../../interfaces/ISetToken.sol";\nimport { IWETH } from "../../interfaces/external/IWETH.sol";\nimport { ModuleBase } from "../lib/ModuleBase.sol";\nimport { Position } from "../lib/Position.sol";\nimport { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";\nimport { ResourceIdentifier } from "../lib/ResourceIdentifier.sol";\n\n/\n * @title NavIssuanceModule\n * @author Set Protocol\n \n * Module that enables issuance and redemption with any valid ERC20 token or ETH if allowed by the manager. Sender receives\n * a proportional amount of SetTokens on issuance or ERC20 token on redemption based on the calculated net asset value using\n * oracle prices. Manager is able to enforce a premium / discount on issuance / redemption to avoid arbitrage and front\n * running when relying on oracle prices. Managers can charge a fee (denominated in reserve asset).\n /\ncontract NavIssuanceModule is ModuleBase, ReentrancyGuard {\n    using AddressArrayUtils for address[];\n    using Invoke for ISetToken;\n    using Position for ISetToken;\n    using PreciseUnitMath for uint256;\n    using PreciseUnitMath for int256;\n    using ResourceIdentifier for IController;\n    using SafeMath for uint256;\n    using SafeCast for int256;\n    using SafeCast for uint256;\n    using SignedSafeMath for int256;\n    / ============ Events ============ /\n    event SetTokenNAVIssued(\n        ISetToken indexed _setToken,\n        address _issuer,\n        address _to,\n        address _reserveAsset,\n        address _hookContract,\n        uint256 _setTokenQuantity,\n        uint256 _managerFee,\n        uint256 _premium\n    );\n    event SetTokenNAVRedeemed(\n        ISetToken indexed _setToken,\n        address _redeemer,\n        address _to,\n        address _reserveAsset,\n        address _hookContract,\n        uint256 _setTokenQuantity,\n        uint256 _managerFee,\n        uint256 _premium\n    );\n    event ReserveAssetAdded(\n        ISetToken indexed _setToken,\n        address _newReserveAsset\n    );\n    event ReserveAssetRemoved(\n        ISetToken indexed _setToken,\n        address _removedReserveAsset\n    );\n    event PremiumEdited(\n        ISetToken indexed _setToken,\n        uint256 _newPremium\n    );\n    event ManagerFeeEdited(\n        ISetToken indexed _setToken,\n        uint256 _newManagerFee,\n        uint256 _index\n    );\n    event FeeRecipientEdited(\n        ISetToken indexed _setToken,\n        address _feeRecipient\n    );\n    / ============ Structs ============ /\n    struct NAVIssuanceSettings {\n        INAVIssuanceHook managerIssuanceHook;      // Issuance hook configurations\n        INAVIssuanceHook managerRedemptionHook;    // Redemption hook configurations\n        address[] reserveAssets;                       // Allowed reserve assets - Must have a price enabled with the price oracle\n        address feeRecipient;                          // Manager fee recipient\n        uint256[2] managerFees;                        // Manager fees. 0 index is issue and 1 index is redeem fee (0.01% = 1e14, 1% = 1e16)\n        uint256 maxManagerFee;                         // Maximum fee manager is allowed to set for issue and redeem\n        uint256 premiumPercentage;                     // Premium percentage (0.01% = 1e14, 1% = 1e16). This premium is a buffer around oracle\n                                                       // prices paid by user to the SetToken, which prevents arbitrage and oracle front running\n        uint256 maxPremiumPercentage;                  // Maximum premium percentage manager is allowed to set (configured by manager)\n        uint256 minSetTokenSupply;                     // Minimum SetToken supply required for issuance and redemption\n                                                       // to prevent dramatic inflationary changes to the SetToken\'s position multiplier\n    }\n    struct ActionInfo {\n        uint256 preFeeReserveQuantity;                 // Reserve value before fees; During issuance, represents raw quantity\n                                                       // During redeem, represents post-premium value\n        uint256 protocolFees;                          // Total protocol fees (direct + manager revenue share)\n        uint256 managerFee;                            // Total manager fee paid in reserve asset\n        uint256 netFlowQuantity;                       // When issuing, quantity of reserve asset sent to SetToken\n                                                       // When redeeming, quantity of reserve asset sent to redeemer\n        uint256 setTokenQuantity;                      // When issuing, quantity of SetTokens minted to mintee\n                                                       // When redeeming, quantity of SetToken redeemed\n        uint256 previousSetTokenSupply;                // SetToken supply prior to issue/redeem action\n        uint256 newSetTokenSupply;                     // SetToken supply after issue/redeem action\n        int256 newPositionMultiplier;                  // SetToken position multiplier after issue/redeem\n        uint256 newReservePositionUnit;                // SetToken reserve asset position unit after issue/redeem\n    }\n    / ============ State Variables ============ /\n    // Wrapped ETH address\n    IWETH public immutable weth;\n    // Mapping of SetToken to NAV issuance settings struct\n    mapping(ISetToken =&gt; NAVIssuanceSettings) public navIssuanceSettings;\n    // Mapping to efficiently check a SetToken\'s reserve asset validity\n    // SetToken =&gt; reserveAsset =&gt; isReserveAsset\n    mapping(ISetToken =&gt; mapping(address =&gt; bool)) public isReserveAsset;\n    / ============ Constants ============ /\n    // 0 index stores the manager fee in managerFees array, percentage charged on issue (denominated in reserve asset)\n    uint256 constant internal MANAGER_ISSUE_FEE_INDEX = 0;\n    // 1 index stores the manager fee percentage in managerFees array, charged on redeem\n    uint256 constant internal MANAGER_REDEEM_FEE_INDEX = 1;\n    // 0 index stores the manager revenue share protocol fee % on the controller, charged in the issuance function\n    uint256 constant internal PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX = 0;\n    // 1 index stores the manager revenue share protocol fee % on the controller, charged in the redeem function\n    uint256 constant internal PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX = 1;\n    // 2 index stores the direct protocol fee % on the controller, charged in the issuance function\n    uint256 constant internal PROTOCOL_ISSUE_DIRECT_FEE_INDEX = 2;\n    // 3 index stores the direct protocol fee % on the controller, charged in the redeem function\n    uint256 constant internal PROTOCOL_REDEEM_DIRECT_FEE_INDEX = 3;\n    / ============ Constructor ============ /\n    /\n     * @param _controller               Address of controller contract\n     * @param _weth                     Address of wrapped eth\n     /\n    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {\n        weth = _weth;\n    }\n    / ============ External Functions ============ /\n    /\n     * Deposits the allowed reserve asset into the SetToken and mints the appropriate % of Net Asset Value of the SetToken\n     * to the specified _to address.\n     \n     * @param _setToken                     Instance of the SetToken contract\n     * @param _reserveAsset                 Address of the reserve asset to issue with\n     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with\n     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance\n     * @param _to                           Address to mint SetToken to\n     /\n    function issue(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _reserveAssetQuantity,\n        uint256 _minSetTokenReceiveQuantity,\n        address _to\n    )\n        external\n        nonReentrant\n        onlyValidAndInitializedSet(_setToken)\n    {\n        _validateCommon(_setToken, _reserveAsset, _reserveAssetQuantity);\n        _callPreIssueHooks(_setToken, _reserveAsset, _reserveAssetQuantity, msg.sender, _to);\n        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, _reserveAsset, _reserveAssetQuantity);\n        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);\n        _transferCollateralAndHandleFees(_setToken, IERC20(_reserveAsset), issueInfo);\n        _handleIssueStateUpdates(_setToken, _reserveAsset, _to, issueInfo);\n    }\n    /\n     * Wraps ETH and deposits WETH if allowed into the SetToken and mints the appropriate % of Net Asset Value of the SetToken\n     * to the specified _to address.\n     \n     * @param _setToken                     Instance of the SetToken contract\n     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance\n     * @param _to                           Address to mint SetToken to\n     /\n    function issueWithEther(\n        ISetToken _setToken,\n        uint256 _minSetTokenReceiveQuantity,\n        address _to\n    )\n        external\n        payable\n        nonReentrant\n        onlyValidAndInitializedSet(_setToken)\n    {\n        weth.deposit{ value: msg.value }();\n        _validateCommon(_setToken, address(weth), msg.value);\n        _callPreIssueHooks(_setToken, address(weth), msg.value, msg.sender, _to);\n        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, address(weth), msg.value);\n        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);\n        _transferWETHAndHandleFees(_setToken, issueInfo);\n        _handleIssueStateUpdates(_setToken, address(weth), _to, issueInfo);\n    }\n    /\n     * Redeems a SetToken into a valid reserve asset representing the appropriate % of Net Asset Value of the SetToken\n     * to the specified _to address. Only valid if there are available reserve units on the SetToken.\n     \n     * @param _setToken                     Instance of the SetToken contract\n     * @param _reserveAsset                 Address of the reserve asset to redeem with\n     * @param _setTokenQuantity             Quantity of SetTokens to redeem\n     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive\n     * @param _to                           Address to redeem reserve asset to\n     /\n    function redeem(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _setTokenQuantity,\n        uint256 _minReserveReceiveQuantity,\n        address _to\n    )\n        external\n        nonReentrant\n        onlyValidAndInitializedSet(_setToken)\n    {\n        _validateCommon(_setToken, _reserveAsset, _setTokenQuantity);\n        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);\n        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, _reserveAsset, _setTokenQuantity);\n        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);\n        _setToken.burn(msg.sender, _setTokenQuantity);\n        // Instruct the SetToken to transfer the reserve asset back to the user\n        _setToken.strictInvokeTransfer(\n            _reserveAsset,\n            _to,\n            redeemInfo.netFlowQuantity\n        );\n        _handleRedemptionFees(_setToken, _reserveAsset, redeemInfo);\n        _handleRedeemStateUpdates(_setToken, _reserveAsset, _to, redeemInfo);\n    }\n    /\n     * Redeems a SetToken into Ether (if WETH is valid) representing the appropriate % of Net Asset Value of the SetToken\n     * to the specified _to address. Only valid if there are available WETH units on the SetToken.\n     \n     * @param _setToken                     Instance of the SetToken contract\n     * @param _setTokenQuantity             Quantity of SetTokens to redeem\n     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive\n     * @param _to                           Address to redeem reserve asset to\n     /\n    function redeemIntoEther(\n        ISetToken _setToken,\n        uint256 _setTokenQuantity,\n        uint256 _minReserveReceiveQuantity,\n        address payable _to\n    )\n        external\n        nonReentrant\n        onlyValidAndInitializedSet(_setToken)\n    {\n        _validateCommon(_setToken, address(weth), _setTokenQuantity);\n        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);\n        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, address(weth), _setTokenQuantity);\n        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);\n        _setToken.burn(msg.sender, _setTokenQuantity);\n        // Instruct the SetToken to transfer WETH from SetToken to module\n        _setToken.strictInvokeTransfer(\n            address(weth),\n            address(this),\n            redeemInfo.netFlowQuantity\n        );\n        weth.withdraw(redeemInfo.netFlowQuantity);\n        _to.transfer(redeemInfo.netFlowQuantity);\n        _handleRedemptionFees(_setToken, address(weth), redeemInfo);\n        _handleRedeemStateUpdates(_setToken, address(weth), _to, redeemInfo);\n    }\n    /\n     * SET MANAGER ONLY. Add an allowed reserve asset\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _reserveAsset                 Address of the reserve asset to add\n     /\n    function addReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {\n        require(!isReserveAsset[_setToken][_reserveAsset], "Reserve asset already exists");\n        navIssuanceSettings[_setToken].reserveAssets.push(_reserveAsset);\n        isReserveAsset[_setToken][_reserveAsset] = true;\n        emit ReserveAssetAdded(_setToken, _reserveAsset);\n    }\n    /\n     * SET MANAGER ONLY. Remove a reserve asset\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _reserveAsset                 Address of the reserve asset to remove\n     /\n    function removeReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {\n        require(isReserveAsset[_setToken][_reserveAsset], "Reserve asset does not exist");\n        navIssuanceSettings[_setToken].reserveAssets = navIssuanceSettings[_setToken].reserveAssets.remove(_reserveAsset);\n        delete isReserveAsset[_setToken][_reserveAsset];\n        emit ReserveAssetRemoved(_setToken, _reserveAsset);\n    }\n    /\n     * SET MANAGER ONLY. Edit the premium percentage\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _premiumPercentage            Premium percentage in 10e16 (e.g. 10e16 = 1%)\n     /\n    function editPremium(ISetToken _setToken, uint256 _premiumPercentage) external onlyManagerAndValidSet(_setToken) {\n        require(_premiumPercentage &lt;= navIssuanceSettings[_setToken].maxPremiumPercentage, "Premium must be less than maximum allowed");\n        navIssuanceSettings[_setToken].premiumPercentage = _premiumPercentage;\n        emit PremiumEdited(_setToken, _premiumPercentage);\n    }\n    /\n     * SET MANAGER ONLY. Edit manager fee\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _managerFeePercentage         Manager fee percentage in 10e16 (e.g. 10e16 = 1%)\n     * @param _managerFeeIndex              Manager fee index. 0 index is issue fee, 1 index is redeem fee\n     /\n    function editManagerFee(\n        ISetToken _setToken,\n        uint256 _managerFeePercentage,\n        uint256 _managerFeeIndex\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        require(_managerFeePercentage &lt;= navIssuanceSettings[_setToken].maxManagerFee, "Manager fee must be less than maximum allowed");\n        navIssuanceSettings[_setToken].managerFees[_managerFeeIndex] = _managerFeePercentage;\n        emit ManagerFeeEdited(_setToken, _managerFeePercentage, _managerFeeIndex);\n    }\n    /\n     * SET MANAGER ONLY. Edit the manager fee recipient\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _managerFeeRecipient          Manager fee recipient\n     /\n    function editFeeRecipient(ISetToken _setToken, address _managerFeeRecipient) external onlyManagerAndValidSet(_setToken) {\n        require(_managerFeeRecipient != address(0), "Fee recipient must not be 0 address");\n        navIssuanceSettings[_setToken].feeRecipient = _managerFeeRecipient;\n        emit FeeRecipientEdited(_setToken, _managerFeeRecipient);\n    }\n    /\n     * SET MANAGER ONLY. Initializes this module to the SetToken with hooks, allowed reserve assets,\n     * fees and issuance premium. Only callable by the SetToken\'s manager. Hook addresses are optional.\n     * Address(0) means that no hook will be called.\n     \n     * @param _setToken                     Instance of the SetToken to issue\n     * @param _navIssuanceSettings          NAVIssuanceSettings struct defining parameters\n     /\n    function initialize(\n        ISetToken _setToken,\n        NAVIssuanceSettings memory _navIssuanceSettings\n    )\n        external\n        onlySetManager(_setToken, msg.sender)\n        onlyValidAndPendingSet(_setToken)\n    {\n        require(_navIssuanceSettings.reserveAssets.length &gt; 0, "Reserve assets must be greater than 0");\n        require(_navIssuanceSettings.maxManagerFee &lt; PreciseUnitMath.preciseUnit(), "Max manager fee must be less than 100%");\n        require(_navIssuanceSettings.maxPremiumPercentage &lt; PreciseUnitMath.preciseUnit(), "Max premium percentage must be less than 100%");\n        require(_navIssuanceSettings.managerFees[0] &lt;= _navIssuanceSettings.maxManagerFee, "Manager issue fee must be less than max");\n        require(_navIssuanceSettings.managerFees[1] &lt;= _navIssuanceSettings.maxManagerFee, "Manager redeem fee must be less than max");\n        require(_navIssuanceSettings.premiumPercentage &lt;= _navIssuanceSettings.maxPremiumPercentage, "Premium must be less than max");\n        require(_navIssuanceSettings.feeRecipient != address(0), "Fee Recipient must be non-zero address.");\n        // Initial mint of Set cannot use NAVIssuance since minSetTokenSupply must be &gt; 0\n        require(_navIssuanceSettings.minSetTokenSupply &gt; 0, "Min SetToken supply must be greater than 0");\n        for (uint256 i = 0; i &lt; _navIssuanceSettings.reserveAssets.length; i++) {\n            require(!isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]], "Reserve assets must be unique");\n            isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]] = true;\n        }\n        navIssuanceSettings[_setToken] = _navIssuanceSettings;\n        _setToken.initializeModule();\n    }\n    /\n     * Removes this module from the SetToken, via call by the SetToken. Issuance settings and\n     * reserve asset states are deleted.\n     /\n    function removeModule() external override {\n        ISetToken setToken = ISetToken(msg.sender);\n        for (uint256 i = 0; i &lt; navIssuanceSettings[setToken].reserveAssets.length; i++) {\n            delete isReserveAsset[setToken][navIssuanceSettings[setToken].reserveAssets[i]];\n        }\n        delete navIssuanceSettings[setToken];\n    }\n    receive() external payable {}\n    / ============ External Getter Functions ============ */\n    function getReserveAssets(ISetToken _setToken) external view returns (address[] memory) {\n        return navIssuanceSettings[_setToken].reserveAssets;\n    }\n    function getIssuePremium(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _reserveAssetQuantity\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getIssuePremium(_setToken, _reserveAsset, _reserveAssetQuantity);\n    }\n    function getRedeemPremium(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _setTokenQuantity\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);\n    }\n    function getManagerFee(ISetToken _setToken, uint256 _managerFeeIndex) external view returns (uint256) {\n        return navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];\n    }\n    /\n     * Get the expected SetTokens minted to recipient on issuance\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _reserveAsset                 Address of the reserve asset\n     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with\n     \n     * @return  uint256                     Expected SetTokens to be minted to recipient\n     /\n    function getExpectedSetTokenIssueQuantity(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _reserveAssetQuantity\n    )\n        external\n        view\n        returns (uint256)\n    {\n        (,, uint256 netReserveFlow) = _getFees(\n            _setToken,\n            _reserveAssetQuantity,\n            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,\n            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,\n            MANAGER_ISSUE_FEE_INDEX\n        );\n        uint256 setTotalSupply = _setToken.totalSupply();\n        return _getSetTokenMintQuantity(\n            _setToken,\n            _reserveAsset,\n            netReserveFlow,\n            setTotalSupply\n        );\n    }\n    /\n     * Get the expected reserve asset to be redeemed\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _reserveAsset                 Address of the reserve asset\n     * @param _setTokenQuantity             Quantity of SetTokens to redeem\n     \n     * @return  uint256                     Expected reserve asset quantity redeemed\n     /\n    function getExpectedReserveRedeemQuantity(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _setTokenQuantity\n    )\n        external\n        view\n        returns (uint256)\n    {\n        uint256 preFeeReserveQuantity = _getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);\n        (,, uint256 netReserveFlows) = _getFees(\n            _setToken,\n            preFeeReserveQuantity,\n            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,\n            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,\n            MANAGER_REDEEM_FEE_INDEX\n        );\n        return netReserveFlows;\n    }\n    /\n     * Checks if issue is valid\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _reserveAsset                 Address of the reserve asset\n     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with\n     \n     * @return  bool                        Returns true if issue is valid\n     */\n    function isIssueValid(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _reserveAssetQuantity\n    )\n        external\n        view\n        returns (bool)\n    {\n        uint256 setTotalSupply = _setToken.totalSupply();\n    return _reserveAssetQuantity != 0\n            &amp;&amp; isReserveAsset[_setToken][_reserveAsset]\n            &amp;&amp; setTotalSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply;\n    }\n    /\n     * Checks if redeem is valid\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _reserveAsset                 Address of the reserve asset\n     * @param _setTokenQuantity             Quantity of SetTokens to redeem\n     \n     * @return  bool                        Returns true if redeem is valid\n     /\n    function isRedeemValid(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _setTokenQuantity\n    )\n        external\n        view\n        returns (bool)\n    {\n        uint256 setTotalSupply = _setToken.totalSupply();\n        if (\n            _setTokenQuantity == 0\n            || !isReserveAsset[_setToken][_reserveAsset]\n            || setTotalSupply &lt; navIssuanceSettings[_setToken].minSetTokenSupply.add(_setTokenQuantity)\n        ) {\n            return false;\n        } else {\n            uint256 totalRedeemValue =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);\n            (,, uint256 expectedRedeemQuantity) = _getFees(\n                _setToken,\n                totalRedeemValue,\n                PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,\n                PROTOCOL_REDEEM_DIRECT_FEE_INDEX,\n                MANAGER_REDEEM_FEE_INDEX\n            );\n            uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();\n            return existingUnit.preciseMul(setTotalSupply) &gt;= expectedRedeemQuantity;\n        }\n    }\n    / ============ Internal Functions ============ /\n    function _validateCommon(ISetToken _setToken, address _reserveAsset, uint256 _quantity) internal view {\n        require(_quantity &gt; 0, "Quantity must be &gt; 0");\n        require(isReserveAsset[_setToken][_reserveAsset], "Must be valid reserve asset");\n    }\n    function _validateIssuanceInfo(ISetToken _setToken, uint256 _minSetTokenReceiveQuantity, ActionInfo memory _issueInfo) internal view {\n        // Check that total supply is greater than min supply needed for issuance\n        // Note: A min supply amount is needed to avoid division by 0 when SetToken supply is 0\n        require(\n            _issueInfo.previousSetTokenSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply,\n            "Supply must be greater than minimum to enable issuance"\n        );\n        require(_issueInfo.setTokenQuantity &gt;= _minSetTokenReceiveQuantity, "Must be greater than min SetToken");\n    }\n    function _validateRedemptionInfo(\n        ISetToken _setToken,\n        uint256 _minReserveReceiveQuantity,\n        ActionInfo memory _redeemInfo\n    )\n        internal\n        view\n    {\n        // Check that new supply is more than min supply needed for redemption\n        // Note: A min supply amount is needed to avoid division by 0 when redeeming SetToken to 0\n        require(\n            _redeemInfo.newSetTokenSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply,\n            "Supply must be greater than minimum to enable redemption"\n        );\n        require(_redeemInfo.netFlowQuantity &gt;= _minReserveReceiveQuantity, "Must be greater than min receive reserve quantity");\n    }\n    function _createIssuanceInfo(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _reserveAssetQuantity\n    )\n        internal\n        view\n        returns (ActionInfo memory)\n    {\n        ActionInfo memory issueInfo;\n        issueInfo.previousSetTokenSupply = _setToken.totalSupply();\n        issueInfo.preFeeReserveQuantity = _reserveAssetQuantity;\n        (issueInfo.protocolFees, issueInfo.managerFee, issueInfo.netFlowQuantity) = _getFees(\n            _setToken,\n            issueInfo.preFeeReserveQuantity,\n            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,\n            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,\n            MANAGER_ISSUE_FEE_INDEX\n        );\n        issueInfo.setTokenQuantity = _getSetTokenMintQuantity(\n            _setToken,\n            _reserveAsset,\n            issueInfo.netFlowQuantity,\n            issueInfo.previousSetTokenSupply\n        );\n        (issueInfo.newSetTokenSupply, issueInfo.newPositionMultiplier) = _getIssuePositionMultiplier(_setToken, issueInfo);\n        issueInfo.newReservePositionUnit = _getIssuePositionUnit(_setToken, _reserveAsset, issueInfo);\n        return issueInfo;\n    }\n    function _createRedemptionInfo(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _setTokenQuantity\n    )\n        internal\n        view\n        returns (ActionInfo memory)\n    {\n        ActionInfo memory redeemInfo;\n        redeemInfo.setTokenQuantity = _setTokenQuantity;\n        redeemInfo.preFeeReserveQuantity =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);\n        (redeemInfo.protocolFees, redeemInfo.managerFee, redeemInfo.netFlowQuantity) = _getFees(\n            _setToken,\n            redeemInfo.preFeeReserveQuantity,\n            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,\n            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,\n            MANAGER_REDEEM_FEE_INDEX\n        );\n        redeemInfo.previousSetTokenSupply = _setToken.totalSupply();\n        (redeemInfo.newSetTokenSupply, redeemInfo.newPositionMultiplier) = _getRedeemPositionMultiplier(_setToken, _setTokenQuantity, redeemInfo);\n        redeemInfo.newReservePositionUnit = _getRedeemPositionUnit(_setToken, _reserveAsset, redeemInfo);\n        return redeemInfo;\n    }\n    /\n     * Transfer reserve asset from user to SetToken and fees from user to appropriate fee recipients\n     /\n    function _transferCollateralAndHandleFees(ISetToken _setToken, IERC20 _reserveAsset, ActionInfo memory _issueInfo) internal {\n        transferFrom(_reserveAsset, msg.sender, address(_setToken), _issueInfo.netFlowQuantity);\n        if (_issueInfo.protocolFees &gt; 0) {\n            transferFrom(_reserveAsset, msg.sender, controller.feeRecipient(), _issueInfo.protocolFees);\n        }\n        if (_issueInfo.managerFee &gt; 0) {\n            transferFrom(_reserveAsset, msg.sender, navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);\n        }\n    }\n\n    /\n      * Transfer WETH from module to SetToken and fees from module to appropriate fee recipients\n     */\n    function _transferWETHAndHandleFees(ISetToken _setToken, ActionInfo memory _issueInfo) internal {\n        weth.transfer(address(_setToken), _issueInfo.netFlowQuantity);\n        if (_issueInfo.protocolFees &gt; 0) {\n            weth.transfer(controller.feeRecipient(), _issueInfo.protocolFees);\n        }\n        if (_issueInfo.managerFee &gt; 0) {\n            weth.transfer(navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);\n        }\n    }\n    function _handleIssueStateUpdates(\n        ISetToken _setToken,\n        address _reserveAsset,\n        address _to,\n        ActionInfo memory _issueInfo\n    )\n        internal\n    {\n        _setToken.editPositionMultiplier(_issueInfo.newPositionMultiplier);\n        _setToken.editDefaultPosition(_reserveAsset, _issueInfo.newReservePositionUnit);\n        _setToken.mint(_to, _issueInfo.setTokenQuantity);\n        emit SetTokenNAVIssued(\n            _setToken,\n            msg.sender,\n            _to,\n            _reserveAsset,\n            address(navIssuanceSettings[_setToken].managerIssuanceHook),\n            _issueInfo.setTokenQuantity,\n            _issueInfo.managerFee,\n            _issueInfo.protocolFees\n        );\n    }\n    function _handleRedeemStateUpdates(\n        ISetToken _setToken,\n        address _reserveAsset,\n        address _to,\n        ActionInfo memory _redeemInfo\n    )\n        internal\n    {\n        _setToken.editPositionMultiplier(_redeemInfo.newPositionMultiplier);\n        _setToken.editDefaultPosition(_reserveAsset, _redeemInfo.newReservePositionUnit);\n        emit SetTokenNAVRedeemed(\n            _setToken,\n            msg.sender,\n            _to,\n            _reserveAsset,\n            address(navIssuanceSettings[_setToken].managerRedemptionHook),\n            _redeemInfo.setTokenQuantity,\n            _redeemInfo.managerFee,\n            _redeemInfo.protocolFees\n        );\n    }\n    function _handleRedemptionFees(ISetToken _setToken, address _reserveAsset, ActionInfo memory _redeemInfo) internal {\n        // Instruct the SetToken to transfer protocol fee to fee recipient if there is a fee\n        payProtocolFeeFromSetToken(_setToken, _reserveAsset, _redeemInfo.protocolFees);\n        // Instruct the SetToken to transfer manager fee to manager fee recipient if there is a fee\n        if (_redeemInfo.managerFee &gt; 0) {\n            _setToken.strictInvokeTransfer(\n                _reserveAsset,\n                navIssuanceSettings[_setToken].feeRecipient,\n                _redeemInfo.managerFee\n            );\n        }\n    }\n    /\n     * Returns the issue premium percentage. Virtual function that can be overridden in future versions of the module\n     * and can contain arbitrary logic to calculate the issuance premium.\n     /\n    function _getIssuePremium(\n        ISetToken _setToken,\n        address / _reserveAsset /,\n        uint256 / _reserveAssetQuantity /\n    )\n        virtual\n        internal\n        view\n        returns (uint256)\n    {\n        return navIssuanceSettings[_setToken].premiumPercentage;\n    }\n    /\n     * Returns the redeem premium percentage. Virtual function that can be overridden in future versions of the module\n     * and can contain arbitrary logic to calculate the redemption premium.\n     /\n    function _getRedeemPremium(\n        ISetToken _setToken,\n        address / _reserveAsset /,\n        uint256 / _setTokenQuantity /\n    )\n        virtual\n        internal\n        view\n        returns (uint256)\n    {\n        return navIssuanceSettings[_setToken].premiumPercentage;\n    }\n    /\n     * Returns the fees attributed to the manager and the protocol. The fees are calculated as follows:\n     \n     * ManagerFee = (manager fee % - % to protocol) * reserveAssetQuantity\n     * Protocol Fee = (% manager fee share + direct fee %) * reserveAssetQuantity\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _reserveAssetQuantity         Quantity of reserve asset to calculate fees from\n     * @param _protocolManagerFeeIndex      Index to pull rev share NAV Issuance fee from the Controller\n     * @param _protocolDirectFeeIndex       Index to pull direct NAV issuance fee from the Controller\n     * @param _managerFeeIndex              Index from NAVIssuanceSettings (0 = issue fee, 1 = redeem fee)\n     \n     * @return  uint256                     Fees paid to the protocol in reserve asset\n     * @return  uint256                     Fees paid to the manager in reserve asset\n     * @return  uint256                     Net reserve to user net of fees\n     /\n    function _getFees(\n        ISetToken _setToken,\n        uint256 _reserveAssetQuantity,\n        uint256 _protocolManagerFeeIndex,\n        uint256 _protocolDirectFeeIndex,\n        uint256 _managerFeeIndex\n    )\n        internal\n        view\n        returns (uint256, uint256, uint256)\n    {\n        (uint256 protocolFeePercentage, uint256 managerFeePercentage) = _getProtocolAndManagerFeePercentages(\n            _setToken,\n            _protocolManagerFeeIndex,\n            _protocolDirectFeeIndex,\n            _managerFeeIndex\n        );\n        // Calculate total notional fees\n        uint256 protocolFees = protocolFeePercentage.preciseMul(_reserveAssetQuantity);\n        uint256 managerFee = managerFeePercentage.preciseMul(_reserveAssetQuantity);\n        uint256 netReserveFlow = _reserveAssetQuantity.sub(protocolFees).sub(managerFee);\n        return (protocolFees, managerFee, netReserveFlow);\n    }\n    function _getProtocolAndManagerFeePercentages(\n        ISetToken _setToken,\n        uint256 _protocolManagerFeeIndex,\n        uint256 _protocolDirectFeeIndex,\n        uint256 _managerFeeIndex\n    )\n        internal\n        view\n        returns(uint256, uint256)\n    {\n        // Get protocol fee percentages\n        uint256 protocolDirectFeePercent = controller.getModuleFee(address(this), _protocolDirectFeeIndex);\n        uint256 protocolManagerShareFeePercent = controller.getModuleFee(address(this), _protocolManagerFeeIndex);\n        uint256 managerFeePercent = navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];\n        // Calculate revenue share split percentage\n        uint256 protocolRevenueSharePercentage = protocolManagerShareFeePercent.preciseMul(managerFeePercent);\n        uint256 managerRevenueSharePercentage = managerFeePercent.sub(protocolRevenueSharePercentage);\n        uint256 totalProtocolFeePercentage = protocolRevenueSharePercentage.add(protocolDirectFeePercent);\n        return (totalProtocolFeePercentage, managerRevenueSharePercentage);\n    }\n    function _getSetTokenMintQuantity(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _netReserveFlows,            // Value of reserve asset net of fees\n        uint256 _setTotalSupply\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 premiumPercentage = _getIssuePremium(_setToken, _reserveAsset, _netReserveFlows);\n        uint256 premiumValue = _netReserveFlows.preciseMul(premiumPercentage);\n        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (1e18)\n        // Reverts if price is not found\n        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);\n        // Get reserve asset decimals\n        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();\n        uint256 normalizedTotalReserveQuantityNetFees = _netReserveFlows.preciseDiv(10 ** reserveAssetDecimals);\n        uint256 normalizedTotalReserveQuantityNetFeesAndPremium = _netReserveFlows.sub(premiumValue).preciseDiv(10 ** reserveAssetDecimals);\n        // Calculate SetTokens to mint to issuer\n        uint256 denominator = _setTotalSupply.preciseMul(setTokenValuation).add(normalizedTotalReserveQuantityNetFees).sub(normalizedTotalReserveQuantityNetFeesAndPremium);\n        return normalizedTotalReserveQuantityNetFeesAndPremium.preciseMul(_setTotalSupply).preciseDiv(denominator);\n    }\n    function _getRedeemReserveQuantity(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _setTokenQuantity\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (10e18)\n        // Reverts if price is not found\n        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);\n        uint256 totalRedeemValueInPreciseUnits = _setTokenQuantity.preciseMul(setTokenValuation);\n        // Get reserve asset decimals\n        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();\n        uint256 prePremiumReserveQuantity = totalRedeemValueInPreciseUnits.preciseMul(10 ** reserveAssetDecimals);\n        uint256 premiumPercentage = _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);\n        uint256 premiumQuantity = prePremiumReserveQuantity.preciseMulCeil(premiumPercentage);\n        return prePremiumReserveQuantity.sub(premiumQuantity);\n    }\n    /\n     * The new position multiplier is calculated as follows:\n     * inflationPercentage = (newSupply - oldSupply) / newSupply\n     * newMultiplier = (1 - inflationPercentage) * positionMultiplier\n     /\n    function _getIssuePositionMultiplier(\n        ISetToken _setToken,\n        ActionInfo memory _issueInfo\n    )\n        internal\n        view\n        returns (uint256, int256)\n    {\n        // Calculate inflation and new position multiplier. Note: Round inflation up in order to round position multiplier down\n        uint256 newTotalSupply = _issueInfo.setTokenQuantity.add(_issueInfo.previousSetTokenSupply);\n        int256 newPositionMultiplier = _setToken.positionMultiplier()\n            .mul(_issueInfo.previousSetTokenSupply.toInt256())\n            .div(newTotalSupply.toInt256());\n        return (newTotalSupply, newPositionMultiplier);\n    }\n    /\n     * Calculate deflation and new position multiplier. Note: Round deflation down in order to round position multiplier down\n     \n     * The new position multiplier is calculated as follows:\n     * deflationPercentage = (oldSupply - newSupply) / newSupply\n     * newMultiplier = (1 + deflationPercentage) * positionMultiplier\n     /\n    function _getRedeemPositionMultiplier(\n        ISetToken _setToken,\n        uint256 _setTokenQuantity,\n        ActionInfo memory _redeemInfo\n    )\n        internal\n        view\n        returns (uint256, int256)\n    {\n        uint256 newTotalSupply = _redeemInfo.previousSetTokenSupply.sub(_setTokenQuantity);\n        int256 newPositionMultiplier = _setToken.positionMultiplier()\n            .mul(_redeemInfo.previousSetTokenSupply.toInt256())\n            .div(newTotalSupply.toInt256());\n        return (newTotalSupply, newPositionMultiplier);\n    }\n    /\n     * The new position reserve asset unit is calculated as follows:\n     * totalReserve = (oldUnit * oldSetTokenSupply) + reserveQuantity\n     * newUnit = totalReserve / newSetTokenSupply\n     /\n    function _getIssuePositionUnit(\n        ISetToken _setToken,\n        address _reserveAsset,\n        ActionInfo memory _issueInfo\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();\n        uint256 totalReserve = existingUnit\n            .preciseMul(_issueInfo.previousSetTokenSupply)\n            .add(_issueInfo.netFlowQuantity);\n        return totalReserve.preciseDiv(_issueInfo.newSetTokenSupply);\n    }\n    /\n     * The new position reserve asset unit is calculated as follows:\n     * totalReserve = (oldUnit * oldSetTokenSupply) - reserveQuantityToSendOut\n     * newUnit = totalReserve / newSetTokenSupply\n     */\n    function _getRedeemPositionUnit(\n        ISetToken _setToken,\n        address _reserveAsset,\n        ActionInfo memory _redeemInfo\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();\n        uint256 totalExistingUnits = existingUnit.preciseMul(_redeemInfo.previousSetTokenSupply);\n        uint256 outflow = _redeemInfo.netFlowQuantity.add(_redeemInfo.protocolFees).add(_redeemInfo.managerFee);\n        // Require withdrawable quantity is greater than existing collateral\n        require(totalExistingUnits &gt;= outflow, "Must be greater than total available collateral");\n        return totalExistingUnits.sub(outflow).preciseDiv(_redeemInfo.newSetTokenSupply);\n    }\n    /\n     * If a pre-issue hook has been configured, call the external-protocol contract. Pre-issue hook logic\n     * can contain arbitrary logic including validations, external function calls, etc.\n     /\n    function _callPreIssueHooks(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _reserveAssetQuantity,\n        address _caller,\n        address _to\n    )\n        internal\n    {\n        INAVIssuanceHook preIssueHook = navIssuanceSettings[_setToken].managerIssuanceHook;\n        if (address(preIssueHook) != address(0)) {\n            preIssueHook.invokePreIssueHook(_setToken, _reserveAsset, _reserveAssetQuantity, _caller, _to);\n        }\n    }\n    /\n     * If a pre-redeem hook has been configured, call the external-protocol contract.\n     /\n    function _callPreRedeemHooks(ISetToken _setToken, uint256 _setQuantity, address _caller, address _to) internal {\n        INAVIssuanceHook preRedeemHook = navIssuanceSettings[_setToken].managerRedemptionHook;\n        if (address(preRedeemHook) != address(0)) {\n            preRedeemHook.invokePreRedeemHook(_setToken, _setQuantity, _caller, _to);\n        }\n    }\n}".\nAs the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.\nNote that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we\'ve collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions".\n\nSecurity Analyst: Certainly', 'question': 'Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" '} |
| **need_reflect** | False |
| **memory** | No existed memory |
| **chat_turn_limit** | 1 |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 05:31:15 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **task_prompt** | /*     Copyright 2020 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol"; import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol"; import { SignedSafeMath } from "@openzeppelin/contracts/math/SignedSafeMath.sol"; import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol"; import { IController } from "../../interfaces/IController.sol"; import { INAVIssuanceHook } from "../../interfaces/INAVIssuanceHook.sol"; import { Invoke } from "../lib/Invoke.sol"; import { ISetToken } from "../../interfaces/ISetToken.sol"; import { IWETH } from "../../interfaces/external/IWETH.sol"; import { ModuleBase } from "../lib/ModuleBase.sol"; import { Position } from "../lib/Position.sol"; import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol"; import { ResourceIdentifier } from "../lib/ResourceIdentifier.sol"; /*  * @title NavIssuanceModule  * @author Set Protocol  *  * Module that enables issuance and redemption with any valid ERC20 token or ETH if allowed by the manager. Sender receives  * a proportional amount of SetTokens on issuance or ERC20 token on redemption based on the calculated net asset value using  * oracle prices. Manager is able to enforce a premium / discount on issuance / redemption to avoid arbitrage and front  * running when relying on oracle prices. Managers can charge a fee (denominated in reserve asset).  / contract NavIssuanceModule is ModuleBase, ReentrancyGuard {     using AddressArrayUtils for address[];     using Invoke for ISetToken;     using Position for ISetToken;     using PreciseUnitMath for uint256;     using PreciseUnitMath for int256;     using ResourceIdentifier for IController;     using SafeMath for uint256;     using SafeCast for int256;     using SafeCast for uint256;     using SignedSafeMath for int256; /* ============ Events ============ */  event SetTokenNAVIssued(     ISetToken indexed _setToken,     address _issuer,     address _to,     address _reserveAsset,     address _hookContract,     uint256 _setTokenQuantity,     uint256 _managerFee,     uint256 _premium );  event SetTokenNAVRedeemed(     ISetToken indexed _setToken,     address _redeemer,     address _to,     address _reserveAsset,     address _hookContract,     uint256 _setTokenQuantity,     uint256 _managerFee,     uint256 _premium );  event ReserveAssetAdded(     ISetToken indexed _setToken,     address _newReserveAsset );  event ReserveAssetRemoved(     ISetToken indexed _setToken,     address _removedReserveAsset );  event PremiumEdited(     ISetToken indexed _setToken,     uint256 _newPremium );  event ManagerFeeEdited(     ISetToken indexed _setToken,     uint256 _newManagerFee,     uint256 _index );  event FeeRecipientEdited(     ISetToken indexed _setToken,     address _feeRecipient );  /* ============ Structs ============ */  struct NAVIssuanceSettings {     INAVIssuanceHook managerIssuanceHook;      // Issuance hook configurations     INAVIssuanceHook managerRedemptionHook;    // Redemption hook configurations     address[] reserveAssets;                       // Allowed reserve assets - Must have a price enabled with the price oracle     address feeRecipient;                          // Manager fee recipient     uint256[2] managerFees;                        // Manager fees. 0 index is issue and 1 index is redeem fee (0.01% = 1e14, 1% = 1e16)     uint256 maxManagerFee;                         // Maximum fee manager is allowed to set for issue and redeem     uint256 premiumPercentage;                     // Premium percentage (0.01% = 1e14, 1% = 1e16). This premium is a buffer around oracle                                                    // prices paid by user to the SetToken, which prevents arbitrage and oracle front running     uint256 maxPremiumPercentage;                  // Maximum premium percentage manager is allowed to set (configured by manager)     uint256 minSetTokenSupply;                     // Minimum SetToken supply required for issuance and redemption                                                    // to prevent dramatic inflationary changes to the SetToken's position multiplier }  struct ActionInfo {     uint256 preFeeReserveQuantity;                 // Reserve value before fees; During issuance, represents raw quantity                                                    // During redeem, represents post-premium value     uint256 protocolFees;                          // Total protocol fees (direct + manager revenue share)     uint256 managerFee;                            // Total manager fee paid in reserve asset     uint256 netFlowQuantity;                       // When issuing, quantity of reserve asset sent to SetToken                                                    // When redeeming, quantity of reserve asset sent to redeemer     uint256 setTokenQuantity;                      // When issuing, quantity of SetTokens minted to mintee                                                    // When redeeming, quantity of SetToken redeemed     uint256 previousSetTokenSupply;                // SetToken supply prior to issue/redeem action     uint256 newSetTokenSupply;                     // SetToken supply after issue/redeem action     int256 newPositionMultiplier;                  // SetToken position multiplier after issue/redeem     uint256 newReservePositionUnit;                // SetToken reserve asset position unit after issue/redeem }  /* ============ State Variables ============ */  // Wrapped ETH address IWETH public immutable weth;  // Mapping of SetToken to NAV issuance settings struct mapping(ISetToken =&gt; NAVIssuanceSettings) public navIssuanceSettings;  // Mapping to efficiently check a SetToken's reserve asset validity // SetToken =&gt; reserveAsset =&gt; isReserveAsset mapping(ISetToken =&gt; mapping(address =&gt; bool)) public isReserveAsset;  /* ============ Constants ============ */  // 0 index stores the manager fee in managerFees array, percentage charged on issue (denominated in reserve asset) uint256 constant internal MANAGER_ISSUE_FEE_INDEX = 0;  // 1 index stores the manager fee percentage in managerFees array, charged on redeem uint256 constant internal MANAGER_REDEEM_FEE_INDEX = 1;  // 0 index stores the manager revenue share protocol fee % on the controller, charged in the issuance function uint256 constant internal PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX = 0;  // 1 index stores the manager revenue share protocol fee % on the controller, charged in the redeem function uint256 constant internal PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX = 1;  // 2 index stores the direct protocol fee % on the controller, charged in the issuance function uint256 constant internal PROTOCOL_ISSUE_DIRECT_FEE_INDEX = 2;  // 3 index stores the direct protocol fee % on the controller, charged in the redeem function uint256 constant internal PROTOCOL_REDEEM_DIRECT_FEE_INDEX = 3;  /* ============ Constructor ============ */  /**  * @param _controller               Address of controller contract  * @param _weth                     Address of wrapped eth  */ constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {     weth = _weth; }  /* ============ External Functions ============ */  /**  * Deposits the allowed reserve asset into the SetToken and mints the appropriate % of Net Asset Value of the SetToken  * to the specified _to address.  *  * @param _setToken                     Instance of the SetToken contract  * @param _reserveAsset                 Address of the reserve asset to issue with  * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with  * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance  * @param _to                           Address to mint SetToken to  */ function issue(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity,     uint256 _minSetTokenReceiveQuantity,     address _to )     external     nonReentrant     onlyValidAndInitializedSet(_setToken) {     _validateCommon(_setToken, _reserveAsset, _reserveAssetQuantity);      _callPreIssueHooks(_setToken, _reserveAsset, _reserveAssetQuantity, msg.sender, _to);      ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, _reserveAsset, _reserveAssetQuantity);      _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);      _transferCollateralAndHandleFees(_setToken, IERC20(_reserveAsset), issueInfo);      _handleIssueStateUpdates(_setToken, _reserveAsset, _to, issueInfo); }  /**  * Wraps ETH and deposits WETH if allowed into the SetToken and mints the appropriate % of Net Asset Value of the SetToken  * to the specified _to address.  *  * @param _setToken                     Instance of the SetToken contract  * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance  * @param _to                           Address to mint SetToken to  */ function issueWithEther(     ISetToken _setToken,     uint256 _minSetTokenReceiveQuantity,     address _to )     external     payable     nonReentrant     onlyValidAndInitializedSet(_setToken) {     weth.deposit{ value: msg.value }();      _validateCommon(_setToken, address(weth), msg.value);      _callPreIssueHooks(_setToken, address(weth), msg.value, msg.sender, _to);      ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, address(weth), msg.value);      _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);      _transferWETHAndHandleFees(_setToken, issueInfo);      _handleIssueStateUpdates(_setToken, address(weth), _to, issueInfo); }  /**  * Redeems a SetToken into a valid reserve asset representing the appropriate % of Net Asset Value of the SetToken  * to the specified _to address. Only valid if there are available reserve units on the SetToken.  *  * @param _setToken                     Instance of the SetToken contract  * @param _reserveAsset                 Address of the reserve asset to redeem with  * @param _setTokenQuantity             Quantity of SetTokens to redeem  * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive  * @param _to                           Address to redeem reserve asset to  */ function redeem(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity,     uint256 _minReserveReceiveQuantity,     address _to )     external     nonReentrant     onlyValidAndInitializedSet(_setToken) {     _validateCommon(_setToken, _reserveAsset, _setTokenQuantity);      _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);      ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, _reserveAsset, _setTokenQuantity);      _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);      _setToken.burn(msg.sender, _setTokenQuantity);      // Instruct the SetToken to transfer the reserve asset back to the user     _setToken.strictInvokeTransfer(         _reserveAsset,         _to,         redeemInfo.netFlowQuantity     );      _handleRedemptionFees(_setToken, _reserveAsset, redeemInfo);      _handleRedeemStateUpdates(_setToken, _reserveAsset, _to, redeemInfo); }  /**  * Redeems a SetToken into Ether (if WETH is valid) representing the appropriate % of Net Asset Value of the SetToken  * to the specified _to address. Only valid if there are available WETH units on the SetToken.  *  * @param _setToken                     Instance of the SetToken contract  * @param _setTokenQuantity             Quantity of SetTokens to redeem  * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive  * @param _to                           Address to redeem reserve asset to  */ function redeemIntoEther(     ISetToken _setToken,     uint256 _setTokenQuantity,     uint256 _minReserveReceiveQuantity,     address payable _to )     external     nonReentrant     onlyValidAndInitializedSet(_setToken) {     _validateCommon(_setToken, address(weth), _setTokenQuantity);      _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);      ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, address(weth), _setTokenQuantity);      _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);      _setToken.burn(msg.sender, _setTokenQuantity);      // Instruct the SetToken to transfer WETH from SetToken to module     _setToken.strictInvokeTransfer(         address(weth),         address(this),         redeemInfo.netFlowQuantity     );      weth.withdraw(redeemInfo.netFlowQuantity);      _to.transfer(redeemInfo.netFlowQuantity);      _handleRedemptionFees(_setToken, address(weth), redeemInfo);      _handleRedeemStateUpdates(_setToken, address(weth), _to, redeemInfo); }  /**  * SET MANAGER ONLY. Add an allowed reserve asset  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset to add  */ function addReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {     require(!isReserveAsset[_setToken][_reserveAsset], "Reserve asset already exists");      navIssuanceSettings[_setToken].reserveAssets.push(_reserveAsset);     isReserveAsset[_setToken][_reserveAsset] = true;      emit ReserveAssetAdded(_setToken, _reserveAsset); }  /**  * SET MANAGER ONLY. Remove a reserve asset  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset to remove  */ function removeReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {     require(isReserveAsset[_setToken][_reserveAsset], "Reserve asset does not exist");      navIssuanceSettings[_setToken].reserveAssets = navIssuanceSettings[_setToken].reserveAssets.remove(_reserveAsset);     delete isReserveAsset[_setToken][_reserveAsset];      emit ReserveAssetRemoved(_setToken, _reserveAsset); }  /**  * SET MANAGER ONLY. Edit the premium percentage  *  * @param _setToken                     Instance of the SetToken  * @param _premiumPercentage            Premium percentage in 10e16 (e.g. 10e16 = 1%)  */ function editPremium(ISetToken _setToken, uint256 _premiumPercentage) external onlyManagerAndValidSet(_setToken) {     require(_premiumPercentage &lt;= navIssuanceSettings[_setToken].maxPremiumPercentage, "Premium must be less than maximum allowed");      navIssuanceSettings[_setToken].premiumPercentage = _premiumPercentage;      emit PremiumEdited(_setToken, _premiumPercentage); }  /**  * SET MANAGER ONLY. Edit manager fee  *  * @param _setToken                     Instance of the SetToken  * @param _managerFeePercentage         Manager fee percentage in 10e16 (e.g. 10e16 = 1%)  * @param _managerFeeIndex              Manager fee index. 0 index is issue fee, 1 index is redeem fee  */ function editManagerFee(     ISetToken _setToken,     uint256 _managerFeePercentage,     uint256 _managerFeeIndex )     external     onlyManagerAndValidSet(_setToken) {     require(_managerFeePercentage &lt;= navIssuanceSettings[_setToken].maxManagerFee, "Manager fee must be less than maximum allowed");      navIssuanceSettings[_setToken].managerFees[_managerFeeIndex] = _managerFeePercentage;      emit ManagerFeeEdited(_setToken, _managerFeePercentage, _managerFeeIndex); }  /**  * SET MANAGER ONLY. Edit the manager fee recipient  *  * @param _setToken                     Instance of the SetToken  * @param _managerFeeRecipient          Manager fee recipient  */ function editFeeRecipient(ISetToken _setToken, address _managerFeeRecipient) external onlyManagerAndValidSet(_setToken) {     require(_managerFeeRecipient != address(0), "Fee recipient must not be 0 address");      navIssuanceSettings[_setToken].feeRecipient = _managerFeeRecipient;      emit FeeRecipientEdited(_setToken, _managerFeeRecipient); }  /**  * SET MANAGER ONLY. Initializes this module to the SetToken with hooks, allowed reserve assets,  * fees and issuance premium. Only callable by the SetToken's manager. Hook addresses are optional.  * Address(0) means that no hook will be called.  *  * @param _setToken                     Instance of the SetToken to issue  * @param _navIssuanceSettings          NAVIssuanceSettings struct defining parameters  */ function initialize(     ISetToken _setToken,     NAVIssuanceSettings memory _navIssuanceSettings )     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     require(_navIssuanceSettings.reserveAssets.length &gt; 0, "Reserve assets must be greater than 0");     require(_navIssuanceSettings.maxManagerFee &lt; PreciseUnitMath.preciseUnit(), "Max manager fee must be less than 100%");     require(_navIssuanceSettings.maxPremiumPercentage &lt; PreciseUnitMath.preciseUnit(), "Max premium percentage must be less than 100%");     require(_navIssuanceSettings.managerFees[0] &lt;= _navIssuanceSettings.maxManagerFee, "Manager issue fee must be less than max");     require(_navIssuanceSettings.managerFees[1] &lt;= _navIssuanceSettings.maxManagerFee, "Manager redeem fee must be less than max");     require(_navIssuanceSettings.premiumPercentage &lt;= _navIssuanceSettings.maxPremiumPercentage, "Premium must be less than max");     require(_navIssuanceSettings.feeRecipient != address(0), "Fee Recipient must be non-zero address.");     // Initial mint of Set cannot use NAVIssuance since minSetTokenSupply must be &gt; 0     require(_navIssuanceSettings.minSetTokenSupply &gt; 0, "Min SetToken supply must be greater than 0");      for (uint256 i = 0; i &lt; _navIssuanceSettings.reserveAssets.length; i++) {         require(!isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]], "Reserve assets must be unique");         isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]] = true;     }      navIssuanceSettings[_setToken] = _navIssuanceSettings;      _setToken.initializeModule(); }  /**  * Removes this module from the SetToken, via call by the SetToken. Issuance settings and  * reserve asset states are deleted.  */ function removeModule() external override {     ISetToken setToken = ISetToken(msg.sender);     for (uint256 i = 0; i &lt; navIssuanceSettings[setToken].reserveAssets.length; i++) {         delete isReserveAsset[setToken][navIssuanceSettings[setToken].reserveAssets[i]];     }      delete navIssuanceSettings[setToken]; }  receive() external payable {}  /* ============ External Getter Functions ============ */  function getReserveAssets(ISetToken _setToken) external view returns (address[] memory) {     return navIssuanceSettings[_setToken].reserveAssets; }  function getIssuePremium(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     external     view     returns (uint256) {     return _getIssuePremium(_setToken, _reserveAsset, _reserveAssetQuantity); }  function getRedeemPremium(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     external     view     returns (uint256) {     return _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity); }  function getManagerFee(ISetToken _setToken, uint256 _managerFeeIndex) external view returns (uint256) {     return navIssuanceSettings[_setToken].managerFees[_managerFeeIndex]; }  /**  * Get the expected SetTokens minted to recipient on issuance  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with  *  * @return  uint256                     Expected SetTokens to be minted to recipient  */ function getExpectedSetTokenIssueQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     external     view     returns (uint256) {     (,, uint256 netReserveFlow) = _getFees(         _setToken,         _reserveAssetQuantity,         PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_ISSUE_DIRECT_FEE_INDEX,         MANAGER_ISSUE_FEE_INDEX     );      uint256 setTotalSupply = _setToken.totalSupply();      return _getSetTokenMintQuantity(         _setToken,         _reserveAsset,         netReserveFlow,         setTotalSupply     ); }  /**  * Get the expected reserve asset to be redeemed  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _setTokenQuantity             Quantity of SetTokens to redeem  *  * @return  uint256                     Expected reserve asset quantity redeemed  */ function getExpectedReserveRedeemQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     external     view     returns (uint256) {     uint256 preFeeReserveQuantity = _getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);      (,, uint256 netReserveFlows) = _getFees(         _setToken,         preFeeReserveQuantity,         PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_REDEEM_DIRECT_FEE_INDEX,         MANAGER_REDEEM_FEE_INDEX     );      return netReserveFlows; }  /**  * Checks if issue is valid  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with  *  * @return  bool                        Returns true if issue is valid  */ function isIssueValid(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     external     view     returns (bool) {     uint256 setTotalSupply = _setToken.totalSupply();  return _reserveAssetQuantity != 0         &amp;&amp; isReserveAsset[_setToken][_reserveAsset]         &amp;&amp; setTotalSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply; }  /**  * Checks if redeem is valid  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _setTokenQuantity             Quantity of SetTokens to redeem  *  * @return  bool                        Returns true if redeem is valid  */ function isRedeemValid(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     external     view     returns (bool) {     uint256 setTotalSupply = _setToken.totalSupply();      if (         _setTokenQuantity == 0         || !isReserveAsset[_setToken][_reserveAsset]         || setTotalSupply &lt; navIssuanceSettings[_setToken].minSetTokenSupply.add(_setTokenQuantity)     ) {         return false;     } else {         uint256 totalRedeemValue =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);          (,, uint256 expectedRedeemQuantity) = _getFees(             _setToken,             totalRedeemValue,             PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,             PROTOCOL_REDEEM_DIRECT_FEE_INDEX,             MANAGER_REDEEM_FEE_INDEX         );          uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();          return existingUnit.preciseMul(setTotalSupply) &gt;= expectedRedeemQuantity;     } }  /* ============ Internal Functions ============ */  function _validateCommon(ISetToken _setToken, address _reserveAsset, uint256 _quantity) internal view {     require(_quantity &gt; 0, "Quantity must be &gt; 0");     require(isReserveAsset[_setToken][_reserveAsset], "Must be valid reserve asset"); }  function _validateIssuanceInfo(ISetToken _setToken, uint256 _minSetTokenReceiveQuantity, ActionInfo memory _issueInfo) internal view {     // Check that total supply is greater than min supply needed for issuance     // Note: A min supply amount is needed to avoid division by 0 when SetToken supply is 0     require(         _issueInfo.previousSetTokenSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply,         "Supply must be greater than minimum to enable issuance"     );      require(_issueInfo.setTokenQuantity &gt;= _minSetTokenReceiveQuantity, "Must be greater than min SetToken"); }  function _validateRedemptionInfo(     ISetToken _setToken,     uint256 _minReserveReceiveQuantity,     ActionInfo memory _redeemInfo )     internal     view {     // Check that new supply is more than min supply needed for redemption     // Note: A min supply amount is needed to avoid division by 0 when redeeming SetToken to 0     require(         _redeemInfo.newSetTokenSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply,         "Supply must be greater than minimum to enable redemption"     );      require(_redeemInfo.netFlowQuantity &gt;= _minReserveReceiveQuantity, "Must be greater than min receive reserve quantity"); }  function _createIssuanceInfo(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     internal     view     returns (ActionInfo memory) {     ActionInfo memory issueInfo;      issueInfo.previousSetTokenSupply = _setToken.totalSupply();      issueInfo.preFeeReserveQuantity = _reserveAssetQuantity;      (issueInfo.protocolFees, issueInfo.managerFee, issueInfo.netFlowQuantity) = _getFees(         _setToken,         issueInfo.preFeeReserveQuantity,         PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_ISSUE_DIRECT_FEE_INDEX,         MANAGER_ISSUE_FEE_INDEX     );      issueInfo.setTokenQuantity = _getSetTokenMintQuantity(         _setToken,         _reserveAsset,         issueInfo.netFlowQuantity,         issueInfo.previousSetTokenSupply     );      (issueInfo.newSetTokenSupply, issueInfo.newPositionMultiplier) = _getIssuePositionMultiplier(_setToken, issueInfo);      issueInfo.newReservePositionUnit = _getIssuePositionUnit(_setToken, _reserveAsset, issueInfo);      return issueInfo; }  function _createRedemptionInfo(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     internal     view     returns (ActionInfo memory) {     ActionInfo memory redeemInfo;      redeemInfo.setTokenQuantity = _setTokenQuantity;      redeemInfo.preFeeReserveQuantity =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);      (redeemInfo.protocolFees, redeemInfo.managerFee, redeemInfo.netFlowQuantity) = _getFees(         _setToken,         redeemInfo.preFeeReserveQuantity,         PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_REDEEM_DIRECT_FEE_INDEX,         MANAGER_REDEEM_FEE_INDEX     );      redeemInfo.previousSetTokenSupply = _setToken.totalSupply();      (redeemInfo.newSetTokenSupply, redeemInfo.newPositionMultiplier) = _getRedeemPositionMultiplier(_setToken, _setTokenQuantity, redeemInfo);      redeemInfo.newReservePositionUnit = _getRedeemPositionUnit(_setToken, _reserveAsset, redeemInfo);      return redeemInfo; }  /**  * Transfer reserve asset from user to SetToken and fees from user to appropriate fee recipients  */ function _transferCollateralAndHandleFees(ISetToken _setToken, IERC20 _reserveAsset, ActionInfo memory _issueInfo) internal {     transferFrom(_reserveAsset, msg.sender, address(_setToken), _issueInfo.netFlowQuantity);      if (_issueInfo.protocolFees &gt; 0) {         transferFrom(_reserveAsset, msg.sender, controller.feeRecipient(), _issueInfo.protocolFees);     }      if (_issueInfo.managerFee &gt; 0) {         transferFrom(_reserveAsset, msg.sender, navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);     } }   /**   * Transfer WETH from module to SetToken and fees from module to appropriate fee recipients  */ function _transferWETHAndHandleFees(ISetToken _setToken, ActionInfo memory _issueInfo) internal {     weth.transfer(address(_setToken), _issueInfo.netFlowQuantity);      if (_issueInfo.protocolFees &gt; 0) {         weth.transfer(controller.feeRecipient(), _issueInfo.protocolFees);     }      if (_issueInfo.managerFee &gt; 0) {         weth.transfer(navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);     } }  function _handleIssueStateUpdates(     ISetToken _setToken,     address _reserveAsset,     address _to,     ActionInfo memory _issueInfo )     internal {     _setToken.editPositionMultiplier(_issueInfo.newPositionMultiplier);      _setToken.editDefaultPosition(_reserveAsset, _issueInfo.newReservePositionUnit);      _setToken.mint(_to, _issueInfo.setTokenQuantity);      emit SetTokenNAVIssued(         _setToken,         msg.sender,         _to,         _reserveAsset,         address(navIssuanceSettings[_setToken].managerIssuanceHook),         _issueInfo.setTokenQuantity,         _issueInfo.managerFee,         _issueInfo.protocolFees     ); }  function _handleRedeemStateUpdates(     ISetToken _setToken,     address _reserveAsset,     address _to,     ActionInfo memory _redeemInfo )     internal {     _setToken.editPositionMultiplier(_redeemInfo.newPositionMultiplier);      _setToken.editDefaultPosition(_reserveAsset, _redeemInfo.newReservePositionUnit);      emit SetTokenNAVRedeemed(         _setToken,         msg.sender,         _to,         _reserveAsset,         address(navIssuanceSettings[_setToken].managerRedemptionHook),         _redeemInfo.setTokenQuantity,         _redeemInfo.managerFee,         _redeemInfo.protocolFees     ); }  function _handleRedemptionFees(ISetToken _setToken, address _reserveAsset, ActionInfo memory _redeemInfo) internal {     // Instruct the SetToken to transfer protocol fee to fee recipient if there is a fee     payProtocolFeeFromSetToken(_setToken, _reserveAsset, _redeemInfo.protocolFees);      // Instruct the SetToken to transfer manager fee to manager fee recipient if there is a fee     if (_redeemInfo.managerFee &gt; 0) {         _setToken.strictInvokeTransfer(             _reserveAsset,             navIssuanceSettings[_setToken].feeRecipient,             _redeemInfo.managerFee         );     } }  /**  * Returns the issue premium percentage. Virtual function that can be overridden in future versions of the module  * and can contain arbitrary logic to calculate the issuance premium.  */ function _getIssuePremium(     ISetToken _setToken,     address /* _reserveAsset */,     uint256 /* _reserveAssetQuantity */ )     virtual     internal     view     returns (uint256) {     return navIssuanceSettings[_setToken].premiumPercentage; }  /**  * Returns the redeem premium percentage. Virtual function that can be overridden in future versions of the module  * and can contain arbitrary logic to calculate the redemption premium.  */ function _getRedeemPremium(     ISetToken _setToken,     address /* _reserveAsset */,     uint256 /* _setTokenQuantity */ )     virtual     internal     view     returns (uint256) {     return navIssuanceSettings[_setToken].premiumPercentage; }  /**  * Returns the fees attributed to the manager and the protocol. The fees are calculated as follows:  *  * ManagerFee = (manager fee % - % to protocol) * reserveAssetQuantity  * Protocol Fee = (% manager fee share + direct fee %) * reserveAssetQuantity  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAssetQuantity         Quantity of reserve asset to calculate fees from  * @param _protocolManagerFeeIndex      Index to pull rev share NAV Issuance fee from the Controller  * @param _protocolDirectFeeIndex       Index to pull direct NAV issuance fee from the Controller  * @param _managerFeeIndex              Index from NAVIssuanceSettings (0 = issue fee, 1 = redeem fee)  *  * @return  uint256                     Fees paid to the protocol in reserve asset  * @return  uint256                     Fees paid to the manager in reserve asset  * @return  uint256                     Net reserve to user net of fees  */ function _getFees(     ISetToken _setToken,     uint256 _reserveAssetQuantity,     uint256 _protocolManagerFeeIndex,     uint256 _protocolDirectFeeIndex,     uint256 _managerFeeIndex )     internal     view     returns (uint256, uint256, uint256) {     (uint256 protocolFeePercentage, uint256 managerFeePercentage) = _getProtocolAndManagerFeePercentages(         _setToken,         _protocolManagerFeeIndex,         _protocolDirectFeeIndex,         _managerFeeIndex     );      // Calculate total notional fees     uint256 protocolFees = protocolFeePercentage.preciseMul(_reserveAssetQuantity);     uint256 managerFee = managerFeePercentage.preciseMul(_reserveAssetQuantity);      uint256 netReserveFlow = _reserveAssetQuantity.sub(protocolFees).sub(managerFee);      return (protocolFees, managerFee, netReserveFlow); }  function _getProtocolAndManagerFeePercentages(     ISetToken _setToken,     uint256 _protocolManagerFeeIndex,     uint256 _protocolDirectFeeIndex,     uint256 _managerFeeIndex )     internal     view     returns(uint256, uint256) {     // Get protocol fee percentages     uint256 protocolDirectFeePercent = controller.getModuleFee(address(this), _protocolDirectFeeIndex);     uint256 protocolManagerShareFeePercent = controller.getModuleFee(address(this), _protocolManagerFeeIndex);     uint256 managerFeePercent = navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];      // Calculate revenue share split percentage     uint256 protocolRevenueSharePercentage = protocolManagerShareFeePercent.preciseMul(managerFeePercent);     uint256 managerRevenueSharePercentage = managerFeePercent.sub(protocolRevenueSharePercentage);     uint256 totalProtocolFeePercentage = protocolRevenueSharePercentage.add(protocolDirectFeePercent);      return (totalProtocolFeePercentage, managerRevenueSharePercentage); }  function _getSetTokenMintQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _netReserveFlows,            // Value of reserve asset net of fees     uint256 _setTotalSupply )     internal     view     returns (uint256) {     uint256 premiumPercentage = _getIssuePremium(_setToken, _reserveAsset, _netReserveFlows);     uint256 premiumValue = _netReserveFlows.preciseMul(premiumPercentage);      // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (1e18)     // Reverts if price is not found     uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);      // Get reserve asset decimals     uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();     uint256 normalizedTotalReserveQuantityNetFees = _netReserveFlows.preciseDiv(10 ** reserveAssetDecimals);     uint256 normalizedTotalReserveQuantityNetFeesAndPremium = _netReserveFlows.sub(premiumValue).preciseDiv(10 ** reserveAssetDecimals);      // Calculate SetTokens to mint to issuer     uint256 denominator = _setTotalSupply.preciseMul(setTokenValuation).add(normalizedTotalReserveQuantityNetFees).sub(normalizedTotalReserveQuantityNetFeesAndPremium);     return normalizedTotalReserveQuantityNetFeesAndPremium.preciseMul(_setTotalSupply).preciseDiv(denominator); }  function _getRedeemReserveQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     internal     view     returns (uint256) {     // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (10e18)     // Reverts if price is not found     uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);      uint256 totalRedeemValueInPreciseUnits = _setTokenQuantity.preciseMul(setTokenValuation);     // Get reserve asset decimals     uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();     uint256 prePremiumReserveQuantity = totalRedeemValueInPreciseUnits.preciseMul(10 ** reserveAssetDecimals);      uint256 premiumPercentage = _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);     uint256 premiumQuantity = prePremiumReserveQuantity.preciseMulCeil(premiumPercentage);      return prePremiumReserveQuantity.sub(premiumQuantity); }  /**  * The new position multiplier is calculated as follows:  * inflationPercentage = (newSupply - oldSupply) / newSupply  * newMultiplier = (1 - inflationPercentage) * positionMultiplier  */ function _getIssuePositionMultiplier(     ISetToken _setToken,     ActionInfo memory _issueInfo )     internal     view     returns (uint256, int256) {     // Calculate inflation and new position multiplier. Note: Round inflation up in order to round position multiplier down     uint256 newTotalSupply = _issueInfo.setTokenQuantity.add(_issueInfo.previousSetTokenSupply);     int256 newPositionMultiplier = _setToken.positionMultiplier()         .mul(_issueInfo.previousSetTokenSupply.toInt256())         .div(newTotalSupply.toInt256());      return (newTotalSupply, newPositionMultiplier); }  /**  * Calculate deflation and new position multiplier. Note: Round deflation down in order to round position multiplier down  *  * The new position multiplier is calculated as follows:  * deflationPercentage = (oldSupply - newSupply) / newSupply  * newMultiplier = (1 + deflationPercentage) * positionMultiplier  */ function _getRedeemPositionMultiplier(     ISetToken _setToken,     uint256 _setTokenQuantity,     ActionInfo memory _redeemInfo )     internal     view     returns (uint256, int256) {     uint256 newTotalSupply = _redeemInfo.previousSetTokenSupply.sub(_setTokenQuantity);     int256 newPositionMultiplier = _setToken.positionMultiplier()         .mul(_redeemInfo.previousSetTokenSupply.toInt256())         .div(newTotalSupply.toInt256());      return (newTotalSupply, newPositionMultiplier); }  /**  * The new position reserve asset unit is calculated as follows:  * totalReserve = (oldUnit * oldSetTokenSupply) + reserveQuantity  * newUnit = totalReserve / newSetTokenSupply  */ function _getIssuePositionUnit(     ISetToken _setToken,     address _reserveAsset,     ActionInfo memory _issueInfo )     internal     view     returns (uint256) {     uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();     uint256 totalReserve = existingUnit         .preciseMul(_issueInfo.previousSetTokenSupply)         .add(_issueInfo.netFlowQuantity);      return totalReserve.preciseDiv(_issueInfo.newSetTokenSupply); }  /**  * The new position reserve asset unit is calculated as follows:  * totalReserve = (oldUnit * oldSetTokenSupply) - reserveQuantityToSendOut  * newUnit = totalReserve / newSetTokenSupply  */ function _getRedeemPositionUnit(     ISetToken _setToken,     address _reserveAsset,     ActionInfo memory _redeemInfo )     internal     view     returns (uint256) {     uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();     uint256 totalExistingUnits = existingUnit.preciseMul(_redeemInfo.previousSetTokenSupply);      uint256 outflow = _redeemInfo.netFlowQuantity.add(_redeemInfo.protocolFees).add(_redeemInfo.managerFee);      // Require withdrawable quantity is greater than existing collateral     require(totalExistingUnits &gt;= outflow, "Must be greater than total available collateral");      return totalExistingUnits.sub(outflow).preciseDiv(_redeemInfo.newSetTokenSupply); }  /**  * If a pre-issue hook has been configured, call the external-protocol contract. Pre-issue hook logic  * can contain arbitrary logic including validations, external function calls, etc.  */ function _callPreIssueHooks(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity,     address _caller,     address _to )     internal {     INAVIssuanceHook preIssueHook = navIssuanceSettings[_setToken].managerIssuanceHook;     if (address(preIssueHook) != address(0)) {         preIssueHook.invokePreIssueHook(_setToken, _reserveAsset, _reserveAssetQuantity, _caller, _to);     } }  /**  * If a pre-redeem hook has been configured, call the external-protocol contract.  */ function _callPreRedeemHooks(ISetToken _setToken, uint256 _setQuantity, address _caller, address _to) internal {     INAVIssuanceHook preRedeemHook = navIssuanceSettings[_setToken].managerRedemptionHook;     if (address(preRedeemHook) != address(0)) {         preRedeemHook.invokePreRedeemHook(_setToken, _setQuantity, _caller, _to);     } }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 05:31:15 INFO] Counselor: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: /*
    Copyright 2020 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";
import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";
import { SignedSafeMath } from "@openzeppelin/contracts/math/SignedSafeMath.sol";

import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";
import { IController } from "../../interfaces/IController.sol";
import { INAVIssuanceHook } from "../../interfaces/INAVIssuanceHook.sol";
import { Invoke } from "../lib/Invoke.sol";
import { ISetToken } from "../../interfaces/ISetToken.sol";
import { IWETH } from "../../interfaces/external/IWETH.sol";
import { ModuleBase } from "../lib/ModuleBase.sol";
import { Position } from "../lib/Position.sol";
import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";
import { ResourceIdentifier } from "../lib/ResourceIdentifier.sol";


/**
 * @title NavIssuanceModule
 * @author Set Protocol
 *
 * Module that enables issuance and redemption with any valid ERC20 token or ETH if allowed by the manager. Sender receives
 * a proportional amount of SetTokens on issuance or ERC20 token on redemption based on the calculated net asset value using
 * oracle prices. Manager is able to enforce a premium / discount on issuance / redemption to avoid arbitrage and front
 * running when relying on oracle prices. Managers can charge a fee (denominated in reserve asset).
 */
contract NavIssuanceModule is ModuleBase, ReentrancyGuard {
    using AddressArrayUtils for address[];
    using Invoke for ISetToken;
    using Position for ISetToken;
    using PreciseUnitMath for uint256;
    using PreciseUnitMath for int256;
    using ResourceIdentifier for IController;
    using SafeMath for uint256;
    using SafeCast for int256;
    using SafeCast for uint256;
    using SignedSafeMath for int256;

    /* ============ Events ============ */

    event SetTokenNAVIssued(
        ISetToken indexed _setToken,
        address _issuer,
        address _to,
        address _reserveAsset,
        address _hookContract,
        uint256 _setTokenQuantity,
        uint256 _managerFee,
        uint256 _premium
    );

    event SetTokenNAVRedeemed(
        ISetToken indexed _setToken,
        address _redeemer,
        address _to,
        address _reserveAsset,
        address _hookContract,
        uint256 _setTokenQuantity,
        uint256 _managerFee,
        uint256 _premium
    );

    event ReserveAssetAdded(
        ISetToken indexed _setToken,
        address _newReserveAsset
    );

    event ReserveAssetRemoved(
        ISetToken indexed _setToken,
        address _removedReserveAsset
    );

    event PremiumEdited(
        ISetToken indexed _setToken,
        uint256 _newPremium
    );

    event ManagerFeeEdited(
        ISetToken indexed _setToken,
        uint256 _newManagerFee,
        uint256 _index
    );

    event FeeRecipientEdited(
        ISetToken indexed _setToken,
        address _feeRecipient
    );

    /* ============ Structs ============ */

    struct NAVIssuanceSettings {
        INAVIssuanceHook managerIssuanceHook;      // Issuance hook configurations
        INAVIssuanceHook managerRedemptionHook;    // Redemption hook configurations
        address[] reserveAssets;                       // Allowed reserve assets - Must have a price enabled with the price oracle
        address feeRecipient;                          // Manager fee recipient
        uint256[2] managerFees;                        // Manager fees. 0 index is issue and 1 index is redeem fee (0.01% = 1e14, 1% = 1e16)
        uint256 maxManagerFee;                         // Maximum fee manager is allowed to set for issue and redeem
        uint256 premiumPercentage;                     // Premium percentage (0.01% = 1e14, 1% = 1e16). This premium is a buffer around oracle
                                                       // prices paid by user to the SetToken, which prevents arbitrage and oracle front running
        uint256 maxPremiumPercentage;                  // Maximum premium percentage manager is allowed to set (configured by manager)
        uint256 minSetTokenSupply;                     // Minimum SetToken supply required for issuance and redemption
                                                       // to prevent dramatic inflationary changes to the SetToken's position multiplier
    }

    struct ActionInfo {
        uint256 preFeeReserveQuantity;                 // Reserve value before fees; During issuance, represents raw quantity
                                                       // During redeem, represents post-premium value
        uint256 protocolFees;                          // Total protocol fees (direct + manager revenue share)
        uint256 managerFee;                            // Total manager fee paid in reserve asset
        uint256 netFlowQuantity;                       // When issuing, quantity of reserve asset sent to SetToken
                                                       // When redeeming, quantity of reserve asset sent to redeemer
        uint256 setTokenQuantity;                      // When issuing, quantity of SetTokens minted to mintee
                                                       // When redeeming, quantity of SetToken redeemed
        uint256 previousSetTokenSupply;                // SetToken supply prior to issue/redeem action
        uint256 newSetTokenSupply;                     // SetToken supply after issue/redeem action
        int256 newPositionMultiplier;                  // SetToken position multiplier after issue/redeem
        uint256 newReservePositionUnit;                // SetToken reserve asset position unit after issue/redeem
    }

    /* ============ State Variables ============ */

    // Wrapped ETH address
    IWETH public immutable weth;

    // Mapping of SetToken to NAV issuance settings struct
    mapping(ISetToken => NAVIssuanceSettings) public navIssuanceSettings;

    // Mapping to efficiently check a SetToken's reserve asset validity
    // SetToken => reserveAsset => isReserveAsset
    mapping(ISetToken => mapping(address => bool)) public isReserveAsset;

    /* ============ Constants ============ */

    // 0 index stores the manager fee in managerFees array, percentage charged on issue (denominated in reserve asset)
    uint256 constant internal MANAGER_ISSUE_FEE_INDEX = 0;

    // 1 index stores the manager fee percentage in managerFees array, charged on redeem
    uint256 constant internal MANAGER_REDEEM_FEE_INDEX = 1;

    // 0 index stores the manager revenue share protocol fee % on the controller, charged in the issuance function
    uint256 constant internal PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX = 0;

    // 1 index stores the manager revenue share protocol fee % on the controller, charged in the redeem function
    uint256 constant internal PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX = 1;

    // 2 index stores the direct protocol fee % on the controller, charged in the issuance function
    uint256 constant internal PROTOCOL_ISSUE_DIRECT_FEE_INDEX = 2;

    // 3 index stores the direct protocol fee % on the controller, charged in the redeem function
    uint256 constant internal PROTOCOL_REDEEM_DIRECT_FEE_INDEX = 3;

    /* ============ Constructor ============ */

    /**
     * @param _controller               Address of controller contract
     * @param _weth                     Address of wrapped eth
     */
    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {
        weth = _weth;
    }

    /* ============ External Functions ============ */

    /**
     * Deposits the allowed reserve asset into the SetToken and mints the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _reserveAsset                 Address of the reserve asset to issue with
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance
     * @param _to                           Address to mint SetToken to
     */
    function issue(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity,
        uint256 _minSetTokenReceiveQuantity,
        address _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, _reserveAsset, _reserveAssetQuantity);

        _callPreIssueHooks(_setToken, _reserveAsset, _reserveAssetQuantity, msg.sender, _to);

        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, _reserveAsset, _reserveAssetQuantity);

        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);

        _transferCollateralAndHandleFees(_setToken, IERC20(_reserveAsset), issueInfo);

        _handleIssueStateUpdates(_setToken, _reserveAsset, _to, issueInfo);
    }

    /**
     * Wraps ETH and deposits WETH if allowed into the SetToken and mints the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance
     * @param _to                           Address to mint SetToken to
     */
    function issueWithEther(
        ISetToken _setToken,
        uint256 _minSetTokenReceiveQuantity,
        address _to
    )
        external
        payable
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        weth.deposit{ value: msg.value }();

        _validateCommon(_setToken, address(weth), msg.value);

        _callPreIssueHooks(_setToken, address(weth), msg.value, msg.sender, _to);

        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, address(weth), msg.value);

        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);

        _transferWETHAndHandleFees(_setToken, issueInfo);

        _handleIssueStateUpdates(_setToken, address(weth), _to, issueInfo);
    }

    /**
     * Redeems a SetToken into a valid reserve asset representing the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address. Only valid if there are available reserve units on the SetToken.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _reserveAsset                 Address of the reserve asset to redeem with
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive
     * @param _to                           Address to redeem reserve asset to
     */
    function redeem(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity,
        uint256 _minReserveReceiveQuantity,
        address _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, _reserveAsset, _setTokenQuantity);

        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);

        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, _reserveAsset, _setTokenQuantity);

        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);

        _setToken.burn(msg.sender, _setTokenQuantity);

        // Instruct the SetToken to transfer the reserve asset back to the user
        _setToken.strictInvokeTransfer(
            _reserveAsset,
            _to,
            redeemInfo.netFlowQuantity
        );

        _handleRedemptionFees(_setToken, _reserveAsset, redeemInfo);

        _handleRedeemStateUpdates(_setToken, _reserveAsset, _to, redeemInfo);
    }

    /**
     * Redeems a SetToken into Ether (if WETH is valid) representing the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address. Only valid if there are available WETH units on the SetToken.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive
     * @param _to                           Address to redeem reserve asset to
     */
    function redeemIntoEther(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        uint256 _minReserveReceiveQuantity,
        address payable _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, address(weth), _setTokenQuantity);

        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);

        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, address(weth), _setTokenQuantity);

        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);

        _setToken.burn(msg.sender, _setTokenQuantity);

        // Instruct the SetToken to transfer WETH from SetToken to module
        _setToken.strictInvokeTransfer(
            address(weth),
            address(this),
            redeemInfo.netFlowQuantity
        );

        weth.withdraw(redeemInfo.netFlowQuantity);

        _to.transfer(redeemInfo.netFlowQuantity);

        _handleRedemptionFees(_setToken, address(weth), redeemInfo);

        _handleRedeemStateUpdates(_setToken, address(weth), _to, redeemInfo);
    }

    /**
     * SET MANAGER ONLY. Add an allowed reserve asset
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset to add
     */
    function addReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {
        require(!isReserveAsset[_setToken][_reserveAsset], "Reserve asset already exists");

        navIssuanceSettings[_setToken].reserveAssets.push(_reserveAsset);
        isReserveAsset[_setToken][_reserveAsset] = true;

        emit ReserveAssetAdded(_setToken, _reserveAsset);
    }

    /**
     * SET MANAGER ONLY. Remove a reserve asset
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset to remove
     */
    function removeReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {
        require(isReserveAsset[_setToken][_reserveAsset], "Reserve asset does not exist");

        navIssuanceSettings[_setToken].reserveAssets = navIssuanceSettings[_setToken].reserveAssets.remove(_reserveAsset);
        delete isReserveAsset[_setToken][_reserveAsset];

        emit ReserveAssetRemoved(_setToken, _reserveAsset);
    }

    /**
     * SET MANAGER ONLY. Edit the premium percentage
     *
     * @param _setToken                     Instance of the SetToken
     * @param _premiumPercentage            Premium percentage in 10e16 (e.g. 10e16 = 1%)
     */
    function editPremium(ISetToken _setToken, uint256 _premiumPercentage) external onlyManagerAndValidSet(_setToken) {
        require(_premiumPercentage <= navIssuanceSettings[_setToken].maxPremiumPercentage, "Premium must be less than maximum allowed");

        navIssuanceSettings[_setToken].premiumPercentage = _premiumPercentage;

        emit PremiumEdited(_setToken, _premiumPercentage);
    }

    /**
     * SET MANAGER ONLY. Edit manager fee
     *
     * @param _setToken                     Instance of the SetToken
     * @param _managerFeePercentage         Manager fee percentage in 10e16 (e.g. 10e16 = 1%)
     * @param _managerFeeIndex              Manager fee index. 0 index is issue fee, 1 index is redeem fee
     */
    function editManagerFee(
        ISetToken _setToken,
        uint256 _managerFeePercentage,
        uint256 _managerFeeIndex
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        require(_managerFeePercentage <= navIssuanceSettings[_setToken].maxManagerFee, "Manager fee must be less than maximum allowed");

        navIssuanceSettings[_setToken].managerFees[_managerFeeIndex] = _managerFeePercentage;

        emit ManagerFeeEdited(_setToken, _managerFeePercentage, _managerFeeIndex);
    }

    /**
     * SET MANAGER ONLY. Edit the manager fee recipient
     *
     * @param _setToken                     Instance of the SetToken
     * @param _managerFeeRecipient          Manager fee recipient
     */
    function editFeeRecipient(ISetToken _setToken, address _managerFeeRecipient) external onlyManagerAndValidSet(_setToken) {
        require(_managerFeeRecipient != address(0), "Fee recipient must not be 0 address");

        navIssuanceSettings[_setToken].feeRecipient = _managerFeeRecipient;

        emit FeeRecipientEdited(_setToken, _managerFeeRecipient);
    }

    /**
     * SET MANAGER ONLY. Initializes this module to the SetToken with hooks, allowed reserve assets,
     * fees and issuance premium. Only callable by the SetToken's manager. Hook addresses are optional.
     * Address(0) means that no hook will be called.
     *
     * @param _setToken                     Instance of the SetToken to issue
     * @param _navIssuanceSettings          NAVIssuanceSettings struct defining parameters
     */
    function initialize(
        ISetToken _setToken,
        NAVIssuanceSettings memory _navIssuanceSettings
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        require(_navIssuanceSettings.reserveAssets.length > 0, "Reserve assets must be greater than 0");
        require(_navIssuanceSettings.maxManagerFee < PreciseUnitMath.preciseUnit(), "Max manager fee must be less than 100%");
        require(_navIssuanceSettings.maxPremiumPercentage < PreciseUnitMath.preciseUnit(), "Max premium percentage must be less than 100%");
        require(_navIssuanceSettings.managerFees[0] <= _navIssuanceSettings.maxManagerFee, "Manager issue fee must be less than max");
        require(_navIssuanceSettings.managerFees[1] <= _navIssuanceSettings.maxManagerFee, "Manager redeem fee must be less than max");
        require(_navIssuanceSettings.premiumPercentage <= _navIssuanceSettings.maxPremiumPercentage, "Premium must be less than max");
        require(_navIssuanceSettings.feeRecipient != address(0), "Fee Recipient must be non-zero address.");
        // Initial mint of Set cannot use NAVIssuance since minSetTokenSupply must be > 0
        require(_navIssuanceSettings.minSetTokenSupply > 0, "Min SetToken supply must be greater than 0");

        for (uint256 i = 0; i < _navIssuanceSettings.reserveAssets.length; i++) {
            require(!isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]], "Reserve assets must be unique");
            isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]] = true;
        }

        navIssuanceSettings[_setToken] = _navIssuanceSettings;

        _setToken.initializeModule();
    }

    /**
     * Removes this module from the SetToken, via call by the SetToken. Issuance settings and
     * reserve asset states are deleted.
     */
    function removeModule() external override {
        ISetToken setToken = ISetToken(msg.sender);
        for (uint256 i = 0; i < navIssuanceSettings[setToken].reserveAssets.length; i++) {
            delete isReserveAsset[setToken][navIssuanceSettings[setToken].reserveAssets[i]];
        }

        delete navIssuanceSettings[setToken];
    }

    receive() external payable {}

    /* ============ External Getter Functions ============ */

    function getReserveAssets(ISetToken _setToken) external view returns (address[] memory) {
        return navIssuanceSettings[_setToken].reserveAssets;
    }

    function getIssuePremium(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (uint256)
    {
        return _getIssuePremium(_setToken, _reserveAsset, _reserveAssetQuantity);
    }

    function getRedeemPremium(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (uint256)
    {
        return _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);
    }

    function getManagerFee(ISetToken _setToken, uint256 _managerFeeIndex) external view returns (uint256) {
        return navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];
    }

    /**
     * Get the expected SetTokens minted to recipient on issuance
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     *
     * @return  uint256                     Expected SetTokens to be minted to recipient
     */
    function getExpectedSetTokenIssueQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (uint256)
    {
        (,, uint256 netReserveFlow) = _getFees(
            _setToken,
            _reserveAssetQuantity,
            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,
            MANAGER_ISSUE_FEE_INDEX
        );

        uint256 setTotalSupply = _setToken.totalSupply();

        return _getSetTokenMintQuantity(
            _setToken,
            _reserveAsset,
            netReserveFlow,
            setTotalSupply
        );
    }

    /**
     * Get the expected reserve asset to be redeemed
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     *
     * @return  uint256                     Expected reserve asset quantity redeemed
     */
    function getExpectedReserveRedeemQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (uint256)
    {
        uint256 preFeeReserveQuantity = _getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

        (,, uint256 netReserveFlows) = _getFees(
            _setToken,
            preFeeReserveQuantity,
            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
            MANAGER_REDEEM_FEE_INDEX
        );

        return netReserveFlows;
    }

    /**
     * Checks if issue is valid
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     *
     * @return  bool                        Returns true if issue is valid
     */
    function isIssueValid(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (bool)
    {
        uint256 setTotalSupply = _setToken.totalSupply();

    return _reserveAssetQuantity != 0
            && isReserveAsset[_setToken][_reserveAsset]
            && setTotalSupply >= navIssuanceSettings[_setToken].minSetTokenSupply;
    }

    /**
     * Checks if redeem is valid
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     *
     * @return  bool                        Returns true if redeem is valid
     */
    function isRedeemValid(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (bool)
    {
        uint256 setTotalSupply = _setToken.totalSupply();

        if (
            _setTokenQuantity == 0
            || !isReserveAsset[_setToken][_reserveAsset]
            || setTotalSupply < navIssuanceSettings[_setToken].minSetTokenSupply.add(_setTokenQuantity)
        ) {
            return false;
        } else {
            uint256 totalRedeemValue =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

            (,, uint256 expectedRedeemQuantity) = _getFees(
                _setToken,
                totalRedeemValue,
                PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
                PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
                MANAGER_REDEEM_FEE_INDEX
            );

            uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();

            return existingUnit.preciseMul(setTotalSupply) >= expectedRedeemQuantity;
        }
    }

    /* ============ Internal Functions ============ */

    function _validateCommon(ISetToken _setToken, address _reserveAsset, uint256 _quantity) internal view {
        require(_quantity > 0, "Quantity must be > 0");
        require(isReserveAsset[_setToken][_reserveAsset], "Must be valid reserve asset");
    }

    function _validateIssuanceInfo(ISetToken _setToken, uint256 _minSetTokenReceiveQuantity, ActionInfo memory _issueInfo) internal view {
        // Check that total supply is greater than min supply needed for issuance
        // Note: A min supply amount is needed to avoid division by 0 when SetToken supply is 0
        require(
            _issueInfo.previousSetTokenSupply >= navIssuanceSettings[_setToken].minSetTokenSupply,
            "Supply must be greater than minimum to enable issuance"
        );

        require(_issueInfo.setTokenQuantity >= _minSetTokenReceiveQuantity, "Must be greater than min SetToken");
    }

    function _validateRedemptionInfo(
        ISetToken _setToken,
        uint256 _minReserveReceiveQuantity,
        ActionInfo memory _redeemInfo
    )
        internal
        view
    {
        // Check that new supply is more than min supply needed for redemption
        // Note: A min supply amount is needed to avoid division by 0 when redeeming SetToken to 0
        require(
            _redeemInfo.newSetTokenSupply >= navIssuanceSettings[_setToken].minSetTokenSupply,
            "Supply must be greater than minimum to enable redemption"
        );

        require(_redeemInfo.netFlowQuantity >= _minReserveReceiveQuantity, "Must be greater than min receive reserve quantity");
    }

    function _createIssuanceInfo(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        internal
        view
        returns (ActionInfo memory)
    {
        ActionInfo memory issueInfo;

        issueInfo.previousSetTokenSupply = _setToken.totalSupply();

        issueInfo.preFeeReserveQuantity = _reserveAssetQuantity;

        (issueInfo.protocolFees, issueInfo.managerFee, issueInfo.netFlowQuantity) = _getFees(
            _setToken,
            issueInfo.preFeeReserveQuantity,
            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,
            MANAGER_ISSUE_FEE_INDEX
        );

        issueInfo.setTokenQuantity = _getSetTokenMintQuantity(
            _setToken,
            _reserveAsset,
            issueInfo.netFlowQuantity,
            issueInfo.previousSetTokenSupply
        );

        (issueInfo.newSetTokenSupply, issueInfo.newPositionMultiplier) = _getIssuePositionMultiplier(_setToken, issueInfo);

        issueInfo.newReservePositionUnit = _getIssuePositionUnit(_setToken, _reserveAsset, issueInfo);

        return issueInfo;
    }

    function _createRedemptionInfo(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        internal
        view
        returns (ActionInfo memory)
    {
        ActionInfo memory redeemInfo;

        redeemInfo.setTokenQuantity = _setTokenQuantity;

        redeemInfo.preFeeReserveQuantity =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

        (redeemInfo.protocolFees, redeemInfo.managerFee, redeemInfo.netFlowQuantity) = _getFees(
            _setToken,
            redeemInfo.preFeeReserveQuantity,
            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
            MANAGER_REDEEM_FEE_INDEX
        );

        redeemInfo.previousSetTokenSupply = _setToken.totalSupply();

        (redeemInfo.newSetTokenSupply, redeemInfo.newPositionMultiplier) = _getRedeemPositionMultiplier(_setToken, _setTokenQuantity, redeemInfo);

        redeemInfo.newReservePositionUnit = _getRedeemPositionUnit(_setToken, _reserveAsset, redeemInfo);

        return redeemInfo;
    }

    /**
     * Transfer reserve asset from user to SetToken and fees from user to appropriate fee recipients
     */
    function _transferCollateralAndHandleFees(ISetToken _setToken, IERC20 _reserveAsset, ActionInfo memory _issueInfo) internal {
        transferFrom(_reserveAsset, msg.sender, address(_setToken), _issueInfo.netFlowQuantity);

        if (_issueInfo.protocolFees > 0) {
            transferFrom(_reserveAsset, msg.sender, controller.feeRecipient(), _issueInfo.protocolFees);
        }

        if (_issueInfo.managerFee > 0) {
            transferFrom(_reserveAsset, msg.sender, navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);
        }
    }


    /**
      * Transfer WETH from module to SetToken and fees from module to appropriate fee recipients
     */
    function _transferWETHAndHandleFees(ISetToken _setToken, ActionInfo memory _issueInfo) internal {
        weth.transfer(address(_setToken), _issueInfo.netFlowQuantity);

        if (_issueInfo.protocolFees > 0) {
            weth.transfer(controller.feeRecipient(), _issueInfo.protocolFees);
        }

        if (_issueInfo.managerFee > 0) {
            weth.transfer(navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);
        }
    }

    function _handleIssueStateUpdates(
        ISetToken _setToken,
        address _reserveAsset,
        address _to,
        ActionInfo memory _issueInfo
    )
        internal
    {
        _setToken.editPositionMultiplier(_issueInfo.newPositionMultiplier);

        _setToken.editDefaultPosition(_reserveAsset, _issueInfo.newReservePositionUnit);

        _setToken.mint(_to, _issueInfo.setTokenQuantity);

        emit SetTokenNAVIssued(
            _setToken,
            msg.sender,
            _to,
            _reserveAsset,
            address(navIssuanceSettings[_setToken].managerIssuanceHook),
            _issueInfo.setTokenQuantity,
            _issueInfo.managerFee,
            _issueInfo.protocolFees
        );
    }

    function _handleRedeemStateUpdates(
        ISetToken _setToken,
        address _reserveAsset,
        address _to,
        ActionInfo memory _redeemInfo
    )
        internal
    {
        _setToken.editPositionMultiplier(_redeemInfo.newPositionMultiplier);

        _setToken.editDefaultPosition(_reserveAsset, _redeemInfo.newReservePositionUnit);

        emit SetTokenNAVRedeemed(
            _setToken,
            msg.sender,
            _to,
            _reserveAsset,
            address(navIssuanceSettings[_setToken].managerRedemptionHook),
            _redeemInfo.setTokenQuantity,
            _redeemInfo.managerFee,
            _redeemInfo.protocolFees
        );
    }

    function _handleRedemptionFees(ISetToken _setToken, address _reserveAsset, ActionInfo memory _redeemInfo) internal {
        // Instruct the SetToken to transfer protocol fee to fee recipient if there is a fee
        payProtocolFeeFromSetToken(_setToken, _reserveAsset, _redeemInfo.protocolFees);

        // Instruct the SetToken to transfer manager fee to manager fee recipient if there is a fee
        if (_redeemInfo.managerFee > 0) {
            _setToken.strictInvokeTransfer(
                _reserveAsset,
                navIssuanceSettings[_setToken].feeRecipient,
                _redeemInfo.managerFee
            );
        }
    }

    /**
     * Returns the issue premium percentage. Virtual function that can be overridden in future versions of the module
     * and can contain arbitrary logic to calculate the issuance premium.
     */
    function _getIssuePremium(
        ISetToken _setToken,
        address /* _reserveAsset */,
        uint256 /* _reserveAssetQuantity */
    )
        virtual
        internal
        view
        returns (uint256)
    {
        return navIssuanceSettings[_setToken].premiumPercentage;
    }

    /**
     * Returns the redeem premium percentage. Virtual function that can be overridden in future versions of the module
     * and can contain arbitrary logic to calculate the redemption premium.
     */
    function _getRedeemPremium(
        ISetToken _setToken,
        address /* _reserveAsset */,
        uint256 /* _setTokenQuantity */
    )
        virtual
        internal
        view
        returns (uint256)
    {
        return navIssuanceSettings[_setToken].premiumPercentage;
    }

    /**
     * Returns the fees attributed to the manager and the protocol. The fees are calculated as follows:
     *
     * ManagerFee = (manager fee % - % to protocol) * reserveAssetQuantity
     * Protocol Fee = (% manager fee share + direct fee %) * reserveAssetQuantity
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAssetQuantity         Quantity of reserve asset to calculate fees from
     * @param _protocolManagerFeeIndex      Index to pull rev share NAV Issuance fee from the Controller
     * @param _protocolDirectFeeIndex       Index to pull direct NAV issuance fee from the Controller
     * @param _managerFeeIndex              Index from NAVIssuanceSettings (0 = issue fee, 1 = redeem fee)
     *
     * @return  uint256                     Fees paid to the protocol in reserve asset
     * @return  uint256                     Fees paid to the manager in reserve asset
     * @return  uint256                     Net reserve to user net of fees
     */
    function _getFees(
        ISetToken _setToken,
        uint256 _reserveAssetQuantity,
        uint256 _protocolManagerFeeIndex,
        uint256 _protocolDirectFeeIndex,
        uint256 _managerFeeIndex
    )
        internal
        view
        returns (uint256, uint256, uint256)
    {
        (uint256 protocolFeePercentage, uint256 managerFeePercentage) = _getProtocolAndManagerFeePercentages(
            _setToken,
            _protocolManagerFeeIndex,
            _protocolDirectFeeIndex,
            _managerFeeIndex
        );

        // Calculate total notional fees
        uint256 protocolFees = protocolFeePercentage.preciseMul(_reserveAssetQuantity);
        uint256 managerFee = managerFeePercentage.preciseMul(_reserveAssetQuantity);

        uint256 netReserveFlow = _reserveAssetQuantity.sub(protocolFees).sub(managerFee);

        return (protocolFees, managerFee, netReserveFlow);
    }

    function _getProtocolAndManagerFeePercentages(
        ISetToken _setToken,
        uint256 _protocolManagerFeeIndex,
        uint256 _protocolDirectFeeIndex,
        uint256 _managerFeeIndex
    )
        internal
        view
        returns(uint256, uint256)
    {
        // Get protocol fee percentages
        uint256 protocolDirectFeePercent = controller.getModuleFee(address(this), _protocolDirectFeeIndex);
        uint256 protocolManagerShareFeePercent = controller.getModuleFee(address(this), _protocolManagerFeeIndex);
        uint256 managerFeePercent = navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];

        // Calculate revenue share split percentage
        uint256 protocolRevenueSharePercentage = protocolManagerShareFeePercent.preciseMul(managerFeePercent);
        uint256 managerRevenueSharePercentage = managerFeePercent.sub(protocolRevenueSharePercentage);
        uint256 totalProtocolFeePercentage = protocolRevenueSharePercentage.add(protocolDirectFeePercent);

        return (totalProtocolFeePercentage, managerRevenueSharePercentage);
    }

    function _getSetTokenMintQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _netReserveFlows,            // Value of reserve asset net of fees
        uint256 _setTotalSupply
    )
        internal
        view
        returns (uint256)
    {
        uint256 premiumPercentage = _getIssuePremium(_setToken, _reserveAsset, _netReserveFlows);
        uint256 premiumValue = _netReserveFlows.preciseMul(premiumPercentage);

        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (1e18)
        // Reverts if price is not found
        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);

        // Get reserve asset decimals
        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();
        uint256 normalizedTotalReserveQuantityNetFees = _netReserveFlows.preciseDiv(10 ** reserveAssetDecimals);
        uint256 normalizedTotalReserveQuantityNetFeesAndPremium = _netReserveFlows.sub(premiumValue).preciseDiv(10 ** reserveAssetDecimals);

        // Calculate SetTokens to mint to issuer
        uint256 denominator = _setTotalSupply.preciseMul(setTokenValuation).add(normalizedTotalReserveQuantityNetFees).sub(normalizedTotalReserveQuantityNetFeesAndPremium);
        return normalizedTotalReserveQuantityNetFeesAndPremium.preciseMul(_setTotalSupply).preciseDiv(denominator);
    }

    function _getRedeemReserveQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        internal
        view
        returns (uint256)
    {
        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (10e18)
        // Reverts if price is not found
        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);

        uint256 totalRedeemValueInPreciseUnits = _setTokenQuantity.preciseMul(setTokenValuation);
        // Get reserve asset decimals
        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();
        uint256 prePremiumReserveQuantity = totalRedeemValueInPreciseUnits.preciseMul(10 ** reserveAssetDecimals);

        uint256 premiumPercentage = _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);
        uint256 premiumQuantity = prePremiumReserveQuantity.preciseMulCeil(premiumPercentage);

        return prePremiumReserveQuantity.sub(premiumQuantity);
    }

    /**
     * The new position multiplier is calculated as follows:
     * inflationPercentage = (newSupply - oldSupply) / newSupply
     * newMultiplier = (1 - inflationPercentage) * positionMultiplier
     */
    function _getIssuePositionMultiplier(
        ISetToken _setToken,
        ActionInfo memory _issueInfo
    )
        internal
        view
        returns (uint256, int256)
    {
        // Calculate inflation and new position multiplier. Note: Round inflation up in order to round position multiplier down
        uint256 newTotalSupply = _issueInfo.setTokenQuantity.add(_issueInfo.previousSetTokenSupply);
        int256 newPositionMultiplier = _setToken.positionMultiplier()
            .mul(_issueInfo.previousSetTokenSupply.toInt256())
            .div(newTotalSupply.toInt256());

        return (newTotalSupply, newPositionMultiplier);
    }

    /**
     * Calculate deflation and new position multiplier. Note: Round deflation down in order to round position multiplier down
     *
     * The new position multiplier is calculated as follows:
     * deflationPercentage = (oldSupply - newSupply) / newSupply
     * newMultiplier = (1 + deflationPercentage) * positionMultiplier
     */
    function _getRedeemPositionMultiplier(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        ActionInfo memory _redeemInfo
    )
        internal
        view
        returns (uint256, int256)
    {
        uint256 newTotalSupply = _redeemInfo.previousSetTokenSupply.sub(_setTokenQuantity);
        int256 newPositionMultiplier = _setToken.positionMultiplier()
            .mul(_redeemInfo.previousSetTokenSupply.toInt256())
            .div(newTotalSupply.toInt256());

        return (newTotalSupply, newPositionMultiplier);
    }

    /**
     * The new position reserve asset unit is calculated as follows:
     * totalReserve = (oldUnit * oldSetTokenSupply) + reserveQuantity
     * newUnit = totalReserve / newSetTokenSupply
     */
    function _getIssuePositionUnit(
        ISetToken _setToken,
        address _reserveAsset,
        ActionInfo memory _issueInfo
    )
        internal
        view
        returns (uint256)
    {
        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();
        uint256 totalReserve = existingUnit
            .preciseMul(_issueInfo.previousSetTokenSupply)
            .add(_issueInfo.netFlowQuantity);

        return totalReserve.preciseDiv(_issueInfo.newSetTokenSupply);
    }

    /**
     * The new position reserve asset unit is calculated as follows:
     * totalReserve = (oldUnit * oldSetTokenSupply) - reserveQuantityToSendOut
     * newUnit = totalReserve / newSetTokenSupply
     */
    function _getRedeemPositionUnit(
        ISetToken _setToken,
        address _reserveAsset,
        ActionInfo memory _redeemInfo
    )
        internal
        view
        returns (uint256)
    {
        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();
        uint256 totalExistingUnits = existingUnit.preciseMul(_redeemInfo.previousSetTokenSupply);

        uint256 outflow = _redeemInfo.netFlowQuantity.add(_redeemInfo.protocolFees).add(_redeemInfo.managerFee);

        // Require withdrawable quantity is greater than existing collateral
        require(totalExistingUnits >= outflow, "Must be greater than total available collateral");

        return totalExistingUnits.sub(outflow).preciseDiv(_redeemInfo.newSetTokenSupply);
    }

    /**
     * If a pre-issue hook has been configured, call the external-protocol contract. Pre-issue hook logic
     * can contain arbitrary logic including validations, external function calls, etc.
     */
    function _callPreIssueHooks(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity,
        address _caller,
        address _to
    )
        internal
    {
        INAVIssuanceHook preIssueHook = navIssuanceSettings[_setToken].managerIssuanceHook;
        if (address(preIssueHook) != address(0)) {
            preIssueHook.invokePreIssueHook(_setToken, _reserveAsset, _reserveAssetQuantity, _caller, _to);
        }
    }

    /**
     * If a pre-redeem hook has been configured, call the external-protocol contract.
     */
    function _callPreRedeemHooks(ISetToken _setToken, uint256 _setQuantity, address _caller, address _to) internal {
        INAVIssuanceHook preRedeemHook = navIssuanceSettings[_setToken].managerRedemptionHook;
        if (address(preRedeemHook) != address(0)) {
            preRedeemHook.invokePreRedeemHook(_setToken, _setQuantity, _caller, _to);
        }
    }
}.]

Here is a conversation between two roles: Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: /*
    Copyright 2020 Set Labs Inc.
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    SPDX-License-Identifier: Apache License, Version 2.0
*/
pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";
import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";
import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";
import { SignedSafeMath } from "@openzeppelin/contracts/math/SignedSafeMath.sol";
import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";
import { IController } from "../../interfaces/IController.sol";
import { INAVIssuanceHook } from "../../interfaces/INAVIssuanceHook.sol";
import { Invoke } from "../lib/Invoke.sol";
import { ISetToken } from "../../interfaces/ISetToken.sol";
import { IWETH } from "../../interfaces/external/IWETH.sol";
import { ModuleBase } from "../lib/ModuleBase.sol";
import { Position } from "../lib/Position.sol";
import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";
import { ResourceIdentifier } from "../lib/ResourceIdentifier.sol";

/**
 * @title NavIssuanceModule
 * @author Set Protocol
 *
 * Module that enables issuance and redemption with any valid ERC20 token or ETH if allowed by the manager. Sender receives
 * a proportional amount of SetTokens on issuance or ERC20 token on redemption based on the calculated net asset value using
 * oracle prices. Manager is able to enforce a premium / discount on issuance / redemption to avoid arbitrage and front
 * running when relying on oracle prices. Managers can charge a fee (denominated in reserve asset).
 */
contract NavIssuanceModule is ModuleBase, ReentrancyGuard {
    using AddressArrayUtils for address[];
    using Invoke for ISetToken;
    using Position for ISetToken;
    using PreciseUnitMath for uint256;
    using PreciseUnitMath for int256;
    using ResourceIdentifier for IController;
    using SafeMath for uint256;
    using SafeCast for int256;
    using SafeCast for uint256;
    using SignedSafeMath for int256;
    /* ============ Events ============ */
    event SetTokenNAVIssued(
        ISetToken indexed _setToken,
        address _issuer,
        address _to,
        address _reserveAsset,
        address _hookContract,
        uint256 _setTokenQuantity,
        uint256 _managerFee,
        uint256 _premium
    );
    event SetTokenNAVRedeemed(
        ISetToken indexed _setToken,
        address _redeemer,
        address _to,
        address _reserveAsset,
        address _hookContract,
        uint256 _setTokenQuantity,
        uint256 _managerFee,
        uint256 _premium
    );
    event ReserveAssetAdded(
        ISetToken indexed _setToken,
        address _newReserveAsset
    );
    event ReserveAssetRemoved(
        ISetToken indexed _setToken,
        address _removedReserveAsset
    );
    event PremiumEdited(
        ISetToken indexed _setToken,
        uint256 _newPremium
    );
    event ManagerFeeEdited(
        ISetToken indexed _setToken,
        uint256 _newManagerFee,
        uint256 _index
    );
    event FeeRecipientEdited(
        ISetToken indexed _setToken,
        address _feeRecipient
    );
    /* ============ Structs ============ */
    struct NAVIssuanceSettings {
        INAVIssuanceHook managerIssuanceHook;      // Issuance hook configurations
        INAVIssuanceHook managerRedemptionHook;    // Redemption hook configurations
        address[] reserveAssets;                       // Allowed reserve assets - Must have a price enabled with the price oracle
        address feeRecipient;                          // Manager fee recipient
        uint256[2] managerFees;                        // Manager fees. 0 index is issue and 1 index is redeem fee (0.01% = 1e14, 1% = 1e16)
        uint256 maxManagerFee;                         // Maximum fee manager is allowed to set for issue and redeem
        uint256 premiumPercentage;                     // Premium percentage (0.01% = 1e14, 1% = 1e16). This premium is a buffer around oracle
                                                       // prices paid by user to the SetToken, which prevents arbitrage and oracle front running
        uint256 maxPremiumPercentage;                  // Maximum premium percentage manager is allowed to set (configured by manager)
        uint256 minSetTokenSupply;                     // Minimum SetToken supply required for issuance and redemption
                                                       // to prevent dramatic inflationary changes to the SetToken's position multiplier
    }
    struct ActionInfo {
        uint256 preFeeReserveQuantity;                 // Reserve value before fees; During issuance, represents raw quantity
                                                       // During redeem, represents post-premium value
        uint256 protocolFees;                          // Total protocol fees (direct + manager revenue share)
        uint256 managerFee;                            // Total manager fee paid in reserve asset
        uint256 netFlowQuantity;                       // When issuing, quantity of reserve asset sent to SetToken
                                                       // When redeeming, quantity of reserve asset sent to redeemer
        uint256 setTokenQuantity;                      // When issuing, quantity of SetTokens minted to mintee
                                                       // When redeeming, quantity of SetToken redeemed
        uint256 previousSetTokenSupply;                // SetToken supply prior to issue/redeem action
        uint256 newSetTokenSupply;                     // SetToken supply after issue/redeem action
        int256 newPositionMultiplier;                  // SetToken position multiplier after issue/redeem
        uint256 newReservePositionUnit;                // SetToken reserve asset position unit after issue/redeem
    }
    /* ============ State Variables ============ */
    // Wrapped ETH address
    IWETH public immutable weth;
    // Mapping of SetToken to NAV issuance settings struct
    mapping(ISetToken => NAVIssuanceSettings) public navIssuanceSettings;
    // Mapping to efficiently check a SetToken's reserve asset validity
    // SetToken => reserveAsset => isReserveAsset
    mapping(ISetToken => mapping(address => bool)) public isReserveAsset;
    /* ============ Constants ============ */
    // 0 index stores the manager fee in managerFees array, percentage charged on issue (denominated in reserve asset)
    uint256 constant internal MANAGER_ISSUE_FEE_INDEX = 0;
    // 1 index stores the manager fee percentage in managerFees array, charged on redeem
    uint256 constant internal MANAGER_REDEEM_FEE_INDEX = 1;
    // 0 index stores the manager revenue share protocol fee % on the controller, charged in the issuance function
    uint256 constant internal PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX = 0;
    // 1 index stores the manager revenue share protocol fee % on the controller, charged in the redeem function
    uint256 constant internal PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX = 1;
    // 2 index stores the direct protocol fee % on the controller, charged in the issuance function
    uint256 constant internal PROTOCOL_ISSUE_DIRECT_FEE_INDEX = 2;
    // 3 index stores the direct protocol fee % on the controller, charged in the redeem function
    uint256 constant internal PROTOCOL_REDEEM_DIRECT_FEE_INDEX = 3;
    /* ============ Constructor ============ */
    /**
     * @param _controller               Address of controller contract
     * @param _weth                     Address of wrapped eth
     */
    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {
        weth = _weth;
    }
    /* ============ External Functions ============ */
    /**
     * Deposits the allowed reserve asset into the SetToken and mints the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _reserveAsset                 Address of the reserve asset to issue with
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance
     * @param _to                           Address to mint SetToken to
     */
    function issue(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity,
        uint256 _minSetTokenReceiveQuantity,
        address _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, _reserveAsset, _reserveAssetQuantity);
        _callPreIssueHooks(_setToken, _reserveAsset, _reserveAssetQuantity, msg.sender, _to);
        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, _reserveAsset, _reserveAssetQuantity);
        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);
        _transferCollateralAndHandleFees(_setToken, IERC20(_reserveAsset), issueInfo);
        _handleIssueStateUpdates(_setToken, _reserveAsset, _to, issueInfo);
    }
    /**
     * Wraps ETH and deposits WETH if allowed into the SetToken and mints the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance
     * @param _to                           Address to mint SetToken to
     */
    function issueWithEther(
        ISetToken _setToken,
        uint256 _minSetTokenReceiveQuantity,
        address _to
    )
        external
        payable
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        weth.deposit{ value: msg.value }();
        _validateCommon(_setToken, address(weth), msg.value);
        _callPreIssueHooks(_setToken, address(weth), msg.value, msg.sender, _to);
        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, address(weth), msg.value);
        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);
        _transferWETHAndHandleFees(_setToken, issueInfo);
        _handleIssueStateUpdates(_setToken, address(weth), _to, issueInfo);
    }
    /**
     * Redeems a SetToken into a valid reserve asset representing the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address. Only valid if there are available reserve units on the SetToken.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _reserveAsset                 Address of the reserve asset to redeem with
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive
     * @param _to                           Address to redeem reserve asset to
     */
    function redeem(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity,
        uint256 _minReserveReceiveQuantity,
        address _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, _reserveAsset, _setTokenQuantity);
        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);
        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, _reserveAsset, _setTokenQuantity);
        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);
        _setToken.burn(msg.sender, _setTokenQuantity);
        // Instruct the SetToken to transfer the reserve asset back to the user
        _setToken.strictInvokeTransfer(
            _reserveAsset,
            _to,
            redeemInfo.netFlowQuantity
        );
        _handleRedemptionFees(_setToken, _reserveAsset, redeemInfo);
        _handleRedeemStateUpdates(_setToken, _reserveAsset, _to, redeemInfo);
    }
    /**
     * Redeems a SetToken into Ether (if WETH is valid) representing the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address. Only valid if there are available WETH units on the SetToken.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive
     * @param _to                           Address to redeem reserve asset to
     */
    function redeemIntoEther(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        uint256 _minReserveReceiveQuantity,
        address payable _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, address(weth), _setTokenQuantity);
        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);
        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, address(weth), _setTokenQuantity);
        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);
        _setToken.burn(msg.sender, _setTokenQuantity);
        // Instruct the SetToken to transfer WETH from SetToken to module
        _setToken.strictInvokeTransfer(
            address(weth),
            address(this),
            redeemInfo.netFlowQuantity
        );
        weth.withdraw(redeemInfo.netFlowQuantity);
        _to.transfer(redeemInfo.netFlowQuantity);
        _handleRedemptionFees(_setToken, address(weth), redeemInfo);
        _handleRedeemStateUpdates(_setToken, address(weth), _to, redeemInfo);
    }
    /**
     * SET MANAGER ONLY. Add an allowed reserve asset
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset to add
     */
    function addReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {
        require(!isReserveAsset[_setToken][_reserveAsset], "Reserve asset already exists");
        navIssuanceSettings[_setToken].reserveAssets.push(_reserveAsset);
        isReserveAsset[_setToken][_reserveAsset] = true;
        emit ReserveAssetAdded(_setToken, _reserveAsset);
    }
    /**
     * SET MANAGER ONLY. Remove a reserve asset
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset to remove
     */
    function removeReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {
        require(isReserveAsset[_setToken][_reserveAsset], "Reserve asset does not exist");
        navIssuanceSettings[_setToken].reserveAssets = navIssuanceSettings[_setToken].reserveAssets.remove(_reserveAsset);
        delete isReserveAsset[_setToken][_reserveAsset];
        emit ReserveAssetRemoved(_setToken, _reserveAsset);
    }
    /**
     * SET MANAGER ONLY. Edit the premium percentage
     *
     * @param _setToken                     Instance of the SetToken
     * @param _premiumPercentage            Premium percentage in 10e16 (e.g. 10e16 = 1%)
     */
    function editPremium(ISetToken _setToken, uint256 _premiumPercentage) external onlyManagerAndValidSet(_setToken) {
        require(_premiumPercentage <= navIssuanceSettings[_setToken].maxPremiumPercentage, "Premium must be less than maximum allowed");
        navIssuanceSettings[_setToken].premiumPercentage = _premiumPercentage;
        emit PremiumEdited(_setToken, _premiumPercentage);
    }
    /**
     * SET MANAGER ONLY. Edit manager fee
     *
     * @param _setToken                     Instance of the SetToken
     * @param _managerFeePercentage         Manager fee percentage in 10e16 (e.g. 10e16 = 1%)
     * @param _managerFeeIndex              Manager fee index. 0 index is issue fee, 1 index is redeem fee
     */
    function editManagerFee(
        ISetToken _setToken,
        uint256 _managerFeePercentage,
        uint256 _managerFeeIndex
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        require(_managerFeePercentage <= navIssuanceSettings[_setToken].maxManagerFee, "Manager fee must be less than maximum allowed");
        navIssuanceSettings[_setToken].managerFees[_managerFeeIndex] = _managerFeePercentage;
        emit ManagerFeeEdited(_setToken, _managerFeePercentage, _managerFeeIndex);
    }
    /**
     * SET MANAGER ONLY. Edit the manager fee recipient
     *
     * @param _setToken                     Instance of the SetToken
     * @param _managerFeeRecipient          Manager fee recipient
     */
    function editFeeRecipient(ISetToken _setToken, address _managerFeeRecipient) external onlyManagerAndValidSet(_setToken) {
        require(_managerFeeRecipient != address(0), "Fee recipient must not be 0 address");
        navIssuanceSettings[_setToken].feeRecipient = _managerFeeRecipient;
        emit FeeRecipientEdited(_setToken, _managerFeeRecipient);
    }
    /**
     * SET MANAGER ONLY. Initializes this module to the SetToken with hooks, allowed reserve assets,
     * fees and issuance premium. Only callable by the SetToken's manager. Hook addresses are optional.
     * Address(0) means that no hook will be called.
     *
     * @param _setToken                     Instance of the SetToken to issue
     * @param _navIssuanceSettings          NAVIssuanceSettings struct defining parameters
     */
    function initialize(
        ISetToken _setToken,
        NAVIssuanceSettings memory _navIssuanceSettings
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        require(_navIssuanceSettings.reserveAssets.length > 0, "Reserve assets must be greater than 0");
        require(_navIssuanceSettings.maxManagerFee < PreciseUnitMath.preciseUnit(), "Max manager fee must be less than 100%");
        require(_navIssuanceSettings.maxPremiumPercentage < PreciseUnitMath.preciseUnit(), "Max premium percentage must be less than 100%");
        require(_navIssuanceSettings.managerFees[0] <= _navIssuanceSettings.maxManagerFee, "Manager issue fee must be less than max");
        require(_navIssuanceSettings.managerFees[1] <= _navIssuanceSettings.maxManagerFee, "Manager redeem fee must be less than max");
        require(_navIssuanceSettings.premiumPercentage <= _navIssuanceSettings.maxPremiumPercentage, "Premium must be less than max");
        require(_navIssuanceSettings.feeRecipient != address(0), "Fee Recipient must be non-zero address.");
        // Initial mint of Set cannot use NAVIssuance since minSetTokenSupply must be > 0
        require(_navIssuanceSettings.minSetTokenSupply > 0, "Min SetToken supply must be greater than 0");
        for (uint256 i = 0; i < _navIssuanceSettings.reserveAssets.length; i++) {
            require(!isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]], "Reserve assets must be unique");
            isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]] = true;
        }
        navIssuanceSettings[_setToken] = _navIssuanceSettings;
        _setToken.initializeModule();
    }
    /**
     * Removes this module from the SetToken, via call by the SetToken. Issuance settings and
     * reserve asset states are deleted.
     */
    function removeModule() external override {
        ISetToken setToken = ISetToken(msg.sender);
        for (uint256 i = 0; i < navIssuanceSettings[setToken].reserveAssets.length; i++) {
            delete isReserveAsset[setToken][navIssuanceSettings[setToken].reserveAssets[i]];
        }
        delete navIssuanceSettings[setToken];
    }
    receive() external payable {}
    /* ============ External Getter Functions ============ */
    function getReserveAssets(ISetToken _setToken) external view returns (address[] memory) {
        return navIssuanceSettings[_setToken].reserveAssets;
    }
    function getIssuePremium(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (uint256)
    {
        return _getIssuePremium(_setToken, _reserveAsset, _reserveAssetQuantity);
    }
    function getRedeemPremium(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (uint256)
    {
        return _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);
    }
    function getManagerFee(ISetToken _setToken, uint256 _managerFeeIndex) external view returns (uint256) {
        return navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];
    }
    /**
     * Get the expected SetTokens minted to recipient on issuance
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     *
     * @return  uint256                     Expected SetTokens to be minted to recipient
     */
    function getExpectedSetTokenIssueQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (uint256)
    {
        (,, uint256 netReserveFlow) = _getFees(
            _setToken,
            _reserveAssetQuantity,
            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,
            MANAGER_ISSUE_FEE_INDEX
        );
        uint256 setTotalSupply = _setToken.totalSupply();
        return _getSetTokenMintQuantity(
            _setToken,
            _reserveAsset,
            netReserveFlow,
            setTotalSupply
        );
    }
    /**
     * Get the expected reserve asset to be redeemed
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     *
     * @return  uint256                     Expected reserve asset quantity redeemed
     */
    function getExpectedReserveRedeemQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (uint256)
    {
        uint256 preFeeReserveQuantity = _getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);
        (,, uint256 netReserveFlows) = _getFees(
            _setToken,
            preFeeReserveQuantity,
            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
            MANAGER_REDEEM_FEE_INDEX
        );
        return netReserveFlows;
    }
    /**
     * Checks if issue is valid
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     *
     * @return  bool                        Returns true if issue is valid
     */
    function isIssueValid(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (bool)
    {
        uint256 setTotalSupply = _setToken.totalSupply();
    return _reserveAssetQuantity != 0
            && isReserveAsset[_setToken][_reserveAsset]
            && setTotalSupply >= navIssuanceSettings[_setToken].minSetTokenSupply;
    }
    /**
     * Checks if redeem is valid
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     *
     * @return  bool                        Returns true if redeem is valid
     */
    function isRedeemValid(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (bool)
    {
        uint256 setTotalSupply = _setToken.totalSupply();
        if (
            _setTokenQuantity == 0
            || !isReserveAsset[_setToken][_reserveAsset]
            || setTotalSupply < navIssuanceSettings[_setToken].minSetTokenSupply.add(_setTokenQuantity)
        ) {
            return false;
        } else {
            uint256 totalRedeemValue =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);
            (,, uint256 expectedRedeemQuantity) = _getFees(
                _setToken,
                totalRedeemValue,
                PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
                PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
                MANAGER_REDEEM_FEE_INDEX
            );
            uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();
            return existingUnit.preciseMul(setTotalSupply) >= expectedRedeemQuantity;
        }
    }
    /* ============ Internal Functions ============ */
    function _validateCommon(ISetToken _setToken, address _reserveAsset, uint256 _quantity) internal view {
        require(_quantity > 0, "Quantity must be > 0");
        require(isReserveAsset[_setToken][_reserveAsset], "Must be valid reserve asset");
    }
    function _validateIssuanceInfo(ISetToken _setToken, uint256 _minSetTokenReceiveQuantity, ActionInfo memory _issueInfo) internal view {
        // Check that total supply is greater than min supply needed for issuance
        // Note: A min supply amount is needed to avoid division by 0 when SetToken supply is 0
        require(
            _issueInfo.previousSetTokenSupply >= navIssuanceSettings[_setToken].minSetTokenSupply,
            "Supply must be greater than minimum to enable issuance"
        );
        require(_issueInfo.setTokenQuantity >= _minSetTokenReceiveQuantity, "Must be greater than min SetToken");
    }
    function _validateRedemptionInfo(
        ISetToken _setToken,
        uint256 _minReserveReceiveQuantity,
        ActionInfo memory _redeemInfo
    )
        internal
        view
    {
        // Check that new supply is more than min supply needed for redemption
        // Note: A min supply amount is needed to avoid division by 0 when redeeming SetToken to 0
        require(
            _redeemInfo.newSetTokenSupply >= navIssuanceSettings[_setToken].minSetTokenSupply,
            "Supply must be greater than minimum to enable redemption"
        );
        require(_redeemInfo.netFlowQuantity >= _minReserveReceiveQuantity, "Must be greater than min receive reserve quantity");
    }
    function _createIssuanceInfo(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        internal
        view
        returns (ActionInfo memory)
    {
        ActionInfo memory issueInfo;
        issueInfo.previousSetTokenSupply = _setToken.totalSupply();
        issueInfo.preFeeReserveQuantity = _reserveAssetQuantity;
        (issueInfo.protocolFees, issueInfo.managerFee, issueInfo.netFlowQuantity) = _getFees(
            _setToken,
            issueInfo.preFeeReserveQuantity,
            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,
            MANAGER_ISSUE_FEE_INDEX
        );
        issueInfo.setTokenQuantity = _getSetTokenMintQuantity(
            _setToken,
            _reserveAsset,
            issueInfo.netFlowQuantity,
            issueInfo.previousSetTokenSupply
        );
        (issueInfo.newSetTokenSupply, issueInfo.newPositionMultiplier) = _getIssuePositionMultiplier(_setToken, issueInfo);
        issueInfo.newReservePositionUnit = _getIssuePositionUnit(_setToken, _reserveAsset, issueInfo);
        return issueInfo;
    }
    function _createRedemptionInfo(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        internal
        view
        returns (ActionInfo memory)
    {
        ActionInfo memory redeemInfo;
        redeemInfo.setTokenQuantity = _setTokenQuantity;
        redeemInfo.preFeeReserveQuantity =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);
        (redeemInfo.protocolFees, redeemInfo.managerFee, redeemInfo.netFlowQuantity) = _getFees(
            _setToken,
            redeemInfo.preFeeReserveQuantity,
            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
            MANAGER_REDEEM_FEE_INDEX
        );
        redeemInfo.previousSetTokenSupply = _setToken.totalSupply();
        (redeemInfo.newSetTokenSupply, redeemInfo.newPositionMultiplier) = _getRedeemPositionMultiplier(_setToken, _setTokenQuantity, redeemInfo);
        redeemInfo.newReservePositionUnit = _getRedeemPositionUnit(_setToken, _reserveAsset, redeemInfo);
        return redeemInfo;
    }
    /**
     * Transfer reserve asset from user to SetToken and fees from user to appropriate fee recipients
     */
    function _transferCollateralAndHandleFees(ISetToken _setToken, IERC20 _reserveAsset, ActionInfo memory _issueInfo) internal {
        transferFrom(_reserveAsset, msg.sender, address(_setToken), _issueInfo.netFlowQuantity);
        if (_issueInfo.protocolFees > 0) {
            transferFrom(_reserveAsset, msg.sender, controller.feeRecipient(), _issueInfo.protocolFees);
        }
        if (_issueInfo.managerFee > 0) {
            transferFrom(_reserveAsset, msg.sender, navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);
        }
    }

    /**
      * Transfer WETH from module to SetToken and fees from module to appropriate fee recipients
     */
    function _transferWETHAndHandleFees(ISetToken _setToken, ActionInfo memory _issueInfo) internal {
        weth.transfer(address(_setToken), _issueInfo.netFlowQuantity);
        if (_issueInfo.protocolFees > 0) {
            weth.transfer(controller.feeRecipient(), _issueInfo.protocolFees);
        }
        if (_issueInfo.managerFee > 0) {
            weth.transfer(navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);
        }
    }
    function _handleIssueStateUpdates(
        ISetToken _setToken,
        address _reserveAsset,
        address _to,
        ActionInfo memory _issueInfo
    )
        internal
    {
        _setToken.editPositionMultiplier(_issueInfo.newPositionMultiplier);
        _setToken.editDefaultPosition(_reserveAsset, _issueInfo.newReservePositionUnit);
        _setToken.mint(_to, _issueInfo.setTokenQuantity);
        emit SetTokenNAVIssued(
            _setToken,
            msg.sender,
            _to,
            _reserveAsset,
            address(navIssuanceSettings[_setToken].managerIssuanceHook),
            _issueInfo.setTokenQuantity,
            _issueInfo.managerFee,
            _issueInfo.protocolFees
        );
    }
    function _handleRedeemStateUpdates(
        ISetToken _setToken,
        address _reserveAsset,
        address _to,
        ActionInfo memory _redeemInfo
    )
        internal
    {
        _setToken.editPositionMultiplier(_redeemInfo.newPositionMultiplier);
        _setToken.editDefaultPosition(_reserveAsset, _redeemInfo.newReservePositionUnit);
        emit SetTokenNAVRedeemed(
            _setToken,
            msg.sender,
            _to,
            _reserveAsset,
            address(navIssuanceSettings[_setToken].managerRedemptionHook),
            _redeemInfo.setTokenQuantity,
            _redeemInfo.managerFee,
            _redeemInfo.protocolFees
        );
    }
    function _handleRedemptionFees(ISetToken _setToken, address _reserveAsset, ActionInfo memory _redeemInfo) internal {
        // Instruct the SetToken to transfer protocol fee to fee recipient if there is a fee
        payProtocolFeeFromSetToken(_setToken, _reserveAsset, _redeemInfo.protocolFees);
        // Instruct the SetToken to transfer manager fee to manager fee recipient if there is a fee
        if (_redeemInfo.managerFee > 0) {
            _setToken.strictInvokeTransfer(
                _reserveAsset,
                navIssuanceSettings[_setToken].feeRecipient,
                _redeemInfo.managerFee
            );
        }
    }
    /**
     * Returns the issue premium percentage. Virtual function that can be overridden in future versions of the module
     * and can contain arbitrary logic to calculate the issuance premium.
     */
    function _getIssuePremium(
        ISetToken _setToken,
        address /* _reserveAsset */,
        uint256 /* _reserveAssetQuantity */
    )
        virtual
        internal
        view
        returns (uint256)
    {
        return navIssuanceSettings[_setToken].premiumPercentage;
    }
    /**
     * Returns the redeem premium percentage. Virtual function that can be overridden in future versions of the module
     * and can contain arbitrary logic to calculate the redemption premium.
     */
    function _getRedeemPremium(
        ISetToken _setToken,
        address /* _reserveAsset */,
        uint256 /* _setTokenQuantity */
    )
        virtual
        internal
        view
        returns (uint256)
    {
        return navIssuanceSettings[_setToken].premiumPercentage;
    }
    /**
     * Returns the fees attributed to the manager and the protocol. The fees are calculated as follows:
     *
     * ManagerFee = (manager fee % - % to protocol) * reserveAssetQuantity
     * Protocol Fee = (% manager fee share + direct fee %) * reserveAssetQuantity
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAssetQuantity         Quantity of reserve asset to calculate fees from
     * @param _protocolManagerFeeIndex      Index to pull rev share NAV Issuance fee from the Controller
     * @param _protocolDirectFeeIndex       Index to pull direct NAV issuance fee from the Controller
     * @param _managerFeeIndex              Index from NAVIssuanceSettings (0 = issue fee, 1 = redeem fee)
     *
     * @return  uint256                     Fees paid to the protocol in reserve asset
     * @return  uint256                     Fees paid to the manager in reserve asset
     * @return  uint256                     Net reserve to user net of fees
     */
    function _getFees(
        ISetToken _setToken,
        uint256 _reserveAssetQuantity,
        uint256 _protocolManagerFeeIndex,
        uint256 _protocolDirectFeeIndex,
        uint256 _managerFeeIndex
    )
        internal
        view
        returns (uint256, uint256, uint256)
    {
        (uint256 protocolFeePercentage, uint256 managerFeePercentage) = _getProtocolAndManagerFeePercentages(
            _setToken,
            _protocolManagerFeeIndex,
            _protocolDirectFeeIndex,
            _managerFeeIndex
        );
        // Calculate total notional fees
        uint256 protocolFees = protocolFeePercentage.preciseMul(_reserveAssetQuantity);
        uint256 managerFee = managerFeePercentage.preciseMul(_reserveAssetQuantity);
        uint256 netReserveFlow = _reserveAssetQuantity.sub(protocolFees).sub(managerFee);
        return (protocolFees, managerFee, netReserveFlow);
    }
    function _getProtocolAndManagerFeePercentages(
        ISetToken _setToken,
        uint256 _protocolManagerFeeIndex,
        uint256 _protocolDirectFeeIndex,
        uint256 _managerFeeIndex
    )
        internal
        view
        returns(uint256, uint256)
    {
        // Get protocol fee percentages
        uint256 protocolDirectFeePercent = controller.getModuleFee(address(this), _protocolDirectFeeIndex);
        uint256 protocolManagerShareFeePercent = controller.getModuleFee(address(this), _protocolManagerFeeIndex);
        uint256 managerFeePercent = navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];
        // Calculate revenue share split percentage
        uint256 protocolRevenueSharePercentage = protocolManagerShareFeePercent.preciseMul(managerFeePercent);
        uint256 managerRevenueSharePercentage = managerFeePercent.sub(protocolRevenueSharePercentage);
        uint256 totalProtocolFeePercentage = protocolRevenueSharePercentage.add(protocolDirectFeePercent);
        return (totalProtocolFeePercentage, managerRevenueSharePercentage);
    }
    function _getSetTokenMintQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _netReserveFlows,            // Value of reserve asset net of fees
        uint256 _setTotalSupply
    )
        internal
        view
        returns (uint256)
    {
        uint256 premiumPercentage = _getIssuePremium(_setToken, _reserveAsset, _netReserveFlows);
        uint256 premiumValue = _netReserveFlows.preciseMul(premiumPercentage);
        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (1e18)
        // Reverts if price is not found
        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);
        // Get reserve asset decimals
        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();
        uint256 normalizedTotalReserveQuantityNetFees = _netReserveFlows.preciseDiv(10 ** reserveAssetDecimals);
        uint256 normalizedTotalReserveQuantityNetFeesAndPremium = _netReserveFlows.sub(premiumValue).preciseDiv(10 ** reserveAssetDecimals);
        // Calculate SetTokens to mint to issuer
        uint256 denominator = _setTotalSupply.preciseMul(setTokenValuation).add(normalizedTotalReserveQuantityNetFees).sub(normalizedTotalReserveQuantityNetFeesAndPremium);
        return normalizedTotalReserveQuantityNetFeesAndPremium.preciseMul(_setTotalSupply).preciseDiv(denominator);
    }
    function _getRedeemReserveQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        internal
        view
        returns (uint256)
    {
        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (10e18)
        // Reverts if price is not found
        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);
        uint256 totalRedeemValueInPreciseUnits = _setTokenQuantity.preciseMul(setTokenValuation);
        // Get reserve asset decimals
        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();
        uint256 prePremiumReserveQuantity = totalRedeemValueInPreciseUnits.preciseMul(10 ** reserveAssetDecimals);
        uint256 premiumPercentage = _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);
        uint256 premiumQuantity = prePremiumReserveQuantity.preciseMulCeil(premiumPercentage);
        return prePremiumReserveQuantity.sub(premiumQuantity);
    }
    /**
     * The new position multiplier is calculated as follows:
     * inflationPercentage = (newSupply - oldSupply) / newSupply
     * newMultiplier = (1 - inflationPercentage) * positionMultiplier
     */
    function _getIssuePositionMultiplier(
        ISetToken _setToken,
        ActionInfo memory _issueInfo
    )
        internal
        view
        returns (uint256, int256)
    {
        // Calculate inflation and new position multiplier. Note: Round inflation up in order to round position multiplier down
        uint256 newTotalSupply = _issueInfo.setTokenQuantity.add(_issueInfo.previousSetTokenSupply);
        int256 newPositionMultiplier = _setToken.positionMultiplier()
            .mul(_issueInfo.previousSetTokenSupply.toInt256())
            .div(newTotalSupply.toInt256());
        return (newTotalSupply, newPositionMultiplier);
    }
    /**
     * Calculate deflation and new position multiplier. Note: Round deflation down in order to round position multiplier down
     *
     * The new position multiplier is calculated as follows:
     * deflationPercentage = (oldSupply - newSupply) / newSupply
     * newMultiplier = (1 + deflationPercentage) * positionMultiplier
     */
    function _getRedeemPositionMultiplier(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        ActionInfo memory _redeemInfo
    )
        internal
        view
        returns (uint256, int256)
    {
        uint256 newTotalSupply = _redeemInfo.previousSetTokenSupply.sub(_setTokenQuantity);
        int256 newPositionMultiplier = _setToken.positionMultiplier()
            .mul(_redeemInfo.previousSetTokenSupply.toInt256())
            .div(newTotalSupply.toInt256());
        return (newTotalSupply, newPositionMultiplier);
    }
    /**
     * The new position reserve asset unit is calculated as follows:
     * totalReserve = (oldUnit * oldSetTokenSupply) + reserveQuantity
     * newUnit = totalReserve / newSetTokenSupply
     */
    function _getIssuePositionUnit(
        ISetToken _setToken,
        address _reserveAsset,
        ActionInfo memory _issueInfo
    )
        internal
        view
        returns (uint256)
    {
        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();
        uint256 totalReserve = existingUnit
            .preciseMul(_issueInfo.previousSetTokenSupply)
            .add(_issueInfo.netFlowQuantity);
        return totalReserve.preciseDiv(_issueInfo.newSetTokenSupply);
    }
    /**
     * The new position reserve asset unit is calculated as follows:
     * totalReserve = (oldUnit * oldSetTokenSupply) - reserveQuantityToSendOut
     * newUnit = totalReserve / newSetTokenSupply
     */
    function _getRedeemPositionUnit(
        ISetToken _setToken,
        address _reserveAsset,
        ActionInfo memory _redeemInfo
    )
        internal
        view
        returns (uint256)
    {
        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();
        uint256 totalExistingUnits = existingUnit.preciseMul(_redeemInfo.previousSetTokenSupply);
        uint256 outflow = _redeemInfo.netFlowQuantity.add(_redeemInfo.protocolFees).add(_redeemInfo.managerFee);
        // Require withdrawable quantity is greater than existing collateral
        require(totalExistingUnits >= outflow, "Must be greater than total available collateral");
        return totalExistingUnits.sub(outflow).preciseDiv(_redeemInfo.newSetTokenSupply);
    }
    /**
     * If a pre-issue hook has been configured, call the external-protocol contract. Pre-issue hook logic
     * can contain arbitrary logic including validations, external function calls, etc.
     */
    function _callPreIssueHooks(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity,
        address _caller,
        address _to
    )
        internal
    {
        INAVIssuanceHook preIssueHook = navIssuanceSettings[_setToken].managerIssuanceHook;
        if (address(preIssueHook) != address(0)) {
            preIssueHook.invokePreIssueHook(_setToken, _reserveAsset, _reserveAssetQuantity, _caller, _to);
        }
    }
    /**
     * If a pre-redeem hook has been configured, call the external-protocol contract.
     */
    function _callPreRedeemHooks(ISetToken _setToken, uint256 _setQuantity, address _caller, address _to) internal {
        INAVIssuanceHook preRedeemHook = navIssuanceSettings[_setToken].managerRedemptionHook;
        if (address(preRedeemHook) != address(0)) {
            preRedeemHook.invokePreRedeemHook(_setToken, _setQuantity, _caller, _to);
        }
    }
}.

Chief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.
Here's a Solidity contract provided by the user: "/*
    Copyright 2020 Set Labs Inc.
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    SPDX-License-Identifier: Apache License, Version 2.0
*/
pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";
import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";
import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";
import { SignedSafeMath } from "@openzeppelin/contracts/math/SignedSafeMath.sol";
import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";
import { IController } from "../../interfaces/IController.sol";
import { INAVIssuanceHook } from "../../interfaces/INAVIssuanceHook.sol";
import { Invoke } from "../lib/Invoke.sol";
import { ISetToken } from "../../interfaces/ISetToken.sol";
import { IWETH } from "../../interfaces/external/IWETH.sol";
import { ModuleBase } from "../lib/ModuleBase.sol";
import { Position } from "../lib/Position.sol";
import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";
import { ResourceIdentifier } from "../lib/ResourceIdentifier.sol";

/**
 * @title NavIssuanceModule
 * @author Set Protocol
 *
 * Module that enables issuance and redemption with any valid ERC20 token or ETH if allowed by the manager. Sender receives
 * a proportional amount of SetTokens on issuance or ERC20 token on redemption based on the calculated net asset value using
 * oracle prices. Manager is able to enforce a premium / discount on issuance / redemption to avoid arbitrage and front
 * running when relying on oracle prices. Managers can charge a fee (denominated in reserve asset).
 */
contract NavIssuanceModule is ModuleBase, ReentrancyGuard {
    using AddressArrayUtils for address[];
    using Invoke for ISetToken;
    using Position for ISetToken;
    using PreciseUnitMath for uint256;
    using PreciseUnitMath for int256;
    using ResourceIdentifier for IController;
    using SafeMath for uint256;
    using SafeCast for int256;
    using SafeCast for uint256;
    using SignedSafeMath for int256;
    /* ============ Events ============ */
    event SetTokenNAVIssued(
        ISetToken indexed _setToken,
        address _issuer,
        address _to,
        address _reserveAsset,
        address _hookContract,
        uint256 _setTokenQuantity,
        uint256 _managerFee,
        uint256 _premium
    );
    event SetTokenNAVRedeemed(
        ISetToken indexed _setToken,
        address _redeemer,
        address _to,
        address _reserveAsset,
        address _hookContract,
        uint256 _setTokenQuantity,
        uint256 _managerFee,
        uint256 _premium
    );
    event ReserveAssetAdded(
        ISetToken indexed _setToken,
        address _newReserveAsset
    );
    event ReserveAssetRemoved(
        ISetToken indexed _setToken,
        address _removedReserveAsset
    );
    event PremiumEdited(
        ISetToken indexed _setToken,
        uint256 _newPremium
    );
    event ManagerFeeEdited(
        ISetToken indexed _setToken,
        uint256 _newManagerFee,
        uint256 _index
    );
    event FeeRecipientEdited(
        ISetToken indexed _setToken,
        address _feeRecipient
    );
    /* ============ Structs ============ */
    struct NAVIssuanceSettings {
        INAVIssuanceHook managerIssuanceHook;      // Issuance hook configurations
        INAVIssuanceHook managerRedemptionHook;    // Redemption hook configurations
        address[] reserveAssets;                       // Allowed reserve assets - Must have a price enabled with the price oracle
        address feeRecipient;                          // Manager fee recipient
        uint256[2] managerFees;                        // Manager fees. 0 index is issue and 1 index is redeem fee (0.01% = 1e14, 1% = 1e16)
        uint256 maxManagerFee;                         // Maximum fee manager is allowed to set for issue and redeem
        uint256 premiumPercentage;                     // Premium percentage (0.01% = 1e14, 1% = 1e16). This premium is a buffer around oracle
                                                       // prices paid by user to the SetToken, which prevents arbitrage and oracle front running
        uint256 maxPremiumPercentage;                  // Maximum premium percentage manager is allowed to set (configured by manager)
        uint256 minSetTokenSupply;                     // Minimum SetToken supply required for issuance and redemption
                                                       // to prevent dramatic inflationary changes to the SetToken's position multiplier
    }
    struct ActionInfo {
        uint256 preFeeReserveQuantity;                 // Reserve value before fees; During issuance, represents raw quantity
                                                       // During redeem, represents post-premium value
        uint256 protocolFees;                          // Total protocol fees (direct + manager revenue share)
        uint256 managerFee;                            // Total manager fee paid in reserve asset
        uint256 netFlowQuantity;                       // When issuing, quantity of reserve asset sent to SetToken
                                                       // When redeeming, quantity of reserve asset sent to redeemer
        uint256 setTokenQuantity;                      // When issuing, quantity of SetTokens minted to mintee
                                                       // When redeeming, quantity of SetToken redeemed
        uint256 previousSetTokenSupply;                // SetToken supply prior to issue/redeem action
        uint256 newSetTokenSupply;                     // SetToken supply after issue/redeem action
        int256 newPositionMultiplier;                  // SetToken position multiplier after issue/redeem
        uint256 newReservePositionUnit;                // SetToken reserve asset position unit after issue/redeem
    }
    /* ============ State Variables ============ */
    // Wrapped ETH address
    IWETH public immutable weth;
    // Mapping of SetToken to NAV issuance settings struct
    mapping(ISetToken => NAVIssuanceSettings) public navIssuanceSettings;
    // Mapping to efficiently check a SetToken's reserve asset validity
    // SetToken => reserveAsset => isReserveAsset
    mapping(ISetToken => mapping(address => bool)) public isReserveAsset;
    /* ============ Constants ============ */
    // 0 index stores the manager fee in managerFees array, percentage charged on issue (denominated in reserve asset)
    uint256 constant internal MANAGER_ISSUE_FEE_INDEX = 0;
    // 1 index stores the manager fee percentage in managerFees array, charged on redeem
    uint256 constant internal MANAGER_REDEEM_FEE_INDEX = 1;
    // 0 index stores the manager revenue share protocol fee % on the controller, charged in the issuance function
    uint256 constant internal PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX = 0;
    // 1 index stores the manager revenue share protocol fee % on the controller, charged in the redeem function
    uint256 constant internal PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX = 1;
    // 2 index stores the direct protocol fee % on the controller, charged in the issuance function
    uint256 constant internal PROTOCOL_ISSUE_DIRECT_FEE_INDEX = 2;
    // 3 index stores the direct protocol fee % on the controller, charged in the redeem function
    uint256 constant internal PROTOCOL_REDEEM_DIRECT_FEE_INDEX = 3;
    /* ============ Constructor ============ */
    /**
     * @param _controller               Address of controller contract
     * @param _weth                     Address of wrapped eth
     */
    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {
        weth = _weth;
    }
    /* ============ External Functions ============ */
    /**
     * Deposits the allowed reserve asset into the SetToken and mints the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _reserveAsset                 Address of the reserve asset to issue with
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance
     * @param _to                           Address to mint SetToken to
     */
    function issue(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity,
        uint256 _minSetTokenReceiveQuantity,
        address _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, _reserveAsset, _reserveAssetQuantity);
        _callPreIssueHooks(_setToken, _reserveAsset, _reserveAssetQuantity, msg.sender, _to);
        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, _reserveAsset, _reserveAssetQuantity);
        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);
        _transferCollateralAndHandleFees(_setToken, IERC20(_reserveAsset), issueInfo);
        _handleIssueStateUpdates(_setToken, _reserveAsset, _to, issueInfo);
    }
    /**
     * Wraps ETH and deposits WETH if allowed into the SetToken and mints the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance
     * @param _to                           Address to mint SetToken to
     */
    function issueWithEther(
        ISetToken _setToken,
        uint256 _minSetTokenReceiveQuantity,
        address _to
    )
        external
        payable
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        weth.deposit{ value: msg.value }();
        _validateCommon(_setToken, address(weth), msg.value);
        _callPreIssueHooks(_setToken, address(weth), msg.value, msg.sender, _to);
        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, address(weth), msg.value);
        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);
        _transferWETHAndHandleFees(_setToken, issueInfo);
        _handleIssueStateUpdates(_setToken, address(weth), _to, issueInfo);
    }
    /**
     * Redeems a SetToken into a valid reserve asset representing the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address. Only valid if there are available reserve units on the SetToken.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _reserveAsset                 Address of the reserve asset to redeem with
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive
     * @param _to                           Address to redeem reserve asset to
     */
    function redeem(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity,
        uint256 _minReserveReceiveQuantity,
        address _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, _reserveAsset, _setTokenQuantity);
        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);
        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, _reserveAsset, _setTokenQuantity);
        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);
        _setToken.burn(msg.sender, _setTokenQuantity);
        // Instruct the SetToken to transfer the reserve asset back to the user
        _setToken.strictInvokeTransfer(
            _reserveAsset,
            _to,
            redeemInfo.netFlowQuantity
        );
        _handleRedemptionFees(_setToken, _reserveAsset, redeemInfo);
        _handleRedeemStateUpdates(_setToken, _reserveAsset, _to, redeemInfo);
    }
    /**
     * Redeems a SetToken into Ether (if WETH is valid) representing the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address. Only valid if there are available WETH units on the SetToken.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive
     * @param _to                           Address to redeem reserve asset to
     */
    function redeemIntoEther(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        uint256 _minReserveReceiveQuantity,
        address payable _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, address(weth), _setTokenQuantity);
        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);
        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, address(weth), _setTokenQuantity);
        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);
        _setToken.burn(msg.sender, _setTokenQuantity);
        // Instruct the SetToken to transfer WETH from SetToken to module
        _setToken.strictInvokeTransfer(
            address(weth),
            address(this),
            redeemInfo.netFlowQuantity
        );
        weth.withdraw(redeemInfo.netFlowQuantity);
        _to.transfer(redeemInfo.netFlowQuantity);
        _handleRedemptionFees(_setToken, address(weth), redeemInfo);
        _handleRedeemStateUpdates(_setToken, address(weth), _to, redeemInfo);
    }
    /**
     * SET MANAGER ONLY. Add an allowed reserve asset
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset to add
     */
    function addReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {
        require(!isReserveAsset[_setToken][_reserveAsset], "Reserve asset already exists");
        navIssuanceSettings[_setToken].reserveAssets.push(_reserveAsset);
        isReserveAsset[_setToken][_reserveAsset] = true;
        emit ReserveAssetAdded(_setToken, _reserveAsset);
    }
    /**
     * SET MANAGER ONLY. Remove a reserve asset
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset to remove
     */
    function removeReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {
        require(isReserveAsset[_setToken][_reserveAsset], "Reserve asset does not exist");
        navIssuanceSettings[_setToken].reserveAssets = navIssuanceSettings[_setToken].reserveAssets.remove(_reserveAsset);
        delete isReserveAsset[_setToken][_reserveAsset];
        emit ReserveAssetRemoved(_setToken, _reserveAsset);
    }
    /**
     * SET MANAGER ONLY. Edit the premium percentage
     *
     * @param _setToken                     Instance of the SetToken
     * @param _premiumPercentage            Premium percentage in 10e16 (e.g. 10e16 = 1%)
     */
    function editPremium(ISetToken _setToken, uint256 _premiumPercentage) external onlyManagerAndValidSet(_setToken) {
        require(_premiumPercentage <= navIssuanceSettings[_setToken].maxPremiumPercentage, "Premium must be less than maximum allowed");
        navIssuanceSettings[_setToken].premiumPercentage = _premiumPercentage;
        emit PremiumEdited(_setToken, _premiumPercentage);
    }
    /**
     * SET MANAGER ONLY. Edit manager fee
     *
     * @param _setToken                     Instance of the SetToken
     * @param _managerFeePercentage         Manager fee percentage in 10e16 (e.g. 10e16 = 1%)
     * @param _managerFeeIndex              Manager fee index. 0 index is issue fee, 1 index is redeem fee
     */
    function editManagerFee(
        ISetToken _setToken,
        uint256 _managerFeePercentage,
        uint256 _managerFeeIndex
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        require(_managerFeePercentage <= navIssuanceSettings[_setToken].maxManagerFee, "Manager fee must be less than maximum allowed");
        navIssuanceSettings[_setToken].managerFees[_managerFeeIndex] = _managerFeePercentage;
        emit ManagerFeeEdited(_setToken, _managerFeePercentage, _managerFeeIndex);
    }
    /**
     * SET MANAGER ONLY. Edit the manager fee recipient
     *
     * @param _setToken                     Instance of the SetToken
     * @param _managerFeeRecipient          Manager fee recipient
     */
    function editFeeRecipient(ISetToken _setToken, address _managerFeeRecipient) external onlyManagerAndValidSet(_setToken) {
        require(_managerFeeRecipient != address(0), "Fee recipient must not be 0 address");
        navIssuanceSettings[_setToken].feeRecipient = _managerFeeRecipient;
        emit FeeRecipientEdited(_setToken, _managerFeeRecipient);
    }
    /**
     * SET MANAGER ONLY. Initializes this module to the SetToken with hooks, allowed reserve assets,
     * fees and issuance premium. Only callable by the SetToken's manager. Hook addresses are optional.
     * Address(0) means that no hook will be called.
     *
     * @param _setToken                     Instance of the SetToken to issue
     * @param _navIssuanceSettings          NAVIssuanceSettings struct defining parameters
     */
    function initialize(
        ISetToken _setToken,
        NAVIssuanceSettings memory _navIssuanceSettings
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        require(_navIssuanceSettings.reserveAssets.length > 0, "Reserve assets must be greater than 0");
        require(_navIssuanceSettings.maxManagerFee < PreciseUnitMath.preciseUnit(), "Max manager fee must be less than 100%");
        require(_navIssuanceSettings.maxPremiumPercentage < PreciseUnitMath.preciseUnit(), "Max premium percentage must be less than 100%");
        require(_navIssuanceSettings.managerFees[0] <= _navIssuanceSettings.maxManagerFee, "Manager issue fee must be less than max");
        require(_navIssuanceSettings.managerFees[1] <= _navIssuanceSettings.maxManagerFee, "Manager redeem fee must be less than max");
        require(_navIssuanceSettings.premiumPercentage <= _navIssuanceSettings.maxPremiumPercentage, "Premium must be less than max");
        require(_navIssuanceSettings.feeRecipient != address(0), "Fee Recipient must be non-zero address.");
        // Initial mint of Set cannot use NAVIssuance since minSetTokenSupply must be > 0
        require(_navIssuanceSettings.minSetTokenSupply > 0, "Min SetToken supply must be greater than 0");
        for (uint256 i = 0; i < _navIssuanceSettings.reserveAssets.length; i++) {
            require(!isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]], "Reserve assets must be unique");
            isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]] = true;
        }
        navIssuanceSettings[_setToken] = _navIssuanceSettings;
        _setToken.initializeModule();
    }
    /**
     * Removes this module from the SetToken, via call by the SetToken. Issuance settings and
     * reserve asset states are deleted.
     */
    function removeModule() external override {
        ISetToken setToken = ISetToken(msg.sender);
        for (uint256 i = 0; i < navIssuanceSettings[setToken].reserveAssets.length; i++) {
            delete isReserveAsset[setToken][navIssuanceSettings[setToken].reserveAssets[i]];
        }
        delete navIssuanceSettings[setToken];
    }
    receive() external payable {}
    /* ============ External Getter Functions ============ */
    function getReserveAssets(ISetToken _setToken) external view returns (address[] memory) {
        return navIssuanceSettings[_setToken].reserveAssets;
    }
    function getIssuePremium(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (uint256)
    {
        return _getIssuePremium(_setToken, _reserveAsset, _reserveAssetQuantity);
    }
    function getRedeemPremium(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (uint256)
    {
        return _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);
    }
    function getManagerFee(ISetToken _setToken, uint256 _managerFeeIndex) external view returns (uint256) {
        return navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];
    }
    /**
     * Get the expected SetTokens minted to recipient on issuance
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     *
     * @return  uint256                     Expected SetTokens to be minted to recipient
     */
    function getExpectedSetTokenIssueQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (uint256)
    {
        (,, uint256 netReserveFlow) = _getFees(
            _setToken,
            _reserveAssetQuantity,
            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,
            MANAGER_ISSUE_FEE_INDEX
        );
        uint256 setTotalSupply = _setToken.totalSupply();
        return _getSetTokenMintQuantity(
            _setToken,
            _reserveAsset,
            netReserveFlow,
            setTotalSupply
        );
    }
    /**
     * Get the expected reserve asset to be redeemed
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     *
     * @return  uint256                     Expected reserve asset quantity redeemed
     */
    function getExpectedReserveRedeemQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (uint256)
    {
        uint256 preFeeReserveQuantity = _getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);
        (,, uint256 netReserveFlows) = _getFees(
            _setToken,
            preFeeReserveQuantity,
            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
            MANAGER_REDEEM_FEE_INDEX
        );
        return netReserveFlows;
    }
    /**
     * Checks if issue is valid
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     *
     * @return  bool                        Returns true if issue is valid
     */
    function isIssueValid(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (bool)
    {
        uint256 setTotalSupply = _setToken.totalSupply();
    return _reserveAssetQuantity != 0
            && isReserveAsset[_setToken][_reserveAsset]
            && setTotalSupply >= navIssuanceSettings[_setToken].minSetTokenSupply;
    }
    /**
     * Checks if redeem is valid
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     *
     * @return  bool                        Returns true if redeem is valid
     */
    function isRedeemValid(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (bool)
    {
        uint256 setTotalSupply = _setToken.totalSupply();
        if (
            _setTokenQuantity == 0
            || !isReserveAsset[_setToken][_reserveAsset]
            || setTotalSupply < navIssuanceSettings[_setToken].minSetTokenSupply.add(_setTokenQuantity)
        ) {
            return false;
        } else {
            uint256 totalRedeemValue =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);
            (,, uint256 expectedRedeemQuantity) = _getFees(
                _setToken,
                totalRedeemValue,
                PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
                PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
                MANAGER_REDEEM_FEE_INDEX
            );
            uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();
            return existingUnit.preciseMul(setTotalSupply) >= expectedRedeemQuantity;
        }
    }
    /* ============ Internal Functions ============ */
    function _validateCommon(ISetToken _setToken, address _reserveAsset, uint256 _quantity) internal view {
        require(_quantity > 0, "Quantity must be > 0");
        require(isReserveAsset[_setToken][_reserveAsset], "Must be valid reserve asset");
    }
    function _validateIssuanceInfo(ISetToken _setToken, uint256 _minSetTokenReceiveQuantity, ActionInfo memory _issueInfo) internal view {
        // Check that total supply is greater than min supply needed for issuance
        // Note: A min supply amount is needed to avoid division by 0 when SetToken supply is 0
        require(
            _issueInfo.previousSetTokenSupply >= navIssuanceSettings[_setToken].minSetTokenSupply,
            "Supply must be greater than minimum to enable issuance"
        );
        require(_issueInfo.setTokenQuantity >= _minSetTokenReceiveQuantity, "Must be greater than min SetToken");
    }
    function _validateRedemptionInfo(
        ISetToken _setToken,
        uint256 _minReserveReceiveQuantity,
        ActionInfo memory _redeemInfo
    )
        internal
        view
    {
        // Check that new supply is more than min supply needed for redemption
        // Note: A min supply amount is needed to avoid division by 0 when redeeming SetToken to 0
        require(
            _redeemInfo.newSetTokenSupply >= navIssuanceSettings[_setToken].minSetTokenSupply,
            "Supply must be greater than minimum to enable redemption"
        );
        require(_redeemInfo.netFlowQuantity >= _minReserveReceiveQuantity, "Must be greater than min receive reserve quantity");
    }
    function _createIssuanceInfo(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        internal
        view
        returns (ActionInfo memory)
    {
        ActionInfo memory issueInfo;
        issueInfo.previousSetTokenSupply = _setToken.totalSupply();
        issueInfo.preFeeReserveQuantity = _reserveAssetQuantity;
        (issueInfo.protocolFees, issueInfo.managerFee, issueInfo.netFlowQuantity) = _getFees(
            _setToken,
            issueInfo.preFeeReserveQuantity,
            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,
            MANAGER_ISSUE_FEE_INDEX
        );
        issueInfo.setTokenQuantity = _getSetTokenMintQuantity(
            _setToken,
            _reserveAsset,
            issueInfo.netFlowQuantity,
            issueInfo.previousSetTokenSupply
        );
        (issueInfo.newSetTokenSupply, issueInfo.newPositionMultiplier) = _getIssuePositionMultiplier(_setToken, issueInfo);
        issueInfo.newReservePositionUnit = _getIssuePositionUnit(_setToken, _reserveAsset, issueInfo);
        return issueInfo;
    }
    function _createRedemptionInfo(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        internal
        view
        returns (ActionInfo memory)
    {
        ActionInfo memory redeemInfo;
        redeemInfo.setTokenQuantity = _setTokenQuantity;
        redeemInfo.preFeeReserveQuantity =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);
        (redeemInfo.protocolFees, redeemInfo.managerFee, redeemInfo.netFlowQuantity) = _getFees(
            _setToken,
            redeemInfo.preFeeReserveQuantity,
            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
            MANAGER_REDEEM_FEE_INDEX
        );
        redeemInfo.previousSetTokenSupply = _setToken.totalSupply();
        (redeemInfo.newSetTokenSupply, redeemInfo.newPositionMultiplier) = _getRedeemPositionMultiplier(_setToken, _setTokenQuantity, redeemInfo);
        redeemInfo.newReservePositionUnit = _getRedeemPositionUnit(_setToken, _reserveAsset, redeemInfo);
        return redeemInfo;
    }
    /**
     * Transfer reserve asset from user to SetToken and fees from user to appropriate fee recipients
     */
    function _transferCollateralAndHandleFees(ISetToken _setToken, IERC20 _reserveAsset, ActionInfo memory _issueInfo) internal {
        transferFrom(_reserveAsset, msg.sender, address(_setToken), _issueInfo.netFlowQuantity);
        if (_issueInfo.protocolFees > 0) {
            transferFrom(_reserveAsset, msg.sender, controller.feeRecipient(), _issueInfo.protocolFees);
        }
        if (_issueInfo.managerFee > 0) {
            transferFrom(_reserveAsset, msg.sender, navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);
        }
    }

    /**
      * Transfer WETH from module to SetToken and fees from module to appropriate fee recipients
     */
    function _transferWETHAndHandleFees(ISetToken _setToken, ActionInfo memory _issueInfo) internal {
        weth.transfer(address(_setToken), _issueInfo.netFlowQuantity);
        if (_issueInfo.protocolFees > 0) {
            weth.transfer(controller.feeRecipient(), _issueInfo.protocolFees);
        }
        if (_issueInfo.managerFee > 0) {
            weth.transfer(navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);
        }
    }
    function _handleIssueStateUpdates(
        ISetToken _setToken,
        address _reserveAsset,
        address _to,
        ActionInfo memory _issueInfo
    )
        internal
    {
        _setToken.editPositionMultiplier(_issueInfo.newPositionMultiplier);
        _setToken.editDefaultPosition(_reserveAsset, _issueInfo.newReservePositionUnit);
        _setToken.mint(_to, _issueInfo.setTokenQuantity);
        emit SetTokenNAVIssued(
            _setToken,
            msg.sender,
            _to,
            _reserveAsset,
            address(navIssuanceSettings[_setToken].managerIssuanceHook),
            _issueInfo.setTokenQuantity,
            _issueInfo.managerFee,
            _issueInfo.protocolFees
        );
    }
    function _handleRedeemStateUpdates(
        ISetToken _setToken,
        address _reserveAsset,
        address _to,
        ActionInfo memory _redeemInfo
    )
        internal
    {
        _setToken.editPositionMultiplier(_redeemInfo.newPositionMultiplier);
        _setToken.editDefaultPosition(_reserveAsset, _redeemInfo.newReservePositionUnit);
        emit SetTokenNAVRedeemed(
            _setToken,
            msg.sender,
            _to,
            _reserveAsset,
            address(navIssuanceSettings[_setToken].managerRedemptionHook),
            _redeemInfo.setTokenQuantity,
            _redeemInfo.managerFee,
            _redeemInfo.protocolFees
        );
    }
    function _handleRedemptionFees(ISetToken _setToken, address _reserveAsset, ActionInfo memory _redeemInfo) internal {
        // Instruct the SetToken to transfer protocol fee to fee recipient if there is a fee
        payProtocolFeeFromSetToken(_setToken, _reserveAsset, _redeemInfo.protocolFees);
        // Instruct the SetToken to transfer manager fee to manager fee recipient if there is a fee
        if (_redeemInfo.managerFee > 0) {
            _setToken.strictInvokeTransfer(
                _reserveAsset,
                navIssuanceSettings[_setToken].feeRecipient,
                _redeemInfo.managerFee
            );
        }
    }
    /**
     * Returns the issue premium percentage. Virtual function that can be overridden in future versions of the module
     * and can contain arbitrary logic to calculate the issuance premium.
     */
    function _getIssuePremium(
        ISetToken _setToken,
        address /* _reserveAsset */,
        uint256 /* _reserveAssetQuantity */
    )
        virtual
        internal
        view
        returns (uint256)
    {
        return navIssuanceSettings[_setToken].premiumPercentage;
    }
    /**
     * Returns the redeem premium percentage. Virtual function that can be overridden in future versions of the module
     * and can contain arbitrary logic to calculate the redemption premium.
     */
    function _getRedeemPremium(
        ISetToken _setToken,
        address /* _reserveAsset */,
        uint256 /* _setTokenQuantity */
    )
        virtual
        internal
        view
        returns (uint256)
    {
        return navIssuanceSettings[_setToken].premiumPercentage;
    }
    /**
     * Returns the fees attributed to the manager and the protocol. The fees are calculated as follows:
     *
     * ManagerFee = (manager fee % - % to protocol) * reserveAssetQuantity
     * Protocol Fee = (% manager fee share + direct fee %) * reserveAssetQuantity
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAssetQuantity         Quantity of reserve asset to calculate fees from
     * @param _protocolManagerFeeIndex      Index to pull rev share NAV Issuance fee from the Controller
     * @param _protocolDirectFeeIndex       Index to pull direct NAV issuance fee from the Controller
     * @param _managerFeeIndex              Index from NAVIssuanceSettings (0 = issue fee, 1 = redeem fee)
     *
     * @return  uint256                     Fees paid to the protocol in reserve asset
     * @return  uint256                     Fees paid to the manager in reserve asset
     * @return  uint256                     Net reserve to user net of fees
     */
    function _getFees(
        ISetToken _setToken,
        uint256 _reserveAssetQuantity,
        uint256 _protocolManagerFeeIndex,
        uint256 _protocolDirectFeeIndex,
        uint256 _managerFeeIndex
    )
        internal
        view
        returns (uint256, uint256, uint256)
    {
        (uint256 protocolFeePercentage, uint256 managerFeePercentage) = _getProtocolAndManagerFeePercentages(
            _setToken,
            _protocolManagerFeeIndex,
            _protocolDirectFeeIndex,
            _managerFeeIndex
        );
        // Calculate total notional fees
        uint256 protocolFees = protocolFeePercentage.preciseMul(_reserveAssetQuantity);
        uint256 managerFee = managerFeePercentage.preciseMul(_reserveAssetQuantity);
        uint256 netReserveFlow = _reserveAssetQuantity.sub(protocolFees).sub(managerFee);
        return (protocolFees, managerFee, netReserveFlow);
    }
    function _getProtocolAndManagerFeePercentages(
        ISetToken _setToken,
        uint256 _protocolManagerFeeIndex,
        uint256 _protocolDirectFeeIndex,
        uint256 _managerFeeIndex
    )
        internal
        view
        returns(uint256, uint256)
    {
        // Get protocol fee percentages
        uint256 protocolDirectFeePercent = controller.getModuleFee(address(this), _protocolDirectFeeIndex);
        uint256 protocolManagerShareFeePercent = controller.getModuleFee(address(this), _protocolManagerFeeIndex);
        uint256 managerFeePercent = navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];
        // Calculate revenue share split percentage
        uint256 protocolRevenueSharePercentage = protocolManagerShareFeePercent.preciseMul(managerFeePercent);
        uint256 managerRevenueSharePercentage = managerFeePercent.sub(protocolRevenueSharePercentage);
        uint256 totalProtocolFeePercentage = protocolRevenueSharePercentage.add(protocolDirectFeePercent);
        return (totalProtocolFeePercentage, managerRevenueSharePercentage);
    }
    function _getSetTokenMintQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _netReserveFlows,            // Value of reserve asset net of fees
        uint256 _setTotalSupply
    )
        internal
        view
        returns (uint256)
    {
        uint256 premiumPercentage = _getIssuePremium(_setToken, _reserveAsset, _netReserveFlows);
        uint256 premiumValue = _netReserveFlows.preciseMul(premiumPercentage);
        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (1e18)
        // Reverts if price is not found
        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);
        // Get reserve asset decimals
        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();
        uint256 normalizedTotalReserveQuantityNetFees = _netReserveFlows.preciseDiv(10 ** reserveAssetDecimals);
        uint256 normalizedTotalReserveQuantityNetFeesAndPremium = _netReserveFlows.sub(premiumValue).preciseDiv(10 ** reserveAssetDecimals);
        // Calculate SetTokens to mint to issuer
        uint256 denominator = _setTotalSupply.preciseMul(setTokenValuation).add(normalizedTotalReserveQuantityNetFees).sub(normalizedTotalReserveQuantityNetFeesAndPremium);
        return normalizedTotalReserveQuantityNetFeesAndPremium.preciseMul(_setTotalSupply).preciseDiv(denominator);
    }
    function _getRedeemReserveQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        internal
        view
        returns (uint256)
    {
        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (10e18)
        // Reverts if price is not found
        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);
        uint256 totalRedeemValueInPreciseUnits = _setTokenQuantity.preciseMul(setTokenValuation);
        // Get reserve asset decimals
        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();
        uint256 prePremiumReserveQuantity = totalRedeemValueInPreciseUnits.preciseMul(10 ** reserveAssetDecimals);
        uint256 premiumPercentage = _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);
        uint256 premiumQuantity = prePremiumReserveQuantity.preciseMulCeil(premiumPercentage);
        return prePremiumReserveQuantity.sub(premiumQuantity);
    }
    /**
     * The new position multiplier is calculated as follows:
     * inflationPercentage = (newSupply - oldSupply) / newSupply
     * newMultiplier = (1 - inflationPercentage) * positionMultiplier
     */
    function _getIssuePositionMultiplier(
        ISetToken _setToken,
        ActionInfo memory _issueInfo
    )
        internal
        view
        returns (uint256, int256)
    {
        // Calculate inflation and new position multiplier. Note: Round inflation up in order to round position multiplier down
        uint256 newTotalSupply = _issueInfo.setTokenQuantity.add(_issueInfo.previousSetTokenSupply);
        int256 newPositionMultiplier = _setToken.positionMultiplier()
            .mul(_issueInfo.previousSetTokenSupply.toInt256())
            .div(newTotalSupply.toInt256());
        return (newTotalSupply, newPositionMultiplier);
    }
    /**
     * Calculate deflation and new position multiplier. Note: Round deflation down in order to round position multiplier down
     *
     * The new position multiplier is calculated as follows:
     * deflationPercentage = (oldSupply - newSupply) / newSupply
     * newMultiplier = (1 + deflationPercentage) * positionMultiplier
     */
    function _getRedeemPositionMultiplier(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        ActionInfo memory _redeemInfo
    )
        internal
        view
        returns (uint256, int256)
    {
        uint256 newTotalSupply = _redeemInfo.previousSetTokenSupply.sub(_setTokenQuantity);
        int256 newPositionMultiplier = _setToken.positionMultiplier()
            .mul(_redeemInfo.previousSetTokenSupply.toInt256())
            .div(newTotalSupply.toInt256());
        return (newTotalSupply, newPositionMultiplier);
    }
    /**
     * The new position reserve asset unit is calculated as follows:
     * totalReserve = (oldUnit * oldSetTokenSupply) + reserveQuantity
     * newUnit = totalReserve / newSetTokenSupply
     */
    function _getIssuePositionUnit(
        ISetToken _setToken,
        address _reserveAsset,
        ActionInfo memory _issueInfo
    )
        internal
        view
        returns (uint256)
    {
        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();
        uint256 totalReserve = existingUnit
            .preciseMul(_issueInfo.previousSetTokenSupply)
            .add(_issueInfo.netFlowQuantity);
        return totalReserve.preciseDiv(_issueInfo.newSetTokenSupply);
    }
    /**
     * The new position reserve asset unit is calculated as follows:
     * totalReserve = (oldUnit * oldSetTokenSupply) - reserveQuantityToSendOut
     * newUnit = totalReserve / newSetTokenSupply
     */
    function _getRedeemPositionUnit(
        ISetToken _setToken,
        address _reserveAsset,
        ActionInfo memory _redeemInfo
    )
        internal
        view
        returns (uint256)
    {
        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();
        uint256 totalExistingUnits = existingUnit.preciseMul(_redeemInfo.previousSetTokenSupply);
        uint256 outflow = _redeemInfo.netFlowQuantity.add(_redeemInfo.protocolFees).add(_redeemInfo.managerFee);
        // Require withdrawable quantity is greater than existing collateral
        require(totalExistingUnits >= outflow, "Must be greater than total available collateral");
        return totalExistingUnits.sub(outflow).preciseDiv(_redeemInfo.newSetTokenSupply);
    }
    /**
     * If a pre-issue hook has been configured, call the external-protocol contract. Pre-issue hook logic
     * can contain arbitrary logic including validations, external function calls, etc.
     */
    function _callPreIssueHooks(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity,
        address _caller,
        address _to
    )
        internal
    {
        INAVIssuanceHook preIssueHook = navIssuanceSettings[_setToken].managerIssuanceHook;
        if (address(preIssueHook) != address(0)) {
            preIssueHook.invokePreIssueHook(_setToken, _reserveAsset, _reserveAssetQuantity, _caller, _to);
        }
    }
    /**
     * If a pre-redeem hook has been configured, call the external-protocol contract.
     */
    function _callPreRedeemHooks(ISetToken _setToken, uint256 _setQuantity, address _caller, address _to) internal {
        INAVIssuanceHook preRedeemHook = navIssuanceSettings[_setToken].managerRedemptionHook;
        if (address(preRedeemHook) != address(0)) {
            preRedeemHook.invokePreRedeemHook(_setToken, _setQuantity, _caller, _to);
        }
    }
}".
As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.
Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

Security Analyst: Certainly Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" 

[2024-01-09 05:31:18 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 05:31:18 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 29921
completion_tokens: 1
total_tokens: 29922
cost: $-1.000000


[2024-01-09 05:31:18 INFO] Chief Executive Officer: **Chief Executive Officer<->Counselor on : Reflection, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your main responsibilities include asking what user and customer think and provide your valuable suggestions. 
Here is a new customer's task: /*
    Copyright 2020 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";
import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";
import { SignedSafeMath } from "@openzeppelin/contracts/math/SignedSafeMath.sol";

import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";
import { IController } from "../../interfaces/IController.sol";
import { INAVIssuanceHook } from "../../interfaces/INAVIssuanceHook.sol";
import { Invoke } from "../lib/Invoke.sol";
import { ISetToken } from "../../interfaces/ISetToken.sol";
import { IWETH } from "../../interfaces/external/IWETH.sol";
import { ModuleBase } from "../lib/ModuleBase.sol";
import { Position } from "../lib/Position.sol";
import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";
import { ResourceIdentifier } from "../lib/ResourceIdentifier.sol";


/**
 * @title NavIssuanceModule
 * @author Set Protocol
 *
 * Module that enables issuance and redemption with any valid ERC20 token or ETH if allowed by the manager. Sender receives
 * a proportional amount of SetTokens on issuance or ERC20 token on redemption based on the calculated net asset value using
 * oracle prices. Manager is able to enforce a premium / discount on issuance / redemption to avoid arbitrage and front
 * running when relying on oracle prices. Managers can charge a fee (denominated in reserve asset).
 */
contract NavIssuanceModule is ModuleBase, ReentrancyGuard {
    using AddressArrayUtils for address[];
    using Invoke for ISetToken;
    using Position for ISetToken;
    using PreciseUnitMath for uint256;
    using PreciseUnitMath for int256;
    using ResourceIdentifier for IController;
    using SafeMath for uint256;
    using SafeCast for int256;
    using SafeCast for uint256;
    using SignedSafeMath for int256;

    /* ============ Events ============ */

    event SetTokenNAVIssued(
        ISetToken indexed _setToken,
        address _issuer,
        address _to,
        address _reserveAsset,
        address _hookContract,
        uint256 _setTokenQuantity,
        uint256 _managerFee,
        uint256 _premium
    );

    event SetTokenNAVRedeemed(
        ISetToken indexed _setToken,
        address _redeemer,
        address _to,
        address _reserveAsset,
        address _hookContract,
        uint256 _setTokenQuantity,
        uint256 _managerFee,
        uint256 _premium
    );

    event ReserveAssetAdded(
        ISetToken indexed _setToken,
        address _newReserveAsset
    );

    event ReserveAssetRemoved(
        ISetToken indexed _setToken,
        address _removedReserveAsset
    );

    event PremiumEdited(
        ISetToken indexed _setToken,
        uint256 _newPremium
    );

    event ManagerFeeEdited(
        ISetToken indexed _setToken,
        uint256 _newManagerFee,
        uint256 _index
    );

    event FeeRecipientEdited(
        ISetToken indexed _setToken,
        address _feeRecipient
    );

    /* ============ Structs ============ */

    struct NAVIssuanceSettings {
        INAVIssuanceHook managerIssuanceHook;      // Issuance hook configurations
        INAVIssuanceHook managerRedemptionHook;    // Redemption hook configurations
        address[] reserveAssets;                       // Allowed reserve assets - Must have a price enabled with the price oracle
        address feeRecipient;                          // Manager fee recipient
        uint256[2] managerFees;                        // Manager fees. 0 index is issue and 1 index is redeem fee (0.01% = 1e14, 1% = 1e16)
        uint256 maxManagerFee;                         // Maximum fee manager is allowed to set for issue and redeem
        uint256 premiumPercentage;                     // Premium percentage (0.01% = 1e14, 1% = 1e16). This premium is a buffer around oracle
                                                       // prices paid by user to the SetToken, which prevents arbitrage and oracle front running
        uint256 maxPremiumPercentage;                  // Maximum premium percentage manager is allowed to set (configured by manager)
        uint256 minSetTokenSupply;                     // Minimum SetToken supply required for issuance and redemption
                                                       // to prevent dramatic inflationary changes to the SetToken's position multiplier
    }

    struct ActionInfo {
        uint256 preFeeReserveQuantity;                 // Reserve value before fees; During issuance, represents raw quantity
                                                       // During redeem, represents post-premium value
        uint256 protocolFees;                          // Total protocol fees (direct + manager revenue share)
        uint256 managerFee;                            // Total manager fee paid in reserve asset
        uint256 netFlowQuantity;                       // When issuing, quantity of reserve asset sent to SetToken
                                                       // When redeeming, quantity of reserve asset sent to redeemer
        uint256 setTokenQuantity;                      // When issuing, quantity of SetTokens minted to mintee
                                                       // When redeeming, quantity of SetToken redeemed
        uint256 previousSetTokenSupply;                // SetToken supply prior to issue/redeem action
        uint256 newSetTokenSupply;                     // SetToken supply after issue/redeem action
        int256 newPositionMultiplier;                  // SetToken position multiplier after issue/redeem
        uint256 newReservePositionUnit;                // SetToken reserve asset position unit after issue/redeem
    }

    /* ============ State Variables ============ */

    // Wrapped ETH address
    IWETH public immutable weth;

    // Mapping of SetToken to NAV issuance settings struct
    mapping(ISetToken => NAVIssuanceSettings) public navIssuanceSettings;

    // Mapping to efficiently check a SetToken's reserve asset validity
    // SetToken => reserveAsset => isReserveAsset
    mapping(ISetToken => mapping(address => bool)) public isReserveAsset;

    /* ============ Constants ============ */

    // 0 index stores the manager fee in managerFees array, percentage charged on issue (denominated in reserve asset)
    uint256 constant internal MANAGER_ISSUE_FEE_INDEX = 0;

    // 1 index stores the manager fee percentage in managerFees array, charged on redeem
    uint256 constant internal MANAGER_REDEEM_FEE_INDEX = 1;

    // 0 index stores the manager revenue share protocol fee % on the controller, charged in the issuance function
    uint256 constant internal PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX = 0;

    // 1 index stores the manager revenue share protocol fee % on the controller, charged in the redeem function
    uint256 constant internal PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX = 1;

    // 2 index stores the direct protocol fee % on the controller, charged in the issuance function
    uint256 constant internal PROTOCOL_ISSUE_DIRECT_FEE_INDEX = 2;

    // 3 index stores the direct protocol fee % on the controller, charged in the redeem function
    uint256 constant internal PROTOCOL_REDEEM_DIRECT_FEE_INDEX = 3;

    /* ============ Constructor ============ */

    /**
     * @param _controller               Address of controller contract
     * @param _weth                     Address of wrapped eth
     */
    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {
        weth = _weth;
    }

    /* ============ External Functions ============ */

    /**
     * Deposits the allowed reserve asset into the SetToken and mints the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _reserveAsset                 Address of the reserve asset to issue with
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance
     * @param _to                           Address to mint SetToken to
     */
    function issue(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity,
        uint256 _minSetTokenReceiveQuantity,
        address _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, _reserveAsset, _reserveAssetQuantity);

        _callPreIssueHooks(_setToken, _reserveAsset, _reserveAssetQuantity, msg.sender, _to);

        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, _reserveAsset, _reserveAssetQuantity);

        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);

        _transferCollateralAndHandleFees(_setToken, IERC20(_reserveAsset), issueInfo);

        _handleIssueStateUpdates(_setToken, _reserveAsset, _to, issueInfo);
    }

    /**
     * Wraps ETH and deposits WETH if allowed into the SetToken and mints the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance
     * @param _to                           Address to mint SetToken to
     */
    function issueWithEther(
        ISetToken _setToken,
        uint256 _minSetTokenReceiveQuantity,
        address _to
    )
        external
        payable
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        weth.deposit{ value: msg.value }();

        _validateCommon(_setToken, address(weth), msg.value);

        _callPreIssueHooks(_setToken, address(weth), msg.value, msg.sender, _to);

        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, address(weth), msg.value);

        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);

        _transferWETHAndHandleFees(_setToken, issueInfo);

        _handleIssueStateUpdates(_setToken, address(weth), _to, issueInfo);
    }

    /**
     * Redeems a SetToken into a valid reserve asset representing the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address. Only valid if there are available reserve units on the SetToken.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _reserveAsset                 Address of the reserve asset to redeem with
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive
     * @param _to                           Address to redeem reserve asset to
     */
    function redeem(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity,
        uint256 _minReserveReceiveQuantity,
        address _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, _reserveAsset, _setTokenQuantity);

        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);

        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, _reserveAsset, _setTokenQuantity);

        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);

        _setToken.burn(msg.sender, _setTokenQuantity);

        // Instruct the SetToken to transfer the reserve asset back to the user
        _setToken.strictInvokeTransfer(
            _reserveAsset,
            _to,
            redeemInfo.netFlowQuantity
        );

        _handleRedemptionFees(_setToken, _reserveAsset, redeemInfo);

        _handleRedeemStateUpdates(_setToken, _reserveAsset, _to, redeemInfo);
    }

    /**
     * Redeems a SetToken into Ether (if WETH is valid) representing the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address. Only valid if there are available WETH units on the SetToken.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive
     * @param _to                           Address to redeem reserve asset to
     */
    function redeemIntoEther(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        uint256 _minReserveReceiveQuantity,
        address payable _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, address(weth), _setTokenQuantity);

        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);

        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, address(weth), _setTokenQuantity);

        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);

        _setToken.burn(msg.sender, _setTokenQuantity);

        // Instruct the SetToken to transfer WETH from SetToken to module
        _setToken.strictInvokeTransfer(
            address(weth),
            address(this),
            redeemInfo.netFlowQuantity
        );

        weth.withdraw(redeemInfo.netFlowQuantity);

        _to.transfer(redeemInfo.netFlowQuantity);

        _handleRedemptionFees(_setToken, address(weth), redeemInfo);

        _handleRedeemStateUpdates(_setToken, address(weth), _to, redeemInfo);
    }

    /**
     * SET MANAGER ONLY. Add an allowed reserve asset
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset to add
     */
    function addReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {
        require(!isReserveAsset[_setToken][_reserveAsset], "Reserve asset already exists");

        navIssuanceSettings[_setToken].reserveAssets.push(_reserveAsset);
        isReserveAsset[_setToken][_reserveAsset] = true;

        emit ReserveAssetAdded(_setToken, _reserveAsset);
    }

    /**
     * SET MANAGER ONLY. Remove a reserve asset
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset to remove
     */
    function removeReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {
        require(isReserveAsset[_setToken][_reserveAsset], "Reserve asset does not exist");

        navIssuanceSettings[_setToken].reserveAssets = navIssuanceSettings[_setToken].reserveAssets.remove(_reserveAsset);
        delete isReserveAsset[_setToken][_reserveAsset];

        emit ReserveAssetRemoved(_setToken, _reserveAsset);
    }

    /**
     * SET MANAGER ONLY. Edit the premium percentage
     *
     * @param _setToken                     Instance of the SetToken
     * @param _premiumPercentage            Premium percentage in 10e16 (e.g. 10e16 = 1%)
     */
    function editPremium(ISetToken _setToken, uint256 _premiumPercentage) external onlyManagerAndValidSet(_setToken) {
        require(_premiumPercentage <= navIssuanceSettings[_setToken].maxPremiumPercentage, "Premium must be less than maximum allowed");

        navIssuanceSettings[_setToken].premiumPercentage = _premiumPercentage;

        emit PremiumEdited(_setToken, _premiumPercentage);
    }

    /**
     * SET MANAGER ONLY. Edit manager fee
     *
     * @param _setToken                     Instance of the SetToken
     * @param _managerFeePercentage         Manager fee percentage in 10e16 (e.g. 10e16 = 1%)
     * @param _managerFeeIndex              Manager fee index. 0 index is issue fee, 1 index is redeem fee
     */
    function editManagerFee(
        ISetToken _setToken,
        uint256 _managerFeePercentage,
        uint256 _managerFeeIndex
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        require(_managerFeePercentage <= navIssuanceSettings[_setToken].maxManagerFee, "Manager fee must be less than maximum allowed");

        navIssuanceSettings[_setToken].managerFees[_managerFeeIndex] = _managerFeePercentage;

        emit ManagerFeeEdited(_setToken, _managerFeePercentage, _managerFeeIndex);
    }

    /**
     * SET MANAGER ONLY. Edit the manager fee recipient
     *
     * @param _setToken                     Instance of the SetToken
     * @param _managerFeeRecipient          Manager fee recipient
     */
    function editFeeRecipient(ISetToken _setToken, address _managerFeeRecipient) external onlyManagerAndValidSet(_setToken) {
        require(_managerFeeRecipient != address(0), "Fee recipient must not be 0 address");

        navIssuanceSettings[_setToken].feeRecipient = _managerFeeRecipient;

        emit FeeRecipientEdited(_setToken, _managerFeeRecipient);
    }

    /**
     * SET MANAGER ONLY. Initializes this module to the SetToken with hooks, allowed reserve assets,
     * fees and issuance premium. Only callable by the SetToken's manager. Hook addresses are optional.
     * Address(0) means that no hook will be called.
     *
     * @param _setToken                     Instance of the SetToken to issue
     * @param _navIssuanceSettings          NAVIssuanceSettings struct defining parameters
     */
    function initialize(
        ISetToken _setToken,
        NAVIssuanceSettings memory _navIssuanceSettings
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        require(_navIssuanceSettings.reserveAssets.length > 0, "Reserve assets must be greater than 0");
        require(_navIssuanceSettings.maxManagerFee < PreciseUnitMath.preciseUnit(), "Max manager fee must be less than 100%");
        require(_navIssuanceSettings.maxPremiumPercentage < PreciseUnitMath.preciseUnit(), "Max premium percentage must be less than 100%");
        require(_navIssuanceSettings.managerFees[0] <= _navIssuanceSettings.maxManagerFee, "Manager issue fee must be less than max");
        require(_navIssuanceSettings.managerFees[1] <= _navIssuanceSettings.maxManagerFee, "Manager redeem fee must be less than max");
        require(_navIssuanceSettings.premiumPercentage <= _navIssuanceSettings.maxPremiumPercentage, "Premium must be less than max");
        require(_navIssuanceSettings.feeRecipient != address(0), "Fee Recipient must be non-zero address.");
        // Initial mint of Set cannot use NAVIssuance since minSetTokenSupply must be > 0
        require(_navIssuanceSettings.minSetTokenSupply > 0, "Min SetToken supply must be greater than 0");

        for (uint256 i = 0; i < _navIssuanceSettings.reserveAssets.length; i++) {
            require(!isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]], "Reserve assets must be unique");
            isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]] = true;
        }

        navIssuanceSettings[_setToken] = _navIssuanceSettings;

        _setToken.initializeModule();
    }

    /**
     * Removes this module from the SetToken, via call by the SetToken. Issuance settings and
     * reserve asset states are deleted.
     */
    function removeModule() external override {
        ISetToken setToken = ISetToken(msg.sender);
        for (uint256 i = 0; i < navIssuanceSettings[setToken].reserveAssets.length; i++) {
            delete isReserveAsset[setToken][navIssuanceSettings[setToken].reserveAssets[i]];
        }

        delete navIssuanceSettings[setToken];
    }

    receive() external payable {}

    /* ============ External Getter Functions ============ */

    function getReserveAssets(ISetToken _setToken) external view returns (address[] memory) {
        return navIssuanceSettings[_setToken].reserveAssets;
    }

    function getIssuePremium(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (uint256)
    {
        return _getIssuePremium(_setToken, _reserveAsset, _reserveAssetQuantity);
    }

    function getRedeemPremium(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (uint256)
    {
        return _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);
    }

    function getManagerFee(ISetToken _setToken, uint256 _managerFeeIndex) external view returns (uint256) {
        return navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];
    }

    /**
     * Get the expected SetTokens minted to recipient on issuance
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     *
     * @return  uint256                     Expected SetTokens to be minted to recipient
     */
    function getExpectedSetTokenIssueQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (uint256)
    {
        (,, uint256 netReserveFlow) = _getFees(
            _setToken,
            _reserveAssetQuantity,
            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,
            MANAGER_ISSUE_FEE_INDEX
        );

        uint256 setTotalSupply = _setToken.totalSupply();

        return _getSetTokenMintQuantity(
            _setToken,
            _reserveAsset,
            netReserveFlow,
            setTotalSupply
        );
    }

    /**
     * Get the expected reserve asset to be redeemed
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     *
     * @return  uint256                     Expected reserve asset quantity redeemed
     */
    function getExpectedReserveRedeemQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (uint256)
    {
        uint256 preFeeReserveQuantity = _getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

        (,, uint256 netReserveFlows) = _getFees(
            _setToken,
            preFeeReserveQuantity,
            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
            MANAGER_REDEEM_FEE_INDEX
        );

        return netReserveFlows;
    }

    /**
     * Checks if issue is valid
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     *
     * @return  bool                        Returns true if issue is valid
     */
    function isIssueValid(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (bool)
    {
        uint256 setTotalSupply = _setToken.totalSupply();

    return _reserveAssetQuantity != 0
            && isReserveAsset[_setToken][_reserveAsset]
            && setTotalSupply >= navIssuanceSettings[_setToken].minSetTokenSupply;
    }

    /**
     * Checks if redeem is valid
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     *
     * @return  bool                        Returns true if redeem is valid
     */
    function isRedeemValid(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (bool)
    {
        uint256 setTotalSupply = _setToken.totalSupply();

        if (
            _setTokenQuantity == 0
            || !isReserveAsset[_setToken][_reserveAsset]
            || setTotalSupply < navIssuanceSettings[_setToken].minSetTokenSupply.add(_setTokenQuantity)
        ) {
            return false;
        } else {
            uint256 totalRedeemValue =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

            (,, uint256 expectedRedeemQuantity) = _getFees(
                _setToken,
                totalRedeemValue,
                PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
                PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
                MANAGER_REDEEM_FEE_INDEX
            );

            uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();

            return existingUnit.preciseMul(setTotalSupply) >= expectedRedeemQuantity;
        }
    }

    /* ============ Internal Functions ============ */

    function _validateCommon(ISetToken _setToken, address _reserveAsset, uint256 _quantity) internal view {
        require(_quantity > 0, "Quantity must be > 0");
        require(isReserveAsset[_setToken][_reserveAsset], "Must be valid reserve asset");
    }

    function _validateIssuanceInfo(ISetToken _setToken, uint256 _minSetTokenReceiveQuantity, ActionInfo memory _issueInfo) internal view {
        // Check that total supply is greater than min supply needed for issuance
        // Note: A min supply amount is needed to avoid division by 0 when SetToken supply is 0
        require(
            _issueInfo.previousSetTokenSupply >= navIssuanceSettings[_setToken].minSetTokenSupply,
            "Supply must be greater than minimum to enable issuance"
        );

        require(_issueInfo.setTokenQuantity >= _minSetTokenReceiveQuantity, "Must be greater than min SetToken");
    }

    function _validateRedemptionInfo(
        ISetToken _setToken,
        uint256 _minReserveReceiveQuantity,
        ActionInfo memory _redeemInfo
    )
        internal
        view
    {
        // Check that new supply is more than min supply needed for redemption
        // Note: A min supply amount is needed to avoid division by 0 when redeeming SetToken to 0
        require(
            _redeemInfo.newSetTokenSupply >= navIssuanceSettings[_setToken].minSetTokenSupply,
            "Supply must be greater than minimum to enable redemption"
        );

        require(_redeemInfo.netFlowQuantity >= _minReserveReceiveQuantity, "Must be greater than min receive reserve quantity");
    }

    function _createIssuanceInfo(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        internal
        view
        returns (ActionInfo memory)
    {
        ActionInfo memory issueInfo;

        issueInfo.previousSetTokenSupply = _setToken.totalSupply();

        issueInfo.preFeeReserveQuantity = _reserveAssetQuantity;

        (issueInfo.protocolFees, issueInfo.managerFee, issueInfo.netFlowQuantity) = _getFees(
            _setToken,
            issueInfo.preFeeReserveQuantity,
            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,
            MANAGER_ISSUE_FEE_INDEX
        );

        issueInfo.setTokenQuantity = _getSetTokenMintQuantity(
            _setToken,
            _reserveAsset,
            issueInfo.netFlowQuantity,
            issueInfo.previousSetTokenSupply
        );

        (issueInfo.newSetTokenSupply, issueInfo.newPositionMultiplier) = _getIssuePositionMultiplier(_setToken, issueInfo);

        issueInfo.newReservePositionUnit = _getIssuePositionUnit(_setToken, _reserveAsset, issueInfo);

        return issueInfo;
    }

    function _createRedemptionInfo(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        internal
        view
        returns (ActionInfo memory)
    {
        ActionInfo memory redeemInfo;

        redeemInfo.setTokenQuantity = _setTokenQuantity;

        redeemInfo.preFeeReserveQuantity =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

        (redeemInfo.protocolFees, redeemInfo.managerFee, redeemInfo.netFlowQuantity) = _getFees(
            _setToken,
            redeemInfo.preFeeReserveQuantity,
            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
            MANAGER_REDEEM_FEE_INDEX
        );

        redeemInfo.previousSetTokenSupply = _setToken.totalSupply();

        (redeemInfo.newSetTokenSupply, redeemInfo.newPositionMultiplier) = _getRedeemPositionMultiplier(_setToken, _setTokenQuantity, redeemInfo);

        redeemInfo.newReservePositionUnit = _getRedeemPositionUnit(_setToken, _reserveAsset, redeemInfo);

        return redeemInfo;
    }

    /**
     * Transfer reserve asset from user to SetToken and fees from user to appropriate fee recipients
     */
    function _transferCollateralAndHandleFees(ISetToken _setToken, IERC20 _reserveAsset, ActionInfo memory _issueInfo) internal {
        transferFrom(_reserveAsset, msg.sender, address(_setToken), _issueInfo.netFlowQuantity);

        if (_issueInfo.protocolFees > 0) {
            transferFrom(_reserveAsset, msg.sender, controller.feeRecipient(), _issueInfo.protocolFees);
        }

        if (_issueInfo.managerFee > 0) {
            transferFrom(_reserveAsset, msg.sender, navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);
        }
    }


    /**
      * Transfer WETH from module to SetToken and fees from module to appropriate fee recipients
     */
    function _transferWETHAndHandleFees(ISetToken _setToken, ActionInfo memory _issueInfo) internal {
        weth.transfer(address(_setToken), _issueInfo.netFlowQuantity);

        if (_issueInfo.protocolFees > 0) {
            weth.transfer(controller.feeRecipient(), _issueInfo.protocolFees);
        }

        if (_issueInfo.managerFee > 0) {
            weth.transfer(navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);
        }
    }

    function _handleIssueStateUpdates(
        ISetToken _setToken,
        address _reserveAsset,
        address _to,
        ActionInfo memory _issueInfo
    )
        internal
    {
        _setToken.editPositionMultiplier(_issueInfo.newPositionMultiplier);

        _setToken.editDefaultPosition(_reserveAsset, _issueInfo.newReservePositionUnit);

        _setToken.mint(_to, _issueInfo.setTokenQuantity);

        emit SetTokenNAVIssued(
            _setToken,
            msg.sender,
            _to,
            _reserveAsset,
            address(navIssuanceSettings[_setToken].managerIssuanceHook),
            _issueInfo.setTokenQuantity,
            _issueInfo.managerFee,
            _issueInfo.protocolFees
        );
    }

    function _handleRedeemStateUpdates(
        ISetToken _setToken,
        address _reserveAsset,
        address _to,
        ActionInfo memory _redeemInfo
    )
        internal
    {
        _setToken.editPositionMultiplier(_redeemInfo.newPositionMultiplier);

        _setToken.editDefaultPosition(_reserveAsset, _redeemInfo.newReservePositionUnit);

        emit SetTokenNAVRedeemed(
            _setToken,
            msg.sender,
            _to,
            _reserveAsset,
            address(navIssuanceSettings[_setToken].managerRedemptionHook),
            _redeemInfo.setTokenQuantity,
            _redeemInfo.managerFee,
            _redeemInfo.protocolFees
        );
    }

    function _handleRedemptionFees(ISetToken _setToken, address _reserveAsset, ActionInfo memory _redeemInfo) internal {
        // Instruct the SetToken to transfer protocol fee to fee recipient if there is a fee
        payProtocolFeeFromSetToken(_setToken, _reserveAsset, _redeemInfo.protocolFees);

        // Instruct the SetToken to transfer manager fee to manager fee recipient if there is a fee
        if (_redeemInfo.managerFee > 0) {
            _setToken.strictInvokeTransfer(
                _reserveAsset,
                navIssuanceSettings[_setToken].feeRecipient,
                _redeemInfo.managerFee
            );
        }
    }

    /**
     * Returns the issue premium percentage. Virtual function that can be overridden in future versions of the module
     * and can contain arbitrary logic to calculate the issuance premium.
     */
    function _getIssuePremium(
        ISetToken _setToken,
        address /* _reserveAsset */,
        uint256 /* _reserveAssetQuantity */
    )
        virtual
        internal
        view
        returns (uint256)
    {
        return navIssuanceSettings[_setToken].premiumPercentage;
    }

    /**
     * Returns the redeem premium percentage. Virtual function that can be overridden in future versions of the module
     * and can contain arbitrary logic to calculate the redemption premium.
     */
    function _getRedeemPremium(
        ISetToken _setToken,
        address /* _reserveAsset */,
        uint256 /* _setTokenQuantity */
    )
        virtual
        internal
        view
        returns (uint256)
    {
        return navIssuanceSettings[_setToken].premiumPercentage;
    }

    /**
     * Returns the fees attributed to the manager and the protocol. The fees are calculated as follows:
     *
     * ManagerFee = (manager fee % - % to protocol) * reserveAssetQuantity
     * Protocol Fee = (% manager fee share + direct fee %) * reserveAssetQuantity
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAssetQuantity         Quantity of reserve asset to calculate fees from
     * @param _protocolManagerFeeIndex      Index to pull rev share NAV Issuance fee from the Controller
     * @param _protocolDirectFeeIndex       Index to pull direct NAV issuance fee from the Controller
     * @param _managerFeeIndex              Index from NAVIssuanceSettings (0 = issue fee, 1 = redeem fee)
     *
     * @return  uint256                     Fees paid to the protocol in reserve asset
     * @return  uint256                     Fees paid to the manager in reserve asset
     * @return  uint256                     Net reserve to user net of fees
     */
    function _getFees(
        ISetToken _setToken,
        uint256 _reserveAssetQuantity,
        uint256 _protocolManagerFeeIndex,
        uint256 _protocolDirectFeeIndex,
        uint256 _managerFeeIndex
    )
        internal
        view
        returns (uint256, uint256, uint256)
    {
        (uint256 protocolFeePercentage, uint256 managerFeePercentage) = _getProtocolAndManagerFeePercentages(
            _setToken,
            _protocolManagerFeeIndex,
            _protocolDirectFeeIndex,
            _managerFeeIndex
        );

        // Calculate total notional fees
        uint256 protocolFees = protocolFeePercentage.preciseMul(_reserveAssetQuantity);
        uint256 managerFee = managerFeePercentage.preciseMul(_reserveAssetQuantity);

        uint256 netReserveFlow = _reserveAssetQuantity.sub(protocolFees).sub(managerFee);

        return (protocolFees, managerFee, netReserveFlow);
    }

    function _getProtocolAndManagerFeePercentages(
        ISetToken _setToken,
        uint256 _protocolManagerFeeIndex,
        uint256 _protocolDirectFeeIndex,
        uint256 _managerFeeIndex
    )
        internal
        view
        returns(uint256, uint256)
    {
        // Get protocol fee percentages
        uint256 protocolDirectFeePercent = controller.getModuleFee(address(this), _protocolDirectFeeIndex);
        uint256 protocolManagerShareFeePercent = controller.getModuleFee(address(this), _protocolManagerFeeIndex);
        uint256 managerFeePercent = navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];

        // Calculate revenue share split percentage
        uint256 protocolRevenueSharePercentage = protocolManagerShareFeePercent.preciseMul(managerFeePercent);
        uint256 managerRevenueSharePercentage = managerFeePercent.sub(protocolRevenueSharePercentage);
        uint256 totalProtocolFeePercentage = protocolRevenueSharePercentage.add(protocolDirectFeePercent);

        return (totalProtocolFeePercentage, managerRevenueSharePercentage);
    }

    function _getSetTokenMintQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _netReserveFlows,            // Value of reserve asset net of fees
        uint256 _setTotalSupply
    )
        internal
        view
        returns (uint256)
    {
        uint256 premiumPercentage = _getIssuePremium(_setToken, _reserveAsset, _netReserveFlows);
        uint256 premiumValue = _netReserveFlows.preciseMul(premiumPercentage);

        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (1e18)
        // Reverts if price is not found
        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);

        // Get reserve asset decimals
        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();
        uint256 normalizedTotalReserveQuantityNetFees = _netReserveFlows.preciseDiv(10 ** reserveAssetDecimals);
        uint256 normalizedTotalReserveQuantityNetFeesAndPremium = _netReserveFlows.sub(premiumValue).preciseDiv(10 ** reserveAssetDecimals);

        // Calculate SetTokens to mint to issuer
        uint256 denominator = _setTotalSupply.preciseMul(setTokenValuation).add(normalizedTotalReserveQuantityNetFees).sub(normalizedTotalReserveQuantityNetFeesAndPremium);
        return normalizedTotalReserveQuantityNetFeesAndPremium.preciseMul(_setTotalSupply).preciseDiv(denominator);
    }

    function _getRedeemReserveQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        internal
        view
        returns (uint256)
    {
        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (10e18)
        // Reverts if price is not found
        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);

        uint256 totalRedeemValueInPreciseUnits = _setTokenQuantity.preciseMul(setTokenValuation);
        // Get reserve asset decimals
        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();
        uint256 prePremiumReserveQuantity = totalRedeemValueInPreciseUnits.preciseMul(10 ** reserveAssetDecimals);

        uint256 premiumPercentage = _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);
        uint256 premiumQuantity = prePremiumReserveQuantity.preciseMulCeil(premiumPercentage);

        return prePremiumReserveQuantity.sub(premiumQuantity);
    }

    /**
     * The new position multiplier is calculated as follows:
     * inflationPercentage = (newSupply - oldSupply) / newSupply
     * newMultiplier = (1 - inflationPercentage) * positionMultiplier
     */
    function _getIssuePositionMultiplier(
        ISetToken _setToken,
        ActionInfo memory _issueInfo
    )
        internal
        view
        returns (uint256, int256)
    {
        // Calculate inflation and new position multiplier. Note: Round inflation up in order to round position multiplier down
        uint256 newTotalSupply = _issueInfo.setTokenQuantity.add(_issueInfo.previousSetTokenSupply);
        int256 newPositionMultiplier = _setToken.positionMultiplier()
            .mul(_issueInfo.previousSetTokenSupply.toInt256())
            .div(newTotalSupply.toInt256());

        return (newTotalSupply, newPositionMultiplier);
    }

    /**
     * Calculate deflation and new position multiplier. Note: Round deflation down in order to round position multiplier down
     *
     * The new position multiplier is calculated as follows:
     * deflationPercentage = (oldSupply - newSupply) / newSupply
     * newMultiplier = (1 + deflationPercentage) * positionMultiplier
     */
    function _getRedeemPositionMultiplier(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        ActionInfo memory _redeemInfo
    )
        internal
        view
        returns (uint256, int256)
    {
        uint256 newTotalSupply = _redeemInfo.previousSetTokenSupply.sub(_setTokenQuantity);
        int256 newPositionMultiplier = _setToken.positionMultiplier()
            .mul(_redeemInfo.previousSetTokenSupply.toInt256())
            .div(newTotalSupply.toInt256());

        return (newTotalSupply, newPositionMultiplier);
    }

    /**
     * The new position reserve asset unit is calculated as follows:
     * totalReserve = (oldUnit * oldSetTokenSupply) + reserveQuantity
     * newUnit = totalReserve / newSetTokenSupply
     */
    function _getIssuePositionUnit(
        ISetToken _setToken,
        address _reserveAsset,
        ActionInfo memory _issueInfo
    )
        internal
        view
        returns (uint256)
    {
        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();
        uint256 totalReserve = existingUnit
            .preciseMul(_issueInfo.previousSetTokenSupply)
            .add(_issueInfo.netFlowQuantity);

        return totalReserve.preciseDiv(_issueInfo.newSetTokenSupply);
    }

    /**
     * The new position reserve asset unit is calculated as follows:
     * totalReserve = (oldUnit * oldSetTokenSupply) - reserveQuantityToSendOut
     * newUnit = totalReserve / newSetTokenSupply
     */
    function _getRedeemPositionUnit(
        ISetToken _setToken,
        address _reserveAsset,
        ActionInfo memory _redeemInfo
    )
        internal
        view
        returns (uint256)
    {
        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();
        uint256 totalExistingUnits = existingUnit.preciseMul(_redeemInfo.previousSetTokenSupply);

        uint256 outflow = _redeemInfo.netFlowQuantity.add(_redeemInfo.protocolFees).add(_redeemInfo.managerFee);

        // Require withdrawable quantity is greater than existing collateral
        require(totalExistingUnits >= outflow, "Must be greater than total available collateral");

        return totalExistingUnits.sub(outflow).preciseDiv(_redeemInfo.newSetTokenSupply);
    }

    /**
     * If a pre-issue hook has been configured, call the external-protocol contract. Pre-issue hook logic
     * can contain arbitrary logic including validations, external function calls, etc.
     */
    function _callPreIssueHooks(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity,
        address _caller,
        address _to
    )
        internal
    {
        INAVIssuanceHook preIssueHook = navIssuanceSettings[_setToken].managerIssuanceHook;
        if (address(preIssueHook) != address(0)) {
            preIssueHook.invokePreIssueHook(_setToken, _reserveAsset, _reserveAssetQuantity, _caller, _to);
        }
    }

    /**
     * If a pre-redeem hook has been configured, call the external-protocol contract.
     */
    function _callPreRedeemHooks(ISetToken _setToken, uint256 _setQuantity, address _caller, address _to) internal {
        INAVIssuanceHook preRedeemHook = navIssuanceSettings[_setToken].managerRedemptionHook;
        if (address(preRedeemHook) != address(0)) {
            preRedeemHook.invokePreRedeemHook(_setToken, _setQuantity, _caller, _to);
        }
    }
}.]

Security

[2024-01-09 05:31:18 INFO] **[Seminar Conclusion]**:

 Security

[2024-01-09 05:31:18 INFO] **[Seminar Conclusion]**:

 <INFO> Security

[2024-01-09 05:31:18 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 1

[2024-01-09 05:31:19 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /*     Copyright 2020 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol"; import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol"; import { SignedSafeMath } from "@openzeppelin/contracts/math/SignedSafeMath.sol"; import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol"; import { IController } from "../../interfaces/IController.sol"; import { INAVIssuanceHook } from "../../interfaces/INAVIssuanceHook.sol"; import { Invoke } from "../lib/Invoke.sol"; import { ISetToken } from "../../interfaces/ISetToken.sol"; import { IWETH } from "../../interfaces/external/IWETH.sol"; import { ModuleBase } from "../lib/ModuleBase.sol"; import { Position } from "../lib/Position.sol"; import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol"; import { ResourceIdentifier } from "../lib/ResourceIdentifier.sol"; /*  * @title NavIssuanceModule  * @author Set Protocol  *  * Module that enables issuance and redemption with any valid ERC20 token or ETH if allowed by the manager. Sender receives  * a proportional amount of SetTokens on issuance or ERC20 token on redemption based on the calculated net asset value using  * oracle prices. Manager is able to enforce a premium / discount on issuance / redemption to avoid arbitrage and front  * running when relying on oracle prices. Managers can charge a fee (denominated in reserve asset).  / contract NavIssuanceModule is ModuleBase, ReentrancyGuard {     using AddressArrayUtils for address[];     using Invoke for ISetToken;     using Position for ISetToken;     using PreciseUnitMath for uint256;     using PreciseUnitMath for int256;     using ResourceIdentifier for IController;     using SafeMath for uint256;     using SafeCast for int256;     using SafeCast for uint256;     using SignedSafeMath for int256; /* ============ Events ============ */  event SetTokenNAVIssued(     ISetToken indexed _setToken,     address _issuer,     address _to,     address _reserveAsset,     address _hookContract,     uint256 _setTokenQuantity,     uint256 _managerFee,     uint256 _premium );  event SetTokenNAVRedeemed(     ISetToken indexed _setToken,     address _redeemer,     address _to,     address _reserveAsset,     address _hookContract,     uint256 _setTokenQuantity,     uint256 _managerFee,     uint256 _premium );  event ReserveAssetAdded(     ISetToken indexed _setToken,     address _newReserveAsset );  event ReserveAssetRemoved(     ISetToken indexed _setToken,     address _removedReserveAsset );  event PremiumEdited(     ISetToken indexed _setToken,     uint256 _newPremium );  event ManagerFeeEdited(     ISetToken indexed _setToken,     uint256 _newManagerFee,     uint256 _index );  event FeeRecipientEdited(     ISetToken indexed _setToken,     address _feeRecipient );  /* ============ Structs ============ */  struct NAVIssuanceSettings {     INAVIssuanceHook managerIssuanceHook;      // Issuance hook configurations     INAVIssuanceHook managerRedemptionHook;    // Redemption hook configurations     address[] reserveAssets;                       // Allowed reserve assets - Must have a price enabled with the price oracle     address feeRecipient;                          // Manager fee recipient     uint256[2] managerFees;                        // Manager fees. 0 index is issue and 1 index is redeem fee (0.01% = 1e14, 1% = 1e16)     uint256 maxManagerFee;                         // Maximum fee manager is allowed to set for issue and redeem     uint256 premiumPercentage;                     // Premium percentage (0.01% = 1e14, 1% = 1e16). This premium is a buffer around oracle                                                    // prices paid by user to the SetToken, which prevents arbitrage and oracle front running     uint256 maxPremiumPercentage;                  // Maximum premium percentage manager is allowed to set (configured by manager)     uint256 minSetTokenSupply;                     // Minimum SetToken supply required for issuance and redemption                                                    // to prevent dramatic inflationary changes to the SetToken's position multiplier }  struct ActionInfo {     uint256 preFeeReserveQuantity;                 // Reserve value before fees; During issuance, represents raw quantity                                                    // During redeem, represents post-premium value     uint256 protocolFees;                          // Total protocol fees (direct + manager revenue share)     uint256 managerFee;                            // Total manager fee paid in reserve asset     uint256 netFlowQuantity;                       // When issuing, quantity of reserve asset sent to SetToken                                                    // When redeeming, quantity of reserve asset sent to redeemer     uint256 setTokenQuantity;                      // When issuing, quantity of SetTokens minted to mintee                                                    // When redeeming, quantity of SetToken redeemed     uint256 previousSetTokenSupply;                // SetToken supply prior to issue/redeem action     uint256 newSetTokenSupply;                     // SetToken supply after issue/redeem action     int256 newPositionMultiplier;                  // SetToken position multiplier after issue/redeem     uint256 newReservePositionUnit;                // SetToken reserve asset position unit after issue/redeem }  /* ============ State Variables ============ */  // Wrapped ETH address IWETH public immutable weth;  // Mapping of SetToken to NAV issuance settings struct mapping(ISetToken =&gt; NAVIssuanceSettings) public navIssuanceSettings;  // Mapping to efficiently check a SetToken's reserve asset validity // SetToken =&gt; reserveAsset =&gt; isReserveAsset mapping(ISetToken =&gt; mapping(address =&gt; bool)) public isReserveAsset;  /* ============ Constants ============ */  // 0 index stores the manager fee in managerFees array, percentage charged on issue (denominated in reserve asset) uint256 constant internal MANAGER_ISSUE_FEE_INDEX = 0;  // 1 index stores the manager fee percentage in managerFees array, charged on redeem uint256 constant internal MANAGER_REDEEM_FEE_INDEX = 1;  // 0 index stores the manager revenue share protocol fee % on the controller, charged in the issuance function uint256 constant internal PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX = 0;  // 1 index stores the manager revenue share protocol fee % on the controller, charged in the redeem function uint256 constant internal PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX = 1;  // 2 index stores the direct protocol fee % on the controller, charged in the issuance function uint256 constant internal PROTOCOL_ISSUE_DIRECT_FEE_INDEX = 2;  // 3 index stores the direct protocol fee % on the controller, charged in the redeem function uint256 constant internal PROTOCOL_REDEEM_DIRECT_FEE_INDEX = 3;  /* ============ Constructor ============ */  /**  * @param _controller               Address of controller contract  * @param _weth                     Address of wrapped eth  */ constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {     weth = _weth; }  /* ============ External Functions ============ */  /**  * Deposits the allowed reserve asset into the SetToken and mints the appropriate % of Net Asset Value of the SetToken  * to the specified _to address.  *  * @param _setToken                     Instance of the SetToken contract  * @param _reserveAsset                 Address of the reserve asset to issue with  * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with  * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance  * @param _to                           Address to mint SetToken to  */ function issue(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity,     uint256 _minSetTokenReceiveQuantity,     address _to )     external     nonReentrant     onlyValidAndInitializedSet(_setToken) {     _validateCommon(_setToken, _reserveAsset, _reserveAssetQuantity);      _callPreIssueHooks(_setToken, _reserveAsset, _reserveAssetQuantity, msg.sender, _to);      ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, _reserveAsset, _reserveAssetQuantity);      _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);      _transferCollateralAndHandleFees(_setToken, IERC20(_reserveAsset), issueInfo);      _handleIssueStateUpdates(_setToken, _reserveAsset, _to, issueInfo); }  /**  * Wraps ETH and deposits WETH if allowed into the SetToken and mints the appropriate % of Net Asset Value of the SetToken  * to the specified _to address.  *  * @param _setToken                     Instance of the SetToken contract  * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance  * @param _to                           Address to mint SetToken to  */ function issueWithEther(     ISetToken _setToken,     uint256 _minSetTokenReceiveQuantity,     address _to )     external     payable     nonReentrant     onlyValidAndInitializedSet(_setToken) {     weth.deposit{ value: msg.value }();      _validateCommon(_setToken, address(weth), msg.value);      _callPreIssueHooks(_setToken, address(weth), msg.value, msg.sender, _to);      ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, address(weth), msg.value);      _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);      _transferWETHAndHandleFees(_setToken, issueInfo);      _handleIssueStateUpdates(_setToken, address(weth), _to, issueInfo); }  /**  * Redeems a SetToken into a valid reserve asset representing the appropriate % of Net Asset Value of the SetToken  * to the specified _to address. Only valid if there are available reserve units on the SetToken.  *  * @param _setToken                     Instance of the SetToken contract  * @param _reserveAsset                 Address of the reserve asset to redeem with  * @param _setTokenQuantity             Quantity of SetTokens to redeem  * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive  * @param _to                           Address to redeem reserve asset to  */ function redeem(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity,     uint256 _minReserveReceiveQuantity,     address _to )     external     nonReentrant     onlyValidAndInitializedSet(_setToken) {     _validateCommon(_setToken, _reserveAsset, _setTokenQuantity);      _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);      ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, _reserveAsset, _setTokenQuantity);      _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);      _setToken.burn(msg.sender, _setTokenQuantity);      // Instruct the SetToken to transfer the reserve asset back to the user     _setToken.strictInvokeTransfer(         _reserveAsset,         _to,         redeemInfo.netFlowQuantity     );      _handleRedemptionFees(_setToken, _reserveAsset, redeemInfo);      _handleRedeemStateUpdates(_setToken, _reserveAsset, _to, redeemInfo); }  /**  * Redeems a SetToken into Ether (if WETH is valid) representing the appropriate % of Net Asset Value of the SetToken  * to the specified _to address. Only valid if there are available WETH units on the SetToken.  *  * @param _setToken                     Instance of the SetToken contract  * @param _setTokenQuantity             Quantity of SetTokens to redeem  * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive  * @param _to                           Address to redeem reserve asset to  */ function redeemIntoEther(     ISetToken _setToken,     uint256 _setTokenQuantity,     uint256 _minReserveReceiveQuantity,     address payable _to )     external     nonReentrant     onlyValidAndInitializedSet(_setToken) {     _validateCommon(_setToken, address(weth), _setTokenQuantity);      _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);      ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, address(weth), _setTokenQuantity);      _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);      _setToken.burn(msg.sender, _setTokenQuantity);      // Instruct the SetToken to transfer WETH from SetToken to module     _setToken.strictInvokeTransfer(         address(weth),         address(this),         redeemInfo.netFlowQuantity     );      weth.withdraw(redeemInfo.netFlowQuantity);      _to.transfer(redeemInfo.netFlowQuantity);      _handleRedemptionFees(_setToken, address(weth), redeemInfo);      _handleRedeemStateUpdates(_setToken, address(weth), _to, redeemInfo); }  /**  * SET MANAGER ONLY. Add an allowed reserve asset  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset to add  */ function addReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {     require(!isReserveAsset[_setToken][_reserveAsset], "Reserve asset already exists");      navIssuanceSettings[_setToken].reserveAssets.push(_reserveAsset);     isReserveAsset[_setToken][_reserveAsset] = true;      emit ReserveAssetAdded(_setToken, _reserveAsset); }  /**  * SET MANAGER ONLY. Remove a reserve asset  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset to remove  */ function removeReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {     require(isReserveAsset[_setToken][_reserveAsset], "Reserve asset does not exist");      navIssuanceSettings[_setToken].reserveAssets = navIssuanceSettings[_setToken].reserveAssets.remove(_reserveAsset);     delete isReserveAsset[_setToken][_reserveAsset];      emit ReserveAssetRemoved(_setToken, _reserveAsset); }  /**  * SET MANAGER ONLY. Edit the premium percentage  *  * @param _setToken                     Instance of the SetToken  * @param _premiumPercentage            Premium percentage in 10e16 (e.g. 10e16 = 1%)  */ function editPremium(ISetToken _setToken, uint256 _premiumPercentage) external onlyManagerAndValidSet(_setToken) {     require(_premiumPercentage &lt;= navIssuanceSettings[_setToken].maxPremiumPercentage, "Premium must be less than maximum allowed");      navIssuanceSettings[_setToken].premiumPercentage = _premiumPercentage;      emit PremiumEdited(_setToken, _premiumPercentage); }  /**  * SET MANAGER ONLY. Edit manager fee  *  * @param _setToken                     Instance of the SetToken  * @param _managerFeePercentage         Manager fee percentage in 10e16 (e.g. 10e16 = 1%)  * @param _managerFeeIndex              Manager fee index. 0 index is issue fee, 1 index is redeem fee  */ function editManagerFee(     ISetToken _setToken,     uint256 _managerFeePercentage,     uint256 _managerFeeIndex )     external     onlyManagerAndValidSet(_setToken) {     require(_managerFeePercentage &lt;= navIssuanceSettings[_setToken].maxManagerFee, "Manager fee must be less than maximum allowed");      navIssuanceSettings[_setToken].managerFees[_managerFeeIndex] = _managerFeePercentage;      emit ManagerFeeEdited(_setToken, _managerFeePercentage, _managerFeeIndex); }  /**  * SET MANAGER ONLY. Edit the manager fee recipient  *  * @param _setToken                     Instance of the SetToken  * @param _managerFeeRecipient          Manager fee recipient  */ function editFeeRecipient(ISetToken _setToken, address _managerFeeRecipient) external onlyManagerAndValidSet(_setToken) {     require(_managerFeeRecipient != address(0), "Fee recipient must not be 0 address");      navIssuanceSettings[_setToken].feeRecipient = _managerFeeRecipient;      emit FeeRecipientEdited(_setToken, _managerFeeRecipient); }  /**  * SET MANAGER ONLY. Initializes this module to the SetToken with hooks, allowed reserve assets,  * fees and issuance premium. Only callable by the SetToken's manager. Hook addresses are optional.  * Address(0) means that no hook will be called.  *  * @param _setToken                     Instance of the SetToken to issue  * @param _navIssuanceSettings          NAVIssuanceSettings struct defining parameters  */ function initialize(     ISetToken _setToken,     NAVIssuanceSettings memory _navIssuanceSettings )     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     require(_navIssuanceSettings.reserveAssets.length &gt; 0, "Reserve assets must be greater than 0");     require(_navIssuanceSettings.maxManagerFee &lt; PreciseUnitMath.preciseUnit(), "Max manager fee must be less than 100%");     require(_navIssuanceSettings.maxPremiumPercentage &lt; PreciseUnitMath.preciseUnit(), "Max premium percentage must be less than 100%");     require(_navIssuanceSettings.managerFees[0] &lt;= _navIssuanceSettings.maxManagerFee, "Manager issue fee must be less than max");     require(_navIssuanceSettings.managerFees[1] &lt;= _navIssuanceSettings.maxManagerFee, "Manager redeem fee must be less than max");     require(_navIssuanceSettings.premiumPercentage &lt;= _navIssuanceSettings.maxPremiumPercentage, "Premium must be less than max");     require(_navIssuanceSettings.feeRecipient != address(0), "Fee Recipient must be non-zero address.");     // Initial mint of Set cannot use NAVIssuance since minSetTokenSupply must be &gt; 0     require(_navIssuanceSettings.minSetTokenSupply &gt; 0, "Min SetToken supply must be greater than 0");      for (uint256 i = 0; i &lt; _navIssuanceSettings.reserveAssets.length; i++) {         require(!isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]], "Reserve assets must be unique");         isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]] = true;     }      navIssuanceSettings[_setToken] = _navIssuanceSettings;      _setToken.initializeModule(); }  /**  * Removes this module from the SetToken, via call by the SetToken. Issuance settings and  * reserve asset states are deleted.  */ function removeModule() external override {     ISetToken setToken = ISetToken(msg.sender);     for (uint256 i = 0; i &lt; navIssuanceSettings[setToken].reserveAssets.length; i++) {         delete isReserveAsset[setToken][navIssuanceSettings[setToken].reserveAssets[i]];     }      delete navIssuanceSettings[setToken]; }  receive() external payable {}  /* ============ External Getter Functions ============ */  function getReserveAssets(ISetToken _setToken) external view returns (address[] memory) {     return navIssuanceSettings[_setToken].reserveAssets; }  function getIssuePremium(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     external     view     returns (uint256) {     return _getIssuePremium(_setToken, _reserveAsset, _reserveAssetQuantity); }  function getRedeemPremium(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     external     view     returns (uint256) {     return _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity); }  function getManagerFee(ISetToken _setToken, uint256 _managerFeeIndex) external view returns (uint256) {     return navIssuanceSettings[_setToken].managerFees[_managerFeeIndex]; }  /**  * Get the expected SetTokens minted to recipient on issuance  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with  *  * @return  uint256                     Expected SetTokens to be minted to recipient  */ function getExpectedSetTokenIssueQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     external     view     returns (uint256) {     (,, uint256 netReserveFlow) = _getFees(         _setToken,         _reserveAssetQuantity,         PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_ISSUE_DIRECT_FEE_INDEX,         MANAGER_ISSUE_FEE_INDEX     );      uint256 setTotalSupply = _setToken.totalSupply();      return _getSetTokenMintQuantity(         _setToken,         _reserveAsset,         netReserveFlow,         setTotalSupply     ); }  /**  * Get the expected reserve asset to be redeemed  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _setTokenQuantity             Quantity of SetTokens to redeem  *  * @return  uint256                     Expected reserve asset quantity redeemed  */ function getExpectedReserveRedeemQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     external     view     returns (uint256) {     uint256 preFeeReserveQuantity = _getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);      (,, uint256 netReserveFlows) = _getFees(         _setToken,         preFeeReserveQuantity,         PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_REDEEM_DIRECT_FEE_INDEX,         MANAGER_REDEEM_FEE_INDEX     );      return netReserveFlows; }  /**  * Checks if issue is valid  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with  *  * @return  bool                        Returns true if issue is valid  */ function isIssueValid(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     external     view     returns (bool) {     uint256 setTotalSupply = _setToken.totalSupply();  return _reserveAssetQuantity != 0         &amp;&amp; isReserveAsset[_setToken][_reserveAsset]         &amp;&amp; setTotalSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply; }  /**  * Checks if redeem is valid  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _setTokenQuantity             Quantity of SetTokens to redeem  *  * @return  bool                        Returns true if redeem is valid  */ function isRedeemValid(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     external     view     returns (bool) {     uint256 setTotalSupply = _setToken.totalSupply();      if (         _setTokenQuantity == 0         || !isReserveAsset[_setToken][_reserveAsset]         || setTotalSupply &lt; navIssuanceSettings[_setToken].minSetTokenSupply.add(_setTokenQuantity)     ) {         return false;     } else {         uint256 totalRedeemValue =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);          (,, uint256 expectedRedeemQuantity) = _getFees(             _setToken,             totalRedeemValue,             PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,             PROTOCOL_REDEEM_DIRECT_FEE_INDEX,             MANAGER_REDEEM_FEE_INDEX         );          uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();          return existingUnit.preciseMul(setTotalSupply) &gt;= expectedRedeemQuantity;     } }  /* ============ Internal Functions ============ */  function _validateCommon(ISetToken _setToken, address _reserveAsset, uint256 _quantity) internal view {     require(_quantity &gt; 0, "Quantity must be &gt; 0");     require(isReserveAsset[_setToken][_reserveAsset], "Must be valid reserve asset"); }  function _validateIssuanceInfo(ISetToken _setToken, uint256 _minSetTokenReceiveQuantity, ActionInfo memory _issueInfo) internal view {     // Check that total supply is greater than min supply needed for issuance     // Note: A min supply amount is needed to avoid division by 0 when SetToken supply is 0     require(         _issueInfo.previousSetTokenSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply,         "Supply must be greater than minimum to enable issuance"     );      require(_issueInfo.setTokenQuantity &gt;= _minSetTokenReceiveQuantity, "Must be greater than min SetToken"); }  function _validateRedemptionInfo(     ISetToken _setToken,     uint256 _minReserveReceiveQuantity,     ActionInfo memory _redeemInfo )     internal     view {     // Check that new supply is more than min supply needed for redemption     // Note: A min supply amount is needed to avoid division by 0 when redeeming SetToken to 0     require(         _redeemInfo.newSetTokenSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply,         "Supply must be greater than minimum to enable redemption"     );      require(_redeemInfo.netFlowQuantity &gt;= _minReserveReceiveQuantity, "Must be greater than min receive reserve quantity"); }  function _createIssuanceInfo(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     internal     view     returns (ActionInfo memory) {     ActionInfo memory issueInfo;      issueInfo.previousSetTokenSupply = _setToken.totalSupply();      issueInfo.preFeeReserveQuantity = _reserveAssetQuantity;      (issueInfo.protocolFees, issueInfo.managerFee, issueInfo.netFlowQuantity) = _getFees(         _setToken,         issueInfo.preFeeReserveQuantity,         PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_ISSUE_DIRECT_FEE_INDEX,         MANAGER_ISSUE_FEE_INDEX     );      issueInfo.setTokenQuantity = _getSetTokenMintQuantity(         _setToken,         _reserveAsset,         issueInfo.netFlowQuantity,         issueInfo.previousSetTokenSupply     );      (issueInfo.newSetTokenSupply, issueInfo.newPositionMultiplier) = _getIssuePositionMultiplier(_setToken, issueInfo);      issueInfo.newReservePositionUnit = _getIssuePositionUnit(_setToken, _reserveAsset, issueInfo);      return issueInfo; }  function _createRedemptionInfo(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     internal     view     returns (ActionInfo memory) {     ActionInfo memory redeemInfo;      redeemInfo.setTokenQuantity = _setTokenQuantity;      redeemInfo.preFeeReserveQuantity =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);      (redeemInfo.protocolFees, redeemInfo.managerFee, redeemInfo.netFlowQuantity) = _getFees(         _setToken,         redeemInfo.preFeeReserveQuantity,         PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_REDEEM_DIRECT_FEE_INDEX,         MANAGER_REDEEM_FEE_INDEX     );      redeemInfo.previousSetTokenSupply = _setToken.totalSupply();      (redeemInfo.newSetTokenSupply, redeemInfo.newPositionMultiplier) = _getRedeemPositionMultiplier(_setToken, _setTokenQuantity, redeemInfo);      redeemInfo.newReservePositionUnit = _getRedeemPositionUnit(_setToken, _reserveAsset, redeemInfo);      return redeemInfo; }  /**  * Transfer reserve asset from user to SetToken and fees from user to appropriate fee recipients  */ function _transferCollateralAndHandleFees(ISetToken _setToken, IERC20 _reserveAsset, ActionInfo memory _issueInfo) internal {     transferFrom(_reserveAsset, msg.sender, address(_setToken), _issueInfo.netFlowQuantity);      if (_issueInfo.protocolFees &gt; 0) {         transferFrom(_reserveAsset, msg.sender, controller.feeRecipient(), _issueInfo.protocolFees);     }      if (_issueInfo.managerFee &gt; 0) {         transferFrom(_reserveAsset, msg.sender, navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);     } }   /**   * Transfer WETH from module to SetToken and fees from module to appropriate fee recipients  */ function _transferWETHAndHandleFees(ISetToken _setToken, ActionInfo memory _issueInfo) internal {     weth.transfer(address(_setToken), _issueInfo.netFlowQuantity);      if (_issueInfo.protocolFees &gt; 0) {         weth.transfer(controller.feeRecipient(), _issueInfo.protocolFees);     }      if (_issueInfo.managerFee &gt; 0) {         weth.transfer(navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);     } }  function _handleIssueStateUpdates(     ISetToken _setToken,     address _reserveAsset,     address _to,     ActionInfo memory _issueInfo )     internal {     _setToken.editPositionMultiplier(_issueInfo.newPositionMultiplier);      _setToken.editDefaultPosition(_reserveAsset, _issueInfo.newReservePositionUnit);      _setToken.mint(_to, _issueInfo.setTokenQuantity);      emit SetTokenNAVIssued(         _setToken,         msg.sender,         _to,         _reserveAsset,         address(navIssuanceSettings[_setToken].managerIssuanceHook),         _issueInfo.setTokenQuantity,         _issueInfo.managerFee,         _issueInfo.protocolFees     ); }  function _handleRedeemStateUpdates(     ISetToken _setToken,     address _reserveAsset,     address _to,     ActionInfo memory _redeemInfo )     internal {     _setToken.editPositionMultiplier(_redeemInfo.newPositionMultiplier);      _setToken.editDefaultPosition(_reserveAsset, _redeemInfo.newReservePositionUnit);      emit SetTokenNAVRedeemed(         _setToken,         msg.sender,         _to,         _reserveAsset,         address(navIssuanceSettings[_setToken].managerRedemptionHook),         _redeemInfo.setTokenQuantity,         _redeemInfo.managerFee,         _redeemInfo.protocolFees     ); }  function _handleRedemptionFees(ISetToken _setToken, address _reserveAsset, ActionInfo memory _redeemInfo) internal {     // Instruct the SetToken to transfer protocol fee to fee recipient if there is a fee     payProtocolFeeFromSetToken(_setToken, _reserveAsset, _redeemInfo.protocolFees);      // Instruct the SetToken to transfer manager fee to manager fee recipient if there is a fee     if (_redeemInfo.managerFee &gt; 0) {         _setToken.strictInvokeTransfer(             _reserveAsset,             navIssuanceSettings[_setToken].feeRecipient,             _redeemInfo.managerFee         );     } }  /**  * Returns the issue premium percentage. Virtual function that can be overridden in future versions of the module  * and can contain arbitrary logic to calculate the issuance premium.  */ function _getIssuePremium(     ISetToken _setToken,     address /* _reserveAsset */,     uint256 /* _reserveAssetQuantity */ )     virtual     internal     view     returns (uint256) {     return navIssuanceSettings[_setToken].premiumPercentage; }  /**  * Returns the redeem premium percentage. Virtual function that can be overridden in future versions of the module  * and can contain arbitrary logic to calculate the redemption premium.  */ function _getRedeemPremium(     ISetToken _setToken,     address /* _reserveAsset */,     uint256 /* _setTokenQuantity */ )     virtual     internal     view     returns (uint256) {     return navIssuanceSettings[_setToken].premiumPercentage; }  /**  * Returns the fees attributed to the manager and the protocol. The fees are calculated as follows:  *  * ManagerFee = (manager fee % - % to protocol) * reserveAssetQuantity  * Protocol Fee = (% manager fee share + direct fee %) * reserveAssetQuantity  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAssetQuantity         Quantity of reserve asset to calculate fees from  * @param _protocolManagerFeeIndex      Index to pull rev share NAV Issuance fee from the Controller  * @param _protocolDirectFeeIndex       Index to pull direct NAV issuance fee from the Controller  * @param _managerFeeIndex              Index from NAVIssuanceSettings (0 = issue fee, 1 = redeem fee)  *  * @return  uint256                     Fees paid to the protocol in reserve asset  * @return  uint256                     Fees paid to the manager in reserve asset  * @return  uint256                     Net reserve to user net of fees  */ function _getFees(     ISetToken _setToken,     uint256 _reserveAssetQuantity,     uint256 _protocolManagerFeeIndex,     uint256 _protocolDirectFeeIndex,     uint256 _managerFeeIndex )     internal     view     returns (uint256, uint256, uint256) {     (uint256 protocolFeePercentage, uint256 managerFeePercentage) = _getProtocolAndManagerFeePercentages(         _setToken,         _protocolManagerFeeIndex,         _protocolDirectFeeIndex,         _managerFeeIndex     );      // Calculate total notional fees     uint256 protocolFees = protocolFeePercentage.preciseMul(_reserveAssetQuantity);     uint256 managerFee = managerFeePercentage.preciseMul(_reserveAssetQuantity);      uint256 netReserveFlow = _reserveAssetQuantity.sub(protocolFees).sub(managerFee);      return (protocolFees, managerFee, netReserveFlow); }  function _getProtocolAndManagerFeePercentages(     ISetToken _setToken,     uint256 _protocolManagerFeeIndex,     uint256 _protocolDirectFeeIndex,     uint256 _managerFeeIndex )     internal     view     returns(uint256, uint256) {     // Get protocol fee percentages     uint256 protocolDirectFeePercent = controller.getModuleFee(address(this), _protocolDirectFeeIndex);     uint256 protocolManagerShareFeePercent = controller.getModuleFee(address(this), _protocolManagerFeeIndex);     uint256 managerFeePercent = navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];      // Calculate revenue share split percentage     uint256 protocolRevenueSharePercentage = protocolManagerShareFeePercent.preciseMul(managerFeePercent);     uint256 managerRevenueSharePercentage = managerFeePercent.sub(protocolRevenueSharePercentage);     uint256 totalProtocolFeePercentage = protocolRevenueSharePercentage.add(protocolDirectFeePercent);      return (totalProtocolFeePercentage, managerRevenueSharePercentage); }  function _getSetTokenMintQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _netReserveFlows,            // Value of reserve asset net of fees     uint256 _setTotalSupply )     internal     view     returns (uint256) {     uint256 premiumPercentage = _getIssuePremium(_setToken, _reserveAsset, _netReserveFlows);     uint256 premiumValue = _netReserveFlows.preciseMul(premiumPercentage);      // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (1e18)     // Reverts if price is not found     uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);      // Get reserve asset decimals     uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();     uint256 normalizedTotalReserveQuantityNetFees = _netReserveFlows.preciseDiv(10 ** reserveAssetDecimals);     uint256 normalizedTotalReserveQuantityNetFeesAndPremium = _netReserveFlows.sub(premiumValue).preciseDiv(10 ** reserveAssetDecimals);      // Calculate SetTokens to mint to issuer     uint256 denominator = _setTotalSupply.preciseMul(setTokenValuation).add(normalizedTotalReserveQuantityNetFees).sub(normalizedTotalReserveQuantityNetFeesAndPremium);     return normalizedTotalReserveQuantityNetFeesAndPremium.preciseMul(_setTotalSupply).preciseDiv(denominator); }  function _getRedeemReserveQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     internal     view     returns (uint256) {     // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (10e18)     // Reverts if price is not found     uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);      uint256 totalRedeemValueInPreciseUnits = _setTokenQuantity.preciseMul(setTokenValuation);     // Get reserve asset decimals     uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();     uint256 prePremiumReserveQuantity = totalRedeemValueInPreciseUnits.preciseMul(10 ** reserveAssetDecimals);      uint256 premiumPercentage = _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);     uint256 premiumQuantity = prePremiumReserveQuantity.preciseMulCeil(premiumPercentage);      return prePremiumReserveQuantity.sub(premiumQuantity); }  /**  * The new position multiplier is calculated as follows:  * inflationPercentage = (newSupply - oldSupply) / newSupply  * newMultiplier = (1 - inflationPercentage) * positionMultiplier  */ function _getIssuePositionMultiplier(     ISetToken _setToken,     ActionInfo memory _issueInfo )     internal     view     returns (uint256, int256) {     // Calculate inflation and new position multiplier. Note: Round inflation up in order to round position multiplier down     uint256 newTotalSupply = _issueInfo.setTokenQuantity.add(_issueInfo.previousSetTokenSupply);     int256 newPositionMultiplier = _setToken.positionMultiplier()         .mul(_issueInfo.previousSetTokenSupply.toInt256())         .div(newTotalSupply.toInt256());      return (newTotalSupply, newPositionMultiplier); }  /**  * Calculate deflation and new position multiplier. Note: Round deflation down in order to round position multiplier down  *  * The new position multiplier is calculated as follows:  * deflationPercentage = (oldSupply - newSupply) / newSupply  * newMultiplier = (1 + deflationPercentage) * positionMultiplier  */ function _getRedeemPositionMultiplier(     ISetToken _setToken,     uint256 _setTokenQuantity,     ActionInfo memory _redeemInfo )     internal     view     returns (uint256, int256) {     uint256 newTotalSupply = _redeemInfo.previousSetTokenSupply.sub(_setTokenQuantity);     int256 newPositionMultiplier = _setToken.positionMultiplier()         .mul(_redeemInfo.previousSetTokenSupply.toInt256())         .div(newTotalSupply.toInt256());      return (newTotalSupply, newPositionMultiplier); }  /**  * The new position reserve asset unit is calculated as follows:  * totalReserve = (oldUnit * oldSetTokenSupply) + reserveQuantity  * newUnit = totalReserve / newSetTokenSupply  */ function _getIssuePositionUnit(     ISetToken _setToken,     address _reserveAsset,     ActionInfo memory _issueInfo )     internal     view     returns (uint256) {     uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();     uint256 totalReserve = existingUnit         .preciseMul(_issueInfo.previousSetTokenSupply)         .add(_issueInfo.netFlowQuantity);      return totalReserve.preciseDiv(_issueInfo.newSetTokenSupply); }  /**  * The new position reserve asset unit is calculated as follows:  * totalReserve = (oldUnit * oldSetTokenSupply) - reserveQuantityToSendOut  * newUnit = totalReserve / newSetTokenSupply  */ function _getRedeemPositionUnit(     ISetToken _setToken,     address _reserveAsset,     ActionInfo memory _redeemInfo )     internal     view     returns (uint256) {     uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();     uint256 totalExistingUnits = existingUnit.preciseMul(_redeemInfo.previousSetTokenSupply);      uint256 outflow = _redeemInfo.netFlowQuantity.add(_redeemInfo.protocolFees).add(_redeemInfo.managerFee);      // Require withdrawable quantity is greater than existing collateral     require(totalExistingUnits &gt;= outflow, "Must be greater than total available collateral");      return totalExistingUnits.sub(outflow).preciseDiv(_redeemInfo.newSetTokenSupply); }  /**  * If a pre-issue hook has been configured, call the external-protocol contract. Pre-issue hook logic  * can contain arbitrary logic including validations, external function calls, etc.  */ function _callPreIssueHooks(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity,     address _caller,     address _to )     internal {     INAVIssuanceHook preIssueHook = navIssuanceSettings[_setToken].managerIssuanceHook;     if (address(preIssueHook) != address(0)) {         preIssueHook.invokePreIssueHook(_setToken, _reserveAsset, _reserveAssetQuantity, _caller, _to);     } }  /**  * If a pre-redeem hook has been configured, call the external-protocol contract.  */ function _callPreRedeemHooks(ISetToken _setToken, uint256 _setQuantity, address _caller, address _to) internal {     INAVIssuanceHook preRedeemHook = navIssuanceSettings[_setToken].managerRedemptionHook;     if (address(preRedeemHook) != address(0)) {         preRedeemHook.invokePreRedeemHook(_setToken, _setQuantity, _caller, _to);     } }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '/\n    Copyright 2020 Set Labs Inc.\n\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n/\n\npragma solidity 0.6.10;\npragma experimental "ABIEncoderV2";\n\nimport { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";\nimport { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";\nimport { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";\nimport { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";\nimport { SignedSafeMath } from "@openzeppelin/contracts/math/SignedSafeMath.sol";\n\nimport { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";\nimport { IController } from "../../interfaces/IController.sol";\nimport { INAVIssuanceHook } from "../../interfaces/INAVIssuanceHook.sol";\nimport { Invoke } from "../lib/Invoke.sol";\nimport { ISetToken } from "../../interfaces/ISetToken.sol";\nimport { IWETH } from "../../interfaces/external/IWETH.sol";\nimport { ModuleBase } from "../lib/ModuleBase.sol";\nimport { Position } from "../lib/Position.sol";\nimport { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";\nimport { ResourceIdentifier } from "../lib/ResourceIdentifier.sol";\n\n\n/\n * @title NavIssuanceModule\n * @author Set Protocol\n \n * Module that enables issuance and redemption with any valid ERC20 token or ETH if allowed by the manager. Sender receives\n * a proportional amount of SetTokens on issuance or ERC20 token on redemption based on the calculated net asset value using\n * oracle prices. Manager is able to enforce a premium / discount on issuance / redemption to avoid arbitrage and front\n * running when relying on oracle prices. Managers can charge a fee (denominated in reserve asset).\n /\ncontract NavIssuanceModule is ModuleBase, ReentrancyGuard {\n    using AddressArrayUtils for address[];\n    using Invoke for ISetToken;\n    using Position for ISetToken;\n    using PreciseUnitMath for uint256;\n    using PreciseUnitMath for int256;\n    using ResourceIdentifier for IController;\n    using SafeMath for uint256;\n    using SafeCast for int256;\n    using SafeCast for uint256;\n    using SignedSafeMath for int256;\n\n    / ============ Events ============ /\n\n    event SetTokenNAVIssued(\n        ISetToken indexed _setToken,\n        address _issuer,\n        address _to,\n        address _reserveAsset,\n        address _hookContract,\n        uint256 _setTokenQuantity,\n        uint256 _managerFee,\n        uint256 _premium\n    );\n\n    event SetTokenNAVRedeemed(\n        ISetToken indexed _setToken,\n        address _redeemer,\n        address _to,\n        address _reserveAsset,\n        address _hookContract,\n        uint256 _setTokenQuantity,\n        uint256 _managerFee,\n        uint256 _premium\n    );\n\n    event ReserveAssetAdded(\n        ISetToken indexed _setToken,\n        address _newReserveAsset\n    );\n\n    event ReserveAssetRemoved(\n        ISetToken indexed _setToken,\n        address _removedReserveAsset\n    );\n\n    event PremiumEdited(\n        ISetToken indexed _setToken,\n        uint256 _newPremium\n    );\n\n    event ManagerFeeEdited(\n        ISetToken indexed _setToken,\n        uint256 _newManagerFee,\n        uint256 _index\n    );\n\n    event FeeRecipientEdited(\n        ISetToken indexed _setToken,\n        address _feeRecipient\n    );\n\n    / ============ Structs ============ /\n\n    struct NAVIssuanceSettings {\n        INAVIssuanceHook managerIssuanceHook;      // Issuance hook configurations\n        INAVIssuanceHook managerRedemptionHook;    // Redemption hook configurations\n        address[] reserveAssets;                       // Allowed reserve assets - Must have a price enabled with the price oracle\n        address feeRecipient;                          // Manager fee recipient\n        uint256[2] managerFees;                        // Manager fees. 0 index is issue and 1 index is redeem fee (0.01% = 1e14, 1% = 1e16)\n        uint256 maxManagerFee;                         // Maximum fee manager is allowed to set for issue and redeem\n        uint256 premiumPercentage;                     // Premium percentage (0.01% = 1e14, 1% = 1e16). This premium is a buffer around oracle\n                                                       // prices paid by user to the SetToken, which prevents arbitrage and oracle front running\n        uint256 maxPremiumPercentage;                  // Maximum premium percentage manager is allowed to set (configured by manager)\n        uint256 minSetTokenSupply;                     // Minimum SetToken supply required for issuance and redemption\n                                                       // to prevent dramatic inflationary changes to the SetToken\'s position multiplier\n    }\n\n    struct ActionInfo {\n        uint256 preFeeReserveQuantity;                 // Reserve value before fees; During issuance, represents raw quantity\n                                                       // During redeem, represents post-premium value\n        uint256 protocolFees;                          // Total protocol fees (direct + manager revenue share)\n        uint256 managerFee;                            // Total manager fee paid in reserve asset\n        uint256 netFlowQuantity;                       // When issuing, quantity of reserve asset sent to SetToken\n                                                       // When redeeming, quantity of reserve asset sent to redeemer\n        uint256 setTokenQuantity;                      // When issuing, quantity of SetTokens minted to mintee\n                                                       // When redeeming, quantity of SetToken redeemed\n        uint256 previousSetTokenSupply;                // SetToken supply prior to issue/redeem action\n        uint256 newSetTokenSupply;                     // SetToken supply after issue/redeem action\n        int256 newPositionMultiplier;                  // SetToken position multiplier after issue/redeem\n        uint256 newReservePositionUnit;                // SetToken reserve asset position unit after issue/redeem\n    }\n\n    / ============ State Variables ============ /\n\n    // Wrapped ETH address\n    IWETH public immutable weth;\n\n    // Mapping of SetToken to NAV issuance settings struct\n    mapping(ISetToken =&gt; NAVIssuanceSettings) public navIssuanceSettings;\n\n    // Mapping to efficiently check a SetToken\'s reserve asset validity\n    // SetToken =&gt; reserveAsset =&gt; isReserveAsset\n    mapping(ISetToken =&gt; mapping(address =&gt; bool)) public isReserveAsset;\n\n    / ============ Constants ============ /\n\n    // 0 index stores the manager fee in managerFees array, percentage charged on issue (denominated in reserve asset)\n    uint256 constant internal MANAGER_ISSUE_FEE_INDEX = 0;\n\n    // 1 index stores the manager fee percentage in managerFees array, charged on redeem\n    uint256 constant internal MANAGER_REDEEM_FEE_INDEX = 1;\n\n    // 0 index stores the manager revenue share protocol fee % on the controller, charged in the issuance function\n    uint256 constant internal PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX = 0;\n\n    // 1 index stores the manager revenue share protocol fee % on the controller, charged in the redeem function\n    uint256 constant internal PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX = 1;\n\n    // 2 index stores the direct protocol fee % on the controller, charged in the issuance function\n    uint256 constant internal PROTOCOL_ISSUE_DIRECT_FEE_INDEX = 2;\n\n    // 3 index stores the direct protocol fee % on the controller, charged in the redeem function\n    uint256 constant internal PROTOCOL_REDEEM_DIRECT_FEE_INDEX = 3;\n\n    / ============ Constructor ============ /\n\n    /\n     * @param _controller               Address of controller contract\n     * @param _weth                     Address of wrapped eth\n     /\n    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {\n        weth = _weth;\n    }\n\n    / ============ External Functions ============ /\n\n    /\n     * Deposits the allowed reserve asset into the SetToken and mints the appropriate % of Net Asset Value of the SetToken\n     * to the specified _to address.\n     \n     * @param _setToken                     Instance of the SetToken contract\n     * @param _reserveAsset                 Address of the reserve asset to issue with\n     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with\n     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance\n     * @param _to                           Address to mint SetToken to\n     /\n    function issue(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _reserveAssetQuantity,\n        uint256 _minSetTokenReceiveQuantity,\n        address _to\n    )\n        external\n        nonReentrant\n        onlyValidAndInitializedSet(_setToken)\n    {\n        _validateCommon(_setToken, _reserveAsset, _reserveAssetQuantity);\n\n        _callPreIssueHooks(_setToken, _reserveAsset, _reserveAssetQuantity, msg.sender, _to);\n\n        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, _reserveAsset, _reserveAssetQuantity);\n\n        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);\n\n        _transferCollateralAndHandleFees(_setToken, IERC20(_reserveAsset), issueInfo);\n\n        _handleIssueStateUpdates(_setToken, _reserveAsset, _to, issueInfo);\n    }\n\n    /\n     * Wraps ETH and deposits WETH if allowed into the SetToken and mints the appropriate % of Net Asset Value of the SetToken\n     * to the specified _to address.\n     \n     * @param _setToken                     Instance of the SetToken contract\n     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance\n     * @param _to                           Address to mint SetToken to\n     /\n    function issueWithEther(\n        ISetToken _setToken,\n        uint256 _minSetTokenReceiveQuantity,\n        address _to\n    )\n        external\n        payable\n        nonReentrant\n        onlyValidAndInitializedSet(_setToken)\n    {\n        weth.deposit{ value: msg.value }();\n\n        _validateCommon(_setToken, address(weth), msg.value);\n\n        _callPreIssueHooks(_setToken, address(weth), msg.value, msg.sender, _to);\n\n        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, address(weth), msg.value);\n\n        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);\n\n        _transferWETHAndHandleFees(_setToken, issueInfo);\n\n        _handleIssueStateUpdates(_setToken, address(weth), _to, issueInfo);\n    }\n\n    /\n     * Redeems a SetToken into a valid reserve asset representing the appropriate % of Net Asset Value of the SetToken\n     * to the specified _to address. Only valid if there are available reserve units on the SetToken.\n     \n     * @param _setToken                     Instance of the SetToken contract\n     * @param _reserveAsset                 Address of the reserve asset to redeem with\n     * @param _setTokenQuantity             Quantity of SetTokens to redeem\n     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive\n     * @param _to                           Address to redeem reserve asset to\n     /\n    function redeem(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _setTokenQuantity,\n        uint256 _minReserveReceiveQuantity,\n        address _to\n    )\n        external\n        nonReentrant\n        onlyValidAndInitializedSet(_setToken)\n    {\n        _validateCommon(_setToken, _reserveAsset, _setTokenQuantity);\n\n        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);\n\n        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, _reserveAsset, _setTokenQuantity);\n\n        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);\n\n        _setToken.burn(msg.sender, _setTokenQuantity);\n\n        // Instruct the SetToken to transfer the reserve asset back to the user\n        _setToken.strictInvokeTransfer(\n            _reserveAsset,\n            _to,\n            redeemInfo.netFlowQuantity\n        );\n\n        _handleRedemptionFees(_setToken, _reserveAsset, redeemInfo);\n\n        _handleRedeemStateUpdates(_setToken, _reserveAsset, _to, redeemInfo);\n    }\n\n    /\n     * Redeems a SetToken into Ether (if WETH is valid) representing the appropriate % of Net Asset Value of the SetToken\n     * to the specified _to address. Only valid if there are available WETH units on the SetToken.\n     \n     * @param _setToken                     Instance of the SetToken contract\n     * @param _setTokenQuantity             Quantity of SetTokens to redeem\n     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive\n     * @param _to                           Address to redeem reserve asset to\n     /\n    function redeemIntoEther(\n        ISetToken _setToken,\n        uint256 _setTokenQuantity,\n        uint256 _minReserveReceiveQuantity,\n        address payable _to\n    )\n        external\n        nonReentrant\n        onlyValidAndInitializedSet(_setToken)\n    {\n        _validateCommon(_setToken, address(weth), _setTokenQuantity);\n\n        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);\n\n        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, address(weth), _setTokenQuantity);\n\n        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);\n\n        _setToken.burn(msg.sender, _setTokenQuantity);\n\n        // Instruct the SetToken to transfer WETH from SetToken to module\n        _setToken.strictInvokeTransfer(\n            address(weth),\n            address(this),\n            redeemInfo.netFlowQuantity\n        );\n\n        weth.withdraw(redeemInfo.netFlowQuantity);\n\n        _to.transfer(redeemInfo.netFlowQuantity);\n\n        _handleRedemptionFees(_setToken, address(weth), redeemInfo);\n\n        _handleRedeemStateUpdates(_setToken, address(weth), _to, redeemInfo);\n    }\n\n    /\n     * SET MANAGER ONLY. Add an allowed reserve asset\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _reserveAsset                 Address of the reserve asset to add\n     /\n    function addReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {\n        require(!isReserveAsset[_setToken][_reserveAsset], "Reserve asset already exists");\n\n        navIssuanceSettings[_setToken].reserveAssets.push(_reserveAsset);\n        isReserveAsset[_setToken][_reserveAsset] = true;\n\n        emit ReserveAssetAdded(_setToken, _reserveAsset);\n    }\n\n    /\n     * SET MANAGER ONLY. Remove a reserve asset\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _reserveAsset                 Address of the reserve asset to remove\n     /\n    function removeReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {\n        require(isReserveAsset[_setToken][_reserveAsset], "Reserve asset does not exist");\n\n        navIssuanceSettings[_setToken].reserveAssets = navIssuanceSettings[_setToken].reserveAssets.remove(_reserveAsset);\n        delete isReserveAsset[_setToken][_reserveAsset];\n\n        emit ReserveAssetRemoved(_setToken, _reserveAsset);\n    }\n\n    /\n     * SET MANAGER ONLY. Edit the premium percentage\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _premiumPercentage            Premium percentage in 10e16 (e.g. 10e16 = 1%)\n     /\n    function editPremium(ISetToken _setToken, uint256 _premiumPercentage) external onlyManagerAndValidSet(_setToken) {\n        require(_premiumPercentage &lt;= navIssuanceSettings[_setToken].maxPremiumPercentage, "Premium must be less than maximum allowed");\n\n        navIssuanceSettings[_setToken].premiumPercentage = _premiumPercentage;\n\n        emit PremiumEdited(_setToken, _premiumPercentage);\n    }\n\n    /\n     * SET MANAGER ONLY. Edit manager fee\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _managerFeePercentage         Manager fee percentage in 10e16 (e.g. 10e16 = 1%)\n     * @param _managerFeeIndex              Manager fee index. 0 index is issue fee, 1 index is redeem fee\n     /\n    function editManagerFee(\n        ISetToken _setToken,\n        uint256 _managerFeePercentage,\n        uint256 _managerFeeIndex\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        require(_managerFeePercentage &lt;= navIssuanceSettings[_setToken].maxManagerFee, "Manager fee must be less than maximum allowed");\n\n        navIssuanceSettings[_setToken].managerFees[_managerFeeIndex] = _managerFeePercentage;\n\n        emit ManagerFeeEdited(_setToken, _managerFeePercentage, _managerFeeIndex);\n    }\n\n    /\n     * SET MANAGER ONLY. Edit the manager fee recipient\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _managerFeeRecipient          Manager fee recipient\n     /\n    function editFeeRecipient(ISetToken _setToken, address _managerFeeRecipient) external onlyManagerAndValidSet(_setToken) {\n        require(_managerFeeRecipient != address(0), "Fee recipient must not be 0 address");\n\n        navIssuanceSettings[_setToken].feeRecipient = _managerFeeRecipient;\n\n        emit FeeRecipientEdited(_setToken, _managerFeeRecipient);\n    }\n\n    /\n     * SET MANAGER ONLY. Initializes this module to the SetToken with hooks, allowed reserve assets,\n     * fees and issuance premium. Only callable by the SetToken\'s manager. Hook addresses are optional.\n     * Address(0) means that no hook will be called.\n     \n     * @param _setToken                     Instance of the SetToken to issue\n     * @param _navIssuanceSettings          NAVIssuanceSettings struct defining parameters\n     /\n    function initialize(\n        ISetToken _setToken,\n        NAVIssuanceSettings memory _navIssuanceSettings\n    )\n        external\n        onlySetManager(_setToken, msg.sender)\n        onlyValidAndPendingSet(_setToken)\n    {\n        require(_navIssuanceSettings.reserveAssets.length &gt; 0, "Reserve assets must be greater than 0");\n        require(_navIssuanceSettings.maxManagerFee &lt; PreciseUnitMath.preciseUnit(), "Max manager fee must be less than 100%");\n        require(_navIssuanceSettings.maxPremiumPercentage &lt; PreciseUnitMath.preciseUnit(), "Max premium percentage must be less than 100%");\n        require(_navIssuanceSettings.managerFees[0] &lt;= _navIssuanceSettings.maxManagerFee, "Manager issue fee must be less than max");\n        require(_navIssuanceSettings.managerFees[1] &lt;= _navIssuanceSettings.maxManagerFee, "Manager redeem fee must be less than max");\n        require(_navIssuanceSettings.premiumPercentage &lt;= _navIssuanceSettings.maxPremiumPercentage, "Premium must be less than max");\n        require(_navIssuanceSettings.feeRecipient != address(0), "Fee Recipient must be non-zero address.");\n        // Initial mint of Set cannot use NAVIssuance since minSetTokenSupply must be &gt; 0\n        require(_navIssuanceSettings.minSetTokenSupply &gt; 0, "Min SetToken supply must be greater than 0");\n\n        for (uint256 i = 0; i &lt; _navIssuanceSettings.reserveAssets.length; i++) {\n            require(!isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]], "Reserve assets must be unique");\n            isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]] = true;\n        }\n\n        navIssuanceSettings[_setToken] = _navIssuanceSettings;\n\n        _setToken.initializeModule();\n    }\n\n    /\n     * Removes this module from the SetToken, via call by the SetToken. Issuance settings and\n     * reserve asset states are deleted.\n     /\n    function removeModule() external override {\n        ISetToken setToken = ISetToken(msg.sender);\n        for (uint256 i = 0; i &lt; navIssuanceSettings[setToken].reserveAssets.length; i++) {\n            delete isReserveAsset[setToken][navIssuanceSettings[setToken].reserveAssets[i]];\n        }\n\n        delete navIssuanceSettings[setToken];\n    }\n\n    receive() external payable {}\n\n    / ============ External Getter Functions ============ /\n\n    function getReserveAssets(ISetToken _setToken) external view returns (address[] memory) {\n        return navIssuanceSettings[_setToken].reserveAssets;\n    }\n\n    function getIssuePremium(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _reserveAssetQuantity\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getIssuePremium(_setToken, _reserveAsset, _reserveAssetQuantity);\n    }\n\n    function getRedeemPremium(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _setTokenQuantity\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);\n    }\n\n    function getManagerFee(ISetToken _setToken, uint256 _managerFeeIndex) external view returns (uint256) {\n        return navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];\n    }\n\n    /\n     * Get the expected SetTokens minted to recipient on issuance\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _reserveAsset                 Address of the reserve asset\n     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with\n     \n     * @return  uint256                     Expected SetTokens to be minted to recipient\n     */\n    function getExpectedSetTokenIssueQuantity(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _reserveAssetQuantity\n    )\n        external\n        view\n        returns (uint256)\n    {\n        (,, uint256 netReserveFlow) = _getFees(\n            _setToken,\n            _reserveAssetQuantity,\n            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,\n            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,\n            MANAGER_ISSUE_FEE_INDEX\n        );\n\n        uint256 setTotalSupply = _setToken.totalSupply();\n\n        return _getSetTokenMintQuantity(\n            _setToken,\n            _reserveAsset,\n            netReserveFlow,\n            setTotalSupply\n        );\n    }\n\n    /\n     * Get the expected reserve asset to be redeemed\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _reserveAsset                 Address of the reserve asset\n     * @param _setTokenQuantity             Quantity of SetTokens to redeem\n     \n     * @return  uint256                     Expected reserve asset quantity redeemed\n     /\n    function getExpectedReserveRedeemQuantity(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _setTokenQuantity\n    )\n        external\n        view\n        returns (uint256)\n    {\n        uint256 preFeeReserveQuantity = _getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);\n\n        (,, uint256 netReserveFlows) = _getFees(\n            _setToken,\n            preFeeReserveQuantity,\n            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,\n            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,\n            MANAGER_REDEEM_FEE_INDEX\n        );\n\n        return netReserveFlows;\n    }\n\n    /\n     * Checks if issue is valid\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _reserveAsset                 Address of the reserve asset\n     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with\n     \n     * @return  bool                        Returns true if issue is valid\n     /\n    function isIssueValid(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _reserveAssetQuantity\n    )\n        external\n        view\n        returns (bool)\n    {\n        uint256 setTotalSupply = _setToken.totalSupply();\n\n    return _reserveAssetQuantity != 0\n            &amp;&amp; isReserveAsset[_setToken][_reserveAsset]\n            &amp;&amp; setTotalSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply;\n    }\n\n    /\n     * Checks if redeem is valid\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _reserveAsset                 Address of the reserve asset\n     * @param _setTokenQuantity             Quantity of SetTokens to redeem\n     \n     * @return  bool                        Returns true if redeem is valid\n     /\n    function isRedeemValid(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _setTokenQuantity\n    )\n        external\n        view\n        returns (bool)\n    {\n        uint256 setTotalSupply = _setToken.totalSupply();\n\n        if (\n            _setTokenQuantity == 0\n            || !isReserveAsset[_setToken][_reserveAsset]\n            || setTotalSupply &lt; navIssuanceSettings[_setToken].minSetTokenSupply.add(_setTokenQuantity)\n        ) {\n            return false;\n        } else {\n            uint256 totalRedeemValue =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);\n\n            (,, uint256 expectedRedeemQuantity) = _getFees(\n                _setToken,\n                totalRedeemValue,\n                PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,\n                PROTOCOL_REDEEM_DIRECT_FEE_INDEX,\n                MANAGER_REDEEM_FEE_INDEX\n            );\n\n            uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();\n\n            return existingUnit.preciseMul(setTotalSupply) &gt;= expectedRedeemQuantity;\n        }\n    }\n\n    / ============ Internal Functions ============ */\n\n    function _validateCommon(ISetToken _setToken, address _reserveAsset, uint256 _quantity) internal view {\n        require(_quantity &gt; 0, "Quantity must be &gt; 0");\n        require(isReserveAsset[_setToken][_reserveAsset], "Must be valid reserve asset");\n    }\n\n    function _validateIssuanceInfo(ISetToken _setToken, uint256 _minSetTokenReceiveQuantity, ActionInfo memory _issueInfo) internal view {\n        // Check that total supply is greater than min supply needed for issuance\n        // Note: A min supply amount is needed to avoid division by 0 when SetToken supply is 0\n        require(\n            _issueInfo.previousSetTokenSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply,\n            "Supply must be greater than minimum to enable issuance"\n        );\n\n        require(_issueInfo.setTokenQuantity &gt;= _minSetTokenReceiveQuantity, "Must be greater than min SetToken");\n    }\n\n    function _validateRedemptionInfo(\n        ISetToken _setToken,\n        uint256 _minReserveReceiveQuantity,\n        ActionInfo memory _redeemInfo\n    )\n        internal\n        view\n    {\n        // Check that new supply is more than min supply needed for redemption\n        // Note: A min supply amount is needed to avoid division by 0 when redeeming SetToken to 0\n        require(\n            _redeemInfo.newSetTokenSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply,\n            "Supply must be greater than minimum to enable redemption"\n        );\n\n        require(_redeemInfo.netFlowQuantity &gt;= _minReserveReceiveQuantity, "Must be greater than min receive reserve quantity");\n    }\n\n    function _createIssuanceInfo(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _reserveAssetQuantity\n    )\n        internal\n        view\n        returns (ActionInfo memory)\n    {\n        ActionInfo memory issueInfo;\n\n        issueInfo.previousSetTokenSupply = _setToken.totalSupply();\n\n        issueInfo.preFeeReserveQuantity = _reserveAssetQuantity;\n\n        (issueInfo.protocolFees, issueInfo.managerFee, issueInfo.netFlowQuantity) = _getFees(\n            _setToken,\n            issueInfo.preFeeReserveQuantity,\n            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,\n            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,\n            MANAGER_ISSUE_FEE_INDEX\n        );\n\n        issueInfo.setTokenQuantity = _getSetTokenMintQuantity(\n            _setToken,\n            _reserveAsset,\n            issueInfo.netFlowQuantity,\n            issueInfo.previousSetTokenSupply\n        );\n\n        (issueInfo.newSetTokenSupply, issueInfo.newPositionMultiplier) = _getIssuePositionMultiplier(_setToken, issueInfo);\n\n        issueInfo.newReservePositionUnit = _getIssuePositionUnit(_setToken, _reserveAsset, issueInfo);\n\n        return issueInfo;\n    }\n\n    function _createRedemptionInfo(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _setTokenQuantity\n    )\n        internal\n        view\n        returns (ActionInfo memory)\n    {\n        ActionInfo memory redeemInfo;\n\n        redeemInfo.setTokenQuantity = _setTokenQuantity;\n\n        redeemInfo.preFeeReserveQuantity =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);\n\n        (redeemInfo.protocolFees, redeemInfo.managerFee, redeemInfo.netFlowQuantity) = _getFees(\n            _setToken,\n            redeemInfo.preFeeReserveQuantity,\n            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,\n            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,\n            MANAGER_REDEEM_FEE_INDEX\n        );\n\n        redeemInfo.previousSetTokenSupply = _setToken.totalSupply();\n\n        (redeemInfo.newSetTokenSupply, redeemInfo.newPositionMultiplier) = _getRedeemPositionMultiplier(_setToken, _setTokenQuantity, redeemInfo);\n\n        redeemInfo.newReservePositionUnit = _getRedeemPositionUnit(_setToken, _reserveAsset, redeemInfo);\n\n        return redeemInfo;\n    }\n\n    /\n     * Transfer reserve asset from user to SetToken and fees from user to appropriate fee recipients\n     /\n    function _transferCollateralAndHandleFees(ISetToken _setToken, IERC20 _reserveAsset, ActionInfo memory _issueInfo) internal {\n        transferFrom(_reserveAsset, msg.sender, address(_setToken), _issueInfo.netFlowQuantity);\n\n        if (_issueInfo.protocolFees &gt; 0) {\n            transferFrom(_reserveAsset, msg.sender, controller.feeRecipient(), _issueInfo.protocolFees);\n        }\n\n        if (_issueInfo.managerFee &gt; 0) {\n            transferFrom(_reserveAsset, msg.sender, navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);\n        }\n    }\n\n\n    /\n      * Transfer WETH from module to SetToken and fees from module to appropriate fee recipients\n     /\n    function _transferWETHAndHandleFees(ISetToken _setToken, ActionInfo memory _issueInfo) internal {\n        weth.transfer(address(_setToken), _issueInfo.netFlowQuantity);\n\n        if (_issueInfo.protocolFees &gt; 0) {\n            weth.transfer(controller.feeRecipient(), _issueInfo.protocolFees);\n        }\n\n        if (_issueInfo.managerFee &gt; 0) {\n            weth.transfer(navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);\n        }\n    }\n\n    function _handleIssueStateUpdates(\n        ISetToken _setToken,\n        address _reserveAsset,\n        address _to,\n        ActionInfo memory _issueInfo\n    )\n        internal\n    {\n        _setToken.editPositionMultiplier(_issueInfo.newPositionMultiplier);\n\n        _setToken.editDefaultPosition(_reserveAsset, _issueInfo.newReservePositionUnit);\n\n        _setToken.mint(_to, _issueInfo.setTokenQuantity);\n\n        emit SetTokenNAVIssued(\n            _setToken,\n            msg.sender,\n            _to,\n            _reserveAsset,\n            address(navIssuanceSettings[_setToken].managerIssuanceHook),\n            _issueInfo.setTokenQuantity,\n            _issueInfo.managerFee,\n            _issueInfo.protocolFees\n        );\n    }\n\n    function _handleRedeemStateUpdates(\n        ISetToken _setToken,\n        address _reserveAsset,\n        address _to,\n        ActionInfo memory _redeemInfo\n    )\n        internal\n    {\n        _setToken.editPositionMultiplier(_redeemInfo.newPositionMultiplier);\n\n        _setToken.editDefaultPosition(_reserveAsset, _redeemInfo.newReservePositionUnit);\n\n        emit SetTokenNAVRedeemed(\n            _setToken,\n            msg.sender,\n            _to,\n            _reserveAsset,\n            address(navIssuanceSettings[_setToken].managerRedemptionHook),\n            _redeemInfo.setTokenQuantity,\n            _redeemInfo.managerFee,\n            _redeemInfo.protocolFees\n        );\n    }\n\n    function _handleRedemptionFees(ISetToken _setToken, address _reserveAsset, ActionInfo memory _redeemInfo) internal {\n        // Instruct the SetToken to transfer protocol fee to fee recipient if there is a fee\n        payProtocolFeeFromSetToken(_setToken, _reserveAsset, _redeemInfo.protocolFees);\n\n        // Instruct the SetToken to transfer manager fee to manager fee recipient if there is a fee\n        if (_redeemInfo.managerFee &gt; 0) {\n            _setToken.strictInvokeTransfer(\n                _reserveAsset,\n                navIssuanceSettings[_setToken].feeRecipient,\n                _redeemInfo.managerFee\n            );\n        }\n    }\n\n    /\n     * Returns the issue premium percentage. Virtual function that can be overridden in future versions of the module\n     * and can contain arbitrary logic to calculate the issuance premium.\n     /\n    function _getIssuePremium(\n        ISetToken _setToken,\n        address / _reserveAsset /,\n        uint256 / _reserveAssetQuantity */\n    )\n        virtual\n        internal\n        view\n        returns (uint256)\n    {\n        return navIssuanceSettings[_setToken].premiumPercentage;\n    }\n\n    /\n     * Returns the redeem premium percentage. Virtual function that can be overridden in future versions of the module\n     * and can contain arbitrary logic to calculate the redemption premium.\n     /\n    function _getRedeemPremium(\n        ISetToken _setToken,\n        address / _reserveAsset /,\n        uint256 / _setTokenQuantity /\n    )\n        virtual\n        internal\n        view\n        returns (uint256)\n    {\n        return navIssuanceSettings[_setToken].premiumPercentage;\n    }\n\n    /\n     * Returns the fees attributed to the manager and the protocol. The fees are calculated as follows:\n     \n     * ManagerFee = (manager fee % - % to protocol) * reserveAssetQuantity\n     * Protocol Fee = (% manager fee share + direct fee %) * reserveAssetQuantity\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _reserveAssetQuantity         Quantity of reserve asset to calculate fees from\n     * @param _protocolManagerFeeIndex      Index to pull rev share NAV Issuance fee from the Controller\n     * @param _protocolDirectFeeIndex       Index to pull direct NAV issuance fee from the Controller\n     * @param _managerFeeIndex              Index from NAVIssuanceSettings (0 = issue fee, 1 = redeem fee)\n     \n     * @return  uint256                     Fees paid to the protocol in reserve asset\n     * @return  uint256                     Fees paid to the manager in reserve asset\n     * @return  uint256                     Net reserve to user net of fees\n     /\n    function _getFees(\n        ISetToken _setToken,\n        uint256 _reserveAssetQuantity,\n        uint256 _protocolManagerFeeIndex,\n        uint256 _protocolDirectFeeIndex,\n        uint256 _managerFeeIndex\n    )\n        internal\n        view\n        returns (uint256, uint256, uint256)\n    {\n        (uint256 protocolFeePercentage, uint256 managerFeePercentage) = _getProtocolAndManagerFeePercentages(\n            _setToken,\n            _protocolManagerFeeIndex,\n            _protocolDirectFeeIndex,\n            _managerFeeIndex\n        );\n\n        // Calculate total notional fees\n        uint256 protocolFees = protocolFeePercentage.preciseMul(_reserveAssetQuantity);\n        uint256 managerFee = managerFeePercentage.preciseMul(_reserveAssetQuantity);\n\n        uint256 netReserveFlow = _reserveAssetQuantity.sub(protocolFees).sub(managerFee);\n\n        return (protocolFees, managerFee, netReserveFlow);\n    }\n\n    function _getProtocolAndManagerFeePercentages(\n        ISetToken _setToken,\n        uint256 _protocolManagerFeeIndex,\n        uint256 _protocolDirectFeeIndex,\n        uint256 _managerFeeIndex\n    )\n        internal\n        view\n        returns(uint256, uint256)\n    {\n        // Get protocol fee percentages\n        uint256 protocolDirectFeePercent = controller.getModuleFee(address(this), _protocolDirectFeeIndex);\n        uint256 protocolManagerShareFeePercent = controller.getModuleFee(address(this), _protocolManagerFeeIndex);\n        uint256 managerFeePercent = navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];\n\n        // Calculate revenue share split percentage\n        uint256 protocolRevenueSharePercentage = protocolManagerShareFeePercent.preciseMul(managerFeePercent);\n        uint256 managerRevenueSharePercentage = managerFeePercent.sub(protocolRevenueSharePercentage);\n        uint256 totalProtocolFeePercentage = protocolRevenueSharePercentage.add(protocolDirectFeePercent);\n\n        return (totalProtocolFeePercentage, managerRevenueSharePercentage);\n    }\n\n    function _getSetTokenMintQuantity(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _netReserveFlows,            // Value of reserve asset net of fees\n        uint256 _setTotalSupply\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 premiumPercentage = _getIssuePremium(_setToken, _reserveAsset, _netReserveFlows);\n        uint256 premiumValue = _netReserveFlows.preciseMul(premiumPercentage);\n\n        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (1e18)\n        // Reverts if price is not found\n        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);\n\n        // Get reserve asset decimals\n        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();\n        uint256 normalizedTotalReserveQuantityNetFees = _netReserveFlows.preciseDiv(10 ** reserveAssetDecimals);\n        uint256 normalizedTotalReserveQuantityNetFeesAndPremium = _netReserveFlows.sub(premiumValue).preciseDiv(10 ** reserveAssetDecimals);\n\n        // Calculate SetTokens to mint to issuer\n        uint256 denominator = _setTotalSupply.preciseMul(setTokenValuation).add(normalizedTotalReserveQuantityNetFees).sub(normalizedTotalReserveQuantityNetFeesAndPremium);\n        return normalizedTotalReserveQuantityNetFeesAndPremium.preciseMul(_setTotalSupply).preciseDiv(denominator);\n    }\n\n    function _getRedeemReserveQuantity(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _setTokenQuantity\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (10e18)\n        // Reverts if price is not found\n        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);\n\n        uint256 totalRedeemValueInPreciseUnits = _setTokenQuantity.preciseMul(setTokenValuation);\n        // Get reserve asset decimals\n        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();\n        uint256 prePremiumReserveQuantity = totalRedeemValueInPreciseUnits.preciseMul(10 ** reserveAssetDecimals);\n\n        uint256 premiumPercentage = _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);\n        uint256 premiumQuantity = prePremiumReserveQuantity.preciseMulCeil(premiumPercentage);\n\n        return prePremiumReserveQuantity.sub(premiumQuantity);\n    }\n\n    /\n     * The new position multiplier is calculated as follows:\n     * inflationPercentage = (newSupply - oldSupply) / newSupply\n     * newMultiplier = (1 - inflationPercentage) * positionMultiplier\n     /\n    function _getIssuePositionMultiplier(\n        ISetToken _setToken,\n        ActionInfo memory _issueInfo\n    )\n        internal\n        view\n        returns (uint256, int256)\n    {\n        // Calculate inflation and new position multiplier. Note: Round inflation up in order to round position multiplier down\n        uint256 newTotalSupply = _issueInfo.setTokenQuantity.add(_issueInfo.previousSetTokenSupply);\n        int256 newPositionMultiplier = _setToken.positionMultiplier()\n            .mul(_issueInfo.previousSetTokenSupply.toInt256())\n            .div(newTotalSupply.toInt256());\n\n        return (newTotalSupply, newPositionMultiplier);\n    }\n\n    /\n     * Calculate deflation and new position multiplier. Note: Round deflation down in order to round position multiplier down\n     \n     * The new position multiplier is calculated as follows:\n     * deflationPercentage = (oldSupply - newSupply) / newSupply\n     * newMultiplier = (1 + deflationPercentage) * positionMultiplier\n     /\n    function _getRedeemPositionMultiplier(\n        ISetToken _setToken,\n        uint256 _setTokenQuantity,\n        ActionInfo memory _redeemInfo\n    )\n        internal\n        view\n        returns (uint256, int256)\n    {\n        uint256 newTotalSupply = _redeemInfo.previousSetTokenSupply.sub(_setTokenQuantity);\n        int256 newPositionMultiplier = _setToken.positionMultiplier()\n            .mul(_redeemInfo.previousSetTokenSupply.toInt256())\n            .div(newTotalSupply.toInt256());\n\n        return (newTotalSupply, newPositionMultiplier);\n    }\n\n    /\n     * The new position reserve asset unit is calculated as follows:\n     * totalReserve = (oldUnit * oldSetTokenSupply) + reserveQuantity\n     * newUnit = totalReserve / newSetTokenSupply\n     /\n    function _getIssuePositionUnit(\n        ISetToken _setToken,\n        address _reserveAsset,\n        ActionInfo memory _issueInfo\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();\n        uint256 totalReserve = existingUnit\n            .preciseMul(_issueInfo.previousSetTokenSupply)\n            .add(_issueInfo.netFlowQuantity);\n\n        return totalReserve.preciseDiv(_issueInfo.newSetTokenSupply);\n    }\n\n    /\n     * The new position reserve asset unit is calculated as follows:\n     * totalReserve = (oldUnit * oldSetTokenSupply) - reserveQuantityToSendOut\n     * newUnit = totalReserve / newSetTokenSupply\n     /\n    function _getRedeemPositionUnit(\n        ISetToken _setToken,\n        address _reserveAsset,\n        ActionInfo memory _redeemInfo\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();\n        uint256 totalExistingUnits = existingUnit.preciseMul(_redeemInfo.previousSetTokenSupply);\n\n        uint256 outflow = _redeemInfo.netFlowQuantity.add(_redeemInfo.protocolFees).add(_redeemInfo.managerFee);\n\n        // Require withdrawable quantity is greater than existing collateral\n        require(totalExistingUnits &gt;= outflow, "Must be greater than total available collateral");\n\n        return totalExistingUnits.sub(outflow).preciseDiv(_redeemInfo.newSetTokenSupply);\n    }\n\n    /\n     * If a pre-issue hook has been configured, call the external-protocol contract. Pre-issue hook logic\n     * can contain arbitrary logic including validations, external function calls, etc.\n     */\n    function _callPreIssueHooks(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _reserveAssetQuantity,\n        address _caller,\n        address _to\n    )\n        internal\n    {\n        INAVIssuanceHook preIssueHook = navIssuanceSettings[_setToken].managerIssuanceHook;\n        if (address(preIssueHook) != address(0)) {\n            preIssueHook.invokePreIssueHook(_setToken, _reserveAsset, _reserveAssetQuantity, _caller, _to);\n        }\n    }\n\n    /\n     * If a pre-redeem hook has been configured, call the external-protocol contract.\n     */\n    function _callPreRedeemHooks(ISetToken _setToken, uint256 _setQuantity, address _caller, address _to) internal {\n        INAVIssuanceHook preRedeemHook = navIssuanceSettings[_setToken].managerRedemptionHook;\n        if (address(preRedeemHook) != address(0)) {\n            preRedeemHook.invokePreRedeemHook(_setToken, _setQuantity, _caller, _to);\n        }\n    }\n}', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 05:31:19 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | /*     Copyright 2020 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol"; import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol"; import { SignedSafeMath } from "@openzeppelin/contracts/math/SignedSafeMath.sol"; import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol"; import { IController } from "../../interfaces/IController.sol"; import { INAVIssuanceHook } from "../../interfaces/INAVIssuanceHook.sol"; import { Invoke } from "../lib/Invoke.sol"; import { ISetToken } from "../../interfaces/ISetToken.sol"; import { IWETH } from "../../interfaces/external/IWETH.sol"; import { ModuleBase } from "../lib/ModuleBase.sol"; import { Position } from "../lib/Position.sol"; import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol"; import { ResourceIdentifier } from "../lib/ResourceIdentifier.sol"; /*  * @title NavIssuanceModule  * @author Set Protocol  *  * Module that enables issuance and redemption with any valid ERC20 token or ETH if allowed by the manager. Sender receives  * a proportional amount of SetTokens on issuance or ERC20 token on redemption based on the calculated net asset value using  * oracle prices. Manager is able to enforce a premium / discount on issuance / redemption to avoid arbitrage and front  * running when relying on oracle prices. Managers can charge a fee (denominated in reserve asset).  / contract NavIssuanceModule is ModuleBase, ReentrancyGuard {     using AddressArrayUtils for address[];     using Invoke for ISetToken;     using Position for ISetToken;     using PreciseUnitMath for uint256;     using PreciseUnitMath for int256;     using ResourceIdentifier for IController;     using SafeMath for uint256;     using SafeCast for int256;     using SafeCast for uint256;     using SignedSafeMath for int256; /* ============ Events ============ */  event SetTokenNAVIssued(     ISetToken indexed _setToken,     address _issuer,     address _to,     address _reserveAsset,     address _hookContract,     uint256 _setTokenQuantity,     uint256 _managerFee,     uint256 _premium );  event SetTokenNAVRedeemed(     ISetToken indexed _setToken,     address _redeemer,     address _to,     address _reserveAsset,     address _hookContract,     uint256 _setTokenQuantity,     uint256 _managerFee,     uint256 _premium );  event ReserveAssetAdded(     ISetToken indexed _setToken,     address _newReserveAsset );  event ReserveAssetRemoved(     ISetToken indexed _setToken,     address _removedReserveAsset );  event PremiumEdited(     ISetToken indexed _setToken,     uint256 _newPremium );  event ManagerFeeEdited(     ISetToken indexed _setToken,     uint256 _newManagerFee,     uint256 _index );  event FeeRecipientEdited(     ISetToken indexed _setToken,     address _feeRecipient );  /* ============ Structs ============ */  struct NAVIssuanceSettings {     INAVIssuanceHook managerIssuanceHook;      // Issuance hook configurations     INAVIssuanceHook managerRedemptionHook;    // Redemption hook configurations     address[] reserveAssets;                       // Allowed reserve assets - Must have a price enabled with the price oracle     address feeRecipient;                          // Manager fee recipient     uint256[2] managerFees;                        // Manager fees. 0 index is issue and 1 index is redeem fee (0.01% = 1e14, 1% = 1e16)     uint256 maxManagerFee;                         // Maximum fee manager is allowed to set for issue and redeem     uint256 premiumPercentage;                     // Premium percentage (0.01% = 1e14, 1% = 1e16). This premium is a buffer around oracle                                                    // prices paid by user to the SetToken, which prevents arbitrage and oracle front running     uint256 maxPremiumPercentage;                  // Maximum premium percentage manager is allowed to set (configured by manager)     uint256 minSetTokenSupply;                     // Minimum SetToken supply required for issuance and redemption                                                    // to prevent dramatic inflationary changes to the SetToken's position multiplier }  struct ActionInfo {     uint256 preFeeReserveQuantity;                 // Reserve value before fees; During issuance, represents raw quantity                                                    // During redeem, represents post-premium value     uint256 protocolFees;                          // Total protocol fees (direct + manager revenue share)     uint256 managerFee;                            // Total manager fee paid in reserve asset     uint256 netFlowQuantity;                       // When issuing, quantity of reserve asset sent to SetToken                                                    // When redeeming, quantity of reserve asset sent to redeemer     uint256 setTokenQuantity;                      // When issuing, quantity of SetTokens minted to mintee                                                    // When redeeming, quantity of SetToken redeemed     uint256 previousSetTokenSupply;                // SetToken supply prior to issue/redeem action     uint256 newSetTokenSupply;                     // SetToken supply after issue/redeem action     int256 newPositionMultiplier;                  // SetToken position multiplier after issue/redeem     uint256 newReservePositionUnit;                // SetToken reserve asset position unit after issue/redeem }  /* ============ State Variables ============ */  // Wrapped ETH address IWETH public immutable weth;  // Mapping of SetToken to NAV issuance settings struct mapping(ISetToken =&gt; NAVIssuanceSettings) public navIssuanceSettings;  // Mapping to efficiently check a SetToken's reserve asset validity // SetToken =&gt; reserveAsset =&gt; isReserveAsset mapping(ISetToken =&gt; mapping(address =&gt; bool)) public isReserveAsset;  /* ============ Constants ============ */  // 0 index stores the manager fee in managerFees array, percentage charged on issue (denominated in reserve asset) uint256 constant internal MANAGER_ISSUE_FEE_INDEX = 0;  // 1 index stores the manager fee percentage in managerFees array, charged on redeem uint256 constant internal MANAGER_REDEEM_FEE_INDEX = 1;  // 0 index stores the manager revenue share protocol fee % on the controller, charged in the issuance function uint256 constant internal PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX = 0;  // 1 index stores the manager revenue share protocol fee % on the controller, charged in the redeem function uint256 constant internal PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX = 1;  // 2 index stores the direct protocol fee % on the controller, charged in the issuance function uint256 constant internal PROTOCOL_ISSUE_DIRECT_FEE_INDEX = 2;  // 3 index stores the direct protocol fee % on the controller, charged in the redeem function uint256 constant internal PROTOCOL_REDEEM_DIRECT_FEE_INDEX = 3;  /* ============ Constructor ============ */  /**  * @param _controller               Address of controller contract  * @param _weth                     Address of wrapped eth  */ constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {     weth = _weth; }  /* ============ External Functions ============ */  /**  * Deposits the allowed reserve asset into the SetToken and mints the appropriate % of Net Asset Value of the SetToken  * to the specified _to address.  *  * @param _setToken                     Instance of the SetToken contract  * @param _reserveAsset                 Address of the reserve asset to issue with  * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with  * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance  * @param _to                           Address to mint SetToken to  */ function issue(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity,     uint256 _minSetTokenReceiveQuantity,     address _to )     external     nonReentrant     onlyValidAndInitializedSet(_setToken) {     _validateCommon(_setToken, _reserveAsset, _reserveAssetQuantity);      _callPreIssueHooks(_setToken, _reserveAsset, _reserveAssetQuantity, msg.sender, _to);      ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, _reserveAsset, _reserveAssetQuantity);      _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);      _transferCollateralAndHandleFees(_setToken, IERC20(_reserveAsset), issueInfo);      _handleIssueStateUpdates(_setToken, _reserveAsset, _to, issueInfo); }  /**  * Wraps ETH and deposits WETH if allowed into the SetToken and mints the appropriate % of Net Asset Value of the SetToken  * to the specified _to address.  *  * @param _setToken                     Instance of the SetToken contract  * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance  * @param _to                           Address to mint SetToken to  */ function issueWithEther(     ISetToken _setToken,     uint256 _minSetTokenReceiveQuantity,     address _to )     external     payable     nonReentrant     onlyValidAndInitializedSet(_setToken) {     weth.deposit{ value: msg.value }();      _validateCommon(_setToken, address(weth), msg.value);      _callPreIssueHooks(_setToken, address(weth), msg.value, msg.sender, _to);      ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, address(weth), msg.value);      _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);      _transferWETHAndHandleFees(_setToken, issueInfo);      _handleIssueStateUpdates(_setToken, address(weth), _to, issueInfo); }  /**  * Redeems a SetToken into a valid reserve asset representing the appropriate % of Net Asset Value of the SetToken  * to the specified _to address. Only valid if there are available reserve units on the SetToken.  *  * @param _setToken                     Instance of the SetToken contract  * @param _reserveAsset                 Address of the reserve asset to redeem with  * @param _setTokenQuantity             Quantity of SetTokens to redeem  * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive  * @param _to                           Address to redeem reserve asset to  */ function redeem(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity,     uint256 _minReserveReceiveQuantity,     address _to )     external     nonReentrant     onlyValidAndInitializedSet(_setToken) {     _validateCommon(_setToken, _reserveAsset, _setTokenQuantity);      _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);      ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, _reserveAsset, _setTokenQuantity);      _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);      _setToken.burn(msg.sender, _setTokenQuantity);      // Instruct the SetToken to transfer the reserve asset back to the user     _setToken.strictInvokeTransfer(         _reserveAsset,         _to,         redeemInfo.netFlowQuantity     );      _handleRedemptionFees(_setToken, _reserveAsset, redeemInfo);      _handleRedeemStateUpdates(_setToken, _reserveAsset, _to, redeemInfo); }  /**  * Redeems a SetToken into Ether (if WETH is valid) representing the appropriate % of Net Asset Value of the SetToken  * to the specified _to address. Only valid if there are available WETH units on the SetToken.  *  * @param _setToken                     Instance of the SetToken contract  * @param _setTokenQuantity             Quantity of SetTokens to redeem  * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive  * @param _to                           Address to redeem reserve asset to  */ function redeemIntoEther(     ISetToken _setToken,     uint256 _setTokenQuantity,     uint256 _minReserveReceiveQuantity,     address payable _to )     external     nonReentrant     onlyValidAndInitializedSet(_setToken) {     _validateCommon(_setToken, address(weth), _setTokenQuantity);      _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);      ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, address(weth), _setTokenQuantity);      _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);      _setToken.burn(msg.sender, _setTokenQuantity);      // Instruct the SetToken to transfer WETH from SetToken to module     _setToken.strictInvokeTransfer(         address(weth),         address(this),         redeemInfo.netFlowQuantity     );      weth.withdraw(redeemInfo.netFlowQuantity);      _to.transfer(redeemInfo.netFlowQuantity);      _handleRedemptionFees(_setToken, address(weth), redeemInfo);      _handleRedeemStateUpdates(_setToken, address(weth), _to, redeemInfo); }  /**  * SET MANAGER ONLY. Add an allowed reserve asset  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset to add  */ function addReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {     require(!isReserveAsset[_setToken][_reserveAsset], "Reserve asset already exists");      navIssuanceSettings[_setToken].reserveAssets.push(_reserveAsset);     isReserveAsset[_setToken][_reserveAsset] = true;      emit ReserveAssetAdded(_setToken, _reserveAsset); }  /**  * SET MANAGER ONLY. Remove a reserve asset  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset to remove  */ function removeReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {     require(isReserveAsset[_setToken][_reserveAsset], "Reserve asset does not exist");      navIssuanceSettings[_setToken].reserveAssets = navIssuanceSettings[_setToken].reserveAssets.remove(_reserveAsset);     delete isReserveAsset[_setToken][_reserveAsset];      emit ReserveAssetRemoved(_setToken, _reserveAsset); }  /**  * SET MANAGER ONLY. Edit the premium percentage  *  * @param _setToken                     Instance of the SetToken  * @param _premiumPercentage            Premium percentage in 10e16 (e.g. 10e16 = 1%)  */ function editPremium(ISetToken _setToken, uint256 _premiumPercentage) external onlyManagerAndValidSet(_setToken) {     require(_premiumPercentage &lt;= navIssuanceSettings[_setToken].maxPremiumPercentage, "Premium must be less than maximum allowed");      navIssuanceSettings[_setToken].premiumPercentage = _premiumPercentage;      emit PremiumEdited(_setToken, _premiumPercentage); }  /**  * SET MANAGER ONLY. Edit manager fee  *  * @param _setToken                     Instance of the SetToken  * @param _managerFeePercentage         Manager fee percentage in 10e16 (e.g. 10e16 = 1%)  * @param _managerFeeIndex              Manager fee index. 0 index is issue fee, 1 index is redeem fee  */ function editManagerFee(     ISetToken _setToken,     uint256 _managerFeePercentage,     uint256 _managerFeeIndex )     external     onlyManagerAndValidSet(_setToken) {     require(_managerFeePercentage &lt;= navIssuanceSettings[_setToken].maxManagerFee, "Manager fee must be less than maximum allowed");      navIssuanceSettings[_setToken].managerFees[_managerFeeIndex] = _managerFeePercentage;      emit ManagerFeeEdited(_setToken, _managerFeePercentage, _managerFeeIndex); }  /**  * SET MANAGER ONLY. Edit the manager fee recipient  *  * @param _setToken                     Instance of the SetToken  * @param _managerFeeRecipient          Manager fee recipient  */ function editFeeRecipient(ISetToken _setToken, address _managerFeeRecipient) external onlyManagerAndValidSet(_setToken) {     require(_managerFeeRecipient != address(0), "Fee recipient must not be 0 address");      navIssuanceSettings[_setToken].feeRecipient = _managerFeeRecipient;      emit FeeRecipientEdited(_setToken, _managerFeeRecipient); }  /**  * SET MANAGER ONLY. Initializes this module to the SetToken with hooks, allowed reserve assets,  * fees and issuance premium. Only callable by the SetToken's manager. Hook addresses are optional.  * Address(0) means that no hook will be called.  *  * @param _setToken                     Instance of the SetToken to issue  * @param _navIssuanceSettings          NAVIssuanceSettings struct defining parameters  */ function initialize(     ISetToken _setToken,     NAVIssuanceSettings memory _navIssuanceSettings )     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     require(_navIssuanceSettings.reserveAssets.length &gt; 0, "Reserve assets must be greater than 0");     require(_navIssuanceSettings.maxManagerFee &lt; PreciseUnitMath.preciseUnit(), "Max manager fee must be less than 100%");     require(_navIssuanceSettings.maxPremiumPercentage &lt; PreciseUnitMath.preciseUnit(), "Max premium percentage must be less than 100%");     require(_navIssuanceSettings.managerFees[0] &lt;= _navIssuanceSettings.maxManagerFee, "Manager issue fee must be less than max");     require(_navIssuanceSettings.managerFees[1] &lt;= _navIssuanceSettings.maxManagerFee, "Manager redeem fee must be less than max");     require(_navIssuanceSettings.premiumPercentage &lt;= _navIssuanceSettings.maxPremiumPercentage, "Premium must be less than max");     require(_navIssuanceSettings.feeRecipient != address(0), "Fee Recipient must be non-zero address.");     // Initial mint of Set cannot use NAVIssuance since minSetTokenSupply must be &gt; 0     require(_navIssuanceSettings.minSetTokenSupply &gt; 0, "Min SetToken supply must be greater than 0");      for (uint256 i = 0; i &lt; _navIssuanceSettings.reserveAssets.length; i++) {         require(!isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]], "Reserve assets must be unique");         isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]] = true;     }      navIssuanceSettings[_setToken] = _navIssuanceSettings;      _setToken.initializeModule(); }  /**  * Removes this module from the SetToken, via call by the SetToken. Issuance settings and  * reserve asset states are deleted.  */ function removeModule() external override {     ISetToken setToken = ISetToken(msg.sender);     for (uint256 i = 0; i &lt; navIssuanceSettings[setToken].reserveAssets.length; i++) {         delete isReserveAsset[setToken][navIssuanceSettings[setToken].reserveAssets[i]];     }      delete navIssuanceSettings[setToken]; }  receive() external payable {}  /* ============ External Getter Functions ============ */  function getReserveAssets(ISetToken _setToken) external view returns (address[] memory) {     return navIssuanceSettings[_setToken].reserveAssets; }  function getIssuePremium(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     external     view     returns (uint256) {     return _getIssuePremium(_setToken, _reserveAsset, _reserveAssetQuantity); }  function getRedeemPremium(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     external     view     returns (uint256) {     return _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity); }  function getManagerFee(ISetToken _setToken, uint256 _managerFeeIndex) external view returns (uint256) {     return navIssuanceSettings[_setToken].managerFees[_managerFeeIndex]; }  /**  * Get the expected SetTokens minted to recipient on issuance  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with  *  * @return  uint256                     Expected SetTokens to be minted to recipient  */ function getExpectedSetTokenIssueQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     external     view     returns (uint256) {     (,, uint256 netReserveFlow) = _getFees(         _setToken,         _reserveAssetQuantity,         PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_ISSUE_DIRECT_FEE_INDEX,         MANAGER_ISSUE_FEE_INDEX     );      uint256 setTotalSupply = _setToken.totalSupply();      return _getSetTokenMintQuantity(         _setToken,         _reserveAsset,         netReserveFlow,         setTotalSupply     ); }  /**  * Get the expected reserve asset to be redeemed  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _setTokenQuantity             Quantity of SetTokens to redeem  *  * @return  uint256                     Expected reserve asset quantity redeemed  */ function getExpectedReserveRedeemQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     external     view     returns (uint256) {     uint256 preFeeReserveQuantity = _getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);      (,, uint256 netReserveFlows) = _getFees(         _setToken,         preFeeReserveQuantity,         PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_REDEEM_DIRECT_FEE_INDEX,         MANAGER_REDEEM_FEE_INDEX     );      return netReserveFlows; }  /**  * Checks if issue is valid  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with  *  * @return  bool                        Returns true if issue is valid  */ function isIssueValid(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     external     view     returns (bool) {     uint256 setTotalSupply = _setToken.totalSupply();  return _reserveAssetQuantity != 0         &amp;&amp; isReserveAsset[_setToken][_reserveAsset]         &amp;&amp; setTotalSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply; }  /**  * Checks if redeem is valid  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _setTokenQuantity             Quantity of SetTokens to redeem  *  * @return  bool                        Returns true if redeem is valid  */ function isRedeemValid(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     external     view     returns (bool) {     uint256 setTotalSupply = _setToken.totalSupply();      if (         _setTokenQuantity == 0         || !isReserveAsset[_setToken][_reserveAsset]         || setTotalSupply &lt; navIssuanceSettings[_setToken].minSetTokenSupply.add(_setTokenQuantity)     ) {         return false;     } else {         uint256 totalRedeemValue =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);          (,, uint256 expectedRedeemQuantity) = _getFees(             _setToken,             totalRedeemValue,             PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,             PROTOCOL_REDEEM_DIRECT_FEE_INDEX,             MANAGER_REDEEM_FEE_INDEX         );          uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();          return existingUnit.preciseMul(setTotalSupply) &gt;= expectedRedeemQuantity;     } }  /* ============ Internal Functions ============ */  function _validateCommon(ISetToken _setToken, address _reserveAsset, uint256 _quantity) internal view {     require(_quantity &gt; 0, "Quantity must be &gt; 0");     require(isReserveAsset[_setToken][_reserveAsset], "Must be valid reserve asset"); }  function _validateIssuanceInfo(ISetToken _setToken, uint256 _minSetTokenReceiveQuantity, ActionInfo memory _issueInfo) internal view {     // Check that total supply is greater than min supply needed for issuance     // Note: A min supply amount is needed to avoid division by 0 when SetToken supply is 0     require(         _issueInfo.previousSetTokenSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply,         "Supply must be greater than minimum to enable issuance"     );      require(_issueInfo.setTokenQuantity &gt;= _minSetTokenReceiveQuantity, "Must be greater than min SetToken"); }  function _validateRedemptionInfo(     ISetToken _setToken,     uint256 _minReserveReceiveQuantity,     ActionInfo memory _redeemInfo )     internal     view {     // Check that new supply is more than min supply needed for redemption     // Note: A min supply amount is needed to avoid division by 0 when redeeming SetToken to 0     require(         _redeemInfo.newSetTokenSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply,         "Supply must be greater than minimum to enable redemption"     );      require(_redeemInfo.netFlowQuantity &gt;= _minReserveReceiveQuantity, "Must be greater than min receive reserve quantity"); }  function _createIssuanceInfo(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     internal     view     returns (ActionInfo memory) {     ActionInfo memory issueInfo;      issueInfo.previousSetTokenSupply = _setToken.totalSupply();      issueInfo.preFeeReserveQuantity = _reserveAssetQuantity;      (issueInfo.protocolFees, issueInfo.managerFee, issueInfo.netFlowQuantity) = _getFees(         _setToken,         issueInfo.preFeeReserveQuantity,         PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_ISSUE_DIRECT_FEE_INDEX,         MANAGER_ISSUE_FEE_INDEX     );      issueInfo.setTokenQuantity = _getSetTokenMintQuantity(         _setToken,         _reserveAsset,         issueInfo.netFlowQuantity,         issueInfo.previousSetTokenSupply     );      (issueInfo.newSetTokenSupply, issueInfo.newPositionMultiplier) = _getIssuePositionMultiplier(_setToken, issueInfo);      issueInfo.newReservePositionUnit = _getIssuePositionUnit(_setToken, _reserveAsset, issueInfo);      return issueInfo; }  function _createRedemptionInfo(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     internal     view     returns (ActionInfo memory) {     ActionInfo memory redeemInfo;      redeemInfo.setTokenQuantity = _setTokenQuantity;      redeemInfo.preFeeReserveQuantity =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);      (redeemInfo.protocolFees, redeemInfo.managerFee, redeemInfo.netFlowQuantity) = _getFees(         _setToken,         redeemInfo.preFeeReserveQuantity,         PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_REDEEM_DIRECT_FEE_INDEX,         MANAGER_REDEEM_FEE_INDEX     );      redeemInfo.previousSetTokenSupply = _setToken.totalSupply();      (redeemInfo.newSetTokenSupply, redeemInfo.newPositionMultiplier) = _getRedeemPositionMultiplier(_setToken, _setTokenQuantity, redeemInfo);      redeemInfo.newReservePositionUnit = _getRedeemPositionUnit(_setToken, _reserveAsset, redeemInfo);      return redeemInfo; }  /**  * Transfer reserve asset from user to SetToken and fees from user to appropriate fee recipients  */ function _transferCollateralAndHandleFees(ISetToken _setToken, IERC20 _reserveAsset, ActionInfo memory _issueInfo) internal {     transferFrom(_reserveAsset, msg.sender, address(_setToken), _issueInfo.netFlowQuantity);      if (_issueInfo.protocolFees &gt; 0) {         transferFrom(_reserveAsset, msg.sender, controller.feeRecipient(), _issueInfo.protocolFees);     }      if (_issueInfo.managerFee &gt; 0) {         transferFrom(_reserveAsset, msg.sender, navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);     } }   /**   * Transfer WETH from module to SetToken and fees from module to appropriate fee recipients  */ function _transferWETHAndHandleFees(ISetToken _setToken, ActionInfo memory _issueInfo) internal {     weth.transfer(address(_setToken), _issueInfo.netFlowQuantity);      if (_issueInfo.protocolFees &gt; 0) {         weth.transfer(controller.feeRecipient(), _issueInfo.protocolFees);     }      if (_issueInfo.managerFee &gt; 0) {         weth.transfer(navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);     } }  function _handleIssueStateUpdates(     ISetToken _setToken,     address _reserveAsset,     address _to,     ActionInfo memory _issueInfo )     internal {     _setToken.editPositionMultiplier(_issueInfo.newPositionMultiplier);      _setToken.editDefaultPosition(_reserveAsset, _issueInfo.newReservePositionUnit);      _setToken.mint(_to, _issueInfo.setTokenQuantity);      emit SetTokenNAVIssued(         _setToken,         msg.sender,         _to,         _reserveAsset,         address(navIssuanceSettings[_setToken].managerIssuanceHook),         _issueInfo.setTokenQuantity,         _issueInfo.managerFee,         _issueInfo.protocolFees     ); }  function _handleRedeemStateUpdates(     ISetToken _setToken,     address _reserveAsset,     address _to,     ActionInfo memory _redeemInfo )     internal {     _setToken.editPositionMultiplier(_redeemInfo.newPositionMultiplier);      _setToken.editDefaultPosition(_reserveAsset, _redeemInfo.newReservePositionUnit);      emit SetTokenNAVRedeemed(         _setToken,         msg.sender,         _to,         _reserveAsset,         address(navIssuanceSettings[_setToken].managerRedemptionHook),         _redeemInfo.setTokenQuantity,         _redeemInfo.managerFee,         _redeemInfo.protocolFees     ); }  function _handleRedemptionFees(ISetToken _setToken, address _reserveAsset, ActionInfo memory _redeemInfo) internal {     // Instruct the SetToken to transfer protocol fee to fee recipient if there is a fee     payProtocolFeeFromSetToken(_setToken, _reserveAsset, _redeemInfo.protocolFees);      // Instruct the SetToken to transfer manager fee to manager fee recipient if there is a fee     if (_redeemInfo.managerFee &gt; 0) {         _setToken.strictInvokeTransfer(             _reserveAsset,             navIssuanceSettings[_setToken].feeRecipient,             _redeemInfo.managerFee         );     } }  /**  * Returns the issue premium percentage. Virtual function that can be overridden in future versions of the module  * and can contain arbitrary logic to calculate the issuance premium.  */ function _getIssuePremium(     ISetToken _setToken,     address /* _reserveAsset */,     uint256 /* _reserveAssetQuantity */ )     virtual     internal     view     returns (uint256) {     return navIssuanceSettings[_setToken].premiumPercentage; }  /**  * Returns the redeem premium percentage. Virtual function that can be overridden in future versions of the module  * and can contain arbitrary logic to calculate the redemption premium.  */ function _getRedeemPremium(     ISetToken _setToken,     address /* _reserveAsset */,     uint256 /* _setTokenQuantity */ )     virtual     internal     view     returns (uint256) {     return navIssuanceSettings[_setToken].premiumPercentage; }  /**  * Returns the fees attributed to the manager and the protocol. The fees are calculated as follows:  *  * ManagerFee = (manager fee % - % to protocol) * reserveAssetQuantity  * Protocol Fee = (% manager fee share + direct fee %) * reserveAssetQuantity  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAssetQuantity         Quantity of reserve asset to calculate fees from  * @param _protocolManagerFeeIndex      Index to pull rev share NAV Issuance fee from the Controller  * @param _protocolDirectFeeIndex       Index to pull direct NAV issuance fee from the Controller  * @param _managerFeeIndex              Index from NAVIssuanceSettings (0 = issue fee, 1 = redeem fee)  *  * @return  uint256                     Fees paid to the protocol in reserve asset  * @return  uint256                     Fees paid to the manager in reserve asset  * @return  uint256                     Net reserve to user net of fees  */ function _getFees(     ISetToken _setToken,     uint256 _reserveAssetQuantity,     uint256 _protocolManagerFeeIndex,     uint256 _protocolDirectFeeIndex,     uint256 _managerFeeIndex )     internal     view     returns (uint256, uint256, uint256) {     (uint256 protocolFeePercentage, uint256 managerFeePercentage) = _getProtocolAndManagerFeePercentages(         _setToken,         _protocolManagerFeeIndex,         _protocolDirectFeeIndex,         _managerFeeIndex     );      // Calculate total notional fees     uint256 protocolFees = protocolFeePercentage.preciseMul(_reserveAssetQuantity);     uint256 managerFee = managerFeePercentage.preciseMul(_reserveAssetQuantity);      uint256 netReserveFlow = _reserveAssetQuantity.sub(protocolFees).sub(managerFee);      return (protocolFees, managerFee, netReserveFlow); }  function _getProtocolAndManagerFeePercentages(     ISetToken _setToken,     uint256 _protocolManagerFeeIndex,     uint256 _protocolDirectFeeIndex,     uint256 _managerFeeIndex )     internal     view     returns(uint256, uint256) {     // Get protocol fee percentages     uint256 protocolDirectFeePercent = controller.getModuleFee(address(this), _protocolDirectFeeIndex);     uint256 protocolManagerShareFeePercent = controller.getModuleFee(address(this), _protocolManagerFeeIndex);     uint256 managerFeePercent = navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];      // Calculate revenue share split percentage     uint256 protocolRevenueSharePercentage = protocolManagerShareFeePercent.preciseMul(managerFeePercent);     uint256 managerRevenueSharePercentage = managerFeePercent.sub(protocolRevenueSharePercentage);     uint256 totalProtocolFeePercentage = protocolRevenueSharePercentage.add(protocolDirectFeePercent);      return (totalProtocolFeePercentage, managerRevenueSharePercentage); }  function _getSetTokenMintQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _netReserveFlows,            // Value of reserve asset net of fees     uint256 _setTotalSupply )     internal     view     returns (uint256) {     uint256 premiumPercentage = _getIssuePremium(_setToken, _reserveAsset, _netReserveFlows);     uint256 premiumValue = _netReserveFlows.preciseMul(premiumPercentage);      // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (1e18)     // Reverts if price is not found     uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);      // Get reserve asset decimals     uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();     uint256 normalizedTotalReserveQuantityNetFees = _netReserveFlows.preciseDiv(10 ** reserveAssetDecimals);     uint256 normalizedTotalReserveQuantityNetFeesAndPremium = _netReserveFlows.sub(premiumValue).preciseDiv(10 ** reserveAssetDecimals);      // Calculate SetTokens to mint to issuer     uint256 denominator = _setTotalSupply.preciseMul(setTokenValuation).add(normalizedTotalReserveQuantityNetFees).sub(normalizedTotalReserveQuantityNetFeesAndPremium);     return normalizedTotalReserveQuantityNetFeesAndPremium.preciseMul(_setTotalSupply).preciseDiv(denominator); }  function _getRedeemReserveQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     internal     view     returns (uint256) {     // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (10e18)     // Reverts if price is not found     uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);      uint256 totalRedeemValueInPreciseUnits = _setTokenQuantity.preciseMul(setTokenValuation);     // Get reserve asset decimals     uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();     uint256 prePremiumReserveQuantity = totalRedeemValueInPreciseUnits.preciseMul(10 ** reserveAssetDecimals);      uint256 premiumPercentage = _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);     uint256 premiumQuantity = prePremiumReserveQuantity.preciseMulCeil(premiumPercentage);      return prePremiumReserveQuantity.sub(premiumQuantity); }  /**  * The new position multiplier is calculated as follows:  * inflationPercentage = (newSupply - oldSupply) / newSupply  * newMultiplier = (1 - inflationPercentage) * positionMultiplier  */ function _getIssuePositionMultiplier(     ISetToken _setToken,     ActionInfo memory _issueInfo )     internal     view     returns (uint256, int256) {     // Calculate inflation and new position multiplier. Note: Round inflation up in order to round position multiplier down     uint256 newTotalSupply = _issueInfo.setTokenQuantity.add(_issueInfo.previousSetTokenSupply);     int256 newPositionMultiplier = _setToken.positionMultiplier()         .mul(_issueInfo.previousSetTokenSupply.toInt256())         .div(newTotalSupply.toInt256());      return (newTotalSupply, newPositionMultiplier); }  /**  * Calculate deflation and new position multiplier. Note: Round deflation down in order to round position multiplier down  *  * The new position multiplier is calculated as follows:  * deflationPercentage = (oldSupply - newSupply) / newSupply  * newMultiplier = (1 + deflationPercentage) * positionMultiplier  */ function _getRedeemPositionMultiplier(     ISetToken _setToken,     uint256 _setTokenQuantity,     ActionInfo memory _redeemInfo )     internal     view     returns (uint256, int256) {     uint256 newTotalSupply = _redeemInfo.previousSetTokenSupply.sub(_setTokenQuantity);     int256 newPositionMultiplier = _setToken.positionMultiplier()         .mul(_redeemInfo.previousSetTokenSupply.toInt256())         .div(newTotalSupply.toInt256());      return (newTotalSupply, newPositionMultiplier); }  /**  * The new position reserve asset unit is calculated as follows:  * totalReserve = (oldUnit * oldSetTokenSupply) + reserveQuantity  * newUnit = totalReserve / newSetTokenSupply  */ function _getIssuePositionUnit(     ISetToken _setToken,     address _reserveAsset,     ActionInfo memory _issueInfo )     internal     view     returns (uint256) {     uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();     uint256 totalReserve = existingUnit         .preciseMul(_issueInfo.previousSetTokenSupply)         .add(_issueInfo.netFlowQuantity);      return totalReserve.preciseDiv(_issueInfo.newSetTokenSupply); }  /**  * The new position reserve asset unit is calculated as follows:  * totalReserve = (oldUnit * oldSetTokenSupply) - reserveQuantityToSendOut  * newUnit = totalReserve / newSetTokenSupply  */ function _getRedeemPositionUnit(     ISetToken _setToken,     address _reserveAsset,     ActionInfo memory _redeemInfo )     internal     view     returns (uint256) {     uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();     uint256 totalExistingUnits = existingUnit.preciseMul(_redeemInfo.previousSetTokenSupply);      uint256 outflow = _redeemInfo.netFlowQuantity.add(_redeemInfo.protocolFees).add(_redeemInfo.managerFee);      // Require withdrawable quantity is greater than existing collateral     require(totalExistingUnits &gt;= outflow, "Must be greater than total available collateral");      return totalExistingUnits.sub(outflow).preciseDiv(_redeemInfo.newSetTokenSupply); }  /**  * If a pre-issue hook has been configured, call the external-protocol contract. Pre-issue hook logic  * can contain arbitrary logic including validations, external function calls, etc.  */ function _callPreIssueHooks(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity,     address _caller,     address _to )     internal {     INAVIssuanceHook preIssueHook = navIssuanceSettings[_setToken].managerIssuanceHook;     if (address(preIssueHook) != address(0)) {         preIssueHook.invokePreIssueHook(_setToken, _reserveAsset, _reserveAssetQuantity, _caller, _to);     } }  /**  * If a pre-redeem hook has been configured, call the external-protocol contract.  */ function _callPreRedeemHooks(ISetToken _setToken, uint256 _setQuantity, address _caller, address _to) internal {     INAVIssuanceHook preRedeemHook = navIssuanceSettings[_setToken].managerRedemptionHook;     if (address(preRedeemHook) != address(0)) {         preRedeemHook.invokePreRedeemHook(_setToken, _setQuantity, _caller, _to);     } }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 05:31:19 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: /*
    Copyright 2020 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";
import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";
import { SignedSafeMath } from "@openzeppelin/contracts/math/SignedSafeMath.sol";

import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";
import { IController } from "../../interfaces/IController.sol";
import { INAVIssuanceHook } from "../../interfaces/INAVIssuanceHook.sol";
import { Invoke } from "../lib/Invoke.sol";
import { ISetToken } from "../../interfaces/ISetToken.sol";
import { IWETH } from "../../interfaces/external/IWETH.sol";
import { ModuleBase } from "../lib/ModuleBase.sol";
import { Position } from "../lib/Position.sol";
import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";
import { ResourceIdentifier } from "../lib/ResourceIdentifier.sol";


/**
 * @title NavIssuanceModule
 * @author Set Protocol
 *
 * Module that enables issuance and redemption with any valid ERC20 token or ETH if allowed by the manager. Sender receives
 * a proportional amount of SetTokens on issuance or ERC20 token on redemption based on the calculated net asset value using
 * oracle prices. Manager is able to enforce a premium / discount on issuance / redemption to avoid arbitrage and front
 * running when relying on oracle prices. Managers can charge a fee (denominated in reserve asset).
 */
contract NavIssuanceModule is ModuleBase, ReentrancyGuard {
    using AddressArrayUtils for address[];
    using Invoke for ISetToken;
    using Position for ISetToken;
    using PreciseUnitMath for uint256;
    using PreciseUnitMath for int256;
    using ResourceIdentifier for IController;
    using SafeMath for uint256;
    using SafeCast for int256;
    using SafeCast for uint256;
    using SignedSafeMath for int256;

    /* ============ Events ============ */

    event SetTokenNAVIssued(
        ISetToken indexed _setToken,
        address _issuer,
        address _to,
        address _reserveAsset,
        address _hookContract,
        uint256 _setTokenQuantity,
        uint256 _managerFee,
        uint256 _premium
    );

    event SetTokenNAVRedeemed(
        ISetToken indexed _setToken,
        address _redeemer,
        address _to,
        address _reserveAsset,
        address _hookContract,
        uint256 _setTokenQuantity,
        uint256 _managerFee,
        uint256 _premium
    );

    event ReserveAssetAdded(
        ISetToken indexed _setToken,
        address _newReserveAsset
    );

    event ReserveAssetRemoved(
        ISetToken indexed _setToken,
        address _removedReserveAsset
    );

    event PremiumEdited(
        ISetToken indexed _setToken,
        uint256 _newPremium
    );

    event ManagerFeeEdited(
        ISetToken indexed _setToken,
        uint256 _newManagerFee,
        uint256 _index
    );

    event FeeRecipientEdited(
        ISetToken indexed _setToken,
        address _feeRecipient
    );

    /* ============ Structs ============ */

    struct NAVIssuanceSettings {
        INAVIssuanceHook managerIssuanceHook;      // Issuance hook configurations
        INAVIssuanceHook managerRedemptionHook;    // Redemption hook configurations
        address[] reserveAssets;                       // Allowed reserve assets - Must have a price enabled with the price oracle
        address feeRecipient;                          // Manager fee recipient
        uint256[2] managerFees;                        // Manager fees. 0 index is issue and 1 index is redeem fee (0.01% = 1e14, 1% = 1e16)
        uint256 maxManagerFee;                         // Maximum fee manager is allowed to set for issue and redeem
        uint256 premiumPercentage;                     // Premium percentage (0.01% = 1e14, 1% = 1e16). This premium is a buffer around oracle
                                                       // prices paid by user to the SetToken, which prevents arbitrage and oracle front running
        uint256 maxPremiumPercentage;                  // Maximum premium percentage manager is allowed to set (configured by manager)
        uint256 minSetTokenSupply;                     // Minimum SetToken supply required for issuance and redemption
                                                       // to prevent dramatic inflationary changes to the SetToken's position multiplier
    }

    struct ActionInfo {
        uint256 preFeeReserveQuantity;                 // Reserve value before fees; During issuance, represents raw quantity
                                                       // During redeem, represents post-premium value
        uint256 protocolFees;                          // Total protocol fees (direct + manager revenue share)
        uint256 managerFee;                            // Total manager fee paid in reserve asset
        uint256 netFlowQuantity;                       // When issuing, quantity of reserve asset sent to SetToken
                                                       // When redeeming, quantity of reserve asset sent to redeemer
        uint256 setTokenQuantity;                      // When issuing, quantity of SetTokens minted to mintee
                                                       // When redeeming, quantity of SetToken redeemed
        uint256 previousSetTokenSupply;                // SetToken supply prior to issue/redeem action
        uint256 newSetTokenSupply;                     // SetToken supply after issue/redeem action
        int256 newPositionMultiplier;                  // SetToken position multiplier after issue/redeem
        uint256 newReservePositionUnit;                // SetToken reserve asset position unit after issue/redeem
    }

    /* ============ State Variables ============ */

    // Wrapped ETH address
    IWETH public immutable weth;

    // Mapping of SetToken to NAV issuance settings struct
    mapping(ISetToken => NAVIssuanceSettings) public navIssuanceSettings;

    // Mapping to efficiently check a SetToken's reserve asset validity
    // SetToken => reserveAsset => isReserveAsset
    mapping(ISetToken => mapping(address => bool)) public isReserveAsset;

    /* ============ Constants ============ */

    // 0 index stores the manager fee in managerFees array, percentage charged on issue (denominated in reserve asset)
    uint256 constant internal MANAGER_ISSUE_FEE_INDEX = 0;

    // 1 index stores the manager fee percentage in managerFees array, charged on redeem
    uint256 constant internal MANAGER_REDEEM_FEE_INDEX = 1;

    // 0 index stores the manager revenue share protocol fee % on the controller, charged in the issuance function
    uint256 constant internal PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX = 0;

    // 1 index stores the manager revenue share protocol fee % on the controller, charged in the redeem function
    uint256 constant internal PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX = 1;

    // 2 index stores the direct protocol fee % on the controller, charged in the issuance function
    uint256 constant internal PROTOCOL_ISSUE_DIRECT_FEE_INDEX = 2;

    // 3 index stores the direct protocol fee % on the controller, charged in the redeem function
    uint256 constant internal PROTOCOL_REDEEM_DIRECT_FEE_INDEX = 3;

    /* ============ Constructor ============ */

    /**
     * @param _controller               Address of controller contract
     * @param _weth                     Address of wrapped eth
     */
    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {
        weth = _weth;
    }

    /* ============ External Functions ============ */

    /**
     * Deposits the allowed reserve asset into the SetToken and mints the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _reserveAsset                 Address of the reserve asset to issue with
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance
     * @param _to                           Address to mint SetToken to
     */
    function issue(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity,
        uint256 _minSetTokenReceiveQuantity,
        address _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, _reserveAsset, _reserveAssetQuantity);

        _callPreIssueHooks(_setToken, _reserveAsset, _reserveAssetQuantity, msg.sender, _to);

        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, _reserveAsset, _reserveAssetQuantity);

        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);

        _transferCollateralAndHandleFees(_setToken, IERC20(_reserveAsset), issueInfo);

        _handleIssueStateUpdates(_setToken, _reserveAsset, _to, issueInfo);
    }

    /**
     * Wraps ETH and deposits WETH if allowed into the SetToken and mints the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance
     * @param _to                           Address to mint SetToken to
     */
    function issueWithEther(
        ISetToken _setToken,
        uint256 _minSetTokenReceiveQuantity,
        address _to
    )
        external
        payable
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        weth.deposit{ value: msg.value }();

        _validateCommon(_setToken, address(weth), msg.value);

        _callPreIssueHooks(_setToken, address(weth), msg.value, msg.sender, _to);

        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, address(weth), msg.value);

        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);

        _transferWETHAndHandleFees(_setToken, issueInfo);

        _handleIssueStateUpdates(_setToken, address(weth), _to, issueInfo);
    }

    /**
     * Redeems a SetToken into a valid reserve asset representing the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address. Only valid if there are available reserve units on the SetToken.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _reserveAsset                 Address of the reserve asset to redeem with
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive
     * @param _to                           Address to redeem reserve asset to
     */
    function redeem(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity,
        uint256 _minReserveReceiveQuantity,
        address _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, _reserveAsset, _setTokenQuantity);

        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);

        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, _reserveAsset, _setTokenQuantity);

        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);

        _setToken.burn(msg.sender, _setTokenQuantity);

        // Instruct the SetToken to transfer the reserve asset back to the user
        _setToken.strictInvokeTransfer(
            _reserveAsset,
            _to,
            redeemInfo.netFlowQuantity
        );

        _handleRedemptionFees(_setToken, _reserveAsset, redeemInfo);

        _handleRedeemStateUpdates(_setToken, _reserveAsset, _to, redeemInfo);
    }

    /**
     * Redeems a SetToken into Ether (if WETH is valid) representing the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address. Only valid if there are available WETH units on the SetToken.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive
     * @param _to                           Address to redeem reserve asset to
     */
    function redeemIntoEther(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        uint256 _minReserveReceiveQuantity,
        address payable _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, address(weth), _setTokenQuantity);

        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);

        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, address(weth), _setTokenQuantity);

        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);

        _setToken.burn(msg.sender, _setTokenQuantity);

        // Instruct the SetToken to transfer WETH from SetToken to module
        _setToken.strictInvokeTransfer(
            address(weth),
            address(this),
            redeemInfo.netFlowQuantity
        );

        weth.withdraw(redeemInfo.netFlowQuantity);

        _to.transfer(redeemInfo.netFlowQuantity);

        _handleRedemptionFees(_setToken, address(weth), redeemInfo);

        _handleRedeemStateUpdates(_setToken, address(weth), _to, redeemInfo);
    }

    /**
     * SET MANAGER ONLY. Add an allowed reserve asset
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset to add
     */
    function addReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {
        require(!isReserveAsset[_setToken][_reserveAsset], "Reserve asset already exists");

        navIssuanceSettings[_setToken].reserveAssets.push(_reserveAsset);
        isReserveAsset[_setToken][_reserveAsset] = true;

        emit ReserveAssetAdded(_setToken, _reserveAsset);
    }

    /**
     * SET MANAGER ONLY. Remove a reserve asset
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset to remove
     */
    function removeReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {
        require(isReserveAsset[_setToken][_reserveAsset], "Reserve asset does not exist");

        navIssuanceSettings[_setToken].reserveAssets = navIssuanceSettings[_setToken].reserveAssets.remove(_reserveAsset);
        delete isReserveAsset[_setToken][_reserveAsset];

        emit ReserveAssetRemoved(_setToken, _reserveAsset);
    }

    /**
     * SET MANAGER ONLY. Edit the premium percentage
     *
     * @param _setToken                     Instance of the SetToken
     * @param _premiumPercentage            Premium percentage in 10e16 (e.g. 10e16 = 1%)
     */
    function editPremium(ISetToken _setToken, uint256 _premiumPercentage) external onlyManagerAndValidSet(_setToken) {
        require(_premiumPercentage <= navIssuanceSettings[_setToken].maxPremiumPercentage, "Premium must be less than maximum allowed");

        navIssuanceSettings[_setToken].premiumPercentage = _premiumPercentage;

        emit PremiumEdited(_setToken, _premiumPercentage);
    }

    /**
     * SET MANAGER ONLY. Edit manager fee
     *
     * @param _setToken                     Instance of the SetToken
     * @param _managerFeePercentage         Manager fee percentage in 10e16 (e.g. 10e16 = 1%)
     * @param _managerFeeIndex              Manager fee index. 0 index is issue fee, 1 index is redeem fee
     */
    function editManagerFee(
        ISetToken _setToken,
        uint256 _managerFeePercentage,
        uint256 _managerFeeIndex
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        require(_managerFeePercentage <= navIssuanceSettings[_setToken].maxManagerFee, "Manager fee must be less than maximum allowed");

        navIssuanceSettings[_setToken].managerFees[_managerFeeIndex] = _managerFeePercentage;

        emit ManagerFeeEdited(_setToken, _managerFeePercentage, _managerFeeIndex);
    }

    /**
     * SET MANAGER ONLY. Edit the manager fee recipient
     *
     * @param _setToken                     Instance of the SetToken
     * @param _managerFeeRecipient          Manager fee recipient
     */
    function editFeeRecipient(ISetToken _setToken, address _managerFeeRecipient) external onlyManagerAndValidSet(_setToken) {
        require(_managerFeeRecipient != address(0), "Fee recipient must not be 0 address");

        navIssuanceSettings[_setToken].feeRecipient = _managerFeeRecipient;

        emit FeeRecipientEdited(_setToken, _managerFeeRecipient);
    }

    /**
     * SET MANAGER ONLY. Initializes this module to the SetToken with hooks, allowed reserve assets,
     * fees and issuance premium. Only callable by the SetToken's manager. Hook addresses are optional.
     * Address(0) means that no hook will be called.
     *
     * @param _setToken                     Instance of the SetToken to issue
     * @param _navIssuanceSettings          NAVIssuanceSettings struct defining parameters
     */
    function initialize(
        ISetToken _setToken,
        NAVIssuanceSettings memory _navIssuanceSettings
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        require(_navIssuanceSettings.reserveAssets.length > 0, "Reserve assets must be greater than 0");
        require(_navIssuanceSettings.maxManagerFee < PreciseUnitMath.preciseUnit(), "Max manager fee must be less than 100%");
        require(_navIssuanceSettings.maxPremiumPercentage < PreciseUnitMath.preciseUnit(), "Max premium percentage must be less than 100%");
        require(_navIssuanceSettings.managerFees[0] <= _navIssuanceSettings.maxManagerFee, "Manager issue fee must be less than max");
        require(_navIssuanceSettings.managerFees[1] <= _navIssuanceSettings.maxManagerFee, "Manager redeem fee must be less than max");
        require(_navIssuanceSettings.premiumPercentage <= _navIssuanceSettings.maxPremiumPercentage, "Premium must be less than max");
        require(_navIssuanceSettings.feeRecipient != address(0), "Fee Recipient must be non-zero address.");
        // Initial mint of Set cannot use NAVIssuance since minSetTokenSupply must be > 0
        require(_navIssuanceSettings.minSetTokenSupply > 0, "Min SetToken supply must be greater than 0");

        for (uint256 i = 0; i < _navIssuanceSettings.reserveAssets.length; i++) {
            require(!isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]], "Reserve assets must be unique");
            isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]] = true;
        }

        navIssuanceSettings[_setToken] = _navIssuanceSettings;

        _setToken.initializeModule();
    }

    /**
     * Removes this module from the SetToken, via call by the SetToken. Issuance settings and
     * reserve asset states are deleted.
     */
    function removeModule() external override {
        ISetToken setToken = ISetToken(msg.sender);
        for (uint256 i = 0; i < navIssuanceSettings[setToken].reserveAssets.length; i++) {
            delete isReserveAsset[setToken][navIssuanceSettings[setToken].reserveAssets[i]];
        }

        delete navIssuanceSettings[setToken];
    }

    receive() external payable {}

    /* ============ External Getter Functions ============ */

    function getReserveAssets(ISetToken _setToken) external view returns (address[] memory) {
        return navIssuanceSettings[_setToken].reserveAssets;
    }

    function getIssuePremium(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (uint256)
    {
        return _getIssuePremium(_setToken, _reserveAsset, _reserveAssetQuantity);
    }

    function getRedeemPremium(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (uint256)
    {
        return _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);
    }

    function getManagerFee(ISetToken _setToken, uint256 _managerFeeIndex) external view returns (uint256) {
        return navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];
    }

    /**
     * Get the expected SetTokens minted to recipient on issuance
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     *
     * @return  uint256                     Expected SetTokens to be minted to recipient
     */
    function getExpectedSetTokenIssueQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (uint256)
    {
        (,, uint256 netReserveFlow) = _getFees(
            _setToken,
            _reserveAssetQuantity,
            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,
            MANAGER_ISSUE_FEE_INDEX
        );

        uint256 setTotalSupply = _setToken.totalSupply();

        return _getSetTokenMintQuantity(
            _setToken,
            _reserveAsset,
            netReserveFlow,
            setTotalSupply
        );
    }

    /**
     * Get the expected reserve asset to be redeemed
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     *
     * @return  uint256                     Expected reserve asset quantity redeemed
     */
    function getExpectedReserveRedeemQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (uint256)
    {
        uint256 preFeeReserveQuantity = _getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

        (,, uint256 netReserveFlows) = _getFees(
            _setToken,
            preFeeReserveQuantity,
            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
            MANAGER_REDEEM_FEE_INDEX
        );

        return netReserveFlows;
    }

    /**
     * Checks if issue is valid
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     *
     * @return  bool                        Returns true if issue is valid
     */
    function isIssueValid(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (bool)
    {
        uint256 setTotalSupply = _setToken.totalSupply();

    return _reserveAssetQuantity != 0
            && isReserveAsset[_setToken][_reserveAsset]
            && setTotalSupply >= navIssuanceSettings[_setToken].minSetTokenSupply;
    }

    /**
     * Checks if redeem is valid
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     *
     * @return  bool                        Returns true if redeem is valid
     */
    function isRedeemValid(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (bool)
    {
        uint256 setTotalSupply = _setToken.totalSupply();

        if (
            _setTokenQuantity == 0
            || !isReserveAsset[_setToken][_reserveAsset]
            || setTotalSupply < navIssuanceSettings[_setToken].minSetTokenSupply.add(_setTokenQuantity)
        ) {
            return false;
        } else {
            uint256 totalRedeemValue =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

            (,, uint256 expectedRedeemQuantity) = _getFees(
                _setToken,
                totalRedeemValue,
                PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
                PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
                MANAGER_REDEEM_FEE_INDEX
            );

            uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();

            return existingUnit.preciseMul(setTotalSupply) >= expectedRedeemQuantity;
        }
    }

    /* ============ Internal Functions ============ */

    function _validateCommon(ISetToken _setToken, address _reserveAsset, uint256 _quantity) internal view {
        require(_quantity > 0, "Quantity must be > 0");
        require(isReserveAsset[_setToken][_reserveAsset], "Must be valid reserve asset");
    }

    function _validateIssuanceInfo(ISetToken _setToken, uint256 _minSetTokenReceiveQuantity, ActionInfo memory _issueInfo) internal view {
        // Check that total supply is greater than min supply needed for issuance
        // Note: A min supply amount is needed to avoid division by 0 when SetToken supply is 0
        require(
            _issueInfo.previousSetTokenSupply >= navIssuanceSettings[_setToken].minSetTokenSupply,
            "Supply must be greater than minimum to enable issuance"
        );

        require(_issueInfo.setTokenQuantity >= _minSetTokenReceiveQuantity, "Must be greater than min SetToken");
    }

    function _validateRedemptionInfo(
        ISetToken _setToken,
        uint256 _minReserveReceiveQuantity,
        ActionInfo memory _redeemInfo
    )
        internal
        view
    {
        // Check that new supply is more than min supply needed for redemption
        // Note: A min supply amount is needed to avoid division by 0 when redeeming SetToken to 0
        require(
            _redeemInfo.newSetTokenSupply >= navIssuanceSettings[_setToken].minSetTokenSupply,
            "Supply must be greater than minimum to enable redemption"
        );

        require(_redeemInfo.netFlowQuantity >= _minReserveReceiveQuantity, "Must be greater than min receive reserve quantity");
    }

    function _createIssuanceInfo(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        internal
        view
        returns (ActionInfo memory)
    {
        ActionInfo memory issueInfo;

        issueInfo.previousSetTokenSupply = _setToken.totalSupply();

        issueInfo.preFeeReserveQuantity = _reserveAssetQuantity;

        (issueInfo.protocolFees, issueInfo.managerFee, issueInfo.netFlowQuantity) = _getFees(
            _setToken,
            issueInfo.preFeeReserveQuantity,
            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,
            MANAGER_ISSUE_FEE_INDEX
        );

        issueInfo.setTokenQuantity = _getSetTokenMintQuantity(
            _setToken,
            _reserveAsset,
            issueInfo.netFlowQuantity,
            issueInfo.previousSetTokenSupply
        );

        (issueInfo.newSetTokenSupply, issueInfo.newPositionMultiplier) = _getIssuePositionMultiplier(_setToken, issueInfo);

        issueInfo.newReservePositionUnit = _getIssuePositionUnit(_setToken, _reserveAsset, issueInfo);

        return issueInfo;
    }

    function _createRedemptionInfo(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        internal
        view
        returns (ActionInfo memory)
    {
        ActionInfo memory redeemInfo;

        redeemInfo.setTokenQuantity = _setTokenQuantity;

        redeemInfo.preFeeReserveQuantity =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

        (redeemInfo.protocolFees, redeemInfo.managerFee, redeemInfo.netFlowQuantity) = _getFees(
            _setToken,
            redeemInfo.preFeeReserveQuantity,
            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
            MANAGER_REDEEM_FEE_INDEX
        );

        redeemInfo.previousSetTokenSupply = _setToken.totalSupply();

        (redeemInfo.newSetTokenSupply, redeemInfo.newPositionMultiplier) = _getRedeemPositionMultiplier(_setToken, _setTokenQuantity, redeemInfo);

        redeemInfo.newReservePositionUnit = _getRedeemPositionUnit(_setToken, _reserveAsset, redeemInfo);

        return redeemInfo;
    }

    /**
     * Transfer reserve asset from user to SetToken and fees from user to appropriate fee recipients
     */
    function _transferCollateralAndHandleFees(ISetToken _setToken, IERC20 _reserveAsset, ActionInfo memory _issueInfo) internal {
        transferFrom(_reserveAsset, msg.sender, address(_setToken), _issueInfo.netFlowQuantity);

        if (_issueInfo.protocolFees > 0) {
            transferFrom(_reserveAsset, msg.sender, controller.feeRecipient(), _issueInfo.protocolFees);
        }

        if (_issueInfo.managerFee > 0) {
            transferFrom(_reserveAsset, msg.sender, navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);
        }
    }


    /**
      * Transfer WETH from module to SetToken and fees from module to appropriate fee recipients
     */
    function _transferWETHAndHandleFees(ISetToken _setToken, ActionInfo memory _issueInfo) internal {
        weth.transfer(address(_setToken), _issueInfo.netFlowQuantity);

        if (_issueInfo.protocolFees > 0) {
            weth.transfer(controller.feeRecipient(), _issueInfo.protocolFees);
        }

        if (_issueInfo.managerFee > 0) {
            weth.transfer(navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);
        }
    }

    function _handleIssueStateUpdates(
        ISetToken _setToken,
        address _reserveAsset,
        address _to,
        ActionInfo memory _issueInfo
    )
        internal
    {
        _setToken.editPositionMultiplier(_issueInfo.newPositionMultiplier);

        _setToken.editDefaultPosition(_reserveAsset, _issueInfo.newReservePositionUnit);

        _setToken.mint(_to, _issueInfo.setTokenQuantity);

        emit SetTokenNAVIssued(
            _setToken,
            msg.sender,
            _to,
            _reserveAsset,
            address(navIssuanceSettings[_setToken].managerIssuanceHook),
            _issueInfo.setTokenQuantity,
            _issueInfo.managerFee,
            _issueInfo.protocolFees
        );
    }

    function _handleRedeemStateUpdates(
        ISetToken _setToken,
        address _reserveAsset,
        address _to,
        ActionInfo memory _redeemInfo
    )
        internal
    {
        _setToken.editPositionMultiplier(_redeemInfo.newPositionMultiplier);

        _setToken.editDefaultPosition(_reserveAsset, _redeemInfo.newReservePositionUnit);

        emit SetTokenNAVRedeemed(
            _setToken,
            msg.sender,
            _to,
            _reserveAsset,
            address(navIssuanceSettings[_setToken].managerRedemptionHook),
            _redeemInfo.setTokenQuantity,
            _redeemInfo.managerFee,
            _redeemInfo.protocolFees
        );
    }

    function _handleRedemptionFees(ISetToken _setToken, address _reserveAsset, ActionInfo memory _redeemInfo) internal {
        // Instruct the SetToken to transfer protocol fee to fee recipient if there is a fee
        payProtocolFeeFromSetToken(_setToken, _reserveAsset, _redeemInfo.protocolFees);

        // Instruct the SetToken to transfer manager fee to manager fee recipient if there is a fee
        if (_redeemInfo.managerFee > 0) {
            _setToken.strictInvokeTransfer(
                _reserveAsset,
                navIssuanceSettings[_setToken].feeRecipient,
                _redeemInfo.managerFee
            );
        }
    }

    /**
     * Returns the issue premium percentage. Virtual function that can be overridden in future versions of the module
     * and can contain arbitrary logic to calculate the issuance premium.
     */
    function _getIssuePremium(
        ISetToken _setToken,
        address /* _reserveAsset */,
        uint256 /* _reserveAssetQuantity */
    )
        virtual
        internal
        view
        returns (uint256)
    {
        return navIssuanceSettings[_setToken].premiumPercentage;
    }

    /**
     * Returns the redeem premium percentage. Virtual function that can be overridden in future versions of the module
     * and can contain arbitrary logic to calculate the redemption premium.
     */
    function _getRedeemPremium(
        ISetToken _setToken,
        address /* _reserveAsset */,
        uint256 /* _setTokenQuantity */
    )
        virtual
        internal
        view
        returns (uint256)
    {
        return navIssuanceSettings[_setToken].premiumPercentage;
    }

    /**
     * Returns the fees attributed to the manager and the protocol. The fees are calculated as follows:
     *
     * ManagerFee = (manager fee % - % to protocol) * reserveAssetQuantity
     * Protocol Fee = (% manager fee share + direct fee %) * reserveAssetQuantity
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAssetQuantity         Quantity of reserve asset to calculate fees from
     * @param _protocolManagerFeeIndex      Index to pull rev share NAV Issuance fee from the Controller
     * @param _protocolDirectFeeIndex       Index to pull direct NAV issuance fee from the Controller
     * @param _managerFeeIndex              Index from NAVIssuanceSettings (0 = issue fee, 1 = redeem fee)
     *
     * @return  uint256                     Fees paid to the protocol in reserve asset
     * @return  uint256                     Fees paid to the manager in reserve asset
     * @return  uint256                     Net reserve to user net of fees
     */
    function _getFees(
        ISetToken _setToken,
        uint256 _reserveAssetQuantity,
        uint256 _protocolManagerFeeIndex,
        uint256 _protocolDirectFeeIndex,
        uint256 _managerFeeIndex
    )
        internal
        view
        returns (uint256, uint256, uint256)
    {
        (uint256 protocolFeePercentage, uint256 managerFeePercentage) = _getProtocolAndManagerFeePercentages(
            _setToken,
            _protocolManagerFeeIndex,
            _protocolDirectFeeIndex,
            _managerFeeIndex
        );

        // Calculate total notional fees
        uint256 protocolFees = protocolFeePercentage.preciseMul(_reserveAssetQuantity);
        uint256 managerFee = managerFeePercentage.preciseMul(_reserveAssetQuantity);

        uint256 netReserveFlow = _reserveAssetQuantity.sub(protocolFees).sub(managerFee);

        return (protocolFees, managerFee, netReserveFlow);
    }

    function _getProtocolAndManagerFeePercentages(
        ISetToken _setToken,
        uint256 _protocolManagerFeeIndex,
        uint256 _protocolDirectFeeIndex,
        uint256 _managerFeeIndex
    )
        internal
        view
        returns(uint256, uint256)
    {
        // Get protocol fee percentages
        uint256 protocolDirectFeePercent = controller.getModuleFee(address(this), _protocolDirectFeeIndex);
        uint256 protocolManagerShareFeePercent = controller.getModuleFee(address(this), _protocolManagerFeeIndex);
        uint256 managerFeePercent = navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];

        // Calculate revenue share split percentage
        uint256 protocolRevenueSharePercentage = protocolManagerShareFeePercent.preciseMul(managerFeePercent);
        uint256 managerRevenueSharePercentage = managerFeePercent.sub(protocolRevenueSharePercentage);
        uint256 totalProtocolFeePercentage = protocolRevenueSharePercentage.add(protocolDirectFeePercent);

        return (totalProtocolFeePercentage, managerRevenueSharePercentage);
    }

    function _getSetTokenMintQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _netReserveFlows,            // Value of reserve asset net of fees
        uint256 _setTotalSupply
    )
        internal
        view
        returns (uint256)
    {
        uint256 premiumPercentage = _getIssuePremium(_setToken, _reserveAsset, _netReserveFlows);
        uint256 premiumValue = _netReserveFlows.preciseMul(premiumPercentage);

        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (1e18)
        // Reverts if price is not found
        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);

        // Get reserve asset decimals
        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();
        uint256 normalizedTotalReserveQuantityNetFees = _netReserveFlows.preciseDiv(10 ** reserveAssetDecimals);
        uint256 normalizedTotalReserveQuantityNetFeesAndPremium = _netReserveFlows.sub(premiumValue).preciseDiv(10 ** reserveAssetDecimals);

        // Calculate SetTokens to mint to issuer
        uint256 denominator = _setTotalSupply.preciseMul(setTokenValuation).add(normalizedTotalReserveQuantityNetFees).sub(normalizedTotalReserveQuantityNetFeesAndPremium);
        return normalizedTotalReserveQuantityNetFeesAndPremium.preciseMul(_setTotalSupply).preciseDiv(denominator);
    }

    function _getRedeemReserveQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        internal
        view
        returns (uint256)
    {
        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (10e18)
        // Reverts if price is not found
        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);

        uint256 totalRedeemValueInPreciseUnits = _setTokenQuantity.preciseMul(setTokenValuation);
        // Get reserve asset decimals
        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();
        uint256 prePremiumReserveQuantity = totalRedeemValueInPreciseUnits.preciseMul(10 ** reserveAssetDecimals);

        uint256 premiumPercentage = _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);
        uint256 premiumQuantity = prePremiumReserveQuantity.preciseMulCeil(premiumPercentage);

        return prePremiumReserveQuantity.sub(premiumQuantity);
    }

    /**
     * The new position multiplier is calculated as follows:
     * inflationPercentage = (newSupply - oldSupply) / newSupply
     * newMultiplier = (1 - inflationPercentage) * positionMultiplier
     */
    function _getIssuePositionMultiplier(
        ISetToken _setToken,
        ActionInfo memory _issueInfo
    )
        internal
        view
        returns (uint256, int256)
    {
        // Calculate inflation and new position multiplier. Note: Round inflation up in order to round position multiplier down
        uint256 newTotalSupply = _issueInfo.setTokenQuantity.add(_issueInfo.previousSetTokenSupply);
        int256 newPositionMultiplier = _setToken.positionMultiplier()
            .mul(_issueInfo.previousSetTokenSupply.toInt256())
            .div(newTotalSupply.toInt256());

        return (newTotalSupply, newPositionMultiplier);
    }

    /**
     * Calculate deflation and new position multiplier. Note: Round deflation down in order to round position multiplier down
     *
     * The new position multiplier is calculated as follows:
     * deflationPercentage = (oldSupply - newSupply) / newSupply
     * newMultiplier = (1 + deflationPercentage) * positionMultiplier
     */
    function _getRedeemPositionMultiplier(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        ActionInfo memory _redeemInfo
    )
        internal
        view
        returns (uint256, int256)
    {
        uint256 newTotalSupply = _redeemInfo.previousSetTokenSupply.sub(_setTokenQuantity);
        int256 newPositionMultiplier = _setToken.positionMultiplier()
            .mul(_redeemInfo.previousSetTokenSupply.toInt256())
            .div(newTotalSupply.toInt256());

        return (newTotalSupply, newPositionMultiplier);
    }

    /**
     * The new position reserve asset unit is calculated as follows:
     * totalReserve = (oldUnit * oldSetTokenSupply) + reserveQuantity
     * newUnit = totalReserve / newSetTokenSupply
     */
    function _getIssuePositionUnit(
        ISetToken _setToken,
        address _reserveAsset,
        ActionInfo memory _issueInfo
    )
        internal
        view
        returns (uint256)
    {
        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();
        uint256 totalReserve = existingUnit
            .preciseMul(_issueInfo.previousSetTokenSupply)
            .add(_issueInfo.netFlowQuantity);

        return totalReserve.preciseDiv(_issueInfo.newSetTokenSupply);
    }

    /**
     * The new position reserve asset unit is calculated as follows:
     * totalReserve = (oldUnit * oldSetTokenSupply) - reserveQuantityToSendOut
     * newUnit = totalReserve / newSetTokenSupply
     */
    function _getRedeemPositionUnit(
        ISetToken _setToken,
        address _reserveAsset,
        ActionInfo memory _redeemInfo
    )
        internal
        view
        returns (uint256)
    {
        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();
        uint256 totalExistingUnits = existingUnit.preciseMul(_redeemInfo.previousSetTokenSupply);

        uint256 outflow = _redeemInfo.netFlowQuantity.add(_redeemInfo.protocolFees).add(_redeemInfo.managerFee);

        // Require withdrawable quantity is greater than existing collateral
        require(totalExistingUnits >= outflow, "Must be greater than total available collateral");

        return totalExistingUnits.sub(outflow).preciseDiv(_redeemInfo.newSetTokenSupply);
    }

    /**
     * If a pre-issue hook has been configured, call the external-protocol contract. Pre-issue hook logic
     * can contain arbitrary logic including validations, external function calls, etc.
     */
    function _callPreIssueHooks(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity,
        address _caller,
        address _to
    )
        internal
    {
        INAVIssuanceHook preIssueHook = navIssuanceSettings[_setToken].managerIssuanceHook;
        if (address(preIssueHook) != address(0)) {
            preIssueHook.invokePreIssueHook(_setToken, _reserveAsset, _reserveAssetQuantity, _caller, _to);
        }
    }

    /**
     * If a pre-redeem hook has been configured, call the external-protocol contract.
     */
    function _callPreRedeemHooks(ISetToken _setToken, uint256 _setQuantity, address _caller, address _to) internal {
        INAVIssuanceHook preRedeemHook = navIssuanceSettings[_setToken].managerRedemptionHook;
        if (address(preRedeemHook) != address(0)) {
            preRedeemHook.invokePreRedeemHook(_setToken, _setQuantity, _caller, _to);
        }
    }
}.]

Given the user's task and the brainstorming ideas provided:
Task: "/*
    Copyright 2020 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";
import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";
import { SignedSafeMath } from "@openzeppelin/contracts/math/SignedSafeMath.sol";

import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";
import { IController } from "../../interfaces/IController.sol";
import { INAVIssuanceHook } from "../../interfaces/INAVIssuanceHook.sol";
import { Invoke } from "../lib/Invoke.sol";
import { ISetToken } from "../../interfaces/ISetToken.sol";
import { IWETH } from "../../interfaces/external/IWETH.sol";
import { ModuleBase } from "../lib/ModuleBase.sol";
import { Position } from "../lib/Position.sol";
import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";
import { ResourceIdentifier } from "../lib/ResourceIdentifier.sol";


/**
 * @title NavIssuanceModule
 * @author Set Protocol
 *
 * Module that enables issuance and redemption with any valid ERC20 token or ETH if allowed by the manager. Sender receives
 * a proportional amount of SetTokens on issuance or ERC20 token on redemption based on the calculated net asset value using
 * oracle prices. Manager is able to enforce a premium / discount on issuance / redemption to avoid arbitrage and front
 * running when relying on oracle prices. Managers can charge a fee (denominated in reserve asset).
 */
contract NavIssuanceModule is ModuleBase, ReentrancyGuard {
    using AddressArrayUtils for address[];
    using Invoke for ISetToken;
    using Position for ISetToken;
    using PreciseUnitMath for uint256;
    using PreciseUnitMath for int256;
    using ResourceIdentifier for IController;
    using SafeMath for uint256;
    using SafeCast for int256;
    using SafeCast for uint256;
    using SignedSafeMath for int256;

    /* ============ Events ============ */

    event SetTokenNAVIssued(
        ISetToken indexed _setToken,
        address _issuer,
        address _to,
        address _reserveAsset,
        address _hookContract,
        uint256 _setTokenQuantity,
        uint256 _managerFee,
        uint256 _premium
    );

    event SetTokenNAVRedeemed(
        ISetToken indexed _setToken,
        address _redeemer,
        address _to,
        address _reserveAsset,
        address _hookContract,
        uint256 _setTokenQuantity,
        uint256 _managerFee,
        uint256 _premium
    );

    event ReserveAssetAdded(
        ISetToken indexed _setToken,
        address _newReserveAsset
    );

    event ReserveAssetRemoved(
        ISetToken indexed _setToken,
        address _removedReserveAsset
    );

    event PremiumEdited(
        ISetToken indexed _setToken,
        uint256 _newPremium
    );

    event ManagerFeeEdited(
        ISetToken indexed _setToken,
        uint256 _newManagerFee,
        uint256 _index
    );

    event FeeRecipientEdited(
        ISetToken indexed _setToken,
        address _feeRecipient
    );

    /* ============ Structs ============ */

    struct NAVIssuanceSettings {
        INAVIssuanceHook managerIssuanceHook;      // Issuance hook configurations
        INAVIssuanceHook managerRedemptionHook;    // Redemption hook configurations
        address[] reserveAssets;                       // Allowed reserve assets - Must have a price enabled with the price oracle
        address feeRecipient;                          // Manager fee recipient
        uint256[2] managerFees;                        // Manager fees. 0 index is issue and 1 index is redeem fee (0.01% = 1e14, 1% = 1e16)
        uint256 maxManagerFee;                         // Maximum fee manager is allowed to set for issue and redeem
        uint256 premiumPercentage;                     // Premium percentage (0.01% = 1e14, 1% = 1e16). This premium is a buffer around oracle
                                                       // prices paid by user to the SetToken, which prevents arbitrage and oracle front running
        uint256 maxPremiumPercentage;                  // Maximum premium percentage manager is allowed to set (configured by manager)
        uint256 minSetTokenSupply;                     // Minimum SetToken supply required for issuance and redemption
                                                       // to prevent dramatic inflationary changes to the SetToken's position multiplier
    }

    struct ActionInfo {
        uint256 preFeeReserveQuantity;                 // Reserve value before fees; During issuance, represents raw quantity
                                                       // During redeem, represents post-premium value
        uint256 protocolFees;                          // Total protocol fees (direct + manager revenue share)
        uint256 managerFee;                            // Total manager fee paid in reserve asset
        uint256 netFlowQuantity;                       // When issuing, quantity of reserve asset sent to SetToken
                                                       // When redeeming, quantity of reserve asset sent to redeemer
        uint256 setTokenQuantity;                      // When issuing, quantity of SetTokens minted to mintee
                                                       // When redeeming, quantity of SetToken redeemed
        uint256 previousSetTokenSupply;                // SetToken supply prior to issue/redeem action
        uint256 newSetTokenSupply;                     // SetToken supply after issue/redeem action
        int256 newPositionMultiplier;                  // SetToken position multiplier after issue/redeem
        uint256 newReservePositionUnit;                // SetToken reserve asset position unit after issue/redeem
    }

    /* ============ State Variables ============ */

    // Wrapped ETH address
    IWETH public immutable weth;

    // Mapping of SetToken to NAV issuance settings struct
    mapping(ISetToken => NAVIssuanceSettings) public navIssuanceSettings;

    // Mapping to efficiently check a SetToken's reserve asset validity
    // SetToken => reserveAsset => isReserveAsset
    mapping(ISetToken => mapping(address => bool)) public isReserveAsset;

    /* ============ Constants ============ */

    // 0 index stores the manager fee in managerFees array, percentage charged on issue (denominated in reserve asset)
    uint256 constant internal MANAGER_ISSUE_FEE_INDEX = 0;

    // 1 index stores the manager fee percentage in managerFees array, charged on redeem
    uint256 constant internal MANAGER_REDEEM_FEE_INDEX = 1;

    // 0 index stores the manager revenue share protocol fee % on the controller, charged in the issuance function
    uint256 constant internal PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX = 0;

    // 1 index stores the manager revenue share protocol fee % on the controller, charged in the redeem function
    uint256 constant internal PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX = 1;

    // 2 index stores the direct protocol fee % on the controller, charged in the issuance function
    uint256 constant internal PROTOCOL_ISSUE_DIRECT_FEE_INDEX = 2;

    // 3 index stores the direct protocol fee % on the controller, charged in the redeem function
    uint256 constant internal PROTOCOL_REDEEM_DIRECT_FEE_INDEX = 3;

    /* ============ Constructor ============ */

    /**
     * @param _controller               Address of controller contract
     * @param _weth                     Address of wrapped eth
     */
    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {
        weth = _weth;
    }

    /* ============ External Functions ============ */

    /**
     * Deposits the allowed reserve asset into the SetToken and mints the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _reserveAsset                 Address of the reserve asset to issue with
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance
     * @param _to                           Address to mint SetToken to
     */
    function issue(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity,
        uint256 _minSetTokenReceiveQuantity,
        address _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, _reserveAsset, _reserveAssetQuantity);

        _callPreIssueHooks(_setToken, _reserveAsset, _reserveAssetQuantity, msg.sender, _to);

        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, _reserveAsset, _reserveAssetQuantity);

        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);

        _transferCollateralAndHandleFees(_setToken, IERC20(_reserveAsset), issueInfo);

        _handleIssueStateUpdates(_setToken, _reserveAsset, _to, issueInfo);
    }

    /**
     * Wraps ETH and deposits WETH if allowed into the SetToken and mints the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance
     * @param _to                           Address to mint SetToken to
     */
    function issueWithEther(
        ISetToken _setToken,
        uint256 _minSetTokenReceiveQuantity,
        address _to
    )
        external
        payable
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        weth.deposit{ value: msg.value }();

        _validateCommon(_setToken, address(weth), msg.value);

        _callPreIssueHooks(_setToken, address(weth), msg.value, msg.sender, _to);

        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, address(weth), msg.value);

        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);

        _transferWETHAndHandleFees(_setToken, issueInfo);

        _handleIssueStateUpdates(_setToken, address(weth), _to, issueInfo);
    }

    /**
     * Redeems a SetToken into a valid reserve asset representing the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address. Only valid if there are available reserve units on the SetToken.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _reserveAsset                 Address of the reserve asset to redeem with
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive
     * @param _to                           Address to redeem reserve asset to
     */
    function redeem(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity,
        uint256 _minReserveReceiveQuantity,
        address _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, _reserveAsset, _setTokenQuantity);

        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);

        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, _reserveAsset, _setTokenQuantity);

        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);

        _setToken.burn(msg.sender, _setTokenQuantity);

        // Instruct the SetToken to transfer the reserve asset back to the user
        _setToken.strictInvokeTransfer(
            _reserveAsset,
            _to,
            redeemInfo.netFlowQuantity
        );

        _handleRedemptionFees(_setToken, _reserveAsset, redeemInfo);

        _handleRedeemStateUpdates(_setToken, _reserveAsset, _to, redeemInfo);
    }

    /**
     * Redeems a SetToken into Ether (if WETH is valid) representing the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address. Only valid if there are available WETH units on the SetToken.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive
     * @param _to                           Address to redeem reserve asset to
     */
    function redeemIntoEther(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        uint256 _minReserveReceiveQuantity,
        address payable _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, address(weth), _setTokenQuantity);

        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);

        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, address(weth), _setTokenQuantity);

        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);

        _setToken.burn(msg.sender, _setTokenQuantity);

        // Instruct the SetToken to transfer WETH from SetToken to module
        _setToken.strictInvokeTransfer(
            address(weth),
            address(this),
            redeemInfo.netFlowQuantity
        );

        weth.withdraw(redeemInfo.netFlowQuantity);

        _to.transfer(redeemInfo.netFlowQuantity);

        _handleRedemptionFees(_setToken, address(weth), redeemInfo);

        _handleRedeemStateUpdates(_setToken, address(weth), _to, redeemInfo);
    }

    /**
     * SET MANAGER ONLY. Add an allowed reserve asset
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset to add
     */
    function addReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {
        require(!isReserveAsset[_setToken][_reserveAsset], "Reserve asset already exists");

        navIssuanceSettings[_setToken].reserveAssets.push(_reserveAsset);
        isReserveAsset[_setToken][_reserveAsset] = true;

        emit ReserveAssetAdded(_setToken, _reserveAsset);
    }

    /**
     * SET MANAGER ONLY. Remove a reserve asset
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset to remove
     */
    function removeReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {
        require(isReserveAsset[_setToken][_reserveAsset], "Reserve asset does not exist");

        navIssuanceSettings[_setToken].reserveAssets = navIssuanceSettings[_setToken].reserveAssets.remove(_reserveAsset);
        delete isReserveAsset[_setToken][_reserveAsset];

        emit ReserveAssetRemoved(_setToken, _reserveAsset);
    }

    /**
     * SET MANAGER ONLY. Edit the premium percentage
     *
     * @param _setToken                     Instance of the SetToken
     * @param _premiumPercentage            Premium percentage in 10e16 (e.g. 10e16 = 1%)
     */
    function editPremium(ISetToken _setToken, uint256 _premiumPercentage) external onlyManagerAndValidSet(_setToken) {
        require(_premiumPercentage <= navIssuanceSettings[_setToken].maxPremiumPercentage, "Premium must be less than maximum allowed");

        navIssuanceSettings[_setToken].premiumPercentage = _premiumPercentage;

        emit PremiumEdited(_setToken, _premiumPercentage);
    }

    /**
     * SET MANAGER ONLY. Edit manager fee
     *
     * @param _setToken                     Instance of the SetToken
     * @param _managerFeePercentage         Manager fee percentage in 10e16 (e.g. 10e16 = 1%)
     * @param _managerFeeIndex              Manager fee index. 0 index is issue fee, 1 index is redeem fee
     */
    function editManagerFee(
        ISetToken _setToken,
        uint256 _managerFeePercentage,
        uint256 _managerFeeIndex
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        require(_managerFeePercentage <= navIssuanceSettings[_setToken].maxManagerFee, "Manager fee must be less than maximum allowed");

        navIssuanceSettings[_setToken].managerFees[_managerFeeIndex] = _managerFeePercentage;

        emit ManagerFeeEdited(_setToken, _managerFeePercentage, _managerFeeIndex);
    }

    /**
     * SET MANAGER ONLY. Edit the manager fee recipient
     *
     * @param _setToken                     Instance of the SetToken
     * @param _managerFeeRecipient          Manager fee recipient
     */
    function editFeeRecipient(ISetToken _setToken, address _managerFeeRecipient) external onlyManagerAndValidSet(_setToken) {
        require(_managerFeeRecipient != address(0), "Fee recipient must not be 0 address");

        navIssuanceSettings[_setToken].feeRecipient = _managerFeeRecipient;

        emit FeeRecipientEdited(_setToken, _managerFeeRecipient);
    }

    /**
     * SET MANAGER ONLY. Initializes this module to the SetToken with hooks, allowed reserve assets,
     * fees and issuance premium. Only callable by the SetToken's manager. Hook addresses are optional.
     * Address(0) means that no hook will be called.
     *
     * @param _setToken                     Instance of the SetToken to issue
     * @param _navIssuanceSettings          NAVIssuanceSettings struct defining parameters
     */
    function initialize(
        ISetToken _setToken,
        NAVIssuanceSettings memory _navIssuanceSettings
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        require(_navIssuanceSettings.reserveAssets.length > 0, "Reserve assets must be greater than 0");
        require(_navIssuanceSettings.maxManagerFee < PreciseUnitMath.preciseUnit(), "Max manager fee must be less than 100%");
        require(_navIssuanceSettings.maxPremiumPercentage < PreciseUnitMath.preciseUnit(), "Max premium percentage must be less than 100%");
        require(_navIssuanceSettings.managerFees[0] <= _navIssuanceSettings.maxManagerFee, "Manager issue fee must be less than max");
        require(_navIssuanceSettings.managerFees[1] <= _navIssuanceSettings.maxManagerFee, "Manager redeem fee must be less than max");
        require(_navIssuanceSettings.premiumPercentage <= _navIssuanceSettings.maxPremiumPercentage, "Premium must be less than max");
        require(_navIssuanceSettings.feeRecipient != address(0), "Fee Recipient must be non-zero address.");
        // Initial mint of Set cannot use NAVIssuance since minSetTokenSupply must be > 0
        require(_navIssuanceSettings.minSetTokenSupply > 0, "Min SetToken supply must be greater than 0");

        for (uint256 i = 0; i < _navIssuanceSettings.reserveAssets.length; i++) {
            require(!isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]], "Reserve assets must be unique");
            isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]] = true;
        }

        navIssuanceSettings[_setToken] = _navIssuanceSettings;

        _setToken.initializeModule();
    }

    /**
     * Removes this module from the SetToken, via call by the SetToken. Issuance settings and
     * reserve asset states are deleted.
     */
    function removeModule() external override {
        ISetToken setToken = ISetToken(msg.sender);
        for (uint256 i = 0; i < navIssuanceSettings[setToken].reserveAssets.length; i++) {
            delete isReserveAsset[setToken][navIssuanceSettings[setToken].reserveAssets[i]];
        }

        delete navIssuanceSettings[setToken];
    }

    receive() external payable {}

    /* ============ External Getter Functions ============ */

    function getReserveAssets(ISetToken _setToken) external view returns (address[] memory) {
        return navIssuanceSettings[_setToken].reserveAssets;
    }

    function getIssuePremium(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (uint256)
    {
        return _getIssuePremium(_setToken, _reserveAsset, _reserveAssetQuantity);
    }

    function getRedeemPremium(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (uint256)
    {
        return _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);
    }

    function getManagerFee(ISetToken _setToken, uint256 _managerFeeIndex) external view returns (uint256) {
        return navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];
    }

    /**
     * Get the expected SetTokens minted to recipient on issuance
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     *
     * @return  uint256                     Expected SetTokens to be minted to recipient
     */
    function getExpectedSetTokenIssueQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (uint256)
    {
        (,, uint256 netReserveFlow) = _getFees(
            _setToken,
            _reserveAssetQuantity,
            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,
            MANAGER_ISSUE_FEE_INDEX
        );

        uint256 setTotalSupply = _setToken.totalSupply();

        return _getSetTokenMintQuantity(
            _setToken,
            _reserveAsset,
            netReserveFlow,
            setTotalSupply
        );
    }

    /**
     * Get the expected reserve asset to be redeemed
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     *
     * @return  uint256                     Expected reserve asset quantity redeemed
     */
    function getExpectedReserveRedeemQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (uint256)
    {
        uint256 preFeeReserveQuantity = _getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

        (,, uint256 netReserveFlows) = _getFees(
            _setToken,
            preFeeReserveQuantity,
            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
            MANAGER_REDEEM_FEE_INDEX
        );

        return netReserveFlows;
    }

    /**
     * Checks if issue is valid
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     *
     * @return  bool                        Returns true if issue is valid
     */
    function isIssueValid(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (bool)
    {
        uint256 setTotalSupply = _setToken.totalSupply();

    return _reserveAssetQuantity != 0
            && isReserveAsset[_setToken][_reserveAsset]
            && setTotalSupply >= navIssuanceSettings[_setToken].minSetTokenSupply;
    }

    /**
     * Checks if redeem is valid
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     *
     * @return  bool                        Returns true if redeem is valid
     */
    function isRedeemValid(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (bool)
    {
        uint256 setTotalSupply = _setToken.totalSupply();

        if (
            _setTokenQuantity == 0
            || !isReserveAsset[_setToken][_reserveAsset]
            || setTotalSupply < navIssuanceSettings[_setToken].minSetTokenSupply.add(_setTokenQuantity)
        ) {
            return false;
        } else {
            uint256 totalRedeemValue =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

            (,, uint256 expectedRedeemQuantity) = _getFees(
                _setToken,
                totalRedeemValue,
                PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
                PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
                MANAGER_REDEEM_FEE_INDEX
            );

            uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();

            return existingUnit.preciseMul(setTotalSupply) >= expectedRedeemQuantity;
        }
    }

    /* ============ Internal Functions ============ */

    function _validateCommon(ISetToken _setToken, address _reserveAsset, uint256 _quantity) internal view {
        require(_quantity > 0, "Quantity must be > 0");
        require(isReserveAsset[_setToken][_reserveAsset], "Must be valid reserve asset");
    }

    function _validateIssuanceInfo(ISetToken _setToken, uint256 _minSetTokenReceiveQuantity, ActionInfo memory _issueInfo) internal view {
        // Check that total supply is greater than min supply needed for issuance
        // Note: A min supply amount is needed to avoid division by 0 when SetToken supply is 0
        require(
            _issueInfo.previousSetTokenSupply >= navIssuanceSettings[_setToken].minSetTokenSupply,
            "Supply must be greater than minimum to enable issuance"
        );

        require(_issueInfo.setTokenQuantity >= _minSetTokenReceiveQuantity, "Must be greater than min SetToken");
    }

    function _validateRedemptionInfo(
        ISetToken _setToken,
        uint256 _minReserveReceiveQuantity,
        ActionInfo memory _redeemInfo
    )
        internal
        view
    {
        // Check that new supply is more than min supply needed for redemption
        // Note: A min supply amount is needed to avoid division by 0 when redeeming SetToken to 0
        require(
            _redeemInfo.newSetTokenSupply >= navIssuanceSettings[_setToken].minSetTokenSupply,
            "Supply must be greater than minimum to enable redemption"
        );

        require(_redeemInfo.netFlowQuantity >= _minReserveReceiveQuantity, "Must be greater than min receive reserve quantity");
    }

    function _createIssuanceInfo(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        internal
        view
        returns (ActionInfo memory)
    {
        ActionInfo memory issueInfo;

        issueInfo.previousSetTokenSupply = _setToken.totalSupply();

        issueInfo.preFeeReserveQuantity = _reserveAssetQuantity;

        (issueInfo.protocolFees, issueInfo.managerFee, issueInfo.netFlowQuantity) = _getFees(
            _setToken,
            issueInfo.preFeeReserveQuantity,
            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,
            MANAGER_ISSUE_FEE_INDEX
        );

        issueInfo.setTokenQuantity = _getSetTokenMintQuantity(
            _setToken,
            _reserveAsset,
            issueInfo.netFlowQuantity,
            issueInfo.previousSetTokenSupply
        );

        (issueInfo.newSetTokenSupply, issueInfo.newPositionMultiplier) = _getIssuePositionMultiplier(_setToken, issueInfo);

        issueInfo.newReservePositionUnit = _getIssuePositionUnit(_setToken, _reserveAsset, issueInfo);

        return issueInfo;
    }

    function _createRedemptionInfo(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        internal
        view
        returns (ActionInfo memory)
    {
        ActionInfo memory redeemInfo;

        redeemInfo.setTokenQuantity = _setTokenQuantity;

        redeemInfo.preFeeReserveQuantity =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

        (redeemInfo.protocolFees, redeemInfo.managerFee, redeemInfo.netFlowQuantity) = _getFees(
            _setToken,
            redeemInfo.preFeeReserveQuantity,
            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
            MANAGER_REDEEM_FEE_INDEX
        );

        redeemInfo.previousSetTokenSupply = _setToken.totalSupply();

        (redeemInfo.newSetTokenSupply, redeemInfo.newPositionMultiplier) = _getRedeemPositionMultiplier(_setToken, _setTokenQuantity, redeemInfo);

        redeemInfo.newReservePositionUnit = _getRedeemPositionUnit(_setToken, _reserveAsset, redeemInfo);

        return redeemInfo;
    }

    /**
     * Transfer reserve asset from user to SetToken and fees from user to appropriate fee recipients
     */
    function _transferCollateralAndHandleFees(ISetToken _setToken, IERC20 _reserveAsset, ActionInfo memory _issueInfo) internal {
        transferFrom(_reserveAsset, msg.sender, address(_setToken), _issueInfo.netFlowQuantity);

        if (_issueInfo.protocolFees > 0) {
            transferFrom(_reserveAsset, msg.sender, controller.feeRecipient(), _issueInfo.protocolFees);
        }

        if (_issueInfo.managerFee > 0) {
            transferFrom(_reserveAsset, msg.sender, navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);
        }
    }


    /**
      * Transfer WETH from module to SetToken and fees from module to appropriate fee recipients
     */
    function _transferWETHAndHandleFees(ISetToken _setToken, ActionInfo memory _issueInfo) internal {
        weth.transfer(address(_setToken), _issueInfo.netFlowQuantity);

        if (_issueInfo.protocolFees > 0) {
            weth.transfer(controller.feeRecipient(), _issueInfo.protocolFees);
        }

        if (_issueInfo.managerFee > 0) {
            weth.transfer(navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);
        }
    }

    function _handleIssueStateUpdates(
        ISetToken _setToken,
        address _reserveAsset,
        address _to,
        ActionInfo memory _issueInfo
    )
        internal
    {
        _setToken.editPositionMultiplier(_issueInfo.newPositionMultiplier);

        _setToken.editDefaultPosition(_reserveAsset, _issueInfo.newReservePositionUnit);

        _setToken.mint(_to, _issueInfo.setTokenQuantity);

        emit SetTokenNAVIssued(
            _setToken,
            msg.sender,
            _to,
            _reserveAsset,
            address(navIssuanceSettings[_setToken].managerIssuanceHook),
            _issueInfo.setTokenQuantity,
            _issueInfo.managerFee,
            _issueInfo.protocolFees
        );
    }

    function _handleRedeemStateUpdates(
        ISetToken _setToken,
        address _reserveAsset,
        address _to,
        ActionInfo memory _redeemInfo
    )
        internal
    {
        _setToken.editPositionMultiplier(_redeemInfo.newPositionMultiplier);

        _setToken.editDefaultPosition(_reserveAsset, _redeemInfo.newReservePositionUnit);

        emit SetTokenNAVRedeemed(
            _setToken,
            msg.sender,
            _to,
            _reserveAsset,
            address(navIssuanceSettings[_setToken].managerRedemptionHook),
            _redeemInfo.setTokenQuantity,
            _redeemInfo.managerFee,
            _redeemInfo.protocolFees
        );
    }

    function _handleRedemptionFees(ISetToken _setToken, address _reserveAsset, ActionInfo memory _redeemInfo) internal {
        // Instruct the SetToken to transfer protocol fee to fee recipient if there is a fee
        payProtocolFeeFromSetToken(_setToken, _reserveAsset, _redeemInfo.protocolFees);

        // Instruct the SetToken to transfer manager fee to manager fee recipient if there is a fee
        if (_redeemInfo.managerFee > 0) {
            _setToken.strictInvokeTransfer(
                _reserveAsset,
                navIssuanceSettings[_setToken].feeRecipient,
                _redeemInfo.managerFee
            );
        }
    }

    /**
     * Returns the issue premium percentage. Virtual function that can be overridden in future versions of the module
     * and can contain arbitrary logic to calculate the issuance premium.
     */
    function _getIssuePremium(
        ISetToken _setToken,
        address /* _reserveAsset */,
        uint256 /* _reserveAssetQuantity */
    )
        virtual
        internal
        view
        returns (uint256)
    {
        return navIssuanceSettings[_setToken].premiumPercentage;
    }

    /**
     * Returns the redeem premium percentage. Virtual function that can be overridden in future versions of the module
     * and can contain arbitrary logic to calculate the redemption premium.
     */
    function _getRedeemPremium(
        ISetToken _setToken,
        address /* _reserveAsset */,
        uint256 /* _setTokenQuantity */
    )
        virtual
        internal
        view
        returns (uint256)
    {
        return navIssuanceSettings[_setToken].premiumPercentage;
    }

    /**
     * Returns the fees attributed to the manager and the protocol. The fees are calculated as follows:
     *
     * ManagerFee = (manager fee % - % to protocol) * reserveAssetQuantity
     * Protocol Fee = (% manager fee share + direct fee %) * reserveAssetQuantity
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAssetQuantity         Quantity of reserve asset to calculate fees from
     * @param _protocolManagerFeeIndex      Index to pull rev share NAV Issuance fee from the Controller
     * @param _protocolDirectFeeIndex       Index to pull direct NAV issuance fee from the Controller
     * @param _managerFeeIndex              Index from NAVIssuanceSettings (0 = issue fee, 1 = redeem fee)
     *
     * @return  uint256                     Fees paid to the protocol in reserve asset
     * @return  uint256                     Fees paid to the manager in reserve asset
     * @return  uint256                     Net reserve to user net of fees
     */
    function _getFees(
        ISetToken _setToken,
        uint256 _reserveAssetQuantity,
        uint256 _protocolManagerFeeIndex,
        uint256 _protocolDirectFeeIndex,
        uint256 _managerFeeIndex
    )
        internal
        view
        returns (uint256, uint256, uint256)
    {
        (uint256 protocolFeePercentage, uint256 managerFeePercentage) = _getProtocolAndManagerFeePercentages(
            _setToken,
            _protocolManagerFeeIndex,
            _protocolDirectFeeIndex,
            _managerFeeIndex
        );

        // Calculate total notional fees
        uint256 protocolFees = protocolFeePercentage.preciseMul(_reserveAssetQuantity);
        uint256 managerFee = managerFeePercentage.preciseMul(_reserveAssetQuantity);

        uint256 netReserveFlow = _reserveAssetQuantity.sub(protocolFees).sub(managerFee);

        return (protocolFees, managerFee, netReserveFlow);
    }

    function _getProtocolAndManagerFeePercentages(
        ISetToken _setToken,
        uint256 _protocolManagerFeeIndex,
        uint256 _protocolDirectFeeIndex,
        uint256 _managerFeeIndex
    )
        internal
        view
        returns(uint256, uint256)
    {
        // Get protocol fee percentages
        uint256 protocolDirectFeePercent = controller.getModuleFee(address(this), _protocolDirectFeeIndex);
        uint256 protocolManagerShareFeePercent = controller.getModuleFee(address(this), _protocolManagerFeeIndex);
        uint256 managerFeePercent = navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];

        // Calculate revenue share split percentage
        uint256 protocolRevenueSharePercentage = protocolManagerShareFeePercent.preciseMul(managerFeePercent);
        uint256 managerRevenueSharePercentage = managerFeePercent.sub(protocolRevenueSharePercentage);
        uint256 totalProtocolFeePercentage = protocolRevenueSharePercentage.add(protocolDirectFeePercent);

        return (totalProtocolFeePercentage, managerRevenueSharePercentage);
    }

    function _getSetTokenMintQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _netReserveFlows,            // Value of reserve asset net of fees
        uint256 _setTotalSupply
    )
        internal
        view
        returns (uint256)
    {
        uint256 premiumPercentage = _getIssuePremium(_setToken, _reserveAsset, _netReserveFlows);
        uint256 premiumValue = _netReserveFlows.preciseMul(premiumPercentage);

        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (1e18)
        // Reverts if price is not found
        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);

        // Get reserve asset decimals
        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();
        uint256 normalizedTotalReserveQuantityNetFees = _netReserveFlows.preciseDiv(10 ** reserveAssetDecimals);
        uint256 normalizedTotalReserveQuantityNetFeesAndPremium = _netReserveFlows.sub(premiumValue).preciseDiv(10 ** reserveAssetDecimals);

        // Calculate SetTokens to mint to issuer
        uint256 denominator = _setTotalSupply.preciseMul(setTokenValuation).add(normalizedTotalReserveQuantityNetFees).sub(normalizedTotalReserveQuantityNetFeesAndPremium);
        return normalizedTotalReserveQuantityNetFeesAndPremium.preciseMul(_setTotalSupply).preciseDiv(denominator);
    }

    function _getRedeemReserveQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        internal
        view
        returns (uint256)
    {
        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (10e18)
        // Reverts if price is not found
        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);

        uint256 totalRedeemValueInPreciseUnits = _setTokenQuantity.preciseMul(setTokenValuation);
        // Get reserve asset decimals
        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();
        uint256 prePremiumReserveQuantity = totalRedeemValueInPreciseUnits.preciseMul(10 ** reserveAssetDecimals);

        uint256 premiumPercentage = _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);
        uint256 premiumQuantity = prePremiumReserveQuantity.preciseMulCeil(premiumPercentage);

        return prePremiumReserveQuantity.sub(premiumQuantity);
    }

    /**
     * The new position multiplier is calculated as follows:
     * inflationPercentage = (newSupply - oldSupply) / newSupply
     * newMultiplier = (1 - inflationPercentage) * positionMultiplier
     */
    function _getIssuePositionMultiplier(
        ISetToken _setToken,
        ActionInfo memory _issueInfo
    )
        internal
        view
        returns (uint256, int256)
    {
        // Calculate inflation and new position multiplier. Note: Round inflation up in order to round position multiplier down
        uint256 newTotalSupply = _issueInfo.setTokenQuantity.add(_issueInfo.previousSetTokenSupply);
        int256 newPositionMultiplier = _setToken.positionMultiplier()
            .mul(_issueInfo.previousSetTokenSupply.toInt256())
            .div(newTotalSupply.toInt256());

        return (newTotalSupply, newPositionMultiplier);
    }

    /**
     * Calculate deflation and new position multiplier. Note: Round deflation down in order to round position multiplier down
     *
     * The new position multiplier is calculated as follows:
     * deflationPercentage = (oldSupply - newSupply) / newSupply
     * newMultiplier = (1 + deflationPercentage) * positionMultiplier
     */
    function _getRedeemPositionMultiplier(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        ActionInfo memory _redeemInfo
    )
        internal
        view
        returns (uint256, int256)
    {
        uint256 newTotalSupply = _redeemInfo.previousSetTokenSupply.sub(_setTokenQuantity);
        int256 newPositionMultiplier = _setToken.positionMultiplier()
            .mul(_redeemInfo.previousSetTokenSupply.toInt256())
            .div(newTotalSupply.toInt256());

        return (newTotalSupply, newPositionMultiplier);
    }

    /**
     * The new position reserve asset unit is calculated as follows:
     * totalReserve = (oldUnit * oldSetTokenSupply) + reserveQuantity
     * newUnit = totalReserve / newSetTokenSupply
     */
    function _getIssuePositionUnit(
        ISetToken _setToken,
        address _reserveAsset,
        ActionInfo memory _issueInfo
    )
        internal
        view
        returns (uint256)
    {
        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();
        uint256 totalReserve = existingUnit
            .preciseMul(_issueInfo.previousSetTokenSupply)
            .add(_issueInfo.netFlowQuantity);

        return totalReserve.preciseDiv(_issueInfo.newSetTokenSupply);
    }

    /**
     * The new position reserve asset unit is calculated as follows:
     * totalReserve = (oldUnit * oldSetTokenSupply) - reserveQuantityToSendOut
     * newUnit = totalReserve / newSetTokenSupply
     */
    function _getRedeemPositionUnit(
        ISetToken _setToken,
        address _reserveAsset,
        ActionInfo memory _redeemInfo
    )
        internal
        view
        returns (uint256)
    {
        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();
        uint256 totalExistingUnits = existingUnit.preciseMul(_redeemInfo.previousSetTokenSupply);

        uint256 outflow = _redeemInfo.netFlowQuantity.add(_redeemInfo.protocolFees).add(_redeemInfo.managerFee);

        // Require withdrawable quantity is greater than existing collateral
        require(totalExistingUnits >= outflow, "Must be greater than total available collateral");

        return totalExistingUnits.sub(outflow).preciseDiv(_redeemInfo.newSetTokenSupply);
    }

    /**
     * If a pre-issue hook has been configured, call the external-protocol contract. Pre-issue hook logic
     * can contain arbitrary logic including validations, external function calls, etc.
     */
    function _callPreIssueHooks(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity,
        address _caller,
        address _to
    )
        internal
    {
        INAVIssuanceHook preIssueHook = navIssuanceSettings[_setToken].managerIssuanceHook;
        if (address(preIssueHook) != address(0)) {
            preIssueHook.invokePreIssueHook(_setToken, _reserveAsset, _reserveAssetQuantity, _caller, _to);
        }
    }

    /**
     * If a pre-redeem hook has been configured, call the external-protocol contract.
     */
    function _callPreRedeemHooks(ISetToken _setToken, uint256 _setQuantity, address _caller, address _to) internal {
        INAVIssuanceHook preRedeemHook = navIssuanceSettings[_setToken].managerRedemptionHook;
        if (address(preRedeemHook) != address(0)) {
            preRedeemHook.invokePreRedeemHook(_setToken, _setQuantity, _caller, _to);
        }
    }
}".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-01-09 05:31:21 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 05:31:21 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 19903
completion_tokens: 1
total_tokens: 19904
cost: $-1.000000


[2024-01-09 05:31:21 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: /*
    Copyright 2020 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";
import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";
import { SignedSafeMath } from "@openzeppelin/contracts/math/SignedSafeMath.sol";

import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";
import { IController } from "../../interfaces/IController.sol";
import { INAVIssuanceHook } from "../../interfaces/INAVIssuanceHook.sol";
import { Invoke } from "../lib/Invoke.sol";
import { ISetToken } from "../../interfaces/ISetToken.sol";
import { IWETH } from "../../interfaces/external/IWETH.sol";
import { ModuleBase } from "../lib/ModuleBase.sol";
import { Position } from "../lib/Position.sol";
import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";
import { ResourceIdentifier } from "../lib/ResourceIdentifier.sol";


/**
 * @title NavIssuanceModule
 * @author Set Protocol
 *
 * Module that enables issuance and redemption with any valid ERC20 token or ETH if allowed by the manager. Sender receives
 * a proportional amount of SetTokens on issuance or ERC20 token on redemption based on the calculated net asset value using
 * oracle prices. Manager is able to enforce a premium / discount on issuance / redemption to avoid arbitrage and front
 * running when relying on oracle prices. Managers can charge a fee (denominated in reserve asset).
 */
contract NavIssuanceModule is ModuleBase, ReentrancyGuard {
    using AddressArrayUtils for address[];
    using Invoke for ISetToken;
    using Position for ISetToken;
    using PreciseUnitMath for uint256;
    using PreciseUnitMath for int256;
    using ResourceIdentifier for IController;
    using SafeMath for uint256;
    using SafeCast for int256;
    using SafeCast for uint256;
    using SignedSafeMath for int256;

    /* ============ Events ============ */

    event SetTokenNAVIssued(
        ISetToken indexed _setToken,
        address _issuer,
        address _to,
        address _reserveAsset,
        address _hookContract,
        uint256 _setTokenQuantity,
        uint256 _managerFee,
        uint256 _premium
    );

    event SetTokenNAVRedeemed(
        ISetToken indexed _setToken,
        address _redeemer,
        address _to,
        address _reserveAsset,
        address _hookContract,
        uint256 _setTokenQuantity,
        uint256 _managerFee,
        uint256 _premium
    );

    event ReserveAssetAdded(
        ISetToken indexed _setToken,
        address _newReserveAsset
    );

    event ReserveAssetRemoved(
        ISetToken indexed _setToken,
        address _removedReserveAsset
    );

    event PremiumEdited(
        ISetToken indexed _setToken,
        uint256 _newPremium
    );

    event ManagerFeeEdited(
        ISetToken indexed _setToken,
        uint256 _newManagerFee,
        uint256 _index
    );

    event FeeRecipientEdited(
        ISetToken indexed _setToken,
        address _feeRecipient
    );

    /* ============ Structs ============ */

    struct NAVIssuanceSettings {
        INAVIssuanceHook managerIssuanceHook;      // Issuance hook configurations
        INAVIssuanceHook managerRedemptionHook;    // Redemption hook configurations
        address[] reserveAssets;                       // Allowed reserve assets - Must have a price enabled with the price oracle
        address feeRecipient;                          // Manager fee recipient
        uint256[2] managerFees;                        // Manager fees. 0 index is issue and 1 index is redeem fee (0.01% = 1e14, 1% = 1e16)
        uint256 maxManagerFee;                         // Maximum fee manager is allowed to set for issue and redeem
        uint256 premiumPercentage;                     // Premium percentage (0.01% = 1e14, 1% = 1e16). This premium is a buffer around oracle
                                                       // prices paid by user to the SetToken, which prevents arbitrage and oracle front running
        uint256 maxPremiumPercentage;                  // Maximum premium percentage manager is allowed to set (configured by manager)
        uint256 minSetTokenSupply;                     // Minimum SetToken supply required for issuance and redemption
                                                       // to prevent dramatic inflationary changes to the SetToken's position multiplier
    }

    struct ActionInfo {
        uint256 preFeeReserveQuantity;                 // Reserve value before fees; During issuance, represents raw quantity
                                                       // During redeem, represents post-premium value
        uint256 protocolFees;                          // Total protocol fees (direct + manager revenue share)
        uint256 managerFee;                            // Total manager fee paid in reserve asset
        uint256 netFlowQuantity;                       // When issuing, quantity of reserve asset sent to SetToken
                                                       // When redeeming, quantity of reserve asset sent to redeemer
        uint256 setTokenQuantity;                      // When issuing, quantity of SetTokens minted to mintee
                                                       // When redeeming, quantity of SetToken redeemed
        uint256 previousSetTokenSupply;                // SetToken supply prior to issue/redeem action
        uint256 newSetTokenSupply;                     // SetToken supply after issue/redeem action
        int256 newPositionMultiplier;                  // SetToken position multiplier after issue/redeem
        uint256 newReservePositionUnit;                // SetToken reserve asset position unit after issue/redeem
    }

    /* ============ State Variables ============ */

    // Wrapped ETH address
    IWETH public immutable weth;

    // Mapping of SetToken to NAV issuance settings struct
    mapping(ISetToken => NAVIssuanceSettings) public navIssuanceSettings;

    // Mapping to efficiently check a SetToken's reserve asset validity
    // SetToken => reserveAsset => isReserveAsset
    mapping(ISetToken => mapping(address => bool)) public isReserveAsset;

    /* ============ Constants ============ */

    // 0 index stores the manager fee in managerFees array, percentage charged on issue (denominated in reserve asset)
    uint256 constant internal MANAGER_ISSUE_FEE_INDEX = 0;

    // 1 index stores the manager fee percentage in managerFees array, charged on redeem
    uint256 constant internal MANAGER_REDEEM_FEE_INDEX = 1;

    // 0 index stores the manager revenue share protocol fee % on the controller, charged in the issuance function
    uint256 constant internal PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX = 0;

    // 1 index stores the manager revenue share protocol fee % on the controller, charged in the redeem function
    uint256 constant internal PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX = 1;

    // 2 index stores the direct protocol fee % on the controller, charged in the issuance function
    uint256 constant internal PROTOCOL_ISSUE_DIRECT_FEE_INDEX = 2;

    // 3 index stores the direct protocol fee % on the controller, charged in the redeem function
    uint256 constant internal PROTOCOL_REDEEM_DIRECT_FEE_INDEX = 3;

    /* ============ Constructor ============ */

    /**
     * @param _controller               Address of controller contract
     * @param _weth                     Address of wrapped eth
     */
    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {
        weth = _weth;
    }

    /* ============ External Functions ============ */

    /**
     * Deposits the allowed reserve asset into the SetToken and mints the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _reserveAsset                 Address of the reserve asset to issue with
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance
     * @param _to                           Address to mint SetToken to
     */
    function issue(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity,
        uint256 _minSetTokenReceiveQuantity,
        address _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, _reserveAsset, _reserveAssetQuantity);

        _callPreIssueHooks(_setToken, _reserveAsset, _reserveAssetQuantity, msg.sender, _to);

        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, _reserveAsset, _reserveAssetQuantity);

        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);

        _transferCollateralAndHandleFees(_setToken, IERC20(_reserveAsset), issueInfo);

        _handleIssueStateUpdates(_setToken, _reserveAsset, _to, issueInfo);
    }

    /**
     * Wraps ETH and deposits WETH if allowed into the SetToken and mints the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance
     * @param _to                           Address to mint SetToken to
     */
    function issueWithEther(
        ISetToken _setToken,
        uint256 _minSetTokenReceiveQuantity,
        address _to
    )
        external
        payable
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        weth.deposit{ value: msg.value }();

        _validateCommon(_setToken, address(weth), msg.value);

        _callPreIssueHooks(_setToken, address(weth), msg.value, msg.sender, _to);

        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, address(weth), msg.value);

        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);

        _transferWETHAndHandleFees(_setToken, issueInfo);

        _handleIssueStateUpdates(_setToken, address(weth), _to, issueInfo);
    }

    /**
     * Redeems a SetToken into a valid reserve asset representing the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address. Only valid if there are available reserve units on the SetToken.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _reserveAsset                 Address of the reserve asset to redeem with
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive
     * @param _to                           Address to redeem reserve asset to
     */
    function redeem(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity,
        uint256 _minReserveReceiveQuantity,
        address _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, _reserveAsset, _setTokenQuantity);

        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);

        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, _reserveAsset, _setTokenQuantity);

        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);

        _setToken.burn(msg.sender, _setTokenQuantity);

        // Instruct the SetToken to transfer the reserve asset back to the user
        _setToken.strictInvokeTransfer(
            _reserveAsset,
            _to,
            redeemInfo.netFlowQuantity
        );

        _handleRedemptionFees(_setToken, _reserveAsset, redeemInfo);

        _handleRedeemStateUpdates(_setToken, _reserveAsset, _to, redeemInfo);
    }

    /**
     * Redeems a SetToken into Ether (if WETH is valid) representing the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address. Only valid if there are available WETH units on the SetToken.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive
     * @param _to                           Address to redeem reserve asset to
     */
    function redeemIntoEther(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        uint256 _minReserveReceiveQuantity,
        address payable _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, address(weth), _setTokenQuantity);

        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);

        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, address(weth), _setTokenQuantity);

        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);

        _setToken.burn(msg.sender, _setTokenQuantity);

        // Instruct the SetToken to transfer WETH from SetToken to module
        _setToken.strictInvokeTransfer(
            address(weth),
            address(this),
            redeemInfo.netFlowQuantity
        );

        weth.withdraw(redeemInfo.netFlowQuantity);

        _to.transfer(redeemInfo.netFlowQuantity);

        _handleRedemptionFees(_setToken, address(weth), redeemInfo);

        _handleRedeemStateUpdates(_setToken, address(weth), _to, redeemInfo);
    }

    /**
     * SET MANAGER ONLY. Add an allowed reserve asset
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset to add
     */
    function addReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {
        require(!isReserveAsset[_setToken][_reserveAsset], "Reserve asset already exists");

        navIssuanceSettings[_setToken].reserveAssets.push(_reserveAsset);
        isReserveAsset[_setToken][_reserveAsset] = true;

        emit ReserveAssetAdded(_setToken, _reserveAsset);
    }

    /**
     * SET MANAGER ONLY. Remove a reserve asset
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset to remove
     */
    function removeReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {
        require(isReserveAsset[_setToken][_reserveAsset], "Reserve asset does not exist");

        navIssuanceSettings[_setToken].reserveAssets = navIssuanceSettings[_setToken].reserveAssets.remove(_reserveAsset);
        delete isReserveAsset[_setToken][_reserveAsset];

        emit ReserveAssetRemoved(_setToken, _reserveAsset);
    }

    /**
     * SET MANAGER ONLY. Edit the premium percentage
     *
     * @param _setToken                     Instance of the SetToken
     * @param _premiumPercentage            Premium percentage in 10e16 (e.g. 10e16 = 1%)
     */
    function editPremium(ISetToken _setToken, uint256 _premiumPercentage) external onlyManagerAndValidSet(_setToken) {
        require(_premiumPercentage <= navIssuanceSettings[_setToken].maxPremiumPercentage, "Premium must be less than maximum allowed");

        navIssuanceSettings[_setToken].premiumPercentage = _premiumPercentage;

        emit PremiumEdited(_setToken, _premiumPercentage);
    }

    /**
     * SET MANAGER ONLY. Edit manager fee
     *
     * @param _setToken                     Instance of the SetToken
     * @param _managerFeePercentage         Manager fee percentage in 10e16 (e.g. 10e16 = 1%)
     * @param _managerFeeIndex              Manager fee index. 0 index is issue fee, 1 index is redeem fee
     */
    function editManagerFee(
        ISetToken _setToken,
        uint256 _managerFeePercentage,
        uint256 _managerFeeIndex
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        require(_managerFeePercentage <= navIssuanceSettings[_setToken].maxManagerFee, "Manager fee must be less than maximum allowed");

        navIssuanceSettings[_setToken].managerFees[_managerFeeIndex] = _managerFeePercentage;

        emit ManagerFeeEdited(_setToken, _managerFeePercentage, _managerFeeIndex);
    }

    /**
     * SET MANAGER ONLY. Edit the manager fee recipient
     *
     * @param _setToken                     Instance of the SetToken
     * @param _managerFeeRecipient          Manager fee recipient
     */
    function editFeeRecipient(ISetToken _setToken, address _managerFeeRecipient) external onlyManagerAndValidSet(_setToken) {
        require(_managerFeeRecipient != address(0), "Fee recipient must not be 0 address");

        navIssuanceSettings[_setToken].feeRecipient = _managerFeeRecipient;

        emit FeeRecipientEdited(_setToken, _managerFeeRecipient);
    }

    /**
     * SET MANAGER ONLY. Initializes this module to the SetToken with hooks, allowed reserve assets,
     * fees and issuance premium. Only callable by the SetToken's manager. Hook addresses are optional.
     * Address(0) means that no hook will be called.
     *
     * @param _setToken                     Instance of the SetToken to issue
     * @param _navIssuanceSettings          NAVIssuanceSettings struct defining parameters
     */
    function initialize(
        ISetToken _setToken,
        NAVIssuanceSettings memory _navIssuanceSettings
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        require(_navIssuanceSettings.reserveAssets.length > 0, "Reserve assets must be greater than 0");
        require(_navIssuanceSettings.maxManagerFee < PreciseUnitMath.preciseUnit(), "Max manager fee must be less than 100%");
        require(_navIssuanceSettings.maxPremiumPercentage < PreciseUnitMath.preciseUnit(), "Max premium percentage must be less than 100%");
        require(_navIssuanceSettings.managerFees[0] <= _navIssuanceSettings.maxManagerFee, "Manager issue fee must be less than max");
        require(_navIssuanceSettings.managerFees[1] <= _navIssuanceSettings.maxManagerFee, "Manager redeem fee must be less than max");
        require(_navIssuanceSettings.premiumPercentage <= _navIssuanceSettings.maxPremiumPercentage, "Premium must be less than max");
        require(_navIssuanceSettings.feeRecipient != address(0), "Fee Recipient must be non-zero address.");
        // Initial mint of Set cannot use NAVIssuance since minSetTokenSupply must be > 0
        require(_navIssuanceSettings.minSetTokenSupply > 0, "Min SetToken supply must be greater than 0");

        for (uint256 i = 0; i < _navIssuanceSettings.reserveAssets.length; i++) {
            require(!isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]], "Reserve assets must be unique");
            isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]] = true;
        }

        navIssuanceSettings[_setToken] = _navIssuanceSettings;

        _setToken.initializeModule();
    }

    /**
     * Removes this module from the SetToken, via call by the SetToken. Issuance settings and
     * reserve asset states are deleted.
     */
    function removeModule() external override {
        ISetToken setToken = ISetToken(msg.sender);
        for (uint256 i = 0; i < navIssuanceSettings[setToken].reserveAssets.length; i++) {
            delete isReserveAsset[setToken][navIssuanceSettings[setToken].reserveAssets[i]];
        }

        delete navIssuanceSettings[setToken];
    }

    receive() external payable {}

    /* ============ External Getter Functions ============ */

    function getReserveAssets(ISetToken _setToken) external view returns (address[] memory) {
        return navIssuanceSettings[_setToken].reserveAssets;
    }

    function getIssuePremium(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (uint256)
    {
        return _getIssuePremium(_setToken, _reserveAsset, _reserveAssetQuantity);
    }

    function getRedeemPremium(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (uint256)
    {
        return _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);
    }

    function getManagerFee(ISetToken _setToken, uint256 _managerFeeIndex) external view returns (uint256) {
        return navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];
    }

    /**
     * Get the expected SetTokens minted to recipient on issuance
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     *
     * @return  uint256                     Expected SetTokens to be minted to recipient
     */
    function getExpectedSetTokenIssueQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (uint256)
    {
        (,, uint256 netReserveFlow) = _getFees(
            _setToken,
            _reserveAssetQuantity,
            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,
            MANAGER_ISSUE_FEE_INDEX
        );

        uint256 setTotalSupply = _setToken.totalSupply();

        return _getSetTokenMintQuantity(
            _setToken,
            _reserveAsset,
            netReserveFlow,
            setTotalSupply
        );
    }

    /**
     * Get the expected reserve asset to be redeemed
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     *
     * @return  uint256                     Expected reserve asset quantity redeemed
     */
    function getExpectedReserveRedeemQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (uint256)
    {
        uint256 preFeeReserveQuantity = _getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

        (,, uint256 netReserveFlows) = _getFees(
            _setToken,
            preFeeReserveQuantity,
            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
            MANAGER_REDEEM_FEE_INDEX
        );

        return netReserveFlows;
    }

    /**
     * Checks if issue is valid
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     *
     * @return  bool                        Returns true if issue is valid
     */
    function isIssueValid(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (bool)
    {
        uint256 setTotalSupply = _setToken.totalSupply();

    return _reserveAssetQuantity != 0
            && isReserveAsset[_setToken][_reserveAsset]
            && setTotalSupply >= navIssuanceSettings[_setToken].minSetTokenSupply;
    }

    /**
     * Checks if redeem is valid
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     *
     * @return  bool                        Returns true if redeem is valid
     */
    function isRedeemValid(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (bool)
    {
        uint256 setTotalSupply = _setToken.totalSupply();

        if (
            _setTokenQuantity == 0
            || !isReserveAsset[_setToken][_reserveAsset]
            || setTotalSupply < navIssuanceSettings[_setToken].minSetTokenSupply.add(_setTokenQuantity)
        ) {
            return false;
        } else {
            uint256 totalRedeemValue =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

            (,, uint256 expectedRedeemQuantity) = _getFees(
                _setToken,
                totalRedeemValue,
                PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
                PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
                MANAGER_REDEEM_FEE_INDEX
            );

            uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();

            return existingUnit.preciseMul(setTotalSupply) >= expectedRedeemQuantity;
        }
    }

    /* ============ Internal Functions ============ */

    function _validateCommon(ISetToken _setToken, address _reserveAsset, uint256 _quantity) internal view {
        require(_quantity > 0, "Quantity must be > 0");
        require(isReserveAsset[_setToken][_reserveAsset], "Must be valid reserve asset");
    }

    function _validateIssuanceInfo(ISetToken _setToken, uint256 _minSetTokenReceiveQuantity, ActionInfo memory _issueInfo) internal view {
        // Check that total supply is greater than min supply needed for issuance
        // Note: A min supply amount is needed to avoid division by 0 when SetToken supply is 0
        require(
            _issueInfo.previousSetTokenSupply >= navIssuanceSettings[_setToken].minSetTokenSupply,
            "Supply must be greater than minimum to enable issuance"
        );

        require(_issueInfo.setTokenQuantity >= _minSetTokenReceiveQuantity, "Must be greater than min SetToken");
    }

    function _validateRedemptionInfo(
        ISetToken _setToken,
        uint256 _minReserveReceiveQuantity,
        ActionInfo memory _redeemInfo
    )
        internal
        view
    {
        // Check that new supply is more than min supply needed for redemption
        // Note: A min supply amount is needed to avoid division by 0 when redeeming SetToken to 0
        require(
            _redeemInfo.newSetTokenSupply >= navIssuanceSettings[_setToken].minSetTokenSupply,
            "Supply must be greater than minimum to enable redemption"
        );

        require(_redeemInfo.netFlowQuantity >= _minReserveReceiveQuantity, "Must be greater than min receive reserve quantity");
    }

    function _createIssuanceInfo(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        internal
        view
        returns (ActionInfo memory)
    {
        ActionInfo memory issueInfo;

        issueInfo.previousSetTokenSupply = _setToken.totalSupply();

        issueInfo.preFeeReserveQuantity = _reserveAssetQuantity;

        (issueInfo.protocolFees, issueInfo.managerFee, issueInfo.netFlowQuantity) = _getFees(
            _setToken,
            issueInfo.preFeeReserveQuantity,
            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,
            MANAGER_ISSUE_FEE_INDEX
        );

        issueInfo.setTokenQuantity = _getSetTokenMintQuantity(
            _setToken,
            _reserveAsset,
            issueInfo.netFlowQuantity,
            issueInfo.previousSetTokenSupply
        );

        (issueInfo.newSetTokenSupply, issueInfo.newPositionMultiplier) = _getIssuePositionMultiplier(_setToken, issueInfo);

        issueInfo.newReservePositionUnit = _getIssuePositionUnit(_setToken, _reserveAsset, issueInfo);

        return issueInfo;
    }

    function _createRedemptionInfo(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        internal
        view
        returns (ActionInfo memory)
    {
        ActionInfo memory redeemInfo;

        redeemInfo.setTokenQuantity = _setTokenQuantity;

        redeemInfo.preFeeReserveQuantity =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

        (redeemInfo.protocolFees, redeemInfo.managerFee, redeemInfo.netFlowQuantity) = _getFees(
            _setToken,
            redeemInfo.preFeeReserveQuantity,
            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
            MANAGER_REDEEM_FEE_INDEX
        );

        redeemInfo.previousSetTokenSupply = _setToken.totalSupply();

        (redeemInfo.newSetTokenSupply, redeemInfo.newPositionMultiplier) = _getRedeemPositionMultiplier(_setToken, _setTokenQuantity, redeemInfo);

        redeemInfo.newReservePositionUnit = _getRedeemPositionUnit(_setToken, _reserveAsset, redeemInfo);

        return redeemInfo;
    }

    /**
     * Transfer reserve asset from user to SetToken and fees from user to appropriate fee recipients
     */
    function _transferCollateralAndHandleFees(ISetToken _setToken, IERC20 _reserveAsset, ActionInfo memory _issueInfo) internal {
        transferFrom(_reserveAsset, msg.sender, address(_setToken), _issueInfo.netFlowQuantity);

        if (_issueInfo.protocolFees > 0) {
            transferFrom(_reserveAsset, msg.sender, controller.feeRecipient(), _issueInfo.protocolFees);
        }

        if (_issueInfo.managerFee > 0) {
            transferFrom(_reserveAsset, msg.sender, navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);
        }
    }


    /**
      * Transfer WETH from module to SetToken and fees from module to appropriate fee recipients
     */
    function _transferWETHAndHandleFees(ISetToken _setToken, ActionInfo memory _issueInfo) internal {
        weth.transfer(address(_setToken), _issueInfo.netFlowQuantity);

        if (_issueInfo.protocolFees > 0) {
            weth.transfer(controller.feeRecipient(), _issueInfo.protocolFees);
        }

        if (_issueInfo.managerFee > 0) {
            weth.transfer(navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);
        }
    }

    function _handleIssueStateUpdates(
        ISetToken _setToken,
        address _reserveAsset,
        address _to,
        ActionInfo memory _issueInfo
    )
        internal
    {
        _setToken.editPositionMultiplier(_issueInfo.newPositionMultiplier);

        _setToken.editDefaultPosition(_reserveAsset, _issueInfo.newReservePositionUnit);

        _setToken.mint(_to, _issueInfo.setTokenQuantity);

        emit SetTokenNAVIssued(
            _setToken,
            msg.sender,
            _to,
            _reserveAsset,
            address(navIssuanceSettings[_setToken].managerIssuanceHook),
            _issueInfo.setTokenQuantity,
            _issueInfo.managerFee,
            _issueInfo.protocolFees
        );
    }

    function _handleRedeemStateUpdates(
        ISetToken _setToken,
        address _reserveAsset,
        address _to,
        ActionInfo memory _redeemInfo
    )
        internal
    {
        _setToken.editPositionMultiplier(_redeemInfo.newPositionMultiplier);

        _setToken.editDefaultPosition(_reserveAsset, _redeemInfo.newReservePositionUnit);

        emit SetTokenNAVRedeemed(
            _setToken,
            msg.sender,
            _to,
            _reserveAsset,
            address(navIssuanceSettings[_setToken].managerRedemptionHook),
            _redeemInfo.setTokenQuantity,
            _redeemInfo.managerFee,
            _redeemInfo.protocolFees
        );
    }

    function _handleRedemptionFees(ISetToken _setToken, address _reserveAsset, ActionInfo memory _redeemInfo) internal {
        // Instruct the SetToken to transfer protocol fee to fee recipient if there is a fee
        payProtocolFeeFromSetToken(_setToken, _reserveAsset, _redeemInfo.protocolFees);

        // Instruct the SetToken to transfer manager fee to manager fee recipient if there is a fee
        if (_redeemInfo.managerFee > 0) {
            _setToken.strictInvokeTransfer(
                _reserveAsset,
                navIssuanceSettings[_setToken].feeRecipient,
                _redeemInfo.managerFee
            );
        }
    }

    /**
     * Returns the issue premium percentage. Virtual function that can be overridden in future versions of the module
     * and can contain arbitrary logic to calculate the issuance premium.
     */
    function _getIssuePremium(
        ISetToken _setToken,
        address /* _reserveAsset */,
        uint256 /* _reserveAssetQuantity */
    )
        virtual
        internal
        view
        returns (uint256)
    {
        return navIssuanceSettings[_setToken].premiumPercentage;
    }

    /**
     * Returns the redeem premium percentage. Virtual function that can be overridden in future versions of the module
     * and can contain arbitrary logic to calculate the redemption premium.
     */
    function _getRedeemPremium(
        ISetToken _setToken,
        address /* _reserveAsset */,
        uint256 /* _setTokenQuantity */
    )
        virtual
        internal
        view
        returns (uint256)
    {
        return navIssuanceSettings[_setToken].premiumPercentage;
    }

    /**
     * Returns the fees attributed to the manager and the protocol. The fees are calculated as follows:
     *
     * ManagerFee = (manager fee % - % to protocol) * reserveAssetQuantity
     * Protocol Fee = (% manager fee share + direct fee %) * reserveAssetQuantity
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAssetQuantity         Quantity of reserve asset to calculate fees from
     * @param _protocolManagerFeeIndex      Index to pull rev share NAV Issuance fee from the Controller
     * @param _protocolDirectFeeIndex       Index to pull direct NAV issuance fee from the Controller
     * @param _managerFeeIndex              Index from NAVIssuanceSettings (0 = issue fee, 1 = redeem fee)
     *
     * @return  uint256                     Fees paid to the protocol in reserve asset
     * @return  uint256                     Fees paid to the manager in reserve asset
     * @return  uint256                     Net reserve to user net of fees
     */
    function _getFees(
        ISetToken _setToken,
        uint256 _reserveAssetQuantity,
        uint256 _protocolManagerFeeIndex,
        uint256 _protocolDirectFeeIndex,
        uint256 _managerFeeIndex
    )
        internal
        view
        returns (uint256, uint256, uint256)
    {
        (uint256 protocolFeePercentage, uint256 managerFeePercentage) = _getProtocolAndManagerFeePercentages(
            _setToken,
            _protocolManagerFeeIndex,
            _protocolDirectFeeIndex,
            _managerFeeIndex
        );

        // Calculate total notional fees
        uint256 protocolFees = protocolFeePercentage.preciseMul(_reserveAssetQuantity);
        uint256 managerFee = managerFeePercentage.preciseMul(_reserveAssetQuantity);

        uint256 netReserveFlow = _reserveAssetQuantity.sub(protocolFees).sub(managerFee);

        return (protocolFees, managerFee, netReserveFlow);
    }

    function _getProtocolAndManagerFeePercentages(
        ISetToken _setToken,
        uint256 _protocolManagerFeeIndex,
        uint256 _protocolDirectFeeIndex,
        uint256 _managerFeeIndex
    )
        internal
        view
        returns(uint256, uint256)
    {
        // Get protocol fee percentages
        uint256 protocolDirectFeePercent = controller.getModuleFee(address(this), _protocolDirectFeeIndex);
        uint256 protocolManagerShareFeePercent = controller.getModuleFee(address(this), _protocolManagerFeeIndex);
        uint256 managerFeePercent = navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];

        // Calculate revenue share split percentage
        uint256 protocolRevenueSharePercentage = protocolManagerShareFeePercent.preciseMul(managerFeePercent);
        uint256 managerRevenueSharePercentage = managerFeePercent.sub(protocolRevenueSharePercentage);
        uint256 totalProtocolFeePercentage = protocolRevenueSharePercentage.add(protocolDirectFeePercent);

        return (totalProtocolFeePercentage, managerRevenueSharePercentage);
    }

    function _getSetTokenMintQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _netReserveFlows,            // Value of reserve asset net of fees
        uint256 _setTotalSupply
    )
        internal
        view
        returns (uint256)
    {
        uint256 premiumPercentage = _getIssuePremium(_setToken, _reserveAsset, _netReserveFlows);
        uint256 premiumValue = _netReserveFlows.preciseMul(premiumPercentage);

        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (1e18)
        // Reverts if price is not found
        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);

        // Get reserve asset decimals
        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();
        uint256 normalizedTotalReserveQuantityNetFees = _netReserveFlows.preciseDiv(10 ** reserveAssetDecimals);
        uint256 normalizedTotalReserveQuantityNetFeesAndPremium = _netReserveFlows.sub(premiumValue).preciseDiv(10 ** reserveAssetDecimals);

        // Calculate SetTokens to mint to issuer
        uint256 denominator = _setTotalSupply.preciseMul(setTokenValuation).add(normalizedTotalReserveQuantityNetFees).sub(normalizedTotalReserveQuantityNetFeesAndPremium);
        return normalizedTotalReserveQuantityNetFeesAndPremium.preciseMul(_setTotalSupply).preciseDiv(denominator);
    }

    function _getRedeemReserveQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        internal
        view
        returns (uint256)
    {
        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (10e18)
        // Reverts if price is not found
        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);

        uint256 totalRedeemValueInPreciseUnits = _setTokenQuantity.preciseMul(setTokenValuation);
        // Get reserve asset decimals
        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();
        uint256 prePremiumReserveQuantity = totalRedeemValueInPreciseUnits.preciseMul(10 ** reserveAssetDecimals);

        uint256 premiumPercentage = _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);
        uint256 premiumQuantity = prePremiumReserveQuantity.preciseMulCeil(premiumPercentage);

        return prePremiumReserveQuantity.sub(premiumQuantity);
    }

    /**
     * The new position multiplier is calculated as follows:
     * inflationPercentage = (newSupply - oldSupply) / newSupply
     * newMultiplier = (1 - inflationPercentage) * positionMultiplier
     */
    function _getIssuePositionMultiplier(
        ISetToken _setToken,
        ActionInfo memory _issueInfo
    )
        internal
        view
        returns (uint256, int256)
    {
        // Calculate inflation and new position multiplier. Note: Round inflation up in order to round position multiplier down
        uint256 newTotalSupply = _issueInfo.setTokenQuantity.add(_issueInfo.previousSetTokenSupply);
        int256 newPositionMultiplier = _setToken.positionMultiplier()
            .mul(_issueInfo.previousSetTokenSupply.toInt256())
            .div(newTotalSupply.toInt256());

        return (newTotalSupply, newPositionMultiplier);
    }

    /**
     * Calculate deflation and new position multiplier. Note: Round deflation down in order to round position multiplier down
     *
     * The new position multiplier is calculated as follows:
     * deflationPercentage = (oldSupply - newSupply) / newSupply
     * newMultiplier = (1 + deflationPercentage) * positionMultiplier
     */
    function _getRedeemPositionMultiplier(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        ActionInfo memory _redeemInfo
    )
        internal
        view
        returns (uint256, int256)
    {
        uint256 newTotalSupply = _redeemInfo.previousSetTokenSupply.sub(_setTokenQuantity);
        int256 newPositionMultiplier = _setToken.positionMultiplier()
            .mul(_redeemInfo.previousSetTokenSupply.toInt256())
            .div(newTotalSupply.toInt256());

        return (newTotalSupply, newPositionMultiplier);
    }

    /**
     * The new position reserve asset unit is calculated as follows:
     * totalReserve = (oldUnit * oldSetTokenSupply) + reserveQuantity
     * newUnit = totalReserve / newSetTokenSupply
     */
    function _getIssuePositionUnit(
        ISetToken _setToken,
        address _reserveAsset,
        ActionInfo memory _issueInfo
    )
        internal
        view
        returns (uint256)
    {
        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();
        uint256 totalReserve = existingUnit
            .preciseMul(_issueInfo.previousSetTokenSupply)
            .add(_issueInfo.netFlowQuantity);

        return totalReserve.preciseDiv(_issueInfo.newSetTokenSupply);
    }

    /**
     * The new position reserve asset unit is calculated as follows:
     * totalReserve = (oldUnit * oldSetTokenSupply) - reserveQuantityToSendOut
     * newUnit = totalReserve / newSetTokenSupply
     */
    function _getRedeemPositionUnit(
        ISetToken _setToken,
        address _reserveAsset,
        ActionInfo memory _redeemInfo
    )
        internal
        view
        returns (uint256)
    {
        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();
        uint256 totalExistingUnits = existingUnit.preciseMul(_redeemInfo.previousSetTokenSupply);

        uint256 outflow = _redeemInfo.netFlowQuantity.add(_redeemInfo.protocolFees).add(_redeemInfo.managerFee);

        // Require withdrawable quantity is greater than existing collateral
        require(totalExistingUnits >= outflow, "Must be greater than total available collateral");

        return totalExistingUnits.sub(outflow).preciseDiv(_redeemInfo.newSetTokenSupply);
    }

    /**
     * If a pre-issue hook has been configured, call the external-protocol contract. Pre-issue hook logic
     * can contain arbitrary logic including validations, external function calls, etc.
     */
    function _callPreIssueHooks(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity,
        address _caller,
        address _to
    )
        internal
    {
        INAVIssuanceHook preIssueHook = navIssuanceSettings[_setToken].managerIssuanceHook;
        if (address(preIssueHook) != address(0)) {
            preIssueHook.invokePreIssueHook(_setToken, _reserveAsset, _reserveAssetQuantity, _caller, _to);
        }
    }

    /**
     * If a pre-redeem hook has been configured, call the external-protocol contract.
     */
    function _callPreRedeemHooks(ISetToken _setToken, uint256 _setQuantity, address _caller, address _to) internal {
        INAVIssuanceHook preRedeemHook = navIssuanceSettings[_setToken].managerRedemptionHook;
        if (address(preRedeemHook) != address(0)) {
            preRedeemHook.invokePreRedeemHook(_setToken, _setQuantity, _caller, _to);
        }
    }
}.]

###

[2024-01-09 05:31:21 INFO] **[Seminar Conclusion]**:

 ###

[2024-01-09 05:31:21 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 1

[2024-01-09 05:31:21 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /*     Copyright 2020 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol"; import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol"; import { SignedSafeMath } from "@openzeppelin/contracts/math/SignedSafeMath.sol"; import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol"; import { IController } from "../../interfaces/IController.sol"; import { INAVIssuanceHook } from "../../interfaces/INAVIssuanceHook.sol"; import { Invoke } from "../lib/Invoke.sol"; import { ISetToken } from "../../interfaces/ISetToken.sol"; import { IWETH } from "../../interfaces/external/IWETH.sol"; import { ModuleBase } from "../lib/ModuleBase.sol"; import { Position } from "../lib/Position.sol"; import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol"; import { ResourceIdentifier } from "../lib/ResourceIdentifier.sol"; /*  * @title NavIssuanceModule  * @author Set Protocol  *  * Module that enables issuance and redemption with any valid ERC20 token or ETH if allowed by the manager. Sender receives  * a proportional amount of SetTokens on issuance or ERC20 token on redemption based on the calculated net asset value using  * oracle prices. Manager is able to enforce a premium / discount on issuance / redemption to avoid arbitrage and front  * running when relying on oracle prices. Managers can charge a fee (denominated in reserve asset).  / contract NavIssuanceModule is ModuleBase, ReentrancyGuard {     using AddressArrayUtils for address[];     using Invoke for ISetToken;     using Position for ISetToken;     using PreciseUnitMath for uint256;     using PreciseUnitMath for int256;     using ResourceIdentifier for IController;     using SafeMath for uint256;     using SafeCast for int256;     using SafeCast for uint256;     using SignedSafeMath for int256; /* ============ Events ============ */  event SetTokenNAVIssued(     ISetToken indexed _setToken,     address _issuer,     address _to,     address _reserveAsset,     address _hookContract,     uint256 _setTokenQuantity,     uint256 _managerFee,     uint256 _premium );  event SetTokenNAVRedeemed(     ISetToken indexed _setToken,     address _redeemer,     address _to,     address _reserveAsset,     address _hookContract,     uint256 _setTokenQuantity,     uint256 _managerFee,     uint256 _premium );  event ReserveAssetAdded(     ISetToken indexed _setToken,     address _newReserveAsset );  event ReserveAssetRemoved(     ISetToken indexed _setToken,     address _removedReserveAsset );  event PremiumEdited(     ISetToken indexed _setToken,     uint256 _newPremium );  event ManagerFeeEdited(     ISetToken indexed _setToken,     uint256 _newManagerFee,     uint256 _index );  event FeeRecipientEdited(     ISetToken indexed _setToken,     address _feeRecipient );  /* ============ Structs ============ */  struct NAVIssuanceSettings {     INAVIssuanceHook managerIssuanceHook;      // Issuance hook configurations     INAVIssuanceHook managerRedemptionHook;    // Redemption hook configurations     address[] reserveAssets;                       // Allowed reserve assets - Must have a price enabled with the price oracle     address feeRecipient;                          // Manager fee recipient     uint256[2] managerFees;                        // Manager fees. 0 index is issue and 1 index is redeem fee (0.01% = 1e14, 1% = 1e16)     uint256 maxManagerFee;                         // Maximum fee manager is allowed to set for issue and redeem     uint256 premiumPercentage;                     // Premium percentage (0.01% = 1e14, 1% = 1e16). This premium is a buffer around oracle                                                    // prices paid by user to the SetToken, which prevents arbitrage and oracle front running     uint256 maxPremiumPercentage;                  // Maximum premium percentage manager is allowed to set (configured by manager)     uint256 minSetTokenSupply;                     // Minimum SetToken supply required for issuance and redemption                                                    // to prevent dramatic inflationary changes to the SetToken's position multiplier }  struct ActionInfo {     uint256 preFeeReserveQuantity;                 // Reserve value before fees; During issuance, represents raw quantity                                                    // During redeem, represents post-premium value     uint256 protocolFees;                          // Total protocol fees (direct + manager revenue share)     uint256 managerFee;                            // Total manager fee paid in reserve asset     uint256 netFlowQuantity;                       // When issuing, quantity of reserve asset sent to SetToken                                                    // When redeeming, quantity of reserve asset sent to redeemer     uint256 setTokenQuantity;                      // When issuing, quantity of SetTokens minted to mintee                                                    // When redeeming, quantity of SetToken redeemed     uint256 previousSetTokenSupply;                // SetToken supply prior to issue/redeem action     uint256 newSetTokenSupply;                     // SetToken supply after issue/redeem action     int256 newPositionMultiplier;                  // SetToken position multiplier after issue/redeem     uint256 newReservePositionUnit;                // SetToken reserve asset position unit after issue/redeem }  /* ============ State Variables ============ */  // Wrapped ETH address IWETH public immutable weth;  // Mapping of SetToken to NAV issuance settings struct mapping(ISetToken =&gt; NAVIssuanceSettings) public navIssuanceSettings;  // Mapping to efficiently check a SetToken's reserve asset validity // SetToken =&gt; reserveAsset =&gt; isReserveAsset mapping(ISetToken =&gt; mapping(address =&gt; bool)) public isReserveAsset;  /* ============ Constants ============ */  // 0 index stores the manager fee in managerFees array, percentage charged on issue (denominated in reserve asset) uint256 constant internal MANAGER_ISSUE_FEE_INDEX = 0;  // 1 index stores the manager fee percentage in managerFees array, charged on redeem uint256 constant internal MANAGER_REDEEM_FEE_INDEX = 1;  // 0 index stores the manager revenue share protocol fee % on the controller, charged in the issuance function uint256 constant internal PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX = 0;  // 1 index stores the manager revenue share protocol fee % on the controller, charged in the redeem function uint256 constant internal PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX = 1;  // 2 index stores the direct protocol fee % on the controller, charged in the issuance function uint256 constant internal PROTOCOL_ISSUE_DIRECT_FEE_INDEX = 2;  // 3 index stores the direct protocol fee % on the controller, charged in the redeem function uint256 constant internal PROTOCOL_REDEEM_DIRECT_FEE_INDEX = 3;  /* ============ Constructor ============ */  /**  * @param _controller               Address of controller contract  * @param _weth                     Address of wrapped eth  */ constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {     weth = _weth; }  /* ============ External Functions ============ */  /**  * Deposits the allowed reserve asset into the SetToken and mints the appropriate % of Net Asset Value of the SetToken  * to the specified _to address.  *  * @param _setToken                     Instance of the SetToken contract  * @param _reserveAsset                 Address of the reserve asset to issue with  * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with  * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance  * @param _to                           Address to mint SetToken to  */ function issue(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity,     uint256 _minSetTokenReceiveQuantity,     address _to )     external     nonReentrant     onlyValidAndInitializedSet(_setToken) {     _validateCommon(_setToken, _reserveAsset, _reserveAssetQuantity);      _callPreIssueHooks(_setToken, _reserveAsset, _reserveAssetQuantity, msg.sender, _to);      ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, _reserveAsset, _reserveAssetQuantity);      _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);      _transferCollateralAndHandleFees(_setToken, IERC20(_reserveAsset), issueInfo);      _handleIssueStateUpdates(_setToken, _reserveAsset, _to, issueInfo); }  /**  * Wraps ETH and deposits WETH if allowed into the SetToken and mints the appropriate % of Net Asset Value of the SetToken  * to the specified _to address.  *  * @param _setToken                     Instance of the SetToken contract  * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance  * @param _to                           Address to mint SetToken to  */ function issueWithEther(     ISetToken _setToken,     uint256 _minSetTokenReceiveQuantity,     address _to )     external     payable     nonReentrant     onlyValidAndInitializedSet(_setToken) {     weth.deposit{ value: msg.value }();      _validateCommon(_setToken, address(weth), msg.value);      _callPreIssueHooks(_setToken, address(weth), msg.value, msg.sender, _to);      ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, address(weth), msg.value);      _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);      _transferWETHAndHandleFees(_setToken, issueInfo);      _handleIssueStateUpdates(_setToken, address(weth), _to, issueInfo); }  /**  * Redeems a SetToken into a valid reserve asset representing the appropriate % of Net Asset Value of the SetToken  * to the specified _to address. Only valid if there are available reserve units on the SetToken.  *  * @param _setToken                     Instance of the SetToken contract  * @param _reserveAsset                 Address of the reserve asset to redeem with  * @param _setTokenQuantity             Quantity of SetTokens to redeem  * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive  * @param _to                           Address to redeem reserve asset to  */ function redeem(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity,     uint256 _minReserveReceiveQuantity,     address _to )     external     nonReentrant     onlyValidAndInitializedSet(_setToken) {     _validateCommon(_setToken, _reserveAsset, _setTokenQuantity);      _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);      ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, _reserveAsset, _setTokenQuantity);      _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);      _setToken.burn(msg.sender, _setTokenQuantity);      // Instruct the SetToken to transfer the reserve asset back to the user     _setToken.strictInvokeTransfer(         _reserveAsset,         _to,         redeemInfo.netFlowQuantity     );      _handleRedemptionFees(_setToken, _reserveAsset, redeemInfo);      _handleRedeemStateUpdates(_setToken, _reserveAsset, _to, redeemInfo); }  /**  * Redeems a SetToken into Ether (if WETH is valid) representing the appropriate % of Net Asset Value of the SetToken  * to the specified _to address. Only valid if there are available WETH units on the SetToken.  *  * @param _setToken                     Instance of the SetToken contract  * @param _setTokenQuantity             Quantity of SetTokens to redeem  * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive  * @param _to                           Address to redeem reserve asset to  */ function redeemIntoEther(     ISetToken _setToken,     uint256 _setTokenQuantity,     uint256 _minReserveReceiveQuantity,     address payable _to )     external     nonReentrant     onlyValidAndInitializedSet(_setToken) {     _validateCommon(_setToken, address(weth), _setTokenQuantity);      _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);      ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, address(weth), _setTokenQuantity);      _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);      _setToken.burn(msg.sender, _setTokenQuantity);      // Instruct the SetToken to transfer WETH from SetToken to module     _setToken.strictInvokeTransfer(         address(weth),         address(this),         redeemInfo.netFlowQuantity     );      weth.withdraw(redeemInfo.netFlowQuantity);      _to.transfer(redeemInfo.netFlowQuantity);      _handleRedemptionFees(_setToken, address(weth), redeemInfo);      _handleRedeemStateUpdates(_setToken, address(weth), _to, redeemInfo); }  /**  * SET MANAGER ONLY. Add an allowed reserve asset  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset to add  */ function addReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {     require(!isReserveAsset[_setToken][_reserveAsset], "Reserve asset already exists");      navIssuanceSettings[_setToken].reserveAssets.push(_reserveAsset);     isReserveAsset[_setToken][_reserveAsset] = true;      emit ReserveAssetAdded(_setToken, _reserveAsset); }  /**  * SET MANAGER ONLY. Remove a reserve asset  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset to remove  */ function removeReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {     require(isReserveAsset[_setToken][_reserveAsset], "Reserve asset does not exist");      navIssuanceSettings[_setToken].reserveAssets = navIssuanceSettings[_setToken].reserveAssets.remove(_reserveAsset);     delete isReserveAsset[_setToken][_reserveAsset];      emit ReserveAssetRemoved(_setToken, _reserveAsset); }  /**  * SET MANAGER ONLY. Edit the premium percentage  *  * @param _setToken                     Instance of the SetToken  * @param _premiumPercentage            Premium percentage in 10e16 (e.g. 10e16 = 1%)  */ function editPremium(ISetToken _setToken, uint256 _premiumPercentage) external onlyManagerAndValidSet(_setToken) {     require(_premiumPercentage &lt;= navIssuanceSettings[_setToken].maxPremiumPercentage, "Premium must be less than maximum allowed");      navIssuanceSettings[_setToken].premiumPercentage = _premiumPercentage;      emit PremiumEdited(_setToken, _premiumPercentage); }  /**  * SET MANAGER ONLY. Edit manager fee  *  * @param _setToken                     Instance of the SetToken  * @param _managerFeePercentage         Manager fee percentage in 10e16 (e.g. 10e16 = 1%)  * @param _managerFeeIndex              Manager fee index. 0 index is issue fee, 1 index is redeem fee  */ function editManagerFee(     ISetToken _setToken,     uint256 _managerFeePercentage,     uint256 _managerFeeIndex )     external     onlyManagerAndValidSet(_setToken) {     require(_managerFeePercentage &lt;= navIssuanceSettings[_setToken].maxManagerFee, "Manager fee must be less than maximum allowed");      navIssuanceSettings[_setToken].managerFees[_managerFeeIndex] = _managerFeePercentage;      emit ManagerFeeEdited(_setToken, _managerFeePercentage, _managerFeeIndex); }  /**  * SET MANAGER ONLY. Edit the manager fee recipient  *  * @param _setToken                     Instance of the SetToken  * @param _managerFeeRecipient          Manager fee recipient  */ function editFeeRecipient(ISetToken _setToken, address _managerFeeRecipient) external onlyManagerAndValidSet(_setToken) {     require(_managerFeeRecipient != address(0), "Fee recipient must not be 0 address");      navIssuanceSettings[_setToken].feeRecipient = _managerFeeRecipient;      emit FeeRecipientEdited(_setToken, _managerFeeRecipient); }  /**  * SET MANAGER ONLY. Initializes this module to the SetToken with hooks, allowed reserve assets,  * fees and issuance premium. Only callable by the SetToken's manager. Hook addresses are optional.  * Address(0) means that no hook will be called.  *  * @param _setToken                     Instance of the SetToken to issue  * @param _navIssuanceSettings          NAVIssuanceSettings struct defining parameters  */ function initialize(     ISetToken _setToken,     NAVIssuanceSettings memory _navIssuanceSettings )     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     require(_navIssuanceSettings.reserveAssets.length &gt; 0, "Reserve assets must be greater than 0");     require(_navIssuanceSettings.maxManagerFee &lt; PreciseUnitMath.preciseUnit(), "Max manager fee must be less than 100%");     require(_navIssuanceSettings.maxPremiumPercentage &lt; PreciseUnitMath.preciseUnit(), "Max premium percentage must be less than 100%");     require(_navIssuanceSettings.managerFees[0] &lt;= _navIssuanceSettings.maxManagerFee, "Manager issue fee must be less than max");     require(_navIssuanceSettings.managerFees[1] &lt;= _navIssuanceSettings.maxManagerFee, "Manager redeem fee must be less than max");     require(_navIssuanceSettings.premiumPercentage &lt;= _navIssuanceSettings.maxPremiumPercentage, "Premium must be less than max");     require(_navIssuanceSettings.feeRecipient != address(0), "Fee Recipient must be non-zero address.");     // Initial mint of Set cannot use NAVIssuance since minSetTokenSupply must be &gt; 0     require(_navIssuanceSettings.minSetTokenSupply &gt; 0, "Min SetToken supply must be greater than 0");      for (uint256 i = 0; i &lt; _navIssuanceSettings.reserveAssets.length; i++) {         require(!isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]], "Reserve assets must be unique");         isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]] = true;     }      navIssuanceSettings[_setToken] = _navIssuanceSettings;      _setToken.initializeModule(); }  /**  * Removes this module from the SetToken, via call by the SetToken. Issuance settings and  * reserve asset states are deleted.  */ function removeModule() external override {     ISetToken setToken = ISetToken(msg.sender);     for (uint256 i = 0; i &lt; navIssuanceSettings[setToken].reserveAssets.length; i++) {         delete isReserveAsset[setToken][navIssuanceSettings[setToken].reserveAssets[i]];     }      delete navIssuanceSettings[setToken]; }  receive() external payable {}  /* ============ External Getter Functions ============ */  function getReserveAssets(ISetToken _setToken) external view returns (address[] memory) {     return navIssuanceSettings[_setToken].reserveAssets; }  function getIssuePremium(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     external     view     returns (uint256) {     return _getIssuePremium(_setToken, _reserveAsset, _reserveAssetQuantity); }  function getRedeemPremium(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     external     view     returns (uint256) {     return _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity); }  function getManagerFee(ISetToken _setToken, uint256 _managerFeeIndex) external view returns (uint256) {     return navIssuanceSettings[_setToken].managerFees[_managerFeeIndex]; }  /**  * Get the expected SetTokens minted to recipient on issuance  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with  *  * @return  uint256                     Expected SetTokens to be minted to recipient  */ function getExpectedSetTokenIssueQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     external     view     returns (uint256) {     (,, uint256 netReserveFlow) = _getFees(         _setToken,         _reserveAssetQuantity,         PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_ISSUE_DIRECT_FEE_INDEX,         MANAGER_ISSUE_FEE_INDEX     );      uint256 setTotalSupply = _setToken.totalSupply();      return _getSetTokenMintQuantity(         _setToken,         _reserveAsset,         netReserveFlow,         setTotalSupply     ); }  /**  * Get the expected reserve asset to be redeemed  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _setTokenQuantity             Quantity of SetTokens to redeem  *  * @return  uint256                     Expected reserve asset quantity redeemed  */ function getExpectedReserveRedeemQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     external     view     returns (uint256) {     uint256 preFeeReserveQuantity = _getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);      (,, uint256 netReserveFlows) = _getFees(         _setToken,         preFeeReserveQuantity,         PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_REDEEM_DIRECT_FEE_INDEX,         MANAGER_REDEEM_FEE_INDEX     );      return netReserveFlows; }  /**  * Checks if issue is valid  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with  *  * @return  bool                        Returns true if issue is valid  */ function isIssueValid(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     external     view     returns (bool) {     uint256 setTotalSupply = _setToken.totalSupply();  return _reserveAssetQuantity != 0         &amp;&amp; isReserveAsset[_setToken][_reserveAsset]         &amp;&amp; setTotalSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply; }  /**  * Checks if redeem is valid  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _setTokenQuantity             Quantity of SetTokens to redeem  *  * @return  bool                        Returns true if redeem is valid  */ function isRedeemValid(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     external     view     returns (bool) {     uint256 setTotalSupply = _setToken.totalSupply();      if (         _setTokenQuantity == 0         || !isReserveAsset[_setToken][_reserveAsset]         || setTotalSupply &lt; navIssuanceSettings[_setToken].minSetTokenSupply.add(_setTokenQuantity)     ) {         return false;     } else {         uint256 totalRedeemValue =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);          (,, uint256 expectedRedeemQuantity) = _getFees(             _setToken,             totalRedeemValue,             PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,             PROTOCOL_REDEEM_DIRECT_FEE_INDEX,             MANAGER_REDEEM_FEE_INDEX         );          uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();          return existingUnit.preciseMul(setTotalSupply) &gt;= expectedRedeemQuantity;     } }  /* ============ Internal Functions ============ */  function _validateCommon(ISetToken _setToken, address _reserveAsset, uint256 _quantity) internal view {     require(_quantity &gt; 0, "Quantity must be &gt; 0");     require(isReserveAsset[_setToken][_reserveAsset], "Must be valid reserve asset"); }  function _validateIssuanceInfo(ISetToken _setToken, uint256 _minSetTokenReceiveQuantity, ActionInfo memory _issueInfo) internal view {     // Check that total supply is greater than min supply needed for issuance     // Note: A min supply amount is needed to avoid division by 0 when SetToken supply is 0     require(         _issueInfo.previousSetTokenSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply,         "Supply must be greater than minimum to enable issuance"     );      require(_issueInfo.setTokenQuantity &gt;= _minSetTokenReceiveQuantity, "Must be greater than min SetToken"); }  function _validateRedemptionInfo(     ISetToken _setToken,     uint256 _minReserveReceiveQuantity,     ActionInfo memory _redeemInfo )     internal     view {     // Check that new supply is more than min supply needed for redemption     // Note: A min supply amount is needed to avoid division by 0 when redeeming SetToken to 0     require(         _redeemInfo.newSetTokenSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply,         "Supply must be greater than minimum to enable redemption"     );      require(_redeemInfo.netFlowQuantity &gt;= _minReserveReceiveQuantity, "Must be greater than min receive reserve quantity"); }  function _createIssuanceInfo(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     internal     view     returns (ActionInfo memory) {     ActionInfo memory issueInfo;      issueInfo.previousSetTokenSupply = _setToken.totalSupply();      issueInfo.preFeeReserveQuantity = _reserveAssetQuantity;      (issueInfo.protocolFees, issueInfo.managerFee, issueInfo.netFlowQuantity) = _getFees(         _setToken,         issueInfo.preFeeReserveQuantity,         PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_ISSUE_DIRECT_FEE_INDEX,         MANAGER_ISSUE_FEE_INDEX     );      issueInfo.setTokenQuantity = _getSetTokenMintQuantity(         _setToken,         _reserveAsset,         issueInfo.netFlowQuantity,         issueInfo.previousSetTokenSupply     );      (issueInfo.newSetTokenSupply, issueInfo.newPositionMultiplier) = _getIssuePositionMultiplier(_setToken, issueInfo);      issueInfo.newReservePositionUnit = _getIssuePositionUnit(_setToken, _reserveAsset, issueInfo);      return issueInfo; }  function _createRedemptionInfo(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     internal     view     returns (ActionInfo memory) {     ActionInfo memory redeemInfo;      redeemInfo.setTokenQuantity = _setTokenQuantity;      redeemInfo.preFeeReserveQuantity =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);      (redeemInfo.protocolFees, redeemInfo.managerFee, redeemInfo.netFlowQuantity) = _getFees(         _setToken,         redeemInfo.preFeeReserveQuantity,         PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_REDEEM_DIRECT_FEE_INDEX,         MANAGER_REDEEM_FEE_INDEX     );      redeemInfo.previousSetTokenSupply = _setToken.totalSupply();      (redeemInfo.newSetTokenSupply, redeemInfo.newPositionMultiplier) = _getRedeemPositionMultiplier(_setToken, _setTokenQuantity, redeemInfo);      redeemInfo.newReservePositionUnit = _getRedeemPositionUnit(_setToken, _reserveAsset, redeemInfo);      return redeemInfo; }  /**  * Transfer reserve asset from user to SetToken and fees from user to appropriate fee recipients  */ function _transferCollateralAndHandleFees(ISetToken _setToken, IERC20 _reserveAsset, ActionInfo memory _issueInfo) internal {     transferFrom(_reserveAsset, msg.sender, address(_setToken), _issueInfo.netFlowQuantity);      if (_issueInfo.protocolFees &gt; 0) {         transferFrom(_reserveAsset, msg.sender, controller.feeRecipient(), _issueInfo.protocolFees);     }      if (_issueInfo.managerFee &gt; 0) {         transferFrom(_reserveAsset, msg.sender, navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);     } }   /**   * Transfer WETH from module to SetToken and fees from module to appropriate fee recipients  */ function _transferWETHAndHandleFees(ISetToken _setToken, ActionInfo memory _issueInfo) internal {     weth.transfer(address(_setToken), _issueInfo.netFlowQuantity);      if (_issueInfo.protocolFees &gt; 0) {         weth.transfer(controller.feeRecipient(), _issueInfo.protocolFees);     }      if (_issueInfo.managerFee &gt; 0) {         weth.transfer(navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);     } }  function _handleIssueStateUpdates(     ISetToken _setToken,     address _reserveAsset,     address _to,     ActionInfo memory _issueInfo )     internal {     _setToken.editPositionMultiplier(_issueInfo.newPositionMultiplier);      _setToken.editDefaultPosition(_reserveAsset, _issueInfo.newReservePositionUnit);      _setToken.mint(_to, _issueInfo.setTokenQuantity);      emit SetTokenNAVIssued(         _setToken,         msg.sender,         _to,         _reserveAsset,         address(navIssuanceSettings[_setToken].managerIssuanceHook),         _issueInfo.setTokenQuantity,         _issueInfo.managerFee,         _issueInfo.protocolFees     ); }  function _handleRedeemStateUpdates(     ISetToken _setToken,     address _reserveAsset,     address _to,     ActionInfo memory _redeemInfo )     internal {     _setToken.editPositionMultiplier(_redeemInfo.newPositionMultiplier);      _setToken.editDefaultPosition(_reserveAsset, _redeemInfo.newReservePositionUnit);      emit SetTokenNAVRedeemed(         _setToken,         msg.sender,         _to,         _reserveAsset,         address(navIssuanceSettings[_setToken].managerRedemptionHook),         _redeemInfo.setTokenQuantity,         _redeemInfo.managerFee,         _redeemInfo.protocolFees     ); }  function _handleRedemptionFees(ISetToken _setToken, address _reserveAsset, ActionInfo memory _redeemInfo) internal {     // Instruct the SetToken to transfer protocol fee to fee recipient if there is a fee     payProtocolFeeFromSetToken(_setToken, _reserveAsset, _redeemInfo.protocolFees);      // Instruct the SetToken to transfer manager fee to manager fee recipient if there is a fee     if (_redeemInfo.managerFee &gt; 0) {         _setToken.strictInvokeTransfer(             _reserveAsset,             navIssuanceSettings[_setToken].feeRecipient,             _redeemInfo.managerFee         );     } }  /**  * Returns the issue premium percentage. Virtual function that can be overridden in future versions of the module  * and can contain arbitrary logic to calculate the issuance premium.  */ function _getIssuePremium(     ISetToken _setToken,     address /* _reserveAsset */,     uint256 /* _reserveAssetQuantity */ )     virtual     internal     view     returns (uint256) {     return navIssuanceSettings[_setToken].premiumPercentage; }  /**  * Returns the redeem premium percentage. Virtual function that can be overridden in future versions of the module  * and can contain arbitrary logic to calculate the redemption premium.  */ function _getRedeemPremium(     ISetToken _setToken,     address /* _reserveAsset */,     uint256 /* _setTokenQuantity */ )     virtual     internal     view     returns (uint256) {     return navIssuanceSettings[_setToken].premiumPercentage; }  /**  * Returns the fees attributed to the manager and the protocol. The fees are calculated as follows:  *  * ManagerFee = (manager fee % - % to protocol) * reserveAssetQuantity  * Protocol Fee = (% manager fee share + direct fee %) * reserveAssetQuantity  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAssetQuantity         Quantity of reserve asset to calculate fees from  * @param _protocolManagerFeeIndex      Index to pull rev share NAV Issuance fee from the Controller  * @param _protocolDirectFeeIndex       Index to pull direct NAV issuance fee from the Controller  * @param _managerFeeIndex              Index from NAVIssuanceSettings (0 = issue fee, 1 = redeem fee)  *  * @return  uint256                     Fees paid to the protocol in reserve asset  * @return  uint256                     Fees paid to the manager in reserve asset  * @return  uint256                     Net reserve to user net of fees  */ function _getFees(     ISetToken _setToken,     uint256 _reserveAssetQuantity,     uint256 _protocolManagerFeeIndex,     uint256 _protocolDirectFeeIndex,     uint256 _managerFeeIndex )     internal     view     returns (uint256, uint256, uint256) {     (uint256 protocolFeePercentage, uint256 managerFeePercentage) = _getProtocolAndManagerFeePercentages(         _setToken,         _protocolManagerFeeIndex,         _protocolDirectFeeIndex,         _managerFeeIndex     );      // Calculate total notional fees     uint256 protocolFees = protocolFeePercentage.preciseMul(_reserveAssetQuantity);     uint256 managerFee = managerFeePercentage.preciseMul(_reserveAssetQuantity);      uint256 netReserveFlow = _reserveAssetQuantity.sub(protocolFees).sub(managerFee);      return (protocolFees, managerFee, netReserveFlow); }  function _getProtocolAndManagerFeePercentages(     ISetToken _setToken,     uint256 _protocolManagerFeeIndex,     uint256 _protocolDirectFeeIndex,     uint256 _managerFeeIndex )     internal     view     returns(uint256, uint256) {     // Get protocol fee percentages     uint256 protocolDirectFeePercent = controller.getModuleFee(address(this), _protocolDirectFeeIndex);     uint256 protocolManagerShareFeePercent = controller.getModuleFee(address(this), _protocolManagerFeeIndex);     uint256 managerFeePercent = navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];      // Calculate revenue share split percentage     uint256 protocolRevenueSharePercentage = protocolManagerShareFeePercent.preciseMul(managerFeePercent);     uint256 managerRevenueSharePercentage = managerFeePercent.sub(protocolRevenueSharePercentage);     uint256 totalProtocolFeePercentage = protocolRevenueSharePercentage.add(protocolDirectFeePercent);      return (totalProtocolFeePercentage, managerRevenueSharePercentage); }  function _getSetTokenMintQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _netReserveFlows,            // Value of reserve asset net of fees     uint256 _setTotalSupply )     internal     view     returns (uint256) {     uint256 premiumPercentage = _getIssuePremium(_setToken, _reserveAsset, _netReserveFlows);     uint256 premiumValue = _netReserveFlows.preciseMul(premiumPercentage);      // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (1e18)     // Reverts if price is not found     uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);      // Get reserve asset decimals     uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();     uint256 normalizedTotalReserveQuantityNetFees = _netReserveFlows.preciseDiv(10 ** reserveAssetDecimals);     uint256 normalizedTotalReserveQuantityNetFeesAndPremium = _netReserveFlows.sub(premiumValue).preciseDiv(10 ** reserveAssetDecimals);      // Calculate SetTokens to mint to issuer     uint256 denominator = _setTotalSupply.preciseMul(setTokenValuation).add(normalizedTotalReserveQuantityNetFees).sub(normalizedTotalReserveQuantityNetFeesAndPremium);     return normalizedTotalReserveQuantityNetFeesAndPremium.preciseMul(_setTotalSupply).preciseDiv(denominator); }  function _getRedeemReserveQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     internal     view     returns (uint256) {     // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (10e18)     // Reverts if price is not found     uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);      uint256 totalRedeemValueInPreciseUnits = _setTokenQuantity.preciseMul(setTokenValuation);     // Get reserve asset decimals     uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();     uint256 prePremiumReserveQuantity = totalRedeemValueInPreciseUnits.preciseMul(10 ** reserveAssetDecimals);      uint256 premiumPercentage = _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);     uint256 premiumQuantity = prePremiumReserveQuantity.preciseMulCeil(premiumPercentage);      return prePremiumReserveQuantity.sub(premiumQuantity); }  /**  * The new position multiplier is calculated as follows:  * inflationPercentage = (newSupply - oldSupply) / newSupply  * newMultiplier = (1 - inflationPercentage) * positionMultiplier  */ function _getIssuePositionMultiplier(     ISetToken _setToken,     ActionInfo memory _issueInfo )     internal     view     returns (uint256, int256) {     // Calculate inflation and new position multiplier. Note: Round inflation up in order to round position multiplier down     uint256 newTotalSupply = _issueInfo.setTokenQuantity.add(_issueInfo.previousSetTokenSupply);     int256 newPositionMultiplier = _setToken.positionMultiplier()         .mul(_issueInfo.previousSetTokenSupply.toInt256())         .div(newTotalSupply.toInt256());      return (newTotalSupply, newPositionMultiplier); }  /**  * Calculate deflation and new position multiplier. Note: Round deflation down in order to round position multiplier down  *  * The new position multiplier is calculated as follows:  * deflationPercentage = (oldSupply - newSupply) / newSupply  * newMultiplier = (1 + deflationPercentage) * positionMultiplier  */ function _getRedeemPositionMultiplier(     ISetToken _setToken,     uint256 _setTokenQuantity,     ActionInfo memory _redeemInfo )     internal     view     returns (uint256, int256) {     uint256 newTotalSupply = _redeemInfo.previousSetTokenSupply.sub(_setTokenQuantity);     int256 newPositionMultiplier = _setToken.positionMultiplier()         .mul(_redeemInfo.previousSetTokenSupply.toInt256())         .div(newTotalSupply.toInt256());      return (newTotalSupply, newPositionMultiplier); }  /**  * The new position reserve asset unit is calculated as follows:  * totalReserve = (oldUnit * oldSetTokenSupply) + reserveQuantity  * newUnit = totalReserve / newSetTokenSupply  */ function _getIssuePositionUnit(     ISetToken _setToken,     address _reserveAsset,     ActionInfo memory _issueInfo )     internal     view     returns (uint256) {     uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();     uint256 totalReserve = existingUnit         .preciseMul(_issueInfo.previousSetTokenSupply)         .add(_issueInfo.netFlowQuantity);      return totalReserve.preciseDiv(_issueInfo.newSetTokenSupply); }  /**  * The new position reserve asset unit is calculated as follows:  * totalReserve = (oldUnit * oldSetTokenSupply) - reserveQuantityToSendOut  * newUnit = totalReserve / newSetTokenSupply  */ function _getRedeemPositionUnit(     ISetToken _setToken,     address _reserveAsset,     ActionInfo memory _redeemInfo )     internal     view     returns (uint256) {     uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();     uint256 totalExistingUnits = existingUnit.preciseMul(_redeemInfo.previousSetTokenSupply);      uint256 outflow = _redeemInfo.netFlowQuantity.add(_redeemInfo.protocolFees).add(_redeemInfo.managerFee);      // Require withdrawable quantity is greater than existing collateral     require(totalExistingUnits &gt;= outflow, "Must be greater than total available collateral");      return totalExistingUnits.sub(outflow).preciseDiv(_redeemInfo.newSetTokenSupply); }  /**  * If a pre-issue hook has been configured, call the external-protocol contract. Pre-issue hook logic  * can contain arbitrary logic including validations, external function calls, etc.  */ function _callPreIssueHooks(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity,     address _caller,     address _to )     internal {     INAVIssuanceHook preIssueHook = navIssuanceSettings[_setToken].managerIssuanceHook;     if (address(preIssueHook) != address(0)) {         preIssueHook.invokePreIssueHook(_setToken, _reserveAsset, _reserveAssetQuantity, _caller, _to);     } }  /**  * If a pre-redeem hook has been configured, call the external-protocol contract.  */ function _callPreRedeemHooks(ISetToken _setToken, uint256 _setQuantity, address _caller, address _to) internal {     INAVIssuanceHook preRedeemHook = navIssuanceSettings[_setToken].managerRedemptionHook;     if (address(preRedeemHook) != address(0)) {         preRedeemHook.invokePreRedeemHook(_setToken, _setQuantity, _caller, _to);     } }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 05:31:22 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | /*     Copyright 2020 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol"; import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol"; import { SignedSafeMath } from "@openzeppelin/contracts/math/SignedSafeMath.sol"; import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol"; import { IController } from "../../interfaces/IController.sol"; import { INAVIssuanceHook } from "../../interfaces/INAVIssuanceHook.sol"; import { Invoke } from "../lib/Invoke.sol"; import { ISetToken } from "../../interfaces/ISetToken.sol"; import { IWETH } from "../../interfaces/external/IWETH.sol"; import { ModuleBase } from "../lib/ModuleBase.sol"; import { Position } from "../lib/Position.sol"; import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol"; import { ResourceIdentifier } from "../lib/ResourceIdentifier.sol"; /*  * @title NavIssuanceModule  * @author Set Protocol  *  * Module that enables issuance and redemption with any valid ERC20 token or ETH if allowed by the manager. Sender receives  * a proportional amount of SetTokens on issuance or ERC20 token on redemption based on the calculated net asset value using  * oracle prices. Manager is able to enforce a premium / discount on issuance / redemption to avoid arbitrage and front  * running when relying on oracle prices. Managers can charge a fee (denominated in reserve asset).  / contract NavIssuanceModule is ModuleBase, ReentrancyGuard {     using AddressArrayUtils for address[];     using Invoke for ISetToken;     using Position for ISetToken;     using PreciseUnitMath for uint256;     using PreciseUnitMath for int256;     using ResourceIdentifier for IController;     using SafeMath for uint256;     using SafeCast for int256;     using SafeCast for uint256;     using SignedSafeMath for int256; /* ============ Events ============ */  event SetTokenNAVIssued(     ISetToken indexed _setToken,     address _issuer,     address _to,     address _reserveAsset,     address _hookContract,     uint256 _setTokenQuantity,     uint256 _managerFee,     uint256 _premium );  event SetTokenNAVRedeemed(     ISetToken indexed _setToken,     address _redeemer,     address _to,     address _reserveAsset,     address _hookContract,     uint256 _setTokenQuantity,     uint256 _managerFee,     uint256 _premium );  event ReserveAssetAdded(     ISetToken indexed _setToken,     address _newReserveAsset );  event ReserveAssetRemoved(     ISetToken indexed _setToken,     address _removedReserveAsset );  event PremiumEdited(     ISetToken indexed _setToken,     uint256 _newPremium );  event ManagerFeeEdited(     ISetToken indexed _setToken,     uint256 _newManagerFee,     uint256 _index );  event FeeRecipientEdited(     ISetToken indexed _setToken,     address _feeRecipient );  /* ============ Structs ============ */  struct NAVIssuanceSettings {     INAVIssuanceHook managerIssuanceHook;      // Issuance hook configurations     INAVIssuanceHook managerRedemptionHook;    // Redemption hook configurations     address[] reserveAssets;                       // Allowed reserve assets - Must have a price enabled with the price oracle     address feeRecipient;                          // Manager fee recipient     uint256[2] managerFees;                        // Manager fees. 0 index is issue and 1 index is redeem fee (0.01% = 1e14, 1% = 1e16)     uint256 maxManagerFee;                         // Maximum fee manager is allowed to set for issue and redeem     uint256 premiumPercentage;                     // Premium percentage (0.01% = 1e14, 1% = 1e16). This premium is a buffer around oracle                                                    // prices paid by user to the SetToken, which prevents arbitrage and oracle front running     uint256 maxPremiumPercentage;                  // Maximum premium percentage manager is allowed to set (configured by manager)     uint256 minSetTokenSupply;                     // Minimum SetToken supply required for issuance and redemption                                                    // to prevent dramatic inflationary changes to the SetToken's position multiplier }  struct ActionInfo {     uint256 preFeeReserveQuantity;                 // Reserve value before fees; During issuance, represents raw quantity                                                    // During redeem, represents post-premium value     uint256 protocolFees;                          // Total protocol fees (direct + manager revenue share)     uint256 managerFee;                            // Total manager fee paid in reserve asset     uint256 netFlowQuantity;                       // When issuing, quantity of reserve asset sent to SetToken                                                    // When redeeming, quantity of reserve asset sent to redeemer     uint256 setTokenQuantity;                      // When issuing, quantity of SetTokens minted to mintee                                                    // When redeeming, quantity of SetToken redeemed     uint256 previousSetTokenSupply;                // SetToken supply prior to issue/redeem action     uint256 newSetTokenSupply;                     // SetToken supply after issue/redeem action     int256 newPositionMultiplier;                  // SetToken position multiplier after issue/redeem     uint256 newReservePositionUnit;                // SetToken reserve asset position unit after issue/redeem }  /* ============ State Variables ============ */  // Wrapped ETH address IWETH public immutable weth;  // Mapping of SetToken to NAV issuance settings struct mapping(ISetToken =&gt; NAVIssuanceSettings) public navIssuanceSettings;  // Mapping to efficiently check a SetToken's reserve asset validity // SetToken =&gt; reserveAsset =&gt; isReserveAsset mapping(ISetToken =&gt; mapping(address =&gt; bool)) public isReserveAsset;  /* ============ Constants ============ */  // 0 index stores the manager fee in managerFees array, percentage charged on issue (denominated in reserve asset) uint256 constant internal MANAGER_ISSUE_FEE_INDEX = 0;  // 1 index stores the manager fee percentage in managerFees array, charged on redeem uint256 constant internal MANAGER_REDEEM_FEE_INDEX = 1;  // 0 index stores the manager revenue share protocol fee % on the controller, charged in the issuance function uint256 constant internal PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX = 0;  // 1 index stores the manager revenue share protocol fee % on the controller, charged in the redeem function uint256 constant internal PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX = 1;  // 2 index stores the direct protocol fee % on the controller, charged in the issuance function uint256 constant internal PROTOCOL_ISSUE_DIRECT_FEE_INDEX = 2;  // 3 index stores the direct protocol fee % on the controller, charged in the redeem function uint256 constant internal PROTOCOL_REDEEM_DIRECT_FEE_INDEX = 3;  /* ============ Constructor ============ */  /**  * @param _controller               Address of controller contract  * @param _weth                     Address of wrapped eth  */ constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {     weth = _weth; }  /* ============ External Functions ============ */  /**  * Deposits the allowed reserve asset into the SetToken and mints the appropriate % of Net Asset Value of the SetToken  * to the specified _to address.  *  * @param _setToken                     Instance of the SetToken contract  * @param _reserveAsset                 Address of the reserve asset to issue with  * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with  * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance  * @param _to                           Address to mint SetToken to  */ function issue(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity,     uint256 _minSetTokenReceiveQuantity,     address _to )     external     nonReentrant     onlyValidAndInitializedSet(_setToken) {     _validateCommon(_setToken, _reserveAsset, _reserveAssetQuantity);      _callPreIssueHooks(_setToken, _reserveAsset, _reserveAssetQuantity, msg.sender, _to);      ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, _reserveAsset, _reserveAssetQuantity);      _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);      _transferCollateralAndHandleFees(_setToken, IERC20(_reserveAsset), issueInfo);      _handleIssueStateUpdates(_setToken, _reserveAsset, _to, issueInfo); }  /**  * Wraps ETH and deposits WETH if allowed into the SetToken and mints the appropriate % of Net Asset Value of the SetToken  * to the specified _to address.  *  * @param _setToken                     Instance of the SetToken contract  * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance  * @param _to                           Address to mint SetToken to  */ function issueWithEther(     ISetToken _setToken,     uint256 _minSetTokenReceiveQuantity,     address _to )     external     payable     nonReentrant     onlyValidAndInitializedSet(_setToken) {     weth.deposit{ value: msg.value }();      _validateCommon(_setToken, address(weth), msg.value);      _callPreIssueHooks(_setToken, address(weth), msg.value, msg.sender, _to);      ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, address(weth), msg.value);      _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);      _transferWETHAndHandleFees(_setToken, issueInfo);      _handleIssueStateUpdates(_setToken, address(weth), _to, issueInfo); }  /**  * Redeems a SetToken into a valid reserve asset representing the appropriate % of Net Asset Value of the SetToken  * to the specified _to address. Only valid if there are available reserve units on the SetToken.  *  * @param _setToken                     Instance of the SetToken contract  * @param _reserveAsset                 Address of the reserve asset to redeem with  * @param _setTokenQuantity             Quantity of SetTokens to redeem  * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive  * @param _to                           Address to redeem reserve asset to  */ function redeem(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity,     uint256 _minReserveReceiveQuantity,     address _to )     external     nonReentrant     onlyValidAndInitializedSet(_setToken) {     _validateCommon(_setToken, _reserveAsset, _setTokenQuantity);      _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);      ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, _reserveAsset, _setTokenQuantity);      _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);      _setToken.burn(msg.sender, _setTokenQuantity);      // Instruct the SetToken to transfer the reserve asset back to the user     _setToken.strictInvokeTransfer(         _reserveAsset,         _to,         redeemInfo.netFlowQuantity     );      _handleRedemptionFees(_setToken, _reserveAsset, redeemInfo);      _handleRedeemStateUpdates(_setToken, _reserveAsset, _to, redeemInfo); }  /**  * Redeems a SetToken into Ether (if WETH is valid) representing the appropriate % of Net Asset Value of the SetToken  * to the specified _to address. Only valid if there are available WETH units on the SetToken.  *  * @param _setToken                     Instance of the SetToken contract  * @param _setTokenQuantity             Quantity of SetTokens to redeem  * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive  * @param _to                           Address to redeem reserve asset to  */ function redeemIntoEther(     ISetToken _setToken,     uint256 _setTokenQuantity,     uint256 _minReserveReceiveQuantity,     address payable _to )     external     nonReentrant     onlyValidAndInitializedSet(_setToken) {     _validateCommon(_setToken, address(weth), _setTokenQuantity);      _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);      ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, address(weth), _setTokenQuantity);      _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);      _setToken.burn(msg.sender, _setTokenQuantity);      // Instruct the SetToken to transfer WETH from SetToken to module     _setToken.strictInvokeTransfer(         address(weth),         address(this),         redeemInfo.netFlowQuantity     );      weth.withdraw(redeemInfo.netFlowQuantity);      _to.transfer(redeemInfo.netFlowQuantity);      _handleRedemptionFees(_setToken, address(weth), redeemInfo);      _handleRedeemStateUpdates(_setToken, address(weth), _to, redeemInfo); }  /**  * SET MANAGER ONLY. Add an allowed reserve asset  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset to add  */ function addReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {     require(!isReserveAsset[_setToken][_reserveAsset], "Reserve asset already exists");      navIssuanceSettings[_setToken].reserveAssets.push(_reserveAsset);     isReserveAsset[_setToken][_reserveAsset] = true;      emit ReserveAssetAdded(_setToken, _reserveAsset); }  /**  * SET MANAGER ONLY. Remove a reserve asset  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset to remove  */ function removeReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {     require(isReserveAsset[_setToken][_reserveAsset], "Reserve asset does not exist");      navIssuanceSettings[_setToken].reserveAssets = navIssuanceSettings[_setToken].reserveAssets.remove(_reserveAsset);     delete isReserveAsset[_setToken][_reserveAsset];      emit ReserveAssetRemoved(_setToken, _reserveAsset); }  /**  * SET MANAGER ONLY. Edit the premium percentage  *  * @param _setToken                     Instance of the SetToken  * @param _premiumPercentage            Premium percentage in 10e16 (e.g. 10e16 = 1%)  */ function editPremium(ISetToken _setToken, uint256 _premiumPercentage) external onlyManagerAndValidSet(_setToken) {     require(_premiumPercentage &lt;= navIssuanceSettings[_setToken].maxPremiumPercentage, "Premium must be less than maximum allowed");      navIssuanceSettings[_setToken].premiumPercentage = _premiumPercentage;      emit PremiumEdited(_setToken, _premiumPercentage); }  /**  * SET MANAGER ONLY. Edit manager fee  *  * @param _setToken                     Instance of the SetToken  * @param _managerFeePercentage         Manager fee percentage in 10e16 (e.g. 10e16 = 1%)  * @param _managerFeeIndex              Manager fee index. 0 index is issue fee, 1 index is redeem fee  */ function editManagerFee(     ISetToken _setToken,     uint256 _managerFeePercentage,     uint256 _managerFeeIndex )     external     onlyManagerAndValidSet(_setToken) {     require(_managerFeePercentage &lt;= navIssuanceSettings[_setToken].maxManagerFee, "Manager fee must be less than maximum allowed");      navIssuanceSettings[_setToken].managerFees[_managerFeeIndex] = _managerFeePercentage;      emit ManagerFeeEdited(_setToken, _managerFeePercentage, _managerFeeIndex); }  /**  * SET MANAGER ONLY. Edit the manager fee recipient  *  * @param _setToken                     Instance of the SetToken  * @param _managerFeeRecipient          Manager fee recipient  */ function editFeeRecipient(ISetToken _setToken, address _managerFeeRecipient) external onlyManagerAndValidSet(_setToken) {     require(_managerFeeRecipient != address(0), "Fee recipient must not be 0 address");      navIssuanceSettings[_setToken].feeRecipient = _managerFeeRecipient;      emit FeeRecipientEdited(_setToken, _managerFeeRecipient); }  /**  * SET MANAGER ONLY. Initializes this module to the SetToken with hooks, allowed reserve assets,  * fees and issuance premium. Only callable by the SetToken's manager. Hook addresses are optional.  * Address(0) means that no hook will be called.  *  * @param _setToken                     Instance of the SetToken to issue  * @param _navIssuanceSettings          NAVIssuanceSettings struct defining parameters  */ function initialize(     ISetToken _setToken,     NAVIssuanceSettings memory _navIssuanceSettings )     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     require(_navIssuanceSettings.reserveAssets.length &gt; 0, "Reserve assets must be greater than 0");     require(_navIssuanceSettings.maxManagerFee &lt; PreciseUnitMath.preciseUnit(), "Max manager fee must be less than 100%");     require(_navIssuanceSettings.maxPremiumPercentage &lt; PreciseUnitMath.preciseUnit(), "Max premium percentage must be less than 100%");     require(_navIssuanceSettings.managerFees[0] &lt;= _navIssuanceSettings.maxManagerFee, "Manager issue fee must be less than max");     require(_navIssuanceSettings.managerFees[1] &lt;= _navIssuanceSettings.maxManagerFee, "Manager redeem fee must be less than max");     require(_navIssuanceSettings.premiumPercentage &lt;= _navIssuanceSettings.maxPremiumPercentage, "Premium must be less than max");     require(_navIssuanceSettings.feeRecipient != address(0), "Fee Recipient must be non-zero address.");     // Initial mint of Set cannot use NAVIssuance since minSetTokenSupply must be &gt; 0     require(_navIssuanceSettings.minSetTokenSupply &gt; 0, "Min SetToken supply must be greater than 0");      for (uint256 i = 0; i &lt; _navIssuanceSettings.reserveAssets.length; i++) {         require(!isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]], "Reserve assets must be unique");         isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]] = true;     }      navIssuanceSettings[_setToken] = _navIssuanceSettings;      _setToken.initializeModule(); }  /**  * Removes this module from the SetToken, via call by the SetToken. Issuance settings and  * reserve asset states are deleted.  */ function removeModule() external override {     ISetToken setToken = ISetToken(msg.sender);     for (uint256 i = 0; i &lt; navIssuanceSettings[setToken].reserveAssets.length; i++) {         delete isReserveAsset[setToken][navIssuanceSettings[setToken].reserveAssets[i]];     }      delete navIssuanceSettings[setToken]; }  receive() external payable {}  /* ============ External Getter Functions ============ */  function getReserveAssets(ISetToken _setToken) external view returns (address[] memory) {     return navIssuanceSettings[_setToken].reserveAssets; }  function getIssuePremium(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     external     view     returns (uint256) {     return _getIssuePremium(_setToken, _reserveAsset, _reserveAssetQuantity); }  function getRedeemPremium(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     external     view     returns (uint256) {     return _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity); }  function getManagerFee(ISetToken _setToken, uint256 _managerFeeIndex) external view returns (uint256) {     return navIssuanceSettings[_setToken].managerFees[_managerFeeIndex]; }  /**  * Get the expected SetTokens minted to recipient on issuance  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with  *  * @return  uint256                     Expected SetTokens to be minted to recipient  */ function getExpectedSetTokenIssueQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     external     view     returns (uint256) {     (,, uint256 netReserveFlow) = _getFees(         _setToken,         _reserveAssetQuantity,         PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_ISSUE_DIRECT_FEE_INDEX,         MANAGER_ISSUE_FEE_INDEX     );      uint256 setTotalSupply = _setToken.totalSupply();      return _getSetTokenMintQuantity(         _setToken,         _reserveAsset,         netReserveFlow,         setTotalSupply     ); }  /**  * Get the expected reserve asset to be redeemed  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _setTokenQuantity             Quantity of SetTokens to redeem  *  * @return  uint256                     Expected reserve asset quantity redeemed  */ function getExpectedReserveRedeemQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     external     view     returns (uint256) {     uint256 preFeeReserveQuantity = _getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);      (,, uint256 netReserveFlows) = _getFees(         _setToken,         preFeeReserveQuantity,         PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_REDEEM_DIRECT_FEE_INDEX,         MANAGER_REDEEM_FEE_INDEX     );      return netReserveFlows; }  /**  * Checks if issue is valid  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with  *  * @return  bool                        Returns true if issue is valid  */ function isIssueValid(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     external     view     returns (bool) {     uint256 setTotalSupply = _setToken.totalSupply();  return _reserveAssetQuantity != 0         &amp;&amp; isReserveAsset[_setToken][_reserveAsset]         &amp;&amp; setTotalSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply; }  /**  * Checks if redeem is valid  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _setTokenQuantity             Quantity of SetTokens to redeem  *  * @return  bool                        Returns true if redeem is valid  */ function isRedeemValid(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     external     view     returns (bool) {     uint256 setTotalSupply = _setToken.totalSupply();      if (         _setTokenQuantity == 0         || !isReserveAsset[_setToken][_reserveAsset]         || setTotalSupply &lt; navIssuanceSettings[_setToken].minSetTokenSupply.add(_setTokenQuantity)     ) {         return false;     } else {         uint256 totalRedeemValue =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);          (,, uint256 expectedRedeemQuantity) = _getFees(             _setToken,             totalRedeemValue,             PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,             PROTOCOL_REDEEM_DIRECT_FEE_INDEX,             MANAGER_REDEEM_FEE_INDEX         );          uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();          return existingUnit.preciseMul(setTotalSupply) &gt;= expectedRedeemQuantity;     } }  /* ============ Internal Functions ============ */  function _validateCommon(ISetToken _setToken, address _reserveAsset, uint256 _quantity) internal view {     require(_quantity &gt; 0, "Quantity must be &gt; 0");     require(isReserveAsset[_setToken][_reserveAsset], "Must be valid reserve asset"); }  function _validateIssuanceInfo(ISetToken _setToken, uint256 _minSetTokenReceiveQuantity, ActionInfo memory _issueInfo) internal view {     // Check that total supply is greater than min supply needed for issuance     // Note: A min supply amount is needed to avoid division by 0 when SetToken supply is 0     require(         _issueInfo.previousSetTokenSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply,         "Supply must be greater than minimum to enable issuance"     );      require(_issueInfo.setTokenQuantity &gt;= _minSetTokenReceiveQuantity, "Must be greater than min SetToken"); }  function _validateRedemptionInfo(     ISetToken _setToken,     uint256 _minReserveReceiveQuantity,     ActionInfo memory _redeemInfo )     internal     view {     // Check that new supply is more than min supply needed for redemption     // Note: A min supply amount is needed to avoid division by 0 when redeeming SetToken to 0     require(         _redeemInfo.newSetTokenSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply,         "Supply must be greater than minimum to enable redemption"     );      require(_redeemInfo.netFlowQuantity &gt;= _minReserveReceiveQuantity, "Must be greater than min receive reserve quantity"); }  function _createIssuanceInfo(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     internal     view     returns (ActionInfo memory) {     ActionInfo memory issueInfo;      issueInfo.previousSetTokenSupply = _setToken.totalSupply();      issueInfo.preFeeReserveQuantity = _reserveAssetQuantity;      (issueInfo.protocolFees, issueInfo.managerFee, issueInfo.netFlowQuantity) = _getFees(         _setToken,         issueInfo.preFeeReserveQuantity,         PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_ISSUE_DIRECT_FEE_INDEX,         MANAGER_ISSUE_FEE_INDEX     );      issueInfo.setTokenQuantity = _getSetTokenMintQuantity(         _setToken,         _reserveAsset,         issueInfo.netFlowQuantity,         issueInfo.previousSetTokenSupply     );      (issueInfo.newSetTokenSupply, issueInfo.newPositionMultiplier) = _getIssuePositionMultiplier(_setToken, issueInfo);      issueInfo.newReservePositionUnit = _getIssuePositionUnit(_setToken, _reserveAsset, issueInfo);      return issueInfo; }  function _createRedemptionInfo(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     internal     view     returns (ActionInfo memory) {     ActionInfo memory redeemInfo;      redeemInfo.setTokenQuantity = _setTokenQuantity;      redeemInfo.preFeeReserveQuantity =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);      (redeemInfo.protocolFees, redeemInfo.managerFee, redeemInfo.netFlowQuantity) = _getFees(         _setToken,         redeemInfo.preFeeReserveQuantity,         PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_REDEEM_DIRECT_FEE_INDEX,         MANAGER_REDEEM_FEE_INDEX     );      redeemInfo.previousSetTokenSupply = _setToken.totalSupply();      (redeemInfo.newSetTokenSupply, redeemInfo.newPositionMultiplier) = _getRedeemPositionMultiplier(_setToken, _setTokenQuantity, redeemInfo);      redeemInfo.newReservePositionUnit = _getRedeemPositionUnit(_setToken, _reserveAsset, redeemInfo);      return redeemInfo; }  /**  * Transfer reserve asset from user to SetToken and fees from user to appropriate fee recipients  */ function _transferCollateralAndHandleFees(ISetToken _setToken, IERC20 _reserveAsset, ActionInfo memory _issueInfo) internal {     transferFrom(_reserveAsset, msg.sender, address(_setToken), _issueInfo.netFlowQuantity);      if (_issueInfo.protocolFees &gt; 0) {         transferFrom(_reserveAsset, msg.sender, controller.feeRecipient(), _issueInfo.protocolFees);     }      if (_issueInfo.managerFee &gt; 0) {         transferFrom(_reserveAsset, msg.sender, navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);     } }   /**   * Transfer WETH from module to SetToken and fees from module to appropriate fee recipients  */ function _transferWETHAndHandleFees(ISetToken _setToken, ActionInfo memory _issueInfo) internal {     weth.transfer(address(_setToken), _issueInfo.netFlowQuantity);      if (_issueInfo.protocolFees &gt; 0) {         weth.transfer(controller.feeRecipient(), _issueInfo.protocolFees);     }      if (_issueInfo.managerFee &gt; 0) {         weth.transfer(navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);     } }  function _handleIssueStateUpdates(     ISetToken _setToken,     address _reserveAsset,     address _to,     ActionInfo memory _issueInfo )     internal {     _setToken.editPositionMultiplier(_issueInfo.newPositionMultiplier);      _setToken.editDefaultPosition(_reserveAsset, _issueInfo.newReservePositionUnit);      _setToken.mint(_to, _issueInfo.setTokenQuantity);      emit SetTokenNAVIssued(         _setToken,         msg.sender,         _to,         _reserveAsset,         address(navIssuanceSettings[_setToken].managerIssuanceHook),         _issueInfo.setTokenQuantity,         _issueInfo.managerFee,         _issueInfo.protocolFees     ); }  function _handleRedeemStateUpdates(     ISetToken _setToken,     address _reserveAsset,     address _to,     ActionInfo memory _redeemInfo )     internal {     _setToken.editPositionMultiplier(_redeemInfo.newPositionMultiplier);      _setToken.editDefaultPosition(_reserveAsset, _redeemInfo.newReservePositionUnit);      emit SetTokenNAVRedeemed(         _setToken,         msg.sender,         _to,         _reserveAsset,         address(navIssuanceSettings[_setToken].managerRedemptionHook),         _redeemInfo.setTokenQuantity,         _redeemInfo.managerFee,         _redeemInfo.protocolFees     ); }  function _handleRedemptionFees(ISetToken _setToken, address _reserveAsset, ActionInfo memory _redeemInfo) internal {     // Instruct the SetToken to transfer protocol fee to fee recipient if there is a fee     payProtocolFeeFromSetToken(_setToken, _reserveAsset, _redeemInfo.protocolFees);      // Instruct the SetToken to transfer manager fee to manager fee recipient if there is a fee     if (_redeemInfo.managerFee &gt; 0) {         _setToken.strictInvokeTransfer(             _reserveAsset,             navIssuanceSettings[_setToken].feeRecipient,             _redeemInfo.managerFee         );     } }  /**  * Returns the issue premium percentage. Virtual function that can be overridden in future versions of the module  * and can contain arbitrary logic to calculate the issuance premium.  */ function _getIssuePremium(     ISetToken _setToken,     address /* _reserveAsset */,     uint256 /* _reserveAssetQuantity */ )     virtual     internal     view     returns (uint256) {     return navIssuanceSettings[_setToken].premiumPercentage; }  /**  * Returns the redeem premium percentage. Virtual function that can be overridden in future versions of the module  * and can contain arbitrary logic to calculate the redemption premium.  */ function _getRedeemPremium(     ISetToken _setToken,     address /* _reserveAsset */,     uint256 /* _setTokenQuantity */ )     virtual     internal     view     returns (uint256) {     return navIssuanceSettings[_setToken].premiumPercentage; }  /**  * Returns the fees attributed to the manager and the protocol. The fees are calculated as follows:  *  * ManagerFee = (manager fee % - % to protocol) * reserveAssetQuantity  * Protocol Fee = (% manager fee share + direct fee %) * reserveAssetQuantity  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAssetQuantity         Quantity of reserve asset to calculate fees from  * @param _protocolManagerFeeIndex      Index to pull rev share NAV Issuance fee from the Controller  * @param _protocolDirectFeeIndex       Index to pull direct NAV issuance fee from the Controller  * @param _managerFeeIndex              Index from NAVIssuanceSettings (0 = issue fee, 1 = redeem fee)  *  * @return  uint256                     Fees paid to the protocol in reserve asset  * @return  uint256                     Fees paid to the manager in reserve asset  * @return  uint256                     Net reserve to user net of fees  */ function _getFees(     ISetToken _setToken,     uint256 _reserveAssetQuantity,     uint256 _protocolManagerFeeIndex,     uint256 _protocolDirectFeeIndex,     uint256 _managerFeeIndex )     internal     view     returns (uint256, uint256, uint256) {     (uint256 protocolFeePercentage, uint256 managerFeePercentage) = _getProtocolAndManagerFeePercentages(         _setToken,         _protocolManagerFeeIndex,         _protocolDirectFeeIndex,         _managerFeeIndex     );      // Calculate total notional fees     uint256 protocolFees = protocolFeePercentage.preciseMul(_reserveAssetQuantity);     uint256 managerFee = managerFeePercentage.preciseMul(_reserveAssetQuantity);      uint256 netReserveFlow = _reserveAssetQuantity.sub(protocolFees).sub(managerFee);      return (protocolFees, managerFee, netReserveFlow); }  function _getProtocolAndManagerFeePercentages(     ISetToken _setToken,     uint256 _protocolManagerFeeIndex,     uint256 _protocolDirectFeeIndex,     uint256 _managerFeeIndex )     internal     view     returns(uint256, uint256) {     // Get protocol fee percentages     uint256 protocolDirectFeePercent = controller.getModuleFee(address(this), _protocolDirectFeeIndex);     uint256 protocolManagerShareFeePercent = controller.getModuleFee(address(this), _protocolManagerFeeIndex);     uint256 managerFeePercent = navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];      // Calculate revenue share split percentage     uint256 protocolRevenueSharePercentage = protocolManagerShareFeePercent.preciseMul(managerFeePercent);     uint256 managerRevenueSharePercentage = managerFeePercent.sub(protocolRevenueSharePercentage);     uint256 totalProtocolFeePercentage = protocolRevenueSharePercentage.add(protocolDirectFeePercent);      return (totalProtocolFeePercentage, managerRevenueSharePercentage); }  function _getSetTokenMintQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _netReserveFlows,            // Value of reserve asset net of fees     uint256 _setTotalSupply )     internal     view     returns (uint256) {     uint256 premiumPercentage = _getIssuePremium(_setToken, _reserveAsset, _netReserveFlows);     uint256 premiumValue = _netReserveFlows.preciseMul(premiumPercentage);      // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (1e18)     // Reverts if price is not found     uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);      // Get reserve asset decimals     uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();     uint256 normalizedTotalReserveQuantityNetFees = _netReserveFlows.preciseDiv(10 ** reserveAssetDecimals);     uint256 normalizedTotalReserveQuantityNetFeesAndPremium = _netReserveFlows.sub(premiumValue).preciseDiv(10 ** reserveAssetDecimals);      // Calculate SetTokens to mint to issuer     uint256 denominator = _setTotalSupply.preciseMul(setTokenValuation).add(normalizedTotalReserveQuantityNetFees).sub(normalizedTotalReserveQuantityNetFeesAndPremium);     return normalizedTotalReserveQuantityNetFeesAndPremium.preciseMul(_setTotalSupply).preciseDiv(denominator); }  function _getRedeemReserveQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     internal     view     returns (uint256) {     // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (10e18)     // Reverts if price is not found     uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);      uint256 totalRedeemValueInPreciseUnits = _setTokenQuantity.preciseMul(setTokenValuation);     // Get reserve asset decimals     uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();     uint256 prePremiumReserveQuantity = totalRedeemValueInPreciseUnits.preciseMul(10 ** reserveAssetDecimals);      uint256 premiumPercentage = _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);     uint256 premiumQuantity = prePremiumReserveQuantity.preciseMulCeil(premiumPercentage);      return prePremiumReserveQuantity.sub(premiumQuantity); }  /**  * The new position multiplier is calculated as follows:  * inflationPercentage = (newSupply - oldSupply) / newSupply  * newMultiplier = (1 - inflationPercentage) * positionMultiplier  */ function _getIssuePositionMultiplier(     ISetToken _setToken,     ActionInfo memory _issueInfo )     internal     view     returns (uint256, int256) {     // Calculate inflation and new position multiplier. Note: Round inflation up in order to round position multiplier down     uint256 newTotalSupply = _issueInfo.setTokenQuantity.add(_issueInfo.previousSetTokenSupply);     int256 newPositionMultiplier = _setToken.positionMultiplier()         .mul(_issueInfo.previousSetTokenSupply.toInt256())         .div(newTotalSupply.toInt256());      return (newTotalSupply, newPositionMultiplier); }  /**  * Calculate deflation and new position multiplier. Note: Round deflation down in order to round position multiplier down  *  * The new position multiplier is calculated as follows:  * deflationPercentage = (oldSupply - newSupply) / newSupply  * newMultiplier = (1 + deflationPercentage) * positionMultiplier  */ function _getRedeemPositionMultiplier(     ISetToken _setToken,     uint256 _setTokenQuantity,     ActionInfo memory _redeemInfo )     internal     view     returns (uint256, int256) {     uint256 newTotalSupply = _redeemInfo.previousSetTokenSupply.sub(_setTokenQuantity);     int256 newPositionMultiplier = _setToken.positionMultiplier()         .mul(_redeemInfo.previousSetTokenSupply.toInt256())         .div(newTotalSupply.toInt256());      return (newTotalSupply, newPositionMultiplier); }  /**  * The new position reserve asset unit is calculated as follows:  * totalReserve = (oldUnit * oldSetTokenSupply) + reserveQuantity  * newUnit = totalReserve / newSetTokenSupply  */ function _getIssuePositionUnit(     ISetToken _setToken,     address _reserveAsset,     ActionInfo memory _issueInfo )     internal     view     returns (uint256) {     uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();     uint256 totalReserve = existingUnit         .preciseMul(_issueInfo.previousSetTokenSupply)         .add(_issueInfo.netFlowQuantity);      return totalReserve.preciseDiv(_issueInfo.newSetTokenSupply); }  /**  * The new position reserve asset unit is calculated as follows:  * totalReserve = (oldUnit * oldSetTokenSupply) - reserveQuantityToSendOut  * newUnit = totalReserve / newSetTokenSupply  */ function _getRedeemPositionUnit(     ISetToken _setToken,     address _reserveAsset,     ActionInfo memory _redeemInfo )     internal     view     returns (uint256) {     uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();     uint256 totalExistingUnits = existingUnit.preciseMul(_redeemInfo.previousSetTokenSupply);      uint256 outflow = _redeemInfo.netFlowQuantity.add(_redeemInfo.protocolFees).add(_redeemInfo.managerFee);      // Require withdrawable quantity is greater than existing collateral     require(totalExistingUnits &gt;= outflow, "Must be greater than total available collateral");      return totalExistingUnits.sub(outflow).preciseDiv(_redeemInfo.newSetTokenSupply); }  /**  * If a pre-issue hook has been configured, call the external-protocol contract. Pre-issue hook logic  * can contain arbitrary logic including validations, external function calls, etc.  */ function _callPreIssueHooks(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity,     address _caller,     address _to )     internal {     INAVIssuanceHook preIssueHook = navIssuanceSettings[_setToken].managerIssuanceHook;     if (address(preIssueHook) != address(0)) {         preIssueHook.invokePreIssueHook(_setToken, _reserveAsset, _reserveAssetQuantity, _caller, _to);     } }  /**  * If a pre-redeem hook has been configured, call the external-protocol contract.  */ function _callPreRedeemHooks(ISetToken _setToken, uint256 _setQuantity, address _caller, address _to) internal {     INAVIssuanceHook preRedeemHook = navIssuanceSettings[_setToken].managerRedemptionHook;     if (address(preRedeemHook) != address(0)) {         preRedeemHook.invokePreRedeemHook(_setToken, _setQuantity, _caller, _to);     } }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 05:31:22 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: /*
    Copyright 2020 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";
import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";
import { SignedSafeMath } from "@openzeppelin/contracts/math/SignedSafeMath.sol";

import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";
import { IController } from "../../interfaces/IController.sol";
import { INAVIssuanceHook } from "../../interfaces/INAVIssuanceHook.sol";
import { Invoke } from "../lib/Invoke.sol";
import { ISetToken } from "../../interfaces/ISetToken.sol";
import { IWETH } from "../../interfaces/external/IWETH.sol";
import { ModuleBase } from "../lib/ModuleBase.sol";
import { Position } from "../lib/Position.sol";
import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";
import { ResourceIdentifier } from "../lib/ResourceIdentifier.sol";


/**
 * @title NavIssuanceModule
 * @author Set Protocol
 *
 * Module that enables issuance and redemption with any valid ERC20 token or ETH if allowed by the manager. Sender receives
 * a proportional amount of SetTokens on issuance or ERC20 token on redemption based on the calculated net asset value using
 * oracle prices. Manager is able to enforce a premium / discount on issuance / redemption to avoid arbitrage and front
 * running when relying on oracle prices. Managers can charge a fee (denominated in reserve asset).
 */
contract NavIssuanceModule is ModuleBase, ReentrancyGuard {
    using AddressArrayUtils for address[];
    using Invoke for ISetToken;
    using Position for ISetToken;
    using PreciseUnitMath for uint256;
    using PreciseUnitMath for int256;
    using ResourceIdentifier for IController;
    using SafeMath for uint256;
    using SafeCast for int256;
    using SafeCast for uint256;
    using SignedSafeMath for int256;

    /* ============ Events ============ */

    event SetTokenNAVIssued(
        ISetToken indexed _setToken,
        address _issuer,
        address _to,
        address _reserveAsset,
        address _hookContract,
        uint256 _setTokenQuantity,
        uint256 _managerFee,
        uint256 _premium
    );

    event SetTokenNAVRedeemed(
        ISetToken indexed _setToken,
        address _redeemer,
        address _to,
        address _reserveAsset,
        address _hookContract,
        uint256 _setTokenQuantity,
        uint256 _managerFee,
        uint256 _premium
    );

    event ReserveAssetAdded(
        ISetToken indexed _setToken,
        address _newReserveAsset
    );

    event ReserveAssetRemoved(
        ISetToken indexed _setToken,
        address _removedReserveAsset
    );

    event PremiumEdited(
        ISetToken indexed _setToken,
        uint256 _newPremium
    );

    event ManagerFeeEdited(
        ISetToken indexed _setToken,
        uint256 _newManagerFee,
        uint256 _index
    );

    event FeeRecipientEdited(
        ISetToken indexed _setToken,
        address _feeRecipient
    );

    /* ============ Structs ============ */

    struct NAVIssuanceSettings {
        INAVIssuanceHook managerIssuanceHook;      // Issuance hook configurations
        INAVIssuanceHook managerRedemptionHook;    // Redemption hook configurations
        address[] reserveAssets;                       // Allowed reserve assets - Must have a price enabled with the price oracle
        address feeRecipient;                          // Manager fee recipient
        uint256[2] managerFees;                        // Manager fees. 0 index is issue and 1 index is redeem fee (0.01% = 1e14, 1% = 1e16)
        uint256 maxManagerFee;                         // Maximum fee manager is allowed to set for issue and redeem
        uint256 premiumPercentage;                     // Premium percentage (0.01% = 1e14, 1% = 1e16). This premium is a buffer around oracle
                                                       // prices paid by user to the SetToken, which prevents arbitrage and oracle front running
        uint256 maxPremiumPercentage;                  // Maximum premium percentage manager is allowed to set (configured by manager)
        uint256 minSetTokenSupply;                     // Minimum SetToken supply required for issuance and redemption
                                                       // to prevent dramatic inflationary changes to the SetToken's position multiplier
    }

    struct ActionInfo {
        uint256 preFeeReserveQuantity;                 // Reserve value before fees; During issuance, represents raw quantity
                                                       // During redeem, represents post-premium value
        uint256 protocolFees;                          // Total protocol fees (direct + manager revenue share)
        uint256 managerFee;                            // Total manager fee paid in reserve asset
        uint256 netFlowQuantity;                       // When issuing, quantity of reserve asset sent to SetToken
                                                       // When redeeming, quantity of reserve asset sent to redeemer
        uint256 setTokenQuantity;                      // When issuing, quantity of SetTokens minted to mintee
                                                       // When redeeming, quantity of SetToken redeemed
        uint256 previousSetTokenSupply;                // SetToken supply prior to issue/redeem action
        uint256 newSetTokenSupply;                     // SetToken supply after issue/redeem action
        int256 newPositionMultiplier;                  // SetToken position multiplier after issue/redeem
        uint256 newReservePositionUnit;                // SetToken reserve asset position unit after issue/redeem
    }

    /* ============ State Variables ============ */

    // Wrapped ETH address
    IWETH public immutable weth;

    // Mapping of SetToken to NAV issuance settings struct
    mapping(ISetToken => NAVIssuanceSettings) public navIssuanceSettings;

    // Mapping to efficiently check a SetToken's reserve asset validity
    // SetToken => reserveAsset => isReserveAsset
    mapping(ISetToken => mapping(address => bool)) public isReserveAsset;

    /* ============ Constants ============ */

    // 0 index stores the manager fee in managerFees array, percentage charged on issue (denominated in reserve asset)
    uint256 constant internal MANAGER_ISSUE_FEE_INDEX = 0;

    // 1 index stores the manager fee percentage in managerFees array, charged on redeem
    uint256 constant internal MANAGER_REDEEM_FEE_INDEX = 1;

    // 0 index stores the manager revenue share protocol fee % on the controller, charged in the issuance function
    uint256 constant internal PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX = 0;

    // 1 index stores the manager revenue share protocol fee % on the controller, charged in the redeem function
    uint256 constant internal PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX = 1;

    // 2 index stores the direct protocol fee % on the controller, charged in the issuance function
    uint256 constant internal PROTOCOL_ISSUE_DIRECT_FEE_INDEX = 2;

    // 3 index stores the direct protocol fee % on the controller, charged in the redeem function
    uint256 constant internal PROTOCOL_REDEEM_DIRECT_FEE_INDEX = 3;

    /* ============ Constructor ============ */

    /**
     * @param _controller               Address of controller contract
     * @param _weth                     Address of wrapped eth
     */
    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {
        weth = _weth;
    }

    /* ============ External Functions ============ */

    /**
     * Deposits the allowed reserve asset into the SetToken and mints the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _reserveAsset                 Address of the reserve asset to issue with
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance
     * @param _to                           Address to mint SetToken to
     */
    function issue(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity,
        uint256 _minSetTokenReceiveQuantity,
        address _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, _reserveAsset, _reserveAssetQuantity);

        _callPreIssueHooks(_setToken, _reserveAsset, _reserveAssetQuantity, msg.sender, _to);

        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, _reserveAsset, _reserveAssetQuantity);

        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);

        _transferCollateralAndHandleFees(_setToken, IERC20(_reserveAsset), issueInfo);

        _handleIssueStateUpdates(_setToken, _reserveAsset, _to, issueInfo);
    }

    /**
     * Wraps ETH and deposits WETH if allowed into the SetToken and mints the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance
     * @param _to                           Address to mint SetToken to
     */
    function issueWithEther(
        ISetToken _setToken,
        uint256 _minSetTokenReceiveQuantity,
        address _to
    )
        external
        payable
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        weth.deposit{ value: msg.value }();

        _validateCommon(_setToken, address(weth), msg.value);

        _callPreIssueHooks(_setToken, address(weth), msg.value, msg.sender, _to);

        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, address(weth), msg.value);

        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);

        _transferWETHAndHandleFees(_setToken, issueInfo);

        _handleIssueStateUpdates(_setToken, address(weth), _to, issueInfo);
    }

    /**
     * Redeems a SetToken into a valid reserve asset representing the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address. Only valid if there are available reserve units on the SetToken.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _reserveAsset                 Address of the reserve asset to redeem with
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive
     * @param _to                           Address to redeem reserve asset to
     */
    function redeem(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity,
        uint256 _minReserveReceiveQuantity,
        address _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, _reserveAsset, _setTokenQuantity);

        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);

        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, _reserveAsset, _setTokenQuantity);

        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);

        _setToken.burn(msg.sender, _setTokenQuantity);

        // Instruct the SetToken to transfer the reserve asset back to the user
        _setToken.strictInvokeTransfer(
            _reserveAsset,
            _to,
            redeemInfo.netFlowQuantity
        );

        _handleRedemptionFees(_setToken, _reserveAsset, redeemInfo);

        _handleRedeemStateUpdates(_setToken, _reserveAsset, _to, redeemInfo);
    }

    /**
     * Redeems a SetToken into Ether (if WETH is valid) representing the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address. Only valid if there are available WETH units on the SetToken.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive
     * @param _to                           Address to redeem reserve asset to
     */
    function redeemIntoEther(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        uint256 _minReserveReceiveQuantity,
        address payable _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, address(weth), _setTokenQuantity);

        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);

        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, address(weth), _setTokenQuantity);

        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);

        _setToken.burn(msg.sender, _setTokenQuantity);

        // Instruct the SetToken to transfer WETH from SetToken to module
        _setToken.strictInvokeTransfer(
            address(weth),
            address(this),
            redeemInfo.netFlowQuantity
        );

        weth.withdraw(redeemInfo.netFlowQuantity);

        _to.transfer(redeemInfo.netFlowQuantity);

        _handleRedemptionFees(_setToken, address(weth), redeemInfo);

        _handleRedeemStateUpdates(_setToken, address(weth), _to, redeemInfo);
    }

    /**
     * SET MANAGER ONLY. Add an allowed reserve asset
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset to add
     */
    function addReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {
        require(!isReserveAsset[_setToken][_reserveAsset], "Reserve asset already exists");

        navIssuanceSettings[_setToken].reserveAssets.push(_reserveAsset);
        isReserveAsset[_setToken][_reserveAsset] = true;

        emit ReserveAssetAdded(_setToken, _reserveAsset);
    }

    /**
     * SET MANAGER ONLY. Remove a reserve asset
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset to remove
     */
    function removeReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {
        require(isReserveAsset[_setToken][_reserveAsset], "Reserve asset does not exist");

        navIssuanceSettings[_setToken].reserveAssets = navIssuanceSettings[_setToken].reserveAssets.remove(_reserveAsset);
        delete isReserveAsset[_setToken][_reserveAsset];

        emit ReserveAssetRemoved(_setToken, _reserveAsset);
    }

    /**
     * SET MANAGER ONLY. Edit the premium percentage
     *
     * @param _setToken                     Instance of the SetToken
     * @param _premiumPercentage            Premium percentage in 10e16 (e.g. 10e16 = 1%)
     */
    function editPremium(ISetToken _setToken, uint256 _premiumPercentage) external onlyManagerAndValidSet(_setToken) {
        require(_premiumPercentage <= navIssuanceSettings[_setToken].maxPremiumPercentage, "Premium must be less than maximum allowed");

        navIssuanceSettings[_setToken].premiumPercentage = _premiumPercentage;

        emit PremiumEdited(_setToken, _premiumPercentage);
    }

    /**
     * SET MANAGER ONLY. Edit manager fee
     *
     * @param _setToken                     Instance of the SetToken
     * @param _managerFeePercentage         Manager fee percentage in 10e16 (e.g. 10e16 = 1%)
     * @param _managerFeeIndex              Manager fee index. 0 index is issue fee, 1 index is redeem fee
     */
    function editManagerFee(
        ISetToken _setToken,
        uint256 _managerFeePercentage,
        uint256 _managerFeeIndex
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        require(_managerFeePercentage <= navIssuanceSettings[_setToken].maxManagerFee, "Manager fee must be less than maximum allowed");

        navIssuanceSettings[_setToken].managerFees[_managerFeeIndex] = _managerFeePercentage;

        emit ManagerFeeEdited(_setToken, _managerFeePercentage, _managerFeeIndex);
    }

    /**
     * SET MANAGER ONLY. Edit the manager fee recipient
     *
     * @param _setToken                     Instance of the SetToken
     * @param _managerFeeRecipient          Manager fee recipient
     */
    function editFeeRecipient(ISetToken _setToken, address _managerFeeRecipient) external onlyManagerAndValidSet(_setToken) {
        require(_managerFeeRecipient != address(0), "Fee recipient must not be 0 address");

        navIssuanceSettings[_setToken].feeRecipient = _managerFeeRecipient;

        emit FeeRecipientEdited(_setToken, _managerFeeRecipient);
    }

    /**
     * SET MANAGER ONLY. Initializes this module to the SetToken with hooks, allowed reserve assets,
     * fees and issuance premium. Only callable by the SetToken's manager. Hook addresses are optional.
     * Address(0) means that no hook will be called.
     *
     * @param _setToken                     Instance of the SetToken to issue
     * @param _navIssuanceSettings          NAVIssuanceSettings struct defining parameters
     */
    function initialize(
        ISetToken _setToken,
        NAVIssuanceSettings memory _navIssuanceSettings
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        require(_navIssuanceSettings.reserveAssets.length > 0, "Reserve assets must be greater than 0");
        require(_navIssuanceSettings.maxManagerFee < PreciseUnitMath.preciseUnit(), "Max manager fee must be less than 100%");
        require(_navIssuanceSettings.maxPremiumPercentage < PreciseUnitMath.preciseUnit(), "Max premium percentage must be less than 100%");
        require(_navIssuanceSettings.managerFees[0] <= _navIssuanceSettings.maxManagerFee, "Manager issue fee must be less than max");
        require(_navIssuanceSettings.managerFees[1] <= _navIssuanceSettings.maxManagerFee, "Manager redeem fee must be less than max");
        require(_navIssuanceSettings.premiumPercentage <= _navIssuanceSettings.maxPremiumPercentage, "Premium must be less than max");
        require(_navIssuanceSettings.feeRecipient != address(0), "Fee Recipient must be non-zero address.");
        // Initial mint of Set cannot use NAVIssuance since minSetTokenSupply must be > 0
        require(_navIssuanceSettings.minSetTokenSupply > 0, "Min SetToken supply must be greater than 0");

        for (uint256 i = 0; i < _navIssuanceSettings.reserveAssets.length; i++) {
            require(!isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]], "Reserve assets must be unique");
            isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]] = true;
        }

        navIssuanceSettings[_setToken] = _navIssuanceSettings;

        _setToken.initializeModule();
    }

    /**
     * Removes this module from the SetToken, via call by the SetToken. Issuance settings and
     * reserve asset states are deleted.
     */
    function removeModule() external override {
        ISetToken setToken = ISetToken(msg.sender);
        for (uint256 i = 0; i < navIssuanceSettings[setToken].reserveAssets.length; i++) {
            delete isReserveAsset[setToken][navIssuanceSettings[setToken].reserveAssets[i]];
        }

        delete navIssuanceSettings[setToken];
    }

    receive() external payable {}

    /* ============ External Getter Functions ============ */

    function getReserveAssets(ISetToken _setToken) external view returns (address[] memory) {
        return navIssuanceSettings[_setToken].reserveAssets;
    }

    function getIssuePremium(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (uint256)
    {
        return _getIssuePremium(_setToken, _reserveAsset, _reserveAssetQuantity);
    }

    function getRedeemPremium(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (uint256)
    {
        return _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);
    }

    function getManagerFee(ISetToken _setToken, uint256 _managerFeeIndex) external view returns (uint256) {
        return navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];
    }

    /**
     * Get the expected SetTokens minted to recipient on issuance
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     *
     * @return  uint256                     Expected SetTokens to be minted to recipient
     */
    function getExpectedSetTokenIssueQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (uint256)
    {
        (,, uint256 netReserveFlow) = _getFees(
            _setToken,
            _reserveAssetQuantity,
            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,
            MANAGER_ISSUE_FEE_INDEX
        );

        uint256 setTotalSupply = _setToken.totalSupply();

        return _getSetTokenMintQuantity(
            _setToken,
            _reserveAsset,
            netReserveFlow,
            setTotalSupply
        );
    }

    /**
     * Get the expected reserve asset to be redeemed
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     *
     * @return  uint256                     Expected reserve asset quantity redeemed
     */
    function getExpectedReserveRedeemQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (uint256)
    {
        uint256 preFeeReserveQuantity = _getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

        (,, uint256 netReserveFlows) = _getFees(
            _setToken,
            preFeeReserveQuantity,
            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
            MANAGER_REDEEM_FEE_INDEX
        );

        return netReserveFlows;
    }

    /**
     * Checks if issue is valid
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     *
     * @return  bool                        Returns true if issue is valid
     */
    function isIssueValid(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (bool)
    {
        uint256 setTotalSupply = _setToken.totalSupply();

    return _reserveAssetQuantity != 0
            && isReserveAsset[_setToken][_reserveAsset]
            && setTotalSupply >= navIssuanceSettings[_setToken].minSetTokenSupply;
    }

    /**
     * Checks if redeem is valid
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     *
     * @return  bool                        Returns true if redeem is valid
     */
    function isRedeemValid(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (bool)
    {
        uint256 setTotalSupply = _setToken.totalSupply();

        if (
            _setTokenQuantity == 0
            || !isReserveAsset[_setToken][_reserveAsset]
            || setTotalSupply < navIssuanceSettings[_setToken].minSetTokenSupply.add(_setTokenQuantity)
        ) {
            return false;
        } else {
            uint256 totalRedeemValue =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

            (,, uint256 expectedRedeemQuantity) = _getFees(
                _setToken,
                totalRedeemValue,
                PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
                PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
                MANAGER_REDEEM_FEE_INDEX
            );

            uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();

            return existingUnit.preciseMul(setTotalSupply) >= expectedRedeemQuantity;
        }
    }

    /* ============ Internal Functions ============ */

    function _validateCommon(ISetToken _setToken, address _reserveAsset, uint256 _quantity) internal view {
        require(_quantity > 0, "Quantity must be > 0");
        require(isReserveAsset[_setToken][_reserveAsset], "Must be valid reserve asset");
    }

    function _validateIssuanceInfo(ISetToken _setToken, uint256 _minSetTokenReceiveQuantity, ActionInfo memory _issueInfo) internal view {
        // Check that total supply is greater than min supply needed for issuance
        // Note: A min supply amount is needed to avoid division by 0 when SetToken supply is 0
        require(
            _issueInfo.previousSetTokenSupply >= navIssuanceSettings[_setToken].minSetTokenSupply,
            "Supply must be greater than minimum to enable issuance"
        );

        require(_issueInfo.setTokenQuantity >= _minSetTokenReceiveQuantity, "Must be greater than min SetToken");
    }

    function _validateRedemptionInfo(
        ISetToken _setToken,
        uint256 _minReserveReceiveQuantity,
        ActionInfo memory _redeemInfo
    )
        internal
        view
    {
        // Check that new supply is more than min supply needed for redemption
        // Note: A min supply amount is needed to avoid division by 0 when redeeming SetToken to 0
        require(
            _redeemInfo.newSetTokenSupply >= navIssuanceSettings[_setToken].minSetTokenSupply,
            "Supply must be greater than minimum to enable redemption"
        );

        require(_redeemInfo.netFlowQuantity >= _minReserveReceiveQuantity, "Must be greater than min receive reserve quantity");
    }

    function _createIssuanceInfo(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        internal
        view
        returns (ActionInfo memory)
    {
        ActionInfo memory issueInfo;

        issueInfo.previousSetTokenSupply = _setToken.totalSupply();

        issueInfo.preFeeReserveQuantity = _reserveAssetQuantity;

        (issueInfo.protocolFees, issueInfo.managerFee, issueInfo.netFlowQuantity) = _getFees(
            _setToken,
            issueInfo.preFeeReserveQuantity,
            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,
            MANAGER_ISSUE_FEE_INDEX
        );

        issueInfo.setTokenQuantity = _getSetTokenMintQuantity(
            _setToken,
            _reserveAsset,
            issueInfo.netFlowQuantity,
            issueInfo.previousSetTokenSupply
        );

        (issueInfo.newSetTokenSupply, issueInfo.newPositionMultiplier) = _getIssuePositionMultiplier(_setToken, issueInfo);

        issueInfo.newReservePositionUnit = _getIssuePositionUnit(_setToken, _reserveAsset, issueInfo);

        return issueInfo;
    }

    function _createRedemptionInfo(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        internal
        view
        returns (ActionInfo memory)
    {
        ActionInfo memory redeemInfo;

        redeemInfo.setTokenQuantity = _setTokenQuantity;

        redeemInfo.preFeeReserveQuantity =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

        (redeemInfo.protocolFees, redeemInfo.managerFee, redeemInfo.netFlowQuantity) = _getFees(
            _setToken,
            redeemInfo.preFeeReserveQuantity,
            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
            MANAGER_REDEEM_FEE_INDEX
        );

        redeemInfo.previousSetTokenSupply = _setToken.totalSupply();

        (redeemInfo.newSetTokenSupply, redeemInfo.newPositionMultiplier) = _getRedeemPositionMultiplier(_setToken, _setTokenQuantity, redeemInfo);

        redeemInfo.newReservePositionUnit = _getRedeemPositionUnit(_setToken, _reserveAsset, redeemInfo);

        return redeemInfo;
    }

    /**
     * Transfer reserve asset from user to SetToken and fees from user to appropriate fee recipients
     */
    function _transferCollateralAndHandleFees(ISetToken _setToken, IERC20 _reserveAsset, ActionInfo memory _issueInfo) internal {
        transferFrom(_reserveAsset, msg.sender, address(_setToken), _issueInfo.netFlowQuantity);

        if (_issueInfo.protocolFees > 0) {
            transferFrom(_reserveAsset, msg.sender, controller.feeRecipient(), _issueInfo.protocolFees);
        }

        if (_issueInfo.managerFee > 0) {
            transferFrom(_reserveAsset, msg.sender, navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);
        }
    }


    /**
      * Transfer WETH from module to SetToken and fees from module to appropriate fee recipients
     */
    function _transferWETHAndHandleFees(ISetToken _setToken, ActionInfo memory _issueInfo) internal {
        weth.transfer(address(_setToken), _issueInfo.netFlowQuantity);

        if (_issueInfo.protocolFees > 0) {
            weth.transfer(controller.feeRecipient(), _issueInfo.protocolFees);
        }

        if (_issueInfo.managerFee > 0) {
            weth.transfer(navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);
        }
    }

    function _handleIssueStateUpdates(
        ISetToken _setToken,
        address _reserveAsset,
        address _to,
        ActionInfo memory _issueInfo
    )
        internal
    {
        _setToken.editPositionMultiplier(_issueInfo.newPositionMultiplier);

        _setToken.editDefaultPosition(_reserveAsset, _issueInfo.newReservePositionUnit);

        _setToken.mint(_to, _issueInfo.setTokenQuantity);

        emit SetTokenNAVIssued(
            _setToken,
            msg.sender,
            _to,
            _reserveAsset,
            address(navIssuanceSettings[_setToken].managerIssuanceHook),
            _issueInfo.setTokenQuantity,
            _issueInfo.managerFee,
            _issueInfo.protocolFees
        );
    }

    function _handleRedeemStateUpdates(
        ISetToken _setToken,
        address _reserveAsset,
        address _to,
        ActionInfo memory _redeemInfo
    )
        internal
    {
        _setToken.editPositionMultiplier(_redeemInfo.newPositionMultiplier);

        _setToken.editDefaultPosition(_reserveAsset, _redeemInfo.newReservePositionUnit);

        emit SetTokenNAVRedeemed(
            _setToken,
            msg.sender,
            _to,
            _reserveAsset,
            address(navIssuanceSettings[_setToken].managerRedemptionHook),
            _redeemInfo.setTokenQuantity,
            _redeemInfo.managerFee,
            _redeemInfo.protocolFees
        );
    }

    function _handleRedemptionFees(ISetToken _setToken, address _reserveAsset, ActionInfo memory _redeemInfo) internal {
        // Instruct the SetToken to transfer protocol fee to fee recipient if there is a fee
        payProtocolFeeFromSetToken(_setToken, _reserveAsset, _redeemInfo.protocolFees);

        // Instruct the SetToken to transfer manager fee to manager fee recipient if there is a fee
        if (_redeemInfo.managerFee > 0) {
            _setToken.strictInvokeTransfer(
                _reserveAsset,
                navIssuanceSettings[_setToken].feeRecipient,
                _redeemInfo.managerFee
            );
        }
    }

    /**
     * Returns the issue premium percentage. Virtual function that can be overridden in future versions of the module
     * and can contain arbitrary logic to calculate the issuance premium.
     */
    function _getIssuePremium(
        ISetToken _setToken,
        address /* _reserveAsset */,
        uint256 /* _reserveAssetQuantity */
    )
        virtual
        internal
        view
        returns (uint256)
    {
        return navIssuanceSettings[_setToken].premiumPercentage;
    }

    /**
     * Returns the redeem premium percentage. Virtual function that can be overridden in future versions of the module
     * and can contain arbitrary logic to calculate the redemption premium.
     */
    function _getRedeemPremium(
        ISetToken _setToken,
        address /* _reserveAsset */,
        uint256 /* _setTokenQuantity */
    )
        virtual
        internal
        view
        returns (uint256)
    {
        return navIssuanceSettings[_setToken].premiumPercentage;
    }

    /**
     * Returns the fees attributed to the manager and the protocol. The fees are calculated as follows:
     *
     * ManagerFee = (manager fee % - % to protocol) * reserveAssetQuantity
     * Protocol Fee = (% manager fee share + direct fee %) * reserveAssetQuantity
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAssetQuantity         Quantity of reserve asset to calculate fees from
     * @param _protocolManagerFeeIndex      Index to pull rev share NAV Issuance fee from the Controller
     * @param _protocolDirectFeeIndex       Index to pull direct NAV issuance fee from the Controller
     * @param _managerFeeIndex              Index from NAVIssuanceSettings (0 = issue fee, 1 = redeem fee)
     *
     * @return  uint256                     Fees paid to the protocol in reserve asset
     * @return  uint256                     Fees paid to the manager in reserve asset
     * @return  uint256                     Net reserve to user net of fees
     */
    function _getFees(
        ISetToken _setToken,
        uint256 _reserveAssetQuantity,
        uint256 _protocolManagerFeeIndex,
        uint256 _protocolDirectFeeIndex,
        uint256 _managerFeeIndex
    )
        internal
        view
        returns (uint256, uint256, uint256)
    {
        (uint256 protocolFeePercentage, uint256 managerFeePercentage) = _getProtocolAndManagerFeePercentages(
            _setToken,
            _protocolManagerFeeIndex,
            _protocolDirectFeeIndex,
            _managerFeeIndex
        );

        // Calculate total notional fees
        uint256 protocolFees = protocolFeePercentage.preciseMul(_reserveAssetQuantity);
        uint256 managerFee = managerFeePercentage.preciseMul(_reserveAssetQuantity);

        uint256 netReserveFlow = _reserveAssetQuantity.sub(protocolFees).sub(managerFee);

        return (protocolFees, managerFee, netReserveFlow);
    }

    function _getProtocolAndManagerFeePercentages(
        ISetToken _setToken,
        uint256 _protocolManagerFeeIndex,
        uint256 _protocolDirectFeeIndex,
        uint256 _managerFeeIndex
    )
        internal
        view
        returns(uint256, uint256)
    {
        // Get protocol fee percentages
        uint256 protocolDirectFeePercent = controller.getModuleFee(address(this), _protocolDirectFeeIndex);
        uint256 protocolManagerShareFeePercent = controller.getModuleFee(address(this), _protocolManagerFeeIndex);
        uint256 managerFeePercent = navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];

        // Calculate revenue share split percentage
        uint256 protocolRevenueSharePercentage = protocolManagerShareFeePercent.preciseMul(managerFeePercent);
        uint256 managerRevenueSharePercentage = managerFeePercent.sub(protocolRevenueSharePercentage);
        uint256 totalProtocolFeePercentage = protocolRevenueSharePercentage.add(protocolDirectFeePercent);

        return (totalProtocolFeePercentage, managerRevenueSharePercentage);
    }

    function _getSetTokenMintQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _netReserveFlows,            // Value of reserve asset net of fees
        uint256 _setTotalSupply
    )
        internal
        view
        returns (uint256)
    {
        uint256 premiumPercentage = _getIssuePremium(_setToken, _reserveAsset, _netReserveFlows);
        uint256 premiumValue = _netReserveFlows.preciseMul(premiumPercentage);

        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (1e18)
        // Reverts if price is not found
        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);

        // Get reserve asset decimals
        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();
        uint256 normalizedTotalReserveQuantityNetFees = _netReserveFlows.preciseDiv(10 ** reserveAssetDecimals);
        uint256 normalizedTotalReserveQuantityNetFeesAndPremium = _netReserveFlows.sub(premiumValue).preciseDiv(10 ** reserveAssetDecimals);

        // Calculate SetTokens to mint to issuer
        uint256 denominator = _setTotalSupply.preciseMul(setTokenValuation).add(normalizedTotalReserveQuantityNetFees).sub(normalizedTotalReserveQuantityNetFeesAndPremium);
        return normalizedTotalReserveQuantityNetFeesAndPremium.preciseMul(_setTotalSupply).preciseDiv(denominator);
    }

    function _getRedeemReserveQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        internal
        view
        returns (uint256)
    {
        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (10e18)
        // Reverts if price is not found
        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);

        uint256 totalRedeemValueInPreciseUnits = _setTokenQuantity.preciseMul(setTokenValuation);
        // Get reserve asset decimals
        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();
        uint256 prePremiumReserveQuantity = totalRedeemValueInPreciseUnits.preciseMul(10 ** reserveAssetDecimals);

        uint256 premiumPercentage = _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);
        uint256 premiumQuantity = prePremiumReserveQuantity.preciseMulCeil(premiumPercentage);

        return prePremiumReserveQuantity.sub(premiumQuantity);
    }

    /**
     * The new position multiplier is calculated as follows:
     * inflationPercentage = (newSupply - oldSupply) / newSupply
     * newMultiplier = (1 - inflationPercentage) * positionMultiplier
     */
    function _getIssuePositionMultiplier(
        ISetToken _setToken,
        ActionInfo memory _issueInfo
    )
        internal
        view
        returns (uint256, int256)
    {
        // Calculate inflation and new position multiplier. Note: Round inflation up in order to round position multiplier down
        uint256 newTotalSupply = _issueInfo.setTokenQuantity.add(_issueInfo.previousSetTokenSupply);
        int256 newPositionMultiplier = _setToken.positionMultiplier()
            .mul(_issueInfo.previousSetTokenSupply.toInt256())
            .div(newTotalSupply.toInt256());

        return (newTotalSupply, newPositionMultiplier);
    }

    /**
     * Calculate deflation and new position multiplier. Note: Round deflation down in order to round position multiplier down
     *
     * The new position multiplier is calculated as follows:
     * deflationPercentage = (oldSupply - newSupply) / newSupply
     * newMultiplier = (1 + deflationPercentage) * positionMultiplier
     */
    function _getRedeemPositionMultiplier(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        ActionInfo memory _redeemInfo
    )
        internal
        view
        returns (uint256, int256)
    {
        uint256 newTotalSupply = _redeemInfo.previousSetTokenSupply.sub(_setTokenQuantity);
        int256 newPositionMultiplier = _setToken.positionMultiplier()
            .mul(_redeemInfo.previousSetTokenSupply.toInt256())
            .div(newTotalSupply.toInt256());

        return (newTotalSupply, newPositionMultiplier);
    }

    /**
     * The new position reserve asset unit is calculated as follows:
     * totalReserve = (oldUnit * oldSetTokenSupply) + reserveQuantity
     * newUnit = totalReserve / newSetTokenSupply
     */
    function _getIssuePositionUnit(
        ISetToken _setToken,
        address _reserveAsset,
        ActionInfo memory _issueInfo
    )
        internal
        view
        returns (uint256)
    {
        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();
        uint256 totalReserve = existingUnit
            .preciseMul(_issueInfo.previousSetTokenSupply)
            .add(_issueInfo.netFlowQuantity);

        return totalReserve.preciseDiv(_issueInfo.newSetTokenSupply);
    }

    /**
     * The new position reserve asset unit is calculated as follows:
     * totalReserve = (oldUnit * oldSetTokenSupply) - reserveQuantityToSendOut
     * newUnit = totalReserve / newSetTokenSupply
     */
    function _getRedeemPositionUnit(
        ISetToken _setToken,
        address _reserveAsset,
        ActionInfo memory _redeemInfo
    )
        internal
        view
        returns (uint256)
    {
        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();
        uint256 totalExistingUnits = existingUnit.preciseMul(_redeemInfo.previousSetTokenSupply);

        uint256 outflow = _redeemInfo.netFlowQuantity.add(_redeemInfo.protocolFees).add(_redeemInfo.managerFee);

        // Require withdrawable quantity is greater than existing collateral
        require(totalExistingUnits >= outflow, "Must be greater than total available collateral");

        return totalExistingUnits.sub(outflow).preciseDiv(_redeemInfo.newSetTokenSupply);
    }

    /**
     * If a pre-issue hook has been configured, call the external-protocol contract. Pre-issue hook logic
     * can contain arbitrary logic including validations, external function calls, etc.
     */
    function _callPreIssueHooks(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity,
        address _caller,
        address _to
    )
        internal
    {
        INAVIssuanceHook preIssueHook = navIssuanceSettings[_setToken].managerIssuanceHook;
        if (address(preIssueHook) != address(0)) {
            preIssueHook.invokePreIssueHook(_setToken, _reserveAsset, _reserveAssetQuantity, _caller, _to);
        }
    }

    /**
     * If a pre-redeem hook has been configured, call the external-protocol contract.
     */
    function _callPreRedeemHooks(ISetToken _setToken, uint256 _setQuantity, address _caller, address _to) internal {
        INAVIssuanceHook preRedeemHook = navIssuanceSettings[_setToken].managerRedemptionHook;
        if (address(preRedeemHook) != address(0)) {
            preRedeemHook.invokePreRedeemHook(_setToken, _setQuantity, _caller, _to);
        }
    }
}.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-01-09 05:31:32 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 05:31:32 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 10010
completion_tokens: 817
total_tokens: 10827
cost: $-1.000000


[2024-01-09 05:31:32 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: /*
    Copyright 2020 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";
import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";
import { SignedSafeMath } from "@openzeppelin/contracts/math/SignedSafeMath.sol";

import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";
import { IController } from "../../interfaces/IController.sol";
import { INAVIssuanceHook } from "../../interfaces/INAVIssuanceHook.sol";
import { Invoke } from "../lib/Invoke.sol";
import { ISetToken } from "../../interfaces/ISetToken.sol";
import { IWETH } from "../../interfaces/external/IWETH.sol";
import { ModuleBase } from "../lib/ModuleBase.sol";
import { Position } from "../lib/Position.sol";
import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";
import { ResourceIdentifier } from "../lib/ResourceIdentifier.sol";


/**
 * @title NavIssuanceModule
 * @author Set Protocol
 *
 * Module that enables issuance and redemption with any valid ERC20 token or ETH if allowed by the manager. Sender receives
 * a proportional amount of SetTokens on issuance or ERC20 token on redemption based on the calculated net asset value using
 * oracle prices. Manager is able to enforce a premium / discount on issuance / redemption to avoid arbitrage and front
 * running when relying on oracle prices. Managers can charge a fee (denominated in reserve asset).
 */
contract NavIssuanceModule is ModuleBase, ReentrancyGuard {
    using AddressArrayUtils for address[];
    using Invoke for ISetToken;
    using Position for ISetToken;
    using PreciseUnitMath for uint256;
    using PreciseUnitMath for int256;
    using ResourceIdentifier for IController;
    using SafeMath for uint256;
    using SafeCast for int256;
    using SafeCast for uint256;
    using SignedSafeMath for int256;

    /* ============ Events ============ */

    event SetTokenNAVIssued(
        ISetToken indexed _setToken,
        address _issuer,
        address _to,
        address _reserveAsset,
        address _hookContract,
        uint256 _setTokenQuantity,
        uint256 _managerFee,
        uint256 _premium
    );

    event SetTokenNAVRedeemed(
        ISetToken indexed _setToken,
        address _redeemer,
        address _to,
        address _reserveAsset,
        address _hookContract,
        uint256 _setTokenQuantity,
        uint256 _managerFee,
        uint256 _premium
    );

    event ReserveAssetAdded(
        ISetToken indexed _setToken,
        address _newReserveAsset
    );

    event ReserveAssetRemoved(
        ISetToken indexed _setToken,
        address _removedReserveAsset
    );

    event PremiumEdited(
        ISetToken indexed _setToken,
        uint256 _newPremium
    );

    event ManagerFeeEdited(
        ISetToken indexed _setToken,
        uint256 _newManagerFee,
        uint256 _index
    );

    event FeeRecipientEdited(
        ISetToken indexed _setToken,
        address _feeRecipient
    );

    /* ============ Structs ============ */

    struct NAVIssuanceSettings {
        INAVIssuanceHook managerIssuanceHook;      // Issuance hook configurations
        INAVIssuanceHook managerRedemptionHook;    // Redemption hook configurations
        address[] reserveAssets;                       // Allowed reserve assets - Must have a price enabled with the price oracle
        address feeRecipient;                          // Manager fee recipient
        uint256[2] managerFees;                        // Manager fees. 0 index is issue and 1 index is redeem fee (0.01% = 1e14, 1% = 1e16)
        uint256 maxManagerFee;                         // Maximum fee manager is allowed to set for issue and redeem
        uint256 premiumPercentage;                     // Premium percentage (0.01% = 1e14, 1% = 1e16). This premium is a buffer around oracle
                                                       // prices paid by user to the SetToken, which prevents arbitrage and oracle front running
        uint256 maxPremiumPercentage;                  // Maximum premium percentage manager is allowed to set (configured by manager)
        uint256 minSetTokenSupply;                     // Minimum SetToken supply required for issuance and redemption
                                                       // to prevent dramatic inflationary changes to the SetToken's position multiplier
    }

    struct ActionInfo {
        uint256 preFeeReserveQuantity;                 // Reserve value before fees; During issuance, represents raw quantity
                                                       // During redeem, represents post-premium value
        uint256 protocolFees;                          // Total protocol fees (direct + manager revenue share)
        uint256 managerFee;                            // Total manager fee paid in reserve asset
        uint256 netFlowQuantity;                       // When issuing, quantity of reserve asset sent to SetToken
                                                       // When redeeming, quantity of reserve asset sent to redeemer
        uint256 setTokenQuantity;                      // When issuing, quantity of SetTokens minted to mintee
                                                       // When redeeming, quantity of SetToken redeemed
        uint256 previousSetTokenSupply;                // SetToken supply prior to issue/redeem action
        uint256 newSetTokenSupply;                     // SetToken supply after issue/redeem action
        int256 newPositionMultiplier;                  // SetToken position multiplier after issue/redeem
        uint256 newReservePositionUnit;                // SetToken reserve asset position unit after issue/redeem
    }

    /* ============ State Variables ============ */

    // Wrapped ETH address
    IWETH public immutable weth;

    // Mapping of SetToken to NAV issuance settings struct
    mapping(ISetToken => NAVIssuanceSettings) public navIssuanceSettings;

    // Mapping to efficiently check a SetToken's reserve asset validity
    // SetToken => reserveAsset => isReserveAsset
    mapping(ISetToken => mapping(address => bool)) public isReserveAsset;

    /* ============ Constants ============ */

    // 0 index stores the manager fee in managerFees array, percentage charged on issue (denominated in reserve asset)
    uint256 constant internal MANAGER_ISSUE_FEE_INDEX = 0;

    // 1 index stores the manager fee percentage in managerFees array, charged on redeem
    uint256 constant internal MANAGER_REDEEM_FEE_INDEX = 1;

    // 0 index stores the manager revenue share protocol fee % on the controller, charged in the issuance function
    uint256 constant internal PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX = 0;

    // 1 index stores the manager revenue share protocol fee % on the controller, charged in the redeem function
    uint256 constant internal PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX = 1;

    // 2 index stores the direct protocol fee % on the controller, charged in the issuance function
    uint256 constant internal PROTOCOL_ISSUE_DIRECT_FEE_INDEX = 2;

    // 3 index stores the direct protocol fee % on the controller, charged in the redeem function
    uint256 constant internal PROTOCOL_REDEEM_DIRECT_FEE_INDEX = 3;

    /* ============ Constructor ============ */

    /**
     * @param _controller               Address of controller contract
     * @param _weth                     Address of wrapped eth
     */
    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {
        weth = _weth;
    }

    /* ============ External Functions ============ */

    /**
     * Deposits the allowed reserve asset into the SetToken and mints the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _reserveAsset                 Address of the reserve asset to issue with
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance
     * @param _to                           Address to mint SetToken to
     */
    function issue(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity,
        uint256 _minSetTokenReceiveQuantity,
        address _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, _reserveAsset, _reserveAssetQuantity);

        _callPreIssueHooks(_setToken, _reserveAsset, _reserveAssetQuantity, msg.sender, _to);

        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, _reserveAsset, _reserveAssetQuantity);

        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);

        _transferCollateralAndHandleFees(_setToken, IERC20(_reserveAsset), issueInfo);

        _handleIssueStateUpdates(_setToken, _reserveAsset, _to, issueInfo);
    }

    /**
     * Wraps ETH and deposits WETH if allowed into the SetToken and mints the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance
     * @param _to                           Address to mint SetToken to
     */
    function issueWithEther(
        ISetToken _setToken,
        uint256 _minSetTokenReceiveQuantity,
        address _to
    )
        external
        payable
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        weth.deposit{ value: msg.value }();

        _validateCommon(_setToken, address(weth), msg.value);

        _callPreIssueHooks(_setToken, address(weth), msg.value, msg.sender, _to);

        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, address(weth), msg.value);

        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);

        _transferWETHAndHandleFees(_setToken, issueInfo);

        _handleIssueStateUpdates(_setToken, address(weth), _to, issueInfo);
    }

    /**
     * Redeems a SetToken into a valid reserve asset representing the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address. Only valid if there are available reserve units on the SetToken.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _reserveAsset                 Address of the reserve asset to redeem with
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive
     * @param _to                           Address to redeem reserve asset to
     */
    function redeem(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity,
        uint256 _minReserveReceiveQuantity,
        address _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, _reserveAsset, _setTokenQuantity);

        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);

        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, _reserveAsset, _setTokenQuantity);

        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);

        _setToken.burn(msg.sender, _setTokenQuantity);

        // Instruct the SetToken to transfer the reserve asset back to the user
        _setToken.strictInvokeTransfer(
            _reserveAsset,
            _to,
            redeemInfo.netFlowQuantity
        );

        _handleRedemptionFees(_setToken, _reserveAsset, redeemInfo);

        _handleRedeemStateUpdates(_setToken, _reserveAsset, _to, redeemInfo);
    }

    /**
     * Redeems a SetToken into Ether (if WETH is valid) representing the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address. Only valid if there are available WETH units on the SetToken.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive
     * @param _to                           Address to redeem reserve asset to
     */
    function redeemIntoEther(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        uint256 _minReserveReceiveQuantity,
        address payable _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, address(weth), _setTokenQuantity);

        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);

        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, address(weth), _setTokenQuantity);

        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);

        _setToken.burn(msg.sender, _setTokenQuantity);

        // Instruct the SetToken to transfer WETH from SetToken to module
        _setToken.strictInvokeTransfer(
            address(weth),
            address(this),
            redeemInfo.netFlowQuantity
        );

        weth.withdraw(redeemInfo.netFlowQuantity);

        _to.transfer(redeemInfo.netFlowQuantity);

        _handleRedemptionFees(_setToken, address(weth), redeemInfo);

        _handleRedeemStateUpdates(_setToken, address(weth), _to, redeemInfo);
    }

    /**
     * SET MANAGER ONLY. Add an allowed reserve asset
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset to add
     */
    function addReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {
        require(!isReserveAsset[_setToken][_reserveAsset], "Reserve asset already exists");

        navIssuanceSettings[_setToken].reserveAssets.push(_reserveAsset);
        isReserveAsset[_setToken][_reserveAsset] = true;

        emit ReserveAssetAdded(_setToken, _reserveAsset);
    }

    /**
     * SET MANAGER ONLY. Remove a reserve asset
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset to remove
     */
    function removeReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {
        require(isReserveAsset[_setToken][_reserveAsset], "Reserve asset does not exist");

        navIssuanceSettings[_setToken].reserveAssets = navIssuanceSettings[_setToken].reserveAssets.remove(_reserveAsset);
        delete isReserveAsset[_setToken][_reserveAsset];

        emit ReserveAssetRemoved(_setToken, _reserveAsset);
    }

    /**
     * SET MANAGER ONLY. Edit the premium percentage
     *
     * @param _setToken                     Instance of the SetToken
     * @param _premiumPercentage            Premium percentage in 10e16 (e.g. 10e16 = 1%)
     */
    function editPremium(ISetToken _setToken, uint256 _premiumPercentage) external onlyManagerAndValidSet(_setToken) {
        require(_premiumPercentage <= navIssuanceSettings[_setToken].maxPremiumPercentage, "Premium must be less than maximum allowed");

        navIssuanceSettings[_setToken].premiumPercentage = _premiumPercentage;

        emit PremiumEdited(_setToken, _premiumPercentage);
    }

    /**
     * SET MANAGER ONLY. Edit manager fee
     *
     * @param _setToken                     Instance of the SetToken
     * @param _managerFeePercentage         Manager fee percentage in 10e16 (e.g. 10e16 = 1%)
     * @param _managerFeeIndex              Manager fee index. 0 index is issue fee, 1 index is redeem fee
     */
    function editManagerFee(
        ISetToken _setToken,
        uint256 _managerFeePercentage,
        uint256 _managerFeeIndex
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        require(_managerFeePercentage <= navIssuanceSettings[_setToken].maxManagerFee, "Manager fee must be less than maximum allowed");

        navIssuanceSettings[_setToken].managerFees[_managerFeeIndex] = _managerFeePercentage;

        emit ManagerFeeEdited(_setToken, _managerFeePercentage, _managerFeeIndex);
    }

    /**
     * SET MANAGER ONLY. Edit the manager fee recipient
     *
     * @param _setToken                     Instance of the SetToken
     * @param _managerFeeRecipient          Manager fee recipient
     */
    function editFeeRecipient(ISetToken _setToken, address _managerFeeRecipient) external onlyManagerAndValidSet(_setToken) {
        require(_managerFeeRecipient != address(0), "Fee recipient must not be 0 address");

        navIssuanceSettings[_setToken].feeRecipient = _managerFeeRecipient;

        emit FeeRecipientEdited(_setToken, _managerFeeRecipient);
    }

    /**
     * SET MANAGER ONLY. Initializes this module to the SetToken with hooks, allowed reserve assets,
     * fees and issuance premium. Only callable by the SetToken's manager. Hook addresses are optional.
     * Address(0) means that no hook will be called.
     *
     * @param _setToken                     Instance of the SetToken to issue
     * @param _navIssuanceSettings          NAVIssuanceSettings struct defining parameters
     */
    function initialize(
        ISetToken _setToken,
        NAVIssuanceSettings memory _navIssuanceSettings
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        require(_navIssuanceSettings.reserveAssets.length > 0, "Reserve assets must be greater than 0");
        require(_navIssuanceSettings.maxManagerFee < PreciseUnitMath.preciseUnit(), "Max manager fee must be less than 100%");
        require(_navIssuanceSettings.maxPremiumPercentage < PreciseUnitMath.preciseUnit(), "Max premium percentage must be less than 100%");
        require(_navIssuanceSettings.managerFees[0] <= _navIssuanceSettings.maxManagerFee, "Manager issue fee must be less than max");
        require(_navIssuanceSettings.managerFees[1] <= _navIssuanceSettings.maxManagerFee, "Manager redeem fee must be less than max");
        require(_navIssuanceSettings.premiumPercentage <= _navIssuanceSettings.maxPremiumPercentage, "Premium must be less than max");
        require(_navIssuanceSettings.feeRecipient != address(0), "Fee Recipient must be non-zero address.");
        // Initial mint of Set cannot use NAVIssuance since minSetTokenSupply must be > 0
        require(_navIssuanceSettings.minSetTokenSupply > 0, "Min SetToken supply must be greater than 0");

        for (uint256 i = 0; i < _navIssuanceSettings.reserveAssets.length; i++) {
            require(!isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]], "Reserve assets must be unique");
            isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]] = true;
        }

        navIssuanceSettings[_setToken] = _navIssuanceSettings;

        _setToken.initializeModule();
    }

    /**
     * Removes this module from the SetToken, via call by the SetToken. Issuance settings and
     * reserve asset states are deleted.
     */
    function removeModule() external override {
        ISetToken setToken = ISetToken(msg.sender);
        for (uint256 i = 0; i < navIssuanceSettings[setToken].reserveAssets.length; i++) {
            delete isReserveAsset[setToken][navIssuanceSettings[setToken].reserveAssets[i]];
        }

        delete navIssuanceSettings[setToken];
    }

    receive() external payable {}

    /* ============ External Getter Functions ============ */

    function getReserveAssets(ISetToken _setToken) external view returns (address[] memory) {
        return navIssuanceSettings[_setToken].reserveAssets;
    }

    function getIssuePremium(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (uint256)
    {
        return _getIssuePremium(_setToken, _reserveAsset, _reserveAssetQuantity);
    }

    function getRedeemPremium(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (uint256)
    {
        return _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);
    }

    function getManagerFee(ISetToken _setToken, uint256 _managerFeeIndex) external view returns (uint256) {
        return navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];
    }

    /**
     * Get the expected SetTokens minted to recipient on issuance
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     *
     * @return  uint256                     Expected SetTokens to be minted to recipient
     */
    function getExpectedSetTokenIssueQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (uint256)
    {
        (,, uint256 netReserveFlow) = _getFees(
            _setToken,
            _reserveAssetQuantity,
            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,
            MANAGER_ISSUE_FEE_INDEX
        );

        uint256 setTotalSupply = _setToken.totalSupply();

        return _getSetTokenMintQuantity(
            _setToken,
            _reserveAsset,
            netReserveFlow,
            setTotalSupply
        );
    }

    /**
     * Get the expected reserve asset to be redeemed
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     *
     * @return  uint256                     Expected reserve asset quantity redeemed
     */
    function getExpectedReserveRedeemQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (uint256)
    {
        uint256 preFeeReserveQuantity = _getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

        (,, uint256 netReserveFlows) = _getFees(
            _setToken,
            preFeeReserveQuantity,
            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
            MANAGER_REDEEM_FEE_INDEX
        );

        return netReserveFlows;
    }

    /**
     * Checks if issue is valid
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     *
     * @return  bool                        Returns true if issue is valid
     */
    function isIssueValid(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (bool)
    {
        uint256 setTotalSupply = _setToken.totalSupply();

    return _reserveAssetQuantity != 0
            && isReserveAsset[_setToken][_reserveAsset]
            && setTotalSupply >= navIssuanceSettings[_setToken].minSetTokenSupply;
    }

    /**
     * Checks if redeem is valid
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     *
     * @return  bool                        Returns true if redeem is valid
     */
    function isRedeemValid(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (bool)
    {
        uint256 setTotalSupply = _setToken.totalSupply();

        if (
            _setTokenQuantity == 0
            || !isReserveAsset[_setToken][_reserveAsset]
            || setTotalSupply < navIssuanceSettings[_setToken].minSetTokenSupply.add(_setTokenQuantity)
        ) {
            return false;
        } else {
            uint256 totalRedeemValue =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

            (,, uint256 expectedRedeemQuantity) = _getFees(
                _setToken,
                totalRedeemValue,
                PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
                PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
                MANAGER_REDEEM_FEE_INDEX
            );

            uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();

            return existingUnit.preciseMul(setTotalSupply) >= expectedRedeemQuantity;
        }
    }

    /* ============ Internal Functions ============ */

    function _validateCommon(ISetToken _setToken, address _reserveAsset, uint256 _quantity) internal view {
        require(_quantity > 0, "Quantity must be > 0");
        require(isReserveAsset[_setToken][_reserveAsset], "Must be valid reserve asset");
    }

    function _validateIssuanceInfo(ISetToken _setToken, uint256 _minSetTokenReceiveQuantity, ActionInfo memory _issueInfo) internal view {
        // Check that total supply is greater than min supply needed for issuance
        // Note: A min supply amount is needed to avoid division by 0 when SetToken supply is 0
        require(
            _issueInfo.previousSetTokenSupply >= navIssuanceSettings[_setToken].minSetTokenSupply,
            "Supply must be greater than minimum to enable issuance"
        );

        require(_issueInfo.setTokenQuantity >= _minSetTokenReceiveQuantity, "Must be greater than min SetToken");
    }

    function _validateRedemptionInfo(
        ISetToken _setToken,
        uint256 _minReserveReceiveQuantity,
        ActionInfo memory _redeemInfo
    )
        internal
        view
    {
        // Check that new supply is more than min supply needed for redemption
        // Note: A min supply amount is needed to avoid division by 0 when redeeming SetToken to 0
        require(
            _redeemInfo.newSetTokenSupply >= navIssuanceSettings[_setToken].minSetTokenSupply,
            "Supply must be greater than minimum to enable redemption"
        );

        require(_redeemInfo.netFlowQuantity >= _minReserveReceiveQuantity, "Must be greater than min receive reserve quantity");
    }

    function _createIssuanceInfo(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        internal
        view
        returns (ActionInfo memory)
    {
        ActionInfo memory issueInfo;

        issueInfo.previousSetTokenSupply = _setToken.totalSupply();

        issueInfo.preFeeReserveQuantity = _reserveAssetQuantity;

        (issueInfo.protocolFees, issueInfo.managerFee, issueInfo.netFlowQuantity) = _getFees(
            _setToken,
            issueInfo.preFeeReserveQuantity,
            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,
            MANAGER_ISSUE_FEE_INDEX
        );

        issueInfo.setTokenQuantity = _getSetTokenMintQuantity(
            _setToken,
            _reserveAsset,
            issueInfo.netFlowQuantity,
            issueInfo.previousSetTokenSupply
        );

        (issueInfo.newSetTokenSupply, issueInfo.newPositionMultiplier) = _getIssuePositionMultiplier(_setToken, issueInfo);

        issueInfo.newReservePositionUnit = _getIssuePositionUnit(_setToken, _reserveAsset, issueInfo);

        return issueInfo;
    }

    function _createRedemptionInfo(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        internal
        view
        returns (ActionInfo memory)
    {
        ActionInfo memory redeemInfo;

        redeemInfo.setTokenQuantity = _setTokenQuantity;

        redeemInfo.preFeeReserveQuantity =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

        (redeemInfo.protocolFees, redeemInfo.managerFee, redeemInfo.netFlowQuantity) = _getFees(
            _setToken,
            redeemInfo.preFeeReserveQuantity,
            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
            MANAGER_REDEEM_FEE_INDEX
        );

        redeemInfo.previousSetTokenSupply = _setToken.totalSupply();

        (redeemInfo.newSetTokenSupply, redeemInfo.newPositionMultiplier) = _getRedeemPositionMultiplier(_setToken, _setTokenQuantity, redeemInfo);

        redeemInfo.newReservePositionUnit = _getRedeemPositionUnit(_setToken, _reserveAsset, redeemInfo);

        return redeemInfo;
    }

    /**
     * Transfer reserve asset from user to SetToken and fees from user to appropriate fee recipients
     */
    function _transferCollateralAndHandleFees(ISetToken _setToken, IERC20 _reserveAsset, ActionInfo memory _issueInfo) internal {
        transferFrom(_reserveAsset, msg.sender, address(_setToken), _issueInfo.netFlowQuantity);

        if (_issueInfo.protocolFees > 0) {
            transferFrom(_reserveAsset, msg.sender, controller.feeRecipient(), _issueInfo.protocolFees);
        }

        if (_issueInfo.managerFee > 0) {
            transferFrom(_reserveAsset, msg.sender, navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);
        }
    }


    /**
      * Transfer WETH from module to SetToken and fees from module to appropriate fee recipients
     */
    function _transferWETHAndHandleFees(ISetToken _setToken, ActionInfo memory _issueInfo) internal {
        weth.transfer(address(_setToken), _issueInfo.netFlowQuantity);

        if (_issueInfo.protocolFees > 0) {
            weth.transfer(controller.feeRecipient(), _issueInfo.protocolFees);
        }

        if (_issueInfo.managerFee > 0) {
            weth.transfer(navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);
        }
    }

    function _handleIssueStateUpdates(
        ISetToken _setToken,
        address _reserveAsset,
        address _to,
        ActionInfo memory _issueInfo
    )
        internal
    {
        _setToken.editPositionMultiplier(_issueInfo.newPositionMultiplier);

        _setToken.editDefaultPosition(_reserveAsset, _issueInfo.newReservePositionUnit);

        _setToken.mint(_to, _issueInfo.setTokenQuantity);

        emit SetTokenNAVIssued(
            _setToken,
            msg.sender,
            _to,
            _reserveAsset,
            address(navIssuanceSettings[_setToken].managerIssuanceHook),
            _issueInfo.setTokenQuantity,
            _issueInfo.managerFee,
            _issueInfo.protocolFees
        );
    }

    function _handleRedeemStateUpdates(
        ISetToken _setToken,
        address _reserveAsset,
        address _to,
        ActionInfo memory _redeemInfo
    )
        internal
    {
        _setToken.editPositionMultiplier(_redeemInfo.newPositionMultiplier);

        _setToken.editDefaultPosition(_reserveAsset, _redeemInfo.newReservePositionUnit);

        emit SetTokenNAVRedeemed(
            _setToken,
            msg.sender,
            _to,
            _reserveAsset,
            address(navIssuanceSettings[_setToken].managerRedemptionHook),
            _redeemInfo.setTokenQuantity,
            _redeemInfo.managerFee,
            _redeemInfo.protocolFees
        );
    }

    function _handleRedemptionFees(ISetToken _setToken, address _reserveAsset, ActionInfo memory _redeemInfo) internal {
        // Instruct the SetToken to transfer protocol fee to fee recipient if there is a fee
        payProtocolFeeFromSetToken(_setToken, _reserveAsset, _redeemInfo.protocolFees);

        // Instruct the SetToken to transfer manager fee to manager fee recipient if there is a fee
        if (_redeemInfo.managerFee > 0) {
            _setToken.strictInvokeTransfer(
                _reserveAsset,
                navIssuanceSettings[_setToken].feeRecipient,
                _redeemInfo.managerFee
            );
        }
    }

    /**
     * Returns the issue premium percentage. Virtual function that can be overridden in future versions of the module
     * and can contain arbitrary logic to calculate the issuance premium.
     */
    function _getIssuePremium(
        ISetToken _setToken,
        address /* _reserveAsset */,
        uint256 /* _reserveAssetQuantity */
    )
        virtual
        internal
        view
        returns (uint256)
    {
        return navIssuanceSettings[_setToken].premiumPercentage;
    }

    /**
     * Returns the redeem premium percentage. Virtual function that can be overridden in future versions of the module
     * and can contain arbitrary logic to calculate the redemption premium.
     */
    function _getRedeemPremium(
        ISetToken _setToken,
        address /* _reserveAsset */,
        uint256 /* _setTokenQuantity */
    )
        virtual
        internal
        view
        returns (uint256)
    {
        return navIssuanceSettings[_setToken].premiumPercentage;
    }

    /**
     * Returns the fees attributed to the manager and the protocol. The fees are calculated as follows:
     *
     * ManagerFee = (manager fee % - % to protocol) * reserveAssetQuantity
     * Protocol Fee = (% manager fee share + direct fee %) * reserveAssetQuantity
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAssetQuantity         Quantity of reserve asset to calculate fees from
     * @param _protocolManagerFeeIndex      Index to pull rev share NAV Issuance fee from the Controller
     * @param _protocolDirectFeeIndex       Index to pull direct NAV issuance fee from the Controller
     * @param _managerFeeIndex              Index from NAVIssuanceSettings (0 = issue fee, 1 = redeem fee)
     *
     * @return  uint256                     Fees paid to the protocol in reserve asset
     * @return  uint256                     Fees paid to the manager in reserve asset
     * @return  uint256                     Net reserve to user net of fees
     */
    function _getFees(
        ISetToken _setToken,
        uint256 _reserveAssetQuantity,
        uint256 _protocolManagerFeeIndex,
        uint256 _protocolDirectFeeIndex,
        uint256 _managerFeeIndex
    )
        internal
        view
        returns (uint256, uint256, uint256)
    {
        (uint256 protocolFeePercentage, uint256 managerFeePercentage) = _getProtocolAndManagerFeePercentages(
            _setToken,
            _protocolManagerFeeIndex,
            _protocolDirectFeeIndex,
            _managerFeeIndex
        );

        // Calculate total notional fees
        uint256 protocolFees = protocolFeePercentage.preciseMul(_reserveAssetQuantity);
        uint256 managerFee = managerFeePercentage.preciseMul(_reserveAssetQuantity);

        uint256 netReserveFlow = _reserveAssetQuantity.sub(protocolFees).sub(managerFee);

        return (protocolFees, managerFee, netReserveFlow);
    }

    function _getProtocolAndManagerFeePercentages(
        ISetToken _setToken,
        uint256 _protocolManagerFeeIndex,
        uint256 _protocolDirectFeeIndex,
        uint256 _managerFeeIndex
    )
        internal
        view
        returns(uint256, uint256)
    {
        // Get protocol fee percentages
        uint256 protocolDirectFeePercent = controller.getModuleFee(address(this), _protocolDirectFeeIndex);
        uint256 protocolManagerShareFeePercent = controller.getModuleFee(address(this), _protocolManagerFeeIndex);
        uint256 managerFeePercent = navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];

        // Calculate revenue share split percentage
        uint256 protocolRevenueSharePercentage = protocolManagerShareFeePercent.preciseMul(managerFeePercent);
        uint256 managerRevenueSharePercentage = managerFeePercent.sub(protocolRevenueSharePercentage);
        uint256 totalProtocolFeePercentage = protocolRevenueSharePercentage.add(protocolDirectFeePercent);

        return (totalProtocolFeePercentage, managerRevenueSharePercentage);
    }

    function _getSetTokenMintQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _netReserveFlows,            // Value of reserve asset net of fees
        uint256 _setTotalSupply
    )
        internal
        view
        returns (uint256)
    {
        uint256 premiumPercentage = _getIssuePremium(_setToken, _reserveAsset, _netReserveFlows);
        uint256 premiumValue = _netReserveFlows.preciseMul(premiumPercentage);

        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (1e18)
        // Reverts if price is not found
        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);

        // Get reserve asset decimals
        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();
        uint256 normalizedTotalReserveQuantityNetFees = _netReserveFlows.preciseDiv(10 ** reserveAssetDecimals);
        uint256 normalizedTotalReserveQuantityNetFeesAndPremium = _netReserveFlows.sub(premiumValue).preciseDiv(10 ** reserveAssetDecimals);

        // Calculate SetTokens to mint to issuer
        uint256 denominator = _setTotalSupply.preciseMul(setTokenValuation).add(normalizedTotalReserveQuantityNetFees).sub(normalizedTotalReserveQuantityNetFeesAndPremium);
        return normalizedTotalReserveQuantityNetFeesAndPremium.preciseMul(_setTotalSupply).preciseDiv(denominator);
    }

    function _getRedeemReserveQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        internal
        view
        returns (uint256)
    {
        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (10e18)
        // Reverts if price is not found
        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);

        uint256 totalRedeemValueInPreciseUnits = _setTokenQuantity.preciseMul(setTokenValuation);
        // Get reserve asset decimals
        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();
        uint256 prePremiumReserveQuantity = totalRedeemValueInPreciseUnits.preciseMul(10 ** reserveAssetDecimals);

        uint256 premiumPercentage = _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);
        uint256 premiumQuantity = prePremiumReserveQuantity.preciseMulCeil(premiumPercentage);

        return prePremiumReserveQuantity.sub(premiumQuantity);
    }

    /**
     * The new position multiplier is calculated as follows:
     * inflationPercentage = (newSupply - oldSupply) / newSupply
     * newMultiplier = (1 - inflationPercentage) * positionMultiplier
     */
    function _getIssuePositionMultiplier(
        ISetToken _setToken,
        ActionInfo memory _issueInfo
    )
        internal
        view
        returns (uint256, int256)
    {
        // Calculate inflation and new position multiplier. Note: Round inflation up in order to round position multiplier down
        uint256 newTotalSupply = _issueInfo.setTokenQuantity.add(_issueInfo.previousSetTokenSupply);
        int256 newPositionMultiplier = _setToken.positionMultiplier()
            .mul(_issueInfo.previousSetTokenSupply.toInt256())
            .div(newTotalSupply.toInt256());

        return (newTotalSupply, newPositionMultiplier);
    }

    /**
     * Calculate deflation and new position multiplier. Note: Round deflation down in order to round position multiplier down
     *
     * The new position multiplier is calculated as follows:
     * deflationPercentage = (oldSupply - newSupply) / newSupply
     * newMultiplier = (1 + deflationPercentage) * positionMultiplier
     */
    function _getRedeemPositionMultiplier(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        ActionInfo memory _redeemInfo
    )
        internal
        view
        returns (uint256, int256)
    {
        uint256 newTotalSupply = _redeemInfo.previousSetTokenSupply.sub(_setTokenQuantity);
        int256 newPositionMultiplier = _setToken.positionMultiplier()
            .mul(_redeemInfo.previousSetTokenSupply.toInt256())
            .div(newTotalSupply.toInt256());

        return (newTotalSupply, newPositionMultiplier);
    }

    /**
     * The new position reserve asset unit is calculated as follows:
     * totalReserve = (oldUnit * oldSetTokenSupply) + reserveQuantity
     * newUnit = totalReserve / newSetTokenSupply
     */
    function _getIssuePositionUnit(
        ISetToken _setToken,
        address _reserveAsset,
        ActionInfo memory _issueInfo
    )
        internal
        view
        returns (uint256)
    {
        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();
        uint256 totalReserve = existingUnit
            .preciseMul(_issueInfo.previousSetTokenSupply)
            .add(_issueInfo.netFlowQuantity);

        return totalReserve.preciseDiv(_issueInfo.newSetTokenSupply);
    }

    /**
     * The new position reserve asset unit is calculated as follows:
     * totalReserve = (oldUnit * oldSetTokenSupply) - reserveQuantityToSendOut
     * newUnit = totalReserve / newSetTokenSupply
     */
    function _getRedeemPositionUnit(
        ISetToken _setToken,
        address _reserveAsset,
        ActionInfo memory _redeemInfo
    )
        internal
        view
        returns (uint256)
    {
        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();
        uint256 totalExistingUnits = existingUnit.preciseMul(_redeemInfo.previousSetTokenSupply);

        uint256 outflow = _redeemInfo.netFlowQuantity.add(_redeemInfo.protocolFees).add(_redeemInfo.managerFee);

        // Require withdrawable quantity is greater than existing collateral
        require(totalExistingUnits >= outflow, "Must be greater than total available collateral");

        return totalExistingUnits.sub(outflow).preciseDiv(_redeemInfo.newSetTokenSupply);
    }

    /**
     * If a pre-issue hook has been configured, call the external-protocol contract. Pre-issue hook logic
     * can contain arbitrary logic including validations, external function calls, etc.
     */
    function _callPreIssueHooks(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity,
        address _caller,
        address _to
    )
        internal
    {
        INAVIssuanceHook preIssueHook = navIssuanceSettings[_setToken].managerIssuanceHook;
        if (address(preIssueHook) != address(0)) {
            preIssueHook.invokePreIssueHook(_setToken, _reserveAsset, _reserveAssetQuantity, _caller, _to);
        }
    }

    /**
     * If a pre-redeem hook has been configured, call the external-protocol contract.
     */
    function _callPreRedeemHooks(ISetToken _setToken, uint256 _setQuantity, address _caller, address _to) internal {
        INAVIssuanceHook preRedeemHook = navIssuanceSettings[_setToken].managerRedemptionHook;
        if (address(preRedeemHook) != address(0)) {
            preRedeemHook.invokePreRedeemHook(_setToken, _setQuantity, _caller, _to);
        }
    }
}.]

Based on the provided smart contract code for the `NavIssuanceModule`, here is a summary of potential security vulnerabilities identified within the contract:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - The contract uses the `nonReentrant` modifier to prevent reentrancy attacks, but it is crucial to ensure that all external calls (like transferring tokens) are made after state changes to avoid potential reentrancy issues.

2. **Access Control**:
   - The contract relies on modifiers like `onlyManagerAndValidSet` and `onlySetManager`, which should be thoroughly audited to ensure that only authorized users can invoke sensitive functions. Any oversight could lead to unauthorized access.

3. **Integer Overflow/Underflow**:
   - Although the contract uses `SafeMath` and `SignedSafeMath` libraries to mitigate overflow and underflow risks, it is essential to verify that all arithmetic operations are covered by these libraries, especially in complex calculations.

4. **Gas Limit and Loops**:
   - Functions that iterate over arrays (like `addReserveAsset` and `removeReserveAsset`) could potentially run into gas limit issues if the arrays grow large. This could lead to denial of service if users cannot execute these functions.

5. **External Calls**:
   - The contract makes several external calls (e.g., invoking hooks). If these external contracts are malicious or have vulnerabilities, they could compromise the security of this contract. It is essential to validate the integrity of external contracts.

6. **Price Manipulation**:
   - The reliance on oracle prices for calculating net asset values could expose the contract to price manipulation attacks. If the oracle is compromised, it could lead to incorrect valuations and potential financial losses.

7. **Lack of Input Validation**:
   - Some functions do not perform adequate validation on inputs (e.g., checking for zero addresses or quantities). This could lead to unexpected behavior or vulnerabilities.

8. **Event Emission**:
   - While the contract emits events for significant actions, it is essential to ensure that all critical state changes are logged appropriately to maintain transparency and facilitate auditing.

### Comprehensive Analysis Report:

The `NavIssuanceModule` contract is designed to facilitate the issuance and redemption of SetTokens using various reserve assets. While it incorporates several best practices, including the use of OpenZeppelin libraries and modifiers for access control, there are notable security vulnerabilities that need to be addressed.

1. **Reentrancy Protection**: Although the contract employs the `nonReentrant` modifier, it is crucial to ensure that all state changes occur before any external calls to mitigate the risk of reentrancy attacks effectively.

2. **Access Control Mechanisms**: The contract's reliance on access control modifiers necessitates a thorough review to ensure that only authorized users can execute sensitive functions. Any vulnerabilities in this area could lead to unauthorized actions.

3. **Arithmetic Safety**: The use of `SafeMath` and `SignedSafeMath` is commendable, but a comprehensive audit is required to ensure that all arithmetic operations are adequately protected against overflow and underflow.

4. **Gas Limit Considerations**: Functions that involve loops should be designed with gas limits in mind to prevent denial of service attacks. It is advisable to implement mechanisms to handle large arrays efficiently.

5. **External Dependency Risks**: The contract's interaction with external contracts and oracles introduces risks that must be managed. Ensuring the integrity of these external dependencies is critical to maintaining the contract's security.

6. **Input Validation**: Strengthening input validation across the contract will help prevent unexpected behaviors and potential vulnerabilities.

7. **Event Logging**: Comprehensive event logging for all critical actions will enhance transparency and facilitate auditing, which is essential for maintaining trust in the contract's operations.

In conclusion, while the `NavIssuanceModule` contract exhibits a solid foundation, addressing the identified vulnerabilities is crucial for ensuring its security and reliability. A thorough audit and testing phase should be conducted to mitigate these risks before deployment.

[2024-01-09 05:31:32 INFO] **[Seminar Conclusion]**:

 Based on the provided smart contract code for the `NavIssuanceModule`, here is a summary of potential security vulnerabilities identified within the contract:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - The contract uses the `nonReentrant` modifier to prevent reentrancy attacks, but it is crucial to ensure that all external calls (like transferring tokens) are made after state changes to avoid potential reentrancy issues.

2. **Access Control**:
   - The contract relies on modifiers like `onlyManagerAndValidSet` and `onlySetManager`, which should be thoroughly audited to ensure that only authorized users can invoke sensitive functions. Any oversight could lead to unauthorized access.

3. **Integer Overflow/Underflow**:
   - Although the contract uses `SafeMath` and `SignedSafeMath` libraries to mitigate overflow and underflow risks, it is essential to verify that all arithmetic operations are covered by these libraries, especially in complex calculations.

4. **Gas Limit and Loops**:
   - Functions that iterate over arrays (like `addReserveAsset` and `removeReserveAsset`) could potentially run into gas limit issues if the arrays grow large. This could lead to denial of service if users cannot execute these functions.

5. **External Calls**:
   - The contract makes several external calls (e.g., invoking hooks). If these external contracts are malicious or have vulnerabilities, they could compromise the security of this contract. It is essential to validate the integrity of external contracts.

6. **Price Manipulation**:
   - The reliance on oracle prices for calculating net asset values could expose the contract to price manipulation attacks. If the oracle is compromised, it could lead to incorrect valuations and potential financial losses.

7. **Lack of Input Validation**:
   - Some functions do not perform adequate validation on inputs (e.g., checking for zero addresses or quantities). This could lead to unexpected behavior or vulnerabilities.

8. **Event Emission**:
   - While the contract emits events for significant actions, it is essential to ensure that all critical state changes are logged appropriately to maintain transparency and facilitate auditing.

### Comprehensive Analysis Report:

The `NavIssuanceModule` contract is designed to facilitate the issuance and redemption of SetTokens using various reserve assets. While it incorporates several best practices, including the use of OpenZeppelin libraries and modifiers for access control, there are notable security vulnerabilities that need to be addressed.

1. **Reentrancy Protection**: Although the contract employs the `nonReentrant` modifier, it is crucial to ensure that all state changes occur before any external calls to mitigate the risk of reentrancy attacks effectively.

2. **Access Control Mechanisms**: The contract's reliance on access control modifiers necessitates a thorough review to ensure that only authorized users can execute sensitive functions. Any vulnerabilities in this area could lead to unauthorized actions.

3. **Arithmetic Safety**: The use of `SafeMath` and `SignedSafeMath` is commendable, but a comprehensive audit is required to ensure that all arithmetic operations are adequately protected against overflow and underflow.

4. **Gas Limit Considerations**: Functions that involve loops should be designed with gas limits in mind to prevent denial of service attacks. It is advisable to implement mechanisms to handle large arrays efficiently.

5. **External Dependency Risks**: The contract's interaction with external contracts and oracles introduces risks that must be managed. Ensuring the integrity of these external dependencies is critical to maintaining the contract's security.

6. **Input Validation**: Strengthening input validation across the contract will help prevent unexpected behaviors and potential vulnerabilities.

7. **Event Logging**: Comprehensive event logging for all critical actions will enhance transparency and facilitate auditing, which is essential for maintaining trust in the contract's operations.

In conclusion, while the `NavIssuanceModule` contract exhibits a solid foundation, addressing the identified vulnerabilities is crucial for ensuring its security and reliability. A thorough audit and testing phase should be conducted to mitigate these risks before deployment.

[2024-01-09 05:31:32 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 2

[2024-01-09 05:31:32 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /*     Copyright 2020 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol"; import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol"; import { SignedSafeMath } from "@openzeppelin/contracts/math/SignedSafeMath.sol"; import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol"; import { IController } from "../../interfaces/IController.sol"; import { INAVIssuanceHook } from "../../interfaces/INAVIssuanceHook.sol"; import { Invoke } from "../lib/Invoke.sol"; import { ISetToken } from "../../interfaces/ISetToken.sol"; import { IWETH } from "../../interfaces/external/IWETH.sol"; import { ModuleBase } from "../lib/ModuleBase.sol"; import { Position } from "../lib/Position.sol"; import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol"; import { ResourceIdentifier } from "../lib/ResourceIdentifier.sol"; /*  * @title NavIssuanceModule  * @author Set Protocol  *  * Module that enables issuance and redemption with any valid ERC20 token or ETH if allowed by the manager. Sender receives  * a proportional amount of SetTokens on issuance or ERC20 token on redemption based on the calculated net asset value using  * oracle prices. Manager is able to enforce a premium / discount on issuance / redemption to avoid arbitrage and front  * running when relying on oracle prices. Managers can charge a fee (denominated in reserve asset).  / contract NavIssuanceModule is ModuleBase, ReentrancyGuard {     using AddressArrayUtils for address[];     using Invoke for ISetToken;     using Position for ISetToken;     using PreciseUnitMath for uint256;     using PreciseUnitMath for int256;     using ResourceIdentifier for IController;     using SafeMath for uint256;     using SafeCast for int256;     using SafeCast for uint256;     using SignedSafeMath for int256; /* ============ Events ============ */  event SetTokenNAVIssued(     ISetToken indexed _setToken,     address _issuer,     address _to,     address _reserveAsset,     address _hookContract,     uint256 _setTokenQuantity,     uint256 _managerFee,     uint256 _premium );  event SetTokenNAVRedeemed(     ISetToken indexed _setToken,     address _redeemer,     address _to,     address _reserveAsset,     address _hookContract,     uint256 _setTokenQuantity,     uint256 _managerFee,     uint256 _premium );  event ReserveAssetAdded(     ISetToken indexed _setToken,     address _newReserveAsset );  event ReserveAssetRemoved(     ISetToken indexed _setToken,     address _removedReserveAsset );  event PremiumEdited(     ISetToken indexed _setToken,     uint256 _newPremium );  event ManagerFeeEdited(     ISetToken indexed _setToken,     uint256 _newManagerFee,     uint256 _index );  event FeeRecipientEdited(     ISetToken indexed _setToken,     address _feeRecipient );  /* ============ Structs ============ */  struct NAVIssuanceSettings {     INAVIssuanceHook managerIssuanceHook;      // Issuance hook configurations     INAVIssuanceHook managerRedemptionHook;    // Redemption hook configurations     address[] reserveAssets;                       // Allowed reserve assets - Must have a price enabled with the price oracle     address feeRecipient;                          // Manager fee recipient     uint256[2] managerFees;                        // Manager fees. 0 index is issue and 1 index is redeem fee (0.01% = 1e14, 1% = 1e16)     uint256 maxManagerFee;                         // Maximum fee manager is allowed to set for issue and redeem     uint256 premiumPercentage;                     // Premium percentage (0.01% = 1e14, 1% = 1e16). This premium is a buffer around oracle                                                    // prices paid by user to the SetToken, which prevents arbitrage and oracle front running     uint256 maxPremiumPercentage;                  // Maximum premium percentage manager is allowed to set (configured by manager)     uint256 minSetTokenSupply;                     // Minimum SetToken supply required for issuance and redemption                                                    // to prevent dramatic inflationary changes to the SetToken's position multiplier }  struct ActionInfo {     uint256 preFeeReserveQuantity;                 // Reserve value before fees; During issuance, represents raw quantity                                                    // During redeem, represents post-premium value     uint256 protocolFees;                          // Total protocol fees (direct + manager revenue share)     uint256 managerFee;                            // Total manager fee paid in reserve asset     uint256 netFlowQuantity;                       // When issuing, quantity of reserve asset sent to SetToken                                                    // When redeeming, quantity of reserve asset sent to redeemer     uint256 setTokenQuantity;                      // When issuing, quantity of SetTokens minted to mintee                                                    // When redeeming, quantity of SetToken redeemed     uint256 previousSetTokenSupply;                // SetToken supply prior to issue/redeem action     uint256 newSetTokenSupply;                     // SetToken supply after issue/redeem action     int256 newPositionMultiplier;                  // SetToken position multiplier after issue/redeem     uint256 newReservePositionUnit;                // SetToken reserve asset position unit after issue/redeem }  /* ============ State Variables ============ */  // Wrapped ETH address IWETH public immutable weth;  // Mapping of SetToken to NAV issuance settings struct mapping(ISetToken =&gt; NAVIssuanceSettings) public navIssuanceSettings;  // Mapping to efficiently check a SetToken's reserve asset validity // SetToken =&gt; reserveAsset =&gt; isReserveAsset mapping(ISetToken =&gt; mapping(address =&gt; bool)) public isReserveAsset;  /* ============ Constants ============ */  // 0 index stores the manager fee in managerFees array, percentage charged on issue (denominated in reserve asset) uint256 constant internal MANAGER_ISSUE_FEE_INDEX = 0;  // 1 index stores the manager fee percentage in managerFees array, charged on redeem uint256 constant internal MANAGER_REDEEM_FEE_INDEX = 1;  // 0 index stores the manager revenue share protocol fee % on the controller, charged in the issuance function uint256 constant internal PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX = 0;  // 1 index stores the manager revenue share protocol fee % on the controller, charged in the redeem function uint256 constant internal PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX = 1;  // 2 index stores the direct protocol fee % on the controller, charged in the issuance function uint256 constant internal PROTOCOL_ISSUE_DIRECT_FEE_INDEX = 2;  // 3 index stores the direct protocol fee % on the controller, charged in the redeem function uint256 constant internal PROTOCOL_REDEEM_DIRECT_FEE_INDEX = 3;  /* ============ Constructor ============ */  /**  * @param _controller               Address of controller contract  * @param _weth                     Address of wrapped eth  */ constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {     weth = _weth; }  /* ============ External Functions ============ */  /**  * Deposits the allowed reserve asset into the SetToken and mints the appropriate % of Net Asset Value of the SetToken  * to the specified _to address.  *  * @param _setToken                     Instance of the SetToken contract  * @param _reserveAsset                 Address of the reserve asset to issue with  * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with  * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance  * @param _to                           Address to mint SetToken to  */ function issue(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity,     uint256 _minSetTokenReceiveQuantity,     address _to )     external     nonReentrant     onlyValidAndInitializedSet(_setToken) {     _validateCommon(_setToken, _reserveAsset, _reserveAssetQuantity);      _callPreIssueHooks(_setToken, _reserveAsset, _reserveAssetQuantity, msg.sender, _to);      ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, _reserveAsset, _reserveAssetQuantity);      _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);      _transferCollateralAndHandleFees(_setToken, IERC20(_reserveAsset), issueInfo);      _handleIssueStateUpdates(_setToken, _reserveAsset, _to, issueInfo); }  /**  * Wraps ETH and deposits WETH if allowed into the SetToken and mints the appropriate % of Net Asset Value of the SetToken  * to the specified _to address.  *  * @param _setToken                     Instance of the SetToken contract  * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance  * @param _to                           Address to mint SetToken to  */ function issueWithEther(     ISetToken _setToken,     uint256 _minSetTokenReceiveQuantity,     address _to )     external     payable     nonReentrant     onlyValidAndInitializedSet(_setToken) {     weth.deposit{ value: msg.value }();      _validateCommon(_setToken, address(weth), msg.value);      _callPreIssueHooks(_setToken, address(weth), msg.value, msg.sender, _to);      ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, address(weth), msg.value);      _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);      _transferWETHAndHandleFees(_setToken, issueInfo);      _handleIssueStateUpdates(_setToken, address(weth), _to, issueInfo); }  /**  * Redeems a SetToken into a valid reserve asset representing the appropriate % of Net Asset Value of the SetToken  * to the specified _to address. Only valid if there are available reserve units on the SetToken.  *  * @param _setToken                     Instance of the SetToken contract  * @param _reserveAsset                 Address of the reserve asset to redeem with  * @param _setTokenQuantity             Quantity of SetTokens to redeem  * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive  * @param _to                           Address to redeem reserve asset to  */ function redeem(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity,     uint256 _minReserveReceiveQuantity,     address _to )     external     nonReentrant     onlyValidAndInitializedSet(_setToken) {     _validateCommon(_setToken, _reserveAsset, _setTokenQuantity);      _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);      ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, _reserveAsset, _setTokenQuantity);      _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);      _setToken.burn(msg.sender, _setTokenQuantity);      // Instruct the SetToken to transfer the reserve asset back to the user     _setToken.strictInvokeTransfer(         _reserveAsset,         _to,         redeemInfo.netFlowQuantity     );      _handleRedemptionFees(_setToken, _reserveAsset, redeemInfo);      _handleRedeemStateUpdates(_setToken, _reserveAsset, _to, redeemInfo); }  /**  * Redeems a SetToken into Ether (if WETH is valid) representing the appropriate % of Net Asset Value of the SetToken  * to the specified _to address. Only valid if there are available WETH units on the SetToken.  *  * @param _setToken                     Instance of the SetToken contract  * @param _setTokenQuantity             Quantity of SetTokens to redeem  * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive  * @param _to                           Address to redeem reserve asset to  */ function redeemIntoEther(     ISetToken _setToken,     uint256 _setTokenQuantity,     uint256 _minReserveReceiveQuantity,     address payable _to )     external     nonReentrant     onlyValidAndInitializedSet(_setToken) {     _validateCommon(_setToken, address(weth), _setTokenQuantity);      _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);      ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, address(weth), _setTokenQuantity);      _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);      _setToken.burn(msg.sender, _setTokenQuantity);      // Instruct the SetToken to transfer WETH from SetToken to module     _setToken.strictInvokeTransfer(         address(weth),         address(this),         redeemInfo.netFlowQuantity     );      weth.withdraw(redeemInfo.netFlowQuantity);      _to.transfer(redeemInfo.netFlowQuantity);      _handleRedemptionFees(_setToken, address(weth), redeemInfo);      _handleRedeemStateUpdates(_setToken, address(weth), _to, redeemInfo); }  /**  * SET MANAGER ONLY. Add an allowed reserve asset  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset to add  */ function addReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {     require(!isReserveAsset[_setToken][_reserveAsset], "Reserve asset already exists");      navIssuanceSettings[_setToken].reserveAssets.push(_reserveAsset);     isReserveAsset[_setToken][_reserveAsset] = true;      emit ReserveAssetAdded(_setToken, _reserveAsset); }  /**  * SET MANAGER ONLY. Remove a reserve asset  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset to remove  */ function removeReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {     require(isReserveAsset[_setToken][_reserveAsset], "Reserve asset does not exist");      navIssuanceSettings[_setToken].reserveAssets = navIssuanceSettings[_setToken].reserveAssets.remove(_reserveAsset);     delete isReserveAsset[_setToken][_reserveAsset];      emit ReserveAssetRemoved(_setToken, _reserveAsset); }  /**  * SET MANAGER ONLY. Edit the premium percentage  *  * @param _setToken                     Instance of the SetToken  * @param _premiumPercentage            Premium percentage in 10e16 (e.g. 10e16 = 1%)  */ function editPremium(ISetToken _setToken, uint256 _premiumPercentage) external onlyManagerAndValidSet(_setToken) {     require(_premiumPercentage &lt;= navIssuanceSettings[_setToken].maxPremiumPercentage, "Premium must be less than maximum allowed");      navIssuanceSettings[_setToken].premiumPercentage = _premiumPercentage;      emit PremiumEdited(_setToken, _premiumPercentage); }  /**  * SET MANAGER ONLY. Edit manager fee  *  * @param _setToken                     Instance of the SetToken  * @param _managerFeePercentage         Manager fee percentage in 10e16 (e.g. 10e16 = 1%)  * @param _managerFeeIndex              Manager fee index. 0 index is issue fee, 1 index is redeem fee  */ function editManagerFee(     ISetToken _setToken,     uint256 _managerFeePercentage,     uint256 _managerFeeIndex )     external     onlyManagerAndValidSet(_setToken) {     require(_managerFeePercentage &lt;= navIssuanceSettings[_setToken].maxManagerFee, "Manager fee must be less than maximum allowed");      navIssuanceSettings[_setToken].managerFees[_managerFeeIndex] = _managerFeePercentage;      emit ManagerFeeEdited(_setToken, _managerFeePercentage, _managerFeeIndex); }  /**  * SET MANAGER ONLY. Edit the manager fee recipient  *  * @param _setToken                     Instance of the SetToken  * @param _managerFeeRecipient          Manager fee recipient  */ function editFeeRecipient(ISetToken _setToken, address _managerFeeRecipient) external onlyManagerAndValidSet(_setToken) {     require(_managerFeeRecipient != address(0), "Fee recipient must not be 0 address");      navIssuanceSettings[_setToken].feeRecipient = _managerFeeRecipient;      emit FeeRecipientEdited(_setToken, _managerFeeRecipient); }  /**  * SET MANAGER ONLY. Initializes this module to the SetToken with hooks, allowed reserve assets,  * fees and issuance premium. Only callable by the SetToken's manager. Hook addresses are optional.  * Address(0) means that no hook will be called.  *  * @param _setToken                     Instance of the SetToken to issue  * @param _navIssuanceSettings          NAVIssuanceSettings struct defining parameters  */ function initialize(     ISetToken _setToken,     NAVIssuanceSettings memory _navIssuanceSettings )     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     require(_navIssuanceSettings.reserveAssets.length &gt; 0, "Reserve assets must be greater than 0");     require(_navIssuanceSettings.maxManagerFee &lt; PreciseUnitMath.preciseUnit(), "Max manager fee must be less than 100%");     require(_navIssuanceSettings.maxPremiumPercentage &lt; PreciseUnitMath.preciseUnit(), "Max premium percentage must be less than 100%");     require(_navIssuanceSettings.managerFees[0] &lt;= _navIssuanceSettings.maxManagerFee, "Manager issue fee must be less than max");     require(_navIssuanceSettings.managerFees[1] &lt;= _navIssuanceSettings.maxManagerFee, "Manager redeem fee must be less than max");     require(_navIssuanceSettings.premiumPercentage &lt;= _navIssuanceSettings.maxPremiumPercentage, "Premium must be less than max");     require(_navIssuanceSettings.feeRecipient != address(0), "Fee Recipient must be non-zero address.");     // Initial mint of Set cannot use NAVIssuance since minSetTokenSupply must be &gt; 0     require(_navIssuanceSettings.minSetTokenSupply &gt; 0, "Min SetToken supply must be greater than 0");      for (uint256 i = 0; i &lt; _navIssuanceSettings.reserveAssets.length; i++) {         require(!isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]], "Reserve assets must be unique");         isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]] = true;     }      navIssuanceSettings[_setToken] = _navIssuanceSettings;      _setToken.initializeModule(); }  /**  * Removes this module from the SetToken, via call by the SetToken. Issuance settings and  * reserve asset states are deleted.  */ function removeModule() external override {     ISetToken setToken = ISetToken(msg.sender);     for (uint256 i = 0; i &lt; navIssuanceSettings[setToken].reserveAssets.length; i++) {         delete isReserveAsset[setToken][navIssuanceSettings[setToken].reserveAssets[i]];     }      delete navIssuanceSettings[setToken]; }  receive() external payable {}  /* ============ External Getter Functions ============ */  function getReserveAssets(ISetToken _setToken) external view returns (address[] memory) {     return navIssuanceSettings[_setToken].reserveAssets; }  function getIssuePremium(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     external     view     returns (uint256) {     return _getIssuePremium(_setToken, _reserveAsset, _reserveAssetQuantity); }  function getRedeemPremium(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     external     view     returns (uint256) {     return _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity); }  function getManagerFee(ISetToken _setToken, uint256 _managerFeeIndex) external view returns (uint256) {     return navIssuanceSettings[_setToken].managerFees[_managerFeeIndex]; }  /**  * Get the expected SetTokens minted to recipient on issuance  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with  *  * @return  uint256                     Expected SetTokens to be minted to recipient  */ function getExpectedSetTokenIssueQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     external     view     returns (uint256) {     (,, uint256 netReserveFlow) = _getFees(         _setToken,         _reserveAssetQuantity,         PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_ISSUE_DIRECT_FEE_INDEX,         MANAGER_ISSUE_FEE_INDEX     );      uint256 setTotalSupply = _setToken.totalSupply();      return _getSetTokenMintQuantity(         _setToken,         _reserveAsset,         netReserveFlow,         setTotalSupply     ); }  /**  * Get the expected reserve asset to be redeemed  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _setTokenQuantity             Quantity of SetTokens to redeem  *  * @return  uint256                     Expected reserve asset quantity redeemed  */ function getExpectedReserveRedeemQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     external     view     returns (uint256) {     uint256 preFeeReserveQuantity = _getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);      (,, uint256 netReserveFlows) = _getFees(         _setToken,         preFeeReserveQuantity,         PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_REDEEM_DIRECT_FEE_INDEX,         MANAGER_REDEEM_FEE_INDEX     );      return netReserveFlows; }  /**  * Checks if issue is valid  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with  *  * @return  bool                        Returns true if issue is valid  */ function isIssueValid(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     external     view     returns (bool) {     uint256 setTotalSupply = _setToken.totalSupply();  return _reserveAssetQuantity != 0         &amp;&amp; isReserveAsset[_setToken][_reserveAsset]         &amp;&amp; setTotalSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply; }  /**  * Checks if redeem is valid  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _setTokenQuantity             Quantity of SetTokens to redeem  *  * @return  bool                        Returns true if redeem is valid  */ function isRedeemValid(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     external     view     returns (bool) {     uint256 setTotalSupply = _setToken.totalSupply();      if (         _setTokenQuantity == 0         || !isReserveAsset[_setToken][_reserveAsset]         || setTotalSupply &lt; navIssuanceSettings[_setToken].minSetTokenSupply.add(_setTokenQuantity)     ) {         return false;     } else {         uint256 totalRedeemValue =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);          (,, uint256 expectedRedeemQuantity) = _getFees(             _setToken,             totalRedeemValue,             PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,             PROTOCOL_REDEEM_DIRECT_FEE_INDEX,             MANAGER_REDEEM_FEE_INDEX         );          uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();          return existingUnit.preciseMul(setTotalSupply) &gt;= expectedRedeemQuantity;     } }  /* ============ Internal Functions ============ */  function _validateCommon(ISetToken _setToken, address _reserveAsset, uint256 _quantity) internal view {     require(_quantity &gt; 0, "Quantity must be &gt; 0");     require(isReserveAsset[_setToken][_reserveAsset], "Must be valid reserve asset"); }  function _validateIssuanceInfo(ISetToken _setToken, uint256 _minSetTokenReceiveQuantity, ActionInfo memory _issueInfo) internal view {     // Check that total supply is greater than min supply needed for issuance     // Note: A min supply amount is needed to avoid division by 0 when SetToken supply is 0     require(         _issueInfo.previousSetTokenSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply,         "Supply must be greater than minimum to enable issuance"     );      require(_issueInfo.setTokenQuantity &gt;= _minSetTokenReceiveQuantity, "Must be greater than min SetToken"); }  function _validateRedemptionInfo(     ISetToken _setToken,     uint256 _minReserveReceiveQuantity,     ActionInfo memory _redeemInfo )     internal     view {     // Check that new supply is more than min supply needed for redemption     // Note: A min supply amount is needed to avoid division by 0 when redeeming SetToken to 0     require(         _redeemInfo.newSetTokenSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply,         "Supply must be greater than minimum to enable redemption"     );      require(_redeemInfo.netFlowQuantity &gt;= _minReserveReceiveQuantity, "Must be greater than min receive reserve quantity"); }  function _createIssuanceInfo(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     internal     view     returns (ActionInfo memory) {     ActionInfo memory issueInfo;      issueInfo.previousSetTokenSupply = _setToken.totalSupply();      issueInfo.preFeeReserveQuantity = _reserveAssetQuantity;      (issueInfo.protocolFees, issueInfo.managerFee, issueInfo.netFlowQuantity) = _getFees(         _setToken,         issueInfo.preFeeReserveQuantity,         PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_ISSUE_DIRECT_FEE_INDEX,         MANAGER_ISSUE_FEE_INDEX     );      issueInfo.setTokenQuantity = _getSetTokenMintQuantity(         _setToken,         _reserveAsset,         issueInfo.netFlowQuantity,         issueInfo.previousSetTokenSupply     );      (issueInfo.newSetTokenSupply, issueInfo.newPositionMultiplier) = _getIssuePositionMultiplier(_setToken, issueInfo);      issueInfo.newReservePositionUnit = _getIssuePositionUnit(_setToken, _reserveAsset, issueInfo);      return issueInfo; }  function _createRedemptionInfo(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     internal     view     returns (ActionInfo memory) {     ActionInfo memory redeemInfo;      redeemInfo.setTokenQuantity = _setTokenQuantity;      redeemInfo.preFeeReserveQuantity =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);      (redeemInfo.protocolFees, redeemInfo.managerFee, redeemInfo.netFlowQuantity) = _getFees(         _setToken,         redeemInfo.preFeeReserveQuantity,         PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_REDEEM_DIRECT_FEE_INDEX,         MANAGER_REDEEM_FEE_INDEX     );      redeemInfo.previousSetTokenSupply = _setToken.totalSupply();      (redeemInfo.newSetTokenSupply, redeemInfo.newPositionMultiplier) = _getRedeemPositionMultiplier(_setToken, _setTokenQuantity, redeemInfo);      redeemInfo.newReservePositionUnit = _getRedeemPositionUnit(_setToken, _reserveAsset, redeemInfo);      return redeemInfo; }  /**  * Transfer reserve asset from user to SetToken and fees from user to appropriate fee recipients  */ function _transferCollateralAndHandleFees(ISetToken _setToken, IERC20 _reserveAsset, ActionInfo memory _issueInfo) internal {     transferFrom(_reserveAsset, msg.sender, address(_setToken), _issueInfo.netFlowQuantity);      if (_issueInfo.protocolFees &gt; 0) {         transferFrom(_reserveAsset, msg.sender, controller.feeRecipient(), _issueInfo.protocolFees);     }      if (_issueInfo.managerFee &gt; 0) {         transferFrom(_reserveAsset, msg.sender, navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);     } }   /**   * Transfer WETH from module to SetToken and fees from module to appropriate fee recipients  */ function _transferWETHAndHandleFees(ISetToken _setToken, ActionInfo memory _issueInfo) internal {     weth.transfer(address(_setToken), _issueInfo.netFlowQuantity);      if (_issueInfo.protocolFees &gt; 0) {         weth.transfer(controller.feeRecipient(), _issueInfo.protocolFees);     }      if (_issueInfo.managerFee &gt; 0) {         weth.transfer(navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);     } }  function _handleIssueStateUpdates(     ISetToken _setToken,     address _reserveAsset,     address _to,     ActionInfo memory _issueInfo )     internal {     _setToken.editPositionMultiplier(_issueInfo.newPositionMultiplier);      _setToken.editDefaultPosition(_reserveAsset, _issueInfo.newReservePositionUnit);      _setToken.mint(_to, _issueInfo.setTokenQuantity);      emit SetTokenNAVIssued(         _setToken,         msg.sender,         _to,         _reserveAsset,         address(navIssuanceSettings[_setToken].managerIssuanceHook),         _issueInfo.setTokenQuantity,         _issueInfo.managerFee,         _issueInfo.protocolFees     ); }  function _handleRedeemStateUpdates(     ISetToken _setToken,     address _reserveAsset,     address _to,     ActionInfo memory _redeemInfo )     internal {     _setToken.editPositionMultiplier(_redeemInfo.newPositionMultiplier);      _setToken.editDefaultPosition(_reserveAsset, _redeemInfo.newReservePositionUnit);      emit SetTokenNAVRedeemed(         _setToken,         msg.sender,         _to,         _reserveAsset,         address(navIssuanceSettings[_setToken].managerRedemptionHook),         _redeemInfo.setTokenQuantity,         _redeemInfo.managerFee,         _redeemInfo.protocolFees     ); }  function _handleRedemptionFees(ISetToken _setToken, address _reserveAsset, ActionInfo memory _redeemInfo) internal {     // Instruct the SetToken to transfer protocol fee to fee recipient if there is a fee     payProtocolFeeFromSetToken(_setToken, _reserveAsset, _redeemInfo.protocolFees);      // Instruct the SetToken to transfer manager fee to manager fee recipient if there is a fee     if (_redeemInfo.managerFee &gt; 0) {         _setToken.strictInvokeTransfer(             _reserveAsset,             navIssuanceSettings[_setToken].feeRecipient,             _redeemInfo.managerFee         );     } }  /**  * Returns the issue premium percentage. Virtual function that can be overridden in future versions of the module  * and can contain arbitrary logic to calculate the issuance premium.  */ function _getIssuePremium(     ISetToken _setToken,     address /* _reserveAsset */,     uint256 /* _reserveAssetQuantity */ )     virtual     internal     view     returns (uint256) {     return navIssuanceSettings[_setToken].premiumPercentage; }  /**  * Returns the redeem premium percentage. Virtual function that can be overridden in future versions of the module  * and can contain arbitrary logic to calculate the redemption premium.  */ function _getRedeemPremium(     ISetToken _setToken,     address /* _reserveAsset */,     uint256 /* _setTokenQuantity */ )     virtual     internal     view     returns (uint256) {     return navIssuanceSettings[_setToken].premiumPercentage; }  /**  * Returns the fees attributed to the manager and the protocol. The fees are calculated as follows:  *  * ManagerFee = (manager fee % - % to protocol) * reserveAssetQuantity  * Protocol Fee = (% manager fee share + direct fee %) * reserveAssetQuantity  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAssetQuantity         Quantity of reserve asset to calculate fees from  * @param _protocolManagerFeeIndex      Index to pull rev share NAV Issuance fee from the Controller  * @param _protocolDirectFeeIndex       Index to pull direct NAV issuance fee from the Controller  * @param _managerFeeIndex              Index from NAVIssuanceSettings (0 = issue fee, 1 = redeem fee)  *  * @return  uint256                     Fees paid to the protocol in reserve asset  * @return  uint256                     Fees paid to the manager in reserve asset  * @return  uint256                     Net reserve to user net of fees  */ function _getFees(     ISetToken _setToken,     uint256 _reserveAssetQuantity,     uint256 _protocolManagerFeeIndex,     uint256 _protocolDirectFeeIndex,     uint256 _managerFeeIndex )     internal     view     returns (uint256, uint256, uint256) {     (uint256 protocolFeePercentage, uint256 managerFeePercentage) = _getProtocolAndManagerFeePercentages(         _setToken,         _protocolManagerFeeIndex,         _protocolDirectFeeIndex,         _managerFeeIndex     );      // Calculate total notional fees     uint256 protocolFees = protocolFeePercentage.preciseMul(_reserveAssetQuantity);     uint256 managerFee = managerFeePercentage.preciseMul(_reserveAssetQuantity);      uint256 netReserveFlow = _reserveAssetQuantity.sub(protocolFees).sub(managerFee);      return (protocolFees, managerFee, netReserveFlow); }  function _getProtocolAndManagerFeePercentages(     ISetToken _setToken,     uint256 _protocolManagerFeeIndex,     uint256 _protocolDirectFeeIndex,     uint256 _managerFeeIndex )     internal     view     returns(uint256, uint256) {     // Get protocol fee percentages     uint256 protocolDirectFeePercent = controller.getModuleFee(address(this), _protocolDirectFeeIndex);     uint256 protocolManagerShareFeePercent = controller.getModuleFee(address(this), _protocolManagerFeeIndex);     uint256 managerFeePercent = navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];      // Calculate revenue share split percentage     uint256 protocolRevenueSharePercentage = protocolManagerShareFeePercent.preciseMul(managerFeePercent);     uint256 managerRevenueSharePercentage = managerFeePercent.sub(protocolRevenueSharePercentage);     uint256 totalProtocolFeePercentage = protocolRevenueSharePercentage.add(protocolDirectFeePercent);      return (totalProtocolFeePercentage, managerRevenueSharePercentage); }  function _getSetTokenMintQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _netReserveFlows,            // Value of reserve asset net of fees     uint256 _setTotalSupply )     internal     view     returns (uint256) {     uint256 premiumPercentage = _getIssuePremium(_setToken, _reserveAsset, _netReserveFlows);     uint256 premiumValue = _netReserveFlows.preciseMul(premiumPercentage);      // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (1e18)     // Reverts if price is not found     uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);      // Get reserve asset decimals     uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();     uint256 normalizedTotalReserveQuantityNetFees = _netReserveFlows.preciseDiv(10 ** reserveAssetDecimals);     uint256 normalizedTotalReserveQuantityNetFeesAndPremium = _netReserveFlows.sub(premiumValue).preciseDiv(10 ** reserveAssetDecimals);      // Calculate SetTokens to mint to issuer     uint256 denominator = _setTotalSupply.preciseMul(setTokenValuation).add(normalizedTotalReserveQuantityNetFees).sub(normalizedTotalReserveQuantityNetFeesAndPremium);     return normalizedTotalReserveQuantityNetFeesAndPremium.preciseMul(_setTotalSupply).preciseDiv(denominator); }  function _getRedeemReserveQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     internal     view     returns (uint256) {     // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (10e18)     // Reverts if price is not found     uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);      uint256 totalRedeemValueInPreciseUnits = _setTokenQuantity.preciseMul(setTokenValuation);     // Get reserve asset decimals     uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();     uint256 prePremiumReserveQuantity = totalRedeemValueInPreciseUnits.preciseMul(10 ** reserveAssetDecimals);      uint256 premiumPercentage = _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);     uint256 premiumQuantity = prePremiumReserveQuantity.preciseMulCeil(premiumPercentage);      return prePremiumReserveQuantity.sub(premiumQuantity); }  /**  * The new position multiplier is calculated as follows:  * inflationPercentage = (newSupply - oldSupply) / newSupply  * newMultiplier = (1 - inflationPercentage) * positionMultiplier  */ function _getIssuePositionMultiplier(     ISetToken _setToken,     ActionInfo memory _issueInfo )     internal     view     returns (uint256, int256) {     // Calculate inflation and new position multiplier. Note: Round inflation up in order to round position multiplier down     uint256 newTotalSupply = _issueInfo.setTokenQuantity.add(_issueInfo.previousSetTokenSupply);     int256 newPositionMultiplier = _setToken.positionMultiplier()         .mul(_issueInfo.previousSetTokenSupply.toInt256())         .div(newTotalSupply.toInt256());      return (newTotalSupply, newPositionMultiplier); }  /**  * Calculate deflation and new position multiplier. Note: Round deflation down in order to round position multiplier down  *  * The new position multiplier is calculated as follows:  * deflationPercentage = (oldSupply - newSupply) / newSupply  * newMultiplier = (1 + deflationPercentage) * positionMultiplier  */ function _getRedeemPositionMultiplier(     ISetToken _setToken,     uint256 _setTokenQuantity,     ActionInfo memory _redeemInfo )     internal     view     returns (uint256, int256) {     uint256 newTotalSupply = _redeemInfo.previousSetTokenSupply.sub(_setTokenQuantity);     int256 newPositionMultiplier = _setToken.positionMultiplier()         .mul(_redeemInfo.previousSetTokenSupply.toInt256())         .div(newTotalSupply.toInt256());      return (newTotalSupply, newPositionMultiplier); }  /**  * The new position reserve asset unit is calculated as follows:  * totalReserve = (oldUnit * oldSetTokenSupply) + reserveQuantity  * newUnit = totalReserve / newSetTokenSupply  */ function _getIssuePositionUnit(     ISetToken _setToken,     address _reserveAsset,     ActionInfo memory _issueInfo )     internal     view     returns (uint256) {     uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();     uint256 totalReserve = existingUnit         .preciseMul(_issueInfo.previousSetTokenSupply)         .add(_issueInfo.netFlowQuantity);      return totalReserve.preciseDiv(_issueInfo.newSetTokenSupply); }  /**  * The new position reserve asset unit is calculated as follows:  * totalReserve = (oldUnit * oldSetTokenSupply) - reserveQuantityToSendOut  * newUnit = totalReserve / newSetTokenSupply  */ function _getRedeemPositionUnit(     ISetToken _setToken,     address _reserveAsset,     ActionInfo memory _redeemInfo )     internal     view     returns (uint256) {     uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();     uint256 totalExistingUnits = existingUnit.preciseMul(_redeemInfo.previousSetTokenSupply);      uint256 outflow = _redeemInfo.netFlowQuantity.add(_redeemInfo.protocolFees).add(_redeemInfo.managerFee);      // Require withdrawable quantity is greater than existing collateral     require(totalExistingUnits &gt;= outflow, "Must be greater than total available collateral");      return totalExistingUnits.sub(outflow).preciseDiv(_redeemInfo.newSetTokenSupply); }  /**  * If a pre-issue hook has been configured, call the external-protocol contract. Pre-issue hook logic  * can contain arbitrary logic including validations, external function calls, etc.  */ function _callPreIssueHooks(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity,     address _caller,     address _to )     internal {     INAVIssuanceHook preIssueHook = navIssuanceSettings[_setToken].managerIssuanceHook;     if (address(preIssueHook) != address(0)) {         preIssueHook.invokePreIssueHook(_setToken, _reserveAsset, _reserveAssetQuantity, _caller, _to);     } }  /**  * If a pre-redeem hook has been configured, call the external-protocol contract.  */ function _callPreRedeemHooks(ISetToken _setToken, uint256 _setQuantity, address _caller, address _to) internal {     INAVIssuanceHook preRedeemHook = navIssuanceSettings[_setToken].managerRedemptionHook;     if (address(preRedeemHook) != address(0)) {         preRedeemHook.invokePreRedeemHook(_setToken, _setQuantity, _caller, _to);     } }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '/\n    Copyright 2020 Set Labs Inc.\n\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n/\n\npragma solidity 0.6.10;\npragma experimental "ABIEncoderV2";\n\nimport { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";\nimport { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";\nimport { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";\nimport { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";\nimport { SignedSafeMath } from "@openzeppelin/contracts/math/SignedSafeMath.sol";\n\nimport { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";\nimport { IController } from "../../interfaces/IController.sol";\nimport { INAVIssuanceHook } from "../../interfaces/INAVIssuanceHook.sol";\nimport { Invoke } from "../lib/Invoke.sol";\nimport { ISetToken } from "../../interfaces/ISetToken.sol";\nimport { IWETH } from "../../interfaces/external/IWETH.sol";\nimport { ModuleBase } from "../lib/ModuleBase.sol";\nimport { Position } from "../lib/Position.sol";\nimport { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";\nimport { ResourceIdentifier } from "../lib/ResourceIdentifier.sol";\n\n\n/\n * @title NavIssuanceModule\n * @author Set Protocol\n \n * Module that enables issuance and redemption with any valid ERC20 token or ETH if allowed by the manager. Sender receives\n * a proportional amount of SetTokens on issuance or ERC20 token on redemption based on the calculated net asset value using\n * oracle prices. Manager is able to enforce a premium / discount on issuance / redemption to avoid arbitrage and front\n * running when relying on oracle prices. Managers can charge a fee (denominated in reserve asset).\n /\ncontract NavIssuanceModule is ModuleBase, ReentrancyGuard {\n    using AddressArrayUtils for address[];\n    using Invoke for ISetToken;\n    using Position for ISetToken;\n    using PreciseUnitMath for uint256;\n    using PreciseUnitMath for int256;\n    using ResourceIdentifier for IController;\n    using SafeMath for uint256;\n    using SafeCast for int256;\n    using SafeCast for uint256;\n    using SignedSafeMath for int256;\n\n    / ============ Events ============ /\n\n    event SetTokenNAVIssued(\n        ISetToken indexed _setToken,\n        address _issuer,\n        address _to,\n        address _reserveAsset,\n        address _hookContract,\n        uint256 _setTokenQuantity,\n        uint256 _managerFee,\n        uint256 _premium\n    );\n\n    event SetTokenNAVRedeemed(\n        ISetToken indexed _setToken,\n        address _redeemer,\n        address _to,\n        address _reserveAsset,\n        address _hookContract,\n        uint256 _setTokenQuantity,\n        uint256 _managerFee,\n        uint256 _premium\n    );\n\n    event ReserveAssetAdded(\n        ISetToken indexed _setToken,\n        address _newReserveAsset\n    );\n\n    event ReserveAssetRemoved(\n        ISetToken indexed _setToken,\n        address _removedReserveAsset\n    );\n\n    event PremiumEdited(\n        ISetToken indexed _setToken,\n        uint256 _newPremium\n    );\n\n    event ManagerFeeEdited(\n        ISetToken indexed _setToken,\n        uint256 _newManagerFee,\n        uint256 _index\n    );\n\n    event FeeRecipientEdited(\n        ISetToken indexed _setToken,\n        address _feeRecipient\n    );\n\n    / ============ Structs ============ /\n\n    struct NAVIssuanceSettings {\n        INAVIssuanceHook managerIssuanceHook;      // Issuance hook configurations\n        INAVIssuanceHook managerRedemptionHook;    // Redemption hook configurations\n        address[] reserveAssets;                       // Allowed reserve assets - Must have a price enabled with the price oracle\n        address feeRecipient;                          // Manager fee recipient\n        uint256[2] managerFees;                        // Manager fees. 0 index is issue and 1 index is redeem fee (0.01% = 1e14, 1% = 1e16)\n        uint256 maxManagerFee;                         // Maximum fee manager is allowed to set for issue and redeem\n        uint256 premiumPercentage;                     // Premium percentage (0.01% = 1e14, 1% = 1e16). This premium is a buffer around oracle\n                                                       // prices paid by user to the SetToken, which prevents arbitrage and oracle front running\n        uint256 maxPremiumPercentage;                  // Maximum premium percentage manager is allowed to set (configured by manager)\n        uint256 minSetTokenSupply;                     // Minimum SetToken supply required for issuance and redemption\n                                                       // to prevent dramatic inflationary changes to the SetToken\'s position multiplier\n    }\n\n    struct ActionInfo {\n        uint256 preFeeReserveQuantity;                 // Reserve value before fees; During issuance, represents raw quantity\n                                                       // During redeem, represents post-premium value\n        uint256 protocolFees;                          // Total protocol fees (direct + manager revenue share)\n        uint256 managerFee;                            // Total manager fee paid in reserve asset\n        uint256 netFlowQuantity;                       // When issuing, quantity of reserve asset sent to SetToken\n                                                       // When redeeming, quantity of reserve asset sent to redeemer\n        uint256 setTokenQuantity;                      // When issuing, quantity of SetTokens minted to mintee\n                                                       // When redeeming, quantity of SetToken redeemed\n        uint256 previousSetTokenSupply;                // SetToken supply prior to issue/redeem action\n        uint256 newSetTokenSupply;                     // SetToken supply after issue/redeem action\n        int256 newPositionMultiplier;                  // SetToken position multiplier after issue/redeem\n        uint256 newReservePositionUnit;                // SetToken reserve asset position unit after issue/redeem\n    }\n\n    / ============ State Variables ============ /\n\n    // Wrapped ETH address\n    IWETH public immutable weth;\n\n    // Mapping of SetToken to NAV issuance settings struct\n    mapping(ISetToken =&gt; NAVIssuanceSettings) public navIssuanceSettings;\n\n    // Mapping to efficiently check a SetToken\'s reserve asset validity\n    // SetToken =&gt; reserveAsset =&gt; isReserveAsset\n    mapping(ISetToken =&gt; mapping(address =&gt; bool)) public isReserveAsset;\n\n    / ============ Constants ============ /\n\n    // 0 index stores the manager fee in managerFees array, percentage charged on issue (denominated in reserve asset)\n    uint256 constant internal MANAGER_ISSUE_FEE_INDEX = 0;\n\n    // 1 index stores the manager fee percentage in managerFees array, charged on redeem\n    uint256 constant internal MANAGER_REDEEM_FEE_INDEX = 1;\n\n    // 0 index stores the manager revenue share protocol fee % on the controller, charged in the issuance function\n    uint256 constant internal PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX = 0;\n\n    // 1 index stores the manager revenue share protocol fee % on the controller, charged in the redeem function\n    uint256 constant internal PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX = 1;\n\n    // 2 index stores the direct protocol fee % on the controller, charged in the issuance function\n    uint256 constant internal PROTOCOL_ISSUE_DIRECT_FEE_INDEX = 2;\n\n    // 3 index stores the direct protocol fee % on the controller, charged in the redeem function\n    uint256 constant internal PROTOCOL_REDEEM_DIRECT_FEE_INDEX = 3;\n\n    / ============ Constructor ============ /\n\n    /\n     * @param _controller               Address of controller contract\n     * @param _weth                     Address of wrapped eth\n     /\n    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {\n        weth = _weth;\n    }\n\n    / ============ External Functions ============ /\n\n    /\n     * Deposits the allowed reserve asset into the SetToken and mints the appropriate % of Net Asset Value of the SetToken\n     * to the specified _to address.\n     \n     * @param _setToken                     Instance of the SetToken contract\n     * @param _reserveAsset                 Address of the reserve asset to issue with\n     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with\n     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance\n     * @param _to                           Address to mint SetToken to\n     /\n    function issue(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _reserveAssetQuantity,\n        uint256 _minSetTokenReceiveQuantity,\n        address _to\n    )\n        external\n        nonReentrant\n        onlyValidAndInitializedSet(_setToken)\n    {\n        _validateCommon(_setToken, _reserveAsset, _reserveAssetQuantity);\n\n        _callPreIssueHooks(_setToken, _reserveAsset, _reserveAssetQuantity, msg.sender, _to);\n\n        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, _reserveAsset, _reserveAssetQuantity);\n\n        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);\n\n        _transferCollateralAndHandleFees(_setToken, IERC20(_reserveAsset), issueInfo);\n\n        _handleIssueStateUpdates(_setToken, _reserveAsset, _to, issueInfo);\n    }\n\n    /\n     * Wraps ETH and deposits WETH if allowed into the SetToken and mints the appropriate % of Net Asset Value of the SetToken\n     * to the specified _to address.\n     \n     * @param _setToken                     Instance of the SetToken contract\n     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance\n     * @param _to                           Address to mint SetToken to\n     /\n    function issueWithEther(\n        ISetToken _setToken,\n        uint256 _minSetTokenReceiveQuantity,\n        address _to\n    )\n        external\n        payable\n        nonReentrant\n        onlyValidAndInitializedSet(_setToken)\n    {\n        weth.deposit{ value: msg.value }();\n\n        _validateCommon(_setToken, address(weth), msg.value);\n\n        _callPreIssueHooks(_setToken, address(weth), msg.value, msg.sender, _to);\n\n        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, address(weth), msg.value);\n\n        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);\n\n        _transferWETHAndHandleFees(_setToken, issueInfo);\n\n        _handleIssueStateUpdates(_setToken, address(weth), _to, issueInfo);\n    }\n\n    /\n     * Redeems a SetToken into a valid reserve asset representing the appropriate % of Net Asset Value of the SetToken\n     * to the specified _to address. Only valid if there are available reserve units on the SetToken.\n     \n     * @param _setToken                     Instance of the SetToken contract\n     * @param _reserveAsset                 Address of the reserve asset to redeem with\n     * @param _setTokenQuantity             Quantity of SetTokens to redeem\n     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive\n     * @param _to                           Address to redeem reserve asset to\n     /\n    function redeem(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _setTokenQuantity,\n        uint256 _minReserveReceiveQuantity,\n        address _to\n    )\n        external\n        nonReentrant\n        onlyValidAndInitializedSet(_setToken)\n    {\n        _validateCommon(_setToken, _reserveAsset, _setTokenQuantity);\n\n        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);\n\n        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, _reserveAsset, _setTokenQuantity);\n\n        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);\n\n        _setToken.burn(msg.sender, _setTokenQuantity);\n\n        // Instruct the SetToken to transfer the reserve asset back to the user\n        _setToken.strictInvokeTransfer(\n            _reserveAsset,\n            _to,\n            redeemInfo.netFlowQuantity\n        );\n\n        _handleRedemptionFees(_setToken, _reserveAsset, redeemInfo);\n\n        _handleRedeemStateUpdates(_setToken, _reserveAsset, _to, redeemInfo);\n    }\n\n    /\n     * Redeems a SetToken into Ether (if WETH is valid) representing the appropriate % of Net Asset Value of the SetToken\n     * to the specified _to address. Only valid if there are available WETH units on the SetToken.\n     \n     * @param _setToken                     Instance of the SetToken contract\n     * @param _setTokenQuantity             Quantity of SetTokens to redeem\n     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive\n     * @param _to                           Address to redeem reserve asset to\n     /\n    function redeemIntoEther(\n        ISetToken _setToken,\n        uint256 _setTokenQuantity,\n        uint256 _minReserveReceiveQuantity,\n        address payable _to\n    )\n        external\n        nonReentrant\n        onlyValidAndInitializedSet(_setToken)\n    {\n        _validateCommon(_setToken, address(weth), _setTokenQuantity);\n\n        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);\n\n        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, address(weth), _setTokenQuantity);\n\n        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);\n\n        _setToken.burn(msg.sender, _setTokenQuantity);\n\n        // Instruct the SetToken to transfer WETH from SetToken to module\n        _setToken.strictInvokeTransfer(\n            address(weth),\n            address(this),\n            redeemInfo.netFlowQuantity\n        );\n\n        weth.withdraw(redeemInfo.netFlowQuantity);\n\n        _to.transfer(redeemInfo.netFlowQuantity);\n\n        _handleRedemptionFees(_setToken, address(weth), redeemInfo);\n\n        _handleRedeemStateUpdates(_setToken, address(weth), _to, redeemInfo);\n    }\n\n    /\n     * SET MANAGER ONLY. Add an allowed reserve asset\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _reserveAsset                 Address of the reserve asset to add\n     /\n    function addReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {\n        require(!isReserveAsset[_setToken][_reserveAsset], "Reserve asset already exists");\n\n        navIssuanceSettings[_setToken].reserveAssets.push(_reserveAsset);\n        isReserveAsset[_setToken][_reserveAsset] = true;\n\n        emit ReserveAssetAdded(_setToken, _reserveAsset);\n    }\n\n    /\n     * SET MANAGER ONLY. Remove a reserve asset\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _reserveAsset                 Address of the reserve asset to remove\n     /\n    function removeReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {\n        require(isReserveAsset[_setToken][_reserveAsset], "Reserve asset does not exist");\n\n        navIssuanceSettings[_setToken].reserveAssets = navIssuanceSettings[_setToken].reserveAssets.remove(_reserveAsset);\n        delete isReserveAsset[_setToken][_reserveAsset];\n\n        emit ReserveAssetRemoved(_setToken, _reserveAsset);\n    }\n\n    /\n     * SET MANAGER ONLY. Edit the premium percentage\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _premiumPercentage            Premium percentage in 10e16 (e.g. 10e16 = 1%)\n     /\n    function editPremium(ISetToken _setToken, uint256 _premiumPercentage) external onlyManagerAndValidSet(_setToken) {\n        require(_premiumPercentage &lt;= navIssuanceSettings[_setToken].maxPremiumPercentage, "Premium must be less than maximum allowed");\n\n        navIssuanceSettings[_setToken].premiumPercentage = _premiumPercentage;\n\n        emit PremiumEdited(_setToken, _premiumPercentage);\n    }\n\n    /\n     * SET MANAGER ONLY. Edit manager fee\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _managerFeePercentage         Manager fee percentage in 10e16 (e.g. 10e16 = 1%)\n     * @param _managerFeeIndex              Manager fee index. 0 index is issue fee, 1 index is redeem fee\n     /\n    function editManagerFee(\n        ISetToken _setToken,\n        uint256 _managerFeePercentage,\n        uint256 _managerFeeIndex\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        require(_managerFeePercentage &lt;= navIssuanceSettings[_setToken].maxManagerFee, "Manager fee must be less than maximum allowed");\n\n        navIssuanceSettings[_setToken].managerFees[_managerFeeIndex] = _managerFeePercentage;\n\n        emit ManagerFeeEdited(_setToken, _managerFeePercentage, _managerFeeIndex);\n    }\n\n    /\n     * SET MANAGER ONLY. Edit the manager fee recipient\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _managerFeeRecipient          Manager fee recipient\n     /\n    function editFeeRecipient(ISetToken _setToken, address _managerFeeRecipient) external onlyManagerAndValidSet(_setToken) {\n        require(_managerFeeRecipient != address(0), "Fee recipient must not be 0 address");\n\n        navIssuanceSettings[_setToken].feeRecipient = _managerFeeRecipient;\n\n        emit FeeRecipientEdited(_setToken, _managerFeeRecipient);\n    }\n\n    /\n     * SET MANAGER ONLY. Initializes this module to the SetToken with hooks, allowed reserve assets,\n     * fees and issuance premium. Only callable by the SetToken\'s manager. Hook addresses are optional.\n     * Address(0) means that no hook will be called.\n     \n     * @param _setToken                     Instance of the SetToken to issue\n     * @param _navIssuanceSettings          NAVIssuanceSettings struct defining parameters\n     /\n    function initialize(\n        ISetToken _setToken,\n        NAVIssuanceSettings memory _navIssuanceSettings\n    )\n        external\n        onlySetManager(_setToken, msg.sender)\n        onlyValidAndPendingSet(_setToken)\n    {\n        require(_navIssuanceSettings.reserveAssets.length &gt; 0, "Reserve assets must be greater than 0");\n        require(_navIssuanceSettings.maxManagerFee &lt; PreciseUnitMath.preciseUnit(), "Max manager fee must be less than 100%");\n        require(_navIssuanceSettings.maxPremiumPercentage &lt; PreciseUnitMath.preciseUnit(), "Max premium percentage must be less than 100%");\n        require(_navIssuanceSettings.managerFees[0] &lt;= _navIssuanceSettings.maxManagerFee, "Manager issue fee must be less than max");\n        require(_navIssuanceSettings.managerFees[1] &lt;= _navIssuanceSettings.maxManagerFee, "Manager redeem fee must be less than max");\n        require(_navIssuanceSettings.premiumPercentage &lt;= _navIssuanceSettings.maxPremiumPercentage, "Premium must be less than max");\n        require(_navIssuanceSettings.feeRecipient != address(0), "Fee Recipient must be non-zero address.");\n        // Initial mint of Set cannot use NAVIssuance since minSetTokenSupply must be &gt; 0\n        require(_navIssuanceSettings.minSetTokenSupply &gt; 0, "Min SetToken supply must be greater than 0");\n\n        for (uint256 i = 0; i &lt; _navIssuanceSettings.reserveAssets.length; i++) {\n            require(!isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]], "Reserve assets must be unique");\n            isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]] = true;\n        }\n\n        navIssuanceSettings[_setToken] = _navIssuanceSettings;\n\n        _setToken.initializeModule();\n    }\n\n    /\n     * Removes this module from the SetToken, via call by the SetToken. Issuance settings and\n     * reserve asset states are deleted.\n     /\n    function removeModule() external override {\n        ISetToken setToken = ISetToken(msg.sender);\n        for (uint256 i = 0; i &lt; navIssuanceSettings[setToken].reserveAssets.length; i++) {\n            delete isReserveAsset[setToken][navIssuanceSettings[setToken].reserveAssets[i]];\n        }\n\n        delete navIssuanceSettings[setToken];\n    }\n\n    receive() external payable {}\n\n    / ============ External Getter Functions ============ /\n\n    function getReserveAssets(ISetToken _setToken) external view returns (address[] memory) {\n        return navIssuanceSettings[_setToken].reserveAssets;\n    }\n\n    function getIssuePremium(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _reserveAssetQuantity\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getIssuePremium(_setToken, _reserveAsset, _reserveAssetQuantity);\n    }\n\n    function getRedeemPremium(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _setTokenQuantity\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);\n    }\n\n    function getManagerFee(ISetToken _setToken, uint256 _managerFeeIndex) external view returns (uint256) {\n        return navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];\n    }\n\n    /\n     * Get the expected SetTokens minted to recipient on issuance\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _reserveAsset                 Address of the reserve asset\n     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with\n     \n     * @return  uint256                     Expected SetTokens to be minted to recipient\n     */\n    function getExpectedSetTokenIssueQuantity(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _reserveAssetQuantity\n    )\n        external\n        view\n        returns (uint256)\n    {\n        (,, uint256 netReserveFlow) = _getFees(\n            _setToken,\n            _reserveAssetQuantity,\n            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,\n            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,\n            MANAGER_ISSUE_FEE_INDEX\n        );\n\n        uint256 setTotalSupply = _setToken.totalSupply();\n\n        return _getSetTokenMintQuantity(\n            _setToken,\n            _reserveAsset,\n            netReserveFlow,\n            setTotalSupply\n        );\n    }\n\n    /\n     * Get the expected reserve asset to be redeemed\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _reserveAsset                 Address of the reserve asset\n     * @param _setTokenQuantity             Quantity of SetTokens to redeem\n     \n     * @return  uint256                     Expected reserve asset quantity redeemed\n     /\n    function getExpectedReserveRedeemQuantity(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _setTokenQuantity\n    )\n        external\n        view\n        returns (uint256)\n    {\n        uint256 preFeeReserveQuantity = _getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);\n\n        (,, uint256 netReserveFlows) = _getFees(\n            _setToken,\n            preFeeReserveQuantity,\n            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,\n            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,\n            MANAGER_REDEEM_FEE_INDEX\n        );\n\n        return netReserveFlows;\n    }\n\n    /\n     * Checks if issue is valid\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _reserveAsset                 Address of the reserve asset\n     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with\n     \n     * @return  bool                        Returns true if issue is valid\n     /\n    function isIssueValid(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _reserveAssetQuantity\n    )\n        external\n        view\n        returns (bool)\n    {\n        uint256 setTotalSupply = _setToken.totalSupply();\n\n    return _reserveAssetQuantity != 0\n            &amp;&amp; isReserveAsset[_setToken][_reserveAsset]\n            &amp;&amp; setTotalSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply;\n    }\n\n    /\n     * Checks if redeem is valid\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _reserveAsset                 Address of the reserve asset\n     * @param _setTokenQuantity             Quantity of SetTokens to redeem\n     \n     * @return  bool                        Returns true if redeem is valid\n     /\n    function isRedeemValid(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _setTokenQuantity\n    )\n        external\n        view\n        returns (bool)\n    {\n        uint256 setTotalSupply = _setToken.totalSupply();\n\n        if (\n            _setTokenQuantity == 0\n            || !isReserveAsset[_setToken][_reserveAsset]\n            || setTotalSupply &lt; navIssuanceSettings[_setToken].minSetTokenSupply.add(_setTokenQuantity)\n        ) {\n            return false;\n        } else {\n            uint256 totalRedeemValue =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);\n\n            (,, uint256 expectedRedeemQuantity) = _getFees(\n                _setToken,\n                totalRedeemValue,\n                PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,\n                PROTOCOL_REDEEM_DIRECT_FEE_INDEX,\n                MANAGER_REDEEM_FEE_INDEX\n            );\n\n            uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();\n\n            return existingUnit.preciseMul(setTotalSupply) &gt;= expectedRedeemQuantity;\n        }\n    }\n\n    / ============ Internal Functions ============ */\n\n    function _validateCommon(ISetToken _setToken, address _reserveAsset, uint256 _quantity) internal view {\n        require(_quantity &gt; 0, "Quantity must be &gt; 0");\n        require(isReserveAsset[_setToken][_reserveAsset], "Must be valid reserve asset");\n    }\n\n    function _validateIssuanceInfo(ISetToken _setToken, uint256 _minSetTokenReceiveQuantity, ActionInfo memory _issueInfo) internal view {\n        // Check that total supply is greater than min supply needed for issuance\n        // Note: A min supply amount is needed to avoid division by 0 when SetToken supply is 0\n        require(\n            _issueInfo.previousSetTokenSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply,\n            "Supply must be greater than minimum to enable issuance"\n        );\n\n        require(_issueInfo.setTokenQuantity &gt;= _minSetTokenReceiveQuantity, "Must be greater than min SetToken");\n    }\n\n    function _validateRedemptionInfo(\n        ISetToken _setToken,\n        uint256 _minReserveReceiveQuantity,\n        ActionInfo memory _redeemInfo\n    )\n        internal\n        view\n    {\n        // Check that new supply is more than min supply needed for redemption\n        // Note: A min supply amount is needed to avoid division by 0 when redeeming SetToken to 0\n        require(\n            _redeemInfo.newSetTokenSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply,\n            "Supply must be greater than minimum to enable redemption"\n        );\n\n        require(_redeemInfo.netFlowQuantity &gt;= _minReserveReceiveQuantity, "Must be greater than min receive reserve quantity");\n    }\n\n    function _createIssuanceInfo(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _reserveAssetQuantity\n    )\n        internal\n        view\n        returns (ActionInfo memory)\n    {\n        ActionInfo memory issueInfo;\n\n        issueInfo.previousSetTokenSupply = _setToken.totalSupply();\n\n        issueInfo.preFeeReserveQuantity = _reserveAssetQuantity;\n\n        (issueInfo.protocolFees, issueInfo.managerFee, issueInfo.netFlowQuantity) = _getFees(\n            _setToken,\n            issueInfo.preFeeReserveQuantity,\n            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,\n            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,\n            MANAGER_ISSUE_FEE_INDEX\n        );\n\n        issueInfo.setTokenQuantity = _getSetTokenMintQuantity(\n            _setToken,\n            _reserveAsset,\n            issueInfo.netFlowQuantity,\n            issueInfo.previousSetTokenSupply\n        );\n\n        (issueInfo.newSetTokenSupply, issueInfo.newPositionMultiplier) = _getIssuePositionMultiplier(_setToken, issueInfo);\n\n        issueInfo.newReservePositionUnit = _getIssuePositionUnit(_setToken, _reserveAsset, issueInfo);\n\n        return issueInfo;\n    }\n\n    function _createRedemptionInfo(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _setTokenQuantity\n    )\n        internal\n        view\n        returns (ActionInfo memory)\n    {\n        ActionInfo memory redeemInfo;\n\n        redeemInfo.setTokenQuantity = _setTokenQuantity;\n\n        redeemInfo.preFeeReserveQuantity =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);\n\n        (redeemInfo.protocolFees, redeemInfo.managerFee, redeemInfo.netFlowQuantity) = _getFees(\n            _setToken,\n            redeemInfo.preFeeReserveQuantity,\n            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,\n            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,\n            MANAGER_REDEEM_FEE_INDEX\n        );\n\n        redeemInfo.previousSetTokenSupply = _setToken.totalSupply();\n\n        (redeemInfo.newSetTokenSupply, redeemInfo.newPositionMultiplier) = _getRedeemPositionMultiplier(_setToken, _setTokenQuantity, redeemInfo);\n\n        redeemInfo.newReservePositionUnit = _getRedeemPositionUnit(_setToken, _reserveAsset, redeemInfo);\n\n        return redeemInfo;\n    }\n\n    /\n     * Transfer reserve asset from user to SetToken and fees from user to appropriate fee recipients\n     /\n    function _transferCollateralAndHandleFees(ISetToken _setToken, IERC20 _reserveAsset, ActionInfo memory _issueInfo) internal {\n        transferFrom(_reserveAsset, msg.sender, address(_setToken), _issueInfo.netFlowQuantity);\n\n        if (_issueInfo.protocolFees &gt; 0) {\n            transferFrom(_reserveAsset, msg.sender, controller.feeRecipient(), _issueInfo.protocolFees);\n        }\n\n        if (_issueInfo.managerFee &gt; 0) {\n            transferFrom(_reserveAsset, msg.sender, navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);\n        }\n    }\n\n\n    /\n      * Transfer WETH from module to SetToken and fees from module to appropriate fee recipients\n     /\n    function _transferWETHAndHandleFees(ISetToken _setToken, ActionInfo memory _issueInfo) internal {\n        weth.transfer(address(_setToken), _issueInfo.netFlowQuantity);\n\n        if (_issueInfo.protocolFees &gt; 0) {\n            weth.transfer(controller.feeRecipient(), _issueInfo.protocolFees);\n        }\n\n        if (_issueInfo.managerFee &gt; 0) {\n            weth.transfer(navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);\n        }\n    }\n\n    function _handleIssueStateUpdates(\n        ISetToken _setToken,\n        address _reserveAsset,\n        address _to,\n        ActionInfo memory _issueInfo\n    )\n        internal\n    {\n        _setToken.editPositionMultiplier(_issueInfo.newPositionMultiplier);\n\n        _setToken.editDefaultPosition(_reserveAsset, _issueInfo.newReservePositionUnit);\n\n        _setToken.mint(_to, _issueInfo.setTokenQuantity);\n\n        emit SetTokenNAVIssued(\n            _setToken,\n            msg.sender,\n            _to,\n            _reserveAsset,\n            address(navIssuanceSettings[_setToken].managerIssuanceHook),\n            _issueInfo.setTokenQuantity,\n            _issueInfo.managerFee,\n            _issueInfo.protocolFees\n        );\n    }\n\n    function _handleRedeemStateUpdates(\n        ISetToken _setToken,\n        address _reserveAsset,\n        address _to,\n        ActionInfo memory _redeemInfo\n    )\n        internal\n    {\n        _setToken.editPositionMultiplier(_redeemInfo.newPositionMultiplier);\n\n        _setToken.editDefaultPosition(_reserveAsset, _redeemInfo.newReservePositionUnit);\n\n        emit SetTokenNAVRedeemed(\n            _setToken,\n            msg.sender,\n            _to,\n            _reserveAsset,\n            address(navIssuanceSettings[_setToken].managerRedemptionHook),\n            _redeemInfo.setTokenQuantity,\n            _redeemInfo.managerFee,\n            _redeemInfo.protocolFees\n        );\n    }\n\n    function _handleRedemptionFees(ISetToken _setToken, address _reserveAsset, ActionInfo memory _redeemInfo) internal {\n        // Instruct the SetToken to transfer protocol fee to fee recipient if there is a fee\n        payProtocolFeeFromSetToken(_setToken, _reserveAsset, _redeemInfo.protocolFees);\n\n        // Instruct the SetToken to transfer manager fee to manager fee recipient if there is a fee\n        if (_redeemInfo.managerFee &gt; 0) {\n            _setToken.strictInvokeTransfer(\n                _reserveAsset,\n                navIssuanceSettings[_setToken].feeRecipient,\n                _redeemInfo.managerFee\n            );\n        }\n    }\n\n    /\n     * Returns the issue premium percentage. Virtual function that can be overridden in future versions of the module\n     * and can contain arbitrary logic to calculate the issuance premium.\n     /\n    function _getIssuePremium(\n        ISetToken _setToken,\n        address / _reserveAsset /,\n        uint256 / _reserveAssetQuantity */\n    )\n        virtual\n        internal\n        view\n        returns (uint256)\n    {\n        return navIssuanceSettings[_setToken].premiumPercentage;\n    }\n\n    /\n     * Returns the redeem premium percentage. Virtual function that can be overridden in future versions of the module\n     * and can contain arbitrary logic to calculate the redemption premium.\n     /\n    function _getRedeemPremium(\n        ISetToken _setToken,\n        address / _reserveAsset /,\n        uint256 / _setTokenQuantity /\n    )\n        virtual\n        internal\n        view\n        returns (uint256)\n    {\n        return navIssuanceSettings[_setToken].premiumPercentage;\n    }\n\n    /\n     * Returns the fees attributed to the manager and the protocol. The fees are calculated as follows:\n     \n     * ManagerFee = (manager fee % - % to protocol) * reserveAssetQuantity\n     * Protocol Fee = (% manager fee share + direct fee %) * reserveAssetQuantity\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _reserveAssetQuantity         Quantity of reserve asset to calculate fees from\n     * @param _protocolManagerFeeIndex      Index to pull rev share NAV Issuance fee from the Controller\n     * @param _protocolDirectFeeIndex       Index to pull direct NAV issuance fee from the Controller\n     * @param _managerFeeIndex              Index from NAVIssuanceSettings (0 = issue fee, 1 = redeem fee)\n     \n     * @return  uint256                     Fees paid to the protocol in reserve asset\n     * @return  uint256                     Fees paid to the manager in reserve asset\n     * @return  uint256                     Net reserve to user net of fees\n     /\n    function _getFees(\n        ISetToken _setToken,\n        uint256 _reserveAssetQuantity,\n        uint256 _protocolManagerFeeIndex,\n        uint256 _protocolDirectFeeIndex,\n        uint256 _managerFeeIndex\n    )\n        internal\n        view\n        returns (uint256, uint256, uint256)\n    {\n        (uint256 protocolFeePercentage, uint256 managerFeePercentage) = _getProtocolAndManagerFeePercentages(\n            _setToken,\n            _protocolManagerFeeIndex,\n            _protocolDirectFeeIndex,\n            _managerFeeIndex\n        );\n\n        // Calculate total notional fees\n        uint256 protocolFees = protocolFeePercentage.preciseMul(_reserveAssetQuantity);\n        uint256 managerFee = managerFeePercentage.preciseMul(_reserveAssetQuantity);\n\n        uint256 netReserveFlow = _reserveAssetQuantity.sub(protocolFees).sub(managerFee);\n\n        return (protocolFees, managerFee, netReserveFlow);\n    }\n\n    function _getProtocolAndManagerFeePercentages(\n        ISetToken _setToken,\n        uint256 _protocolManagerFeeIndex,\n        uint256 _protocolDirectFeeIndex,\n        uint256 _managerFeeIndex\n    )\n        internal\n        view\n        returns(uint256, uint256)\n    {\n        // Get protocol fee percentages\n        uint256 protocolDirectFeePercent = controller.getModuleFee(address(this), _protocolDirectFeeIndex);\n        uint256 protocolManagerShareFeePercent = controller.getModuleFee(address(this), _protocolManagerFeeIndex);\n        uint256 managerFeePercent = navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];\n\n        // Calculate revenue share split percentage\n        uint256 protocolRevenueSharePercentage = protocolManagerShareFeePercent.preciseMul(managerFeePercent);\n        uint256 managerRevenueSharePercentage = managerFeePercent.sub(protocolRevenueSharePercentage);\n        uint256 totalProtocolFeePercentage = protocolRevenueSharePercentage.add(protocolDirectFeePercent);\n\n        return (totalProtocolFeePercentage, managerRevenueSharePercentage);\n    }\n\n    function _getSetTokenMintQuantity(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _netReserveFlows,            // Value of reserve asset net of fees\n        uint256 _setTotalSupply\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 premiumPercentage = _getIssuePremium(_setToken, _reserveAsset, _netReserveFlows);\n        uint256 premiumValue = _netReserveFlows.preciseMul(premiumPercentage);\n\n        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (1e18)\n        // Reverts if price is not found\n        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);\n\n        // Get reserve asset decimals\n        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();\n        uint256 normalizedTotalReserveQuantityNetFees = _netReserveFlows.preciseDiv(10 ** reserveAssetDecimals);\n        uint256 normalizedTotalReserveQuantityNetFeesAndPremium = _netReserveFlows.sub(premiumValue).preciseDiv(10 ** reserveAssetDecimals);\n\n        // Calculate SetTokens to mint to issuer\n        uint256 denominator = _setTotalSupply.preciseMul(setTokenValuation).add(normalizedTotalReserveQuantityNetFees).sub(normalizedTotalReserveQuantityNetFeesAndPremium);\n        return normalizedTotalReserveQuantityNetFeesAndPremium.preciseMul(_setTotalSupply).preciseDiv(denominator);\n    }\n\n    function _getRedeemReserveQuantity(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _setTokenQuantity\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (10e18)\n        // Reverts if price is not found\n        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);\n\n        uint256 totalRedeemValueInPreciseUnits = _setTokenQuantity.preciseMul(setTokenValuation);\n        // Get reserve asset decimals\n        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();\n        uint256 prePremiumReserveQuantity = totalRedeemValueInPreciseUnits.preciseMul(10 ** reserveAssetDecimals);\n\n        uint256 premiumPercentage = _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);\n        uint256 premiumQuantity = prePremiumReserveQuantity.preciseMulCeil(premiumPercentage);\n\n        return prePremiumReserveQuantity.sub(premiumQuantity);\n    }\n\n    /\n     * The new position multiplier is calculated as follows:\n     * inflationPercentage = (newSupply - oldSupply) / newSupply\n     * newMultiplier = (1 - inflationPercentage) * positionMultiplier\n     /\n    function _getIssuePositionMultiplier(\n        ISetToken _setToken,\n        ActionInfo memory _issueInfo\n    )\n        internal\n        view\n        returns (uint256, int256)\n    {\n        // Calculate inflation and new position multiplier. Note: Round inflation up in order to round position multiplier down\n        uint256 newTotalSupply = _issueInfo.setTokenQuantity.add(_issueInfo.previousSetTokenSupply);\n        int256 newPositionMultiplier = _setToken.positionMultiplier()\n            .mul(_issueInfo.previousSetTokenSupply.toInt256())\n            .div(newTotalSupply.toInt256());\n\n        return (newTotalSupply, newPositionMultiplier);\n    }\n\n    /\n     * Calculate deflation and new position multiplier. Note: Round deflation down in order to round position multiplier down\n     \n     * The new position multiplier is calculated as follows:\n     * deflationPercentage = (oldSupply - newSupply) / newSupply\n     * newMultiplier = (1 + deflationPercentage) * positionMultiplier\n     /\n    function _getRedeemPositionMultiplier(\n        ISetToken _setToken,\n        uint256 _setTokenQuantity,\n        ActionInfo memory _redeemInfo\n    )\n        internal\n        view\n        returns (uint256, int256)\n    {\n        uint256 newTotalSupply = _redeemInfo.previousSetTokenSupply.sub(_setTokenQuantity);\n        int256 newPositionMultiplier = _setToken.positionMultiplier()\n            .mul(_redeemInfo.previousSetTokenSupply.toInt256())\n            .div(newTotalSupply.toInt256());\n\n        return (newTotalSupply, newPositionMultiplier);\n    }\n\n    /\n     * The new position reserve asset unit is calculated as follows:\n     * totalReserve = (oldUnit * oldSetTokenSupply) + reserveQuantity\n     * newUnit = totalReserve / newSetTokenSupply\n     /\n    function _getIssuePositionUnit(\n        ISetToken _setToken,\n        address _reserveAsset,\n        ActionInfo memory _issueInfo\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();\n        uint256 totalReserve = existingUnit\n            .preciseMul(_issueInfo.previousSetTokenSupply)\n            .add(_issueInfo.netFlowQuantity);\n\n        return totalReserve.preciseDiv(_issueInfo.newSetTokenSupply);\n    }\n\n    /\n     * The new position reserve asset unit is calculated as follows:\n     * totalReserve = (oldUnit * oldSetTokenSupply) - reserveQuantityToSendOut\n     * newUnit = totalReserve / newSetTokenSupply\n     /\n    function _getRedeemPositionUnit(\n        ISetToken _setToken,\n        address _reserveAsset,\n        ActionInfo memory _redeemInfo\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();\n        uint256 totalExistingUnits = existingUnit.preciseMul(_redeemInfo.previousSetTokenSupply);\n\n        uint256 outflow = _redeemInfo.netFlowQuantity.add(_redeemInfo.protocolFees).add(_redeemInfo.managerFee);\n\n        // Require withdrawable quantity is greater than existing collateral\n        require(totalExistingUnits &gt;= outflow, "Must be greater than total available collateral");\n\n        return totalExistingUnits.sub(outflow).preciseDiv(_redeemInfo.newSetTokenSupply);\n    }\n\n    /\n     * If a pre-issue hook has been configured, call the external-protocol contract. Pre-issue hook logic\n     * can contain arbitrary logic including validations, external function calls, etc.\n     */\n    function _callPreIssueHooks(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _reserveAssetQuantity,\n        address _caller,\n        address _to\n    )\n        internal\n    {\n        INAVIssuanceHook preIssueHook = navIssuanceSettings[_setToken].managerIssuanceHook;\n        if (address(preIssueHook) != address(0)) {\n            preIssueHook.invokePreIssueHook(_setToken, _reserveAsset, _reserveAssetQuantity, _caller, _to);\n        }\n    }\n\n    /\n     * If a pre-redeem hook has been configured, call the external-protocol contract.\n     */\n    function _callPreRedeemHooks(ISetToken _setToken, uint256 _setQuantity, address _caller, address _to) internal {\n        INAVIssuanceHook preRedeemHook = navIssuanceSettings[_setToken].managerRedemptionHook;\n        if (address(preRedeemHook) != address(0)) {\n            preRedeemHook.invokePreRedeemHook(_setToken, _setQuantity, _caller, _to);\n        }\n    }\n}', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 05:31:32 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | /*     Copyright 2020 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol"; import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol"; import { SignedSafeMath } from "@openzeppelin/contracts/math/SignedSafeMath.sol"; import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol"; import { IController } from "../../interfaces/IController.sol"; import { INAVIssuanceHook } from "../../interfaces/INAVIssuanceHook.sol"; import { Invoke } from "../lib/Invoke.sol"; import { ISetToken } from "../../interfaces/ISetToken.sol"; import { IWETH } from "../../interfaces/external/IWETH.sol"; import { ModuleBase } from "../lib/ModuleBase.sol"; import { Position } from "../lib/Position.sol"; import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol"; import { ResourceIdentifier } from "../lib/ResourceIdentifier.sol"; /*  * @title NavIssuanceModule  * @author Set Protocol  *  * Module that enables issuance and redemption with any valid ERC20 token or ETH if allowed by the manager. Sender receives  * a proportional amount of SetTokens on issuance or ERC20 token on redemption based on the calculated net asset value using  * oracle prices. Manager is able to enforce a premium / discount on issuance / redemption to avoid arbitrage and front  * running when relying on oracle prices. Managers can charge a fee (denominated in reserve asset).  / contract NavIssuanceModule is ModuleBase, ReentrancyGuard {     using AddressArrayUtils for address[];     using Invoke for ISetToken;     using Position for ISetToken;     using PreciseUnitMath for uint256;     using PreciseUnitMath for int256;     using ResourceIdentifier for IController;     using SafeMath for uint256;     using SafeCast for int256;     using SafeCast for uint256;     using SignedSafeMath for int256; /* ============ Events ============ */  event SetTokenNAVIssued(     ISetToken indexed _setToken,     address _issuer,     address _to,     address _reserveAsset,     address _hookContract,     uint256 _setTokenQuantity,     uint256 _managerFee,     uint256 _premium );  event SetTokenNAVRedeemed(     ISetToken indexed _setToken,     address _redeemer,     address _to,     address _reserveAsset,     address _hookContract,     uint256 _setTokenQuantity,     uint256 _managerFee,     uint256 _premium );  event ReserveAssetAdded(     ISetToken indexed _setToken,     address _newReserveAsset );  event ReserveAssetRemoved(     ISetToken indexed _setToken,     address _removedReserveAsset );  event PremiumEdited(     ISetToken indexed _setToken,     uint256 _newPremium );  event ManagerFeeEdited(     ISetToken indexed _setToken,     uint256 _newManagerFee,     uint256 _index );  event FeeRecipientEdited(     ISetToken indexed _setToken,     address _feeRecipient );  /* ============ Structs ============ */  struct NAVIssuanceSettings {     INAVIssuanceHook managerIssuanceHook;      // Issuance hook configurations     INAVIssuanceHook managerRedemptionHook;    // Redemption hook configurations     address[] reserveAssets;                       // Allowed reserve assets - Must have a price enabled with the price oracle     address feeRecipient;                          // Manager fee recipient     uint256[2] managerFees;                        // Manager fees. 0 index is issue and 1 index is redeem fee (0.01% = 1e14, 1% = 1e16)     uint256 maxManagerFee;                         // Maximum fee manager is allowed to set for issue and redeem     uint256 premiumPercentage;                     // Premium percentage (0.01% = 1e14, 1% = 1e16). This premium is a buffer around oracle                                                    // prices paid by user to the SetToken, which prevents arbitrage and oracle front running     uint256 maxPremiumPercentage;                  // Maximum premium percentage manager is allowed to set (configured by manager)     uint256 minSetTokenSupply;                     // Minimum SetToken supply required for issuance and redemption                                                    // to prevent dramatic inflationary changes to the SetToken's position multiplier }  struct ActionInfo {     uint256 preFeeReserveQuantity;                 // Reserve value before fees; During issuance, represents raw quantity                                                    // During redeem, represents post-premium value     uint256 protocolFees;                          // Total protocol fees (direct + manager revenue share)     uint256 managerFee;                            // Total manager fee paid in reserve asset     uint256 netFlowQuantity;                       // When issuing, quantity of reserve asset sent to SetToken                                                    // When redeeming, quantity of reserve asset sent to redeemer     uint256 setTokenQuantity;                      // When issuing, quantity of SetTokens minted to mintee                                                    // When redeeming, quantity of SetToken redeemed     uint256 previousSetTokenSupply;                // SetToken supply prior to issue/redeem action     uint256 newSetTokenSupply;                     // SetToken supply after issue/redeem action     int256 newPositionMultiplier;                  // SetToken position multiplier after issue/redeem     uint256 newReservePositionUnit;                // SetToken reserve asset position unit after issue/redeem }  /* ============ State Variables ============ */  // Wrapped ETH address IWETH public immutable weth;  // Mapping of SetToken to NAV issuance settings struct mapping(ISetToken =&gt; NAVIssuanceSettings) public navIssuanceSettings;  // Mapping to efficiently check a SetToken's reserve asset validity // SetToken =&gt; reserveAsset =&gt; isReserveAsset mapping(ISetToken =&gt; mapping(address =&gt; bool)) public isReserveAsset;  /* ============ Constants ============ */  // 0 index stores the manager fee in managerFees array, percentage charged on issue (denominated in reserve asset) uint256 constant internal MANAGER_ISSUE_FEE_INDEX = 0;  // 1 index stores the manager fee percentage in managerFees array, charged on redeem uint256 constant internal MANAGER_REDEEM_FEE_INDEX = 1;  // 0 index stores the manager revenue share protocol fee % on the controller, charged in the issuance function uint256 constant internal PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX = 0;  // 1 index stores the manager revenue share protocol fee % on the controller, charged in the redeem function uint256 constant internal PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX = 1;  // 2 index stores the direct protocol fee % on the controller, charged in the issuance function uint256 constant internal PROTOCOL_ISSUE_DIRECT_FEE_INDEX = 2;  // 3 index stores the direct protocol fee % on the controller, charged in the redeem function uint256 constant internal PROTOCOL_REDEEM_DIRECT_FEE_INDEX = 3;  /* ============ Constructor ============ */  /**  * @param _controller               Address of controller contract  * @param _weth                     Address of wrapped eth  */ constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {     weth = _weth; }  /* ============ External Functions ============ */  /**  * Deposits the allowed reserve asset into the SetToken and mints the appropriate % of Net Asset Value of the SetToken  * to the specified _to address.  *  * @param _setToken                     Instance of the SetToken contract  * @param _reserveAsset                 Address of the reserve asset to issue with  * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with  * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance  * @param _to                           Address to mint SetToken to  */ function issue(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity,     uint256 _minSetTokenReceiveQuantity,     address _to )     external     nonReentrant     onlyValidAndInitializedSet(_setToken) {     _validateCommon(_setToken, _reserveAsset, _reserveAssetQuantity);      _callPreIssueHooks(_setToken, _reserveAsset, _reserveAssetQuantity, msg.sender, _to);      ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, _reserveAsset, _reserveAssetQuantity);      _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);      _transferCollateralAndHandleFees(_setToken, IERC20(_reserveAsset), issueInfo);      _handleIssueStateUpdates(_setToken, _reserveAsset, _to, issueInfo); }  /**  * Wraps ETH and deposits WETH if allowed into the SetToken and mints the appropriate % of Net Asset Value of the SetToken  * to the specified _to address.  *  * @param _setToken                     Instance of the SetToken contract  * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance  * @param _to                           Address to mint SetToken to  */ function issueWithEther(     ISetToken _setToken,     uint256 _minSetTokenReceiveQuantity,     address _to )     external     payable     nonReentrant     onlyValidAndInitializedSet(_setToken) {     weth.deposit{ value: msg.value }();      _validateCommon(_setToken, address(weth), msg.value);      _callPreIssueHooks(_setToken, address(weth), msg.value, msg.sender, _to);      ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, address(weth), msg.value);      _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);      _transferWETHAndHandleFees(_setToken, issueInfo);      _handleIssueStateUpdates(_setToken, address(weth), _to, issueInfo); }  /**  * Redeems a SetToken into a valid reserve asset representing the appropriate % of Net Asset Value of the SetToken  * to the specified _to address. Only valid if there are available reserve units on the SetToken.  *  * @param _setToken                     Instance of the SetToken contract  * @param _reserveAsset                 Address of the reserve asset to redeem with  * @param _setTokenQuantity             Quantity of SetTokens to redeem  * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive  * @param _to                           Address to redeem reserve asset to  */ function redeem(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity,     uint256 _minReserveReceiveQuantity,     address _to )     external     nonReentrant     onlyValidAndInitializedSet(_setToken) {     _validateCommon(_setToken, _reserveAsset, _setTokenQuantity);      _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);      ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, _reserveAsset, _setTokenQuantity);      _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);      _setToken.burn(msg.sender, _setTokenQuantity);      // Instruct the SetToken to transfer the reserve asset back to the user     _setToken.strictInvokeTransfer(         _reserveAsset,         _to,         redeemInfo.netFlowQuantity     );      _handleRedemptionFees(_setToken, _reserveAsset, redeemInfo);      _handleRedeemStateUpdates(_setToken, _reserveAsset, _to, redeemInfo); }  /**  * Redeems a SetToken into Ether (if WETH is valid) representing the appropriate % of Net Asset Value of the SetToken  * to the specified _to address. Only valid if there are available WETH units on the SetToken.  *  * @param _setToken                     Instance of the SetToken contract  * @param _setTokenQuantity             Quantity of SetTokens to redeem  * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive  * @param _to                           Address to redeem reserve asset to  */ function redeemIntoEther(     ISetToken _setToken,     uint256 _setTokenQuantity,     uint256 _minReserveReceiveQuantity,     address payable _to )     external     nonReentrant     onlyValidAndInitializedSet(_setToken) {     _validateCommon(_setToken, address(weth), _setTokenQuantity);      _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);      ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, address(weth), _setTokenQuantity);      _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);      _setToken.burn(msg.sender, _setTokenQuantity);      // Instruct the SetToken to transfer WETH from SetToken to module     _setToken.strictInvokeTransfer(         address(weth),         address(this),         redeemInfo.netFlowQuantity     );      weth.withdraw(redeemInfo.netFlowQuantity);      _to.transfer(redeemInfo.netFlowQuantity);      _handleRedemptionFees(_setToken, address(weth), redeemInfo);      _handleRedeemStateUpdates(_setToken, address(weth), _to, redeemInfo); }  /**  * SET MANAGER ONLY. Add an allowed reserve asset  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset to add  */ function addReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {     require(!isReserveAsset[_setToken][_reserveAsset], "Reserve asset already exists");      navIssuanceSettings[_setToken].reserveAssets.push(_reserveAsset);     isReserveAsset[_setToken][_reserveAsset] = true;      emit ReserveAssetAdded(_setToken, _reserveAsset); }  /**  * SET MANAGER ONLY. Remove a reserve asset  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset to remove  */ function removeReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {     require(isReserveAsset[_setToken][_reserveAsset], "Reserve asset does not exist");      navIssuanceSettings[_setToken].reserveAssets = navIssuanceSettings[_setToken].reserveAssets.remove(_reserveAsset);     delete isReserveAsset[_setToken][_reserveAsset];      emit ReserveAssetRemoved(_setToken, _reserveAsset); }  /**  * SET MANAGER ONLY. Edit the premium percentage  *  * @param _setToken                     Instance of the SetToken  * @param _premiumPercentage            Premium percentage in 10e16 (e.g. 10e16 = 1%)  */ function editPremium(ISetToken _setToken, uint256 _premiumPercentage) external onlyManagerAndValidSet(_setToken) {     require(_premiumPercentage &lt;= navIssuanceSettings[_setToken].maxPremiumPercentage, "Premium must be less than maximum allowed");      navIssuanceSettings[_setToken].premiumPercentage = _premiumPercentage;      emit PremiumEdited(_setToken, _premiumPercentage); }  /**  * SET MANAGER ONLY. Edit manager fee  *  * @param _setToken                     Instance of the SetToken  * @param _managerFeePercentage         Manager fee percentage in 10e16 (e.g. 10e16 = 1%)  * @param _managerFeeIndex              Manager fee index. 0 index is issue fee, 1 index is redeem fee  */ function editManagerFee(     ISetToken _setToken,     uint256 _managerFeePercentage,     uint256 _managerFeeIndex )     external     onlyManagerAndValidSet(_setToken) {     require(_managerFeePercentage &lt;= navIssuanceSettings[_setToken].maxManagerFee, "Manager fee must be less than maximum allowed");      navIssuanceSettings[_setToken].managerFees[_managerFeeIndex] = _managerFeePercentage;      emit ManagerFeeEdited(_setToken, _managerFeePercentage, _managerFeeIndex); }  /**  * SET MANAGER ONLY. Edit the manager fee recipient  *  * @param _setToken                     Instance of the SetToken  * @param _managerFeeRecipient          Manager fee recipient  */ function editFeeRecipient(ISetToken _setToken, address _managerFeeRecipient) external onlyManagerAndValidSet(_setToken) {     require(_managerFeeRecipient != address(0), "Fee recipient must not be 0 address");      navIssuanceSettings[_setToken].feeRecipient = _managerFeeRecipient;      emit FeeRecipientEdited(_setToken, _managerFeeRecipient); }  /**  * SET MANAGER ONLY. Initializes this module to the SetToken with hooks, allowed reserve assets,  * fees and issuance premium. Only callable by the SetToken's manager. Hook addresses are optional.  * Address(0) means that no hook will be called.  *  * @param _setToken                     Instance of the SetToken to issue  * @param _navIssuanceSettings          NAVIssuanceSettings struct defining parameters  */ function initialize(     ISetToken _setToken,     NAVIssuanceSettings memory _navIssuanceSettings )     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     require(_navIssuanceSettings.reserveAssets.length &gt; 0, "Reserve assets must be greater than 0");     require(_navIssuanceSettings.maxManagerFee &lt; PreciseUnitMath.preciseUnit(), "Max manager fee must be less than 100%");     require(_navIssuanceSettings.maxPremiumPercentage &lt; PreciseUnitMath.preciseUnit(), "Max premium percentage must be less than 100%");     require(_navIssuanceSettings.managerFees[0] &lt;= _navIssuanceSettings.maxManagerFee, "Manager issue fee must be less than max");     require(_navIssuanceSettings.managerFees[1] &lt;= _navIssuanceSettings.maxManagerFee, "Manager redeem fee must be less than max");     require(_navIssuanceSettings.premiumPercentage &lt;= _navIssuanceSettings.maxPremiumPercentage, "Premium must be less than max");     require(_navIssuanceSettings.feeRecipient != address(0), "Fee Recipient must be non-zero address.");     // Initial mint of Set cannot use NAVIssuance since minSetTokenSupply must be &gt; 0     require(_navIssuanceSettings.minSetTokenSupply &gt; 0, "Min SetToken supply must be greater than 0");      for (uint256 i = 0; i &lt; _navIssuanceSettings.reserveAssets.length; i++) {         require(!isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]], "Reserve assets must be unique");         isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]] = true;     }      navIssuanceSettings[_setToken] = _navIssuanceSettings;      _setToken.initializeModule(); }  /**  * Removes this module from the SetToken, via call by the SetToken. Issuance settings and  * reserve asset states are deleted.  */ function removeModule() external override {     ISetToken setToken = ISetToken(msg.sender);     for (uint256 i = 0; i &lt; navIssuanceSettings[setToken].reserveAssets.length; i++) {         delete isReserveAsset[setToken][navIssuanceSettings[setToken].reserveAssets[i]];     }      delete navIssuanceSettings[setToken]; }  receive() external payable {}  /* ============ External Getter Functions ============ */  function getReserveAssets(ISetToken _setToken) external view returns (address[] memory) {     return navIssuanceSettings[_setToken].reserveAssets; }  function getIssuePremium(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     external     view     returns (uint256) {     return _getIssuePremium(_setToken, _reserveAsset, _reserveAssetQuantity); }  function getRedeemPremium(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     external     view     returns (uint256) {     return _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity); }  function getManagerFee(ISetToken _setToken, uint256 _managerFeeIndex) external view returns (uint256) {     return navIssuanceSettings[_setToken].managerFees[_managerFeeIndex]; }  /**  * Get the expected SetTokens minted to recipient on issuance  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with  *  * @return  uint256                     Expected SetTokens to be minted to recipient  */ function getExpectedSetTokenIssueQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     external     view     returns (uint256) {     (,, uint256 netReserveFlow) = _getFees(         _setToken,         _reserveAssetQuantity,         PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_ISSUE_DIRECT_FEE_INDEX,         MANAGER_ISSUE_FEE_INDEX     );      uint256 setTotalSupply = _setToken.totalSupply();      return _getSetTokenMintQuantity(         _setToken,         _reserveAsset,         netReserveFlow,         setTotalSupply     ); }  /**  * Get the expected reserve asset to be redeemed  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _setTokenQuantity             Quantity of SetTokens to redeem  *  * @return  uint256                     Expected reserve asset quantity redeemed  */ function getExpectedReserveRedeemQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     external     view     returns (uint256) {     uint256 preFeeReserveQuantity = _getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);      (,, uint256 netReserveFlows) = _getFees(         _setToken,         preFeeReserveQuantity,         PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_REDEEM_DIRECT_FEE_INDEX,         MANAGER_REDEEM_FEE_INDEX     );      return netReserveFlows; }  /**  * Checks if issue is valid  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with  *  * @return  bool                        Returns true if issue is valid  */ function isIssueValid(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     external     view     returns (bool) {     uint256 setTotalSupply = _setToken.totalSupply();  return _reserveAssetQuantity != 0         &amp;&amp; isReserveAsset[_setToken][_reserveAsset]         &amp;&amp; setTotalSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply; }  /**  * Checks if redeem is valid  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _setTokenQuantity             Quantity of SetTokens to redeem  *  * @return  bool                        Returns true if redeem is valid  */ function isRedeemValid(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     external     view     returns (bool) {     uint256 setTotalSupply = _setToken.totalSupply();      if (         _setTokenQuantity == 0         || !isReserveAsset[_setToken][_reserveAsset]         || setTotalSupply &lt; navIssuanceSettings[_setToken].minSetTokenSupply.add(_setTokenQuantity)     ) {         return false;     } else {         uint256 totalRedeemValue =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);          (,, uint256 expectedRedeemQuantity) = _getFees(             _setToken,             totalRedeemValue,             PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,             PROTOCOL_REDEEM_DIRECT_FEE_INDEX,             MANAGER_REDEEM_FEE_INDEX         );          uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();          return existingUnit.preciseMul(setTotalSupply) &gt;= expectedRedeemQuantity;     } }  /* ============ Internal Functions ============ */  function _validateCommon(ISetToken _setToken, address _reserveAsset, uint256 _quantity) internal view {     require(_quantity &gt; 0, "Quantity must be &gt; 0");     require(isReserveAsset[_setToken][_reserveAsset], "Must be valid reserve asset"); }  function _validateIssuanceInfo(ISetToken _setToken, uint256 _minSetTokenReceiveQuantity, ActionInfo memory _issueInfo) internal view {     // Check that total supply is greater than min supply needed for issuance     // Note: A min supply amount is needed to avoid division by 0 when SetToken supply is 0     require(         _issueInfo.previousSetTokenSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply,         "Supply must be greater than minimum to enable issuance"     );      require(_issueInfo.setTokenQuantity &gt;= _minSetTokenReceiveQuantity, "Must be greater than min SetToken"); }  function _validateRedemptionInfo(     ISetToken _setToken,     uint256 _minReserveReceiveQuantity,     ActionInfo memory _redeemInfo )     internal     view {     // Check that new supply is more than min supply needed for redemption     // Note: A min supply amount is needed to avoid division by 0 when redeeming SetToken to 0     require(         _redeemInfo.newSetTokenSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply,         "Supply must be greater than minimum to enable redemption"     );      require(_redeemInfo.netFlowQuantity &gt;= _minReserveReceiveQuantity, "Must be greater than min receive reserve quantity"); }  function _createIssuanceInfo(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     internal     view     returns (ActionInfo memory) {     ActionInfo memory issueInfo;      issueInfo.previousSetTokenSupply = _setToken.totalSupply();      issueInfo.preFeeReserveQuantity = _reserveAssetQuantity;      (issueInfo.protocolFees, issueInfo.managerFee, issueInfo.netFlowQuantity) = _getFees(         _setToken,         issueInfo.preFeeReserveQuantity,         PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_ISSUE_DIRECT_FEE_INDEX,         MANAGER_ISSUE_FEE_INDEX     );      issueInfo.setTokenQuantity = _getSetTokenMintQuantity(         _setToken,         _reserveAsset,         issueInfo.netFlowQuantity,         issueInfo.previousSetTokenSupply     );      (issueInfo.newSetTokenSupply, issueInfo.newPositionMultiplier) = _getIssuePositionMultiplier(_setToken, issueInfo);      issueInfo.newReservePositionUnit = _getIssuePositionUnit(_setToken, _reserveAsset, issueInfo);      return issueInfo; }  function _createRedemptionInfo(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     internal     view     returns (ActionInfo memory) {     ActionInfo memory redeemInfo;      redeemInfo.setTokenQuantity = _setTokenQuantity;      redeemInfo.preFeeReserveQuantity =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);      (redeemInfo.protocolFees, redeemInfo.managerFee, redeemInfo.netFlowQuantity) = _getFees(         _setToken,         redeemInfo.preFeeReserveQuantity,         PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_REDEEM_DIRECT_FEE_INDEX,         MANAGER_REDEEM_FEE_INDEX     );      redeemInfo.previousSetTokenSupply = _setToken.totalSupply();      (redeemInfo.newSetTokenSupply, redeemInfo.newPositionMultiplier) = _getRedeemPositionMultiplier(_setToken, _setTokenQuantity, redeemInfo);      redeemInfo.newReservePositionUnit = _getRedeemPositionUnit(_setToken, _reserveAsset, redeemInfo);      return redeemInfo; }  /**  * Transfer reserve asset from user to SetToken and fees from user to appropriate fee recipients  */ function _transferCollateralAndHandleFees(ISetToken _setToken, IERC20 _reserveAsset, ActionInfo memory _issueInfo) internal {     transferFrom(_reserveAsset, msg.sender, address(_setToken), _issueInfo.netFlowQuantity);      if (_issueInfo.protocolFees &gt; 0) {         transferFrom(_reserveAsset, msg.sender, controller.feeRecipient(), _issueInfo.protocolFees);     }      if (_issueInfo.managerFee &gt; 0) {         transferFrom(_reserveAsset, msg.sender, navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);     } }   /**   * Transfer WETH from module to SetToken and fees from module to appropriate fee recipients  */ function _transferWETHAndHandleFees(ISetToken _setToken, ActionInfo memory _issueInfo) internal {     weth.transfer(address(_setToken), _issueInfo.netFlowQuantity);      if (_issueInfo.protocolFees &gt; 0) {         weth.transfer(controller.feeRecipient(), _issueInfo.protocolFees);     }      if (_issueInfo.managerFee &gt; 0) {         weth.transfer(navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);     } }  function _handleIssueStateUpdates(     ISetToken _setToken,     address _reserveAsset,     address _to,     ActionInfo memory _issueInfo )     internal {     _setToken.editPositionMultiplier(_issueInfo.newPositionMultiplier);      _setToken.editDefaultPosition(_reserveAsset, _issueInfo.newReservePositionUnit);      _setToken.mint(_to, _issueInfo.setTokenQuantity);      emit SetTokenNAVIssued(         _setToken,         msg.sender,         _to,         _reserveAsset,         address(navIssuanceSettings[_setToken].managerIssuanceHook),         _issueInfo.setTokenQuantity,         _issueInfo.managerFee,         _issueInfo.protocolFees     ); }  function _handleRedeemStateUpdates(     ISetToken _setToken,     address _reserveAsset,     address _to,     ActionInfo memory _redeemInfo )     internal {     _setToken.editPositionMultiplier(_redeemInfo.newPositionMultiplier);      _setToken.editDefaultPosition(_reserveAsset, _redeemInfo.newReservePositionUnit);      emit SetTokenNAVRedeemed(         _setToken,         msg.sender,         _to,         _reserveAsset,         address(navIssuanceSettings[_setToken].managerRedemptionHook),         _redeemInfo.setTokenQuantity,         _redeemInfo.managerFee,         _redeemInfo.protocolFees     ); }  function _handleRedemptionFees(ISetToken _setToken, address _reserveAsset, ActionInfo memory _redeemInfo) internal {     // Instruct the SetToken to transfer protocol fee to fee recipient if there is a fee     payProtocolFeeFromSetToken(_setToken, _reserveAsset, _redeemInfo.protocolFees);      // Instruct the SetToken to transfer manager fee to manager fee recipient if there is a fee     if (_redeemInfo.managerFee &gt; 0) {         _setToken.strictInvokeTransfer(             _reserveAsset,             navIssuanceSettings[_setToken].feeRecipient,             _redeemInfo.managerFee         );     } }  /**  * Returns the issue premium percentage. Virtual function that can be overridden in future versions of the module  * and can contain arbitrary logic to calculate the issuance premium.  */ function _getIssuePremium(     ISetToken _setToken,     address /* _reserveAsset */,     uint256 /* _reserveAssetQuantity */ )     virtual     internal     view     returns (uint256) {     return navIssuanceSettings[_setToken].premiumPercentage; }  /**  * Returns the redeem premium percentage. Virtual function that can be overridden in future versions of the module  * and can contain arbitrary logic to calculate the redemption premium.  */ function _getRedeemPremium(     ISetToken _setToken,     address /* _reserveAsset */,     uint256 /* _setTokenQuantity */ )     virtual     internal     view     returns (uint256) {     return navIssuanceSettings[_setToken].premiumPercentage; }  /**  * Returns the fees attributed to the manager and the protocol. The fees are calculated as follows:  *  * ManagerFee = (manager fee % - % to protocol) * reserveAssetQuantity  * Protocol Fee = (% manager fee share + direct fee %) * reserveAssetQuantity  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAssetQuantity         Quantity of reserve asset to calculate fees from  * @param _protocolManagerFeeIndex      Index to pull rev share NAV Issuance fee from the Controller  * @param _protocolDirectFeeIndex       Index to pull direct NAV issuance fee from the Controller  * @param _managerFeeIndex              Index from NAVIssuanceSettings (0 = issue fee, 1 = redeem fee)  *  * @return  uint256                     Fees paid to the protocol in reserve asset  * @return  uint256                     Fees paid to the manager in reserve asset  * @return  uint256                     Net reserve to user net of fees  */ function _getFees(     ISetToken _setToken,     uint256 _reserveAssetQuantity,     uint256 _protocolManagerFeeIndex,     uint256 _protocolDirectFeeIndex,     uint256 _managerFeeIndex )     internal     view     returns (uint256, uint256, uint256) {     (uint256 protocolFeePercentage, uint256 managerFeePercentage) = _getProtocolAndManagerFeePercentages(         _setToken,         _protocolManagerFeeIndex,         _protocolDirectFeeIndex,         _managerFeeIndex     );      // Calculate total notional fees     uint256 protocolFees = protocolFeePercentage.preciseMul(_reserveAssetQuantity);     uint256 managerFee = managerFeePercentage.preciseMul(_reserveAssetQuantity);      uint256 netReserveFlow = _reserveAssetQuantity.sub(protocolFees).sub(managerFee);      return (protocolFees, managerFee, netReserveFlow); }  function _getProtocolAndManagerFeePercentages(     ISetToken _setToken,     uint256 _protocolManagerFeeIndex,     uint256 _protocolDirectFeeIndex,     uint256 _managerFeeIndex )     internal     view     returns(uint256, uint256) {     // Get protocol fee percentages     uint256 protocolDirectFeePercent = controller.getModuleFee(address(this), _protocolDirectFeeIndex);     uint256 protocolManagerShareFeePercent = controller.getModuleFee(address(this), _protocolManagerFeeIndex);     uint256 managerFeePercent = navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];      // Calculate revenue share split percentage     uint256 protocolRevenueSharePercentage = protocolManagerShareFeePercent.preciseMul(managerFeePercent);     uint256 managerRevenueSharePercentage = managerFeePercent.sub(protocolRevenueSharePercentage);     uint256 totalProtocolFeePercentage = protocolRevenueSharePercentage.add(protocolDirectFeePercent);      return (totalProtocolFeePercentage, managerRevenueSharePercentage); }  function _getSetTokenMintQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _netReserveFlows,            // Value of reserve asset net of fees     uint256 _setTotalSupply )     internal     view     returns (uint256) {     uint256 premiumPercentage = _getIssuePremium(_setToken, _reserveAsset, _netReserveFlows);     uint256 premiumValue = _netReserveFlows.preciseMul(premiumPercentage);      // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (1e18)     // Reverts if price is not found     uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);      // Get reserve asset decimals     uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();     uint256 normalizedTotalReserveQuantityNetFees = _netReserveFlows.preciseDiv(10 ** reserveAssetDecimals);     uint256 normalizedTotalReserveQuantityNetFeesAndPremium = _netReserveFlows.sub(premiumValue).preciseDiv(10 ** reserveAssetDecimals);      // Calculate SetTokens to mint to issuer     uint256 denominator = _setTotalSupply.preciseMul(setTokenValuation).add(normalizedTotalReserveQuantityNetFees).sub(normalizedTotalReserveQuantityNetFeesAndPremium);     return normalizedTotalReserveQuantityNetFeesAndPremium.preciseMul(_setTotalSupply).preciseDiv(denominator); }  function _getRedeemReserveQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     internal     view     returns (uint256) {     // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (10e18)     // Reverts if price is not found     uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);      uint256 totalRedeemValueInPreciseUnits = _setTokenQuantity.preciseMul(setTokenValuation);     // Get reserve asset decimals     uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();     uint256 prePremiumReserveQuantity = totalRedeemValueInPreciseUnits.preciseMul(10 ** reserveAssetDecimals);      uint256 premiumPercentage = _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);     uint256 premiumQuantity = prePremiumReserveQuantity.preciseMulCeil(premiumPercentage);      return prePremiumReserveQuantity.sub(premiumQuantity); }  /**  * The new position multiplier is calculated as follows:  * inflationPercentage = (newSupply - oldSupply) / newSupply  * newMultiplier = (1 - inflationPercentage) * positionMultiplier  */ function _getIssuePositionMultiplier(     ISetToken _setToken,     ActionInfo memory _issueInfo )     internal     view     returns (uint256, int256) {     // Calculate inflation and new position multiplier. Note: Round inflation up in order to round position multiplier down     uint256 newTotalSupply = _issueInfo.setTokenQuantity.add(_issueInfo.previousSetTokenSupply);     int256 newPositionMultiplier = _setToken.positionMultiplier()         .mul(_issueInfo.previousSetTokenSupply.toInt256())         .div(newTotalSupply.toInt256());      return (newTotalSupply, newPositionMultiplier); }  /**  * Calculate deflation and new position multiplier. Note: Round deflation down in order to round position multiplier down  *  * The new position multiplier is calculated as follows:  * deflationPercentage = (oldSupply - newSupply) / newSupply  * newMultiplier = (1 + deflationPercentage) * positionMultiplier  */ function _getRedeemPositionMultiplier(     ISetToken _setToken,     uint256 _setTokenQuantity,     ActionInfo memory _redeemInfo )     internal     view     returns (uint256, int256) {     uint256 newTotalSupply = _redeemInfo.previousSetTokenSupply.sub(_setTokenQuantity);     int256 newPositionMultiplier = _setToken.positionMultiplier()         .mul(_redeemInfo.previousSetTokenSupply.toInt256())         .div(newTotalSupply.toInt256());      return (newTotalSupply, newPositionMultiplier); }  /**  * The new position reserve asset unit is calculated as follows:  * totalReserve = (oldUnit * oldSetTokenSupply) + reserveQuantity  * newUnit = totalReserve / newSetTokenSupply  */ function _getIssuePositionUnit(     ISetToken _setToken,     address _reserveAsset,     ActionInfo memory _issueInfo )     internal     view     returns (uint256) {     uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();     uint256 totalReserve = existingUnit         .preciseMul(_issueInfo.previousSetTokenSupply)         .add(_issueInfo.netFlowQuantity);      return totalReserve.preciseDiv(_issueInfo.newSetTokenSupply); }  /**  * The new position reserve asset unit is calculated as follows:  * totalReserve = (oldUnit * oldSetTokenSupply) - reserveQuantityToSendOut  * newUnit = totalReserve / newSetTokenSupply  */ function _getRedeemPositionUnit(     ISetToken _setToken,     address _reserveAsset,     ActionInfo memory _redeemInfo )     internal     view     returns (uint256) {     uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();     uint256 totalExistingUnits = existingUnit.preciseMul(_redeemInfo.previousSetTokenSupply);      uint256 outflow = _redeemInfo.netFlowQuantity.add(_redeemInfo.protocolFees).add(_redeemInfo.managerFee);      // Require withdrawable quantity is greater than existing collateral     require(totalExistingUnits &gt;= outflow, "Must be greater than total available collateral");      return totalExistingUnits.sub(outflow).preciseDiv(_redeemInfo.newSetTokenSupply); }  /**  * If a pre-issue hook has been configured, call the external-protocol contract. Pre-issue hook logic  * can contain arbitrary logic including validations, external function calls, etc.  */ function _callPreIssueHooks(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity,     address _caller,     address _to )     internal {     INAVIssuanceHook preIssueHook = navIssuanceSettings[_setToken].managerIssuanceHook;     if (address(preIssueHook) != address(0)) {         preIssueHook.invokePreIssueHook(_setToken, _reserveAsset, _reserveAssetQuantity, _caller, _to);     } }  /**  * If a pre-redeem hook has been configured, call the external-protocol contract.  */ function _callPreRedeemHooks(ISetToken _setToken, uint256 _setQuantity, address _caller, address _to) internal {     INAVIssuanceHook preRedeemHook = navIssuanceSettings[_setToken].managerRedemptionHook;     if (address(preRedeemHook) != address(0)) {         preRedeemHook.invokePreRedeemHook(_setToken, _setQuantity, _caller, _to);     } }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 05:31:32 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: /*
    Copyright 2020 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";
import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";
import { SignedSafeMath } from "@openzeppelin/contracts/math/SignedSafeMath.sol";

import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";
import { IController } from "../../interfaces/IController.sol";
import { INAVIssuanceHook } from "../../interfaces/INAVIssuanceHook.sol";
import { Invoke } from "../lib/Invoke.sol";
import { ISetToken } from "../../interfaces/ISetToken.sol";
import { IWETH } from "../../interfaces/external/IWETH.sol";
import { ModuleBase } from "../lib/ModuleBase.sol";
import { Position } from "../lib/Position.sol";
import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";
import { ResourceIdentifier } from "../lib/ResourceIdentifier.sol";


/**
 * @title NavIssuanceModule
 * @author Set Protocol
 *
 * Module that enables issuance and redemption with any valid ERC20 token or ETH if allowed by the manager. Sender receives
 * a proportional amount of SetTokens on issuance or ERC20 token on redemption based on the calculated net asset value using
 * oracle prices. Manager is able to enforce a premium / discount on issuance / redemption to avoid arbitrage and front
 * running when relying on oracle prices. Managers can charge a fee (denominated in reserve asset).
 */
contract NavIssuanceModule is ModuleBase, ReentrancyGuard {
    using AddressArrayUtils for address[];
    using Invoke for ISetToken;
    using Position for ISetToken;
    using PreciseUnitMath for uint256;
    using PreciseUnitMath for int256;
    using ResourceIdentifier for IController;
    using SafeMath for uint256;
    using SafeCast for int256;
    using SafeCast for uint256;
    using SignedSafeMath for int256;

    /* ============ Events ============ */

    event SetTokenNAVIssued(
        ISetToken indexed _setToken,
        address _issuer,
        address _to,
        address _reserveAsset,
        address _hookContract,
        uint256 _setTokenQuantity,
        uint256 _managerFee,
        uint256 _premium
    );

    event SetTokenNAVRedeemed(
        ISetToken indexed _setToken,
        address _redeemer,
        address _to,
        address _reserveAsset,
        address _hookContract,
        uint256 _setTokenQuantity,
        uint256 _managerFee,
        uint256 _premium
    );

    event ReserveAssetAdded(
        ISetToken indexed _setToken,
        address _newReserveAsset
    );

    event ReserveAssetRemoved(
        ISetToken indexed _setToken,
        address _removedReserveAsset
    );

    event PremiumEdited(
        ISetToken indexed _setToken,
        uint256 _newPremium
    );

    event ManagerFeeEdited(
        ISetToken indexed _setToken,
        uint256 _newManagerFee,
        uint256 _index
    );

    event FeeRecipientEdited(
        ISetToken indexed _setToken,
        address _feeRecipient
    );

    /* ============ Structs ============ */

    struct NAVIssuanceSettings {
        INAVIssuanceHook managerIssuanceHook;      // Issuance hook configurations
        INAVIssuanceHook managerRedemptionHook;    // Redemption hook configurations
        address[] reserveAssets;                       // Allowed reserve assets - Must have a price enabled with the price oracle
        address feeRecipient;                          // Manager fee recipient
        uint256[2] managerFees;                        // Manager fees. 0 index is issue and 1 index is redeem fee (0.01% = 1e14, 1% = 1e16)
        uint256 maxManagerFee;                         // Maximum fee manager is allowed to set for issue and redeem
        uint256 premiumPercentage;                     // Premium percentage (0.01% = 1e14, 1% = 1e16). This premium is a buffer around oracle
                                                       // prices paid by user to the SetToken, which prevents arbitrage and oracle front running
        uint256 maxPremiumPercentage;                  // Maximum premium percentage manager is allowed to set (configured by manager)
        uint256 minSetTokenSupply;                     // Minimum SetToken supply required for issuance and redemption
                                                       // to prevent dramatic inflationary changes to the SetToken's position multiplier
    }

    struct ActionInfo {
        uint256 preFeeReserveQuantity;                 // Reserve value before fees; During issuance, represents raw quantity
                                                       // During redeem, represents post-premium value
        uint256 protocolFees;                          // Total protocol fees (direct + manager revenue share)
        uint256 managerFee;                            // Total manager fee paid in reserve asset
        uint256 netFlowQuantity;                       // When issuing, quantity of reserve asset sent to SetToken
                                                       // When redeeming, quantity of reserve asset sent to redeemer
        uint256 setTokenQuantity;                      // When issuing, quantity of SetTokens minted to mintee
                                                       // When redeeming, quantity of SetToken redeemed
        uint256 previousSetTokenSupply;                // SetToken supply prior to issue/redeem action
        uint256 newSetTokenSupply;                     // SetToken supply after issue/redeem action
        int256 newPositionMultiplier;                  // SetToken position multiplier after issue/redeem
        uint256 newReservePositionUnit;                // SetToken reserve asset position unit after issue/redeem
    }

    /* ============ State Variables ============ */

    // Wrapped ETH address
    IWETH public immutable weth;

    // Mapping of SetToken to NAV issuance settings struct
    mapping(ISetToken => NAVIssuanceSettings) public navIssuanceSettings;

    // Mapping to efficiently check a SetToken's reserve asset validity
    // SetToken => reserveAsset => isReserveAsset
    mapping(ISetToken => mapping(address => bool)) public isReserveAsset;

    /* ============ Constants ============ */

    // 0 index stores the manager fee in managerFees array, percentage charged on issue (denominated in reserve asset)
    uint256 constant internal MANAGER_ISSUE_FEE_INDEX = 0;

    // 1 index stores the manager fee percentage in managerFees array, charged on redeem
    uint256 constant internal MANAGER_REDEEM_FEE_INDEX = 1;

    // 0 index stores the manager revenue share protocol fee % on the controller, charged in the issuance function
    uint256 constant internal PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX = 0;

    // 1 index stores the manager revenue share protocol fee % on the controller, charged in the redeem function
    uint256 constant internal PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX = 1;

    // 2 index stores the direct protocol fee % on the controller, charged in the issuance function
    uint256 constant internal PROTOCOL_ISSUE_DIRECT_FEE_INDEX = 2;

    // 3 index stores the direct protocol fee % on the controller, charged in the redeem function
    uint256 constant internal PROTOCOL_REDEEM_DIRECT_FEE_INDEX = 3;

    /* ============ Constructor ============ */

    /**
     * @param _controller               Address of controller contract
     * @param _weth                     Address of wrapped eth
     */
    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {
        weth = _weth;
    }

    /* ============ External Functions ============ */

    /**
     * Deposits the allowed reserve asset into the SetToken and mints the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _reserveAsset                 Address of the reserve asset to issue with
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance
     * @param _to                           Address to mint SetToken to
     */
    function issue(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity,
        uint256 _minSetTokenReceiveQuantity,
        address _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, _reserveAsset, _reserveAssetQuantity);

        _callPreIssueHooks(_setToken, _reserveAsset, _reserveAssetQuantity, msg.sender, _to);

        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, _reserveAsset, _reserveAssetQuantity);

        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);

        _transferCollateralAndHandleFees(_setToken, IERC20(_reserveAsset), issueInfo);

        _handleIssueStateUpdates(_setToken, _reserveAsset, _to, issueInfo);
    }

    /**
     * Wraps ETH and deposits WETH if allowed into the SetToken and mints the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance
     * @param _to                           Address to mint SetToken to
     */
    function issueWithEther(
        ISetToken _setToken,
        uint256 _minSetTokenReceiveQuantity,
        address _to
    )
        external
        payable
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        weth.deposit{ value: msg.value }();

        _validateCommon(_setToken, address(weth), msg.value);

        _callPreIssueHooks(_setToken, address(weth), msg.value, msg.sender, _to);

        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, address(weth), msg.value);

        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);

        _transferWETHAndHandleFees(_setToken, issueInfo);

        _handleIssueStateUpdates(_setToken, address(weth), _to, issueInfo);
    }

    /**
     * Redeems a SetToken into a valid reserve asset representing the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address. Only valid if there are available reserve units on the SetToken.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _reserveAsset                 Address of the reserve asset to redeem with
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive
     * @param _to                           Address to redeem reserve asset to
     */
    function redeem(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity,
        uint256 _minReserveReceiveQuantity,
        address _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, _reserveAsset, _setTokenQuantity);

        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);

        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, _reserveAsset, _setTokenQuantity);

        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);

        _setToken.burn(msg.sender, _setTokenQuantity);

        // Instruct the SetToken to transfer the reserve asset back to the user
        _setToken.strictInvokeTransfer(
            _reserveAsset,
            _to,
            redeemInfo.netFlowQuantity
        );

        _handleRedemptionFees(_setToken, _reserveAsset, redeemInfo);

        _handleRedeemStateUpdates(_setToken, _reserveAsset, _to, redeemInfo);
    }

    /**
     * Redeems a SetToken into Ether (if WETH is valid) representing the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address. Only valid if there are available WETH units on the SetToken.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive
     * @param _to                           Address to redeem reserve asset to
     */
    function redeemIntoEther(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        uint256 _minReserveReceiveQuantity,
        address payable _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, address(weth), _setTokenQuantity);

        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);

        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, address(weth), _setTokenQuantity);

        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);

        _setToken.burn(msg.sender, _setTokenQuantity);

        // Instruct the SetToken to transfer WETH from SetToken to module
        _setToken.strictInvokeTransfer(
            address(weth),
            address(this),
            redeemInfo.netFlowQuantity
        );

        weth.withdraw(redeemInfo.netFlowQuantity);

        _to.transfer(redeemInfo.netFlowQuantity);

        _handleRedemptionFees(_setToken, address(weth), redeemInfo);

        _handleRedeemStateUpdates(_setToken, address(weth), _to, redeemInfo);
    }

    /**
     * SET MANAGER ONLY. Add an allowed reserve asset
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset to add
     */
    function addReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {
        require(!isReserveAsset[_setToken][_reserveAsset], "Reserve asset already exists");

        navIssuanceSettings[_setToken].reserveAssets.push(_reserveAsset);
        isReserveAsset[_setToken][_reserveAsset] = true;

        emit ReserveAssetAdded(_setToken, _reserveAsset);
    }

    /**
     * SET MANAGER ONLY. Remove a reserve asset
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset to remove
     */
    function removeReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {
        require(isReserveAsset[_setToken][_reserveAsset], "Reserve asset does not exist");

        navIssuanceSettings[_setToken].reserveAssets = navIssuanceSettings[_setToken].reserveAssets.remove(_reserveAsset);
        delete isReserveAsset[_setToken][_reserveAsset];

        emit ReserveAssetRemoved(_setToken, _reserveAsset);
    }

    /**
     * SET MANAGER ONLY. Edit the premium percentage
     *
     * @param _setToken                     Instance of the SetToken
     * @param _premiumPercentage            Premium percentage in 10e16 (e.g. 10e16 = 1%)
     */
    function editPremium(ISetToken _setToken, uint256 _premiumPercentage) external onlyManagerAndValidSet(_setToken) {
        require(_premiumPercentage <= navIssuanceSettings[_setToken].maxPremiumPercentage, "Premium must be less than maximum allowed");

        navIssuanceSettings[_setToken].premiumPercentage = _premiumPercentage;

        emit PremiumEdited(_setToken, _premiumPercentage);
    }

    /**
     * SET MANAGER ONLY. Edit manager fee
     *
     * @param _setToken                     Instance of the SetToken
     * @param _managerFeePercentage         Manager fee percentage in 10e16 (e.g. 10e16 = 1%)
     * @param _managerFeeIndex              Manager fee index. 0 index is issue fee, 1 index is redeem fee
     */
    function editManagerFee(
        ISetToken _setToken,
        uint256 _managerFeePercentage,
        uint256 _managerFeeIndex
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        require(_managerFeePercentage <= navIssuanceSettings[_setToken].maxManagerFee, "Manager fee must be less than maximum allowed");

        navIssuanceSettings[_setToken].managerFees[_managerFeeIndex] = _managerFeePercentage;

        emit ManagerFeeEdited(_setToken, _managerFeePercentage, _managerFeeIndex);
    }

    /**
     * SET MANAGER ONLY. Edit the manager fee recipient
     *
     * @param _setToken                     Instance of the SetToken
     * @param _managerFeeRecipient          Manager fee recipient
     */
    function editFeeRecipient(ISetToken _setToken, address _managerFeeRecipient) external onlyManagerAndValidSet(_setToken) {
        require(_managerFeeRecipient != address(0), "Fee recipient must not be 0 address");

        navIssuanceSettings[_setToken].feeRecipient = _managerFeeRecipient;

        emit FeeRecipientEdited(_setToken, _managerFeeRecipient);
    }

    /**
     * SET MANAGER ONLY. Initializes this module to the SetToken with hooks, allowed reserve assets,
     * fees and issuance premium. Only callable by the SetToken's manager. Hook addresses are optional.
     * Address(0) means that no hook will be called.
     *
     * @param _setToken                     Instance of the SetToken to issue
     * @param _navIssuanceSettings          NAVIssuanceSettings struct defining parameters
     */
    function initialize(
        ISetToken _setToken,
        NAVIssuanceSettings memory _navIssuanceSettings
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        require(_navIssuanceSettings.reserveAssets.length > 0, "Reserve assets must be greater than 0");
        require(_navIssuanceSettings.maxManagerFee < PreciseUnitMath.preciseUnit(), "Max manager fee must be less than 100%");
        require(_navIssuanceSettings.maxPremiumPercentage < PreciseUnitMath.preciseUnit(), "Max premium percentage must be less than 100%");
        require(_navIssuanceSettings.managerFees[0] <= _navIssuanceSettings.maxManagerFee, "Manager issue fee must be less than max");
        require(_navIssuanceSettings.managerFees[1] <= _navIssuanceSettings.maxManagerFee, "Manager redeem fee must be less than max");
        require(_navIssuanceSettings.premiumPercentage <= _navIssuanceSettings.maxPremiumPercentage, "Premium must be less than max");
        require(_navIssuanceSettings.feeRecipient != address(0), "Fee Recipient must be non-zero address.");
        // Initial mint of Set cannot use NAVIssuance since minSetTokenSupply must be > 0
        require(_navIssuanceSettings.minSetTokenSupply > 0, "Min SetToken supply must be greater than 0");

        for (uint256 i = 0; i < _navIssuanceSettings.reserveAssets.length; i++) {
            require(!isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]], "Reserve assets must be unique");
            isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]] = true;
        }

        navIssuanceSettings[_setToken] = _navIssuanceSettings;

        _setToken.initializeModule();
    }

    /**
     * Removes this module from the SetToken, via call by the SetToken. Issuance settings and
     * reserve asset states are deleted.
     */
    function removeModule() external override {
        ISetToken setToken = ISetToken(msg.sender);
        for (uint256 i = 0; i < navIssuanceSettings[setToken].reserveAssets.length; i++) {
            delete isReserveAsset[setToken][navIssuanceSettings[setToken].reserveAssets[i]];
        }

        delete navIssuanceSettings[setToken];
    }

    receive() external payable {}

    /* ============ External Getter Functions ============ */

    function getReserveAssets(ISetToken _setToken) external view returns (address[] memory) {
        return navIssuanceSettings[_setToken].reserveAssets;
    }

    function getIssuePremium(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (uint256)
    {
        return _getIssuePremium(_setToken, _reserveAsset, _reserveAssetQuantity);
    }

    function getRedeemPremium(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (uint256)
    {
        return _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);
    }

    function getManagerFee(ISetToken _setToken, uint256 _managerFeeIndex) external view returns (uint256) {
        return navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];
    }

    /**
     * Get the expected SetTokens minted to recipient on issuance
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     *
     * @return  uint256                     Expected SetTokens to be minted to recipient
     */
    function getExpectedSetTokenIssueQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (uint256)
    {
        (,, uint256 netReserveFlow) = _getFees(
            _setToken,
            _reserveAssetQuantity,
            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,
            MANAGER_ISSUE_FEE_INDEX
        );

        uint256 setTotalSupply = _setToken.totalSupply();

        return _getSetTokenMintQuantity(
            _setToken,
            _reserveAsset,
            netReserveFlow,
            setTotalSupply
        );
    }

    /**
     * Get the expected reserve asset to be redeemed
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     *
     * @return  uint256                     Expected reserve asset quantity redeemed
     */
    function getExpectedReserveRedeemQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (uint256)
    {
        uint256 preFeeReserveQuantity = _getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

        (,, uint256 netReserveFlows) = _getFees(
            _setToken,
            preFeeReserveQuantity,
            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
            MANAGER_REDEEM_FEE_INDEX
        );

        return netReserveFlows;
    }

    /**
     * Checks if issue is valid
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     *
     * @return  bool                        Returns true if issue is valid
     */
    function isIssueValid(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (bool)
    {
        uint256 setTotalSupply = _setToken.totalSupply();

    return _reserveAssetQuantity != 0
            && isReserveAsset[_setToken][_reserveAsset]
            && setTotalSupply >= navIssuanceSettings[_setToken].minSetTokenSupply;
    }

    /**
     * Checks if redeem is valid
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     *
     * @return  bool                        Returns true if redeem is valid
     */
    function isRedeemValid(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (bool)
    {
        uint256 setTotalSupply = _setToken.totalSupply();

        if (
            _setTokenQuantity == 0
            || !isReserveAsset[_setToken][_reserveAsset]
            || setTotalSupply < navIssuanceSettings[_setToken].minSetTokenSupply.add(_setTokenQuantity)
        ) {
            return false;
        } else {
            uint256 totalRedeemValue =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

            (,, uint256 expectedRedeemQuantity) = _getFees(
                _setToken,
                totalRedeemValue,
                PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
                PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
                MANAGER_REDEEM_FEE_INDEX
            );

            uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();

            return existingUnit.preciseMul(setTotalSupply) >= expectedRedeemQuantity;
        }
    }

    /* ============ Internal Functions ============ */

    function _validateCommon(ISetToken _setToken, address _reserveAsset, uint256 _quantity) internal view {
        require(_quantity > 0, "Quantity must be > 0");
        require(isReserveAsset[_setToken][_reserveAsset], "Must be valid reserve asset");
    }

    function _validateIssuanceInfo(ISetToken _setToken, uint256 _minSetTokenReceiveQuantity, ActionInfo memory _issueInfo) internal view {
        // Check that total supply is greater than min supply needed for issuance
        // Note: A min supply amount is needed to avoid division by 0 when SetToken supply is 0
        require(
            _issueInfo.previousSetTokenSupply >= navIssuanceSettings[_setToken].minSetTokenSupply,
            "Supply must be greater than minimum to enable issuance"
        );

        require(_issueInfo.setTokenQuantity >= _minSetTokenReceiveQuantity, "Must be greater than min SetToken");
    }

    function _validateRedemptionInfo(
        ISetToken _setToken,
        uint256 _minReserveReceiveQuantity,
        ActionInfo memory _redeemInfo
    )
        internal
        view
    {
        // Check that new supply is more than min supply needed for redemption
        // Note: A min supply amount is needed to avoid division by 0 when redeeming SetToken to 0
        require(
            _redeemInfo.newSetTokenSupply >= navIssuanceSettings[_setToken].minSetTokenSupply,
            "Supply must be greater than minimum to enable redemption"
        );

        require(_redeemInfo.netFlowQuantity >= _minReserveReceiveQuantity, "Must be greater than min receive reserve quantity");
    }

    function _createIssuanceInfo(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        internal
        view
        returns (ActionInfo memory)
    {
        ActionInfo memory issueInfo;

        issueInfo.previousSetTokenSupply = _setToken.totalSupply();

        issueInfo.preFeeReserveQuantity = _reserveAssetQuantity;

        (issueInfo.protocolFees, issueInfo.managerFee, issueInfo.netFlowQuantity) = _getFees(
            _setToken,
            issueInfo.preFeeReserveQuantity,
            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,
            MANAGER_ISSUE_FEE_INDEX
        );

        issueInfo.setTokenQuantity = _getSetTokenMintQuantity(
            _setToken,
            _reserveAsset,
            issueInfo.netFlowQuantity,
            issueInfo.previousSetTokenSupply
        );

        (issueInfo.newSetTokenSupply, issueInfo.newPositionMultiplier) = _getIssuePositionMultiplier(_setToken, issueInfo);

        issueInfo.newReservePositionUnit = _getIssuePositionUnit(_setToken, _reserveAsset, issueInfo);

        return issueInfo;
    }

    function _createRedemptionInfo(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        internal
        view
        returns (ActionInfo memory)
    {
        ActionInfo memory redeemInfo;

        redeemInfo.setTokenQuantity = _setTokenQuantity;

        redeemInfo.preFeeReserveQuantity =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

        (redeemInfo.protocolFees, redeemInfo.managerFee, redeemInfo.netFlowQuantity) = _getFees(
            _setToken,
            redeemInfo.preFeeReserveQuantity,
            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
            MANAGER_REDEEM_FEE_INDEX
        );

        redeemInfo.previousSetTokenSupply = _setToken.totalSupply();

        (redeemInfo.newSetTokenSupply, redeemInfo.newPositionMultiplier) = _getRedeemPositionMultiplier(_setToken, _setTokenQuantity, redeemInfo);

        redeemInfo.newReservePositionUnit = _getRedeemPositionUnit(_setToken, _reserveAsset, redeemInfo);

        return redeemInfo;
    }

    /**
     * Transfer reserve asset from user to SetToken and fees from user to appropriate fee recipients
     */
    function _transferCollateralAndHandleFees(ISetToken _setToken, IERC20 _reserveAsset, ActionInfo memory _issueInfo) internal {
        transferFrom(_reserveAsset, msg.sender, address(_setToken), _issueInfo.netFlowQuantity);

        if (_issueInfo.protocolFees > 0) {
            transferFrom(_reserveAsset, msg.sender, controller.feeRecipient(), _issueInfo.protocolFees);
        }

        if (_issueInfo.managerFee > 0) {
            transferFrom(_reserveAsset, msg.sender, navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);
        }
    }


    /**
      * Transfer WETH from module to SetToken and fees from module to appropriate fee recipients
     */
    function _transferWETHAndHandleFees(ISetToken _setToken, ActionInfo memory _issueInfo) internal {
        weth.transfer(address(_setToken), _issueInfo.netFlowQuantity);

        if (_issueInfo.protocolFees > 0) {
            weth.transfer(controller.feeRecipient(), _issueInfo.protocolFees);
        }

        if (_issueInfo.managerFee > 0) {
            weth.transfer(navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);
        }
    }

    function _handleIssueStateUpdates(
        ISetToken _setToken,
        address _reserveAsset,
        address _to,
        ActionInfo memory _issueInfo
    )
        internal
    {
        _setToken.editPositionMultiplier(_issueInfo.newPositionMultiplier);

        _setToken.editDefaultPosition(_reserveAsset, _issueInfo.newReservePositionUnit);

        _setToken.mint(_to, _issueInfo.setTokenQuantity);

        emit SetTokenNAVIssued(
            _setToken,
            msg.sender,
            _to,
            _reserveAsset,
            address(navIssuanceSettings[_setToken].managerIssuanceHook),
            _issueInfo.setTokenQuantity,
            _issueInfo.managerFee,
            _issueInfo.protocolFees
        );
    }

    function _handleRedeemStateUpdates(
        ISetToken _setToken,
        address _reserveAsset,
        address _to,
        ActionInfo memory _redeemInfo
    )
        internal
    {
        _setToken.editPositionMultiplier(_redeemInfo.newPositionMultiplier);

        _setToken.editDefaultPosition(_reserveAsset, _redeemInfo.newReservePositionUnit);

        emit SetTokenNAVRedeemed(
            _setToken,
            msg.sender,
            _to,
            _reserveAsset,
            address(navIssuanceSettings[_setToken].managerRedemptionHook),
            _redeemInfo.setTokenQuantity,
            _redeemInfo.managerFee,
            _redeemInfo.protocolFees
        );
    }

    function _handleRedemptionFees(ISetToken _setToken, address _reserveAsset, ActionInfo memory _redeemInfo) internal {
        // Instruct the SetToken to transfer protocol fee to fee recipient if there is a fee
        payProtocolFeeFromSetToken(_setToken, _reserveAsset, _redeemInfo.protocolFees);

        // Instruct the SetToken to transfer manager fee to manager fee recipient if there is a fee
        if (_redeemInfo.managerFee > 0) {
            _setToken.strictInvokeTransfer(
                _reserveAsset,
                navIssuanceSettings[_setToken].feeRecipient,
                _redeemInfo.managerFee
            );
        }
    }

    /**
     * Returns the issue premium percentage. Virtual function that can be overridden in future versions of the module
     * and can contain arbitrary logic to calculate the issuance premium.
     */
    function _getIssuePremium(
        ISetToken _setToken,
        address /* _reserveAsset */,
        uint256 /* _reserveAssetQuantity */
    )
        virtual
        internal
        view
        returns (uint256)
    {
        return navIssuanceSettings[_setToken].premiumPercentage;
    }

    /**
     * Returns the redeem premium percentage. Virtual function that can be overridden in future versions of the module
     * and can contain arbitrary logic to calculate the redemption premium.
     */
    function _getRedeemPremium(
        ISetToken _setToken,
        address /* _reserveAsset */,
        uint256 /* _setTokenQuantity */
    )
        virtual
        internal
        view
        returns (uint256)
    {
        return navIssuanceSettings[_setToken].premiumPercentage;
    }

    /**
     * Returns the fees attributed to the manager and the protocol. The fees are calculated as follows:
     *
     * ManagerFee = (manager fee % - % to protocol) * reserveAssetQuantity
     * Protocol Fee = (% manager fee share + direct fee %) * reserveAssetQuantity
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAssetQuantity         Quantity of reserve asset to calculate fees from
     * @param _protocolManagerFeeIndex      Index to pull rev share NAV Issuance fee from the Controller
     * @param _protocolDirectFeeIndex       Index to pull direct NAV issuance fee from the Controller
     * @param _managerFeeIndex              Index from NAVIssuanceSettings (0 = issue fee, 1 = redeem fee)
     *
     * @return  uint256                     Fees paid to the protocol in reserve asset
     * @return  uint256                     Fees paid to the manager in reserve asset
     * @return  uint256                     Net reserve to user net of fees
     */
    function _getFees(
        ISetToken _setToken,
        uint256 _reserveAssetQuantity,
        uint256 _protocolManagerFeeIndex,
        uint256 _protocolDirectFeeIndex,
        uint256 _managerFeeIndex
    )
        internal
        view
        returns (uint256, uint256, uint256)
    {
        (uint256 protocolFeePercentage, uint256 managerFeePercentage) = _getProtocolAndManagerFeePercentages(
            _setToken,
            _protocolManagerFeeIndex,
            _protocolDirectFeeIndex,
            _managerFeeIndex
        );

        // Calculate total notional fees
        uint256 protocolFees = protocolFeePercentage.preciseMul(_reserveAssetQuantity);
        uint256 managerFee = managerFeePercentage.preciseMul(_reserveAssetQuantity);

        uint256 netReserveFlow = _reserveAssetQuantity.sub(protocolFees).sub(managerFee);

        return (protocolFees, managerFee, netReserveFlow);
    }

    function _getProtocolAndManagerFeePercentages(
        ISetToken _setToken,
        uint256 _protocolManagerFeeIndex,
        uint256 _protocolDirectFeeIndex,
        uint256 _managerFeeIndex
    )
        internal
        view
        returns(uint256, uint256)
    {
        // Get protocol fee percentages
        uint256 protocolDirectFeePercent = controller.getModuleFee(address(this), _protocolDirectFeeIndex);
        uint256 protocolManagerShareFeePercent = controller.getModuleFee(address(this), _protocolManagerFeeIndex);
        uint256 managerFeePercent = navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];

        // Calculate revenue share split percentage
        uint256 protocolRevenueSharePercentage = protocolManagerShareFeePercent.preciseMul(managerFeePercent);
        uint256 managerRevenueSharePercentage = managerFeePercent.sub(protocolRevenueSharePercentage);
        uint256 totalProtocolFeePercentage = protocolRevenueSharePercentage.add(protocolDirectFeePercent);

        return (totalProtocolFeePercentage, managerRevenueSharePercentage);
    }

    function _getSetTokenMintQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _netReserveFlows,            // Value of reserve asset net of fees
        uint256 _setTotalSupply
    )
        internal
        view
        returns (uint256)
    {
        uint256 premiumPercentage = _getIssuePremium(_setToken, _reserveAsset, _netReserveFlows);
        uint256 premiumValue = _netReserveFlows.preciseMul(premiumPercentage);

        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (1e18)
        // Reverts if price is not found
        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);

        // Get reserve asset decimals
        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();
        uint256 normalizedTotalReserveQuantityNetFees = _netReserveFlows.preciseDiv(10 ** reserveAssetDecimals);
        uint256 normalizedTotalReserveQuantityNetFeesAndPremium = _netReserveFlows.sub(premiumValue).preciseDiv(10 ** reserveAssetDecimals);

        // Calculate SetTokens to mint to issuer
        uint256 denominator = _setTotalSupply.preciseMul(setTokenValuation).add(normalizedTotalReserveQuantityNetFees).sub(normalizedTotalReserveQuantityNetFeesAndPremium);
        return normalizedTotalReserveQuantityNetFeesAndPremium.preciseMul(_setTotalSupply).preciseDiv(denominator);
    }

    function _getRedeemReserveQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        internal
        view
        returns (uint256)
    {
        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (10e18)
        // Reverts if price is not found
        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);

        uint256 totalRedeemValueInPreciseUnits = _setTokenQuantity.preciseMul(setTokenValuation);
        // Get reserve asset decimals
        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();
        uint256 prePremiumReserveQuantity = totalRedeemValueInPreciseUnits.preciseMul(10 ** reserveAssetDecimals);

        uint256 premiumPercentage = _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);
        uint256 premiumQuantity = prePremiumReserveQuantity.preciseMulCeil(premiumPercentage);

        return prePremiumReserveQuantity.sub(premiumQuantity);
    }

    /**
     * The new position multiplier is calculated as follows:
     * inflationPercentage = (newSupply - oldSupply) / newSupply
     * newMultiplier = (1 - inflationPercentage) * positionMultiplier
     */
    function _getIssuePositionMultiplier(
        ISetToken _setToken,
        ActionInfo memory _issueInfo
    )
        internal
        view
        returns (uint256, int256)
    {
        // Calculate inflation and new position multiplier. Note: Round inflation up in order to round position multiplier down
        uint256 newTotalSupply = _issueInfo.setTokenQuantity.add(_issueInfo.previousSetTokenSupply);
        int256 newPositionMultiplier = _setToken.positionMultiplier()
            .mul(_issueInfo.previousSetTokenSupply.toInt256())
            .div(newTotalSupply.toInt256());

        return (newTotalSupply, newPositionMultiplier);
    }

    /**
     * Calculate deflation and new position multiplier. Note: Round deflation down in order to round position multiplier down
     *
     * The new position multiplier is calculated as follows:
     * deflationPercentage = (oldSupply - newSupply) / newSupply
     * newMultiplier = (1 + deflationPercentage) * positionMultiplier
     */
    function _getRedeemPositionMultiplier(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        ActionInfo memory _redeemInfo
    )
        internal
        view
        returns (uint256, int256)
    {
        uint256 newTotalSupply = _redeemInfo.previousSetTokenSupply.sub(_setTokenQuantity);
        int256 newPositionMultiplier = _setToken.positionMultiplier()
            .mul(_redeemInfo.previousSetTokenSupply.toInt256())
            .div(newTotalSupply.toInt256());

        return (newTotalSupply, newPositionMultiplier);
    }

    /**
     * The new position reserve asset unit is calculated as follows:
     * totalReserve = (oldUnit * oldSetTokenSupply) + reserveQuantity
     * newUnit = totalReserve / newSetTokenSupply
     */
    function _getIssuePositionUnit(
        ISetToken _setToken,
        address _reserveAsset,
        ActionInfo memory _issueInfo
    )
        internal
        view
        returns (uint256)
    {
        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();
        uint256 totalReserve = existingUnit
            .preciseMul(_issueInfo.previousSetTokenSupply)
            .add(_issueInfo.netFlowQuantity);

        return totalReserve.preciseDiv(_issueInfo.newSetTokenSupply);
    }

    /**
     * The new position reserve asset unit is calculated as follows:
     * totalReserve = (oldUnit * oldSetTokenSupply) - reserveQuantityToSendOut
     * newUnit = totalReserve / newSetTokenSupply
     */
    function _getRedeemPositionUnit(
        ISetToken _setToken,
        address _reserveAsset,
        ActionInfo memory _redeemInfo
    )
        internal
        view
        returns (uint256)
    {
        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();
        uint256 totalExistingUnits = existingUnit.preciseMul(_redeemInfo.previousSetTokenSupply);

        uint256 outflow = _redeemInfo.netFlowQuantity.add(_redeemInfo.protocolFees).add(_redeemInfo.managerFee);

        // Require withdrawable quantity is greater than existing collateral
        require(totalExistingUnits >= outflow, "Must be greater than total available collateral");

        return totalExistingUnits.sub(outflow).preciseDiv(_redeemInfo.newSetTokenSupply);
    }

    /**
     * If a pre-issue hook has been configured, call the external-protocol contract. Pre-issue hook logic
     * can contain arbitrary logic including validations, external function calls, etc.
     */
    function _callPreIssueHooks(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity,
        address _caller,
        address _to
    )
        internal
    {
        INAVIssuanceHook preIssueHook = navIssuanceSettings[_setToken].managerIssuanceHook;
        if (address(preIssueHook) != address(0)) {
            preIssueHook.invokePreIssueHook(_setToken, _reserveAsset, _reserveAssetQuantity, _caller, _to);
        }
    }

    /**
     * If a pre-redeem hook has been configured, call the external-protocol contract.
     */
    function _callPreRedeemHooks(ISetToken _setToken, uint256 _setQuantity, address _caller, address _to) internal {
        INAVIssuanceHook preRedeemHook = navIssuanceSettings[_setToken].managerRedemptionHook;
        if (address(preRedeemHook) != address(0)) {
            preRedeemHook.invokePreRedeemHook(_setToken, _setQuantity, _caller, _to);
        }
    }
}.]

Given the user's task and the brainstorming ideas provided:
Task: "/*
    Copyright 2020 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";
import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";
import { SignedSafeMath } from "@openzeppelin/contracts/math/SignedSafeMath.sol";

import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";
import { IController } from "../../interfaces/IController.sol";
import { INAVIssuanceHook } from "../../interfaces/INAVIssuanceHook.sol";
import { Invoke } from "../lib/Invoke.sol";
import { ISetToken } from "../../interfaces/ISetToken.sol";
import { IWETH } from "../../interfaces/external/IWETH.sol";
import { ModuleBase } from "../lib/ModuleBase.sol";
import { Position } from "../lib/Position.sol";
import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";
import { ResourceIdentifier } from "../lib/ResourceIdentifier.sol";


/**
 * @title NavIssuanceModule
 * @author Set Protocol
 *
 * Module that enables issuance and redemption with any valid ERC20 token or ETH if allowed by the manager. Sender receives
 * a proportional amount of SetTokens on issuance or ERC20 token on redemption based on the calculated net asset value using
 * oracle prices. Manager is able to enforce a premium / discount on issuance / redemption to avoid arbitrage and front
 * running when relying on oracle prices. Managers can charge a fee (denominated in reserve asset).
 */
contract NavIssuanceModule is ModuleBase, ReentrancyGuard {
    using AddressArrayUtils for address[];
    using Invoke for ISetToken;
    using Position for ISetToken;
    using PreciseUnitMath for uint256;
    using PreciseUnitMath for int256;
    using ResourceIdentifier for IController;
    using SafeMath for uint256;
    using SafeCast for int256;
    using SafeCast for uint256;
    using SignedSafeMath for int256;

    /* ============ Events ============ */

    event SetTokenNAVIssued(
        ISetToken indexed _setToken,
        address _issuer,
        address _to,
        address _reserveAsset,
        address _hookContract,
        uint256 _setTokenQuantity,
        uint256 _managerFee,
        uint256 _premium
    );

    event SetTokenNAVRedeemed(
        ISetToken indexed _setToken,
        address _redeemer,
        address _to,
        address _reserveAsset,
        address _hookContract,
        uint256 _setTokenQuantity,
        uint256 _managerFee,
        uint256 _premium
    );

    event ReserveAssetAdded(
        ISetToken indexed _setToken,
        address _newReserveAsset
    );

    event ReserveAssetRemoved(
        ISetToken indexed _setToken,
        address _removedReserveAsset
    );

    event PremiumEdited(
        ISetToken indexed _setToken,
        uint256 _newPremium
    );

    event ManagerFeeEdited(
        ISetToken indexed _setToken,
        uint256 _newManagerFee,
        uint256 _index
    );

    event FeeRecipientEdited(
        ISetToken indexed _setToken,
        address _feeRecipient
    );

    /* ============ Structs ============ */

    struct NAVIssuanceSettings {
        INAVIssuanceHook managerIssuanceHook;      // Issuance hook configurations
        INAVIssuanceHook managerRedemptionHook;    // Redemption hook configurations
        address[] reserveAssets;                       // Allowed reserve assets - Must have a price enabled with the price oracle
        address feeRecipient;                          // Manager fee recipient
        uint256[2] managerFees;                        // Manager fees. 0 index is issue and 1 index is redeem fee (0.01% = 1e14, 1% = 1e16)
        uint256 maxManagerFee;                         // Maximum fee manager is allowed to set for issue and redeem
        uint256 premiumPercentage;                     // Premium percentage (0.01% = 1e14, 1% = 1e16). This premium is a buffer around oracle
                                                       // prices paid by user to the SetToken, which prevents arbitrage and oracle front running
        uint256 maxPremiumPercentage;                  // Maximum premium percentage manager is allowed to set (configured by manager)
        uint256 minSetTokenSupply;                     // Minimum SetToken supply required for issuance and redemption
                                                       // to prevent dramatic inflationary changes to the SetToken's position multiplier
    }

    struct ActionInfo {
        uint256 preFeeReserveQuantity;                 // Reserve value before fees; During issuance, represents raw quantity
                                                       // During redeem, represents post-premium value
        uint256 protocolFees;                          // Total protocol fees (direct + manager revenue share)
        uint256 managerFee;                            // Total manager fee paid in reserve asset
        uint256 netFlowQuantity;                       // When issuing, quantity of reserve asset sent to SetToken
                                                       // When redeeming, quantity of reserve asset sent to redeemer
        uint256 setTokenQuantity;                      // When issuing, quantity of SetTokens minted to mintee
                                                       // When redeeming, quantity of SetToken redeemed
        uint256 previousSetTokenSupply;                // SetToken supply prior to issue/redeem action
        uint256 newSetTokenSupply;                     // SetToken supply after issue/redeem action
        int256 newPositionMultiplier;                  // SetToken position multiplier after issue/redeem
        uint256 newReservePositionUnit;                // SetToken reserve asset position unit after issue/redeem
    }

    /* ============ State Variables ============ */

    // Wrapped ETH address
    IWETH public immutable weth;

    // Mapping of SetToken to NAV issuance settings struct
    mapping(ISetToken => NAVIssuanceSettings) public navIssuanceSettings;

    // Mapping to efficiently check a SetToken's reserve asset validity
    // SetToken => reserveAsset => isReserveAsset
    mapping(ISetToken => mapping(address => bool)) public isReserveAsset;

    /* ============ Constants ============ */

    // 0 index stores the manager fee in managerFees array, percentage charged on issue (denominated in reserve asset)
    uint256 constant internal MANAGER_ISSUE_FEE_INDEX = 0;

    // 1 index stores the manager fee percentage in managerFees array, charged on redeem
    uint256 constant internal MANAGER_REDEEM_FEE_INDEX = 1;

    // 0 index stores the manager revenue share protocol fee % on the controller, charged in the issuance function
    uint256 constant internal PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX = 0;

    // 1 index stores the manager revenue share protocol fee % on the controller, charged in the redeem function
    uint256 constant internal PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX = 1;

    // 2 index stores the direct protocol fee % on the controller, charged in the issuance function
    uint256 constant internal PROTOCOL_ISSUE_DIRECT_FEE_INDEX = 2;

    // 3 index stores the direct protocol fee % on the controller, charged in the redeem function
    uint256 constant internal PROTOCOL_REDEEM_DIRECT_FEE_INDEX = 3;

    /* ============ Constructor ============ */

    /**
     * @param _controller               Address of controller contract
     * @param _weth                     Address of wrapped eth
     */
    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {
        weth = _weth;
    }

    /* ============ External Functions ============ */

    /**
     * Deposits the allowed reserve asset into the SetToken and mints the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _reserveAsset                 Address of the reserve asset to issue with
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance
     * @param _to                           Address to mint SetToken to
     */
    function issue(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity,
        uint256 _minSetTokenReceiveQuantity,
        address _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, _reserveAsset, _reserveAssetQuantity);

        _callPreIssueHooks(_setToken, _reserveAsset, _reserveAssetQuantity, msg.sender, _to);

        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, _reserveAsset, _reserveAssetQuantity);

        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);

        _transferCollateralAndHandleFees(_setToken, IERC20(_reserveAsset), issueInfo);

        _handleIssueStateUpdates(_setToken, _reserveAsset, _to, issueInfo);
    }

    /**
     * Wraps ETH and deposits WETH if allowed into the SetToken and mints the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance
     * @param _to                           Address to mint SetToken to
     */
    function issueWithEther(
        ISetToken _setToken,
        uint256 _minSetTokenReceiveQuantity,
        address _to
    )
        external
        payable
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        weth.deposit{ value: msg.value }();

        _validateCommon(_setToken, address(weth), msg.value);

        _callPreIssueHooks(_setToken, address(weth), msg.value, msg.sender, _to);

        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, address(weth), msg.value);

        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);

        _transferWETHAndHandleFees(_setToken, issueInfo);

        _handleIssueStateUpdates(_setToken, address(weth), _to, issueInfo);
    }

    /**
     * Redeems a SetToken into a valid reserve asset representing the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address. Only valid if there are available reserve units on the SetToken.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _reserveAsset                 Address of the reserve asset to redeem with
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive
     * @param _to                           Address to redeem reserve asset to
     */
    function redeem(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity,
        uint256 _minReserveReceiveQuantity,
        address _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, _reserveAsset, _setTokenQuantity);

        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);

        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, _reserveAsset, _setTokenQuantity);

        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);

        _setToken.burn(msg.sender, _setTokenQuantity);

        // Instruct the SetToken to transfer the reserve asset back to the user
        _setToken.strictInvokeTransfer(
            _reserveAsset,
            _to,
            redeemInfo.netFlowQuantity
        );

        _handleRedemptionFees(_setToken, _reserveAsset, redeemInfo);

        _handleRedeemStateUpdates(_setToken, _reserveAsset, _to, redeemInfo);
    }

    /**
     * Redeems a SetToken into Ether (if WETH is valid) representing the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address. Only valid if there are available WETH units on the SetToken.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive
     * @param _to                           Address to redeem reserve asset to
     */
    function redeemIntoEther(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        uint256 _minReserveReceiveQuantity,
        address payable _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, address(weth), _setTokenQuantity);

        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);

        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, address(weth), _setTokenQuantity);

        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);

        _setToken.burn(msg.sender, _setTokenQuantity);

        // Instruct the SetToken to transfer WETH from SetToken to module
        _setToken.strictInvokeTransfer(
            address(weth),
            address(this),
            redeemInfo.netFlowQuantity
        );

        weth.withdraw(redeemInfo.netFlowQuantity);

        _to.transfer(redeemInfo.netFlowQuantity);

        _handleRedemptionFees(_setToken, address(weth), redeemInfo);

        _handleRedeemStateUpdates(_setToken, address(weth), _to, redeemInfo);
    }

    /**
     * SET MANAGER ONLY. Add an allowed reserve asset
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset to add
     */
    function addReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {
        require(!isReserveAsset[_setToken][_reserveAsset], "Reserve asset already exists");

        navIssuanceSettings[_setToken].reserveAssets.push(_reserveAsset);
        isReserveAsset[_setToken][_reserveAsset] = true;

        emit ReserveAssetAdded(_setToken, _reserveAsset);
    }

    /**
     * SET MANAGER ONLY. Remove a reserve asset
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset to remove
     */
    function removeReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {
        require(isReserveAsset[_setToken][_reserveAsset], "Reserve asset does not exist");

        navIssuanceSettings[_setToken].reserveAssets = navIssuanceSettings[_setToken].reserveAssets.remove(_reserveAsset);
        delete isReserveAsset[_setToken][_reserveAsset];

        emit ReserveAssetRemoved(_setToken, _reserveAsset);
    }

    /**
     * SET MANAGER ONLY. Edit the premium percentage
     *
     * @param _setToken                     Instance of the SetToken
     * @param _premiumPercentage            Premium percentage in 10e16 (e.g. 10e16 = 1%)
     */
    function editPremium(ISetToken _setToken, uint256 _premiumPercentage) external onlyManagerAndValidSet(_setToken) {
        require(_premiumPercentage <= navIssuanceSettings[_setToken].maxPremiumPercentage, "Premium must be less than maximum allowed");

        navIssuanceSettings[_setToken].premiumPercentage = _premiumPercentage;

        emit PremiumEdited(_setToken, _premiumPercentage);
    }

    /**
     * SET MANAGER ONLY. Edit manager fee
     *
     * @param _setToken                     Instance of the SetToken
     * @param _managerFeePercentage         Manager fee percentage in 10e16 (e.g. 10e16 = 1%)
     * @param _managerFeeIndex              Manager fee index. 0 index is issue fee, 1 index is redeem fee
     */
    function editManagerFee(
        ISetToken _setToken,
        uint256 _managerFeePercentage,
        uint256 _managerFeeIndex
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        require(_managerFeePercentage <= navIssuanceSettings[_setToken].maxManagerFee, "Manager fee must be less than maximum allowed");

        navIssuanceSettings[_setToken].managerFees[_managerFeeIndex] = _managerFeePercentage;

        emit ManagerFeeEdited(_setToken, _managerFeePercentage, _managerFeeIndex);
    }

    /**
     * SET MANAGER ONLY. Edit the manager fee recipient
     *
     * @param _setToken                     Instance of the SetToken
     * @param _managerFeeRecipient          Manager fee recipient
     */
    function editFeeRecipient(ISetToken _setToken, address _managerFeeRecipient) external onlyManagerAndValidSet(_setToken) {
        require(_managerFeeRecipient != address(0), "Fee recipient must not be 0 address");

        navIssuanceSettings[_setToken].feeRecipient = _managerFeeRecipient;

        emit FeeRecipientEdited(_setToken, _managerFeeRecipient);
    }

    /**
     * SET MANAGER ONLY. Initializes this module to the SetToken with hooks, allowed reserve assets,
     * fees and issuance premium. Only callable by the SetToken's manager. Hook addresses are optional.
     * Address(0) means that no hook will be called.
     *
     * @param _setToken                     Instance of the SetToken to issue
     * @param _navIssuanceSettings          NAVIssuanceSettings struct defining parameters
     */
    function initialize(
        ISetToken _setToken,
        NAVIssuanceSettings memory _navIssuanceSettings
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        require(_navIssuanceSettings.reserveAssets.length > 0, "Reserve assets must be greater than 0");
        require(_navIssuanceSettings.maxManagerFee < PreciseUnitMath.preciseUnit(), "Max manager fee must be less than 100%");
        require(_navIssuanceSettings.maxPremiumPercentage < PreciseUnitMath.preciseUnit(), "Max premium percentage must be less than 100%");
        require(_navIssuanceSettings.managerFees[0] <= _navIssuanceSettings.maxManagerFee, "Manager issue fee must be less than max");
        require(_navIssuanceSettings.managerFees[1] <= _navIssuanceSettings.maxManagerFee, "Manager redeem fee must be less than max");
        require(_navIssuanceSettings.premiumPercentage <= _navIssuanceSettings.maxPremiumPercentage, "Premium must be less than max");
        require(_navIssuanceSettings.feeRecipient != address(0), "Fee Recipient must be non-zero address.");
        // Initial mint of Set cannot use NAVIssuance since minSetTokenSupply must be > 0
        require(_navIssuanceSettings.minSetTokenSupply > 0, "Min SetToken supply must be greater than 0");

        for (uint256 i = 0; i < _navIssuanceSettings.reserveAssets.length; i++) {
            require(!isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]], "Reserve assets must be unique");
            isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]] = true;
        }

        navIssuanceSettings[_setToken] = _navIssuanceSettings;

        _setToken.initializeModule();
    }

    /**
     * Removes this module from the SetToken, via call by the SetToken. Issuance settings and
     * reserve asset states are deleted.
     */
    function removeModule() external override {
        ISetToken setToken = ISetToken(msg.sender);
        for (uint256 i = 0; i < navIssuanceSettings[setToken].reserveAssets.length; i++) {
            delete isReserveAsset[setToken][navIssuanceSettings[setToken].reserveAssets[i]];
        }

        delete navIssuanceSettings[setToken];
    }

    receive() external payable {}

    /* ============ External Getter Functions ============ */

    function getReserveAssets(ISetToken _setToken) external view returns (address[] memory) {
        return navIssuanceSettings[_setToken].reserveAssets;
    }

    function getIssuePremium(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (uint256)
    {
        return _getIssuePremium(_setToken, _reserveAsset, _reserveAssetQuantity);
    }

    function getRedeemPremium(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (uint256)
    {
        return _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);
    }

    function getManagerFee(ISetToken _setToken, uint256 _managerFeeIndex) external view returns (uint256) {
        return navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];
    }

    /**
     * Get the expected SetTokens minted to recipient on issuance
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     *
     * @return  uint256                     Expected SetTokens to be minted to recipient
     */
    function getExpectedSetTokenIssueQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (uint256)
    {
        (,, uint256 netReserveFlow) = _getFees(
            _setToken,
            _reserveAssetQuantity,
            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,
            MANAGER_ISSUE_FEE_INDEX
        );

        uint256 setTotalSupply = _setToken.totalSupply();

        return _getSetTokenMintQuantity(
            _setToken,
            _reserveAsset,
            netReserveFlow,
            setTotalSupply
        );
    }

    /**
     * Get the expected reserve asset to be redeemed
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     *
     * @return  uint256                     Expected reserve asset quantity redeemed
     */
    function getExpectedReserveRedeemQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (uint256)
    {
        uint256 preFeeReserveQuantity = _getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

        (,, uint256 netReserveFlows) = _getFees(
            _setToken,
            preFeeReserveQuantity,
            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
            MANAGER_REDEEM_FEE_INDEX
        );

        return netReserveFlows;
    }

    /**
     * Checks if issue is valid
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     *
     * @return  bool                        Returns true if issue is valid
     */
    function isIssueValid(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (bool)
    {
        uint256 setTotalSupply = _setToken.totalSupply();

    return _reserveAssetQuantity != 0
            && isReserveAsset[_setToken][_reserveAsset]
            && setTotalSupply >= navIssuanceSettings[_setToken].minSetTokenSupply;
    }

    /**
     * Checks if redeem is valid
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     *
     * @return  bool                        Returns true if redeem is valid
     */
    function isRedeemValid(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (bool)
    {
        uint256 setTotalSupply = _setToken.totalSupply();

        if (
            _setTokenQuantity == 0
            || !isReserveAsset[_setToken][_reserveAsset]
            || setTotalSupply < navIssuanceSettings[_setToken].minSetTokenSupply.add(_setTokenQuantity)
        ) {
            return false;
        } else {
            uint256 totalRedeemValue =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

            (,, uint256 expectedRedeemQuantity) = _getFees(
                _setToken,
                totalRedeemValue,
                PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
                PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
                MANAGER_REDEEM_FEE_INDEX
            );

            uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();

            return existingUnit.preciseMul(setTotalSupply) >= expectedRedeemQuantity;
        }
    }

    /* ============ Internal Functions ============ */

    function _validateCommon(ISetToken _setToken, address _reserveAsset, uint256 _quantity) internal view {
        require(_quantity > 0, "Quantity must be > 0");
        require(isReserveAsset[_setToken][_reserveAsset], "Must be valid reserve asset");
    }

    function _validateIssuanceInfo(ISetToken _setToken, uint256 _minSetTokenReceiveQuantity, ActionInfo memory _issueInfo) internal view {
        // Check that total supply is greater than min supply needed for issuance
        // Note: A min supply amount is needed to avoid division by 0 when SetToken supply is 0
        require(
            _issueInfo.previousSetTokenSupply >= navIssuanceSettings[_setToken].minSetTokenSupply,
            "Supply must be greater than minimum to enable issuance"
        );

        require(_issueInfo.setTokenQuantity >= _minSetTokenReceiveQuantity, "Must be greater than min SetToken");
    }

    function _validateRedemptionInfo(
        ISetToken _setToken,
        uint256 _minReserveReceiveQuantity,
        ActionInfo memory _redeemInfo
    )
        internal
        view
    {
        // Check that new supply is more than min supply needed for redemption
        // Note: A min supply amount is needed to avoid division by 0 when redeeming SetToken to 0
        require(
            _redeemInfo.newSetTokenSupply >= navIssuanceSettings[_setToken].minSetTokenSupply,
            "Supply must be greater than minimum to enable redemption"
        );

        require(_redeemInfo.netFlowQuantity >= _minReserveReceiveQuantity, "Must be greater than min receive reserve quantity");
    }

    function _createIssuanceInfo(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        internal
        view
        returns (ActionInfo memory)
    {
        ActionInfo memory issueInfo;

        issueInfo.previousSetTokenSupply = _setToken.totalSupply();

        issueInfo.preFeeReserveQuantity = _reserveAssetQuantity;

        (issueInfo.protocolFees, issueInfo.managerFee, issueInfo.netFlowQuantity) = _getFees(
            _setToken,
            issueInfo.preFeeReserveQuantity,
            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,
            MANAGER_ISSUE_FEE_INDEX
        );

        issueInfo.setTokenQuantity = _getSetTokenMintQuantity(
            _setToken,
            _reserveAsset,
            issueInfo.netFlowQuantity,
            issueInfo.previousSetTokenSupply
        );

        (issueInfo.newSetTokenSupply, issueInfo.newPositionMultiplier) = _getIssuePositionMultiplier(_setToken, issueInfo);

        issueInfo.newReservePositionUnit = _getIssuePositionUnit(_setToken, _reserveAsset, issueInfo);

        return issueInfo;
    }

    function _createRedemptionInfo(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        internal
        view
        returns (ActionInfo memory)
    {
        ActionInfo memory redeemInfo;

        redeemInfo.setTokenQuantity = _setTokenQuantity;

        redeemInfo.preFeeReserveQuantity =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

        (redeemInfo.protocolFees, redeemInfo.managerFee, redeemInfo.netFlowQuantity) = _getFees(
            _setToken,
            redeemInfo.preFeeReserveQuantity,
            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
            MANAGER_REDEEM_FEE_INDEX
        );

        redeemInfo.previousSetTokenSupply = _setToken.totalSupply();

        (redeemInfo.newSetTokenSupply, redeemInfo.newPositionMultiplier) = _getRedeemPositionMultiplier(_setToken, _setTokenQuantity, redeemInfo);

        redeemInfo.newReservePositionUnit = _getRedeemPositionUnit(_setToken, _reserveAsset, redeemInfo);

        return redeemInfo;
    }

    /**
     * Transfer reserve asset from user to SetToken and fees from user to appropriate fee recipients
     */
    function _transferCollateralAndHandleFees(ISetToken _setToken, IERC20 _reserveAsset, ActionInfo memory _issueInfo) internal {
        transferFrom(_reserveAsset, msg.sender, address(_setToken), _issueInfo.netFlowQuantity);

        if (_issueInfo.protocolFees > 0) {
            transferFrom(_reserveAsset, msg.sender, controller.feeRecipient(), _issueInfo.protocolFees);
        }

        if (_issueInfo.managerFee > 0) {
            transferFrom(_reserveAsset, msg.sender, navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);
        }
    }


    /**
      * Transfer WETH from module to SetToken and fees from module to appropriate fee recipients
     */
    function _transferWETHAndHandleFees(ISetToken _setToken, ActionInfo memory _issueInfo) internal {
        weth.transfer(address(_setToken), _issueInfo.netFlowQuantity);

        if (_issueInfo.protocolFees > 0) {
            weth.transfer(controller.feeRecipient(), _issueInfo.protocolFees);
        }

        if (_issueInfo.managerFee > 0) {
            weth.transfer(navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);
        }
    }

    function _handleIssueStateUpdates(
        ISetToken _setToken,
        address _reserveAsset,
        address _to,
        ActionInfo memory _issueInfo
    )
        internal
    {
        _setToken.editPositionMultiplier(_issueInfo.newPositionMultiplier);

        _setToken.editDefaultPosition(_reserveAsset, _issueInfo.newReservePositionUnit);

        _setToken.mint(_to, _issueInfo.setTokenQuantity);

        emit SetTokenNAVIssued(
            _setToken,
            msg.sender,
            _to,
            _reserveAsset,
            address(navIssuanceSettings[_setToken].managerIssuanceHook),
            _issueInfo.setTokenQuantity,
            _issueInfo.managerFee,
            _issueInfo.protocolFees
        );
    }

    function _handleRedeemStateUpdates(
        ISetToken _setToken,
        address _reserveAsset,
        address _to,
        ActionInfo memory _redeemInfo
    )
        internal
    {
        _setToken.editPositionMultiplier(_redeemInfo.newPositionMultiplier);

        _setToken.editDefaultPosition(_reserveAsset, _redeemInfo.newReservePositionUnit);

        emit SetTokenNAVRedeemed(
            _setToken,
            msg.sender,
            _to,
            _reserveAsset,
            address(navIssuanceSettings[_setToken].managerRedemptionHook),
            _redeemInfo.setTokenQuantity,
            _redeemInfo.managerFee,
            _redeemInfo.protocolFees
        );
    }

    function _handleRedemptionFees(ISetToken _setToken, address _reserveAsset, ActionInfo memory _redeemInfo) internal {
        // Instruct the SetToken to transfer protocol fee to fee recipient if there is a fee
        payProtocolFeeFromSetToken(_setToken, _reserveAsset, _redeemInfo.protocolFees);

        // Instruct the SetToken to transfer manager fee to manager fee recipient if there is a fee
        if (_redeemInfo.managerFee > 0) {
            _setToken.strictInvokeTransfer(
                _reserveAsset,
                navIssuanceSettings[_setToken].feeRecipient,
                _redeemInfo.managerFee
            );
        }
    }

    /**
     * Returns the issue premium percentage. Virtual function that can be overridden in future versions of the module
     * and can contain arbitrary logic to calculate the issuance premium.
     */
    function _getIssuePremium(
        ISetToken _setToken,
        address /* _reserveAsset */,
        uint256 /* _reserveAssetQuantity */
    )
        virtual
        internal
        view
        returns (uint256)
    {
        return navIssuanceSettings[_setToken].premiumPercentage;
    }

    /**
     * Returns the redeem premium percentage. Virtual function that can be overridden in future versions of the module
     * and can contain arbitrary logic to calculate the redemption premium.
     */
    function _getRedeemPremium(
        ISetToken _setToken,
        address /* _reserveAsset */,
        uint256 /* _setTokenQuantity */
    )
        virtual
        internal
        view
        returns (uint256)
    {
        return navIssuanceSettings[_setToken].premiumPercentage;
    }

    /**
     * Returns the fees attributed to the manager and the protocol. The fees are calculated as follows:
     *
     * ManagerFee = (manager fee % - % to protocol) * reserveAssetQuantity
     * Protocol Fee = (% manager fee share + direct fee %) * reserveAssetQuantity
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAssetQuantity         Quantity of reserve asset to calculate fees from
     * @param _protocolManagerFeeIndex      Index to pull rev share NAV Issuance fee from the Controller
     * @param _protocolDirectFeeIndex       Index to pull direct NAV issuance fee from the Controller
     * @param _managerFeeIndex              Index from NAVIssuanceSettings (0 = issue fee, 1 = redeem fee)
     *
     * @return  uint256                     Fees paid to the protocol in reserve asset
     * @return  uint256                     Fees paid to the manager in reserve asset
     * @return  uint256                     Net reserve to user net of fees
     */
    function _getFees(
        ISetToken _setToken,
        uint256 _reserveAssetQuantity,
        uint256 _protocolManagerFeeIndex,
        uint256 _protocolDirectFeeIndex,
        uint256 _managerFeeIndex
    )
        internal
        view
        returns (uint256, uint256, uint256)
    {
        (uint256 protocolFeePercentage, uint256 managerFeePercentage) = _getProtocolAndManagerFeePercentages(
            _setToken,
            _protocolManagerFeeIndex,
            _protocolDirectFeeIndex,
            _managerFeeIndex
        );

        // Calculate total notional fees
        uint256 protocolFees = protocolFeePercentage.preciseMul(_reserveAssetQuantity);
        uint256 managerFee = managerFeePercentage.preciseMul(_reserveAssetQuantity);

        uint256 netReserveFlow = _reserveAssetQuantity.sub(protocolFees).sub(managerFee);

        return (protocolFees, managerFee, netReserveFlow);
    }

    function _getProtocolAndManagerFeePercentages(
        ISetToken _setToken,
        uint256 _protocolManagerFeeIndex,
        uint256 _protocolDirectFeeIndex,
        uint256 _managerFeeIndex
    )
        internal
        view
        returns(uint256, uint256)
    {
        // Get protocol fee percentages
        uint256 protocolDirectFeePercent = controller.getModuleFee(address(this), _protocolDirectFeeIndex);
        uint256 protocolManagerShareFeePercent = controller.getModuleFee(address(this), _protocolManagerFeeIndex);
        uint256 managerFeePercent = navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];

        // Calculate revenue share split percentage
        uint256 protocolRevenueSharePercentage = protocolManagerShareFeePercent.preciseMul(managerFeePercent);
        uint256 managerRevenueSharePercentage = managerFeePercent.sub(protocolRevenueSharePercentage);
        uint256 totalProtocolFeePercentage = protocolRevenueSharePercentage.add(protocolDirectFeePercent);

        return (totalProtocolFeePercentage, managerRevenueSharePercentage);
    }

    function _getSetTokenMintQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _netReserveFlows,            // Value of reserve asset net of fees
        uint256 _setTotalSupply
    )
        internal
        view
        returns (uint256)
    {
        uint256 premiumPercentage = _getIssuePremium(_setToken, _reserveAsset, _netReserveFlows);
        uint256 premiumValue = _netReserveFlows.preciseMul(premiumPercentage);

        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (1e18)
        // Reverts if price is not found
        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);

        // Get reserve asset decimals
        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();
        uint256 normalizedTotalReserveQuantityNetFees = _netReserveFlows.preciseDiv(10 ** reserveAssetDecimals);
        uint256 normalizedTotalReserveQuantityNetFeesAndPremium = _netReserveFlows.sub(premiumValue).preciseDiv(10 ** reserveAssetDecimals);

        // Calculate SetTokens to mint to issuer
        uint256 denominator = _setTotalSupply.preciseMul(setTokenValuation).add(normalizedTotalReserveQuantityNetFees).sub(normalizedTotalReserveQuantityNetFeesAndPremium);
        return normalizedTotalReserveQuantityNetFeesAndPremium.preciseMul(_setTotalSupply).preciseDiv(denominator);
    }

    function _getRedeemReserveQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        internal
        view
        returns (uint256)
    {
        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (10e18)
        // Reverts if price is not found
        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);

        uint256 totalRedeemValueInPreciseUnits = _setTokenQuantity.preciseMul(setTokenValuation);
        // Get reserve asset decimals
        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();
        uint256 prePremiumReserveQuantity = totalRedeemValueInPreciseUnits.preciseMul(10 ** reserveAssetDecimals);

        uint256 premiumPercentage = _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);
        uint256 premiumQuantity = prePremiumReserveQuantity.preciseMulCeil(premiumPercentage);

        return prePremiumReserveQuantity.sub(premiumQuantity);
    }

    /**
     * The new position multiplier is calculated as follows:
     * inflationPercentage = (newSupply - oldSupply) / newSupply
     * newMultiplier = (1 - inflationPercentage) * positionMultiplier
     */
    function _getIssuePositionMultiplier(
        ISetToken _setToken,
        ActionInfo memory _issueInfo
    )
        internal
        view
        returns (uint256, int256)
    {
        // Calculate inflation and new position multiplier. Note: Round inflation up in order to round position multiplier down
        uint256 newTotalSupply = _issueInfo.setTokenQuantity.add(_issueInfo.previousSetTokenSupply);
        int256 newPositionMultiplier = _setToken.positionMultiplier()
            .mul(_issueInfo.previousSetTokenSupply.toInt256())
            .div(newTotalSupply.toInt256());

        return (newTotalSupply, newPositionMultiplier);
    }

    /**
     * Calculate deflation and new position multiplier. Note: Round deflation down in order to round position multiplier down
     *
     * The new position multiplier is calculated as follows:
     * deflationPercentage = (oldSupply - newSupply) / newSupply
     * newMultiplier = (1 + deflationPercentage) * positionMultiplier
     */
    function _getRedeemPositionMultiplier(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        ActionInfo memory _redeemInfo
    )
        internal
        view
        returns (uint256, int256)
    {
        uint256 newTotalSupply = _redeemInfo.previousSetTokenSupply.sub(_setTokenQuantity);
        int256 newPositionMultiplier = _setToken.positionMultiplier()
            .mul(_redeemInfo.previousSetTokenSupply.toInt256())
            .div(newTotalSupply.toInt256());

        return (newTotalSupply, newPositionMultiplier);
    }

    /**
     * The new position reserve asset unit is calculated as follows:
     * totalReserve = (oldUnit * oldSetTokenSupply) + reserveQuantity
     * newUnit = totalReserve / newSetTokenSupply
     */
    function _getIssuePositionUnit(
        ISetToken _setToken,
        address _reserveAsset,
        ActionInfo memory _issueInfo
    )
        internal
        view
        returns (uint256)
    {
        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();
        uint256 totalReserve = existingUnit
            .preciseMul(_issueInfo.previousSetTokenSupply)
            .add(_issueInfo.netFlowQuantity);

        return totalReserve.preciseDiv(_issueInfo.newSetTokenSupply);
    }

    /**
     * The new position reserve asset unit is calculated as follows:
     * totalReserve = (oldUnit * oldSetTokenSupply) - reserveQuantityToSendOut
     * newUnit = totalReserve / newSetTokenSupply
     */
    function _getRedeemPositionUnit(
        ISetToken _setToken,
        address _reserveAsset,
        ActionInfo memory _redeemInfo
    )
        internal
        view
        returns (uint256)
    {
        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();
        uint256 totalExistingUnits = existingUnit.preciseMul(_redeemInfo.previousSetTokenSupply);

        uint256 outflow = _redeemInfo.netFlowQuantity.add(_redeemInfo.protocolFees).add(_redeemInfo.managerFee);

        // Require withdrawable quantity is greater than existing collateral
        require(totalExistingUnits >= outflow, "Must be greater than total available collateral");

        return totalExistingUnits.sub(outflow).preciseDiv(_redeemInfo.newSetTokenSupply);
    }

    /**
     * If a pre-issue hook has been configured, call the external-protocol contract. Pre-issue hook logic
     * can contain arbitrary logic including validations, external function calls, etc.
     */
    function _callPreIssueHooks(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity,
        address _caller,
        address _to
    )
        internal
    {
        INAVIssuanceHook preIssueHook = navIssuanceSettings[_setToken].managerIssuanceHook;
        if (address(preIssueHook) != address(0)) {
            preIssueHook.invokePreIssueHook(_setToken, _reserveAsset, _reserveAssetQuantity, _caller, _to);
        }
    }

    /**
     * If a pre-redeem hook has been configured, call the external-protocol contract.
     */
    function _callPreRedeemHooks(ISetToken _setToken, uint256 _setQuantity, address _caller, address _to) internal {
        INAVIssuanceHook preRedeemHook = navIssuanceSettings[_setToken].managerRedemptionHook;
        if (address(preRedeemHook) != address(0)) {
            preRedeemHook.invokePreRedeemHook(_setToken, _setQuantity, _caller, _to);
        }
    }
}".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-01-09 05:31:35 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 05:31:35 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 19903
completion_tokens: 1
total_tokens: 19904
cost: $-1.000000


[2024-01-09 05:31:35 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: /*
    Copyright 2020 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";
import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";
import { SignedSafeMath } from "@openzeppelin/contracts/math/SignedSafeMath.sol";

import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";
import { IController } from "../../interfaces/IController.sol";
import { INAVIssuanceHook } from "../../interfaces/INAVIssuanceHook.sol";
import { Invoke } from "../lib/Invoke.sol";
import { ISetToken } from "../../interfaces/ISetToken.sol";
import { IWETH } from "../../interfaces/external/IWETH.sol";
import { ModuleBase } from "../lib/ModuleBase.sol";
import { Position } from "../lib/Position.sol";
import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";
import { ResourceIdentifier } from "../lib/ResourceIdentifier.sol";


/**
 * @title NavIssuanceModule
 * @author Set Protocol
 *
 * Module that enables issuance and redemption with any valid ERC20 token or ETH if allowed by the manager. Sender receives
 * a proportional amount of SetTokens on issuance or ERC20 token on redemption based on the calculated net asset value using
 * oracle prices. Manager is able to enforce a premium / discount on issuance / redemption to avoid arbitrage and front
 * running when relying on oracle prices. Managers can charge a fee (denominated in reserve asset).
 */
contract NavIssuanceModule is ModuleBase, ReentrancyGuard {
    using AddressArrayUtils for address[];
    using Invoke for ISetToken;
    using Position for ISetToken;
    using PreciseUnitMath for uint256;
    using PreciseUnitMath for int256;
    using ResourceIdentifier for IController;
    using SafeMath for uint256;
    using SafeCast for int256;
    using SafeCast for uint256;
    using SignedSafeMath for int256;

    /* ============ Events ============ */

    event SetTokenNAVIssued(
        ISetToken indexed _setToken,
        address _issuer,
        address _to,
        address _reserveAsset,
        address _hookContract,
        uint256 _setTokenQuantity,
        uint256 _managerFee,
        uint256 _premium
    );

    event SetTokenNAVRedeemed(
        ISetToken indexed _setToken,
        address _redeemer,
        address _to,
        address _reserveAsset,
        address _hookContract,
        uint256 _setTokenQuantity,
        uint256 _managerFee,
        uint256 _premium
    );

    event ReserveAssetAdded(
        ISetToken indexed _setToken,
        address _newReserveAsset
    );

    event ReserveAssetRemoved(
        ISetToken indexed _setToken,
        address _removedReserveAsset
    );

    event PremiumEdited(
        ISetToken indexed _setToken,
        uint256 _newPremium
    );

    event ManagerFeeEdited(
        ISetToken indexed _setToken,
        uint256 _newManagerFee,
        uint256 _index
    );

    event FeeRecipientEdited(
        ISetToken indexed _setToken,
        address _feeRecipient
    );

    /* ============ Structs ============ */

    struct NAVIssuanceSettings {
        INAVIssuanceHook managerIssuanceHook;      // Issuance hook configurations
        INAVIssuanceHook managerRedemptionHook;    // Redemption hook configurations
        address[] reserveAssets;                       // Allowed reserve assets - Must have a price enabled with the price oracle
        address feeRecipient;                          // Manager fee recipient
        uint256[2] managerFees;                        // Manager fees. 0 index is issue and 1 index is redeem fee (0.01% = 1e14, 1% = 1e16)
        uint256 maxManagerFee;                         // Maximum fee manager is allowed to set for issue and redeem
        uint256 premiumPercentage;                     // Premium percentage (0.01% = 1e14, 1% = 1e16). This premium is a buffer around oracle
                                                       // prices paid by user to the SetToken, which prevents arbitrage and oracle front running
        uint256 maxPremiumPercentage;                  // Maximum premium percentage manager is allowed to set (configured by manager)
        uint256 minSetTokenSupply;                     // Minimum SetToken supply required for issuance and redemption
                                                       // to prevent dramatic inflationary changes to the SetToken's position multiplier
    }

    struct ActionInfo {
        uint256 preFeeReserveQuantity;                 // Reserve value before fees; During issuance, represents raw quantity
                                                       // During redeem, represents post-premium value
        uint256 protocolFees;                          // Total protocol fees (direct + manager revenue share)
        uint256 managerFee;                            // Total manager fee paid in reserve asset
        uint256 netFlowQuantity;                       // When issuing, quantity of reserve asset sent to SetToken
                                                       // When redeeming, quantity of reserve asset sent to redeemer
        uint256 setTokenQuantity;                      // When issuing, quantity of SetTokens minted to mintee
                                                       // When redeeming, quantity of SetToken redeemed
        uint256 previousSetTokenSupply;                // SetToken supply prior to issue/redeem action
        uint256 newSetTokenSupply;                     // SetToken supply after issue/redeem action
        int256 newPositionMultiplier;                  // SetToken position multiplier after issue/redeem
        uint256 newReservePositionUnit;                // SetToken reserve asset position unit after issue/redeem
    }

    /* ============ State Variables ============ */

    // Wrapped ETH address
    IWETH public immutable weth;

    // Mapping of SetToken to NAV issuance settings struct
    mapping(ISetToken => NAVIssuanceSettings) public navIssuanceSettings;

    // Mapping to efficiently check a SetToken's reserve asset validity
    // SetToken => reserveAsset => isReserveAsset
    mapping(ISetToken => mapping(address => bool)) public isReserveAsset;

    /* ============ Constants ============ */

    // 0 index stores the manager fee in managerFees array, percentage charged on issue (denominated in reserve asset)
    uint256 constant internal MANAGER_ISSUE_FEE_INDEX = 0;

    // 1 index stores the manager fee percentage in managerFees array, charged on redeem
    uint256 constant internal MANAGER_REDEEM_FEE_INDEX = 1;

    // 0 index stores the manager revenue share protocol fee % on the controller, charged in the issuance function
    uint256 constant internal PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX = 0;

    // 1 index stores the manager revenue share protocol fee % on the controller, charged in the redeem function
    uint256 constant internal PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX = 1;

    // 2 index stores the direct protocol fee % on the controller, charged in the issuance function
    uint256 constant internal PROTOCOL_ISSUE_DIRECT_FEE_INDEX = 2;

    // 3 index stores the direct protocol fee % on the controller, charged in the redeem function
    uint256 constant internal PROTOCOL_REDEEM_DIRECT_FEE_INDEX = 3;

    /* ============ Constructor ============ */

    /**
     * @param _controller               Address of controller contract
     * @param _weth                     Address of wrapped eth
     */
    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {
        weth = _weth;
    }

    /* ============ External Functions ============ */

    /**
     * Deposits the allowed reserve asset into the SetToken and mints the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _reserveAsset                 Address of the reserve asset to issue with
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance
     * @param _to                           Address to mint SetToken to
     */
    function issue(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity,
        uint256 _minSetTokenReceiveQuantity,
        address _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, _reserveAsset, _reserveAssetQuantity);

        _callPreIssueHooks(_setToken, _reserveAsset, _reserveAssetQuantity, msg.sender, _to);

        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, _reserveAsset, _reserveAssetQuantity);

        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);

        _transferCollateralAndHandleFees(_setToken, IERC20(_reserveAsset), issueInfo);

        _handleIssueStateUpdates(_setToken, _reserveAsset, _to, issueInfo);
    }

    /**
     * Wraps ETH and deposits WETH if allowed into the SetToken and mints the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance
     * @param _to                           Address to mint SetToken to
     */
    function issueWithEther(
        ISetToken _setToken,
        uint256 _minSetTokenReceiveQuantity,
        address _to
    )
        external
        payable
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        weth.deposit{ value: msg.value }();

        _validateCommon(_setToken, address(weth), msg.value);

        _callPreIssueHooks(_setToken, address(weth), msg.value, msg.sender, _to);

        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, address(weth), msg.value);

        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);

        _transferWETHAndHandleFees(_setToken, issueInfo);

        _handleIssueStateUpdates(_setToken, address(weth), _to, issueInfo);
    }

    /**
     * Redeems a SetToken into a valid reserve asset representing the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address. Only valid if there are available reserve units on the SetToken.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _reserveAsset                 Address of the reserve asset to redeem with
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive
     * @param _to                           Address to redeem reserve asset to
     */
    function redeem(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity,
        uint256 _minReserveReceiveQuantity,
        address _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, _reserveAsset, _setTokenQuantity);

        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);

        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, _reserveAsset, _setTokenQuantity);

        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);

        _setToken.burn(msg.sender, _setTokenQuantity);

        // Instruct the SetToken to transfer the reserve asset back to the user
        _setToken.strictInvokeTransfer(
            _reserveAsset,
            _to,
            redeemInfo.netFlowQuantity
        );

        _handleRedemptionFees(_setToken, _reserveAsset, redeemInfo);

        _handleRedeemStateUpdates(_setToken, _reserveAsset, _to, redeemInfo);
    }

    /**
     * Redeems a SetToken into Ether (if WETH is valid) representing the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address. Only valid if there are available WETH units on the SetToken.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive
     * @param _to                           Address to redeem reserve asset to
     */
    function redeemIntoEther(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        uint256 _minReserveReceiveQuantity,
        address payable _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, address(weth), _setTokenQuantity);

        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);

        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, address(weth), _setTokenQuantity);

        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);

        _setToken.burn(msg.sender, _setTokenQuantity);

        // Instruct the SetToken to transfer WETH from SetToken to module
        _setToken.strictInvokeTransfer(
            address(weth),
            address(this),
            redeemInfo.netFlowQuantity
        );

        weth.withdraw(redeemInfo.netFlowQuantity);

        _to.transfer(redeemInfo.netFlowQuantity);

        _handleRedemptionFees(_setToken, address(weth), redeemInfo);

        _handleRedeemStateUpdates(_setToken, address(weth), _to, redeemInfo);
    }

    /**
     * SET MANAGER ONLY. Add an allowed reserve asset
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset to add
     */
    function addReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {
        require(!isReserveAsset[_setToken][_reserveAsset], "Reserve asset already exists");

        navIssuanceSettings[_setToken].reserveAssets.push(_reserveAsset);
        isReserveAsset[_setToken][_reserveAsset] = true;

        emit ReserveAssetAdded(_setToken, _reserveAsset);
    }

    /**
     * SET MANAGER ONLY. Remove a reserve asset
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset to remove
     */
    function removeReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {
        require(isReserveAsset[_setToken][_reserveAsset], "Reserve asset does not exist");

        navIssuanceSettings[_setToken].reserveAssets = navIssuanceSettings[_setToken].reserveAssets.remove(_reserveAsset);
        delete isReserveAsset[_setToken][_reserveAsset];

        emit ReserveAssetRemoved(_setToken, _reserveAsset);
    }

    /**
     * SET MANAGER ONLY. Edit the premium percentage
     *
     * @param _setToken                     Instance of the SetToken
     * @param _premiumPercentage            Premium percentage in 10e16 (e.g. 10e16 = 1%)
     */
    function editPremium(ISetToken _setToken, uint256 _premiumPercentage) external onlyManagerAndValidSet(_setToken) {
        require(_premiumPercentage <= navIssuanceSettings[_setToken].maxPremiumPercentage, "Premium must be less than maximum allowed");

        navIssuanceSettings[_setToken].premiumPercentage = _premiumPercentage;

        emit PremiumEdited(_setToken, _premiumPercentage);
    }

    /**
     * SET MANAGER ONLY. Edit manager fee
     *
     * @param _setToken                     Instance of the SetToken
     * @param _managerFeePercentage         Manager fee percentage in 10e16 (e.g. 10e16 = 1%)
     * @param _managerFeeIndex              Manager fee index. 0 index is issue fee, 1 index is redeem fee
     */
    function editManagerFee(
        ISetToken _setToken,
        uint256 _managerFeePercentage,
        uint256 _managerFeeIndex
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        require(_managerFeePercentage <= navIssuanceSettings[_setToken].maxManagerFee, "Manager fee must be less than maximum allowed");

        navIssuanceSettings[_setToken].managerFees[_managerFeeIndex] = _managerFeePercentage;

        emit ManagerFeeEdited(_setToken, _managerFeePercentage, _managerFeeIndex);
    }

    /**
     * SET MANAGER ONLY. Edit the manager fee recipient
     *
     * @param _setToken                     Instance of the SetToken
     * @param _managerFeeRecipient          Manager fee recipient
     */
    function editFeeRecipient(ISetToken _setToken, address _managerFeeRecipient) external onlyManagerAndValidSet(_setToken) {
        require(_managerFeeRecipient != address(0), "Fee recipient must not be 0 address");

        navIssuanceSettings[_setToken].feeRecipient = _managerFeeRecipient;

        emit FeeRecipientEdited(_setToken, _managerFeeRecipient);
    }

    /**
     * SET MANAGER ONLY. Initializes this module to the SetToken with hooks, allowed reserve assets,
     * fees and issuance premium. Only callable by the SetToken's manager. Hook addresses are optional.
     * Address(0) means that no hook will be called.
     *
     * @param _setToken                     Instance of the SetToken to issue
     * @param _navIssuanceSettings          NAVIssuanceSettings struct defining parameters
     */
    function initialize(
        ISetToken _setToken,
        NAVIssuanceSettings memory _navIssuanceSettings
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        require(_navIssuanceSettings.reserveAssets.length > 0, "Reserve assets must be greater than 0");
        require(_navIssuanceSettings.maxManagerFee < PreciseUnitMath.preciseUnit(), "Max manager fee must be less than 100%");
        require(_navIssuanceSettings.maxPremiumPercentage < PreciseUnitMath.preciseUnit(), "Max premium percentage must be less than 100%");
        require(_navIssuanceSettings.managerFees[0] <= _navIssuanceSettings.maxManagerFee, "Manager issue fee must be less than max");
        require(_navIssuanceSettings.managerFees[1] <= _navIssuanceSettings.maxManagerFee, "Manager redeem fee must be less than max");
        require(_navIssuanceSettings.premiumPercentage <= _navIssuanceSettings.maxPremiumPercentage, "Premium must be less than max");
        require(_navIssuanceSettings.feeRecipient != address(0), "Fee Recipient must be non-zero address.");
        // Initial mint of Set cannot use NAVIssuance since minSetTokenSupply must be > 0
        require(_navIssuanceSettings.minSetTokenSupply > 0, "Min SetToken supply must be greater than 0");

        for (uint256 i = 0; i < _navIssuanceSettings.reserveAssets.length; i++) {
            require(!isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]], "Reserve assets must be unique");
            isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]] = true;
        }

        navIssuanceSettings[_setToken] = _navIssuanceSettings;

        _setToken.initializeModule();
    }

    /**
     * Removes this module from the SetToken, via call by the SetToken. Issuance settings and
     * reserve asset states are deleted.
     */
    function removeModule() external override {
        ISetToken setToken = ISetToken(msg.sender);
        for (uint256 i = 0; i < navIssuanceSettings[setToken].reserveAssets.length; i++) {
            delete isReserveAsset[setToken][navIssuanceSettings[setToken].reserveAssets[i]];
        }

        delete navIssuanceSettings[setToken];
    }

    receive() external payable {}

    /* ============ External Getter Functions ============ */

    function getReserveAssets(ISetToken _setToken) external view returns (address[] memory) {
        return navIssuanceSettings[_setToken].reserveAssets;
    }

    function getIssuePremium(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (uint256)
    {
        return _getIssuePremium(_setToken, _reserveAsset, _reserveAssetQuantity);
    }

    function getRedeemPremium(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (uint256)
    {
        return _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);
    }

    function getManagerFee(ISetToken _setToken, uint256 _managerFeeIndex) external view returns (uint256) {
        return navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];
    }

    /**
     * Get the expected SetTokens minted to recipient on issuance
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     *
     * @return  uint256                     Expected SetTokens to be minted to recipient
     */
    function getExpectedSetTokenIssueQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (uint256)
    {
        (,, uint256 netReserveFlow) = _getFees(
            _setToken,
            _reserveAssetQuantity,
            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,
            MANAGER_ISSUE_FEE_INDEX
        );

        uint256 setTotalSupply = _setToken.totalSupply();

        return _getSetTokenMintQuantity(
            _setToken,
            _reserveAsset,
            netReserveFlow,
            setTotalSupply
        );
    }

    /**
     * Get the expected reserve asset to be redeemed
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     *
     * @return  uint256                     Expected reserve asset quantity redeemed
     */
    function getExpectedReserveRedeemQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (uint256)
    {
        uint256 preFeeReserveQuantity = _getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

        (,, uint256 netReserveFlows) = _getFees(
            _setToken,
            preFeeReserveQuantity,
            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
            MANAGER_REDEEM_FEE_INDEX
        );

        return netReserveFlows;
    }

    /**
     * Checks if issue is valid
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     *
     * @return  bool                        Returns true if issue is valid
     */
    function isIssueValid(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (bool)
    {
        uint256 setTotalSupply = _setToken.totalSupply();

    return _reserveAssetQuantity != 0
            && isReserveAsset[_setToken][_reserveAsset]
            && setTotalSupply >= navIssuanceSettings[_setToken].minSetTokenSupply;
    }

    /**
     * Checks if redeem is valid
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     *
     * @return  bool                        Returns true if redeem is valid
     */
    function isRedeemValid(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (bool)
    {
        uint256 setTotalSupply = _setToken.totalSupply();

        if (
            _setTokenQuantity == 0
            || !isReserveAsset[_setToken][_reserveAsset]
            || setTotalSupply < navIssuanceSettings[_setToken].minSetTokenSupply.add(_setTokenQuantity)
        ) {
            return false;
        } else {
            uint256 totalRedeemValue =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

            (,, uint256 expectedRedeemQuantity) = _getFees(
                _setToken,
                totalRedeemValue,
                PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
                PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
                MANAGER_REDEEM_FEE_INDEX
            );

            uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();

            return existingUnit.preciseMul(setTotalSupply) >= expectedRedeemQuantity;
        }
    }

    /* ============ Internal Functions ============ */

    function _validateCommon(ISetToken _setToken, address _reserveAsset, uint256 _quantity) internal view {
        require(_quantity > 0, "Quantity must be > 0");
        require(isReserveAsset[_setToken][_reserveAsset], "Must be valid reserve asset");
    }

    function _validateIssuanceInfo(ISetToken _setToken, uint256 _minSetTokenReceiveQuantity, ActionInfo memory _issueInfo) internal view {
        // Check that total supply is greater than min supply needed for issuance
        // Note: A min supply amount is needed to avoid division by 0 when SetToken supply is 0
        require(
            _issueInfo.previousSetTokenSupply >= navIssuanceSettings[_setToken].minSetTokenSupply,
            "Supply must be greater than minimum to enable issuance"
        );

        require(_issueInfo.setTokenQuantity >= _minSetTokenReceiveQuantity, "Must be greater than min SetToken");
    }

    function _validateRedemptionInfo(
        ISetToken _setToken,
        uint256 _minReserveReceiveQuantity,
        ActionInfo memory _redeemInfo
    )
        internal
        view
    {
        // Check that new supply is more than min supply needed for redemption
        // Note: A min supply amount is needed to avoid division by 0 when redeeming SetToken to 0
        require(
            _redeemInfo.newSetTokenSupply >= navIssuanceSettings[_setToken].minSetTokenSupply,
            "Supply must be greater than minimum to enable redemption"
        );

        require(_redeemInfo.netFlowQuantity >= _minReserveReceiveQuantity, "Must be greater than min receive reserve quantity");
    }

    function _createIssuanceInfo(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        internal
        view
        returns (ActionInfo memory)
    {
        ActionInfo memory issueInfo;

        issueInfo.previousSetTokenSupply = _setToken.totalSupply();

        issueInfo.preFeeReserveQuantity = _reserveAssetQuantity;

        (issueInfo.protocolFees, issueInfo.managerFee, issueInfo.netFlowQuantity) = _getFees(
            _setToken,
            issueInfo.preFeeReserveQuantity,
            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,
            MANAGER_ISSUE_FEE_INDEX
        );

        issueInfo.setTokenQuantity = _getSetTokenMintQuantity(
            _setToken,
            _reserveAsset,
            issueInfo.netFlowQuantity,
            issueInfo.previousSetTokenSupply
        );

        (issueInfo.newSetTokenSupply, issueInfo.newPositionMultiplier) = _getIssuePositionMultiplier(_setToken, issueInfo);

        issueInfo.newReservePositionUnit = _getIssuePositionUnit(_setToken, _reserveAsset, issueInfo);

        return issueInfo;
    }

    function _createRedemptionInfo(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        internal
        view
        returns (ActionInfo memory)
    {
        ActionInfo memory redeemInfo;

        redeemInfo.setTokenQuantity = _setTokenQuantity;

        redeemInfo.preFeeReserveQuantity =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

        (redeemInfo.protocolFees, redeemInfo.managerFee, redeemInfo.netFlowQuantity) = _getFees(
            _setToken,
            redeemInfo.preFeeReserveQuantity,
            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
            MANAGER_REDEEM_FEE_INDEX
        );

        redeemInfo.previousSetTokenSupply = _setToken.totalSupply();

        (redeemInfo.newSetTokenSupply, redeemInfo.newPositionMultiplier) = _getRedeemPositionMultiplier(_setToken, _setTokenQuantity, redeemInfo);

        redeemInfo.newReservePositionUnit = _getRedeemPositionUnit(_setToken, _reserveAsset, redeemInfo);

        return redeemInfo;
    }

    /**
     * Transfer reserve asset from user to SetToken and fees from user to appropriate fee recipients
     */
    function _transferCollateralAndHandleFees(ISetToken _setToken, IERC20 _reserveAsset, ActionInfo memory _issueInfo) internal {
        transferFrom(_reserveAsset, msg.sender, address(_setToken), _issueInfo.netFlowQuantity);

        if (_issueInfo.protocolFees > 0) {
            transferFrom(_reserveAsset, msg.sender, controller.feeRecipient(), _issueInfo.protocolFees);
        }

        if (_issueInfo.managerFee > 0) {
            transferFrom(_reserveAsset, msg.sender, navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);
        }
    }


    /**
      * Transfer WETH from module to SetToken and fees from module to appropriate fee recipients
     */
    function _transferWETHAndHandleFees(ISetToken _setToken, ActionInfo memory _issueInfo) internal {
        weth.transfer(address(_setToken), _issueInfo.netFlowQuantity);

        if (_issueInfo.protocolFees > 0) {
            weth.transfer(controller.feeRecipient(), _issueInfo.protocolFees);
        }

        if (_issueInfo.managerFee > 0) {
            weth.transfer(navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);
        }
    }

    function _handleIssueStateUpdates(
        ISetToken _setToken,
        address _reserveAsset,
        address _to,
        ActionInfo memory _issueInfo
    )
        internal
    {
        _setToken.editPositionMultiplier(_issueInfo.newPositionMultiplier);

        _setToken.editDefaultPosition(_reserveAsset, _issueInfo.newReservePositionUnit);

        _setToken.mint(_to, _issueInfo.setTokenQuantity);

        emit SetTokenNAVIssued(
            _setToken,
            msg.sender,
            _to,
            _reserveAsset,
            address(navIssuanceSettings[_setToken].managerIssuanceHook),
            _issueInfo.setTokenQuantity,
            _issueInfo.managerFee,
            _issueInfo.protocolFees
        );
    }

    function _handleRedeemStateUpdates(
        ISetToken _setToken,
        address _reserveAsset,
        address _to,
        ActionInfo memory _redeemInfo
    )
        internal
    {
        _setToken.editPositionMultiplier(_redeemInfo.newPositionMultiplier);

        _setToken.editDefaultPosition(_reserveAsset, _redeemInfo.newReservePositionUnit);

        emit SetTokenNAVRedeemed(
            _setToken,
            msg.sender,
            _to,
            _reserveAsset,
            address(navIssuanceSettings[_setToken].managerRedemptionHook),
            _redeemInfo.setTokenQuantity,
            _redeemInfo.managerFee,
            _redeemInfo.protocolFees
        );
    }

    function _handleRedemptionFees(ISetToken _setToken, address _reserveAsset, ActionInfo memory _redeemInfo) internal {
        // Instruct the SetToken to transfer protocol fee to fee recipient if there is a fee
        payProtocolFeeFromSetToken(_setToken, _reserveAsset, _redeemInfo.protocolFees);

        // Instruct the SetToken to transfer manager fee to manager fee recipient if there is a fee
        if (_redeemInfo.managerFee > 0) {
            _setToken.strictInvokeTransfer(
                _reserveAsset,
                navIssuanceSettings[_setToken].feeRecipient,
                _redeemInfo.managerFee
            );
        }
    }

    /**
     * Returns the issue premium percentage. Virtual function that can be overridden in future versions of the module
     * and can contain arbitrary logic to calculate the issuance premium.
     */
    function _getIssuePremium(
        ISetToken _setToken,
        address /* _reserveAsset */,
        uint256 /* _reserveAssetQuantity */
    )
        virtual
        internal
        view
        returns (uint256)
    {
        return navIssuanceSettings[_setToken].premiumPercentage;
    }

    /**
     * Returns the redeem premium percentage. Virtual function that can be overridden in future versions of the module
     * and can contain arbitrary logic to calculate the redemption premium.
     */
    function _getRedeemPremium(
        ISetToken _setToken,
        address /* _reserveAsset */,
        uint256 /* _setTokenQuantity */
    )
        virtual
        internal
        view
        returns (uint256)
    {
        return navIssuanceSettings[_setToken].premiumPercentage;
    }

    /**
     * Returns the fees attributed to the manager and the protocol. The fees are calculated as follows:
     *
     * ManagerFee = (manager fee % - % to protocol) * reserveAssetQuantity
     * Protocol Fee = (% manager fee share + direct fee %) * reserveAssetQuantity
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAssetQuantity         Quantity of reserve asset to calculate fees from
     * @param _protocolManagerFeeIndex      Index to pull rev share NAV Issuance fee from the Controller
     * @param _protocolDirectFeeIndex       Index to pull direct NAV issuance fee from the Controller
     * @param _managerFeeIndex              Index from NAVIssuanceSettings (0 = issue fee, 1 = redeem fee)
     *
     * @return  uint256                     Fees paid to the protocol in reserve asset
     * @return  uint256                     Fees paid to the manager in reserve asset
     * @return  uint256                     Net reserve to user net of fees
     */
    function _getFees(
        ISetToken _setToken,
        uint256 _reserveAssetQuantity,
        uint256 _protocolManagerFeeIndex,
        uint256 _protocolDirectFeeIndex,
        uint256 _managerFeeIndex
    )
        internal
        view
        returns (uint256, uint256, uint256)
    {
        (uint256 protocolFeePercentage, uint256 managerFeePercentage) = _getProtocolAndManagerFeePercentages(
            _setToken,
            _protocolManagerFeeIndex,
            _protocolDirectFeeIndex,
            _managerFeeIndex
        );

        // Calculate total notional fees
        uint256 protocolFees = protocolFeePercentage.preciseMul(_reserveAssetQuantity);
        uint256 managerFee = managerFeePercentage.preciseMul(_reserveAssetQuantity);

        uint256 netReserveFlow = _reserveAssetQuantity.sub(protocolFees).sub(managerFee);

        return (protocolFees, managerFee, netReserveFlow);
    }

    function _getProtocolAndManagerFeePercentages(
        ISetToken _setToken,
        uint256 _protocolManagerFeeIndex,
        uint256 _protocolDirectFeeIndex,
        uint256 _managerFeeIndex
    )
        internal
        view
        returns(uint256, uint256)
    {
        // Get protocol fee percentages
        uint256 protocolDirectFeePercent = controller.getModuleFee(address(this), _protocolDirectFeeIndex);
        uint256 protocolManagerShareFeePercent = controller.getModuleFee(address(this), _protocolManagerFeeIndex);
        uint256 managerFeePercent = navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];

        // Calculate revenue share split percentage
        uint256 protocolRevenueSharePercentage = protocolManagerShareFeePercent.preciseMul(managerFeePercent);
        uint256 managerRevenueSharePercentage = managerFeePercent.sub(protocolRevenueSharePercentage);
        uint256 totalProtocolFeePercentage = protocolRevenueSharePercentage.add(protocolDirectFeePercent);

        return (totalProtocolFeePercentage, managerRevenueSharePercentage);
    }

    function _getSetTokenMintQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _netReserveFlows,            // Value of reserve asset net of fees
        uint256 _setTotalSupply
    )
        internal
        view
        returns (uint256)
    {
        uint256 premiumPercentage = _getIssuePremium(_setToken, _reserveAsset, _netReserveFlows);
        uint256 premiumValue = _netReserveFlows.preciseMul(premiumPercentage);

        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (1e18)
        // Reverts if price is not found
        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);

        // Get reserve asset decimals
        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();
        uint256 normalizedTotalReserveQuantityNetFees = _netReserveFlows.preciseDiv(10 ** reserveAssetDecimals);
        uint256 normalizedTotalReserveQuantityNetFeesAndPremium = _netReserveFlows.sub(premiumValue).preciseDiv(10 ** reserveAssetDecimals);

        // Calculate SetTokens to mint to issuer
        uint256 denominator = _setTotalSupply.preciseMul(setTokenValuation).add(normalizedTotalReserveQuantityNetFees).sub(normalizedTotalReserveQuantityNetFeesAndPremium);
        return normalizedTotalReserveQuantityNetFeesAndPremium.preciseMul(_setTotalSupply).preciseDiv(denominator);
    }

    function _getRedeemReserveQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        internal
        view
        returns (uint256)
    {
        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (10e18)
        // Reverts if price is not found
        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);

        uint256 totalRedeemValueInPreciseUnits = _setTokenQuantity.preciseMul(setTokenValuation);
        // Get reserve asset decimals
        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();
        uint256 prePremiumReserveQuantity = totalRedeemValueInPreciseUnits.preciseMul(10 ** reserveAssetDecimals);

        uint256 premiumPercentage = _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);
        uint256 premiumQuantity = prePremiumReserveQuantity.preciseMulCeil(premiumPercentage);

        return prePremiumReserveQuantity.sub(premiumQuantity);
    }

    /**
     * The new position multiplier is calculated as follows:
     * inflationPercentage = (newSupply - oldSupply) / newSupply
     * newMultiplier = (1 - inflationPercentage) * positionMultiplier
     */
    function _getIssuePositionMultiplier(
        ISetToken _setToken,
        ActionInfo memory _issueInfo
    )
        internal
        view
        returns (uint256, int256)
    {
        // Calculate inflation and new position multiplier. Note: Round inflation up in order to round position multiplier down
        uint256 newTotalSupply = _issueInfo.setTokenQuantity.add(_issueInfo.previousSetTokenSupply);
        int256 newPositionMultiplier = _setToken.positionMultiplier()
            .mul(_issueInfo.previousSetTokenSupply.toInt256())
            .div(newTotalSupply.toInt256());

        return (newTotalSupply, newPositionMultiplier);
    }

    /**
     * Calculate deflation and new position multiplier. Note: Round deflation down in order to round position multiplier down
     *
     * The new position multiplier is calculated as follows:
     * deflationPercentage = (oldSupply - newSupply) / newSupply
     * newMultiplier = (1 + deflationPercentage) * positionMultiplier
     */
    function _getRedeemPositionMultiplier(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        ActionInfo memory _redeemInfo
    )
        internal
        view
        returns (uint256, int256)
    {
        uint256 newTotalSupply = _redeemInfo.previousSetTokenSupply.sub(_setTokenQuantity);
        int256 newPositionMultiplier = _setToken.positionMultiplier()
            .mul(_redeemInfo.previousSetTokenSupply.toInt256())
            .div(newTotalSupply.toInt256());

        return (newTotalSupply, newPositionMultiplier);
    }

    /**
     * The new position reserve asset unit is calculated as follows:
     * totalReserve = (oldUnit * oldSetTokenSupply) + reserveQuantity
     * newUnit = totalReserve / newSetTokenSupply
     */
    function _getIssuePositionUnit(
        ISetToken _setToken,
        address _reserveAsset,
        ActionInfo memory _issueInfo
    )
        internal
        view
        returns (uint256)
    {
        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();
        uint256 totalReserve = existingUnit
            .preciseMul(_issueInfo.previousSetTokenSupply)
            .add(_issueInfo.netFlowQuantity);

        return totalReserve.preciseDiv(_issueInfo.newSetTokenSupply);
    }

    /**
     * The new position reserve asset unit is calculated as follows:
     * totalReserve = (oldUnit * oldSetTokenSupply) - reserveQuantityToSendOut
     * newUnit = totalReserve / newSetTokenSupply
     */
    function _getRedeemPositionUnit(
        ISetToken _setToken,
        address _reserveAsset,
        ActionInfo memory _redeemInfo
    )
        internal
        view
        returns (uint256)
    {
        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();
        uint256 totalExistingUnits = existingUnit.preciseMul(_redeemInfo.previousSetTokenSupply);

        uint256 outflow = _redeemInfo.netFlowQuantity.add(_redeemInfo.protocolFees).add(_redeemInfo.managerFee);

        // Require withdrawable quantity is greater than existing collateral
        require(totalExistingUnits >= outflow, "Must be greater than total available collateral");

        return totalExistingUnits.sub(outflow).preciseDiv(_redeemInfo.newSetTokenSupply);
    }

    /**
     * If a pre-issue hook has been configured, call the external-protocol contract. Pre-issue hook logic
     * can contain arbitrary logic including validations, external function calls, etc.
     */
    function _callPreIssueHooks(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity,
        address _caller,
        address _to
    )
        internal
    {
        INAVIssuanceHook preIssueHook = navIssuanceSettings[_setToken].managerIssuanceHook;
        if (address(preIssueHook) != address(0)) {
            preIssueHook.invokePreIssueHook(_setToken, _reserveAsset, _reserveAssetQuantity, _caller, _to);
        }
    }

    /**
     * If a pre-redeem hook has been configured, call the external-protocol contract.
     */
    function _callPreRedeemHooks(ISetToken _setToken, uint256 _setQuantity, address _caller, address _to) internal {
        INAVIssuanceHook preRedeemHook = navIssuanceSettings[_setToken].managerRedemptionHook;
        if (address(preRedeemHook) != address(0)) {
            preRedeemHook.invokePreRedeemHook(_setToken, _setQuantity, _caller, _to);
        }
    }
}.]

###

[2024-01-09 05:31:35 INFO] **[Seminar Conclusion]**:

 ###

[2024-01-09 05:31:35 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 2

[2024-01-09 05:31:35 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /*     Copyright 2020 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol"; import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol"; import { SignedSafeMath } from "@openzeppelin/contracts/math/SignedSafeMath.sol"; import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol"; import { IController } from "../../interfaces/IController.sol"; import { INAVIssuanceHook } from "../../interfaces/INAVIssuanceHook.sol"; import { Invoke } from "../lib/Invoke.sol"; import { ISetToken } from "../../interfaces/ISetToken.sol"; import { IWETH } from "../../interfaces/external/IWETH.sol"; import { ModuleBase } from "../lib/ModuleBase.sol"; import { Position } from "../lib/Position.sol"; import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol"; import { ResourceIdentifier } from "../lib/ResourceIdentifier.sol"; /*  * @title NavIssuanceModule  * @author Set Protocol  *  * Module that enables issuance and redemption with any valid ERC20 token or ETH if allowed by the manager. Sender receives  * a proportional amount of SetTokens on issuance or ERC20 token on redemption based on the calculated net asset value using  * oracle prices. Manager is able to enforce a premium / discount on issuance / redemption to avoid arbitrage and front  * running when relying on oracle prices. Managers can charge a fee (denominated in reserve asset).  / contract NavIssuanceModule is ModuleBase, ReentrancyGuard {     using AddressArrayUtils for address[];     using Invoke for ISetToken;     using Position for ISetToken;     using PreciseUnitMath for uint256;     using PreciseUnitMath for int256;     using ResourceIdentifier for IController;     using SafeMath for uint256;     using SafeCast for int256;     using SafeCast for uint256;     using SignedSafeMath for int256; /* ============ Events ============ */  event SetTokenNAVIssued(     ISetToken indexed _setToken,     address _issuer,     address _to,     address _reserveAsset,     address _hookContract,     uint256 _setTokenQuantity,     uint256 _managerFee,     uint256 _premium );  event SetTokenNAVRedeemed(     ISetToken indexed _setToken,     address _redeemer,     address _to,     address _reserveAsset,     address _hookContract,     uint256 _setTokenQuantity,     uint256 _managerFee,     uint256 _premium );  event ReserveAssetAdded(     ISetToken indexed _setToken,     address _newReserveAsset );  event ReserveAssetRemoved(     ISetToken indexed _setToken,     address _removedReserveAsset );  event PremiumEdited(     ISetToken indexed _setToken,     uint256 _newPremium );  event ManagerFeeEdited(     ISetToken indexed _setToken,     uint256 _newManagerFee,     uint256 _index );  event FeeRecipientEdited(     ISetToken indexed _setToken,     address _feeRecipient );  /* ============ Structs ============ */  struct NAVIssuanceSettings {     INAVIssuanceHook managerIssuanceHook;      // Issuance hook configurations     INAVIssuanceHook managerRedemptionHook;    // Redemption hook configurations     address[] reserveAssets;                       // Allowed reserve assets - Must have a price enabled with the price oracle     address feeRecipient;                          // Manager fee recipient     uint256[2] managerFees;                        // Manager fees. 0 index is issue and 1 index is redeem fee (0.01% = 1e14, 1% = 1e16)     uint256 maxManagerFee;                         // Maximum fee manager is allowed to set for issue and redeem     uint256 premiumPercentage;                     // Premium percentage (0.01% = 1e14, 1% = 1e16). This premium is a buffer around oracle                                                    // prices paid by user to the SetToken, which prevents arbitrage and oracle front running     uint256 maxPremiumPercentage;                  // Maximum premium percentage manager is allowed to set (configured by manager)     uint256 minSetTokenSupply;                     // Minimum SetToken supply required for issuance and redemption                                                    // to prevent dramatic inflationary changes to the SetToken's position multiplier }  struct ActionInfo {     uint256 preFeeReserveQuantity;                 // Reserve value before fees; During issuance, represents raw quantity                                                    // During redeem, represents post-premium value     uint256 protocolFees;                          // Total protocol fees (direct + manager revenue share)     uint256 managerFee;                            // Total manager fee paid in reserve asset     uint256 netFlowQuantity;                       // When issuing, quantity of reserve asset sent to SetToken                                                    // When redeeming, quantity of reserve asset sent to redeemer     uint256 setTokenQuantity;                      // When issuing, quantity of SetTokens minted to mintee                                                    // When redeeming, quantity of SetToken redeemed     uint256 previousSetTokenSupply;                // SetToken supply prior to issue/redeem action     uint256 newSetTokenSupply;                     // SetToken supply after issue/redeem action     int256 newPositionMultiplier;                  // SetToken position multiplier after issue/redeem     uint256 newReservePositionUnit;                // SetToken reserve asset position unit after issue/redeem }  /* ============ State Variables ============ */  // Wrapped ETH address IWETH public immutable weth;  // Mapping of SetToken to NAV issuance settings struct mapping(ISetToken =&gt; NAVIssuanceSettings) public navIssuanceSettings;  // Mapping to efficiently check a SetToken's reserve asset validity // SetToken =&gt; reserveAsset =&gt; isReserveAsset mapping(ISetToken =&gt; mapping(address =&gt; bool)) public isReserveAsset;  /* ============ Constants ============ */  // 0 index stores the manager fee in managerFees array, percentage charged on issue (denominated in reserve asset) uint256 constant internal MANAGER_ISSUE_FEE_INDEX = 0;  // 1 index stores the manager fee percentage in managerFees array, charged on redeem uint256 constant internal MANAGER_REDEEM_FEE_INDEX = 1;  // 0 index stores the manager revenue share protocol fee % on the controller, charged in the issuance function uint256 constant internal PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX = 0;  // 1 index stores the manager revenue share protocol fee % on the controller, charged in the redeem function uint256 constant internal PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX = 1;  // 2 index stores the direct protocol fee % on the controller, charged in the issuance function uint256 constant internal PROTOCOL_ISSUE_DIRECT_FEE_INDEX = 2;  // 3 index stores the direct protocol fee % on the controller, charged in the redeem function uint256 constant internal PROTOCOL_REDEEM_DIRECT_FEE_INDEX = 3;  /* ============ Constructor ============ */  /**  * @param _controller               Address of controller contract  * @param _weth                     Address of wrapped eth  */ constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {     weth = _weth; }  /* ============ External Functions ============ */  /**  * Deposits the allowed reserve asset into the SetToken and mints the appropriate % of Net Asset Value of the SetToken  * to the specified _to address.  *  * @param _setToken                     Instance of the SetToken contract  * @param _reserveAsset                 Address of the reserve asset to issue with  * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with  * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance  * @param _to                           Address to mint SetToken to  */ function issue(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity,     uint256 _minSetTokenReceiveQuantity,     address _to )     external     nonReentrant     onlyValidAndInitializedSet(_setToken) {     _validateCommon(_setToken, _reserveAsset, _reserveAssetQuantity);      _callPreIssueHooks(_setToken, _reserveAsset, _reserveAssetQuantity, msg.sender, _to);      ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, _reserveAsset, _reserveAssetQuantity);      _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);      _transferCollateralAndHandleFees(_setToken, IERC20(_reserveAsset), issueInfo);      _handleIssueStateUpdates(_setToken, _reserveAsset, _to, issueInfo); }  /**  * Wraps ETH and deposits WETH if allowed into the SetToken and mints the appropriate % of Net Asset Value of the SetToken  * to the specified _to address.  *  * @param _setToken                     Instance of the SetToken contract  * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance  * @param _to                           Address to mint SetToken to  */ function issueWithEther(     ISetToken _setToken,     uint256 _minSetTokenReceiveQuantity,     address _to )     external     payable     nonReentrant     onlyValidAndInitializedSet(_setToken) {     weth.deposit{ value: msg.value }();      _validateCommon(_setToken, address(weth), msg.value);      _callPreIssueHooks(_setToken, address(weth), msg.value, msg.sender, _to);      ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, address(weth), msg.value);      _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);      _transferWETHAndHandleFees(_setToken, issueInfo);      _handleIssueStateUpdates(_setToken, address(weth), _to, issueInfo); }  /**  * Redeems a SetToken into a valid reserve asset representing the appropriate % of Net Asset Value of the SetToken  * to the specified _to address. Only valid if there are available reserve units on the SetToken.  *  * @param _setToken                     Instance of the SetToken contract  * @param _reserveAsset                 Address of the reserve asset to redeem with  * @param _setTokenQuantity             Quantity of SetTokens to redeem  * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive  * @param _to                           Address to redeem reserve asset to  */ function redeem(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity,     uint256 _minReserveReceiveQuantity,     address _to )     external     nonReentrant     onlyValidAndInitializedSet(_setToken) {     _validateCommon(_setToken, _reserveAsset, _setTokenQuantity);      _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);      ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, _reserveAsset, _setTokenQuantity);      _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);      _setToken.burn(msg.sender, _setTokenQuantity);      // Instruct the SetToken to transfer the reserve asset back to the user     _setToken.strictInvokeTransfer(         _reserveAsset,         _to,         redeemInfo.netFlowQuantity     );      _handleRedemptionFees(_setToken, _reserveAsset, redeemInfo);      _handleRedeemStateUpdates(_setToken, _reserveAsset, _to, redeemInfo); }  /**  * Redeems a SetToken into Ether (if WETH is valid) representing the appropriate % of Net Asset Value of the SetToken  * to the specified _to address. Only valid if there are available WETH units on the SetToken.  *  * @param _setToken                     Instance of the SetToken contract  * @param _setTokenQuantity             Quantity of SetTokens to redeem  * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive  * @param _to                           Address to redeem reserve asset to  */ function redeemIntoEther(     ISetToken _setToken,     uint256 _setTokenQuantity,     uint256 _minReserveReceiveQuantity,     address payable _to )     external     nonReentrant     onlyValidAndInitializedSet(_setToken) {     _validateCommon(_setToken, address(weth), _setTokenQuantity);      _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);      ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, address(weth), _setTokenQuantity);      _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);      _setToken.burn(msg.sender, _setTokenQuantity);      // Instruct the SetToken to transfer WETH from SetToken to module     _setToken.strictInvokeTransfer(         address(weth),         address(this),         redeemInfo.netFlowQuantity     );      weth.withdraw(redeemInfo.netFlowQuantity);      _to.transfer(redeemInfo.netFlowQuantity);      _handleRedemptionFees(_setToken, address(weth), redeemInfo);      _handleRedeemStateUpdates(_setToken, address(weth), _to, redeemInfo); }  /**  * SET MANAGER ONLY. Add an allowed reserve asset  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset to add  */ function addReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {     require(!isReserveAsset[_setToken][_reserveAsset], "Reserve asset already exists");      navIssuanceSettings[_setToken].reserveAssets.push(_reserveAsset);     isReserveAsset[_setToken][_reserveAsset] = true;      emit ReserveAssetAdded(_setToken, _reserveAsset); }  /**  * SET MANAGER ONLY. Remove a reserve asset  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset to remove  */ function removeReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {     require(isReserveAsset[_setToken][_reserveAsset], "Reserve asset does not exist");      navIssuanceSettings[_setToken].reserveAssets = navIssuanceSettings[_setToken].reserveAssets.remove(_reserveAsset);     delete isReserveAsset[_setToken][_reserveAsset];      emit ReserveAssetRemoved(_setToken, _reserveAsset); }  /**  * SET MANAGER ONLY. Edit the premium percentage  *  * @param _setToken                     Instance of the SetToken  * @param _premiumPercentage            Premium percentage in 10e16 (e.g. 10e16 = 1%)  */ function editPremium(ISetToken _setToken, uint256 _premiumPercentage) external onlyManagerAndValidSet(_setToken) {     require(_premiumPercentage &lt;= navIssuanceSettings[_setToken].maxPremiumPercentage, "Premium must be less than maximum allowed");      navIssuanceSettings[_setToken].premiumPercentage = _premiumPercentage;      emit PremiumEdited(_setToken, _premiumPercentage); }  /**  * SET MANAGER ONLY. Edit manager fee  *  * @param _setToken                     Instance of the SetToken  * @param _managerFeePercentage         Manager fee percentage in 10e16 (e.g. 10e16 = 1%)  * @param _managerFeeIndex              Manager fee index. 0 index is issue fee, 1 index is redeem fee  */ function editManagerFee(     ISetToken _setToken,     uint256 _managerFeePercentage,     uint256 _managerFeeIndex )     external     onlyManagerAndValidSet(_setToken) {     require(_managerFeePercentage &lt;= navIssuanceSettings[_setToken].maxManagerFee, "Manager fee must be less than maximum allowed");      navIssuanceSettings[_setToken].managerFees[_managerFeeIndex] = _managerFeePercentage;      emit ManagerFeeEdited(_setToken, _managerFeePercentage, _managerFeeIndex); }  /**  * SET MANAGER ONLY. Edit the manager fee recipient  *  * @param _setToken                     Instance of the SetToken  * @param _managerFeeRecipient          Manager fee recipient  */ function editFeeRecipient(ISetToken _setToken, address _managerFeeRecipient) external onlyManagerAndValidSet(_setToken) {     require(_managerFeeRecipient != address(0), "Fee recipient must not be 0 address");      navIssuanceSettings[_setToken].feeRecipient = _managerFeeRecipient;      emit FeeRecipientEdited(_setToken, _managerFeeRecipient); }  /**  * SET MANAGER ONLY. Initializes this module to the SetToken with hooks, allowed reserve assets,  * fees and issuance premium. Only callable by the SetToken's manager. Hook addresses are optional.  * Address(0) means that no hook will be called.  *  * @param _setToken                     Instance of the SetToken to issue  * @param _navIssuanceSettings          NAVIssuanceSettings struct defining parameters  */ function initialize(     ISetToken _setToken,     NAVIssuanceSettings memory _navIssuanceSettings )     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     require(_navIssuanceSettings.reserveAssets.length &gt; 0, "Reserve assets must be greater than 0");     require(_navIssuanceSettings.maxManagerFee &lt; PreciseUnitMath.preciseUnit(), "Max manager fee must be less than 100%");     require(_navIssuanceSettings.maxPremiumPercentage &lt; PreciseUnitMath.preciseUnit(), "Max premium percentage must be less than 100%");     require(_navIssuanceSettings.managerFees[0] &lt;= _navIssuanceSettings.maxManagerFee, "Manager issue fee must be less than max");     require(_navIssuanceSettings.managerFees[1] &lt;= _navIssuanceSettings.maxManagerFee, "Manager redeem fee must be less than max");     require(_navIssuanceSettings.premiumPercentage &lt;= _navIssuanceSettings.maxPremiumPercentage, "Premium must be less than max");     require(_navIssuanceSettings.feeRecipient != address(0), "Fee Recipient must be non-zero address.");     // Initial mint of Set cannot use NAVIssuance since minSetTokenSupply must be &gt; 0     require(_navIssuanceSettings.minSetTokenSupply &gt; 0, "Min SetToken supply must be greater than 0");      for (uint256 i = 0; i &lt; _navIssuanceSettings.reserveAssets.length; i++) {         require(!isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]], "Reserve assets must be unique");         isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]] = true;     }      navIssuanceSettings[_setToken] = _navIssuanceSettings;      _setToken.initializeModule(); }  /**  * Removes this module from the SetToken, via call by the SetToken. Issuance settings and  * reserve asset states are deleted.  */ function removeModule() external override {     ISetToken setToken = ISetToken(msg.sender);     for (uint256 i = 0; i &lt; navIssuanceSettings[setToken].reserveAssets.length; i++) {         delete isReserveAsset[setToken][navIssuanceSettings[setToken].reserveAssets[i]];     }      delete navIssuanceSettings[setToken]; }  receive() external payable {}  /* ============ External Getter Functions ============ */  function getReserveAssets(ISetToken _setToken) external view returns (address[] memory) {     return navIssuanceSettings[_setToken].reserveAssets; }  function getIssuePremium(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     external     view     returns (uint256) {     return _getIssuePremium(_setToken, _reserveAsset, _reserveAssetQuantity); }  function getRedeemPremium(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     external     view     returns (uint256) {     return _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity); }  function getManagerFee(ISetToken _setToken, uint256 _managerFeeIndex) external view returns (uint256) {     return navIssuanceSettings[_setToken].managerFees[_managerFeeIndex]; }  /**  * Get the expected SetTokens minted to recipient on issuance  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with  *  * @return  uint256                     Expected SetTokens to be minted to recipient  */ function getExpectedSetTokenIssueQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     external     view     returns (uint256) {     (,, uint256 netReserveFlow) = _getFees(         _setToken,         _reserveAssetQuantity,         PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_ISSUE_DIRECT_FEE_INDEX,         MANAGER_ISSUE_FEE_INDEX     );      uint256 setTotalSupply = _setToken.totalSupply();      return _getSetTokenMintQuantity(         _setToken,         _reserveAsset,         netReserveFlow,         setTotalSupply     ); }  /**  * Get the expected reserve asset to be redeemed  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _setTokenQuantity             Quantity of SetTokens to redeem  *  * @return  uint256                     Expected reserve asset quantity redeemed  */ function getExpectedReserveRedeemQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     external     view     returns (uint256) {     uint256 preFeeReserveQuantity = _getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);      (,, uint256 netReserveFlows) = _getFees(         _setToken,         preFeeReserveQuantity,         PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_REDEEM_DIRECT_FEE_INDEX,         MANAGER_REDEEM_FEE_INDEX     );      return netReserveFlows; }  /**  * Checks if issue is valid  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with  *  * @return  bool                        Returns true if issue is valid  */ function isIssueValid(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     external     view     returns (bool) {     uint256 setTotalSupply = _setToken.totalSupply();  return _reserveAssetQuantity != 0         &amp;&amp; isReserveAsset[_setToken][_reserveAsset]         &amp;&amp; setTotalSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply; }  /**  * Checks if redeem is valid  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _setTokenQuantity             Quantity of SetTokens to redeem  *  * @return  bool                        Returns true if redeem is valid  */ function isRedeemValid(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     external     view     returns (bool) {     uint256 setTotalSupply = _setToken.totalSupply();      if (         _setTokenQuantity == 0         || !isReserveAsset[_setToken][_reserveAsset]         || setTotalSupply &lt; navIssuanceSettings[_setToken].minSetTokenSupply.add(_setTokenQuantity)     ) {         return false;     } else {         uint256 totalRedeemValue =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);          (,, uint256 expectedRedeemQuantity) = _getFees(             _setToken,             totalRedeemValue,             PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,             PROTOCOL_REDEEM_DIRECT_FEE_INDEX,             MANAGER_REDEEM_FEE_INDEX         );          uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();          return existingUnit.preciseMul(setTotalSupply) &gt;= expectedRedeemQuantity;     } }  /* ============ Internal Functions ============ */  function _validateCommon(ISetToken _setToken, address _reserveAsset, uint256 _quantity) internal view {     require(_quantity &gt; 0, "Quantity must be &gt; 0");     require(isReserveAsset[_setToken][_reserveAsset], "Must be valid reserve asset"); }  function _validateIssuanceInfo(ISetToken _setToken, uint256 _minSetTokenReceiveQuantity, ActionInfo memory _issueInfo) internal view {     // Check that total supply is greater than min supply needed for issuance     // Note: A min supply amount is needed to avoid division by 0 when SetToken supply is 0     require(         _issueInfo.previousSetTokenSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply,         "Supply must be greater than minimum to enable issuance"     );      require(_issueInfo.setTokenQuantity &gt;= _minSetTokenReceiveQuantity, "Must be greater than min SetToken"); }  function _validateRedemptionInfo(     ISetToken _setToken,     uint256 _minReserveReceiveQuantity,     ActionInfo memory _redeemInfo )     internal     view {     // Check that new supply is more than min supply needed for redemption     // Note: A min supply amount is needed to avoid division by 0 when redeeming SetToken to 0     require(         _redeemInfo.newSetTokenSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply,         "Supply must be greater than minimum to enable redemption"     );      require(_redeemInfo.netFlowQuantity &gt;= _minReserveReceiveQuantity, "Must be greater than min receive reserve quantity"); }  function _createIssuanceInfo(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     internal     view     returns (ActionInfo memory) {     ActionInfo memory issueInfo;      issueInfo.previousSetTokenSupply = _setToken.totalSupply();      issueInfo.preFeeReserveQuantity = _reserveAssetQuantity;      (issueInfo.protocolFees, issueInfo.managerFee, issueInfo.netFlowQuantity) = _getFees(         _setToken,         issueInfo.preFeeReserveQuantity,         PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_ISSUE_DIRECT_FEE_INDEX,         MANAGER_ISSUE_FEE_INDEX     );      issueInfo.setTokenQuantity = _getSetTokenMintQuantity(         _setToken,         _reserveAsset,         issueInfo.netFlowQuantity,         issueInfo.previousSetTokenSupply     );      (issueInfo.newSetTokenSupply, issueInfo.newPositionMultiplier) = _getIssuePositionMultiplier(_setToken, issueInfo);      issueInfo.newReservePositionUnit = _getIssuePositionUnit(_setToken, _reserveAsset, issueInfo);      return issueInfo; }  function _createRedemptionInfo(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     internal     view     returns (ActionInfo memory) {     ActionInfo memory redeemInfo;      redeemInfo.setTokenQuantity = _setTokenQuantity;      redeemInfo.preFeeReserveQuantity =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);      (redeemInfo.protocolFees, redeemInfo.managerFee, redeemInfo.netFlowQuantity) = _getFees(         _setToken,         redeemInfo.preFeeReserveQuantity,         PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_REDEEM_DIRECT_FEE_INDEX,         MANAGER_REDEEM_FEE_INDEX     );      redeemInfo.previousSetTokenSupply = _setToken.totalSupply();      (redeemInfo.newSetTokenSupply, redeemInfo.newPositionMultiplier) = _getRedeemPositionMultiplier(_setToken, _setTokenQuantity, redeemInfo);      redeemInfo.newReservePositionUnit = _getRedeemPositionUnit(_setToken, _reserveAsset, redeemInfo);      return redeemInfo; }  /**  * Transfer reserve asset from user to SetToken and fees from user to appropriate fee recipients  */ function _transferCollateralAndHandleFees(ISetToken _setToken, IERC20 _reserveAsset, ActionInfo memory _issueInfo) internal {     transferFrom(_reserveAsset, msg.sender, address(_setToken), _issueInfo.netFlowQuantity);      if (_issueInfo.protocolFees &gt; 0) {         transferFrom(_reserveAsset, msg.sender, controller.feeRecipient(), _issueInfo.protocolFees);     }      if (_issueInfo.managerFee &gt; 0) {         transferFrom(_reserveAsset, msg.sender, navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);     } }   /**   * Transfer WETH from module to SetToken and fees from module to appropriate fee recipients  */ function _transferWETHAndHandleFees(ISetToken _setToken, ActionInfo memory _issueInfo) internal {     weth.transfer(address(_setToken), _issueInfo.netFlowQuantity);      if (_issueInfo.protocolFees &gt; 0) {         weth.transfer(controller.feeRecipient(), _issueInfo.protocolFees);     }      if (_issueInfo.managerFee &gt; 0) {         weth.transfer(navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);     } }  function _handleIssueStateUpdates(     ISetToken _setToken,     address _reserveAsset,     address _to,     ActionInfo memory _issueInfo )     internal {     _setToken.editPositionMultiplier(_issueInfo.newPositionMultiplier);      _setToken.editDefaultPosition(_reserveAsset, _issueInfo.newReservePositionUnit);      _setToken.mint(_to, _issueInfo.setTokenQuantity);      emit SetTokenNAVIssued(         _setToken,         msg.sender,         _to,         _reserveAsset,         address(navIssuanceSettings[_setToken].managerIssuanceHook),         _issueInfo.setTokenQuantity,         _issueInfo.managerFee,         _issueInfo.protocolFees     ); }  function _handleRedeemStateUpdates(     ISetToken _setToken,     address _reserveAsset,     address _to,     ActionInfo memory _redeemInfo )     internal {     _setToken.editPositionMultiplier(_redeemInfo.newPositionMultiplier);      _setToken.editDefaultPosition(_reserveAsset, _redeemInfo.newReservePositionUnit);      emit SetTokenNAVRedeemed(         _setToken,         msg.sender,         _to,         _reserveAsset,         address(navIssuanceSettings[_setToken].managerRedemptionHook),         _redeemInfo.setTokenQuantity,         _redeemInfo.managerFee,         _redeemInfo.protocolFees     ); }  function _handleRedemptionFees(ISetToken _setToken, address _reserveAsset, ActionInfo memory _redeemInfo) internal {     // Instruct the SetToken to transfer protocol fee to fee recipient if there is a fee     payProtocolFeeFromSetToken(_setToken, _reserveAsset, _redeemInfo.protocolFees);      // Instruct the SetToken to transfer manager fee to manager fee recipient if there is a fee     if (_redeemInfo.managerFee &gt; 0) {         _setToken.strictInvokeTransfer(             _reserveAsset,             navIssuanceSettings[_setToken].feeRecipient,             _redeemInfo.managerFee         );     } }  /**  * Returns the issue premium percentage. Virtual function that can be overridden in future versions of the module  * and can contain arbitrary logic to calculate the issuance premium.  */ function _getIssuePremium(     ISetToken _setToken,     address /* _reserveAsset */,     uint256 /* _reserveAssetQuantity */ )     virtual     internal     view     returns (uint256) {     return navIssuanceSettings[_setToken].premiumPercentage; }  /**  * Returns the redeem premium percentage. Virtual function that can be overridden in future versions of the module  * and can contain arbitrary logic to calculate the redemption premium.  */ function _getRedeemPremium(     ISetToken _setToken,     address /* _reserveAsset */,     uint256 /* _setTokenQuantity */ )     virtual     internal     view     returns (uint256) {     return navIssuanceSettings[_setToken].premiumPercentage; }  /**  * Returns the fees attributed to the manager and the protocol. The fees are calculated as follows:  *  * ManagerFee = (manager fee % - % to protocol) * reserveAssetQuantity  * Protocol Fee = (% manager fee share + direct fee %) * reserveAssetQuantity  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAssetQuantity         Quantity of reserve asset to calculate fees from  * @param _protocolManagerFeeIndex      Index to pull rev share NAV Issuance fee from the Controller  * @param _protocolDirectFeeIndex       Index to pull direct NAV issuance fee from the Controller  * @param _managerFeeIndex              Index from NAVIssuanceSettings (0 = issue fee, 1 = redeem fee)  *  * @return  uint256                     Fees paid to the protocol in reserve asset  * @return  uint256                     Fees paid to the manager in reserve asset  * @return  uint256                     Net reserve to user net of fees  */ function _getFees(     ISetToken _setToken,     uint256 _reserveAssetQuantity,     uint256 _protocolManagerFeeIndex,     uint256 _protocolDirectFeeIndex,     uint256 _managerFeeIndex )     internal     view     returns (uint256, uint256, uint256) {     (uint256 protocolFeePercentage, uint256 managerFeePercentage) = _getProtocolAndManagerFeePercentages(         _setToken,         _protocolManagerFeeIndex,         _protocolDirectFeeIndex,         _managerFeeIndex     );      // Calculate total notional fees     uint256 protocolFees = protocolFeePercentage.preciseMul(_reserveAssetQuantity);     uint256 managerFee = managerFeePercentage.preciseMul(_reserveAssetQuantity);      uint256 netReserveFlow = _reserveAssetQuantity.sub(protocolFees).sub(managerFee);      return (protocolFees, managerFee, netReserveFlow); }  function _getProtocolAndManagerFeePercentages(     ISetToken _setToken,     uint256 _protocolManagerFeeIndex,     uint256 _protocolDirectFeeIndex,     uint256 _managerFeeIndex )     internal     view     returns(uint256, uint256) {     // Get protocol fee percentages     uint256 protocolDirectFeePercent = controller.getModuleFee(address(this), _protocolDirectFeeIndex);     uint256 protocolManagerShareFeePercent = controller.getModuleFee(address(this), _protocolManagerFeeIndex);     uint256 managerFeePercent = navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];      // Calculate revenue share split percentage     uint256 protocolRevenueSharePercentage = protocolManagerShareFeePercent.preciseMul(managerFeePercent);     uint256 managerRevenueSharePercentage = managerFeePercent.sub(protocolRevenueSharePercentage);     uint256 totalProtocolFeePercentage = protocolRevenueSharePercentage.add(protocolDirectFeePercent);      return (totalProtocolFeePercentage, managerRevenueSharePercentage); }  function _getSetTokenMintQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _netReserveFlows,            // Value of reserve asset net of fees     uint256 _setTotalSupply )     internal     view     returns (uint256) {     uint256 premiumPercentage = _getIssuePremium(_setToken, _reserveAsset, _netReserveFlows);     uint256 premiumValue = _netReserveFlows.preciseMul(premiumPercentage);      // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (1e18)     // Reverts if price is not found     uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);      // Get reserve asset decimals     uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();     uint256 normalizedTotalReserveQuantityNetFees = _netReserveFlows.preciseDiv(10 ** reserveAssetDecimals);     uint256 normalizedTotalReserveQuantityNetFeesAndPremium = _netReserveFlows.sub(premiumValue).preciseDiv(10 ** reserveAssetDecimals);      // Calculate SetTokens to mint to issuer     uint256 denominator = _setTotalSupply.preciseMul(setTokenValuation).add(normalizedTotalReserveQuantityNetFees).sub(normalizedTotalReserveQuantityNetFeesAndPremium);     return normalizedTotalReserveQuantityNetFeesAndPremium.preciseMul(_setTotalSupply).preciseDiv(denominator); }  function _getRedeemReserveQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     internal     view     returns (uint256) {     // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (10e18)     // Reverts if price is not found     uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);      uint256 totalRedeemValueInPreciseUnits = _setTokenQuantity.preciseMul(setTokenValuation);     // Get reserve asset decimals     uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();     uint256 prePremiumReserveQuantity = totalRedeemValueInPreciseUnits.preciseMul(10 ** reserveAssetDecimals);      uint256 premiumPercentage = _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);     uint256 premiumQuantity = prePremiumReserveQuantity.preciseMulCeil(premiumPercentage);      return prePremiumReserveQuantity.sub(premiumQuantity); }  /**  * The new position multiplier is calculated as follows:  * inflationPercentage = (newSupply - oldSupply) / newSupply  * newMultiplier = (1 - inflationPercentage) * positionMultiplier  */ function _getIssuePositionMultiplier(     ISetToken _setToken,     ActionInfo memory _issueInfo )     internal     view     returns (uint256, int256) {     // Calculate inflation and new position multiplier. Note: Round inflation up in order to round position multiplier down     uint256 newTotalSupply = _issueInfo.setTokenQuantity.add(_issueInfo.previousSetTokenSupply);     int256 newPositionMultiplier = _setToken.positionMultiplier()         .mul(_issueInfo.previousSetTokenSupply.toInt256())         .div(newTotalSupply.toInt256());      return (newTotalSupply, newPositionMultiplier); }  /**  * Calculate deflation and new position multiplier. Note: Round deflation down in order to round position multiplier down  *  * The new position multiplier is calculated as follows:  * deflationPercentage = (oldSupply - newSupply) / newSupply  * newMultiplier = (1 + deflationPercentage) * positionMultiplier  */ function _getRedeemPositionMultiplier(     ISetToken _setToken,     uint256 _setTokenQuantity,     ActionInfo memory _redeemInfo )     internal     view     returns (uint256, int256) {     uint256 newTotalSupply = _redeemInfo.previousSetTokenSupply.sub(_setTokenQuantity);     int256 newPositionMultiplier = _setToken.positionMultiplier()         .mul(_redeemInfo.previousSetTokenSupply.toInt256())         .div(newTotalSupply.toInt256());      return (newTotalSupply, newPositionMultiplier); }  /**  * The new position reserve asset unit is calculated as follows:  * totalReserve = (oldUnit * oldSetTokenSupply) + reserveQuantity  * newUnit = totalReserve / newSetTokenSupply  */ function _getIssuePositionUnit(     ISetToken _setToken,     address _reserveAsset,     ActionInfo memory _issueInfo )     internal     view     returns (uint256) {     uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();     uint256 totalReserve = existingUnit         .preciseMul(_issueInfo.previousSetTokenSupply)         .add(_issueInfo.netFlowQuantity);      return totalReserve.preciseDiv(_issueInfo.newSetTokenSupply); }  /**  * The new position reserve asset unit is calculated as follows:  * totalReserve = (oldUnit * oldSetTokenSupply) - reserveQuantityToSendOut  * newUnit = totalReserve / newSetTokenSupply  */ function _getRedeemPositionUnit(     ISetToken _setToken,     address _reserveAsset,     ActionInfo memory _redeemInfo )     internal     view     returns (uint256) {     uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();     uint256 totalExistingUnits = existingUnit.preciseMul(_redeemInfo.previousSetTokenSupply);      uint256 outflow = _redeemInfo.netFlowQuantity.add(_redeemInfo.protocolFees).add(_redeemInfo.managerFee);      // Require withdrawable quantity is greater than existing collateral     require(totalExistingUnits &gt;= outflow, "Must be greater than total available collateral");      return totalExistingUnits.sub(outflow).preciseDiv(_redeemInfo.newSetTokenSupply); }  /**  * If a pre-issue hook has been configured, call the external-protocol contract. Pre-issue hook logic  * can contain arbitrary logic including validations, external function calls, etc.  */ function _callPreIssueHooks(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity,     address _caller,     address _to )     internal {     INAVIssuanceHook preIssueHook = navIssuanceSettings[_setToken].managerIssuanceHook;     if (address(preIssueHook) != address(0)) {         preIssueHook.invokePreIssueHook(_setToken, _reserveAsset, _reserveAssetQuantity, _caller, _to);     } }  /**  * If a pre-redeem hook has been configured, call the external-protocol contract.  */ function _callPreRedeemHooks(ISetToken _setToken, uint256 _setQuantity, address _caller, address _to) internal {     INAVIssuanceHook preRedeemHook = navIssuanceSettings[_setToken].managerRedemptionHook;     if (address(preRedeemHook) != address(0)) {         preRedeemHook.invokePreRedeemHook(_setToken, _setQuantity, _caller, _to);     } }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 05:31:35 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | /*     Copyright 2020 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol"; import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol"; import { SignedSafeMath } from "@openzeppelin/contracts/math/SignedSafeMath.sol"; import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol"; import { IController } from "../../interfaces/IController.sol"; import { INAVIssuanceHook } from "../../interfaces/INAVIssuanceHook.sol"; import { Invoke } from "../lib/Invoke.sol"; import { ISetToken } from "../../interfaces/ISetToken.sol"; import { IWETH } from "../../interfaces/external/IWETH.sol"; import { ModuleBase } from "../lib/ModuleBase.sol"; import { Position } from "../lib/Position.sol"; import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol"; import { ResourceIdentifier } from "../lib/ResourceIdentifier.sol"; /*  * @title NavIssuanceModule  * @author Set Protocol  *  * Module that enables issuance and redemption with any valid ERC20 token or ETH if allowed by the manager. Sender receives  * a proportional amount of SetTokens on issuance or ERC20 token on redemption based on the calculated net asset value using  * oracle prices. Manager is able to enforce a premium / discount on issuance / redemption to avoid arbitrage and front  * running when relying on oracle prices. Managers can charge a fee (denominated in reserve asset).  / contract NavIssuanceModule is ModuleBase, ReentrancyGuard {     using AddressArrayUtils for address[];     using Invoke for ISetToken;     using Position for ISetToken;     using PreciseUnitMath for uint256;     using PreciseUnitMath for int256;     using ResourceIdentifier for IController;     using SafeMath for uint256;     using SafeCast for int256;     using SafeCast for uint256;     using SignedSafeMath for int256; /* ============ Events ============ */  event SetTokenNAVIssued(     ISetToken indexed _setToken,     address _issuer,     address _to,     address _reserveAsset,     address _hookContract,     uint256 _setTokenQuantity,     uint256 _managerFee,     uint256 _premium );  event SetTokenNAVRedeemed(     ISetToken indexed _setToken,     address _redeemer,     address _to,     address _reserveAsset,     address _hookContract,     uint256 _setTokenQuantity,     uint256 _managerFee,     uint256 _premium );  event ReserveAssetAdded(     ISetToken indexed _setToken,     address _newReserveAsset );  event ReserveAssetRemoved(     ISetToken indexed _setToken,     address _removedReserveAsset );  event PremiumEdited(     ISetToken indexed _setToken,     uint256 _newPremium );  event ManagerFeeEdited(     ISetToken indexed _setToken,     uint256 _newManagerFee,     uint256 _index );  event FeeRecipientEdited(     ISetToken indexed _setToken,     address _feeRecipient );  /* ============ Structs ============ */  struct NAVIssuanceSettings {     INAVIssuanceHook managerIssuanceHook;      // Issuance hook configurations     INAVIssuanceHook managerRedemptionHook;    // Redemption hook configurations     address[] reserveAssets;                       // Allowed reserve assets - Must have a price enabled with the price oracle     address feeRecipient;                          // Manager fee recipient     uint256[2] managerFees;                        // Manager fees. 0 index is issue and 1 index is redeem fee (0.01% = 1e14, 1% = 1e16)     uint256 maxManagerFee;                         // Maximum fee manager is allowed to set for issue and redeem     uint256 premiumPercentage;                     // Premium percentage (0.01% = 1e14, 1% = 1e16). This premium is a buffer around oracle                                                    // prices paid by user to the SetToken, which prevents arbitrage and oracle front running     uint256 maxPremiumPercentage;                  // Maximum premium percentage manager is allowed to set (configured by manager)     uint256 minSetTokenSupply;                     // Minimum SetToken supply required for issuance and redemption                                                    // to prevent dramatic inflationary changes to the SetToken's position multiplier }  struct ActionInfo {     uint256 preFeeReserveQuantity;                 // Reserve value before fees; During issuance, represents raw quantity                                                    // During redeem, represents post-premium value     uint256 protocolFees;                          // Total protocol fees (direct + manager revenue share)     uint256 managerFee;                            // Total manager fee paid in reserve asset     uint256 netFlowQuantity;                       // When issuing, quantity of reserve asset sent to SetToken                                                    // When redeeming, quantity of reserve asset sent to redeemer     uint256 setTokenQuantity;                      // When issuing, quantity of SetTokens minted to mintee                                                    // When redeeming, quantity of SetToken redeemed     uint256 previousSetTokenSupply;                // SetToken supply prior to issue/redeem action     uint256 newSetTokenSupply;                     // SetToken supply after issue/redeem action     int256 newPositionMultiplier;                  // SetToken position multiplier after issue/redeem     uint256 newReservePositionUnit;                // SetToken reserve asset position unit after issue/redeem }  /* ============ State Variables ============ */  // Wrapped ETH address IWETH public immutable weth;  // Mapping of SetToken to NAV issuance settings struct mapping(ISetToken =&gt; NAVIssuanceSettings) public navIssuanceSettings;  // Mapping to efficiently check a SetToken's reserve asset validity // SetToken =&gt; reserveAsset =&gt; isReserveAsset mapping(ISetToken =&gt; mapping(address =&gt; bool)) public isReserveAsset;  /* ============ Constants ============ */  // 0 index stores the manager fee in managerFees array, percentage charged on issue (denominated in reserve asset) uint256 constant internal MANAGER_ISSUE_FEE_INDEX = 0;  // 1 index stores the manager fee percentage in managerFees array, charged on redeem uint256 constant internal MANAGER_REDEEM_FEE_INDEX = 1;  // 0 index stores the manager revenue share protocol fee % on the controller, charged in the issuance function uint256 constant internal PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX = 0;  // 1 index stores the manager revenue share protocol fee % on the controller, charged in the redeem function uint256 constant internal PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX = 1;  // 2 index stores the direct protocol fee % on the controller, charged in the issuance function uint256 constant internal PROTOCOL_ISSUE_DIRECT_FEE_INDEX = 2;  // 3 index stores the direct protocol fee % on the controller, charged in the redeem function uint256 constant internal PROTOCOL_REDEEM_DIRECT_FEE_INDEX = 3;  /* ============ Constructor ============ */  /**  * @param _controller               Address of controller contract  * @param _weth                     Address of wrapped eth  */ constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {     weth = _weth; }  /* ============ External Functions ============ */  /**  * Deposits the allowed reserve asset into the SetToken and mints the appropriate % of Net Asset Value of the SetToken  * to the specified _to address.  *  * @param _setToken                     Instance of the SetToken contract  * @param _reserveAsset                 Address of the reserve asset to issue with  * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with  * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance  * @param _to                           Address to mint SetToken to  */ function issue(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity,     uint256 _minSetTokenReceiveQuantity,     address _to )     external     nonReentrant     onlyValidAndInitializedSet(_setToken) {     _validateCommon(_setToken, _reserveAsset, _reserveAssetQuantity);      _callPreIssueHooks(_setToken, _reserveAsset, _reserveAssetQuantity, msg.sender, _to);      ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, _reserveAsset, _reserveAssetQuantity);      _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);      _transferCollateralAndHandleFees(_setToken, IERC20(_reserveAsset), issueInfo);      _handleIssueStateUpdates(_setToken, _reserveAsset, _to, issueInfo); }  /**  * Wraps ETH and deposits WETH if allowed into the SetToken and mints the appropriate % of Net Asset Value of the SetToken  * to the specified _to address.  *  * @param _setToken                     Instance of the SetToken contract  * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance  * @param _to                           Address to mint SetToken to  */ function issueWithEther(     ISetToken _setToken,     uint256 _minSetTokenReceiveQuantity,     address _to )     external     payable     nonReentrant     onlyValidAndInitializedSet(_setToken) {     weth.deposit{ value: msg.value }();      _validateCommon(_setToken, address(weth), msg.value);      _callPreIssueHooks(_setToken, address(weth), msg.value, msg.sender, _to);      ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, address(weth), msg.value);      _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);      _transferWETHAndHandleFees(_setToken, issueInfo);      _handleIssueStateUpdates(_setToken, address(weth), _to, issueInfo); }  /**  * Redeems a SetToken into a valid reserve asset representing the appropriate % of Net Asset Value of the SetToken  * to the specified _to address. Only valid if there are available reserve units on the SetToken.  *  * @param _setToken                     Instance of the SetToken contract  * @param _reserveAsset                 Address of the reserve asset to redeem with  * @param _setTokenQuantity             Quantity of SetTokens to redeem  * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive  * @param _to                           Address to redeem reserve asset to  */ function redeem(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity,     uint256 _minReserveReceiveQuantity,     address _to )     external     nonReentrant     onlyValidAndInitializedSet(_setToken) {     _validateCommon(_setToken, _reserveAsset, _setTokenQuantity);      _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);      ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, _reserveAsset, _setTokenQuantity);      _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);      _setToken.burn(msg.sender, _setTokenQuantity);      // Instruct the SetToken to transfer the reserve asset back to the user     _setToken.strictInvokeTransfer(         _reserveAsset,         _to,         redeemInfo.netFlowQuantity     );      _handleRedemptionFees(_setToken, _reserveAsset, redeemInfo);      _handleRedeemStateUpdates(_setToken, _reserveAsset, _to, redeemInfo); }  /**  * Redeems a SetToken into Ether (if WETH is valid) representing the appropriate % of Net Asset Value of the SetToken  * to the specified _to address. Only valid if there are available WETH units on the SetToken.  *  * @param _setToken                     Instance of the SetToken contract  * @param _setTokenQuantity             Quantity of SetTokens to redeem  * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive  * @param _to                           Address to redeem reserve asset to  */ function redeemIntoEther(     ISetToken _setToken,     uint256 _setTokenQuantity,     uint256 _minReserveReceiveQuantity,     address payable _to )     external     nonReentrant     onlyValidAndInitializedSet(_setToken) {     _validateCommon(_setToken, address(weth), _setTokenQuantity);      _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);      ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, address(weth), _setTokenQuantity);      _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);      _setToken.burn(msg.sender, _setTokenQuantity);      // Instruct the SetToken to transfer WETH from SetToken to module     _setToken.strictInvokeTransfer(         address(weth),         address(this),         redeemInfo.netFlowQuantity     );      weth.withdraw(redeemInfo.netFlowQuantity);      _to.transfer(redeemInfo.netFlowQuantity);      _handleRedemptionFees(_setToken, address(weth), redeemInfo);      _handleRedeemStateUpdates(_setToken, address(weth), _to, redeemInfo); }  /**  * SET MANAGER ONLY. Add an allowed reserve asset  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset to add  */ function addReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {     require(!isReserveAsset[_setToken][_reserveAsset], "Reserve asset already exists");      navIssuanceSettings[_setToken].reserveAssets.push(_reserveAsset);     isReserveAsset[_setToken][_reserveAsset] = true;      emit ReserveAssetAdded(_setToken, _reserveAsset); }  /**  * SET MANAGER ONLY. Remove a reserve asset  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset to remove  */ function removeReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {     require(isReserveAsset[_setToken][_reserveAsset], "Reserve asset does not exist");      navIssuanceSettings[_setToken].reserveAssets = navIssuanceSettings[_setToken].reserveAssets.remove(_reserveAsset);     delete isReserveAsset[_setToken][_reserveAsset];      emit ReserveAssetRemoved(_setToken, _reserveAsset); }  /**  * SET MANAGER ONLY. Edit the premium percentage  *  * @param _setToken                     Instance of the SetToken  * @param _premiumPercentage            Premium percentage in 10e16 (e.g. 10e16 = 1%)  */ function editPremium(ISetToken _setToken, uint256 _premiumPercentage) external onlyManagerAndValidSet(_setToken) {     require(_premiumPercentage &lt;= navIssuanceSettings[_setToken].maxPremiumPercentage, "Premium must be less than maximum allowed");      navIssuanceSettings[_setToken].premiumPercentage = _premiumPercentage;      emit PremiumEdited(_setToken, _premiumPercentage); }  /**  * SET MANAGER ONLY. Edit manager fee  *  * @param _setToken                     Instance of the SetToken  * @param _managerFeePercentage         Manager fee percentage in 10e16 (e.g. 10e16 = 1%)  * @param _managerFeeIndex              Manager fee index. 0 index is issue fee, 1 index is redeem fee  */ function editManagerFee(     ISetToken _setToken,     uint256 _managerFeePercentage,     uint256 _managerFeeIndex )     external     onlyManagerAndValidSet(_setToken) {     require(_managerFeePercentage &lt;= navIssuanceSettings[_setToken].maxManagerFee, "Manager fee must be less than maximum allowed");      navIssuanceSettings[_setToken].managerFees[_managerFeeIndex] = _managerFeePercentage;      emit ManagerFeeEdited(_setToken, _managerFeePercentage, _managerFeeIndex); }  /**  * SET MANAGER ONLY. Edit the manager fee recipient  *  * @param _setToken                     Instance of the SetToken  * @param _managerFeeRecipient          Manager fee recipient  */ function editFeeRecipient(ISetToken _setToken, address _managerFeeRecipient) external onlyManagerAndValidSet(_setToken) {     require(_managerFeeRecipient != address(0), "Fee recipient must not be 0 address");      navIssuanceSettings[_setToken].feeRecipient = _managerFeeRecipient;      emit FeeRecipientEdited(_setToken, _managerFeeRecipient); }  /**  * SET MANAGER ONLY. Initializes this module to the SetToken with hooks, allowed reserve assets,  * fees and issuance premium. Only callable by the SetToken's manager. Hook addresses are optional.  * Address(0) means that no hook will be called.  *  * @param _setToken                     Instance of the SetToken to issue  * @param _navIssuanceSettings          NAVIssuanceSettings struct defining parameters  */ function initialize(     ISetToken _setToken,     NAVIssuanceSettings memory _navIssuanceSettings )     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     require(_navIssuanceSettings.reserveAssets.length &gt; 0, "Reserve assets must be greater than 0");     require(_navIssuanceSettings.maxManagerFee &lt; PreciseUnitMath.preciseUnit(), "Max manager fee must be less than 100%");     require(_navIssuanceSettings.maxPremiumPercentage &lt; PreciseUnitMath.preciseUnit(), "Max premium percentage must be less than 100%");     require(_navIssuanceSettings.managerFees[0] &lt;= _navIssuanceSettings.maxManagerFee, "Manager issue fee must be less than max");     require(_navIssuanceSettings.managerFees[1] &lt;= _navIssuanceSettings.maxManagerFee, "Manager redeem fee must be less than max");     require(_navIssuanceSettings.premiumPercentage &lt;= _navIssuanceSettings.maxPremiumPercentage, "Premium must be less than max");     require(_navIssuanceSettings.feeRecipient != address(0), "Fee Recipient must be non-zero address.");     // Initial mint of Set cannot use NAVIssuance since minSetTokenSupply must be &gt; 0     require(_navIssuanceSettings.minSetTokenSupply &gt; 0, "Min SetToken supply must be greater than 0");      for (uint256 i = 0; i &lt; _navIssuanceSettings.reserveAssets.length; i++) {         require(!isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]], "Reserve assets must be unique");         isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]] = true;     }      navIssuanceSettings[_setToken] = _navIssuanceSettings;      _setToken.initializeModule(); }  /**  * Removes this module from the SetToken, via call by the SetToken. Issuance settings and  * reserve asset states are deleted.  */ function removeModule() external override {     ISetToken setToken = ISetToken(msg.sender);     for (uint256 i = 0; i &lt; navIssuanceSettings[setToken].reserveAssets.length; i++) {         delete isReserveAsset[setToken][navIssuanceSettings[setToken].reserveAssets[i]];     }      delete navIssuanceSettings[setToken]; }  receive() external payable {}  /* ============ External Getter Functions ============ */  function getReserveAssets(ISetToken _setToken) external view returns (address[] memory) {     return navIssuanceSettings[_setToken].reserveAssets; }  function getIssuePremium(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     external     view     returns (uint256) {     return _getIssuePremium(_setToken, _reserveAsset, _reserveAssetQuantity); }  function getRedeemPremium(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     external     view     returns (uint256) {     return _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity); }  function getManagerFee(ISetToken _setToken, uint256 _managerFeeIndex) external view returns (uint256) {     return navIssuanceSettings[_setToken].managerFees[_managerFeeIndex]; }  /**  * Get the expected SetTokens minted to recipient on issuance  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with  *  * @return  uint256                     Expected SetTokens to be minted to recipient  */ function getExpectedSetTokenIssueQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     external     view     returns (uint256) {     (,, uint256 netReserveFlow) = _getFees(         _setToken,         _reserveAssetQuantity,         PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_ISSUE_DIRECT_FEE_INDEX,         MANAGER_ISSUE_FEE_INDEX     );      uint256 setTotalSupply = _setToken.totalSupply();      return _getSetTokenMintQuantity(         _setToken,         _reserveAsset,         netReserveFlow,         setTotalSupply     ); }  /**  * Get the expected reserve asset to be redeemed  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _setTokenQuantity             Quantity of SetTokens to redeem  *  * @return  uint256                     Expected reserve asset quantity redeemed  */ function getExpectedReserveRedeemQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     external     view     returns (uint256) {     uint256 preFeeReserveQuantity = _getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);      (,, uint256 netReserveFlows) = _getFees(         _setToken,         preFeeReserveQuantity,         PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_REDEEM_DIRECT_FEE_INDEX,         MANAGER_REDEEM_FEE_INDEX     );      return netReserveFlows; }  /**  * Checks if issue is valid  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with  *  * @return  bool                        Returns true if issue is valid  */ function isIssueValid(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     external     view     returns (bool) {     uint256 setTotalSupply = _setToken.totalSupply();  return _reserveAssetQuantity != 0         &amp;&amp; isReserveAsset[_setToken][_reserveAsset]         &amp;&amp; setTotalSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply; }  /**  * Checks if redeem is valid  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _setTokenQuantity             Quantity of SetTokens to redeem  *  * @return  bool                        Returns true if redeem is valid  */ function isRedeemValid(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     external     view     returns (bool) {     uint256 setTotalSupply = _setToken.totalSupply();      if (         _setTokenQuantity == 0         || !isReserveAsset[_setToken][_reserveAsset]         || setTotalSupply &lt; navIssuanceSettings[_setToken].minSetTokenSupply.add(_setTokenQuantity)     ) {         return false;     } else {         uint256 totalRedeemValue =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);          (,, uint256 expectedRedeemQuantity) = _getFees(             _setToken,             totalRedeemValue,             PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,             PROTOCOL_REDEEM_DIRECT_FEE_INDEX,             MANAGER_REDEEM_FEE_INDEX         );          uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();          return existingUnit.preciseMul(setTotalSupply) &gt;= expectedRedeemQuantity;     } }  /* ============ Internal Functions ============ */  function _validateCommon(ISetToken _setToken, address _reserveAsset, uint256 _quantity) internal view {     require(_quantity &gt; 0, "Quantity must be &gt; 0");     require(isReserveAsset[_setToken][_reserveAsset], "Must be valid reserve asset"); }  function _validateIssuanceInfo(ISetToken _setToken, uint256 _minSetTokenReceiveQuantity, ActionInfo memory _issueInfo) internal view {     // Check that total supply is greater than min supply needed for issuance     // Note: A min supply amount is needed to avoid division by 0 when SetToken supply is 0     require(         _issueInfo.previousSetTokenSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply,         "Supply must be greater than minimum to enable issuance"     );      require(_issueInfo.setTokenQuantity &gt;= _minSetTokenReceiveQuantity, "Must be greater than min SetToken"); }  function _validateRedemptionInfo(     ISetToken _setToken,     uint256 _minReserveReceiveQuantity,     ActionInfo memory _redeemInfo )     internal     view {     // Check that new supply is more than min supply needed for redemption     // Note: A min supply amount is needed to avoid division by 0 when redeeming SetToken to 0     require(         _redeemInfo.newSetTokenSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply,         "Supply must be greater than minimum to enable redemption"     );      require(_redeemInfo.netFlowQuantity &gt;= _minReserveReceiveQuantity, "Must be greater than min receive reserve quantity"); }  function _createIssuanceInfo(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     internal     view     returns (ActionInfo memory) {     ActionInfo memory issueInfo;      issueInfo.previousSetTokenSupply = _setToken.totalSupply();      issueInfo.preFeeReserveQuantity = _reserveAssetQuantity;      (issueInfo.protocolFees, issueInfo.managerFee, issueInfo.netFlowQuantity) = _getFees(         _setToken,         issueInfo.preFeeReserveQuantity,         PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_ISSUE_DIRECT_FEE_INDEX,         MANAGER_ISSUE_FEE_INDEX     );      issueInfo.setTokenQuantity = _getSetTokenMintQuantity(         _setToken,         _reserveAsset,         issueInfo.netFlowQuantity,         issueInfo.previousSetTokenSupply     );      (issueInfo.newSetTokenSupply, issueInfo.newPositionMultiplier) = _getIssuePositionMultiplier(_setToken, issueInfo);      issueInfo.newReservePositionUnit = _getIssuePositionUnit(_setToken, _reserveAsset, issueInfo);      return issueInfo; }  function _createRedemptionInfo(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     internal     view     returns (ActionInfo memory) {     ActionInfo memory redeemInfo;      redeemInfo.setTokenQuantity = _setTokenQuantity;      redeemInfo.preFeeReserveQuantity =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);      (redeemInfo.protocolFees, redeemInfo.managerFee, redeemInfo.netFlowQuantity) = _getFees(         _setToken,         redeemInfo.preFeeReserveQuantity,         PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_REDEEM_DIRECT_FEE_INDEX,         MANAGER_REDEEM_FEE_INDEX     );      redeemInfo.previousSetTokenSupply = _setToken.totalSupply();      (redeemInfo.newSetTokenSupply, redeemInfo.newPositionMultiplier) = _getRedeemPositionMultiplier(_setToken, _setTokenQuantity, redeemInfo);      redeemInfo.newReservePositionUnit = _getRedeemPositionUnit(_setToken, _reserveAsset, redeemInfo);      return redeemInfo; }  /**  * Transfer reserve asset from user to SetToken and fees from user to appropriate fee recipients  */ function _transferCollateralAndHandleFees(ISetToken _setToken, IERC20 _reserveAsset, ActionInfo memory _issueInfo) internal {     transferFrom(_reserveAsset, msg.sender, address(_setToken), _issueInfo.netFlowQuantity);      if (_issueInfo.protocolFees &gt; 0) {         transferFrom(_reserveAsset, msg.sender, controller.feeRecipient(), _issueInfo.protocolFees);     }      if (_issueInfo.managerFee &gt; 0) {         transferFrom(_reserveAsset, msg.sender, navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);     } }   /**   * Transfer WETH from module to SetToken and fees from module to appropriate fee recipients  */ function _transferWETHAndHandleFees(ISetToken _setToken, ActionInfo memory _issueInfo) internal {     weth.transfer(address(_setToken), _issueInfo.netFlowQuantity);      if (_issueInfo.protocolFees &gt; 0) {         weth.transfer(controller.feeRecipient(), _issueInfo.protocolFees);     }      if (_issueInfo.managerFee &gt; 0) {         weth.transfer(navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);     } }  function _handleIssueStateUpdates(     ISetToken _setToken,     address _reserveAsset,     address _to,     ActionInfo memory _issueInfo )     internal {     _setToken.editPositionMultiplier(_issueInfo.newPositionMultiplier);      _setToken.editDefaultPosition(_reserveAsset, _issueInfo.newReservePositionUnit);      _setToken.mint(_to, _issueInfo.setTokenQuantity);      emit SetTokenNAVIssued(         _setToken,         msg.sender,         _to,         _reserveAsset,         address(navIssuanceSettings[_setToken].managerIssuanceHook),         _issueInfo.setTokenQuantity,         _issueInfo.managerFee,         _issueInfo.protocolFees     ); }  function _handleRedeemStateUpdates(     ISetToken _setToken,     address _reserveAsset,     address _to,     ActionInfo memory _redeemInfo )     internal {     _setToken.editPositionMultiplier(_redeemInfo.newPositionMultiplier);      _setToken.editDefaultPosition(_reserveAsset, _redeemInfo.newReservePositionUnit);      emit SetTokenNAVRedeemed(         _setToken,         msg.sender,         _to,         _reserveAsset,         address(navIssuanceSettings[_setToken].managerRedemptionHook),         _redeemInfo.setTokenQuantity,         _redeemInfo.managerFee,         _redeemInfo.protocolFees     ); }  function _handleRedemptionFees(ISetToken _setToken, address _reserveAsset, ActionInfo memory _redeemInfo) internal {     // Instruct the SetToken to transfer protocol fee to fee recipient if there is a fee     payProtocolFeeFromSetToken(_setToken, _reserveAsset, _redeemInfo.protocolFees);      // Instruct the SetToken to transfer manager fee to manager fee recipient if there is a fee     if (_redeemInfo.managerFee &gt; 0) {         _setToken.strictInvokeTransfer(             _reserveAsset,             navIssuanceSettings[_setToken].feeRecipient,             _redeemInfo.managerFee         );     } }  /**  * Returns the issue premium percentage. Virtual function that can be overridden in future versions of the module  * and can contain arbitrary logic to calculate the issuance premium.  */ function _getIssuePremium(     ISetToken _setToken,     address /* _reserveAsset */,     uint256 /* _reserveAssetQuantity */ )     virtual     internal     view     returns (uint256) {     return navIssuanceSettings[_setToken].premiumPercentage; }  /**  * Returns the redeem premium percentage. Virtual function that can be overridden in future versions of the module  * and can contain arbitrary logic to calculate the redemption premium.  */ function _getRedeemPremium(     ISetToken _setToken,     address /* _reserveAsset */,     uint256 /* _setTokenQuantity */ )     virtual     internal     view     returns (uint256) {     return navIssuanceSettings[_setToken].premiumPercentage; }  /**  * Returns the fees attributed to the manager and the protocol. The fees are calculated as follows:  *  * ManagerFee = (manager fee % - % to protocol) * reserveAssetQuantity  * Protocol Fee = (% manager fee share + direct fee %) * reserveAssetQuantity  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAssetQuantity         Quantity of reserve asset to calculate fees from  * @param _protocolManagerFeeIndex      Index to pull rev share NAV Issuance fee from the Controller  * @param _protocolDirectFeeIndex       Index to pull direct NAV issuance fee from the Controller  * @param _managerFeeIndex              Index from NAVIssuanceSettings (0 = issue fee, 1 = redeem fee)  *  * @return  uint256                     Fees paid to the protocol in reserve asset  * @return  uint256                     Fees paid to the manager in reserve asset  * @return  uint256                     Net reserve to user net of fees  */ function _getFees(     ISetToken _setToken,     uint256 _reserveAssetQuantity,     uint256 _protocolManagerFeeIndex,     uint256 _protocolDirectFeeIndex,     uint256 _managerFeeIndex )     internal     view     returns (uint256, uint256, uint256) {     (uint256 protocolFeePercentage, uint256 managerFeePercentage) = _getProtocolAndManagerFeePercentages(         _setToken,         _protocolManagerFeeIndex,         _protocolDirectFeeIndex,         _managerFeeIndex     );      // Calculate total notional fees     uint256 protocolFees = protocolFeePercentage.preciseMul(_reserveAssetQuantity);     uint256 managerFee = managerFeePercentage.preciseMul(_reserveAssetQuantity);      uint256 netReserveFlow = _reserveAssetQuantity.sub(protocolFees).sub(managerFee);      return (protocolFees, managerFee, netReserveFlow); }  function _getProtocolAndManagerFeePercentages(     ISetToken _setToken,     uint256 _protocolManagerFeeIndex,     uint256 _protocolDirectFeeIndex,     uint256 _managerFeeIndex )     internal     view     returns(uint256, uint256) {     // Get protocol fee percentages     uint256 protocolDirectFeePercent = controller.getModuleFee(address(this), _protocolDirectFeeIndex);     uint256 protocolManagerShareFeePercent = controller.getModuleFee(address(this), _protocolManagerFeeIndex);     uint256 managerFeePercent = navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];      // Calculate revenue share split percentage     uint256 protocolRevenueSharePercentage = protocolManagerShareFeePercent.preciseMul(managerFeePercent);     uint256 managerRevenueSharePercentage = managerFeePercent.sub(protocolRevenueSharePercentage);     uint256 totalProtocolFeePercentage = protocolRevenueSharePercentage.add(protocolDirectFeePercent);      return (totalProtocolFeePercentage, managerRevenueSharePercentage); }  function _getSetTokenMintQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _netReserveFlows,            // Value of reserve asset net of fees     uint256 _setTotalSupply )     internal     view     returns (uint256) {     uint256 premiumPercentage = _getIssuePremium(_setToken, _reserveAsset, _netReserveFlows);     uint256 premiumValue = _netReserveFlows.preciseMul(premiumPercentage);      // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (1e18)     // Reverts if price is not found     uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);      // Get reserve asset decimals     uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();     uint256 normalizedTotalReserveQuantityNetFees = _netReserveFlows.preciseDiv(10 ** reserveAssetDecimals);     uint256 normalizedTotalReserveQuantityNetFeesAndPremium = _netReserveFlows.sub(premiumValue).preciseDiv(10 ** reserveAssetDecimals);      // Calculate SetTokens to mint to issuer     uint256 denominator = _setTotalSupply.preciseMul(setTokenValuation).add(normalizedTotalReserveQuantityNetFees).sub(normalizedTotalReserveQuantityNetFeesAndPremium);     return normalizedTotalReserveQuantityNetFeesAndPremium.preciseMul(_setTotalSupply).preciseDiv(denominator); }  function _getRedeemReserveQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     internal     view     returns (uint256) {     // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (10e18)     // Reverts if price is not found     uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);      uint256 totalRedeemValueInPreciseUnits = _setTokenQuantity.preciseMul(setTokenValuation);     // Get reserve asset decimals     uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();     uint256 prePremiumReserveQuantity = totalRedeemValueInPreciseUnits.preciseMul(10 ** reserveAssetDecimals);      uint256 premiumPercentage = _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);     uint256 premiumQuantity = prePremiumReserveQuantity.preciseMulCeil(premiumPercentage);      return prePremiumReserveQuantity.sub(premiumQuantity); }  /**  * The new position multiplier is calculated as follows:  * inflationPercentage = (newSupply - oldSupply) / newSupply  * newMultiplier = (1 - inflationPercentage) * positionMultiplier  */ function _getIssuePositionMultiplier(     ISetToken _setToken,     ActionInfo memory _issueInfo )     internal     view     returns (uint256, int256) {     // Calculate inflation and new position multiplier. Note: Round inflation up in order to round position multiplier down     uint256 newTotalSupply = _issueInfo.setTokenQuantity.add(_issueInfo.previousSetTokenSupply);     int256 newPositionMultiplier = _setToken.positionMultiplier()         .mul(_issueInfo.previousSetTokenSupply.toInt256())         .div(newTotalSupply.toInt256());      return (newTotalSupply, newPositionMultiplier); }  /**  * Calculate deflation and new position multiplier. Note: Round deflation down in order to round position multiplier down  *  * The new position multiplier is calculated as follows:  * deflationPercentage = (oldSupply - newSupply) / newSupply  * newMultiplier = (1 + deflationPercentage) * positionMultiplier  */ function _getRedeemPositionMultiplier(     ISetToken _setToken,     uint256 _setTokenQuantity,     ActionInfo memory _redeemInfo )     internal     view     returns (uint256, int256) {     uint256 newTotalSupply = _redeemInfo.previousSetTokenSupply.sub(_setTokenQuantity);     int256 newPositionMultiplier = _setToken.positionMultiplier()         .mul(_redeemInfo.previousSetTokenSupply.toInt256())         .div(newTotalSupply.toInt256());      return (newTotalSupply, newPositionMultiplier); }  /**  * The new position reserve asset unit is calculated as follows:  * totalReserve = (oldUnit * oldSetTokenSupply) + reserveQuantity  * newUnit = totalReserve / newSetTokenSupply  */ function _getIssuePositionUnit(     ISetToken _setToken,     address _reserveAsset,     ActionInfo memory _issueInfo )     internal     view     returns (uint256) {     uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();     uint256 totalReserve = existingUnit         .preciseMul(_issueInfo.previousSetTokenSupply)         .add(_issueInfo.netFlowQuantity);      return totalReserve.preciseDiv(_issueInfo.newSetTokenSupply); }  /**  * The new position reserve asset unit is calculated as follows:  * totalReserve = (oldUnit * oldSetTokenSupply) - reserveQuantityToSendOut  * newUnit = totalReserve / newSetTokenSupply  */ function _getRedeemPositionUnit(     ISetToken _setToken,     address _reserveAsset,     ActionInfo memory _redeemInfo )     internal     view     returns (uint256) {     uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();     uint256 totalExistingUnits = existingUnit.preciseMul(_redeemInfo.previousSetTokenSupply);      uint256 outflow = _redeemInfo.netFlowQuantity.add(_redeemInfo.protocolFees).add(_redeemInfo.managerFee);      // Require withdrawable quantity is greater than existing collateral     require(totalExistingUnits &gt;= outflow, "Must be greater than total available collateral");      return totalExistingUnits.sub(outflow).preciseDiv(_redeemInfo.newSetTokenSupply); }  /**  * If a pre-issue hook has been configured, call the external-protocol contract. Pre-issue hook logic  * can contain arbitrary logic including validations, external function calls, etc.  */ function _callPreIssueHooks(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity,     address _caller,     address _to )     internal {     INAVIssuanceHook preIssueHook = navIssuanceSettings[_setToken].managerIssuanceHook;     if (address(preIssueHook) != address(0)) {         preIssueHook.invokePreIssueHook(_setToken, _reserveAsset, _reserveAssetQuantity, _caller, _to);     } }  /**  * If a pre-redeem hook has been configured, call the external-protocol contract.  */ function _callPreRedeemHooks(ISetToken _setToken, uint256 _setQuantity, address _caller, address _to) internal {     INAVIssuanceHook preRedeemHook = navIssuanceSettings[_setToken].managerRedemptionHook;     if (address(preRedeemHook) != address(0)) {         preRedeemHook.invokePreRedeemHook(_setToken, _setQuantity, _caller, _to);     } }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 05:31:35 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: /*
    Copyright 2020 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";
import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";
import { SignedSafeMath } from "@openzeppelin/contracts/math/SignedSafeMath.sol";

import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";
import { IController } from "../../interfaces/IController.sol";
import { INAVIssuanceHook } from "../../interfaces/INAVIssuanceHook.sol";
import { Invoke } from "../lib/Invoke.sol";
import { ISetToken } from "../../interfaces/ISetToken.sol";
import { IWETH } from "../../interfaces/external/IWETH.sol";
import { ModuleBase } from "../lib/ModuleBase.sol";
import { Position } from "../lib/Position.sol";
import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";
import { ResourceIdentifier } from "../lib/ResourceIdentifier.sol";


/**
 * @title NavIssuanceModule
 * @author Set Protocol
 *
 * Module that enables issuance and redemption with any valid ERC20 token or ETH if allowed by the manager. Sender receives
 * a proportional amount of SetTokens on issuance or ERC20 token on redemption based on the calculated net asset value using
 * oracle prices. Manager is able to enforce a premium / discount on issuance / redemption to avoid arbitrage and front
 * running when relying on oracle prices. Managers can charge a fee (denominated in reserve asset).
 */
contract NavIssuanceModule is ModuleBase, ReentrancyGuard {
    using AddressArrayUtils for address[];
    using Invoke for ISetToken;
    using Position for ISetToken;
    using PreciseUnitMath for uint256;
    using PreciseUnitMath for int256;
    using ResourceIdentifier for IController;
    using SafeMath for uint256;
    using SafeCast for int256;
    using SafeCast for uint256;
    using SignedSafeMath for int256;

    /* ============ Events ============ */

    event SetTokenNAVIssued(
        ISetToken indexed _setToken,
        address _issuer,
        address _to,
        address _reserveAsset,
        address _hookContract,
        uint256 _setTokenQuantity,
        uint256 _managerFee,
        uint256 _premium
    );

    event SetTokenNAVRedeemed(
        ISetToken indexed _setToken,
        address _redeemer,
        address _to,
        address _reserveAsset,
        address _hookContract,
        uint256 _setTokenQuantity,
        uint256 _managerFee,
        uint256 _premium
    );

    event ReserveAssetAdded(
        ISetToken indexed _setToken,
        address _newReserveAsset
    );

    event ReserveAssetRemoved(
        ISetToken indexed _setToken,
        address _removedReserveAsset
    );

    event PremiumEdited(
        ISetToken indexed _setToken,
        uint256 _newPremium
    );

    event ManagerFeeEdited(
        ISetToken indexed _setToken,
        uint256 _newManagerFee,
        uint256 _index
    );

    event FeeRecipientEdited(
        ISetToken indexed _setToken,
        address _feeRecipient
    );

    /* ============ Structs ============ */

    struct NAVIssuanceSettings {
        INAVIssuanceHook managerIssuanceHook;      // Issuance hook configurations
        INAVIssuanceHook managerRedemptionHook;    // Redemption hook configurations
        address[] reserveAssets;                       // Allowed reserve assets - Must have a price enabled with the price oracle
        address feeRecipient;                          // Manager fee recipient
        uint256[2] managerFees;                        // Manager fees. 0 index is issue and 1 index is redeem fee (0.01% = 1e14, 1% = 1e16)
        uint256 maxManagerFee;                         // Maximum fee manager is allowed to set for issue and redeem
        uint256 premiumPercentage;                     // Premium percentage (0.01% = 1e14, 1% = 1e16). This premium is a buffer around oracle
                                                       // prices paid by user to the SetToken, which prevents arbitrage and oracle front running
        uint256 maxPremiumPercentage;                  // Maximum premium percentage manager is allowed to set (configured by manager)
        uint256 minSetTokenSupply;                     // Minimum SetToken supply required for issuance and redemption
                                                       // to prevent dramatic inflationary changes to the SetToken's position multiplier
    }

    struct ActionInfo {
        uint256 preFeeReserveQuantity;                 // Reserve value before fees; During issuance, represents raw quantity
                                                       // During redeem, represents post-premium value
        uint256 protocolFees;                          // Total protocol fees (direct + manager revenue share)
        uint256 managerFee;                            // Total manager fee paid in reserve asset
        uint256 netFlowQuantity;                       // When issuing, quantity of reserve asset sent to SetToken
                                                       // When redeeming, quantity of reserve asset sent to redeemer
        uint256 setTokenQuantity;                      // When issuing, quantity of SetTokens minted to mintee
                                                       // When redeeming, quantity of SetToken redeemed
        uint256 previousSetTokenSupply;                // SetToken supply prior to issue/redeem action
        uint256 newSetTokenSupply;                     // SetToken supply after issue/redeem action
        int256 newPositionMultiplier;                  // SetToken position multiplier after issue/redeem
        uint256 newReservePositionUnit;                // SetToken reserve asset position unit after issue/redeem
    }

    /* ============ State Variables ============ */

    // Wrapped ETH address
    IWETH public immutable weth;

    // Mapping of SetToken to NAV issuance settings struct
    mapping(ISetToken => NAVIssuanceSettings) public navIssuanceSettings;

    // Mapping to efficiently check a SetToken's reserve asset validity
    // SetToken => reserveAsset => isReserveAsset
    mapping(ISetToken => mapping(address => bool)) public isReserveAsset;

    /* ============ Constants ============ */

    // 0 index stores the manager fee in managerFees array, percentage charged on issue (denominated in reserve asset)
    uint256 constant internal MANAGER_ISSUE_FEE_INDEX = 0;

    // 1 index stores the manager fee percentage in managerFees array, charged on redeem
    uint256 constant internal MANAGER_REDEEM_FEE_INDEX = 1;

    // 0 index stores the manager revenue share protocol fee % on the controller, charged in the issuance function
    uint256 constant internal PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX = 0;

    // 1 index stores the manager revenue share protocol fee % on the controller, charged in the redeem function
    uint256 constant internal PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX = 1;

    // 2 index stores the direct protocol fee % on the controller, charged in the issuance function
    uint256 constant internal PROTOCOL_ISSUE_DIRECT_FEE_INDEX = 2;

    // 3 index stores the direct protocol fee % on the controller, charged in the redeem function
    uint256 constant internal PROTOCOL_REDEEM_DIRECT_FEE_INDEX = 3;

    /* ============ Constructor ============ */

    /**
     * @param _controller               Address of controller contract
     * @param _weth                     Address of wrapped eth
     */
    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {
        weth = _weth;
    }

    /* ============ External Functions ============ */

    /**
     * Deposits the allowed reserve asset into the SetToken and mints the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _reserveAsset                 Address of the reserve asset to issue with
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance
     * @param _to                           Address to mint SetToken to
     */
    function issue(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity,
        uint256 _minSetTokenReceiveQuantity,
        address _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, _reserveAsset, _reserveAssetQuantity);

        _callPreIssueHooks(_setToken, _reserveAsset, _reserveAssetQuantity, msg.sender, _to);

        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, _reserveAsset, _reserveAssetQuantity);

        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);

        _transferCollateralAndHandleFees(_setToken, IERC20(_reserveAsset), issueInfo);

        _handleIssueStateUpdates(_setToken, _reserveAsset, _to, issueInfo);
    }

    /**
     * Wraps ETH and deposits WETH if allowed into the SetToken and mints the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance
     * @param _to                           Address to mint SetToken to
     */
    function issueWithEther(
        ISetToken _setToken,
        uint256 _minSetTokenReceiveQuantity,
        address _to
    )
        external
        payable
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        weth.deposit{ value: msg.value }();

        _validateCommon(_setToken, address(weth), msg.value);

        _callPreIssueHooks(_setToken, address(weth), msg.value, msg.sender, _to);

        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, address(weth), msg.value);

        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);

        _transferWETHAndHandleFees(_setToken, issueInfo);

        _handleIssueStateUpdates(_setToken, address(weth), _to, issueInfo);
    }

    /**
     * Redeems a SetToken into a valid reserve asset representing the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address. Only valid if there are available reserve units on the SetToken.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _reserveAsset                 Address of the reserve asset to redeem with
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive
     * @param _to                           Address to redeem reserve asset to
     */
    function redeem(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity,
        uint256 _minReserveReceiveQuantity,
        address _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, _reserveAsset, _setTokenQuantity);

        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);

        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, _reserveAsset, _setTokenQuantity);

        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);

        _setToken.burn(msg.sender, _setTokenQuantity);

        // Instruct the SetToken to transfer the reserve asset back to the user
        _setToken.strictInvokeTransfer(
            _reserveAsset,
            _to,
            redeemInfo.netFlowQuantity
        );

        _handleRedemptionFees(_setToken, _reserveAsset, redeemInfo);

        _handleRedeemStateUpdates(_setToken, _reserveAsset, _to, redeemInfo);
    }

    /**
     * Redeems a SetToken into Ether (if WETH is valid) representing the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address. Only valid if there are available WETH units on the SetToken.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive
     * @param _to                           Address to redeem reserve asset to
     */
    function redeemIntoEther(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        uint256 _minReserveReceiveQuantity,
        address payable _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, address(weth), _setTokenQuantity);

        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);

        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, address(weth), _setTokenQuantity);

        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);

        _setToken.burn(msg.sender, _setTokenQuantity);

        // Instruct the SetToken to transfer WETH from SetToken to module
        _setToken.strictInvokeTransfer(
            address(weth),
            address(this),
            redeemInfo.netFlowQuantity
        );

        weth.withdraw(redeemInfo.netFlowQuantity);

        _to.transfer(redeemInfo.netFlowQuantity);

        _handleRedemptionFees(_setToken, address(weth), redeemInfo);

        _handleRedeemStateUpdates(_setToken, address(weth), _to, redeemInfo);
    }

    /**
     * SET MANAGER ONLY. Add an allowed reserve asset
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset to add
     */
    function addReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {
        require(!isReserveAsset[_setToken][_reserveAsset], "Reserve asset already exists");

        navIssuanceSettings[_setToken].reserveAssets.push(_reserveAsset);
        isReserveAsset[_setToken][_reserveAsset] = true;

        emit ReserveAssetAdded(_setToken, _reserveAsset);
    }

    /**
     * SET MANAGER ONLY. Remove a reserve asset
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset to remove
     */
    function removeReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {
        require(isReserveAsset[_setToken][_reserveAsset], "Reserve asset does not exist");

        navIssuanceSettings[_setToken].reserveAssets = navIssuanceSettings[_setToken].reserveAssets.remove(_reserveAsset);
        delete isReserveAsset[_setToken][_reserveAsset];

        emit ReserveAssetRemoved(_setToken, _reserveAsset);
    }

    /**
     * SET MANAGER ONLY. Edit the premium percentage
     *
     * @param _setToken                     Instance of the SetToken
     * @param _premiumPercentage            Premium percentage in 10e16 (e.g. 10e16 = 1%)
     */
    function editPremium(ISetToken _setToken, uint256 _premiumPercentage) external onlyManagerAndValidSet(_setToken) {
        require(_premiumPercentage <= navIssuanceSettings[_setToken].maxPremiumPercentage, "Premium must be less than maximum allowed");

        navIssuanceSettings[_setToken].premiumPercentage = _premiumPercentage;

        emit PremiumEdited(_setToken, _premiumPercentage);
    }

    /**
     * SET MANAGER ONLY. Edit manager fee
     *
     * @param _setToken                     Instance of the SetToken
     * @param _managerFeePercentage         Manager fee percentage in 10e16 (e.g. 10e16 = 1%)
     * @param _managerFeeIndex              Manager fee index. 0 index is issue fee, 1 index is redeem fee
     */
    function editManagerFee(
        ISetToken _setToken,
        uint256 _managerFeePercentage,
        uint256 _managerFeeIndex
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        require(_managerFeePercentage <= navIssuanceSettings[_setToken].maxManagerFee, "Manager fee must be less than maximum allowed");

        navIssuanceSettings[_setToken].managerFees[_managerFeeIndex] = _managerFeePercentage;

        emit ManagerFeeEdited(_setToken, _managerFeePercentage, _managerFeeIndex);
    }

    /**
     * SET MANAGER ONLY. Edit the manager fee recipient
     *
     * @param _setToken                     Instance of the SetToken
     * @param _managerFeeRecipient          Manager fee recipient
     */
    function editFeeRecipient(ISetToken _setToken, address _managerFeeRecipient) external onlyManagerAndValidSet(_setToken) {
        require(_managerFeeRecipient != address(0), "Fee recipient must not be 0 address");

        navIssuanceSettings[_setToken].feeRecipient = _managerFeeRecipient;

        emit FeeRecipientEdited(_setToken, _managerFeeRecipient);
    }

    /**
     * SET MANAGER ONLY. Initializes this module to the SetToken with hooks, allowed reserve assets,
     * fees and issuance premium. Only callable by the SetToken's manager. Hook addresses are optional.
     * Address(0) means that no hook will be called.
     *
     * @param _setToken                     Instance of the SetToken to issue
     * @param _navIssuanceSettings          NAVIssuanceSettings struct defining parameters
     */
    function initialize(
        ISetToken _setToken,
        NAVIssuanceSettings memory _navIssuanceSettings
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        require(_navIssuanceSettings.reserveAssets.length > 0, "Reserve assets must be greater than 0");
        require(_navIssuanceSettings.maxManagerFee < PreciseUnitMath.preciseUnit(), "Max manager fee must be less than 100%");
        require(_navIssuanceSettings.maxPremiumPercentage < PreciseUnitMath.preciseUnit(), "Max premium percentage must be less than 100%");
        require(_navIssuanceSettings.managerFees[0] <= _navIssuanceSettings.maxManagerFee, "Manager issue fee must be less than max");
        require(_navIssuanceSettings.managerFees[1] <= _navIssuanceSettings.maxManagerFee, "Manager redeem fee must be less than max");
        require(_navIssuanceSettings.premiumPercentage <= _navIssuanceSettings.maxPremiumPercentage, "Premium must be less than max");
        require(_navIssuanceSettings.feeRecipient != address(0), "Fee Recipient must be non-zero address.");
        // Initial mint of Set cannot use NAVIssuance since minSetTokenSupply must be > 0
        require(_navIssuanceSettings.minSetTokenSupply > 0, "Min SetToken supply must be greater than 0");

        for (uint256 i = 0; i < _navIssuanceSettings.reserveAssets.length; i++) {
            require(!isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]], "Reserve assets must be unique");
            isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]] = true;
        }

        navIssuanceSettings[_setToken] = _navIssuanceSettings;

        _setToken.initializeModule();
    }

    /**
     * Removes this module from the SetToken, via call by the SetToken. Issuance settings and
     * reserve asset states are deleted.
     */
    function removeModule() external override {
        ISetToken setToken = ISetToken(msg.sender);
        for (uint256 i = 0; i < navIssuanceSettings[setToken].reserveAssets.length; i++) {
            delete isReserveAsset[setToken][navIssuanceSettings[setToken].reserveAssets[i]];
        }

        delete navIssuanceSettings[setToken];
    }

    receive() external payable {}

    /* ============ External Getter Functions ============ */

    function getReserveAssets(ISetToken _setToken) external view returns (address[] memory) {
        return navIssuanceSettings[_setToken].reserveAssets;
    }

    function getIssuePremium(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (uint256)
    {
        return _getIssuePremium(_setToken, _reserveAsset, _reserveAssetQuantity);
    }

    function getRedeemPremium(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (uint256)
    {
        return _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);
    }

    function getManagerFee(ISetToken _setToken, uint256 _managerFeeIndex) external view returns (uint256) {
        return navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];
    }

    /**
     * Get the expected SetTokens minted to recipient on issuance
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     *
     * @return  uint256                     Expected SetTokens to be minted to recipient
     */
    function getExpectedSetTokenIssueQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (uint256)
    {
        (,, uint256 netReserveFlow) = _getFees(
            _setToken,
            _reserveAssetQuantity,
            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,
            MANAGER_ISSUE_FEE_INDEX
        );

        uint256 setTotalSupply = _setToken.totalSupply();

        return _getSetTokenMintQuantity(
            _setToken,
            _reserveAsset,
            netReserveFlow,
            setTotalSupply
        );
    }

    /**
     * Get the expected reserve asset to be redeemed
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     *
     * @return  uint256                     Expected reserve asset quantity redeemed
     */
    function getExpectedReserveRedeemQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (uint256)
    {
        uint256 preFeeReserveQuantity = _getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

        (,, uint256 netReserveFlows) = _getFees(
            _setToken,
            preFeeReserveQuantity,
            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
            MANAGER_REDEEM_FEE_INDEX
        );

        return netReserveFlows;
    }

    /**
     * Checks if issue is valid
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     *
     * @return  bool                        Returns true if issue is valid
     */
    function isIssueValid(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (bool)
    {
        uint256 setTotalSupply = _setToken.totalSupply();

    return _reserveAssetQuantity != 0
            && isReserveAsset[_setToken][_reserveAsset]
            && setTotalSupply >= navIssuanceSettings[_setToken].minSetTokenSupply;
    }

    /**
     * Checks if redeem is valid
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     *
     * @return  bool                        Returns true if redeem is valid
     */
    function isRedeemValid(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (bool)
    {
        uint256 setTotalSupply = _setToken.totalSupply();

        if (
            _setTokenQuantity == 0
            || !isReserveAsset[_setToken][_reserveAsset]
            || setTotalSupply < navIssuanceSettings[_setToken].minSetTokenSupply.add(_setTokenQuantity)
        ) {
            return false;
        } else {
            uint256 totalRedeemValue =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

            (,, uint256 expectedRedeemQuantity) = _getFees(
                _setToken,
                totalRedeemValue,
                PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
                PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
                MANAGER_REDEEM_FEE_INDEX
            );

            uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();

            return existingUnit.preciseMul(setTotalSupply) >= expectedRedeemQuantity;
        }
    }

    /* ============ Internal Functions ============ */

    function _validateCommon(ISetToken _setToken, address _reserveAsset, uint256 _quantity) internal view {
        require(_quantity > 0, "Quantity must be > 0");
        require(isReserveAsset[_setToken][_reserveAsset], "Must be valid reserve asset");
    }

    function _validateIssuanceInfo(ISetToken _setToken, uint256 _minSetTokenReceiveQuantity, ActionInfo memory _issueInfo) internal view {
        // Check that total supply is greater than min supply needed for issuance
        // Note: A min supply amount is needed to avoid division by 0 when SetToken supply is 0
        require(
            _issueInfo.previousSetTokenSupply >= navIssuanceSettings[_setToken].minSetTokenSupply,
            "Supply must be greater than minimum to enable issuance"
        );

        require(_issueInfo.setTokenQuantity >= _minSetTokenReceiveQuantity, "Must be greater than min SetToken");
    }

    function _validateRedemptionInfo(
        ISetToken _setToken,
        uint256 _minReserveReceiveQuantity,
        ActionInfo memory _redeemInfo
    )
        internal
        view
    {
        // Check that new supply is more than min supply needed for redemption
        // Note: A min supply amount is needed to avoid division by 0 when redeeming SetToken to 0
        require(
            _redeemInfo.newSetTokenSupply >= navIssuanceSettings[_setToken].minSetTokenSupply,
            "Supply must be greater than minimum to enable redemption"
        );

        require(_redeemInfo.netFlowQuantity >= _minReserveReceiveQuantity, "Must be greater than min receive reserve quantity");
    }

    function _createIssuanceInfo(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        internal
        view
        returns (ActionInfo memory)
    {
        ActionInfo memory issueInfo;

        issueInfo.previousSetTokenSupply = _setToken.totalSupply();

        issueInfo.preFeeReserveQuantity = _reserveAssetQuantity;

        (issueInfo.protocolFees, issueInfo.managerFee, issueInfo.netFlowQuantity) = _getFees(
            _setToken,
            issueInfo.preFeeReserveQuantity,
            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,
            MANAGER_ISSUE_FEE_INDEX
        );

        issueInfo.setTokenQuantity = _getSetTokenMintQuantity(
            _setToken,
            _reserveAsset,
            issueInfo.netFlowQuantity,
            issueInfo.previousSetTokenSupply
        );

        (issueInfo.newSetTokenSupply, issueInfo.newPositionMultiplier) = _getIssuePositionMultiplier(_setToken, issueInfo);

        issueInfo.newReservePositionUnit = _getIssuePositionUnit(_setToken, _reserveAsset, issueInfo);

        return issueInfo;
    }

    function _createRedemptionInfo(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        internal
        view
        returns (ActionInfo memory)
    {
        ActionInfo memory redeemInfo;

        redeemInfo.setTokenQuantity = _setTokenQuantity;

        redeemInfo.preFeeReserveQuantity =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

        (redeemInfo.protocolFees, redeemInfo.managerFee, redeemInfo.netFlowQuantity) = _getFees(
            _setToken,
            redeemInfo.preFeeReserveQuantity,
            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
            MANAGER_REDEEM_FEE_INDEX
        );

        redeemInfo.previousSetTokenSupply = _setToken.totalSupply();

        (redeemInfo.newSetTokenSupply, redeemInfo.newPositionMultiplier) = _getRedeemPositionMultiplier(_setToken, _setTokenQuantity, redeemInfo);

        redeemInfo.newReservePositionUnit = _getRedeemPositionUnit(_setToken, _reserveAsset, redeemInfo);

        return redeemInfo;
    }

    /**
     * Transfer reserve asset from user to SetToken and fees from user to appropriate fee recipients
     */
    function _transferCollateralAndHandleFees(ISetToken _setToken, IERC20 _reserveAsset, ActionInfo memory _issueInfo) internal {
        transferFrom(_reserveAsset, msg.sender, address(_setToken), _issueInfo.netFlowQuantity);

        if (_issueInfo.protocolFees > 0) {
            transferFrom(_reserveAsset, msg.sender, controller.feeRecipient(), _issueInfo.protocolFees);
        }

        if (_issueInfo.managerFee > 0) {
            transferFrom(_reserveAsset, msg.sender, navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);
        }
    }


    /**
      * Transfer WETH from module to SetToken and fees from module to appropriate fee recipients
     */
    function _transferWETHAndHandleFees(ISetToken _setToken, ActionInfo memory _issueInfo) internal {
        weth.transfer(address(_setToken), _issueInfo.netFlowQuantity);

        if (_issueInfo.protocolFees > 0) {
            weth.transfer(controller.feeRecipient(), _issueInfo.protocolFees);
        }

        if (_issueInfo.managerFee > 0) {
            weth.transfer(navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);
        }
    }

    function _handleIssueStateUpdates(
        ISetToken _setToken,
        address _reserveAsset,
        address _to,
        ActionInfo memory _issueInfo
    )
        internal
    {
        _setToken.editPositionMultiplier(_issueInfo.newPositionMultiplier);

        _setToken.editDefaultPosition(_reserveAsset, _issueInfo.newReservePositionUnit);

        _setToken.mint(_to, _issueInfo.setTokenQuantity);

        emit SetTokenNAVIssued(
            _setToken,
            msg.sender,
            _to,
            _reserveAsset,
            address(navIssuanceSettings[_setToken].managerIssuanceHook),
            _issueInfo.setTokenQuantity,
            _issueInfo.managerFee,
            _issueInfo.protocolFees
        );
    }

    function _handleRedeemStateUpdates(
        ISetToken _setToken,
        address _reserveAsset,
        address _to,
        ActionInfo memory _redeemInfo
    )
        internal
    {
        _setToken.editPositionMultiplier(_redeemInfo.newPositionMultiplier);

        _setToken.editDefaultPosition(_reserveAsset, _redeemInfo.newReservePositionUnit);

        emit SetTokenNAVRedeemed(
            _setToken,
            msg.sender,
            _to,
            _reserveAsset,
            address(navIssuanceSettings[_setToken].managerRedemptionHook),
            _redeemInfo.setTokenQuantity,
            _redeemInfo.managerFee,
            _redeemInfo.protocolFees
        );
    }

    function _handleRedemptionFees(ISetToken _setToken, address _reserveAsset, ActionInfo memory _redeemInfo) internal {
        // Instruct the SetToken to transfer protocol fee to fee recipient if there is a fee
        payProtocolFeeFromSetToken(_setToken, _reserveAsset, _redeemInfo.protocolFees);

        // Instruct the SetToken to transfer manager fee to manager fee recipient if there is a fee
        if (_redeemInfo.managerFee > 0) {
            _setToken.strictInvokeTransfer(
                _reserveAsset,
                navIssuanceSettings[_setToken].feeRecipient,
                _redeemInfo.managerFee
            );
        }
    }

    /**
     * Returns the issue premium percentage. Virtual function that can be overridden in future versions of the module
     * and can contain arbitrary logic to calculate the issuance premium.
     */
    function _getIssuePremium(
        ISetToken _setToken,
        address /* _reserveAsset */,
        uint256 /* _reserveAssetQuantity */
    )
        virtual
        internal
        view
        returns (uint256)
    {
        return navIssuanceSettings[_setToken].premiumPercentage;
    }

    /**
     * Returns the redeem premium percentage. Virtual function that can be overridden in future versions of the module
     * and can contain arbitrary logic to calculate the redemption premium.
     */
    function _getRedeemPremium(
        ISetToken _setToken,
        address /* _reserveAsset */,
        uint256 /* _setTokenQuantity */
    )
        virtual
        internal
        view
        returns (uint256)
    {
        return navIssuanceSettings[_setToken].premiumPercentage;
    }

    /**
     * Returns the fees attributed to the manager and the protocol. The fees are calculated as follows:
     *
     * ManagerFee = (manager fee % - % to protocol) * reserveAssetQuantity
     * Protocol Fee = (% manager fee share + direct fee %) * reserveAssetQuantity
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAssetQuantity         Quantity of reserve asset to calculate fees from
     * @param _protocolManagerFeeIndex      Index to pull rev share NAV Issuance fee from the Controller
     * @param _protocolDirectFeeIndex       Index to pull direct NAV issuance fee from the Controller
     * @param _managerFeeIndex              Index from NAVIssuanceSettings (0 = issue fee, 1 = redeem fee)
     *
     * @return  uint256                     Fees paid to the protocol in reserve asset
     * @return  uint256                     Fees paid to the manager in reserve asset
     * @return  uint256                     Net reserve to user net of fees
     */
    function _getFees(
        ISetToken _setToken,
        uint256 _reserveAssetQuantity,
        uint256 _protocolManagerFeeIndex,
        uint256 _protocolDirectFeeIndex,
        uint256 _managerFeeIndex
    )
        internal
        view
        returns (uint256, uint256, uint256)
    {
        (uint256 protocolFeePercentage, uint256 managerFeePercentage) = _getProtocolAndManagerFeePercentages(
            _setToken,
            _protocolManagerFeeIndex,
            _protocolDirectFeeIndex,
            _managerFeeIndex
        );

        // Calculate total notional fees
        uint256 protocolFees = protocolFeePercentage.preciseMul(_reserveAssetQuantity);
        uint256 managerFee = managerFeePercentage.preciseMul(_reserveAssetQuantity);

        uint256 netReserveFlow = _reserveAssetQuantity.sub(protocolFees).sub(managerFee);

        return (protocolFees, managerFee, netReserveFlow);
    }

    function _getProtocolAndManagerFeePercentages(
        ISetToken _setToken,
        uint256 _protocolManagerFeeIndex,
        uint256 _protocolDirectFeeIndex,
        uint256 _managerFeeIndex
    )
        internal
        view
        returns(uint256, uint256)
    {
        // Get protocol fee percentages
        uint256 protocolDirectFeePercent = controller.getModuleFee(address(this), _protocolDirectFeeIndex);
        uint256 protocolManagerShareFeePercent = controller.getModuleFee(address(this), _protocolManagerFeeIndex);
        uint256 managerFeePercent = navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];

        // Calculate revenue share split percentage
        uint256 protocolRevenueSharePercentage = protocolManagerShareFeePercent.preciseMul(managerFeePercent);
        uint256 managerRevenueSharePercentage = managerFeePercent.sub(protocolRevenueSharePercentage);
        uint256 totalProtocolFeePercentage = protocolRevenueSharePercentage.add(protocolDirectFeePercent);

        return (totalProtocolFeePercentage, managerRevenueSharePercentage);
    }

    function _getSetTokenMintQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _netReserveFlows,            // Value of reserve asset net of fees
        uint256 _setTotalSupply
    )
        internal
        view
        returns (uint256)
    {
        uint256 premiumPercentage = _getIssuePremium(_setToken, _reserveAsset, _netReserveFlows);
        uint256 premiumValue = _netReserveFlows.preciseMul(premiumPercentage);

        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (1e18)
        // Reverts if price is not found
        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);

        // Get reserve asset decimals
        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();
        uint256 normalizedTotalReserveQuantityNetFees = _netReserveFlows.preciseDiv(10 ** reserveAssetDecimals);
        uint256 normalizedTotalReserveQuantityNetFeesAndPremium = _netReserveFlows.sub(premiumValue).preciseDiv(10 ** reserveAssetDecimals);

        // Calculate SetTokens to mint to issuer
        uint256 denominator = _setTotalSupply.preciseMul(setTokenValuation).add(normalizedTotalReserveQuantityNetFees).sub(normalizedTotalReserveQuantityNetFeesAndPremium);
        return normalizedTotalReserveQuantityNetFeesAndPremium.preciseMul(_setTotalSupply).preciseDiv(denominator);
    }

    function _getRedeemReserveQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        internal
        view
        returns (uint256)
    {
        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (10e18)
        // Reverts if price is not found
        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);

        uint256 totalRedeemValueInPreciseUnits = _setTokenQuantity.preciseMul(setTokenValuation);
        // Get reserve asset decimals
        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();
        uint256 prePremiumReserveQuantity = totalRedeemValueInPreciseUnits.preciseMul(10 ** reserveAssetDecimals);

        uint256 premiumPercentage = _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);
        uint256 premiumQuantity = prePremiumReserveQuantity.preciseMulCeil(premiumPercentage);

        return prePremiumReserveQuantity.sub(premiumQuantity);
    }

    /**
     * The new position multiplier is calculated as follows:
     * inflationPercentage = (newSupply - oldSupply) / newSupply
     * newMultiplier = (1 - inflationPercentage) * positionMultiplier
     */
    function _getIssuePositionMultiplier(
        ISetToken _setToken,
        ActionInfo memory _issueInfo
    )
        internal
        view
        returns (uint256, int256)
    {
        // Calculate inflation and new position multiplier. Note: Round inflation up in order to round position multiplier down
        uint256 newTotalSupply = _issueInfo.setTokenQuantity.add(_issueInfo.previousSetTokenSupply);
        int256 newPositionMultiplier = _setToken.positionMultiplier()
            .mul(_issueInfo.previousSetTokenSupply.toInt256())
            .div(newTotalSupply.toInt256());

        return (newTotalSupply, newPositionMultiplier);
    }

    /**
     * Calculate deflation and new position multiplier. Note: Round deflation down in order to round position multiplier down
     *
     * The new position multiplier is calculated as follows:
     * deflationPercentage = (oldSupply - newSupply) / newSupply
     * newMultiplier = (1 + deflationPercentage) * positionMultiplier
     */
    function _getRedeemPositionMultiplier(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        ActionInfo memory _redeemInfo
    )
        internal
        view
        returns (uint256, int256)
    {
        uint256 newTotalSupply = _redeemInfo.previousSetTokenSupply.sub(_setTokenQuantity);
        int256 newPositionMultiplier = _setToken.positionMultiplier()
            .mul(_redeemInfo.previousSetTokenSupply.toInt256())
            .div(newTotalSupply.toInt256());

        return (newTotalSupply, newPositionMultiplier);
    }

    /**
     * The new position reserve asset unit is calculated as follows:
     * totalReserve = (oldUnit * oldSetTokenSupply) + reserveQuantity
     * newUnit = totalReserve / newSetTokenSupply
     */
    function _getIssuePositionUnit(
        ISetToken _setToken,
        address _reserveAsset,
        ActionInfo memory _issueInfo
    )
        internal
        view
        returns (uint256)
    {
        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();
        uint256 totalReserve = existingUnit
            .preciseMul(_issueInfo.previousSetTokenSupply)
            .add(_issueInfo.netFlowQuantity);

        return totalReserve.preciseDiv(_issueInfo.newSetTokenSupply);
    }

    /**
     * The new position reserve asset unit is calculated as follows:
     * totalReserve = (oldUnit * oldSetTokenSupply) - reserveQuantityToSendOut
     * newUnit = totalReserve / newSetTokenSupply
     */
    function _getRedeemPositionUnit(
        ISetToken _setToken,
        address _reserveAsset,
        ActionInfo memory _redeemInfo
    )
        internal
        view
        returns (uint256)
    {
        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();
        uint256 totalExistingUnits = existingUnit.preciseMul(_redeemInfo.previousSetTokenSupply);

        uint256 outflow = _redeemInfo.netFlowQuantity.add(_redeemInfo.protocolFees).add(_redeemInfo.managerFee);

        // Require withdrawable quantity is greater than existing collateral
        require(totalExistingUnits >= outflow, "Must be greater than total available collateral");

        return totalExistingUnits.sub(outflow).preciseDiv(_redeemInfo.newSetTokenSupply);
    }

    /**
     * If a pre-issue hook has been configured, call the external-protocol contract. Pre-issue hook logic
     * can contain arbitrary logic including validations, external function calls, etc.
     */
    function _callPreIssueHooks(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity,
        address _caller,
        address _to
    )
        internal
    {
        INAVIssuanceHook preIssueHook = navIssuanceSettings[_setToken].managerIssuanceHook;
        if (address(preIssueHook) != address(0)) {
            preIssueHook.invokePreIssueHook(_setToken, _reserveAsset, _reserveAssetQuantity, _caller, _to);
        }
    }

    /**
     * If a pre-redeem hook has been configured, call the external-protocol contract.
     */
    function _callPreRedeemHooks(ISetToken _setToken, uint256 _setQuantity, address _caller, address _to) internal {
        INAVIssuanceHook preRedeemHook = navIssuanceSettings[_setToken].managerRedemptionHook;
        if (address(preRedeemHook) != address(0)) {
            preRedeemHook.invokePreRedeemHook(_setToken, _setQuantity, _caller, _to);
        }
    }
}.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-01-09 05:31:43 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 05:31:43 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 10010
completion_tokens: 907
total_tokens: 10917
cost: $-1.000000


[2024-01-09 05:31:43 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: /*
    Copyright 2020 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";
import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";
import { SignedSafeMath } from "@openzeppelin/contracts/math/SignedSafeMath.sol";

import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";
import { IController } from "../../interfaces/IController.sol";
import { INAVIssuanceHook } from "../../interfaces/INAVIssuanceHook.sol";
import { Invoke } from "../lib/Invoke.sol";
import { ISetToken } from "../../interfaces/ISetToken.sol";
import { IWETH } from "../../interfaces/external/IWETH.sol";
import { ModuleBase } from "../lib/ModuleBase.sol";
import { Position } from "../lib/Position.sol";
import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";
import { ResourceIdentifier } from "../lib/ResourceIdentifier.sol";


/**
 * @title NavIssuanceModule
 * @author Set Protocol
 *
 * Module that enables issuance and redemption with any valid ERC20 token or ETH if allowed by the manager. Sender receives
 * a proportional amount of SetTokens on issuance or ERC20 token on redemption based on the calculated net asset value using
 * oracle prices. Manager is able to enforce a premium / discount on issuance / redemption to avoid arbitrage and front
 * running when relying on oracle prices. Managers can charge a fee (denominated in reserve asset).
 */
contract NavIssuanceModule is ModuleBase, ReentrancyGuard {
    using AddressArrayUtils for address[];
    using Invoke for ISetToken;
    using Position for ISetToken;
    using PreciseUnitMath for uint256;
    using PreciseUnitMath for int256;
    using ResourceIdentifier for IController;
    using SafeMath for uint256;
    using SafeCast for int256;
    using SafeCast for uint256;
    using SignedSafeMath for int256;

    /* ============ Events ============ */

    event SetTokenNAVIssued(
        ISetToken indexed _setToken,
        address _issuer,
        address _to,
        address _reserveAsset,
        address _hookContract,
        uint256 _setTokenQuantity,
        uint256 _managerFee,
        uint256 _premium
    );

    event SetTokenNAVRedeemed(
        ISetToken indexed _setToken,
        address _redeemer,
        address _to,
        address _reserveAsset,
        address _hookContract,
        uint256 _setTokenQuantity,
        uint256 _managerFee,
        uint256 _premium
    );

    event ReserveAssetAdded(
        ISetToken indexed _setToken,
        address _newReserveAsset
    );

    event ReserveAssetRemoved(
        ISetToken indexed _setToken,
        address _removedReserveAsset
    );

    event PremiumEdited(
        ISetToken indexed _setToken,
        uint256 _newPremium
    );

    event ManagerFeeEdited(
        ISetToken indexed _setToken,
        uint256 _newManagerFee,
        uint256 _index
    );

    event FeeRecipientEdited(
        ISetToken indexed _setToken,
        address _feeRecipient
    );

    /* ============ Structs ============ */

    struct NAVIssuanceSettings {
        INAVIssuanceHook managerIssuanceHook;      // Issuance hook configurations
        INAVIssuanceHook managerRedemptionHook;    // Redemption hook configurations
        address[] reserveAssets;                       // Allowed reserve assets - Must have a price enabled with the price oracle
        address feeRecipient;                          // Manager fee recipient
        uint256[2] managerFees;                        // Manager fees. 0 index is issue and 1 index is redeem fee (0.01% = 1e14, 1% = 1e16)
        uint256 maxManagerFee;                         // Maximum fee manager is allowed to set for issue and redeem
        uint256 premiumPercentage;                     // Premium percentage (0.01% = 1e14, 1% = 1e16). This premium is a buffer around oracle
                                                       // prices paid by user to the SetToken, which prevents arbitrage and oracle front running
        uint256 maxPremiumPercentage;                  // Maximum premium percentage manager is allowed to set (configured by manager)
        uint256 minSetTokenSupply;                     // Minimum SetToken supply required for issuance and redemption
                                                       // to prevent dramatic inflationary changes to the SetToken's position multiplier
    }

    struct ActionInfo {
        uint256 preFeeReserveQuantity;                 // Reserve value before fees; During issuance, represents raw quantity
                                                       // During redeem, represents post-premium value
        uint256 protocolFees;                          // Total protocol fees (direct + manager revenue share)
        uint256 managerFee;                            // Total manager fee paid in reserve asset
        uint256 netFlowQuantity;                       // When issuing, quantity of reserve asset sent to SetToken
                                                       // When redeeming, quantity of reserve asset sent to redeemer
        uint256 setTokenQuantity;                      // When issuing, quantity of SetTokens minted to mintee
                                                       // When redeeming, quantity of SetToken redeemed
        uint256 previousSetTokenSupply;                // SetToken supply prior to issue/redeem action
        uint256 newSetTokenSupply;                     // SetToken supply after issue/redeem action
        int256 newPositionMultiplier;                  // SetToken position multiplier after issue/redeem
        uint256 newReservePositionUnit;                // SetToken reserve asset position unit after issue/redeem
    }

    /* ============ State Variables ============ */

    // Wrapped ETH address
    IWETH public immutable weth;

    // Mapping of SetToken to NAV issuance settings struct
    mapping(ISetToken => NAVIssuanceSettings) public navIssuanceSettings;

    // Mapping to efficiently check a SetToken's reserve asset validity
    // SetToken => reserveAsset => isReserveAsset
    mapping(ISetToken => mapping(address => bool)) public isReserveAsset;

    /* ============ Constants ============ */

    // 0 index stores the manager fee in managerFees array, percentage charged on issue (denominated in reserve asset)
    uint256 constant internal MANAGER_ISSUE_FEE_INDEX = 0;

    // 1 index stores the manager fee percentage in managerFees array, charged on redeem
    uint256 constant internal MANAGER_REDEEM_FEE_INDEX = 1;

    // 0 index stores the manager revenue share protocol fee % on the controller, charged in the issuance function
    uint256 constant internal PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX = 0;

    // 1 index stores the manager revenue share protocol fee % on the controller, charged in the redeem function
    uint256 constant internal PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX = 1;

    // 2 index stores the direct protocol fee % on the controller, charged in the issuance function
    uint256 constant internal PROTOCOL_ISSUE_DIRECT_FEE_INDEX = 2;

    // 3 index stores the direct protocol fee % on the controller, charged in the redeem function
    uint256 constant internal PROTOCOL_REDEEM_DIRECT_FEE_INDEX = 3;

    /* ============ Constructor ============ */

    /**
     * @param _controller               Address of controller contract
     * @param _weth                     Address of wrapped eth
     */
    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {
        weth = _weth;
    }

    /* ============ External Functions ============ */

    /**
     * Deposits the allowed reserve asset into the SetToken and mints the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _reserveAsset                 Address of the reserve asset to issue with
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance
     * @param _to                           Address to mint SetToken to
     */
    function issue(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity,
        uint256 _minSetTokenReceiveQuantity,
        address _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, _reserveAsset, _reserveAssetQuantity);

        _callPreIssueHooks(_setToken, _reserveAsset, _reserveAssetQuantity, msg.sender, _to);

        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, _reserveAsset, _reserveAssetQuantity);

        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);

        _transferCollateralAndHandleFees(_setToken, IERC20(_reserveAsset), issueInfo);

        _handleIssueStateUpdates(_setToken, _reserveAsset, _to, issueInfo);
    }

    /**
     * Wraps ETH and deposits WETH if allowed into the SetToken and mints the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance
     * @param _to                           Address to mint SetToken to
     */
    function issueWithEther(
        ISetToken _setToken,
        uint256 _minSetTokenReceiveQuantity,
        address _to
    )
        external
        payable
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        weth.deposit{ value: msg.value }();

        _validateCommon(_setToken, address(weth), msg.value);

        _callPreIssueHooks(_setToken, address(weth), msg.value, msg.sender, _to);

        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, address(weth), msg.value);

        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);

        _transferWETHAndHandleFees(_setToken, issueInfo);

        _handleIssueStateUpdates(_setToken, address(weth), _to, issueInfo);
    }

    /**
     * Redeems a SetToken into a valid reserve asset representing the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address. Only valid if there are available reserve units on the SetToken.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _reserveAsset                 Address of the reserve asset to redeem with
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive
     * @param _to                           Address to redeem reserve asset to
     */
    function redeem(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity,
        uint256 _minReserveReceiveQuantity,
        address _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, _reserveAsset, _setTokenQuantity);

        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);

        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, _reserveAsset, _setTokenQuantity);

        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);

        _setToken.burn(msg.sender, _setTokenQuantity);

        // Instruct the SetToken to transfer the reserve asset back to the user
        _setToken.strictInvokeTransfer(
            _reserveAsset,
            _to,
            redeemInfo.netFlowQuantity
        );

        _handleRedemptionFees(_setToken, _reserveAsset, redeemInfo);

        _handleRedeemStateUpdates(_setToken, _reserveAsset, _to, redeemInfo);
    }

    /**
     * Redeems a SetToken into Ether (if WETH is valid) representing the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address. Only valid if there are available WETH units on the SetToken.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive
     * @param _to                           Address to redeem reserve asset to
     */
    function redeemIntoEther(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        uint256 _minReserveReceiveQuantity,
        address payable _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, address(weth), _setTokenQuantity);

        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);

        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, address(weth), _setTokenQuantity);

        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);

        _setToken.burn(msg.sender, _setTokenQuantity);

        // Instruct the SetToken to transfer WETH from SetToken to module
        _setToken.strictInvokeTransfer(
            address(weth),
            address(this),
            redeemInfo.netFlowQuantity
        );

        weth.withdraw(redeemInfo.netFlowQuantity);

        _to.transfer(redeemInfo.netFlowQuantity);

        _handleRedemptionFees(_setToken, address(weth), redeemInfo);

        _handleRedeemStateUpdates(_setToken, address(weth), _to, redeemInfo);
    }

    /**
     * SET MANAGER ONLY. Add an allowed reserve asset
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset to add
     */
    function addReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {
        require(!isReserveAsset[_setToken][_reserveAsset], "Reserve asset already exists");

        navIssuanceSettings[_setToken].reserveAssets.push(_reserveAsset);
        isReserveAsset[_setToken][_reserveAsset] = true;

        emit ReserveAssetAdded(_setToken, _reserveAsset);
    }

    /**
     * SET MANAGER ONLY. Remove a reserve asset
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset to remove
     */
    function removeReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {
        require(isReserveAsset[_setToken][_reserveAsset], "Reserve asset does not exist");

        navIssuanceSettings[_setToken].reserveAssets = navIssuanceSettings[_setToken].reserveAssets.remove(_reserveAsset);
        delete isReserveAsset[_setToken][_reserveAsset];

        emit ReserveAssetRemoved(_setToken, _reserveAsset);
    }

    /**
     * SET MANAGER ONLY. Edit the premium percentage
     *
     * @param _setToken                     Instance of the SetToken
     * @param _premiumPercentage            Premium percentage in 10e16 (e.g. 10e16 = 1%)
     */
    function editPremium(ISetToken _setToken, uint256 _premiumPercentage) external onlyManagerAndValidSet(_setToken) {
        require(_premiumPercentage <= navIssuanceSettings[_setToken].maxPremiumPercentage, "Premium must be less than maximum allowed");

        navIssuanceSettings[_setToken].premiumPercentage = _premiumPercentage;

        emit PremiumEdited(_setToken, _premiumPercentage);
    }

    /**
     * SET MANAGER ONLY. Edit manager fee
     *
     * @param _setToken                     Instance of the SetToken
     * @param _managerFeePercentage         Manager fee percentage in 10e16 (e.g. 10e16 = 1%)
     * @param _managerFeeIndex              Manager fee index. 0 index is issue fee, 1 index is redeem fee
     */
    function editManagerFee(
        ISetToken _setToken,
        uint256 _managerFeePercentage,
        uint256 _managerFeeIndex
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        require(_managerFeePercentage <= navIssuanceSettings[_setToken].maxManagerFee, "Manager fee must be less than maximum allowed");

        navIssuanceSettings[_setToken].managerFees[_managerFeeIndex] = _managerFeePercentage;

        emit ManagerFeeEdited(_setToken, _managerFeePercentage, _managerFeeIndex);
    }

    /**
     * SET MANAGER ONLY. Edit the manager fee recipient
     *
     * @param _setToken                     Instance of the SetToken
     * @param _managerFeeRecipient          Manager fee recipient
     */
    function editFeeRecipient(ISetToken _setToken, address _managerFeeRecipient) external onlyManagerAndValidSet(_setToken) {
        require(_managerFeeRecipient != address(0), "Fee recipient must not be 0 address");

        navIssuanceSettings[_setToken].feeRecipient = _managerFeeRecipient;

        emit FeeRecipientEdited(_setToken, _managerFeeRecipient);
    }

    /**
     * SET MANAGER ONLY. Initializes this module to the SetToken with hooks, allowed reserve assets,
     * fees and issuance premium. Only callable by the SetToken's manager. Hook addresses are optional.
     * Address(0) means that no hook will be called.
     *
     * @param _setToken                     Instance of the SetToken to issue
     * @param _navIssuanceSettings          NAVIssuanceSettings struct defining parameters
     */
    function initialize(
        ISetToken _setToken,
        NAVIssuanceSettings memory _navIssuanceSettings
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        require(_navIssuanceSettings.reserveAssets.length > 0, "Reserve assets must be greater than 0");
        require(_navIssuanceSettings.maxManagerFee < PreciseUnitMath.preciseUnit(), "Max manager fee must be less than 100%");
        require(_navIssuanceSettings.maxPremiumPercentage < PreciseUnitMath.preciseUnit(), "Max premium percentage must be less than 100%");
        require(_navIssuanceSettings.managerFees[0] <= _navIssuanceSettings.maxManagerFee, "Manager issue fee must be less than max");
        require(_navIssuanceSettings.managerFees[1] <= _navIssuanceSettings.maxManagerFee, "Manager redeem fee must be less than max");
        require(_navIssuanceSettings.premiumPercentage <= _navIssuanceSettings.maxPremiumPercentage, "Premium must be less than max");
        require(_navIssuanceSettings.feeRecipient != address(0), "Fee Recipient must be non-zero address.");
        // Initial mint of Set cannot use NAVIssuance since minSetTokenSupply must be > 0
        require(_navIssuanceSettings.minSetTokenSupply > 0, "Min SetToken supply must be greater than 0");

        for (uint256 i = 0; i < _navIssuanceSettings.reserveAssets.length; i++) {
            require(!isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]], "Reserve assets must be unique");
            isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]] = true;
        }

        navIssuanceSettings[_setToken] = _navIssuanceSettings;

        _setToken.initializeModule();
    }

    /**
     * Removes this module from the SetToken, via call by the SetToken. Issuance settings and
     * reserve asset states are deleted.
     */
    function removeModule() external override {
        ISetToken setToken = ISetToken(msg.sender);
        for (uint256 i = 0; i < navIssuanceSettings[setToken].reserveAssets.length; i++) {
            delete isReserveAsset[setToken][navIssuanceSettings[setToken].reserveAssets[i]];
        }

        delete navIssuanceSettings[setToken];
    }

    receive() external payable {}

    /* ============ External Getter Functions ============ */

    function getReserveAssets(ISetToken _setToken) external view returns (address[] memory) {
        return navIssuanceSettings[_setToken].reserveAssets;
    }

    function getIssuePremium(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (uint256)
    {
        return _getIssuePremium(_setToken, _reserveAsset, _reserveAssetQuantity);
    }

    function getRedeemPremium(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (uint256)
    {
        return _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);
    }

    function getManagerFee(ISetToken _setToken, uint256 _managerFeeIndex) external view returns (uint256) {
        return navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];
    }

    /**
     * Get the expected SetTokens minted to recipient on issuance
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     *
     * @return  uint256                     Expected SetTokens to be minted to recipient
     */
    function getExpectedSetTokenIssueQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (uint256)
    {
        (,, uint256 netReserveFlow) = _getFees(
            _setToken,
            _reserveAssetQuantity,
            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,
            MANAGER_ISSUE_FEE_INDEX
        );

        uint256 setTotalSupply = _setToken.totalSupply();

        return _getSetTokenMintQuantity(
            _setToken,
            _reserveAsset,
            netReserveFlow,
            setTotalSupply
        );
    }

    /**
     * Get the expected reserve asset to be redeemed
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     *
     * @return  uint256                     Expected reserve asset quantity redeemed
     */
    function getExpectedReserveRedeemQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (uint256)
    {
        uint256 preFeeReserveQuantity = _getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

        (,, uint256 netReserveFlows) = _getFees(
            _setToken,
            preFeeReserveQuantity,
            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
            MANAGER_REDEEM_FEE_INDEX
        );

        return netReserveFlows;
    }

    /**
     * Checks if issue is valid
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     *
     * @return  bool                        Returns true if issue is valid
     */
    function isIssueValid(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (bool)
    {
        uint256 setTotalSupply = _setToken.totalSupply();

    return _reserveAssetQuantity != 0
            && isReserveAsset[_setToken][_reserveAsset]
            && setTotalSupply >= navIssuanceSettings[_setToken].minSetTokenSupply;
    }

    /**
     * Checks if redeem is valid
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     *
     * @return  bool                        Returns true if redeem is valid
     */
    function isRedeemValid(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (bool)
    {
        uint256 setTotalSupply = _setToken.totalSupply();

        if (
            _setTokenQuantity == 0
            || !isReserveAsset[_setToken][_reserveAsset]
            || setTotalSupply < navIssuanceSettings[_setToken].minSetTokenSupply.add(_setTokenQuantity)
        ) {
            return false;
        } else {
            uint256 totalRedeemValue =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

            (,, uint256 expectedRedeemQuantity) = _getFees(
                _setToken,
                totalRedeemValue,
                PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
                PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
                MANAGER_REDEEM_FEE_INDEX
            );

            uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();

            return existingUnit.preciseMul(setTotalSupply) >= expectedRedeemQuantity;
        }
    }

    /* ============ Internal Functions ============ */

    function _validateCommon(ISetToken _setToken, address _reserveAsset, uint256 _quantity) internal view {
        require(_quantity > 0, "Quantity must be > 0");
        require(isReserveAsset[_setToken][_reserveAsset], "Must be valid reserve asset");
    }

    function _validateIssuanceInfo(ISetToken _setToken, uint256 _minSetTokenReceiveQuantity, ActionInfo memory _issueInfo) internal view {
        // Check that total supply is greater than min supply needed for issuance
        // Note: A min supply amount is needed to avoid division by 0 when SetToken supply is 0
        require(
            _issueInfo.previousSetTokenSupply >= navIssuanceSettings[_setToken].minSetTokenSupply,
            "Supply must be greater than minimum to enable issuance"
        );

        require(_issueInfo.setTokenQuantity >= _minSetTokenReceiveQuantity, "Must be greater than min SetToken");
    }

    function _validateRedemptionInfo(
        ISetToken _setToken,
        uint256 _minReserveReceiveQuantity,
        ActionInfo memory _redeemInfo
    )
        internal
        view
    {
        // Check that new supply is more than min supply needed for redemption
        // Note: A min supply amount is needed to avoid division by 0 when redeeming SetToken to 0
        require(
            _redeemInfo.newSetTokenSupply >= navIssuanceSettings[_setToken].minSetTokenSupply,
            "Supply must be greater than minimum to enable redemption"
        );

        require(_redeemInfo.netFlowQuantity >= _minReserveReceiveQuantity, "Must be greater than min receive reserve quantity");
    }

    function _createIssuanceInfo(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        internal
        view
        returns (ActionInfo memory)
    {
        ActionInfo memory issueInfo;

        issueInfo.previousSetTokenSupply = _setToken.totalSupply();

        issueInfo.preFeeReserveQuantity = _reserveAssetQuantity;

        (issueInfo.protocolFees, issueInfo.managerFee, issueInfo.netFlowQuantity) = _getFees(
            _setToken,
            issueInfo.preFeeReserveQuantity,
            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,
            MANAGER_ISSUE_FEE_INDEX
        );

        issueInfo.setTokenQuantity = _getSetTokenMintQuantity(
            _setToken,
            _reserveAsset,
            issueInfo.netFlowQuantity,
            issueInfo.previousSetTokenSupply
        );

        (issueInfo.newSetTokenSupply, issueInfo.newPositionMultiplier) = _getIssuePositionMultiplier(_setToken, issueInfo);

        issueInfo.newReservePositionUnit = _getIssuePositionUnit(_setToken, _reserveAsset, issueInfo);

        return issueInfo;
    }

    function _createRedemptionInfo(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        internal
        view
        returns (ActionInfo memory)
    {
        ActionInfo memory redeemInfo;

        redeemInfo.setTokenQuantity = _setTokenQuantity;

        redeemInfo.preFeeReserveQuantity =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

        (redeemInfo.protocolFees, redeemInfo.managerFee, redeemInfo.netFlowQuantity) = _getFees(
            _setToken,
            redeemInfo.preFeeReserveQuantity,
            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
            MANAGER_REDEEM_FEE_INDEX
        );

        redeemInfo.previousSetTokenSupply = _setToken.totalSupply();

        (redeemInfo.newSetTokenSupply, redeemInfo.newPositionMultiplier) = _getRedeemPositionMultiplier(_setToken, _setTokenQuantity, redeemInfo);

        redeemInfo.newReservePositionUnit = _getRedeemPositionUnit(_setToken, _reserveAsset, redeemInfo);

        return redeemInfo;
    }

    /**
     * Transfer reserve asset from user to SetToken and fees from user to appropriate fee recipients
     */
    function _transferCollateralAndHandleFees(ISetToken _setToken, IERC20 _reserveAsset, ActionInfo memory _issueInfo) internal {
        transferFrom(_reserveAsset, msg.sender, address(_setToken), _issueInfo.netFlowQuantity);

        if (_issueInfo.protocolFees > 0) {
            transferFrom(_reserveAsset, msg.sender, controller.feeRecipient(), _issueInfo.protocolFees);
        }

        if (_issueInfo.managerFee > 0) {
            transferFrom(_reserveAsset, msg.sender, navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);
        }
    }


    /**
      * Transfer WETH from module to SetToken and fees from module to appropriate fee recipients
     */
    function _transferWETHAndHandleFees(ISetToken _setToken, ActionInfo memory _issueInfo) internal {
        weth.transfer(address(_setToken), _issueInfo.netFlowQuantity);

        if (_issueInfo.protocolFees > 0) {
            weth.transfer(controller.feeRecipient(), _issueInfo.protocolFees);
        }

        if (_issueInfo.managerFee > 0) {
            weth.transfer(navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);
        }
    }

    function _handleIssueStateUpdates(
        ISetToken _setToken,
        address _reserveAsset,
        address _to,
        ActionInfo memory _issueInfo
    )
        internal
    {
        _setToken.editPositionMultiplier(_issueInfo.newPositionMultiplier);

        _setToken.editDefaultPosition(_reserveAsset, _issueInfo.newReservePositionUnit);

        _setToken.mint(_to, _issueInfo.setTokenQuantity);

        emit SetTokenNAVIssued(
            _setToken,
            msg.sender,
            _to,
            _reserveAsset,
            address(navIssuanceSettings[_setToken].managerIssuanceHook),
            _issueInfo.setTokenQuantity,
            _issueInfo.managerFee,
            _issueInfo.protocolFees
        );
    }

    function _handleRedeemStateUpdates(
        ISetToken _setToken,
        address _reserveAsset,
        address _to,
        ActionInfo memory _redeemInfo
    )
        internal
    {
        _setToken.editPositionMultiplier(_redeemInfo.newPositionMultiplier);

        _setToken.editDefaultPosition(_reserveAsset, _redeemInfo.newReservePositionUnit);

        emit SetTokenNAVRedeemed(
            _setToken,
            msg.sender,
            _to,
            _reserveAsset,
            address(navIssuanceSettings[_setToken].managerRedemptionHook),
            _redeemInfo.setTokenQuantity,
            _redeemInfo.managerFee,
            _redeemInfo.protocolFees
        );
    }

    function _handleRedemptionFees(ISetToken _setToken, address _reserveAsset, ActionInfo memory _redeemInfo) internal {
        // Instruct the SetToken to transfer protocol fee to fee recipient if there is a fee
        payProtocolFeeFromSetToken(_setToken, _reserveAsset, _redeemInfo.protocolFees);

        // Instruct the SetToken to transfer manager fee to manager fee recipient if there is a fee
        if (_redeemInfo.managerFee > 0) {
            _setToken.strictInvokeTransfer(
                _reserveAsset,
                navIssuanceSettings[_setToken].feeRecipient,
                _redeemInfo.managerFee
            );
        }
    }

    /**
     * Returns the issue premium percentage. Virtual function that can be overridden in future versions of the module
     * and can contain arbitrary logic to calculate the issuance premium.
     */
    function _getIssuePremium(
        ISetToken _setToken,
        address /* _reserveAsset */,
        uint256 /* _reserveAssetQuantity */
    )
        virtual
        internal
        view
        returns (uint256)
    {
        return navIssuanceSettings[_setToken].premiumPercentage;
    }

    /**
     * Returns the redeem premium percentage. Virtual function that can be overridden in future versions of the module
     * and can contain arbitrary logic to calculate the redemption premium.
     */
    function _getRedeemPremium(
        ISetToken _setToken,
        address /* _reserveAsset */,
        uint256 /* _setTokenQuantity */
    )
        virtual
        internal
        view
        returns (uint256)
    {
        return navIssuanceSettings[_setToken].premiumPercentage;
    }

    /**
     * Returns the fees attributed to the manager and the protocol. The fees are calculated as follows:
     *
     * ManagerFee = (manager fee % - % to protocol) * reserveAssetQuantity
     * Protocol Fee = (% manager fee share + direct fee %) * reserveAssetQuantity
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAssetQuantity         Quantity of reserve asset to calculate fees from
     * @param _protocolManagerFeeIndex      Index to pull rev share NAV Issuance fee from the Controller
     * @param _protocolDirectFeeIndex       Index to pull direct NAV issuance fee from the Controller
     * @param _managerFeeIndex              Index from NAVIssuanceSettings (0 = issue fee, 1 = redeem fee)
     *
     * @return  uint256                     Fees paid to the protocol in reserve asset
     * @return  uint256                     Fees paid to the manager in reserve asset
     * @return  uint256                     Net reserve to user net of fees
     */
    function _getFees(
        ISetToken _setToken,
        uint256 _reserveAssetQuantity,
        uint256 _protocolManagerFeeIndex,
        uint256 _protocolDirectFeeIndex,
        uint256 _managerFeeIndex
    )
        internal
        view
        returns (uint256, uint256, uint256)
    {
        (uint256 protocolFeePercentage, uint256 managerFeePercentage) = _getProtocolAndManagerFeePercentages(
            _setToken,
            _protocolManagerFeeIndex,
            _protocolDirectFeeIndex,
            _managerFeeIndex
        );

        // Calculate total notional fees
        uint256 protocolFees = protocolFeePercentage.preciseMul(_reserveAssetQuantity);
        uint256 managerFee = managerFeePercentage.preciseMul(_reserveAssetQuantity);

        uint256 netReserveFlow = _reserveAssetQuantity.sub(protocolFees).sub(managerFee);

        return (protocolFees, managerFee, netReserveFlow);
    }

    function _getProtocolAndManagerFeePercentages(
        ISetToken _setToken,
        uint256 _protocolManagerFeeIndex,
        uint256 _protocolDirectFeeIndex,
        uint256 _managerFeeIndex
    )
        internal
        view
        returns(uint256, uint256)
    {
        // Get protocol fee percentages
        uint256 protocolDirectFeePercent = controller.getModuleFee(address(this), _protocolDirectFeeIndex);
        uint256 protocolManagerShareFeePercent = controller.getModuleFee(address(this), _protocolManagerFeeIndex);
        uint256 managerFeePercent = navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];

        // Calculate revenue share split percentage
        uint256 protocolRevenueSharePercentage = protocolManagerShareFeePercent.preciseMul(managerFeePercent);
        uint256 managerRevenueSharePercentage = managerFeePercent.sub(protocolRevenueSharePercentage);
        uint256 totalProtocolFeePercentage = protocolRevenueSharePercentage.add(protocolDirectFeePercent);

        return (totalProtocolFeePercentage, managerRevenueSharePercentage);
    }

    function _getSetTokenMintQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _netReserveFlows,            // Value of reserve asset net of fees
        uint256 _setTotalSupply
    )
        internal
        view
        returns (uint256)
    {
        uint256 premiumPercentage = _getIssuePremium(_setToken, _reserveAsset, _netReserveFlows);
        uint256 premiumValue = _netReserveFlows.preciseMul(premiumPercentage);

        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (1e18)
        // Reverts if price is not found
        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);

        // Get reserve asset decimals
        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();
        uint256 normalizedTotalReserveQuantityNetFees = _netReserveFlows.preciseDiv(10 ** reserveAssetDecimals);
        uint256 normalizedTotalReserveQuantityNetFeesAndPremium = _netReserveFlows.sub(premiumValue).preciseDiv(10 ** reserveAssetDecimals);

        // Calculate SetTokens to mint to issuer
        uint256 denominator = _setTotalSupply.preciseMul(setTokenValuation).add(normalizedTotalReserveQuantityNetFees).sub(normalizedTotalReserveQuantityNetFeesAndPremium);
        return normalizedTotalReserveQuantityNetFeesAndPremium.preciseMul(_setTotalSupply).preciseDiv(denominator);
    }

    function _getRedeemReserveQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        internal
        view
        returns (uint256)
    {
        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (10e18)
        // Reverts if price is not found
        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);

        uint256 totalRedeemValueInPreciseUnits = _setTokenQuantity.preciseMul(setTokenValuation);
        // Get reserve asset decimals
        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();
        uint256 prePremiumReserveQuantity = totalRedeemValueInPreciseUnits.preciseMul(10 ** reserveAssetDecimals);

        uint256 premiumPercentage = _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);
        uint256 premiumQuantity = prePremiumReserveQuantity.preciseMulCeil(premiumPercentage);

        return prePremiumReserveQuantity.sub(premiumQuantity);
    }

    /**
     * The new position multiplier is calculated as follows:
     * inflationPercentage = (newSupply - oldSupply) / newSupply
     * newMultiplier = (1 - inflationPercentage) * positionMultiplier
     */
    function _getIssuePositionMultiplier(
        ISetToken _setToken,
        ActionInfo memory _issueInfo
    )
        internal
        view
        returns (uint256, int256)
    {
        // Calculate inflation and new position multiplier. Note: Round inflation up in order to round position multiplier down
        uint256 newTotalSupply = _issueInfo.setTokenQuantity.add(_issueInfo.previousSetTokenSupply);
        int256 newPositionMultiplier = _setToken.positionMultiplier()
            .mul(_issueInfo.previousSetTokenSupply.toInt256())
            .div(newTotalSupply.toInt256());

        return (newTotalSupply, newPositionMultiplier);
    }

    /**
     * Calculate deflation and new position multiplier. Note: Round deflation down in order to round position multiplier down
     *
     * The new position multiplier is calculated as follows:
     * deflationPercentage = (oldSupply - newSupply) / newSupply
     * newMultiplier = (1 + deflationPercentage) * positionMultiplier
     */
    function _getRedeemPositionMultiplier(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        ActionInfo memory _redeemInfo
    )
        internal
        view
        returns (uint256, int256)
    {
        uint256 newTotalSupply = _redeemInfo.previousSetTokenSupply.sub(_setTokenQuantity);
        int256 newPositionMultiplier = _setToken.positionMultiplier()
            .mul(_redeemInfo.previousSetTokenSupply.toInt256())
            .div(newTotalSupply.toInt256());

        return (newTotalSupply, newPositionMultiplier);
    }

    /**
     * The new position reserve asset unit is calculated as follows:
     * totalReserve = (oldUnit * oldSetTokenSupply) + reserveQuantity
     * newUnit = totalReserve / newSetTokenSupply
     */
    function _getIssuePositionUnit(
        ISetToken _setToken,
        address _reserveAsset,
        ActionInfo memory _issueInfo
    )
        internal
        view
        returns (uint256)
    {
        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();
        uint256 totalReserve = existingUnit
            .preciseMul(_issueInfo.previousSetTokenSupply)
            .add(_issueInfo.netFlowQuantity);

        return totalReserve.preciseDiv(_issueInfo.newSetTokenSupply);
    }

    /**
     * The new position reserve asset unit is calculated as follows:
     * totalReserve = (oldUnit * oldSetTokenSupply) - reserveQuantityToSendOut
     * newUnit = totalReserve / newSetTokenSupply
     */
    function _getRedeemPositionUnit(
        ISetToken _setToken,
        address _reserveAsset,
        ActionInfo memory _redeemInfo
    )
        internal
        view
        returns (uint256)
    {
        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();
        uint256 totalExistingUnits = existingUnit.preciseMul(_redeemInfo.previousSetTokenSupply);

        uint256 outflow = _redeemInfo.netFlowQuantity.add(_redeemInfo.protocolFees).add(_redeemInfo.managerFee);

        // Require withdrawable quantity is greater than existing collateral
        require(totalExistingUnits >= outflow, "Must be greater than total available collateral");

        return totalExistingUnits.sub(outflow).preciseDiv(_redeemInfo.newSetTokenSupply);
    }

    /**
     * If a pre-issue hook has been configured, call the external-protocol contract. Pre-issue hook logic
     * can contain arbitrary logic including validations, external function calls, etc.
     */
    function _callPreIssueHooks(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity,
        address _caller,
        address _to
    )
        internal
    {
        INAVIssuanceHook preIssueHook = navIssuanceSettings[_setToken].managerIssuanceHook;
        if (address(preIssueHook) != address(0)) {
            preIssueHook.invokePreIssueHook(_setToken, _reserveAsset, _reserveAssetQuantity, _caller, _to);
        }
    }

    /**
     * If a pre-redeem hook has been configured, call the external-protocol contract.
     */
    function _callPreRedeemHooks(ISetToken _setToken, uint256 _setQuantity, address _caller, address _to) internal {
        INAVIssuanceHook preRedeemHook = navIssuanceSettings[_setToken].managerRedemptionHook;
        if (address(preRedeemHook) != address(0)) {
            preRedeemHook.invokePreRedeemHook(_setToken, _setQuantity, _caller, _to);
        }
    }
}.]

Based on the provided smart contract code for the `NavIssuanceModule`, here is a succinct summary of the identified security vulnerabilities and issues:

### Summary of Security Vulnerabilities

1. **Reentrancy Risks**: 
   - Although the contract uses `ReentrancyGuard`, there are still potential reentrancy risks in functions that involve external calls, such as `_transferCollateralAndHandleFees`, `_transferWETHAndHandleFees`, and `_setToken.strictInvokeTransfer`. If external contracts are malicious, they could exploit these calls.

2. **Access Control Issues**:
   - The contract relies on modifiers like `onlyManagerAndValidSet` and `onlySetManager`, which may not be sufficiently robust if the manager's address is compromised. There should be a mechanism to change the manager or recover from a compromised state.

3. **Integer Overflow/Underflow**:
   - Although the contract uses `SafeMath`, there are still areas where unchecked arithmetic could lead to vulnerabilities, especially in calculations involving fees and quantities. Ensure all arithmetic operations are protected.

4. **Gas Limit and Loops**:
   - Functions that involve looping through arrays, such as `addReserveAsset` and `removeReserveAsset`, could run into gas limit issues if the number of reserve assets becomes large. This could lead to denial of service.

5. **Lack of Input Validation**:
   - Certain functions do not validate the input parameters thoroughly. For example, in `editManagerFee`, the contract does not check if the `_managerFeeIndex` is valid (0 or 1).

6. **Potential for Front-Running**:
   - The issuance and redemption processes rely on oracle prices, which can be manipulated. If a malicious actor can predict the issuance or redemption, they could front-run transactions to exploit price discrepancies.

7. **Event Emission**:
   - While events are emitted for important actions, there may be a lack of comprehensive logging for all state changes, making it difficult to track the history of actions taken on the contract.

8. **Fallback Function**:
   - The `receive()` function is present but does not have any logic to handle unexpected Ether transfers, which could lead to loss of funds if Ether is sent directly to the contract.

### Comprehensive Analysis Report

The `NavIssuanceModule` contract is a sophisticated implementation that facilitates the issuance and redemption of SetTokens using various reserve assets. While it incorporates several best practices, including the use of OpenZeppelin's libraries for security, there are notable vulnerabilities that need to be addressed to ensure the contract's robustness.

1. **Reentrancy Protection**: The use of `ReentrancyGuard` is a positive aspect, but the potential for reentrancy still exists due to external calls. It is crucial to ensure that all state changes occur before any external calls to mitigate this risk.

2. **Access Control**: The reliance on manager roles for critical functions poses a risk if the manager's private key is compromised. Implementing a multi-signature wallet or a time-lock mechanism for sensitive operations could enhance security.

3. **Arithmetic Safety**: While `SafeMath` is used, it is essential to ensure that all arithmetic operations are consistently protected. A thorough review of all calculations is necessary to prevent overflow or underflow vulnerabilities.

4. **Gas Limit Considerations**: The potential for gas limit issues in functions that loop through arrays should be addressed. Consider implementing a cap on the number of reserve assets or using a more gas-efficient data structure.

5. **Input Validation**: Strengthening input validation across all functions will help prevent invalid states and unexpected behaviors. This includes validating indices and ensuring that parameters fall within acceptable ranges.

6. **Front-Running Mitigation**: To protect against front-running, consider implementing measures such as time-locks or price oracles that are resistant to manipulation.

7. **Event Logging**: Comprehensive event logging for all state changes will improve transparency and facilitate easier audits and tracking of contract activity.

8. **Fallback Function Handling**: The fallback function should include logic to handle unexpected Ether transfers, ensuring that funds are not lost and can be managed appropriately.

In conclusion, while the `NavIssuanceModule` contract demonstrates a solid foundation for managing SetToken issuance and redemption, addressing the identified vulnerabilities is critical for ensuring the security and reliability of the contract in a production environment. A thorough audit and testing phase should be conducted before deployment to mitigate these risks effectively.

[2024-01-09 05:31:43 INFO] **[Seminar Conclusion]**:

 Based on the provided smart contract code for the `NavIssuanceModule`, here is a succinct summary of the identified security vulnerabilities and issues:

### Summary of Security Vulnerabilities

1. **Reentrancy Risks**: 
   - Although the contract uses `ReentrancyGuard`, there are still potential reentrancy risks in functions that involve external calls, such as `_transferCollateralAndHandleFees`, `_transferWETHAndHandleFees`, and `_setToken.strictInvokeTransfer`. If external contracts are malicious, they could exploit these calls.

2. **Access Control Issues**:
   - The contract relies on modifiers like `onlyManagerAndValidSet` and `onlySetManager`, which may not be sufficiently robust if the manager's address is compromised. There should be a mechanism to change the manager or recover from a compromised state.

3. **Integer Overflow/Underflow**:
   - Although the contract uses `SafeMath`, there are still areas where unchecked arithmetic could lead to vulnerabilities, especially in calculations involving fees and quantities. Ensure all arithmetic operations are protected.

4. **Gas Limit and Loops**:
   - Functions that involve looping through arrays, such as `addReserveAsset` and `removeReserveAsset`, could run into gas limit issues if the number of reserve assets becomes large. This could lead to denial of service.

5. **Lack of Input Validation**:
   - Certain functions do not validate the input parameters thoroughly. For example, in `editManagerFee`, the contract does not check if the `_managerFeeIndex` is valid (0 or 1).

6. **Potential for Front-Running**:
   - The issuance and redemption processes rely on oracle prices, which can be manipulated. If a malicious actor can predict the issuance or redemption, they could front-run transactions to exploit price discrepancies.

7. **Event Emission**:
   - While events are emitted for important actions, there may be a lack of comprehensive logging for all state changes, making it difficult to track the history of actions taken on the contract.

8. **Fallback Function**:
   - The `receive()` function is present but does not have any logic to handle unexpected Ether transfers, which could lead to loss of funds if Ether is sent directly to the contract.

### Comprehensive Analysis Report

The `NavIssuanceModule` contract is a sophisticated implementation that facilitates the issuance and redemption of SetTokens using various reserve assets. While it incorporates several best practices, including the use of OpenZeppelin's libraries for security, there are notable vulnerabilities that need to be addressed to ensure the contract's robustness.

1. **Reentrancy Protection**: The use of `ReentrancyGuard` is a positive aspect, but the potential for reentrancy still exists due to external calls. It is crucial to ensure that all state changes occur before any external calls to mitigate this risk.

2. **Access Control**: The reliance on manager roles for critical functions poses a risk if the manager's private key is compromised. Implementing a multi-signature wallet or a time-lock mechanism for sensitive operations could enhance security.

3. **Arithmetic Safety**: While `SafeMath` is used, it is essential to ensure that all arithmetic operations are consistently protected. A thorough review of all calculations is necessary to prevent overflow or underflow vulnerabilities.

4. **Gas Limit Considerations**: The potential for gas limit issues in functions that loop through arrays should be addressed. Consider implementing a cap on the number of reserve assets or using a more gas-efficient data structure.

5. **Input Validation**: Strengthening input validation across all functions will help prevent invalid states and unexpected behaviors. This includes validating indices and ensuring that parameters fall within acceptable ranges.

6. **Front-Running Mitigation**: To protect against front-running, consider implementing measures such as time-locks or price oracles that are resistant to manipulation.

7. **Event Logging**: Comprehensive event logging for all state changes will improve transparency and facilitate easier audits and tracking of contract activity.

8. **Fallback Function Handling**: The fallback function should include logic to handle unexpected Ether transfers, ensuring that funds are not lost and can be managed appropriately.

In conclusion, while the `NavIssuanceModule` contract demonstrates a solid foundation for managing SetToken issuance and redemption, addressing the identified vulnerabilities is critical for ensuring the security and reliability of the contract in a production environment. A thorough audit and testing phase should be conducted before deployment to mitigate these risks effectively.

[2024-01-09 05:31:43 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 3

[2024-01-09 05:31:43 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /*     Copyright 2020 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol"; import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol"; import { SignedSafeMath } from "@openzeppelin/contracts/math/SignedSafeMath.sol"; import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol"; import { IController } from "../../interfaces/IController.sol"; import { INAVIssuanceHook } from "../../interfaces/INAVIssuanceHook.sol"; import { Invoke } from "../lib/Invoke.sol"; import { ISetToken } from "../../interfaces/ISetToken.sol"; import { IWETH } from "../../interfaces/external/IWETH.sol"; import { ModuleBase } from "../lib/ModuleBase.sol"; import { Position } from "../lib/Position.sol"; import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol"; import { ResourceIdentifier } from "../lib/ResourceIdentifier.sol"; /*  * @title NavIssuanceModule  * @author Set Protocol  *  * Module that enables issuance and redemption with any valid ERC20 token or ETH if allowed by the manager. Sender receives  * a proportional amount of SetTokens on issuance or ERC20 token on redemption based on the calculated net asset value using  * oracle prices. Manager is able to enforce a premium / discount on issuance / redemption to avoid arbitrage and front  * running when relying on oracle prices. Managers can charge a fee (denominated in reserve asset).  / contract NavIssuanceModule is ModuleBase, ReentrancyGuard {     using AddressArrayUtils for address[];     using Invoke for ISetToken;     using Position for ISetToken;     using PreciseUnitMath for uint256;     using PreciseUnitMath for int256;     using ResourceIdentifier for IController;     using SafeMath for uint256;     using SafeCast for int256;     using SafeCast for uint256;     using SignedSafeMath for int256; /* ============ Events ============ */  event SetTokenNAVIssued(     ISetToken indexed _setToken,     address _issuer,     address _to,     address _reserveAsset,     address _hookContract,     uint256 _setTokenQuantity,     uint256 _managerFee,     uint256 _premium );  event SetTokenNAVRedeemed(     ISetToken indexed _setToken,     address _redeemer,     address _to,     address _reserveAsset,     address _hookContract,     uint256 _setTokenQuantity,     uint256 _managerFee,     uint256 _premium );  event ReserveAssetAdded(     ISetToken indexed _setToken,     address _newReserveAsset );  event ReserveAssetRemoved(     ISetToken indexed _setToken,     address _removedReserveAsset );  event PremiumEdited(     ISetToken indexed _setToken,     uint256 _newPremium );  event ManagerFeeEdited(     ISetToken indexed _setToken,     uint256 _newManagerFee,     uint256 _index );  event FeeRecipientEdited(     ISetToken indexed _setToken,     address _feeRecipient );  /* ============ Structs ============ */  struct NAVIssuanceSettings {     INAVIssuanceHook managerIssuanceHook;      // Issuance hook configurations     INAVIssuanceHook managerRedemptionHook;    // Redemption hook configurations     address[] reserveAssets;                       // Allowed reserve assets - Must have a price enabled with the price oracle     address feeRecipient;                          // Manager fee recipient     uint256[2] managerFees;                        // Manager fees. 0 index is issue and 1 index is redeem fee (0.01% = 1e14, 1% = 1e16)     uint256 maxManagerFee;                         // Maximum fee manager is allowed to set for issue and redeem     uint256 premiumPercentage;                     // Premium percentage (0.01% = 1e14, 1% = 1e16). This premium is a buffer around oracle                                                    // prices paid by user to the SetToken, which prevents arbitrage and oracle front running     uint256 maxPremiumPercentage;                  // Maximum premium percentage manager is allowed to set (configured by manager)     uint256 minSetTokenSupply;                     // Minimum SetToken supply required for issuance and redemption                                                    // to prevent dramatic inflationary changes to the SetToken's position multiplier }  struct ActionInfo {     uint256 preFeeReserveQuantity;                 // Reserve value before fees; During issuance, represents raw quantity                                                    // During redeem, represents post-premium value     uint256 protocolFees;                          // Total protocol fees (direct + manager revenue share)     uint256 managerFee;                            // Total manager fee paid in reserve asset     uint256 netFlowQuantity;                       // When issuing, quantity of reserve asset sent to SetToken                                                    // When redeeming, quantity of reserve asset sent to redeemer     uint256 setTokenQuantity;                      // When issuing, quantity of SetTokens minted to mintee                                                    // When redeeming, quantity of SetToken redeemed     uint256 previousSetTokenSupply;                // SetToken supply prior to issue/redeem action     uint256 newSetTokenSupply;                     // SetToken supply after issue/redeem action     int256 newPositionMultiplier;                  // SetToken position multiplier after issue/redeem     uint256 newReservePositionUnit;                // SetToken reserve asset position unit after issue/redeem }  /* ============ State Variables ============ */  // Wrapped ETH address IWETH public immutable weth;  // Mapping of SetToken to NAV issuance settings struct mapping(ISetToken =&gt; NAVIssuanceSettings) public navIssuanceSettings;  // Mapping to efficiently check a SetToken's reserve asset validity // SetToken =&gt; reserveAsset =&gt; isReserveAsset mapping(ISetToken =&gt; mapping(address =&gt; bool)) public isReserveAsset;  /* ============ Constants ============ */  // 0 index stores the manager fee in managerFees array, percentage charged on issue (denominated in reserve asset) uint256 constant internal MANAGER_ISSUE_FEE_INDEX = 0;  // 1 index stores the manager fee percentage in managerFees array, charged on redeem uint256 constant internal MANAGER_REDEEM_FEE_INDEX = 1;  // 0 index stores the manager revenue share protocol fee % on the controller, charged in the issuance function uint256 constant internal PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX = 0;  // 1 index stores the manager revenue share protocol fee % on the controller, charged in the redeem function uint256 constant internal PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX = 1;  // 2 index stores the direct protocol fee % on the controller, charged in the issuance function uint256 constant internal PROTOCOL_ISSUE_DIRECT_FEE_INDEX = 2;  // 3 index stores the direct protocol fee % on the controller, charged in the redeem function uint256 constant internal PROTOCOL_REDEEM_DIRECT_FEE_INDEX = 3;  /* ============ Constructor ============ */  /**  * @param _controller               Address of controller contract  * @param _weth                     Address of wrapped eth  */ constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {     weth = _weth; }  /* ============ External Functions ============ */  /**  * Deposits the allowed reserve asset into the SetToken and mints the appropriate % of Net Asset Value of the SetToken  * to the specified _to address.  *  * @param _setToken                     Instance of the SetToken contract  * @param _reserveAsset                 Address of the reserve asset to issue with  * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with  * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance  * @param _to                           Address to mint SetToken to  */ function issue(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity,     uint256 _minSetTokenReceiveQuantity,     address _to )     external     nonReentrant     onlyValidAndInitializedSet(_setToken) {     _validateCommon(_setToken, _reserveAsset, _reserveAssetQuantity);      _callPreIssueHooks(_setToken, _reserveAsset, _reserveAssetQuantity, msg.sender, _to);      ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, _reserveAsset, _reserveAssetQuantity);      _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);      _transferCollateralAndHandleFees(_setToken, IERC20(_reserveAsset), issueInfo);      _handleIssueStateUpdates(_setToken, _reserveAsset, _to, issueInfo); }  /**  * Wraps ETH and deposits WETH if allowed into the SetToken and mints the appropriate % of Net Asset Value of the SetToken  * to the specified _to address.  *  * @param _setToken                     Instance of the SetToken contract  * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance  * @param _to                           Address to mint SetToken to  */ function issueWithEther(     ISetToken _setToken,     uint256 _minSetTokenReceiveQuantity,     address _to )     external     payable     nonReentrant     onlyValidAndInitializedSet(_setToken) {     weth.deposit{ value: msg.value }();      _validateCommon(_setToken, address(weth), msg.value);      _callPreIssueHooks(_setToken, address(weth), msg.value, msg.sender, _to);      ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, address(weth), msg.value);      _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);      _transferWETHAndHandleFees(_setToken, issueInfo);      _handleIssueStateUpdates(_setToken, address(weth), _to, issueInfo); }  /**  * Redeems a SetToken into a valid reserve asset representing the appropriate % of Net Asset Value of the SetToken  * to the specified _to address. Only valid if there are available reserve units on the SetToken.  *  * @param _setToken                     Instance of the SetToken contract  * @param _reserveAsset                 Address of the reserve asset to redeem with  * @param _setTokenQuantity             Quantity of SetTokens to redeem  * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive  * @param _to                           Address to redeem reserve asset to  */ function redeem(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity,     uint256 _minReserveReceiveQuantity,     address _to )     external     nonReentrant     onlyValidAndInitializedSet(_setToken) {     _validateCommon(_setToken, _reserveAsset, _setTokenQuantity);      _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);      ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, _reserveAsset, _setTokenQuantity);      _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);      _setToken.burn(msg.sender, _setTokenQuantity);      // Instruct the SetToken to transfer the reserve asset back to the user     _setToken.strictInvokeTransfer(         _reserveAsset,         _to,         redeemInfo.netFlowQuantity     );      _handleRedemptionFees(_setToken, _reserveAsset, redeemInfo);      _handleRedeemStateUpdates(_setToken, _reserveAsset, _to, redeemInfo); }  /**  * Redeems a SetToken into Ether (if WETH is valid) representing the appropriate % of Net Asset Value of the SetToken  * to the specified _to address. Only valid if there are available WETH units on the SetToken.  *  * @param _setToken                     Instance of the SetToken contract  * @param _setTokenQuantity             Quantity of SetTokens to redeem  * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive  * @param _to                           Address to redeem reserve asset to  */ function redeemIntoEther(     ISetToken _setToken,     uint256 _setTokenQuantity,     uint256 _minReserveReceiveQuantity,     address payable _to )     external     nonReentrant     onlyValidAndInitializedSet(_setToken) {     _validateCommon(_setToken, address(weth), _setTokenQuantity);      _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);      ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, address(weth), _setTokenQuantity);      _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);      _setToken.burn(msg.sender, _setTokenQuantity);      // Instruct the SetToken to transfer WETH from SetToken to module     _setToken.strictInvokeTransfer(         address(weth),         address(this),         redeemInfo.netFlowQuantity     );      weth.withdraw(redeemInfo.netFlowQuantity);      _to.transfer(redeemInfo.netFlowQuantity);      _handleRedemptionFees(_setToken, address(weth), redeemInfo);      _handleRedeemStateUpdates(_setToken, address(weth), _to, redeemInfo); }  /**  * SET MANAGER ONLY. Add an allowed reserve asset  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset to add  */ function addReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {     require(!isReserveAsset[_setToken][_reserveAsset], "Reserve asset already exists");      navIssuanceSettings[_setToken].reserveAssets.push(_reserveAsset);     isReserveAsset[_setToken][_reserveAsset] = true;      emit ReserveAssetAdded(_setToken, _reserveAsset); }  /**  * SET MANAGER ONLY. Remove a reserve asset  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset to remove  */ function removeReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {     require(isReserveAsset[_setToken][_reserveAsset], "Reserve asset does not exist");      navIssuanceSettings[_setToken].reserveAssets = navIssuanceSettings[_setToken].reserveAssets.remove(_reserveAsset);     delete isReserveAsset[_setToken][_reserveAsset];      emit ReserveAssetRemoved(_setToken, _reserveAsset); }  /**  * SET MANAGER ONLY. Edit the premium percentage  *  * @param _setToken                     Instance of the SetToken  * @param _premiumPercentage            Premium percentage in 10e16 (e.g. 10e16 = 1%)  */ function editPremium(ISetToken _setToken, uint256 _premiumPercentage) external onlyManagerAndValidSet(_setToken) {     require(_premiumPercentage &lt;= navIssuanceSettings[_setToken].maxPremiumPercentage, "Premium must be less than maximum allowed");      navIssuanceSettings[_setToken].premiumPercentage = _premiumPercentage;      emit PremiumEdited(_setToken, _premiumPercentage); }  /**  * SET MANAGER ONLY. Edit manager fee  *  * @param _setToken                     Instance of the SetToken  * @param _managerFeePercentage         Manager fee percentage in 10e16 (e.g. 10e16 = 1%)  * @param _managerFeeIndex              Manager fee index. 0 index is issue fee, 1 index is redeem fee  */ function editManagerFee(     ISetToken _setToken,     uint256 _managerFeePercentage,     uint256 _managerFeeIndex )     external     onlyManagerAndValidSet(_setToken) {     require(_managerFeePercentage &lt;= navIssuanceSettings[_setToken].maxManagerFee, "Manager fee must be less than maximum allowed");      navIssuanceSettings[_setToken].managerFees[_managerFeeIndex] = _managerFeePercentage;      emit ManagerFeeEdited(_setToken, _managerFeePercentage, _managerFeeIndex); }  /**  * SET MANAGER ONLY. Edit the manager fee recipient  *  * @param _setToken                     Instance of the SetToken  * @param _managerFeeRecipient          Manager fee recipient  */ function editFeeRecipient(ISetToken _setToken, address _managerFeeRecipient) external onlyManagerAndValidSet(_setToken) {     require(_managerFeeRecipient != address(0), "Fee recipient must not be 0 address");      navIssuanceSettings[_setToken].feeRecipient = _managerFeeRecipient;      emit FeeRecipientEdited(_setToken, _managerFeeRecipient); }  /**  * SET MANAGER ONLY. Initializes this module to the SetToken with hooks, allowed reserve assets,  * fees and issuance premium. Only callable by the SetToken's manager. Hook addresses are optional.  * Address(0) means that no hook will be called.  *  * @param _setToken                     Instance of the SetToken to issue  * @param _navIssuanceSettings          NAVIssuanceSettings struct defining parameters  */ function initialize(     ISetToken _setToken,     NAVIssuanceSettings memory _navIssuanceSettings )     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     require(_navIssuanceSettings.reserveAssets.length &gt; 0, "Reserve assets must be greater than 0");     require(_navIssuanceSettings.maxManagerFee &lt; PreciseUnitMath.preciseUnit(), "Max manager fee must be less than 100%");     require(_navIssuanceSettings.maxPremiumPercentage &lt; PreciseUnitMath.preciseUnit(), "Max premium percentage must be less than 100%");     require(_navIssuanceSettings.managerFees[0] &lt;= _navIssuanceSettings.maxManagerFee, "Manager issue fee must be less than max");     require(_navIssuanceSettings.managerFees[1] &lt;= _navIssuanceSettings.maxManagerFee, "Manager redeem fee must be less than max");     require(_navIssuanceSettings.premiumPercentage &lt;= _navIssuanceSettings.maxPremiumPercentage, "Premium must be less than max");     require(_navIssuanceSettings.feeRecipient != address(0), "Fee Recipient must be non-zero address.");     // Initial mint of Set cannot use NAVIssuance since minSetTokenSupply must be &gt; 0     require(_navIssuanceSettings.minSetTokenSupply &gt; 0, "Min SetToken supply must be greater than 0");      for (uint256 i = 0; i &lt; _navIssuanceSettings.reserveAssets.length; i++) {         require(!isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]], "Reserve assets must be unique");         isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]] = true;     }      navIssuanceSettings[_setToken] = _navIssuanceSettings;      _setToken.initializeModule(); }  /**  * Removes this module from the SetToken, via call by the SetToken. Issuance settings and  * reserve asset states are deleted.  */ function removeModule() external override {     ISetToken setToken = ISetToken(msg.sender);     for (uint256 i = 0; i &lt; navIssuanceSettings[setToken].reserveAssets.length; i++) {         delete isReserveAsset[setToken][navIssuanceSettings[setToken].reserveAssets[i]];     }      delete navIssuanceSettings[setToken]; }  receive() external payable {}  /* ============ External Getter Functions ============ */  function getReserveAssets(ISetToken _setToken) external view returns (address[] memory) {     return navIssuanceSettings[_setToken].reserveAssets; }  function getIssuePremium(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     external     view     returns (uint256) {     return _getIssuePremium(_setToken, _reserveAsset, _reserveAssetQuantity); }  function getRedeemPremium(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     external     view     returns (uint256) {     return _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity); }  function getManagerFee(ISetToken _setToken, uint256 _managerFeeIndex) external view returns (uint256) {     return navIssuanceSettings[_setToken].managerFees[_managerFeeIndex]; }  /**  * Get the expected SetTokens minted to recipient on issuance  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with  *  * @return  uint256                     Expected SetTokens to be minted to recipient  */ function getExpectedSetTokenIssueQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     external     view     returns (uint256) {     (,, uint256 netReserveFlow) = _getFees(         _setToken,         _reserveAssetQuantity,         PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_ISSUE_DIRECT_FEE_INDEX,         MANAGER_ISSUE_FEE_INDEX     );      uint256 setTotalSupply = _setToken.totalSupply();      return _getSetTokenMintQuantity(         _setToken,         _reserveAsset,         netReserveFlow,         setTotalSupply     ); }  /**  * Get the expected reserve asset to be redeemed  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _setTokenQuantity             Quantity of SetTokens to redeem  *  * @return  uint256                     Expected reserve asset quantity redeemed  */ function getExpectedReserveRedeemQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     external     view     returns (uint256) {     uint256 preFeeReserveQuantity = _getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);      (,, uint256 netReserveFlows) = _getFees(         _setToken,         preFeeReserveQuantity,         PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_REDEEM_DIRECT_FEE_INDEX,         MANAGER_REDEEM_FEE_INDEX     );      return netReserveFlows; }  /**  * Checks if issue is valid  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with  *  * @return  bool                        Returns true if issue is valid  */ function isIssueValid(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     external     view     returns (bool) {     uint256 setTotalSupply = _setToken.totalSupply();  return _reserveAssetQuantity != 0         &amp;&amp; isReserveAsset[_setToken][_reserveAsset]         &amp;&amp; setTotalSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply; }  /**  * Checks if redeem is valid  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _setTokenQuantity             Quantity of SetTokens to redeem  *  * @return  bool                        Returns true if redeem is valid  */ function isRedeemValid(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     external     view     returns (bool) {     uint256 setTotalSupply = _setToken.totalSupply();      if (         _setTokenQuantity == 0         || !isReserveAsset[_setToken][_reserveAsset]         || setTotalSupply &lt; navIssuanceSettings[_setToken].minSetTokenSupply.add(_setTokenQuantity)     ) {         return false;     } else {         uint256 totalRedeemValue =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);          (,, uint256 expectedRedeemQuantity) = _getFees(             _setToken,             totalRedeemValue,             PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,             PROTOCOL_REDEEM_DIRECT_FEE_INDEX,             MANAGER_REDEEM_FEE_INDEX         );          uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();          return existingUnit.preciseMul(setTotalSupply) &gt;= expectedRedeemQuantity;     } }  /* ============ Internal Functions ============ */  function _validateCommon(ISetToken _setToken, address _reserveAsset, uint256 _quantity) internal view {     require(_quantity &gt; 0, "Quantity must be &gt; 0");     require(isReserveAsset[_setToken][_reserveAsset], "Must be valid reserve asset"); }  function _validateIssuanceInfo(ISetToken _setToken, uint256 _minSetTokenReceiveQuantity, ActionInfo memory _issueInfo) internal view {     // Check that total supply is greater than min supply needed for issuance     // Note: A min supply amount is needed to avoid division by 0 when SetToken supply is 0     require(         _issueInfo.previousSetTokenSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply,         "Supply must be greater than minimum to enable issuance"     );      require(_issueInfo.setTokenQuantity &gt;= _minSetTokenReceiveQuantity, "Must be greater than min SetToken"); }  function _validateRedemptionInfo(     ISetToken _setToken,     uint256 _minReserveReceiveQuantity,     ActionInfo memory _redeemInfo )     internal     view {     // Check that new supply is more than min supply needed for redemption     // Note: A min supply amount is needed to avoid division by 0 when redeeming SetToken to 0     require(         _redeemInfo.newSetTokenSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply,         "Supply must be greater than minimum to enable redemption"     );      require(_redeemInfo.netFlowQuantity &gt;= _minReserveReceiveQuantity, "Must be greater than min receive reserve quantity"); }  function _createIssuanceInfo(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     internal     view     returns (ActionInfo memory) {     ActionInfo memory issueInfo;      issueInfo.previousSetTokenSupply = _setToken.totalSupply();      issueInfo.preFeeReserveQuantity = _reserveAssetQuantity;      (issueInfo.protocolFees, issueInfo.managerFee, issueInfo.netFlowQuantity) = _getFees(         _setToken,         issueInfo.preFeeReserveQuantity,         PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_ISSUE_DIRECT_FEE_INDEX,         MANAGER_ISSUE_FEE_INDEX     );      issueInfo.setTokenQuantity = _getSetTokenMintQuantity(         _setToken,         _reserveAsset,         issueInfo.netFlowQuantity,         issueInfo.previousSetTokenSupply     );      (issueInfo.newSetTokenSupply, issueInfo.newPositionMultiplier) = _getIssuePositionMultiplier(_setToken, issueInfo);      issueInfo.newReservePositionUnit = _getIssuePositionUnit(_setToken, _reserveAsset, issueInfo);      return issueInfo; }  function _createRedemptionInfo(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     internal     view     returns (ActionInfo memory) {     ActionInfo memory redeemInfo;      redeemInfo.setTokenQuantity = _setTokenQuantity;      redeemInfo.preFeeReserveQuantity =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);      (redeemInfo.protocolFees, redeemInfo.managerFee, redeemInfo.netFlowQuantity) = _getFees(         _setToken,         redeemInfo.preFeeReserveQuantity,         PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_REDEEM_DIRECT_FEE_INDEX,         MANAGER_REDEEM_FEE_INDEX     );      redeemInfo.previousSetTokenSupply = _setToken.totalSupply();      (redeemInfo.newSetTokenSupply, redeemInfo.newPositionMultiplier) = _getRedeemPositionMultiplier(_setToken, _setTokenQuantity, redeemInfo);      redeemInfo.newReservePositionUnit = _getRedeemPositionUnit(_setToken, _reserveAsset, redeemInfo);      return redeemInfo; }  /**  * Transfer reserve asset from user to SetToken and fees from user to appropriate fee recipients  */ function _transferCollateralAndHandleFees(ISetToken _setToken, IERC20 _reserveAsset, ActionInfo memory _issueInfo) internal {     transferFrom(_reserveAsset, msg.sender, address(_setToken), _issueInfo.netFlowQuantity);      if (_issueInfo.protocolFees &gt; 0) {         transferFrom(_reserveAsset, msg.sender, controller.feeRecipient(), _issueInfo.protocolFees);     }      if (_issueInfo.managerFee &gt; 0) {         transferFrom(_reserveAsset, msg.sender, navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);     } }   /**   * Transfer WETH from module to SetToken and fees from module to appropriate fee recipients  */ function _transferWETHAndHandleFees(ISetToken _setToken, ActionInfo memory _issueInfo) internal {     weth.transfer(address(_setToken), _issueInfo.netFlowQuantity);      if (_issueInfo.protocolFees &gt; 0) {         weth.transfer(controller.feeRecipient(), _issueInfo.protocolFees);     }      if (_issueInfo.managerFee &gt; 0) {         weth.transfer(navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);     } }  function _handleIssueStateUpdates(     ISetToken _setToken,     address _reserveAsset,     address _to,     ActionInfo memory _issueInfo )     internal {     _setToken.editPositionMultiplier(_issueInfo.newPositionMultiplier);      _setToken.editDefaultPosition(_reserveAsset, _issueInfo.newReservePositionUnit);      _setToken.mint(_to, _issueInfo.setTokenQuantity);      emit SetTokenNAVIssued(         _setToken,         msg.sender,         _to,         _reserveAsset,         address(navIssuanceSettings[_setToken].managerIssuanceHook),         _issueInfo.setTokenQuantity,         _issueInfo.managerFee,         _issueInfo.protocolFees     ); }  function _handleRedeemStateUpdates(     ISetToken _setToken,     address _reserveAsset,     address _to,     ActionInfo memory _redeemInfo )     internal {     _setToken.editPositionMultiplier(_redeemInfo.newPositionMultiplier);      _setToken.editDefaultPosition(_reserveAsset, _redeemInfo.newReservePositionUnit);      emit SetTokenNAVRedeemed(         _setToken,         msg.sender,         _to,         _reserveAsset,         address(navIssuanceSettings[_setToken].managerRedemptionHook),         _redeemInfo.setTokenQuantity,         _redeemInfo.managerFee,         _redeemInfo.protocolFees     ); }  function _handleRedemptionFees(ISetToken _setToken, address _reserveAsset, ActionInfo memory _redeemInfo) internal {     // Instruct the SetToken to transfer protocol fee to fee recipient if there is a fee     payProtocolFeeFromSetToken(_setToken, _reserveAsset, _redeemInfo.protocolFees);      // Instruct the SetToken to transfer manager fee to manager fee recipient if there is a fee     if (_redeemInfo.managerFee &gt; 0) {         _setToken.strictInvokeTransfer(             _reserveAsset,             navIssuanceSettings[_setToken].feeRecipient,             _redeemInfo.managerFee         );     } }  /**  * Returns the issue premium percentage. Virtual function that can be overridden in future versions of the module  * and can contain arbitrary logic to calculate the issuance premium.  */ function _getIssuePremium(     ISetToken _setToken,     address /* _reserveAsset */,     uint256 /* _reserveAssetQuantity */ )     virtual     internal     view     returns (uint256) {     return navIssuanceSettings[_setToken].premiumPercentage; }  /**  * Returns the redeem premium percentage. Virtual function that can be overridden in future versions of the module  * and can contain arbitrary logic to calculate the redemption premium.  */ function _getRedeemPremium(     ISetToken _setToken,     address /* _reserveAsset */,     uint256 /* _setTokenQuantity */ )     virtual     internal     view     returns (uint256) {     return navIssuanceSettings[_setToken].premiumPercentage; }  /**  * Returns the fees attributed to the manager and the protocol. The fees are calculated as follows:  *  * ManagerFee = (manager fee % - % to protocol) * reserveAssetQuantity  * Protocol Fee = (% manager fee share + direct fee %) * reserveAssetQuantity  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAssetQuantity         Quantity of reserve asset to calculate fees from  * @param _protocolManagerFeeIndex      Index to pull rev share NAV Issuance fee from the Controller  * @param _protocolDirectFeeIndex       Index to pull direct NAV issuance fee from the Controller  * @param _managerFeeIndex              Index from NAVIssuanceSettings (0 = issue fee, 1 = redeem fee)  *  * @return  uint256                     Fees paid to the protocol in reserve asset  * @return  uint256                     Fees paid to the manager in reserve asset  * @return  uint256                     Net reserve to user net of fees  */ function _getFees(     ISetToken _setToken,     uint256 _reserveAssetQuantity,     uint256 _protocolManagerFeeIndex,     uint256 _protocolDirectFeeIndex,     uint256 _managerFeeIndex )     internal     view     returns (uint256, uint256, uint256) {     (uint256 protocolFeePercentage, uint256 managerFeePercentage) = _getProtocolAndManagerFeePercentages(         _setToken,         _protocolManagerFeeIndex,         _protocolDirectFeeIndex,         _managerFeeIndex     );      // Calculate total notional fees     uint256 protocolFees = protocolFeePercentage.preciseMul(_reserveAssetQuantity);     uint256 managerFee = managerFeePercentage.preciseMul(_reserveAssetQuantity);      uint256 netReserveFlow = _reserveAssetQuantity.sub(protocolFees).sub(managerFee);      return (protocolFees, managerFee, netReserveFlow); }  function _getProtocolAndManagerFeePercentages(     ISetToken _setToken,     uint256 _protocolManagerFeeIndex,     uint256 _protocolDirectFeeIndex,     uint256 _managerFeeIndex )     internal     view     returns(uint256, uint256) {     // Get protocol fee percentages     uint256 protocolDirectFeePercent = controller.getModuleFee(address(this), _protocolDirectFeeIndex);     uint256 protocolManagerShareFeePercent = controller.getModuleFee(address(this), _protocolManagerFeeIndex);     uint256 managerFeePercent = navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];      // Calculate revenue share split percentage     uint256 protocolRevenueSharePercentage = protocolManagerShareFeePercent.preciseMul(managerFeePercent);     uint256 managerRevenueSharePercentage = managerFeePercent.sub(protocolRevenueSharePercentage);     uint256 totalProtocolFeePercentage = protocolRevenueSharePercentage.add(protocolDirectFeePercent);      return (totalProtocolFeePercentage, managerRevenueSharePercentage); }  function _getSetTokenMintQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _netReserveFlows,            // Value of reserve asset net of fees     uint256 _setTotalSupply )     internal     view     returns (uint256) {     uint256 premiumPercentage = _getIssuePremium(_setToken, _reserveAsset, _netReserveFlows);     uint256 premiumValue = _netReserveFlows.preciseMul(premiumPercentage);      // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (1e18)     // Reverts if price is not found     uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);      // Get reserve asset decimals     uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();     uint256 normalizedTotalReserveQuantityNetFees = _netReserveFlows.preciseDiv(10 ** reserveAssetDecimals);     uint256 normalizedTotalReserveQuantityNetFeesAndPremium = _netReserveFlows.sub(premiumValue).preciseDiv(10 ** reserveAssetDecimals);      // Calculate SetTokens to mint to issuer     uint256 denominator = _setTotalSupply.preciseMul(setTokenValuation).add(normalizedTotalReserveQuantityNetFees).sub(normalizedTotalReserveQuantityNetFeesAndPremium);     return normalizedTotalReserveQuantityNetFeesAndPremium.preciseMul(_setTotalSupply).preciseDiv(denominator); }  function _getRedeemReserveQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     internal     view     returns (uint256) {     // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (10e18)     // Reverts if price is not found     uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);      uint256 totalRedeemValueInPreciseUnits = _setTokenQuantity.preciseMul(setTokenValuation);     // Get reserve asset decimals     uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();     uint256 prePremiumReserveQuantity = totalRedeemValueInPreciseUnits.preciseMul(10 ** reserveAssetDecimals);      uint256 premiumPercentage = _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);     uint256 premiumQuantity = prePremiumReserveQuantity.preciseMulCeil(premiumPercentage);      return prePremiumReserveQuantity.sub(premiumQuantity); }  /**  * The new position multiplier is calculated as follows:  * inflationPercentage = (newSupply - oldSupply) / newSupply  * newMultiplier = (1 - inflationPercentage) * positionMultiplier  */ function _getIssuePositionMultiplier(     ISetToken _setToken,     ActionInfo memory _issueInfo )     internal     view     returns (uint256, int256) {     // Calculate inflation and new position multiplier. Note: Round inflation up in order to round position multiplier down     uint256 newTotalSupply = _issueInfo.setTokenQuantity.add(_issueInfo.previousSetTokenSupply);     int256 newPositionMultiplier = _setToken.positionMultiplier()         .mul(_issueInfo.previousSetTokenSupply.toInt256())         .div(newTotalSupply.toInt256());      return (newTotalSupply, newPositionMultiplier); }  /**  * Calculate deflation and new position multiplier. Note: Round deflation down in order to round position multiplier down  *  * The new position multiplier is calculated as follows:  * deflationPercentage = (oldSupply - newSupply) / newSupply  * newMultiplier = (1 + deflationPercentage) * positionMultiplier  */ function _getRedeemPositionMultiplier(     ISetToken _setToken,     uint256 _setTokenQuantity,     ActionInfo memory _redeemInfo )     internal     view     returns (uint256, int256) {     uint256 newTotalSupply = _redeemInfo.previousSetTokenSupply.sub(_setTokenQuantity);     int256 newPositionMultiplier = _setToken.positionMultiplier()         .mul(_redeemInfo.previousSetTokenSupply.toInt256())         .div(newTotalSupply.toInt256());      return (newTotalSupply, newPositionMultiplier); }  /**  * The new position reserve asset unit is calculated as follows:  * totalReserve = (oldUnit * oldSetTokenSupply) + reserveQuantity  * newUnit = totalReserve / newSetTokenSupply  */ function _getIssuePositionUnit(     ISetToken _setToken,     address _reserveAsset,     ActionInfo memory _issueInfo )     internal     view     returns (uint256) {     uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();     uint256 totalReserve = existingUnit         .preciseMul(_issueInfo.previousSetTokenSupply)         .add(_issueInfo.netFlowQuantity);      return totalReserve.preciseDiv(_issueInfo.newSetTokenSupply); }  /**  * The new position reserve asset unit is calculated as follows:  * totalReserve = (oldUnit * oldSetTokenSupply) - reserveQuantityToSendOut  * newUnit = totalReserve / newSetTokenSupply  */ function _getRedeemPositionUnit(     ISetToken _setToken,     address _reserveAsset,     ActionInfo memory _redeemInfo )     internal     view     returns (uint256) {     uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();     uint256 totalExistingUnits = existingUnit.preciseMul(_redeemInfo.previousSetTokenSupply);      uint256 outflow = _redeemInfo.netFlowQuantity.add(_redeemInfo.protocolFees).add(_redeemInfo.managerFee);      // Require withdrawable quantity is greater than existing collateral     require(totalExistingUnits &gt;= outflow, "Must be greater than total available collateral");      return totalExistingUnits.sub(outflow).preciseDiv(_redeemInfo.newSetTokenSupply); }  /**  * If a pre-issue hook has been configured, call the external-protocol contract. Pre-issue hook logic  * can contain arbitrary logic including validations, external function calls, etc.  */ function _callPreIssueHooks(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity,     address _caller,     address _to )     internal {     INAVIssuanceHook preIssueHook = navIssuanceSettings[_setToken].managerIssuanceHook;     if (address(preIssueHook) != address(0)) {         preIssueHook.invokePreIssueHook(_setToken, _reserveAsset, _reserveAssetQuantity, _caller, _to);     } }  /**  * If a pre-redeem hook has been configured, call the external-protocol contract.  */ function _callPreRedeemHooks(ISetToken _setToken, uint256 _setQuantity, address _caller, address _to) internal {     INAVIssuanceHook preRedeemHook = navIssuanceSettings[_setToken].managerRedemptionHook;     if (address(preRedeemHook) != address(0)) {         preRedeemHook.invokePreRedeemHook(_setToken, _setQuantity, _caller, _to);     } }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '/\n    Copyright 2020 Set Labs Inc.\n\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n/\n\npragma solidity 0.6.10;\npragma experimental "ABIEncoderV2";\n\nimport { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";\nimport { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";\nimport { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";\nimport { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";\nimport { SignedSafeMath } from "@openzeppelin/contracts/math/SignedSafeMath.sol";\n\nimport { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";\nimport { IController } from "../../interfaces/IController.sol";\nimport { INAVIssuanceHook } from "../../interfaces/INAVIssuanceHook.sol";\nimport { Invoke } from "../lib/Invoke.sol";\nimport { ISetToken } from "../../interfaces/ISetToken.sol";\nimport { IWETH } from "../../interfaces/external/IWETH.sol";\nimport { ModuleBase } from "../lib/ModuleBase.sol";\nimport { Position } from "../lib/Position.sol";\nimport { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";\nimport { ResourceIdentifier } from "../lib/ResourceIdentifier.sol";\n\n\n/\n * @title NavIssuanceModule\n * @author Set Protocol\n \n * Module that enables issuance and redemption with any valid ERC20 token or ETH if allowed by the manager. Sender receives\n * a proportional amount of SetTokens on issuance or ERC20 token on redemption based on the calculated net asset value using\n * oracle prices. Manager is able to enforce a premium / discount on issuance / redemption to avoid arbitrage and front\n * running when relying on oracle prices. Managers can charge a fee (denominated in reserve asset).\n /\ncontract NavIssuanceModule is ModuleBase, ReentrancyGuard {\n    using AddressArrayUtils for address[];\n    using Invoke for ISetToken;\n    using Position for ISetToken;\n    using PreciseUnitMath for uint256;\n    using PreciseUnitMath for int256;\n    using ResourceIdentifier for IController;\n    using SafeMath for uint256;\n    using SafeCast for int256;\n    using SafeCast for uint256;\n    using SignedSafeMath for int256;\n\n    / ============ Events ============ /\n\n    event SetTokenNAVIssued(\n        ISetToken indexed _setToken,\n        address _issuer,\n        address _to,\n        address _reserveAsset,\n        address _hookContract,\n        uint256 _setTokenQuantity,\n        uint256 _managerFee,\n        uint256 _premium\n    );\n\n    event SetTokenNAVRedeemed(\n        ISetToken indexed _setToken,\n        address _redeemer,\n        address _to,\n        address _reserveAsset,\n        address _hookContract,\n        uint256 _setTokenQuantity,\n        uint256 _managerFee,\n        uint256 _premium\n    );\n\n    event ReserveAssetAdded(\n        ISetToken indexed _setToken,\n        address _newReserveAsset\n    );\n\n    event ReserveAssetRemoved(\n        ISetToken indexed _setToken,\n        address _removedReserveAsset\n    );\n\n    event PremiumEdited(\n        ISetToken indexed _setToken,\n        uint256 _newPremium\n    );\n\n    event ManagerFeeEdited(\n        ISetToken indexed _setToken,\n        uint256 _newManagerFee,\n        uint256 _index\n    );\n\n    event FeeRecipientEdited(\n        ISetToken indexed _setToken,\n        address _feeRecipient\n    );\n\n    / ============ Structs ============ /\n\n    struct NAVIssuanceSettings {\n        INAVIssuanceHook managerIssuanceHook;      // Issuance hook configurations\n        INAVIssuanceHook managerRedemptionHook;    // Redemption hook configurations\n        address[] reserveAssets;                       // Allowed reserve assets - Must have a price enabled with the price oracle\n        address feeRecipient;                          // Manager fee recipient\n        uint256[2] managerFees;                        // Manager fees. 0 index is issue and 1 index is redeem fee (0.01% = 1e14, 1% = 1e16)\n        uint256 maxManagerFee;                         // Maximum fee manager is allowed to set for issue and redeem\n        uint256 premiumPercentage;                     // Premium percentage (0.01% = 1e14, 1% = 1e16). This premium is a buffer around oracle\n                                                       // prices paid by user to the SetToken, which prevents arbitrage and oracle front running\n        uint256 maxPremiumPercentage;                  // Maximum premium percentage manager is allowed to set (configured by manager)\n        uint256 minSetTokenSupply;                     // Minimum SetToken supply required for issuance and redemption\n                                                       // to prevent dramatic inflationary changes to the SetToken\'s position multiplier\n    }\n\n    struct ActionInfo {\n        uint256 preFeeReserveQuantity;                 // Reserve value before fees; During issuance, represents raw quantity\n                                                       // During redeem, represents post-premium value\n        uint256 protocolFees;                          // Total protocol fees (direct + manager revenue share)\n        uint256 managerFee;                            // Total manager fee paid in reserve asset\n        uint256 netFlowQuantity;                       // When issuing, quantity of reserve asset sent to SetToken\n                                                       // When redeeming, quantity of reserve asset sent to redeemer\n        uint256 setTokenQuantity;                      // When issuing, quantity of SetTokens minted to mintee\n                                                       // When redeeming, quantity of SetToken redeemed\n        uint256 previousSetTokenSupply;                // SetToken supply prior to issue/redeem action\n        uint256 newSetTokenSupply;                     // SetToken supply after issue/redeem action\n        int256 newPositionMultiplier;                  // SetToken position multiplier after issue/redeem\n        uint256 newReservePositionUnit;                // SetToken reserve asset position unit after issue/redeem\n    }\n\n    / ============ State Variables ============ /\n\n    // Wrapped ETH address\n    IWETH public immutable weth;\n\n    // Mapping of SetToken to NAV issuance settings struct\n    mapping(ISetToken =&gt; NAVIssuanceSettings) public navIssuanceSettings;\n\n    // Mapping to efficiently check a SetToken\'s reserve asset validity\n    // SetToken =&gt; reserveAsset =&gt; isReserveAsset\n    mapping(ISetToken =&gt; mapping(address =&gt; bool)) public isReserveAsset;\n\n    / ============ Constants ============ /\n\n    // 0 index stores the manager fee in managerFees array, percentage charged on issue (denominated in reserve asset)\n    uint256 constant internal MANAGER_ISSUE_FEE_INDEX = 0;\n\n    // 1 index stores the manager fee percentage in managerFees array, charged on redeem\n    uint256 constant internal MANAGER_REDEEM_FEE_INDEX = 1;\n\n    // 0 index stores the manager revenue share protocol fee % on the controller, charged in the issuance function\n    uint256 constant internal PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX = 0;\n\n    // 1 index stores the manager revenue share protocol fee % on the controller, charged in the redeem function\n    uint256 constant internal PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX = 1;\n\n    // 2 index stores the direct protocol fee % on the controller, charged in the issuance function\n    uint256 constant internal PROTOCOL_ISSUE_DIRECT_FEE_INDEX = 2;\n\n    // 3 index stores the direct protocol fee % on the controller, charged in the redeem function\n    uint256 constant internal PROTOCOL_REDEEM_DIRECT_FEE_INDEX = 3;\n\n    / ============ Constructor ============ /\n\n    /\n     * @param _controller               Address of controller contract\n     * @param _weth                     Address of wrapped eth\n     /\n    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {\n        weth = _weth;\n    }\n\n    / ============ External Functions ============ /\n\n    /\n     * Deposits the allowed reserve asset into the SetToken and mints the appropriate % of Net Asset Value of the SetToken\n     * to the specified _to address.\n     \n     * @param _setToken                     Instance of the SetToken contract\n     * @param _reserveAsset                 Address of the reserve asset to issue with\n     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with\n     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance\n     * @param _to                           Address to mint SetToken to\n     /\n    function issue(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _reserveAssetQuantity,\n        uint256 _minSetTokenReceiveQuantity,\n        address _to\n    )\n        external\n        nonReentrant\n        onlyValidAndInitializedSet(_setToken)\n    {\n        _validateCommon(_setToken, _reserveAsset, _reserveAssetQuantity);\n\n        _callPreIssueHooks(_setToken, _reserveAsset, _reserveAssetQuantity, msg.sender, _to);\n\n        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, _reserveAsset, _reserveAssetQuantity);\n\n        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);\n\n        _transferCollateralAndHandleFees(_setToken, IERC20(_reserveAsset), issueInfo);\n\n        _handleIssueStateUpdates(_setToken, _reserveAsset, _to, issueInfo);\n    }\n\n    /\n     * Wraps ETH and deposits WETH if allowed into the SetToken and mints the appropriate % of Net Asset Value of the SetToken\n     * to the specified _to address.\n     \n     * @param _setToken                     Instance of the SetToken contract\n     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance\n     * @param _to                           Address to mint SetToken to\n     /\n    function issueWithEther(\n        ISetToken _setToken,\n        uint256 _minSetTokenReceiveQuantity,\n        address _to\n    )\n        external\n        payable\n        nonReentrant\n        onlyValidAndInitializedSet(_setToken)\n    {\n        weth.deposit{ value: msg.value }();\n\n        _validateCommon(_setToken, address(weth), msg.value);\n\n        _callPreIssueHooks(_setToken, address(weth), msg.value, msg.sender, _to);\n\n        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, address(weth), msg.value);\n\n        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);\n\n        _transferWETHAndHandleFees(_setToken, issueInfo);\n\n        _handleIssueStateUpdates(_setToken, address(weth), _to, issueInfo);\n    }\n\n    /\n     * Redeems a SetToken into a valid reserve asset representing the appropriate % of Net Asset Value of the SetToken\n     * to the specified _to address. Only valid if there are available reserve units on the SetToken.\n     \n     * @param _setToken                     Instance of the SetToken contract\n     * @param _reserveAsset                 Address of the reserve asset to redeem with\n     * @param _setTokenQuantity             Quantity of SetTokens to redeem\n     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive\n     * @param _to                           Address to redeem reserve asset to\n     /\n    function redeem(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _setTokenQuantity,\n        uint256 _minReserveReceiveQuantity,\n        address _to\n    )\n        external\n        nonReentrant\n        onlyValidAndInitializedSet(_setToken)\n    {\n        _validateCommon(_setToken, _reserveAsset, _setTokenQuantity);\n\n        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);\n\n        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, _reserveAsset, _setTokenQuantity);\n\n        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);\n\n        _setToken.burn(msg.sender, _setTokenQuantity);\n\n        // Instruct the SetToken to transfer the reserve asset back to the user\n        _setToken.strictInvokeTransfer(\n            _reserveAsset,\n            _to,\n            redeemInfo.netFlowQuantity\n        );\n\n        _handleRedemptionFees(_setToken, _reserveAsset, redeemInfo);\n\n        _handleRedeemStateUpdates(_setToken, _reserveAsset, _to, redeemInfo);\n    }\n\n    /\n     * Redeems a SetToken into Ether (if WETH is valid) representing the appropriate % of Net Asset Value of the SetToken\n     * to the specified _to address. Only valid if there are available WETH units on the SetToken.\n     \n     * @param _setToken                     Instance of the SetToken contract\n     * @param _setTokenQuantity             Quantity of SetTokens to redeem\n     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive\n     * @param _to                           Address to redeem reserve asset to\n     /\n    function redeemIntoEther(\n        ISetToken _setToken,\n        uint256 _setTokenQuantity,\n        uint256 _minReserveReceiveQuantity,\n        address payable _to\n    )\n        external\n        nonReentrant\n        onlyValidAndInitializedSet(_setToken)\n    {\n        _validateCommon(_setToken, address(weth), _setTokenQuantity);\n\n        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);\n\n        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, address(weth), _setTokenQuantity);\n\n        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);\n\n        _setToken.burn(msg.sender, _setTokenQuantity);\n\n        // Instruct the SetToken to transfer WETH from SetToken to module\n        _setToken.strictInvokeTransfer(\n            address(weth),\n            address(this),\n            redeemInfo.netFlowQuantity\n        );\n\n        weth.withdraw(redeemInfo.netFlowQuantity);\n\n        _to.transfer(redeemInfo.netFlowQuantity);\n\n        _handleRedemptionFees(_setToken, address(weth), redeemInfo);\n\n        _handleRedeemStateUpdates(_setToken, address(weth), _to, redeemInfo);\n    }\n\n    /\n     * SET MANAGER ONLY. Add an allowed reserve asset\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _reserveAsset                 Address of the reserve asset to add\n     /\n    function addReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {\n        require(!isReserveAsset[_setToken][_reserveAsset], "Reserve asset already exists");\n\n        navIssuanceSettings[_setToken].reserveAssets.push(_reserveAsset);\n        isReserveAsset[_setToken][_reserveAsset] = true;\n\n        emit ReserveAssetAdded(_setToken, _reserveAsset);\n    }\n\n    /\n     * SET MANAGER ONLY. Remove a reserve asset\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _reserveAsset                 Address of the reserve asset to remove\n     /\n    function removeReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {\n        require(isReserveAsset[_setToken][_reserveAsset], "Reserve asset does not exist");\n\n        navIssuanceSettings[_setToken].reserveAssets = navIssuanceSettings[_setToken].reserveAssets.remove(_reserveAsset);\n        delete isReserveAsset[_setToken][_reserveAsset];\n\n        emit ReserveAssetRemoved(_setToken, _reserveAsset);\n    }\n\n    /\n     * SET MANAGER ONLY. Edit the premium percentage\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _premiumPercentage            Premium percentage in 10e16 (e.g. 10e16 = 1%)\n     /\n    function editPremium(ISetToken _setToken, uint256 _premiumPercentage) external onlyManagerAndValidSet(_setToken) {\n        require(_premiumPercentage &lt;= navIssuanceSettings[_setToken].maxPremiumPercentage, "Premium must be less than maximum allowed");\n\n        navIssuanceSettings[_setToken].premiumPercentage = _premiumPercentage;\n\n        emit PremiumEdited(_setToken, _premiumPercentage);\n    }\n\n    /\n     * SET MANAGER ONLY. Edit manager fee\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _managerFeePercentage         Manager fee percentage in 10e16 (e.g. 10e16 = 1%)\n     * @param _managerFeeIndex              Manager fee index. 0 index is issue fee, 1 index is redeem fee\n     /\n    function editManagerFee(\n        ISetToken _setToken,\n        uint256 _managerFeePercentage,\n        uint256 _managerFeeIndex\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        require(_managerFeePercentage &lt;= navIssuanceSettings[_setToken].maxManagerFee, "Manager fee must be less than maximum allowed");\n\n        navIssuanceSettings[_setToken].managerFees[_managerFeeIndex] = _managerFeePercentage;\n\n        emit ManagerFeeEdited(_setToken, _managerFeePercentage, _managerFeeIndex);\n    }\n\n    /\n     * SET MANAGER ONLY. Edit the manager fee recipient\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _managerFeeRecipient          Manager fee recipient\n     /\n    function editFeeRecipient(ISetToken _setToken, address _managerFeeRecipient) external onlyManagerAndValidSet(_setToken) {\n        require(_managerFeeRecipient != address(0), "Fee recipient must not be 0 address");\n\n        navIssuanceSettings[_setToken].feeRecipient = _managerFeeRecipient;\n\n        emit FeeRecipientEdited(_setToken, _managerFeeRecipient);\n    }\n\n    /\n     * SET MANAGER ONLY. Initializes this module to the SetToken with hooks, allowed reserve assets,\n     * fees and issuance premium. Only callable by the SetToken\'s manager. Hook addresses are optional.\n     * Address(0) means that no hook will be called.\n     \n     * @param _setToken                     Instance of the SetToken to issue\n     * @param _navIssuanceSettings          NAVIssuanceSettings struct defining parameters\n     /\n    function initialize(\n        ISetToken _setToken,\n        NAVIssuanceSettings memory _navIssuanceSettings\n    )\n        external\n        onlySetManager(_setToken, msg.sender)\n        onlyValidAndPendingSet(_setToken)\n    {\n        require(_navIssuanceSettings.reserveAssets.length &gt; 0, "Reserve assets must be greater than 0");\n        require(_navIssuanceSettings.maxManagerFee &lt; PreciseUnitMath.preciseUnit(), "Max manager fee must be less than 100%");\n        require(_navIssuanceSettings.maxPremiumPercentage &lt; PreciseUnitMath.preciseUnit(), "Max premium percentage must be less than 100%");\n        require(_navIssuanceSettings.managerFees[0] &lt;= _navIssuanceSettings.maxManagerFee, "Manager issue fee must be less than max");\n        require(_navIssuanceSettings.managerFees[1] &lt;= _navIssuanceSettings.maxManagerFee, "Manager redeem fee must be less than max");\n        require(_navIssuanceSettings.premiumPercentage &lt;= _navIssuanceSettings.maxPremiumPercentage, "Premium must be less than max");\n        require(_navIssuanceSettings.feeRecipient != address(0), "Fee Recipient must be non-zero address.");\n        // Initial mint of Set cannot use NAVIssuance since minSetTokenSupply must be &gt; 0\n        require(_navIssuanceSettings.minSetTokenSupply &gt; 0, "Min SetToken supply must be greater than 0");\n\n        for (uint256 i = 0; i &lt; _navIssuanceSettings.reserveAssets.length; i++) {\n            require(!isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]], "Reserve assets must be unique");\n            isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]] = true;\n        }\n\n        navIssuanceSettings[_setToken] = _navIssuanceSettings;\n\n        _setToken.initializeModule();\n    }\n\n    /\n     * Removes this module from the SetToken, via call by the SetToken. Issuance settings and\n     * reserve asset states are deleted.\n     /\n    function removeModule() external override {\n        ISetToken setToken = ISetToken(msg.sender);\n        for (uint256 i = 0; i &lt; navIssuanceSettings[setToken].reserveAssets.length; i++) {\n            delete isReserveAsset[setToken][navIssuanceSettings[setToken].reserveAssets[i]];\n        }\n\n        delete navIssuanceSettings[setToken];\n    }\n\n    receive() external payable {}\n\n    / ============ External Getter Functions ============ /\n\n    function getReserveAssets(ISetToken _setToken) external view returns (address[] memory) {\n        return navIssuanceSettings[_setToken].reserveAssets;\n    }\n\n    function getIssuePremium(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _reserveAssetQuantity\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getIssuePremium(_setToken, _reserveAsset, _reserveAssetQuantity);\n    }\n\n    function getRedeemPremium(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _setTokenQuantity\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);\n    }\n\n    function getManagerFee(ISetToken _setToken, uint256 _managerFeeIndex) external view returns (uint256) {\n        return navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];\n    }\n\n    /\n     * Get the expected SetTokens minted to recipient on issuance\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _reserveAsset                 Address of the reserve asset\n     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with\n     \n     * @return  uint256                     Expected SetTokens to be minted to recipient\n     */\n    function getExpectedSetTokenIssueQuantity(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _reserveAssetQuantity\n    )\n        external\n        view\n        returns (uint256)\n    {\n        (,, uint256 netReserveFlow) = _getFees(\n            _setToken,\n            _reserveAssetQuantity,\n            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,\n            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,\n            MANAGER_ISSUE_FEE_INDEX\n        );\n\n        uint256 setTotalSupply = _setToken.totalSupply();\n\n        return _getSetTokenMintQuantity(\n            _setToken,\n            _reserveAsset,\n            netReserveFlow,\n            setTotalSupply\n        );\n    }\n\n    /\n     * Get the expected reserve asset to be redeemed\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _reserveAsset                 Address of the reserve asset\n     * @param _setTokenQuantity             Quantity of SetTokens to redeem\n     \n     * @return  uint256                     Expected reserve asset quantity redeemed\n     /\n    function getExpectedReserveRedeemQuantity(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _setTokenQuantity\n    )\n        external\n        view\n        returns (uint256)\n    {\n        uint256 preFeeReserveQuantity = _getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);\n\n        (,, uint256 netReserveFlows) = _getFees(\n            _setToken,\n            preFeeReserveQuantity,\n            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,\n            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,\n            MANAGER_REDEEM_FEE_INDEX\n        );\n\n        return netReserveFlows;\n    }\n\n    /\n     * Checks if issue is valid\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _reserveAsset                 Address of the reserve asset\n     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with\n     \n     * @return  bool                        Returns true if issue is valid\n     /\n    function isIssueValid(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _reserveAssetQuantity\n    )\n        external\n        view\n        returns (bool)\n    {\n        uint256 setTotalSupply = _setToken.totalSupply();\n\n    return _reserveAssetQuantity != 0\n            &amp;&amp; isReserveAsset[_setToken][_reserveAsset]\n            &amp;&amp; setTotalSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply;\n    }\n\n    /\n     * Checks if redeem is valid\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _reserveAsset                 Address of the reserve asset\n     * @param _setTokenQuantity             Quantity of SetTokens to redeem\n     \n     * @return  bool                        Returns true if redeem is valid\n     /\n    function isRedeemValid(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _setTokenQuantity\n    )\n        external\n        view\n        returns (bool)\n    {\n        uint256 setTotalSupply = _setToken.totalSupply();\n\n        if (\n            _setTokenQuantity == 0\n            || !isReserveAsset[_setToken][_reserveAsset]\n            || setTotalSupply &lt; navIssuanceSettings[_setToken].minSetTokenSupply.add(_setTokenQuantity)\n        ) {\n            return false;\n        } else {\n            uint256 totalRedeemValue =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);\n\n            (,, uint256 expectedRedeemQuantity) = _getFees(\n                _setToken,\n                totalRedeemValue,\n                PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,\n                PROTOCOL_REDEEM_DIRECT_FEE_INDEX,\n                MANAGER_REDEEM_FEE_INDEX\n            );\n\n            uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();\n\n            return existingUnit.preciseMul(setTotalSupply) &gt;= expectedRedeemQuantity;\n        }\n    }\n\n    / ============ Internal Functions ============ */\n\n    function _validateCommon(ISetToken _setToken, address _reserveAsset, uint256 _quantity) internal view {\n        require(_quantity &gt; 0, "Quantity must be &gt; 0");\n        require(isReserveAsset[_setToken][_reserveAsset], "Must be valid reserve asset");\n    }\n\n    function _validateIssuanceInfo(ISetToken _setToken, uint256 _minSetTokenReceiveQuantity, ActionInfo memory _issueInfo) internal view {\n        // Check that total supply is greater than min supply needed for issuance\n        // Note: A min supply amount is needed to avoid division by 0 when SetToken supply is 0\n        require(\n            _issueInfo.previousSetTokenSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply,\n            "Supply must be greater than minimum to enable issuance"\n        );\n\n        require(_issueInfo.setTokenQuantity &gt;= _minSetTokenReceiveQuantity, "Must be greater than min SetToken");\n    }\n\n    function _validateRedemptionInfo(\n        ISetToken _setToken,\n        uint256 _minReserveReceiveQuantity,\n        ActionInfo memory _redeemInfo\n    )\n        internal\n        view\n    {\n        // Check that new supply is more than min supply needed for redemption\n        // Note: A min supply amount is needed to avoid division by 0 when redeeming SetToken to 0\n        require(\n            _redeemInfo.newSetTokenSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply,\n            "Supply must be greater than minimum to enable redemption"\n        );\n\n        require(_redeemInfo.netFlowQuantity &gt;= _minReserveReceiveQuantity, "Must be greater than min receive reserve quantity");\n    }\n\n    function _createIssuanceInfo(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _reserveAssetQuantity\n    )\n        internal\n        view\n        returns (ActionInfo memory)\n    {\n        ActionInfo memory issueInfo;\n\n        issueInfo.previousSetTokenSupply = _setToken.totalSupply();\n\n        issueInfo.preFeeReserveQuantity = _reserveAssetQuantity;\n\n        (issueInfo.protocolFees, issueInfo.managerFee, issueInfo.netFlowQuantity) = _getFees(\n            _setToken,\n            issueInfo.preFeeReserveQuantity,\n            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,\n            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,\n            MANAGER_ISSUE_FEE_INDEX\n        );\n\n        issueInfo.setTokenQuantity = _getSetTokenMintQuantity(\n            _setToken,\n            _reserveAsset,\n            issueInfo.netFlowQuantity,\n            issueInfo.previousSetTokenSupply\n        );\n\n        (issueInfo.newSetTokenSupply, issueInfo.newPositionMultiplier) = _getIssuePositionMultiplier(_setToken, issueInfo);\n\n        issueInfo.newReservePositionUnit = _getIssuePositionUnit(_setToken, _reserveAsset, issueInfo);\n\n        return issueInfo;\n    }\n\n    function _createRedemptionInfo(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _setTokenQuantity\n    )\n        internal\n        view\n        returns (ActionInfo memory)\n    {\n        ActionInfo memory redeemInfo;\n\n        redeemInfo.setTokenQuantity = _setTokenQuantity;\n\n        redeemInfo.preFeeReserveQuantity =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);\n\n        (redeemInfo.protocolFees, redeemInfo.managerFee, redeemInfo.netFlowQuantity) = _getFees(\n            _setToken,\n            redeemInfo.preFeeReserveQuantity,\n            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,\n            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,\n            MANAGER_REDEEM_FEE_INDEX\n        );\n\n        redeemInfo.previousSetTokenSupply = _setToken.totalSupply();\n\n        (redeemInfo.newSetTokenSupply, redeemInfo.newPositionMultiplier) = _getRedeemPositionMultiplier(_setToken, _setTokenQuantity, redeemInfo);\n\n        redeemInfo.newReservePositionUnit = _getRedeemPositionUnit(_setToken, _reserveAsset, redeemInfo);\n\n        return redeemInfo;\n    }\n\n    /\n     * Transfer reserve asset from user to SetToken and fees from user to appropriate fee recipients\n     /\n    function _transferCollateralAndHandleFees(ISetToken _setToken, IERC20 _reserveAsset, ActionInfo memory _issueInfo) internal {\n        transferFrom(_reserveAsset, msg.sender, address(_setToken), _issueInfo.netFlowQuantity);\n\n        if (_issueInfo.protocolFees &gt; 0) {\n            transferFrom(_reserveAsset, msg.sender, controller.feeRecipient(), _issueInfo.protocolFees);\n        }\n\n        if (_issueInfo.managerFee &gt; 0) {\n            transferFrom(_reserveAsset, msg.sender, navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);\n        }\n    }\n\n\n    /\n      * Transfer WETH from module to SetToken and fees from module to appropriate fee recipients\n     /\n    function _transferWETHAndHandleFees(ISetToken _setToken, ActionInfo memory _issueInfo) internal {\n        weth.transfer(address(_setToken), _issueInfo.netFlowQuantity);\n\n        if (_issueInfo.protocolFees &gt; 0) {\n            weth.transfer(controller.feeRecipient(), _issueInfo.protocolFees);\n        }\n\n        if (_issueInfo.managerFee &gt; 0) {\n            weth.transfer(navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);\n        }\n    }\n\n    function _handleIssueStateUpdates(\n        ISetToken _setToken,\n        address _reserveAsset,\n        address _to,\n        ActionInfo memory _issueInfo\n    )\n        internal\n    {\n        _setToken.editPositionMultiplier(_issueInfo.newPositionMultiplier);\n\n        _setToken.editDefaultPosition(_reserveAsset, _issueInfo.newReservePositionUnit);\n\n        _setToken.mint(_to, _issueInfo.setTokenQuantity);\n\n        emit SetTokenNAVIssued(\n            _setToken,\n            msg.sender,\n            _to,\n            _reserveAsset,\n            address(navIssuanceSettings[_setToken].managerIssuanceHook),\n            _issueInfo.setTokenQuantity,\n            _issueInfo.managerFee,\n            _issueInfo.protocolFees\n        );\n    }\n\n    function _handleRedeemStateUpdates(\n        ISetToken _setToken,\n        address _reserveAsset,\n        address _to,\n        ActionInfo memory _redeemInfo\n    )\n        internal\n    {\n        _setToken.editPositionMultiplier(_redeemInfo.newPositionMultiplier);\n\n        _setToken.editDefaultPosition(_reserveAsset, _redeemInfo.newReservePositionUnit);\n\n        emit SetTokenNAVRedeemed(\n            _setToken,\n            msg.sender,\n            _to,\n            _reserveAsset,\n            address(navIssuanceSettings[_setToken].managerRedemptionHook),\n            _redeemInfo.setTokenQuantity,\n            _redeemInfo.managerFee,\n            _redeemInfo.protocolFees\n        );\n    }\n\n    function _handleRedemptionFees(ISetToken _setToken, address _reserveAsset, ActionInfo memory _redeemInfo) internal {\n        // Instruct the SetToken to transfer protocol fee to fee recipient if there is a fee\n        payProtocolFeeFromSetToken(_setToken, _reserveAsset, _redeemInfo.protocolFees);\n\n        // Instruct the SetToken to transfer manager fee to manager fee recipient if there is a fee\n        if (_redeemInfo.managerFee &gt; 0) {\n            _setToken.strictInvokeTransfer(\n                _reserveAsset,\n                navIssuanceSettings[_setToken].feeRecipient,\n                _redeemInfo.managerFee\n            );\n        }\n    }\n\n    /\n     * Returns the issue premium percentage. Virtual function that can be overridden in future versions of the module\n     * and can contain arbitrary logic to calculate the issuance premium.\n     /\n    function _getIssuePremium(\n        ISetToken _setToken,\n        address / _reserveAsset /,\n        uint256 / _reserveAssetQuantity */\n    )\n        virtual\n        internal\n        view\n        returns (uint256)\n    {\n        return navIssuanceSettings[_setToken].premiumPercentage;\n    }\n\n    /\n     * Returns the redeem premium percentage. Virtual function that can be overridden in future versions of the module\n     * and can contain arbitrary logic to calculate the redemption premium.\n     /\n    function _getRedeemPremium(\n        ISetToken _setToken,\n        address / _reserveAsset /,\n        uint256 / _setTokenQuantity /\n    )\n        virtual\n        internal\n        view\n        returns (uint256)\n    {\n        return navIssuanceSettings[_setToken].premiumPercentage;\n    }\n\n    /\n     * Returns the fees attributed to the manager and the protocol. The fees are calculated as follows:\n     \n     * ManagerFee = (manager fee % - % to protocol) * reserveAssetQuantity\n     * Protocol Fee = (% manager fee share + direct fee %) * reserveAssetQuantity\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _reserveAssetQuantity         Quantity of reserve asset to calculate fees from\n     * @param _protocolManagerFeeIndex      Index to pull rev share NAV Issuance fee from the Controller\n     * @param _protocolDirectFeeIndex       Index to pull direct NAV issuance fee from the Controller\n     * @param _managerFeeIndex              Index from NAVIssuanceSettings (0 = issue fee, 1 = redeem fee)\n     \n     * @return  uint256                     Fees paid to the protocol in reserve asset\n     * @return  uint256                     Fees paid to the manager in reserve asset\n     * @return  uint256                     Net reserve to user net of fees\n     /\n    function _getFees(\n        ISetToken _setToken,\n        uint256 _reserveAssetQuantity,\n        uint256 _protocolManagerFeeIndex,\n        uint256 _protocolDirectFeeIndex,\n        uint256 _managerFeeIndex\n    )\n        internal\n        view\n        returns (uint256, uint256, uint256)\n    {\n        (uint256 protocolFeePercentage, uint256 managerFeePercentage) = _getProtocolAndManagerFeePercentages(\n            _setToken,\n            _protocolManagerFeeIndex,\n            _protocolDirectFeeIndex,\n            _managerFeeIndex\n        );\n\n        // Calculate total notional fees\n        uint256 protocolFees = protocolFeePercentage.preciseMul(_reserveAssetQuantity);\n        uint256 managerFee = managerFeePercentage.preciseMul(_reserveAssetQuantity);\n\n        uint256 netReserveFlow = _reserveAssetQuantity.sub(protocolFees).sub(managerFee);\n\n        return (protocolFees, managerFee, netReserveFlow);\n    }\n\n    function _getProtocolAndManagerFeePercentages(\n        ISetToken _setToken,\n        uint256 _protocolManagerFeeIndex,\n        uint256 _protocolDirectFeeIndex,\n        uint256 _managerFeeIndex\n    )\n        internal\n        view\n        returns(uint256, uint256)\n    {\n        // Get protocol fee percentages\n        uint256 protocolDirectFeePercent = controller.getModuleFee(address(this), _protocolDirectFeeIndex);\n        uint256 protocolManagerShareFeePercent = controller.getModuleFee(address(this), _protocolManagerFeeIndex);\n        uint256 managerFeePercent = navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];\n\n        // Calculate revenue share split percentage\n        uint256 protocolRevenueSharePercentage = protocolManagerShareFeePercent.preciseMul(managerFeePercent);\n        uint256 managerRevenueSharePercentage = managerFeePercent.sub(protocolRevenueSharePercentage);\n        uint256 totalProtocolFeePercentage = protocolRevenueSharePercentage.add(protocolDirectFeePercent);\n\n        return (totalProtocolFeePercentage, managerRevenueSharePercentage);\n    }\n\n    function _getSetTokenMintQuantity(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _netReserveFlows,            // Value of reserve asset net of fees\n        uint256 _setTotalSupply\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 premiumPercentage = _getIssuePremium(_setToken, _reserveAsset, _netReserveFlows);\n        uint256 premiumValue = _netReserveFlows.preciseMul(premiumPercentage);\n\n        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (1e18)\n        // Reverts if price is not found\n        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);\n\n        // Get reserve asset decimals\n        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();\n        uint256 normalizedTotalReserveQuantityNetFees = _netReserveFlows.preciseDiv(10 ** reserveAssetDecimals);\n        uint256 normalizedTotalReserveQuantityNetFeesAndPremium = _netReserveFlows.sub(premiumValue).preciseDiv(10 ** reserveAssetDecimals);\n\n        // Calculate SetTokens to mint to issuer\n        uint256 denominator = _setTotalSupply.preciseMul(setTokenValuation).add(normalizedTotalReserveQuantityNetFees).sub(normalizedTotalReserveQuantityNetFeesAndPremium);\n        return normalizedTotalReserveQuantityNetFeesAndPremium.preciseMul(_setTotalSupply).preciseDiv(denominator);\n    }\n\n    function _getRedeemReserveQuantity(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _setTokenQuantity\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (10e18)\n        // Reverts if price is not found\n        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);\n\n        uint256 totalRedeemValueInPreciseUnits = _setTokenQuantity.preciseMul(setTokenValuation);\n        // Get reserve asset decimals\n        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();\n        uint256 prePremiumReserveQuantity = totalRedeemValueInPreciseUnits.preciseMul(10 ** reserveAssetDecimals);\n\n        uint256 premiumPercentage = _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);\n        uint256 premiumQuantity = prePremiumReserveQuantity.preciseMulCeil(premiumPercentage);\n\n        return prePremiumReserveQuantity.sub(premiumQuantity);\n    }\n\n    /\n     * The new position multiplier is calculated as follows:\n     * inflationPercentage = (newSupply - oldSupply) / newSupply\n     * newMultiplier = (1 - inflationPercentage) * positionMultiplier\n     /\n    function _getIssuePositionMultiplier(\n        ISetToken _setToken,\n        ActionInfo memory _issueInfo\n    )\n        internal\n        view\n        returns (uint256, int256)\n    {\n        // Calculate inflation and new position multiplier. Note: Round inflation up in order to round position multiplier down\n        uint256 newTotalSupply = _issueInfo.setTokenQuantity.add(_issueInfo.previousSetTokenSupply);\n        int256 newPositionMultiplier = _setToken.positionMultiplier()\n            .mul(_issueInfo.previousSetTokenSupply.toInt256())\n            .div(newTotalSupply.toInt256());\n\n        return (newTotalSupply, newPositionMultiplier);\n    }\n\n    /\n     * Calculate deflation and new position multiplier. Note: Round deflation down in order to round position multiplier down\n     \n     * The new position multiplier is calculated as follows:\n     * deflationPercentage = (oldSupply - newSupply) / newSupply\n     * newMultiplier = (1 + deflationPercentage) * positionMultiplier\n     /\n    function _getRedeemPositionMultiplier(\n        ISetToken _setToken,\n        uint256 _setTokenQuantity,\n        ActionInfo memory _redeemInfo\n    )\n        internal\n        view\n        returns (uint256, int256)\n    {\n        uint256 newTotalSupply = _redeemInfo.previousSetTokenSupply.sub(_setTokenQuantity);\n        int256 newPositionMultiplier = _setToken.positionMultiplier()\n            .mul(_redeemInfo.previousSetTokenSupply.toInt256())\n            .div(newTotalSupply.toInt256());\n\n        return (newTotalSupply, newPositionMultiplier);\n    }\n\n    /\n     * The new position reserve asset unit is calculated as follows:\n     * totalReserve = (oldUnit * oldSetTokenSupply) + reserveQuantity\n     * newUnit = totalReserve / newSetTokenSupply\n     /\n    function _getIssuePositionUnit(\n        ISetToken _setToken,\n        address _reserveAsset,\n        ActionInfo memory _issueInfo\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();\n        uint256 totalReserve = existingUnit\n            .preciseMul(_issueInfo.previousSetTokenSupply)\n            .add(_issueInfo.netFlowQuantity);\n\n        return totalReserve.preciseDiv(_issueInfo.newSetTokenSupply);\n    }\n\n    /\n     * The new position reserve asset unit is calculated as follows:\n     * totalReserve = (oldUnit * oldSetTokenSupply) - reserveQuantityToSendOut\n     * newUnit = totalReserve / newSetTokenSupply\n     /\n    function _getRedeemPositionUnit(\n        ISetToken _setToken,\n        address _reserveAsset,\n        ActionInfo memory _redeemInfo\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();\n        uint256 totalExistingUnits = existingUnit.preciseMul(_redeemInfo.previousSetTokenSupply);\n\n        uint256 outflow = _redeemInfo.netFlowQuantity.add(_redeemInfo.protocolFees).add(_redeemInfo.managerFee);\n\n        // Require withdrawable quantity is greater than existing collateral\n        require(totalExistingUnits &gt;= outflow, "Must be greater than total available collateral");\n\n        return totalExistingUnits.sub(outflow).preciseDiv(_redeemInfo.newSetTokenSupply);\n    }\n\n    /\n     * If a pre-issue hook has been configured, call the external-protocol contract. Pre-issue hook logic\n     * can contain arbitrary logic including validations, external function calls, etc.\n     */\n    function _callPreIssueHooks(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _reserveAssetQuantity,\n        address _caller,\n        address _to\n    )\n        internal\n    {\n        INAVIssuanceHook preIssueHook = navIssuanceSettings[_setToken].managerIssuanceHook;\n        if (address(preIssueHook) != address(0)) {\n            preIssueHook.invokePreIssueHook(_setToken, _reserveAsset, _reserveAssetQuantity, _caller, _to);\n        }\n    }\n\n    /\n     * If a pre-redeem hook has been configured, call the external-protocol contract.\n     */\n    function _callPreRedeemHooks(ISetToken _setToken, uint256 _setQuantity, address _caller, address _to) internal {\n        INAVIssuanceHook preRedeemHook = navIssuanceSettings[_setToken].managerRedemptionHook;\n        if (address(preRedeemHook) != address(0)) {\n            preRedeemHook.invokePreRedeemHook(_setToken, _setQuantity, _caller, _to);\n        }\n    }\n}', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 05:31:43 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | /*     Copyright 2020 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol"; import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol"; import { SignedSafeMath } from "@openzeppelin/contracts/math/SignedSafeMath.sol"; import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol"; import { IController } from "../../interfaces/IController.sol"; import { INAVIssuanceHook } from "../../interfaces/INAVIssuanceHook.sol"; import { Invoke } from "../lib/Invoke.sol"; import { ISetToken } from "../../interfaces/ISetToken.sol"; import { IWETH } from "../../interfaces/external/IWETH.sol"; import { ModuleBase } from "../lib/ModuleBase.sol"; import { Position } from "../lib/Position.sol"; import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol"; import { ResourceIdentifier } from "../lib/ResourceIdentifier.sol"; /*  * @title NavIssuanceModule  * @author Set Protocol  *  * Module that enables issuance and redemption with any valid ERC20 token or ETH if allowed by the manager. Sender receives  * a proportional amount of SetTokens on issuance or ERC20 token on redemption based on the calculated net asset value using  * oracle prices. Manager is able to enforce a premium / discount on issuance / redemption to avoid arbitrage and front  * running when relying on oracle prices. Managers can charge a fee (denominated in reserve asset).  / contract NavIssuanceModule is ModuleBase, ReentrancyGuard {     using AddressArrayUtils for address[];     using Invoke for ISetToken;     using Position for ISetToken;     using PreciseUnitMath for uint256;     using PreciseUnitMath for int256;     using ResourceIdentifier for IController;     using SafeMath for uint256;     using SafeCast for int256;     using SafeCast for uint256;     using SignedSafeMath for int256; /* ============ Events ============ */  event SetTokenNAVIssued(     ISetToken indexed _setToken,     address _issuer,     address _to,     address _reserveAsset,     address _hookContract,     uint256 _setTokenQuantity,     uint256 _managerFee,     uint256 _premium );  event SetTokenNAVRedeemed(     ISetToken indexed _setToken,     address _redeemer,     address _to,     address _reserveAsset,     address _hookContract,     uint256 _setTokenQuantity,     uint256 _managerFee,     uint256 _premium );  event ReserveAssetAdded(     ISetToken indexed _setToken,     address _newReserveAsset );  event ReserveAssetRemoved(     ISetToken indexed _setToken,     address _removedReserveAsset );  event PremiumEdited(     ISetToken indexed _setToken,     uint256 _newPremium );  event ManagerFeeEdited(     ISetToken indexed _setToken,     uint256 _newManagerFee,     uint256 _index );  event FeeRecipientEdited(     ISetToken indexed _setToken,     address _feeRecipient );  /* ============ Structs ============ */  struct NAVIssuanceSettings {     INAVIssuanceHook managerIssuanceHook;      // Issuance hook configurations     INAVIssuanceHook managerRedemptionHook;    // Redemption hook configurations     address[] reserveAssets;                       // Allowed reserve assets - Must have a price enabled with the price oracle     address feeRecipient;                          // Manager fee recipient     uint256[2] managerFees;                        // Manager fees. 0 index is issue and 1 index is redeem fee (0.01% = 1e14, 1% = 1e16)     uint256 maxManagerFee;                         // Maximum fee manager is allowed to set for issue and redeem     uint256 premiumPercentage;                     // Premium percentage (0.01% = 1e14, 1% = 1e16). This premium is a buffer around oracle                                                    // prices paid by user to the SetToken, which prevents arbitrage and oracle front running     uint256 maxPremiumPercentage;                  // Maximum premium percentage manager is allowed to set (configured by manager)     uint256 minSetTokenSupply;                     // Minimum SetToken supply required for issuance and redemption                                                    // to prevent dramatic inflationary changes to the SetToken's position multiplier }  struct ActionInfo {     uint256 preFeeReserveQuantity;                 // Reserve value before fees; During issuance, represents raw quantity                                                    // During redeem, represents post-premium value     uint256 protocolFees;                          // Total protocol fees (direct + manager revenue share)     uint256 managerFee;                            // Total manager fee paid in reserve asset     uint256 netFlowQuantity;                       // When issuing, quantity of reserve asset sent to SetToken                                                    // When redeeming, quantity of reserve asset sent to redeemer     uint256 setTokenQuantity;                      // When issuing, quantity of SetTokens minted to mintee                                                    // When redeeming, quantity of SetToken redeemed     uint256 previousSetTokenSupply;                // SetToken supply prior to issue/redeem action     uint256 newSetTokenSupply;                     // SetToken supply after issue/redeem action     int256 newPositionMultiplier;                  // SetToken position multiplier after issue/redeem     uint256 newReservePositionUnit;                // SetToken reserve asset position unit after issue/redeem }  /* ============ State Variables ============ */  // Wrapped ETH address IWETH public immutable weth;  // Mapping of SetToken to NAV issuance settings struct mapping(ISetToken =&gt; NAVIssuanceSettings) public navIssuanceSettings;  // Mapping to efficiently check a SetToken's reserve asset validity // SetToken =&gt; reserveAsset =&gt; isReserveAsset mapping(ISetToken =&gt; mapping(address =&gt; bool)) public isReserveAsset;  /* ============ Constants ============ */  // 0 index stores the manager fee in managerFees array, percentage charged on issue (denominated in reserve asset) uint256 constant internal MANAGER_ISSUE_FEE_INDEX = 0;  // 1 index stores the manager fee percentage in managerFees array, charged on redeem uint256 constant internal MANAGER_REDEEM_FEE_INDEX = 1;  // 0 index stores the manager revenue share protocol fee % on the controller, charged in the issuance function uint256 constant internal PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX = 0;  // 1 index stores the manager revenue share protocol fee % on the controller, charged in the redeem function uint256 constant internal PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX = 1;  // 2 index stores the direct protocol fee % on the controller, charged in the issuance function uint256 constant internal PROTOCOL_ISSUE_DIRECT_FEE_INDEX = 2;  // 3 index stores the direct protocol fee % on the controller, charged in the redeem function uint256 constant internal PROTOCOL_REDEEM_DIRECT_FEE_INDEX = 3;  /* ============ Constructor ============ */  /**  * @param _controller               Address of controller contract  * @param _weth                     Address of wrapped eth  */ constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {     weth = _weth; }  /* ============ External Functions ============ */  /**  * Deposits the allowed reserve asset into the SetToken and mints the appropriate % of Net Asset Value of the SetToken  * to the specified _to address.  *  * @param _setToken                     Instance of the SetToken contract  * @param _reserveAsset                 Address of the reserve asset to issue with  * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with  * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance  * @param _to                           Address to mint SetToken to  */ function issue(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity,     uint256 _minSetTokenReceiveQuantity,     address _to )     external     nonReentrant     onlyValidAndInitializedSet(_setToken) {     _validateCommon(_setToken, _reserveAsset, _reserveAssetQuantity);      _callPreIssueHooks(_setToken, _reserveAsset, _reserveAssetQuantity, msg.sender, _to);      ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, _reserveAsset, _reserveAssetQuantity);      _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);      _transferCollateralAndHandleFees(_setToken, IERC20(_reserveAsset), issueInfo);      _handleIssueStateUpdates(_setToken, _reserveAsset, _to, issueInfo); }  /**  * Wraps ETH and deposits WETH if allowed into the SetToken and mints the appropriate % of Net Asset Value of the SetToken  * to the specified _to address.  *  * @param _setToken                     Instance of the SetToken contract  * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance  * @param _to                           Address to mint SetToken to  */ function issueWithEther(     ISetToken _setToken,     uint256 _minSetTokenReceiveQuantity,     address _to )     external     payable     nonReentrant     onlyValidAndInitializedSet(_setToken) {     weth.deposit{ value: msg.value }();      _validateCommon(_setToken, address(weth), msg.value);      _callPreIssueHooks(_setToken, address(weth), msg.value, msg.sender, _to);      ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, address(weth), msg.value);      _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);      _transferWETHAndHandleFees(_setToken, issueInfo);      _handleIssueStateUpdates(_setToken, address(weth), _to, issueInfo); }  /**  * Redeems a SetToken into a valid reserve asset representing the appropriate % of Net Asset Value of the SetToken  * to the specified _to address. Only valid if there are available reserve units on the SetToken.  *  * @param _setToken                     Instance of the SetToken contract  * @param _reserveAsset                 Address of the reserve asset to redeem with  * @param _setTokenQuantity             Quantity of SetTokens to redeem  * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive  * @param _to                           Address to redeem reserve asset to  */ function redeem(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity,     uint256 _minReserveReceiveQuantity,     address _to )     external     nonReentrant     onlyValidAndInitializedSet(_setToken) {     _validateCommon(_setToken, _reserveAsset, _setTokenQuantity);      _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);      ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, _reserveAsset, _setTokenQuantity);      _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);      _setToken.burn(msg.sender, _setTokenQuantity);      // Instruct the SetToken to transfer the reserve asset back to the user     _setToken.strictInvokeTransfer(         _reserveAsset,         _to,         redeemInfo.netFlowQuantity     );      _handleRedemptionFees(_setToken, _reserveAsset, redeemInfo);      _handleRedeemStateUpdates(_setToken, _reserveAsset, _to, redeemInfo); }  /**  * Redeems a SetToken into Ether (if WETH is valid) representing the appropriate % of Net Asset Value of the SetToken  * to the specified _to address. Only valid if there are available WETH units on the SetToken.  *  * @param _setToken                     Instance of the SetToken contract  * @param _setTokenQuantity             Quantity of SetTokens to redeem  * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive  * @param _to                           Address to redeem reserve asset to  */ function redeemIntoEther(     ISetToken _setToken,     uint256 _setTokenQuantity,     uint256 _minReserveReceiveQuantity,     address payable _to )     external     nonReentrant     onlyValidAndInitializedSet(_setToken) {     _validateCommon(_setToken, address(weth), _setTokenQuantity);      _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);      ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, address(weth), _setTokenQuantity);      _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);      _setToken.burn(msg.sender, _setTokenQuantity);      // Instruct the SetToken to transfer WETH from SetToken to module     _setToken.strictInvokeTransfer(         address(weth),         address(this),         redeemInfo.netFlowQuantity     );      weth.withdraw(redeemInfo.netFlowQuantity);      _to.transfer(redeemInfo.netFlowQuantity);      _handleRedemptionFees(_setToken, address(weth), redeemInfo);      _handleRedeemStateUpdates(_setToken, address(weth), _to, redeemInfo); }  /**  * SET MANAGER ONLY. Add an allowed reserve asset  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset to add  */ function addReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {     require(!isReserveAsset[_setToken][_reserveAsset], "Reserve asset already exists");      navIssuanceSettings[_setToken].reserveAssets.push(_reserveAsset);     isReserveAsset[_setToken][_reserveAsset] = true;      emit ReserveAssetAdded(_setToken, _reserveAsset); }  /**  * SET MANAGER ONLY. Remove a reserve asset  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset to remove  */ function removeReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {     require(isReserveAsset[_setToken][_reserveAsset], "Reserve asset does not exist");      navIssuanceSettings[_setToken].reserveAssets = navIssuanceSettings[_setToken].reserveAssets.remove(_reserveAsset);     delete isReserveAsset[_setToken][_reserveAsset];      emit ReserveAssetRemoved(_setToken, _reserveAsset); }  /**  * SET MANAGER ONLY. Edit the premium percentage  *  * @param _setToken                     Instance of the SetToken  * @param _premiumPercentage            Premium percentage in 10e16 (e.g. 10e16 = 1%)  */ function editPremium(ISetToken _setToken, uint256 _premiumPercentage) external onlyManagerAndValidSet(_setToken) {     require(_premiumPercentage &lt;= navIssuanceSettings[_setToken].maxPremiumPercentage, "Premium must be less than maximum allowed");      navIssuanceSettings[_setToken].premiumPercentage = _premiumPercentage;      emit PremiumEdited(_setToken, _premiumPercentage); }  /**  * SET MANAGER ONLY. Edit manager fee  *  * @param _setToken                     Instance of the SetToken  * @param _managerFeePercentage         Manager fee percentage in 10e16 (e.g. 10e16 = 1%)  * @param _managerFeeIndex              Manager fee index. 0 index is issue fee, 1 index is redeem fee  */ function editManagerFee(     ISetToken _setToken,     uint256 _managerFeePercentage,     uint256 _managerFeeIndex )     external     onlyManagerAndValidSet(_setToken) {     require(_managerFeePercentage &lt;= navIssuanceSettings[_setToken].maxManagerFee, "Manager fee must be less than maximum allowed");      navIssuanceSettings[_setToken].managerFees[_managerFeeIndex] = _managerFeePercentage;      emit ManagerFeeEdited(_setToken, _managerFeePercentage, _managerFeeIndex); }  /**  * SET MANAGER ONLY. Edit the manager fee recipient  *  * @param _setToken                     Instance of the SetToken  * @param _managerFeeRecipient          Manager fee recipient  */ function editFeeRecipient(ISetToken _setToken, address _managerFeeRecipient) external onlyManagerAndValidSet(_setToken) {     require(_managerFeeRecipient != address(0), "Fee recipient must not be 0 address");      navIssuanceSettings[_setToken].feeRecipient = _managerFeeRecipient;      emit FeeRecipientEdited(_setToken, _managerFeeRecipient); }  /**  * SET MANAGER ONLY. Initializes this module to the SetToken with hooks, allowed reserve assets,  * fees and issuance premium. Only callable by the SetToken's manager. Hook addresses are optional.  * Address(0) means that no hook will be called.  *  * @param _setToken                     Instance of the SetToken to issue  * @param _navIssuanceSettings          NAVIssuanceSettings struct defining parameters  */ function initialize(     ISetToken _setToken,     NAVIssuanceSettings memory _navIssuanceSettings )     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     require(_navIssuanceSettings.reserveAssets.length &gt; 0, "Reserve assets must be greater than 0");     require(_navIssuanceSettings.maxManagerFee &lt; PreciseUnitMath.preciseUnit(), "Max manager fee must be less than 100%");     require(_navIssuanceSettings.maxPremiumPercentage &lt; PreciseUnitMath.preciseUnit(), "Max premium percentage must be less than 100%");     require(_navIssuanceSettings.managerFees[0] &lt;= _navIssuanceSettings.maxManagerFee, "Manager issue fee must be less than max");     require(_navIssuanceSettings.managerFees[1] &lt;= _navIssuanceSettings.maxManagerFee, "Manager redeem fee must be less than max");     require(_navIssuanceSettings.premiumPercentage &lt;= _navIssuanceSettings.maxPremiumPercentage, "Premium must be less than max");     require(_navIssuanceSettings.feeRecipient != address(0), "Fee Recipient must be non-zero address.");     // Initial mint of Set cannot use NAVIssuance since minSetTokenSupply must be &gt; 0     require(_navIssuanceSettings.minSetTokenSupply &gt; 0, "Min SetToken supply must be greater than 0");      for (uint256 i = 0; i &lt; _navIssuanceSettings.reserveAssets.length; i++) {         require(!isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]], "Reserve assets must be unique");         isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]] = true;     }      navIssuanceSettings[_setToken] = _navIssuanceSettings;      _setToken.initializeModule(); }  /**  * Removes this module from the SetToken, via call by the SetToken. Issuance settings and  * reserve asset states are deleted.  */ function removeModule() external override {     ISetToken setToken = ISetToken(msg.sender);     for (uint256 i = 0; i &lt; navIssuanceSettings[setToken].reserveAssets.length; i++) {         delete isReserveAsset[setToken][navIssuanceSettings[setToken].reserveAssets[i]];     }      delete navIssuanceSettings[setToken]; }  receive() external payable {}  /* ============ External Getter Functions ============ */  function getReserveAssets(ISetToken _setToken) external view returns (address[] memory) {     return navIssuanceSettings[_setToken].reserveAssets; }  function getIssuePremium(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     external     view     returns (uint256) {     return _getIssuePremium(_setToken, _reserveAsset, _reserveAssetQuantity); }  function getRedeemPremium(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     external     view     returns (uint256) {     return _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity); }  function getManagerFee(ISetToken _setToken, uint256 _managerFeeIndex) external view returns (uint256) {     return navIssuanceSettings[_setToken].managerFees[_managerFeeIndex]; }  /**  * Get the expected SetTokens minted to recipient on issuance  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with  *  * @return  uint256                     Expected SetTokens to be minted to recipient  */ function getExpectedSetTokenIssueQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     external     view     returns (uint256) {     (,, uint256 netReserveFlow) = _getFees(         _setToken,         _reserveAssetQuantity,         PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_ISSUE_DIRECT_FEE_INDEX,         MANAGER_ISSUE_FEE_INDEX     );      uint256 setTotalSupply = _setToken.totalSupply();      return _getSetTokenMintQuantity(         _setToken,         _reserveAsset,         netReserveFlow,         setTotalSupply     ); }  /**  * Get the expected reserve asset to be redeemed  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _setTokenQuantity             Quantity of SetTokens to redeem  *  * @return  uint256                     Expected reserve asset quantity redeemed  */ function getExpectedReserveRedeemQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     external     view     returns (uint256) {     uint256 preFeeReserveQuantity = _getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);      (,, uint256 netReserveFlows) = _getFees(         _setToken,         preFeeReserveQuantity,         PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_REDEEM_DIRECT_FEE_INDEX,         MANAGER_REDEEM_FEE_INDEX     );      return netReserveFlows; }  /**  * Checks if issue is valid  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with  *  * @return  bool                        Returns true if issue is valid  */ function isIssueValid(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     external     view     returns (bool) {     uint256 setTotalSupply = _setToken.totalSupply();  return _reserveAssetQuantity != 0         &amp;&amp; isReserveAsset[_setToken][_reserveAsset]         &amp;&amp; setTotalSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply; }  /**  * Checks if redeem is valid  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _setTokenQuantity             Quantity of SetTokens to redeem  *  * @return  bool                        Returns true if redeem is valid  */ function isRedeemValid(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     external     view     returns (bool) {     uint256 setTotalSupply = _setToken.totalSupply();      if (         _setTokenQuantity == 0         || !isReserveAsset[_setToken][_reserveAsset]         || setTotalSupply &lt; navIssuanceSettings[_setToken].minSetTokenSupply.add(_setTokenQuantity)     ) {         return false;     } else {         uint256 totalRedeemValue =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);          (,, uint256 expectedRedeemQuantity) = _getFees(             _setToken,             totalRedeemValue,             PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,             PROTOCOL_REDEEM_DIRECT_FEE_INDEX,             MANAGER_REDEEM_FEE_INDEX         );          uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();          return existingUnit.preciseMul(setTotalSupply) &gt;= expectedRedeemQuantity;     } }  /* ============ Internal Functions ============ */  function _validateCommon(ISetToken _setToken, address _reserveAsset, uint256 _quantity) internal view {     require(_quantity &gt; 0, "Quantity must be &gt; 0");     require(isReserveAsset[_setToken][_reserveAsset], "Must be valid reserve asset"); }  function _validateIssuanceInfo(ISetToken _setToken, uint256 _minSetTokenReceiveQuantity, ActionInfo memory _issueInfo) internal view {     // Check that total supply is greater than min supply needed for issuance     // Note: A min supply amount is needed to avoid division by 0 when SetToken supply is 0     require(         _issueInfo.previousSetTokenSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply,         "Supply must be greater than minimum to enable issuance"     );      require(_issueInfo.setTokenQuantity &gt;= _minSetTokenReceiveQuantity, "Must be greater than min SetToken"); }  function _validateRedemptionInfo(     ISetToken _setToken,     uint256 _minReserveReceiveQuantity,     ActionInfo memory _redeemInfo )     internal     view {     // Check that new supply is more than min supply needed for redemption     // Note: A min supply amount is needed to avoid division by 0 when redeeming SetToken to 0     require(         _redeemInfo.newSetTokenSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply,         "Supply must be greater than minimum to enable redemption"     );      require(_redeemInfo.netFlowQuantity &gt;= _minReserveReceiveQuantity, "Must be greater than min receive reserve quantity"); }  function _createIssuanceInfo(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     internal     view     returns (ActionInfo memory) {     ActionInfo memory issueInfo;      issueInfo.previousSetTokenSupply = _setToken.totalSupply();      issueInfo.preFeeReserveQuantity = _reserveAssetQuantity;      (issueInfo.protocolFees, issueInfo.managerFee, issueInfo.netFlowQuantity) = _getFees(         _setToken,         issueInfo.preFeeReserveQuantity,         PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_ISSUE_DIRECT_FEE_INDEX,         MANAGER_ISSUE_FEE_INDEX     );      issueInfo.setTokenQuantity = _getSetTokenMintQuantity(         _setToken,         _reserveAsset,         issueInfo.netFlowQuantity,         issueInfo.previousSetTokenSupply     );      (issueInfo.newSetTokenSupply, issueInfo.newPositionMultiplier) = _getIssuePositionMultiplier(_setToken, issueInfo);      issueInfo.newReservePositionUnit = _getIssuePositionUnit(_setToken, _reserveAsset, issueInfo);      return issueInfo; }  function _createRedemptionInfo(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     internal     view     returns (ActionInfo memory) {     ActionInfo memory redeemInfo;      redeemInfo.setTokenQuantity = _setTokenQuantity;      redeemInfo.preFeeReserveQuantity =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);      (redeemInfo.protocolFees, redeemInfo.managerFee, redeemInfo.netFlowQuantity) = _getFees(         _setToken,         redeemInfo.preFeeReserveQuantity,         PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_REDEEM_DIRECT_FEE_INDEX,         MANAGER_REDEEM_FEE_INDEX     );      redeemInfo.previousSetTokenSupply = _setToken.totalSupply();      (redeemInfo.newSetTokenSupply, redeemInfo.newPositionMultiplier) = _getRedeemPositionMultiplier(_setToken, _setTokenQuantity, redeemInfo);      redeemInfo.newReservePositionUnit = _getRedeemPositionUnit(_setToken, _reserveAsset, redeemInfo);      return redeemInfo; }  /**  * Transfer reserve asset from user to SetToken and fees from user to appropriate fee recipients  */ function _transferCollateralAndHandleFees(ISetToken _setToken, IERC20 _reserveAsset, ActionInfo memory _issueInfo) internal {     transferFrom(_reserveAsset, msg.sender, address(_setToken), _issueInfo.netFlowQuantity);      if (_issueInfo.protocolFees &gt; 0) {         transferFrom(_reserveAsset, msg.sender, controller.feeRecipient(), _issueInfo.protocolFees);     }      if (_issueInfo.managerFee &gt; 0) {         transferFrom(_reserveAsset, msg.sender, navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);     } }   /**   * Transfer WETH from module to SetToken and fees from module to appropriate fee recipients  */ function _transferWETHAndHandleFees(ISetToken _setToken, ActionInfo memory _issueInfo) internal {     weth.transfer(address(_setToken), _issueInfo.netFlowQuantity);      if (_issueInfo.protocolFees &gt; 0) {         weth.transfer(controller.feeRecipient(), _issueInfo.protocolFees);     }      if (_issueInfo.managerFee &gt; 0) {         weth.transfer(navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);     } }  function _handleIssueStateUpdates(     ISetToken _setToken,     address _reserveAsset,     address _to,     ActionInfo memory _issueInfo )     internal {     _setToken.editPositionMultiplier(_issueInfo.newPositionMultiplier);      _setToken.editDefaultPosition(_reserveAsset, _issueInfo.newReservePositionUnit);      _setToken.mint(_to, _issueInfo.setTokenQuantity);      emit SetTokenNAVIssued(         _setToken,         msg.sender,         _to,         _reserveAsset,         address(navIssuanceSettings[_setToken].managerIssuanceHook),         _issueInfo.setTokenQuantity,         _issueInfo.managerFee,         _issueInfo.protocolFees     ); }  function _handleRedeemStateUpdates(     ISetToken _setToken,     address _reserveAsset,     address _to,     ActionInfo memory _redeemInfo )     internal {     _setToken.editPositionMultiplier(_redeemInfo.newPositionMultiplier);      _setToken.editDefaultPosition(_reserveAsset, _redeemInfo.newReservePositionUnit);      emit SetTokenNAVRedeemed(         _setToken,         msg.sender,         _to,         _reserveAsset,         address(navIssuanceSettings[_setToken].managerRedemptionHook),         _redeemInfo.setTokenQuantity,         _redeemInfo.managerFee,         _redeemInfo.protocolFees     ); }  function _handleRedemptionFees(ISetToken _setToken, address _reserveAsset, ActionInfo memory _redeemInfo) internal {     // Instruct the SetToken to transfer protocol fee to fee recipient if there is a fee     payProtocolFeeFromSetToken(_setToken, _reserveAsset, _redeemInfo.protocolFees);      // Instruct the SetToken to transfer manager fee to manager fee recipient if there is a fee     if (_redeemInfo.managerFee &gt; 0) {         _setToken.strictInvokeTransfer(             _reserveAsset,             navIssuanceSettings[_setToken].feeRecipient,             _redeemInfo.managerFee         );     } }  /**  * Returns the issue premium percentage. Virtual function that can be overridden in future versions of the module  * and can contain arbitrary logic to calculate the issuance premium.  */ function _getIssuePremium(     ISetToken _setToken,     address /* _reserveAsset */,     uint256 /* _reserveAssetQuantity */ )     virtual     internal     view     returns (uint256) {     return navIssuanceSettings[_setToken].premiumPercentage; }  /**  * Returns the redeem premium percentage. Virtual function that can be overridden in future versions of the module  * and can contain arbitrary logic to calculate the redemption premium.  */ function _getRedeemPremium(     ISetToken _setToken,     address /* _reserveAsset */,     uint256 /* _setTokenQuantity */ )     virtual     internal     view     returns (uint256) {     return navIssuanceSettings[_setToken].premiumPercentage; }  /**  * Returns the fees attributed to the manager and the protocol. The fees are calculated as follows:  *  * ManagerFee = (manager fee % - % to protocol) * reserveAssetQuantity  * Protocol Fee = (% manager fee share + direct fee %) * reserveAssetQuantity  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAssetQuantity         Quantity of reserve asset to calculate fees from  * @param _protocolManagerFeeIndex      Index to pull rev share NAV Issuance fee from the Controller  * @param _protocolDirectFeeIndex       Index to pull direct NAV issuance fee from the Controller  * @param _managerFeeIndex              Index from NAVIssuanceSettings (0 = issue fee, 1 = redeem fee)  *  * @return  uint256                     Fees paid to the protocol in reserve asset  * @return  uint256                     Fees paid to the manager in reserve asset  * @return  uint256                     Net reserve to user net of fees  */ function _getFees(     ISetToken _setToken,     uint256 _reserveAssetQuantity,     uint256 _protocolManagerFeeIndex,     uint256 _protocolDirectFeeIndex,     uint256 _managerFeeIndex )     internal     view     returns (uint256, uint256, uint256) {     (uint256 protocolFeePercentage, uint256 managerFeePercentage) = _getProtocolAndManagerFeePercentages(         _setToken,         _protocolManagerFeeIndex,         _protocolDirectFeeIndex,         _managerFeeIndex     );      // Calculate total notional fees     uint256 protocolFees = protocolFeePercentage.preciseMul(_reserveAssetQuantity);     uint256 managerFee = managerFeePercentage.preciseMul(_reserveAssetQuantity);      uint256 netReserveFlow = _reserveAssetQuantity.sub(protocolFees).sub(managerFee);      return (protocolFees, managerFee, netReserveFlow); }  function _getProtocolAndManagerFeePercentages(     ISetToken _setToken,     uint256 _protocolManagerFeeIndex,     uint256 _protocolDirectFeeIndex,     uint256 _managerFeeIndex )     internal     view     returns(uint256, uint256) {     // Get protocol fee percentages     uint256 protocolDirectFeePercent = controller.getModuleFee(address(this), _protocolDirectFeeIndex);     uint256 protocolManagerShareFeePercent = controller.getModuleFee(address(this), _protocolManagerFeeIndex);     uint256 managerFeePercent = navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];      // Calculate revenue share split percentage     uint256 protocolRevenueSharePercentage = protocolManagerShareFeePercent.preciseMul(managerFeePercent);     uint256 managerRevenueSharePercentage = managerFeePercent.sub(protocolRevenueSharePercentage);     uint256 totalProtocolFeePercentage = protocolRevenueSharePercentage.add(protocolDirectFeePercent);      return (totalProtocolFeePercentage, managerRevenueSharePercentage); }  function _getSetTokenMintQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _netReserveFlows,            // Value of reserve asset net of fees     uint256 _setTotalSupply )     internal     view     returns (uint256) {     uint256 premiumPercentage = _getIssuePremium(_setToken, _reserveAsset, _netReserveFlows);     uint256 premiumValue = _netReserveFlows.preciseMul(premiumPercentage);      // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (1e18)     // Reverts if price is not found     uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);      // Get reserve asset decimals     uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();     uint256 normalizedTotalReserveQuantityNetFees = _netReserveFlows.preciseDiv(10 ** reserveAssetDecimals);     uint256 normalizedTotalReserveQuantityNetFeesAndPremium = _netReserveFlows.sub(premiumValue).preciseDiv(10 ** reserveAssetDecimals);      // Calculate SetTokens to mint to issuer     uint256 denominator = _setTotalSupply.preciseMul(setTokenValuation).add(normalizedTotalReserveQuantityNetFees).sub(normalizedTotalReserveQuantityNetFeesAndPremium);     return normalizedTotalReserveQuantityNetFeesAndPremium.preciseMul(_setTotalSupply).preciseDiv(denominator); }  function _getRedeemReserveQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     internal     view     returns (uint256) {     // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (10e18)     // Reverts if price is not found     uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);      uint256 totalRedeemValueInPreciseUnits = _setTokenQuantity.preciseMul(setTokenValuation);     // Get reserve asset decimals     uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();     uint256 prePremiumReserveQuantity = totalRedeemValueInPreciseUnits.preciseMul(10 ** reserveAssetDecimals);      uint256 premiumPercentage = _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);     uint256 premiumQuantity = prePremiumReserveQuantity.preciseMulCeil(premiumPercentage);      return prePremiumReserveQuantity.sub(premiumQuantity); }  /**  * The new position multiplier is calculated as follows:  * inflationPercentage = (newSupply - oldSupply) / newSupply  * newMultiplier = (1 - inflationPercentage) * positionMultiplier  */ function _getIssuePositionMultiplier(     ISetToken _setToken,     ActionInfo memory _issueInfo )     internal     view     returns (uint256, int256) {     // Calculate inflation and new position multiplier. Note: Round inflation up in order to round position multiplier down     uint256 newTotalSupply = _issueInfo.setTokenQuantity.add(_issueInfo.previousSetTokenSupply);     int256 newPositionMultiplier = _setToken.positionMultiplier()         .mul(_issueInfo.previousSetTokenSupply.toInt256())         .div(newTotalSupply.toInt256());      return (newTotalSupply, newPositionMultiplier); }  /**  * Calculate deflation and new position multiplier. Note: Round deflation down in order to round position multiplier down  *  * The new position multiplier is calculated as follows:  * deflationPercentage = (oldSupply - newSupply) / newSupply  * newMultiplier = (1 + deflationPercentage) * positionMultiplier  */ function _getRedeemPositionMultiplier(     ISetToken _setToken,     uint256 _setTokenQuantity,     ActionInfo memory _redeemInfo )     internal     view     returns (uint256, int256) {     uint256 newTotalSupply = _redeemInfo.previousSetTokenSupply.sub(_setTokenQuantity);     int256 newPositionMultiplier = _setToken.positionMultiplier()         .mul(_redeemInfo.previousSetTokenSupply.toInt256())         .div(newTotalSupply.toInt256());      return (newTotalSupply, newPositionMultiplier); }  /**  * The new position reserve asset unit is calculated as follows:  * totalReserve = (oldUnit * oldSetTokenSupply) + reserveQuantity  * newUnit = totalReserve / newSetTokenSupply  */ function _getIssuePositionUnit(     ISetToken _setToken,     address _reserveAsset,     ActionInfo memory _issueInfo )     internal     view     returns (uint256) {     uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();     uint256 totalReserve = existingUnit         .preciseMul(_issueInfo.previousSetTokenSupply)         .add(_issueInfo.netFlowQuantity);      return totalReserve.preciseDiv(_issueInfo.newSetTokenSupply); }  /**  * The new position reserve asset unit is calculated as follows:  * totalReserve = (oldUnit * oldSetTokenSupply) - reserveQuantityToSendOut  * newUnit = totalReserve / newSetTokenSupply  */ function _getRedeemPositionUnit(     ISetToken _setToken,     address _reserveAsset,     ActionInfo memory _redeemInfo )     internal     view     returns (uint256) {     uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();     uint256 totalExistingUnits = existingUnit.preciseMul(_redeemInfo.previousSetTokenSupply);      uint256 outflow = _redeemInfo.netFlowQuantity.add(_redeemInfo.protocolFees).add(_redeemInfo.managerFee);      // Require withdrawable quantity is greater than existing collateral     require(totalExistingUnits &gt;= outflow, "Must be greater than total available collateral");      return totalExistingUnits.sub(outflow).preciseDiv(_redeemInfo.newSetTokenSupply); }  /**  * If a pre-issue hook has been configured, call the external-protocol contract. Pre-issue hook logic  * can contain arbitrary logic including validations, external function calls, etc.  */ function _callPreIssueHooks(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity,     address _caller,     address _to )     internal {     INAVIssuanceHook preIssueHook = navIssuanceSettings[_setToken].managerIssuanceHook;     if (address(preIssueHook) != address(0)) {         preIssueHook.invokePreIssueHook(_setToken, _reserveAsset, _reserveAssetQuantity, _caller, _to);     } }  /**  * If a pre-redeem hook has been configured, call the external-protocol contract.  */ function _callPreRedeemHooks(ISetToken _setToken, uint256 _setQuantity, address _caller, address _to) internal {     INAVIssuanceHook preRedeemHook = navIssuanceSettings[_setToken].managerRedemptionHook;     if (address(preRedeemHook) != address(0)) {         preRedeemHook.invokePreRedeemHook(_setToken, _setQuantity, _caller, _to);     } }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 05:31:43 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: /*
    Copyright 2020 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";
import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";
import { SignedSafeMath } from "@openzeppelin/contracts/math/SignedSafeMath.sol";

import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";
import { IController } from "../../interfaces/IController.sol";
import { INAVIssuanceHook } from "../../interfaces/INAVIssuanceHook.sol";
import { Invoke } from "../lib/Invoke.sol";
import { ISetToken } from "../../interfaces/ISetToken.sol";
import { IWETH } from "../../interfaces/external/IWETH.sol";
import { ModuleBase } from "../lib/ModuleBase.sol";
import { Position } from "../lib/Position.sol";
import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";
import { ResourceIdentifier } from "../lib/ResourceIdentifier.sol";


/**
 * @title NavIssuanceModule
 * @author Set Protocol
 *
 * Module that enables issuance and redemption with any valid ERC20 token or ETH if allowed by the manager. Sender receives
 * a proportional amount of SetTokens on issuance or ERC20 token on redemption based on the calculated net asset value using
 * oracle prices. Manager is able to enforce a premium / discount on issuance / redemption to avoid arbitrage and front
 * running when relying on oracle prices. Managers can charge a fee (denominated in reserve asset).
 */
contract NavIssuanceModule is ModuleBase, ReentrancyGuard {
    using AddressArrayUtils for address[];
    using Invoke for ISetToken;
    using Position for ISetToken;
    using PreciseUnitMath for uint256;
    using PreciseUnitMath for int256;
    using ResourceIdentifier for IController;
    using SafeMath for uint256;
    using SafeCast for int256;
    using SafeCast for uint256;
    using SignedSafeMath for int256;

    /* ============ Events ============ */

    event SetTokenNAVIssued(
        ISetToken indexed _setToken,
        address _issuer,
        address _to,
        address _reserveAsset,
        address _hookContract,
        uint256 _setTokenQuantity,
        uint256 _managerFee,
        uint256 _premium
    );

    event SetTokenNAVRedeemed(
        ISetToken indexed _setToken,
        address _redeemer,
        address _to,
        address _reserveAsset,
        address _hookContract,
        uint256 _setTokenQuantity,
        uint256 _managerFee,
        uint256 _premium
    );

    event ReserveAssetAdded(
        ISetToken indexed _setToken,
        address _newReserveAsset
    );

    event ReserveAssetRemoved(
        ISetToken indexed _setToken,
        address _removedReserveAsset
    );

    event PremiumEdited(
        ISetToken indexed _setToken,
        uint256 _newPremium
    );

    event ManagerFeeEdited(
        ISetToken indexed _setToken,
        uint256 _newManagerFee,
        uint256 _index
    );

    event FeeRecipientEdited(
        ISetToken indexed _setToken,
        address _feeRecipient
    );

    /* ============ Structs ============ */

    struct NAVIssuanceSettings {
        INAVIssuanceHook managerIssuanceHook;      // Issuance hook configurations
        INAVIssuanceHook managerRedemptionHook;    // Redemption hook configurations
        address[] reserveAssets;                       // Allowed reserve assets - Must have a price enabled with the price oracle
        address feeRecipient;                          // Manager fee recipient
        uint256[2] managerFees;                        // Manager fees. 0 index is issue and 1 index is redeem fee (0.01% = 1e14, 1% = 1e16)
        uint256 maxManagerFee;                         // Maximum fee manager is allowed to set for issue and redeem
        uint256 premiumPercentage;                     // Premium percentage (0.01% = 1e14, 1% = 1e16). This premium is a buffer around oracle
                                                       // prices paid by user to the SetToken, which prevents arbitrage and oracle front running
        uint256 maxPremiumPercentage;                  // Maximum premium percentage manager is allowed to set (configured by manager)
        uint256 minSetTokenSupply;                     // Minimum SetToken supply required for issuance and redemption
                                                       // to prevent dramatic inflationary changes to the SetToken's position multiplier
    }

    struct ActionInfo {
        uint256 preFeeReserveQuantity;                 // Reserve value before fees; During issuance, represents raw quantity
                                                       // During redeem, represents post-premium value
        uint256 protocolFees;                          // Total protocol fees (direct + manager revenue share)
        uint256 managerFee;                            // Total manager fee paid in reserve asset
        uint256 netFlowQuantity;                       // When issuing, quantity of reserve asset sent to SetToken
                                                       // When redeeming, quantity of reserve asset sent to redeemer
        uint256 setTokenQuantity;                      // When issuing, quantity of SetTokens minted to mintee
                                                       // When redeeming, quantity of SetToken redeemed
        uint256 previousSetTokenSupply;                // SetToken supply prior to issue/redeem action
        uint256 newSetTokenSupply;                     // SetToken supply after issue/redeem action
        int256 newPositionMultiplier;                  // SetToken position multiplier after issue/redeem
        uint256 newReservePositionUnit;                // SetToken reserve asset position unit after issue/redeem
    }

    /* ============ State Variables ============ */

    // Wrapped ETH address
    IWETH public immutable weth;

    // Mapping of SetToken to NAV issuance settings struct
    mapping(ISetToken => NAVIssuanceSettings) public navIssuanceSettings;

    // Mapping to efficiently check a SetToken's reserve asset validity
    // SetToken => reserveAsset => isReserveAsset
    mapping(ISetToken => mapping(address => bool)) public isReserveAsset;

    /* ============ Constants ============ */

    // 0 index stores the manager fee in managerFees array, percentage charged on issue (denominated in reserve asset)
    uint256 constant internal MANAGER_ISSUE_FEE_INDEX = 0;

    // 1 index stores the manager fee percentage in managerFees array, charged on redeem
    uint256 constant internal MANAGER_REDEEM_FEE_INDEX = 1;

    // 0 index stores the manager revenue share protocol fee % on the controller, charged in the issuance function
    uint256 constant internal PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX = 0;

    // 1 index stores the manager revenue share protocol fee % on the controller, charged in the redeem function
    uint256 constant internal PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX = 1;

    // 2 index stores the direct protocol fee % on the controller, charged in the issuance function
    uint256 constant internal PROTOCOL_ISSUE_DIRECT_FEE_INDEX = 2;

    // 3 index stores the direct protocol fee % on the controller, charged in the redeem function
    uint256 constant internal PROTOCOL_REDEEM_DIRECT_FEE_INDEX = 3;

    /* ============ Constructor ============ */

    /**
     * @param _controller               Address of controller contract
     * @param _weth                     Address of wrapped eth
     */
    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {
        weth = _weth;
    }

    /* ============ External Functions ============ */

    /**
     * Deposits the allowed reserve asset into the SetToken and mints the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _reserveAsset                 Address of the reserve asset to issue with
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance
     * @param _to                           Address to mint SetToken to
     */
    function issue(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity,
        uint256 _minSetTokenReceiveQuantity,
        address _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, _reserveAsset, _reserveAssetQuantity);

        _callPreIssueHooks(_setToken, _reserveAsset, _reserveAssetQuantity, msg.sender, _to);

        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, _reserveAsset, _reserveAssetQuantity);

        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);

        _transferCollateralAndHandleFees(_setToken, IERC20(_reserveAsset), issueInfo);

        _handleIssueStateUpdates(_setToken, _reserveAsset, _to, issueInfo);
    }

    /**
     * Wraps ETH and deposits WETH if allowed into the SetToken and mints the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance
     * @param _to                           Address to mint SetToken to
     */
    function issueWithEther(
        ISetToken _setToken,
        uint256 _minSetTokenReceiveQuantity,
        address _to
    )
        external
        payable
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        weth.deposit{ value: msg.value }();

        _validateCommon(_setToken, address(weth), msg.value);

        _callPreIssueHooks(_setToken, address(weth), msg.value, msg.sender, _to);

        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, address(weth), msg.value);

        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);

        _transferWETHAndHandleFees(_setToken, issueInfo);

        _handleIssueStateUpdates(_setToken, address(weth), _to, issueInfo);
    }

    /**
     * Redeems a SetToken into a valid reserve asset representing the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address. Only valid if there are available reserve units on the SetToken.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _reserveAsset                 Address of the reserve asset to redeem with
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive
     * @param _to                           Address to redeem reserve asset to
     */
    function redeem(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity,
        uint256 _minReserveReceiveQuantity,
        address _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, _reserveAsset, _setTokenQuantity);

        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);

        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, _reserveAsset, _setTokenQuantity);

        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);

        _setToken.burn(msg.sender, _setTokenQuantity);

        // Instruct the SetToken to transfer the reserve asset back to the user
        _setToken.strictInvokeTransfer(
            _reserveAsset,
            _to,
            redeemInfo.netFlowQuantity
        );

        _handleRedemptionFees(_setToken, _reserveAsset, redeemInfo);

        _handleRedeemStateUpdates(_setToken, _reserveAsset, _to, redeemInfo);
    }

    /**
     * Redeems a SetToken into Ether (if WETH is valid) representing the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address. Only valid if there are available WETH units on the SetToken.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive
     * @param _to                           Address to redeem reserve asset to
     */
    function redeemIntoEther(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        uint256 _minReserveReceiveQuantity,
        address payable _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, address(weth), _setTokenQuantity);

        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);

        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, address(weth), _setTokenQuantity);

        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);

        _setToken.burn(msg.sender, _setTokenQuantity);

        // Instruct the SetToken to transfer WETH from SetToken to module
        _setToken.strictInvokeTransfer(
            address(weth),
            address(this),
            redeemInfo.netFlowQuantity
        );

        weth.withdraw(redeemInfo.netFlowQuantity);

        _to.transfer(redeemInfo.netFlowQuantity);

        _handleRedemptionFees(_setToken, address(weth), redeemInfo);

        _handleRedeemStateUpdates(_setToken, address(weth), _to, redeemInfo);
    }

    /**
     * SET MANAGER ONLY. Add an allowed reserve asset
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset to add
     */
    function addReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {
        require(!isReserveAsset[_setToken][_reserveAsset], "Reserve asset already exists");

        navIssuanceSettings[_setToken].reserveAssets.push(_reserveAsset);
        isReserveAsset[_setToken][_reserveAsset] = true;

        emit ReserveAssetAdded(_setToken, _reserveAsset);
    }

    /**
     * SET MANAGER ONLY. Remove a reserve asset
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset to remove
     */
    function removeReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {
        require(isReserveAsset[_setToken][_reserveAsset], "Reserve asset does not exist");

        navIssuanceSettings[_setToken].reserveAssets = navIssuanceSettings[_setToken].reserveAssets.remove(_reserveAsset);
        delete isReserveAsset[_setToken][_reserveAsset];

        emit ReserveAssetRemoved(_setToken, _reserveAsset);
    }

    /**
     * SET MANAGER ONLY. Edit the premium percentage
     *
     * @param _setToken                     Instance of the SetToken
     * @param _premiumPercentage            Premium percentage in 10e16 (e.g. 10e16 = 1%)
     */
    function editPremium(ISetToken _setToken, uint256 _premiumPercentage) external onlyManagerAndValidSet(_setToken) {
        require(_premiumPercentage <= navIssuanceSettings[_setToken].maxPremiumPercentage, "Premium must be less than maximum allowed");

        navIssuanceSettings[_setToken].premiumPercentage = _premiumPercentage;

        emit PremiumEdited(_setToken, _premiumPercentage);
    }

    /**
     * SET MANAGER ONLY. Edit manager fee
     *
     * @param _setToken                     Instance of the SetToken
     * @param _managerFeePercentage         Manager fee percentage in 10e16 (e.g. 10e16 = 1%)
     * @param _managerFeeIndex              Manager fee index. 0 index is issue fee, 1 index is redeem fee
     */
    function editManagerFee(
        ISetToken _setToken,
        uint256 _managerFeePercentage,
        uint256 _managerFeeIndex
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        require(_managerFeePercentage <= navIssuanceSettings[_setToken].maxManagerFee, "Manager fee must be less than maximum allowed");

        navIssuanceSettings[_setToken].managerFees[_managerFeeIndex] = _managerFeePercentage;

        emit ManagerFeeEdited(_setToken, _managerFeePercentage, _managerFeeIndex);
    }

    /**
     * SET MANAGER ONLY. Edit the manager fee recipient
     *
     * @param _setToken                     Instance of the SetToken
     * @param _managerFeeRecipient          Manager fee recipient
     */
    function editFeeRecipient(ISetToken _setToken, address _managerFeeRecipient) external onlyManagerAndValidSet(_setToken) {
        require(_managerFeeRecipient != address(0), "Fee recipient must not be 0 address");

        navIssuanceSettings[_setToken].feeRecipient = _managerFeeRecipient;

        emit FeeRecipientEdited(_setToken, _managerFeeRecipient);
    }

    /**
     * SET MANAGER ONLY. Initializes this module to the SetToken with hooks, allowed reserve assets,
     * fees and issuance premium. Only callable by the SetToken's manager. Hook addresses are optional.
     * Address(0) means that no hook will be called.
     *
     * @param _setToken                     Instance of the SetToken to issue
     * @param _navIssuanceSettings          NAVIssuanceSettings struct defining parameters
     */
    function initialize(
        ISetToken _setToken,
        NAVIssuanceSettings memory _navIssuanceSettings
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        require(_navIssuanceSettings.reserveAssets.length > 0, "Reserve assets must be greater than 0");
        require(_navIssuanceSettings.maxManagerFee < PreciseUnitMath.preciseUnit(), "Max manager fee must be less than 100%");
        require(_navIssuanceSettings.maxPremiumPercentage < PreciseUnitMath.preciseUnit(), "Max premium percentage must be less than 100%");
        require(_navIssuanceSettings.managerFees[0] <= _navIssuanceSettings.maxManagerFee, "Manager issue fee must be less than max");
        require(_navIssuanceSettings.managerFees[1] <= _navIssuanceSettings.maxManagerFee, "Manager redeem fee must be less than max");
        require(_navIssuanceSettings.premiumPercentage <= _navIssuanceSettings.maxPremiumPercentage, "Premium must be less than max");
        require(_navIssuanceSettings.feeRecipient != address(0), "Fee Recipient must be non-zero address.");
        // Initial mint of Set cannot use NAVIssuance since minSetTokenSupply must be > 0
        require(_navIssuanceSettings.minSetTokenSupply > 0, "Min SetToken supply must be greater than 0");

        for (uint256 i = 0; i < _navIssuanceSettings.reserveAssets.length; i++) {
            require(!isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]], "Reserve assets must be unique");
            isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]] = true;
        }

        navIssuanceSettings[_setToken] = _navIssuanceSettings;

        _setToken.initializeModule();
    }

    /**
     * Removes this module from the SetToken, via call by the SetToken. Issuance settings and
     * reserve asset states are deleted.
     */
    function removeModule() external override {
        ISetToken setToken = ISetToken(msg.sender);
        for (uint256 i = 0; i < navIssuanceSettings[setToken].reserveAssets.length; i++) {
            delete isReserveAsset[setToken][navIssuanceSettings[setToken].reserveAssets[i]];
        }

        delete navIssuanceSettings[setToken];
    }

    receive() external payable {}

    /* ============ External Getter Functions ============ */

    function getReserveAssets(ISetToken _setToken) external view returns (address[] memory) {
        return navIssuanceSettings[_setToken].reserveAssets;
    }

    function getIssuePremium(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (uint256)
    {
        return _getIssuePremium(_setToken, _reserveAsset, _reserveAssetQuantity);
    }

    function getRedeemPremium(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (uint256)
    {
        return _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);
    }

    function getManagerFee(ISetToken _setToken, uint256 _managerFeeIndex) external view returns (uint256) {
        return navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];
    }

    /**
     * Get the expected SetTokens minted to recipient on issuance
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     *
     * @return  uint256                     Expected SetTokens to be minted to recipient
     */
    function getExpectedSetTokenIssueQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (uint256)
    {
        (,, uint256 netReserveFlow) = _getFees(
            _setToken,
            _reserveAssetQuantity,
            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,
            MANAGER_ISSUE_FEE_INDEX
        );

        uint256 setTotalSupply = _setToken.totalSupply();

        return _getSetTokenMintQuantity(
            _setToken,
            _reserveAsset,
            netReserveFlow,
            setTotalSupply
        );
    }

    /**
     * Get the expected reserve asset to be redeemed
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     *
     * @return  uint256                     Expected reserve asset quantity redeemed
     */
    function getExpectedReserveRedeemQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (uint256)
    {
        uint256 preFeeReserveQuantity = _getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

        (,, uint256 netReserveFlows) = _getFees(
            _setToken,
            preFeeReserveQuantity,
            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
            MANAGER_REDEEM_FEE_INDEX
        );

        return netReserveFlows;
    }

    /**
     * Checks if issue is valid
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     *
     * @return  bool                        Returns true if issue is valid
     */
    function isIssueValid(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (bool)
    {
        uint256 setTotalSupply = _setToken.totalSupply();

    return _reserveAssetQuantity != 0
            && isReserveAsset[_setToken][_reserveAsset]
            && setTotalSupply >= navIssuanceSettings[_setToken].minSetTokenSupply;
    }

    /**
     * Checks if redeem is valid
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     *
     * @return  bool                        Returns true if redeem is valid
     */
    function isRedeemValid(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (bool)
    {
        uint256 setTotalSupply = _setToken.totalSupply();

        if (
            _setTokenQuantity == 0
            || !isReserveAsset[_setToken][_reserveAsset]
            || setTotalSupply < navIssuanceSettings[_setToken].minSetTokenSupply.add(_setTokenQuantity)
        ) {
            return false;
        } else {
            uint256 totalRedeemValue =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

            (,, uint256 expectedRedeemQuantity) = _getFees(
                _setToken,
                totalRedeemValue,
                PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
                PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
                MANAGER_REDEEM_FEE_INDEX
            );

            uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();

            return existingUnit.preciseMul(setTotalSupply) >= expectedRedeemQuantity;
        }
    }

    /* ============ Internal Functions ============ */

    function _validateCommon(ISetToken _setToken, address _reserveAsset, uint256 _quantity) internal view {
        require(_quantity > 0, "Quantity must be > 0");
        require(isReserveAsset[_setToken][_reserveAsset], "Must be valid reserve asset");
    }

    function _validateIssuanceInfo(ISetToken _setToken, uint256 _minSetTokenReceiveQuantity, ActionInfo memory _issueInfo) internal view {
        // Check that total supply is greater than min supply needed for issuance
        // Note: A min supply amount is needed to avoid division by 0 when SetToken supply is 0
        require(
            _issueInfo.previousSetTokenSupply >= navIssuanceSettings[_setToken].minSetTokenSupply,
            "Supply must be greater than minimum to enable issuance"
        );

        require(_issueInfo.setTokenQuantity >= _minSetTokenReceiveQuantity, "Must be greater than min SetToken");
    }

    function _validateRedemptionInfo(
        ISetToken _setToken,
        uint256 _minReserveReceiveQuantity,
        ActionInfo memory _redeemInfo
    )
        internal
        view
    {
        // Check that new supply is more than min supply needed for redemption
        // Note: A min supply amount is needed to avoid division by 0 when redeeming SetToken to 0
        require(
            _redeemInfo.newSetTokenSupply >= navIssuanceSettings[_setToken].minSetTokenSupply,
            "Supply must be greater than minimum to enable redemption"
        );

        require(_redeemInfo.netFlowQuantity >= _minReserveReceiveQuantity, "Must be greater than min receive reserve quantity");
    }

    function _createIssuanceInfo(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        internal
        view
        returns (ActionInfo memory)
    {
        ActionInfo memory issueInfo;

        issueInfo.previousSetTokenSupply = _setToken.totalSupply();

        issueInfo.preFeeReserveQuantity = _reserveAssetQuantity;

        (issueInfo.protocolFees, issueInfo.managerFee, issueInfo.netFlowQuantity) = _getFees(
            _setToken,
            issueInfo.preFeeReserveQuantity,
            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,
            MANAGER_ISSUE_FEE_INDEX
        );

        issueInfo.setTokenQuantity = _getSetTokenMintQuantity(
            _setToken,
            _reserveAsset,
            issueInfo.netFlowQuantity,
            issueInfo.previousSetTokenSupply
        );

        (issueInfo.newSetTokenSupply, issueInfo.newPositionMultiplier) = _getIssuePositionMultiplier(_setToken, issueInfo);

        issueInfo.newReservePositionUnit = _getIssuePositionUnit(_setToken, _reserveAsset, issueInfo);

        return issueInfo;
    }

    function _createRedemptionInfo(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        internal
        view
        returns (ActionInfo memory)
    {
        ActionInfo memory redeemInfo;

        redeemInfo.setTokenQuantity = _setTokenQuantity;

        redeemInfo.preFeeReserveQuantity =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

        (redeemInfo.protocolFees, redeemInfo.managerFee, redeemInfo.netFlowQuantity) = _getFees(
            _setToken,
            redeemInfo.preFeeReserveQuantity,
            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
            MANAGER_REDEEM_FEE_INDEX
        );

        redeemInfo.previousSetTokenSupply = _setToken.totalSupply();

        (redeemInfo.newSetTokenSupply, redeemInfo.newPositionMultiplier) = _getRedeemPositionMultiplier(_setToken, _setTokenQuantity, redeemInfo);

        redeemInfo.newReservePositionUnit = _getRedeemPositionUnit(_setToken, _reserveAsset, redeemInfo);

        return redeemInfo;
    }

    /**
     * Transfer reserve asset from user to SetToken and fees from user to appropriate fee recipients
     */
    function _transferCollateralAndHandleFees(ISetToken _setToken, IERC20 _reserveAsset, ActionInfo memory _issueInfo) internal {
        transferFrom(_reserveAsset, msg.sender, address(_setToken), _issueInfo.netFlowQuantity);

        if (_issueInfo.protocolFees > 0) {
            transferFrom(_reserveAsset, msg.sender, controller.feeRecipient(), _issueInfo.protocolFees);
        }

        if (_issueInfo.managerFee > 0) {
            transferFrom(_reserveAsset, msg.sender, navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);
        }
    }


    /**
      * Transfer WETH from module to SetToken and fees from module to appropriate fee recipients
     */
    function _transferWETHAndHandleFees(ISetToken _setToken, ActionInfo memory _issueInfo) internal {
        weth.transfer(address(_setToken), _issueInfo.netFlowQuantity);

        if (_issueInfo.protocolFees > 0) {
            weth.transfer(controller.feeRecipient(), _issueInfo.protocolFees);
        }

        if (_issueInfo.managerFee > 0) {
            weth.transfer(navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);
        }
    }

    function _handleIssueStateUpdates(
        ISetToken _setToken,
        address _reserveAsset,
        address _to,
        ActionInfo memory _issueInfo
    )
        internal
    {
        _setToken.editPositionMultiplier(_issueInfo.newPositionMultiplier);

        _setToken.editDefaultPosition(_reserveAsset, _issueInfo.newReservePositionUnit);

        _setToken.mint(_to, _issueInfo.setTokenQuantity);

        emit SetTokenNAVIssued(
            _setToken,
            msg.sender,
            _to,
            _reserveAsset,
            address(navIssuanceSettings[_setToken].managerIssuanceHook),
            _issueInfo.setTokenQuantity,
            _issueInfo.managerFee,
            _issueInfo.protocolFees
        );
    }

    function _handleRedeemStateUpdates(
        ISetToken _setToken,
        address _reserveAsset,
        address _to,
        ActionInfo memory _redeemInfo
    )
        internal
    {
        _setToken.editPositionMultiplier(_redeemInfo.newPositionMultiplier);

        _setToken.editDefaultPosition(_reserveAsset, _redeemInfo.newReservePositionUnit);

        emit SetTokenNAVRedeemed(
            _setToken,
            msg.sender,
            _to,
            _reserveAsset,
            address(navIssuanceSettings[_setToken].managerRedemptionHook),
            _redeemInfo.setTokenQuantity,
            _redeemInfo.managerFee,
            _redeemInfo.protocolFees
        );
    }

    function _handleRedemptionFees(ISetToken _setToken, address _reserveAsset, ActionInfo memory _redeemInfo) internal {
        // Instruct the SetToken to transfer protocol fee to fee recipient if there is a fee
        payProtocolFeeFromSetToken(_setToken, _reserveAsset, _redeemInfo.protocolFees);

        // Instruct the SetToken to transfer manager fee to manager fee recipient if there is a fee
        if (_redeemInfo.managerFee > 0) {
            _setToken.strictInvokeTransfer(
                _reserveAsset,
                navIssuanceSettings[_setToken].feeRecipient,
                _redeemInfo.managerFee
            );
        }
    }

    /**
     * Returns the issue premium percentage. Virtual function that can be overridden in future versions of the module
     * and can contain arbitrary logic to calculate the issuance premium.
     */
    function _getIssuePremium(
        ISetToken _setToken,
        address /* _reserveAsset */,
        uint256 /* _reserveAssetQuantity */
    )
        virtual
        internal
        view
        returns (uint256)
    {
        return navIssuanceSettings[_setToken].premiumPercentage;
    }

    /**
     * Returns the redeem premium percentage. Virtual function that can be overridden in future versions of the module
     * and can contain arbitrary logic to calculate the redemption premium.
     */
    function _getRedeemPremium(
        ISetToken _setToken,
        address /* _reserveAsset */,
        uint256 /* _setTokenQuantity */
    )
        virtual
        internal
        view
        returns (uint256)
    {
        return navIssuanceSettings[_setToken].premiumPercentage;
    }

    /**
     * Returns the fees attributed to the manager and the protocol. The fees are calculated as follows:
     *
     * ManagerFee = (manager fee % - % to protocol) * reserveAssetQuantity
     * Protocol Fee = (% manager fee share + direct fee %) * reserveAssetQuantity
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAssetQuantity         Quantity of reserve asset to calculate fees from
     * @param _protocolManagerFeeIndex      Index to pull rev share NAV Issuance fee from the Controller
     * @param _protocolDirectFeeIndex       Index to pull direct NAV issuance fee from the Controller
     * @param _managerFeeIndex              Index from NAVIssuanceSettings (0 = issue fee, 1 = redeem fee)
     *
     * @return  uint256                     Fees paid to the protocol in reserve asset
     * @return  uint256                     Fees paid to the manager in reserve asset
     * @return  uint256                     Net reserve to user net of fees
     */
    function _getFees(
        ISetToken _setToken,
        uint256 _reserveAssetQuantity,
        uint256 _protocolManagerFeeIndex,
        uint256 _protocolDirectFeeIndex,
        uint256 _managerFeeIndex
    )
        internal
        view
        returns (uint256, uint256, uint256)
    {
        (uint256 protocolFeePercentage, uint256 managerFeePercentage) = _getProtocolAndManagerFeePercentages(
            _setToken,
            _protocolManagerFeeIndex,
            _protocolDirectFeeIndex,
            _managerFeeIndex
        );

        // Calculate total notional fees
        uint256 protocolFees = protocolFeePercentage.preciseMul(_reserveAssetQuantity);
        uint256 managerFee = managerFeePercentage.preciseMul(_reserveAssetQuantity);

        uint256 netReserveFlow = _reserveAssetQuantity.sub(protocolFees).sub(managerFee);

        return (protocolFees, managerFee, netReserveFlow);
    }

    function _getProtocolAndManagerFeePercentages(
        ISetToken _setToken,
        uint256 _protocolManagerFeeIndex,
        uint256 _protocolDirectFeeIndex,
        uint256 _managerFeeIndex
    )
        internal
        view
        returns(uint256, uint256)
    {
        // Get protocol fee percentages
        uint256 protocolDirectFeePercent = controller.getModuleFee(address(this), _protocolDirectFeeIndex);
        uint256 protocolManagerShareFeePercent = controller.getModuleFee(address(this), _protocolManagerFeeIndex);
        uint256 managerFeePercent = navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];

        // Calculate revenue share split percentage
        uint256 protocolRevenueSharePercentage = protocolManagerShareFeePercent.preciseMul(managerFeePercent);
        uint256 managerRevenueSharePercentage = managerFeePercent.sub(protocolRevenueSharePercentage);
        uint256 totalProtocolFeePercentage = protocolRevenueSharePercentage.add(protocolDirectFeePercent);

        return (totalProtocolFeePercentage, managerRevenueSharePercentage);
    }

    function _getSetTokenMintQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _netReserveFlows,            // Value of reserve asset net of fees
        uint256 _setTotalSupply
    )
        internal
        view
        returns (uint256)
    {
        uint256 premiumPercentage = _getIssuePremium(_setToken, _reserveAsset, _netReserveFlows);
        uint256 premiumValue = _netReserveFlows.preciseMul(premiumPercentage);

        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (1e18)
        // Reverts if price is not found
        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);

        // Get reserve asset decimals
        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();
        uint256 normalizedTotalReserveQuantityNetFees = _netReserveFlows.preciseDiv(10 ** reserveAssetDecimals);
        uint256 normalizedTotalReserveQuantityNetFeesAndPremium = _netReserveFlows.sub(premiumValue).preciseDiv(10 ** reserveAssetDecimals);

        // Calculate SetTokens to mint to issuer
        uint256 denominator = _setTotalSupply.preciseMul(setTokenValuation).add(normalizedTotalReserveQuantityNetFees).sub(normalizedTotalReserveQuantityNetFeesAndPremium);
        return normalizedTotalReserveQuantityNetFeesAndPremium.preciseMul(_setTotalSupply).preciseDiv(denominator);
    }

    function _getRedeemReserveQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        internal
        view
        returns (uint256)
    {
        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (10e18)
        // Reverts if price is not found
        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);

        uint256 totalRedeemValueInPreciseUnits = _setTokenQuantity.preciseMul(setTokenValuation);
        // Get reserve asset decimals
        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();
        uint256 prePremiumReserveQuantity = totalRedeemValueInPreciseUnits.preciseMul(10 ** reserveAssetDecimals);

        uint256 premiumPercentage = _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);
        uint256 premiumQuantity = prePremiumReserveQuantity.preciseMulCeil(premiumPercentage);

        return prePremiumReserveQuantity.sub(premiumQuantity);
    }

    /**
     * The new position multiplier is calculated as follows:
     * inflationPercentage = (newSupply - oldSupply) / newSupply
     * newMultiplier = (1 - inflationPercentage) * positionMultiplier
     */
    function _getIssuePositionMultiplier(
        ISetToken _setToken,
        ActionInfo memory _issueInfo
    )
        internal
        view
        returns (uint256, int256)
    {
        // Calculate inflation and new position multiplier. Note: Round inflation up in order to round position multiplier down
        uint256 newTotalSupply = _issueInfo.setTokenQuantity.add(_issueInfo.previousSetTokenSupply);
        int256 newPositionMultiplier = _setToken.positionMultiplier()
            .mul(_issueInfo.previousSetTokenSupply.toInt256())
            .div(newTotalSupply.toInt256());

        return (newTotalSupply, newPositionMultiplier);
    }

    /**
     * Calculate deflation and new position multiplier. Note: Round deflation down in order to round position multiplier down
     *
     * The new position multiplier is calculated as follows:
     * deflationPercentage = (oldSupply - newSupply) / newSupply
     * newMultiplier = (1 + deflationPercentage) * positionMultiplier
     */
    function _getRedeemPositionMultiplier(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        ActionInfo memory _redeemInfo
    )
        internal
        view
        returns (uint256, int256)
    {
        uint256 newTotalSupply = _redeemInfo.previousSetTokenSupply.sub(_setTokenQuantity);
        int256 newPositionMultiplier = _setToken.positionMultiplier()
            .mul(_redeemInfo.previousSetTokenSupply.toInt256())
            .div(newTotalSupply.toInt256());

        return (newTotalSupply, newPositionMultiplier);
    }

    /**
     * The new position reserve asset unit is calculated as follows:
     * totalReserve = (oldUnit * oldSetTokenSupply) + reserveQuantity
     * newUnit = totalReserve / newSetTokenSupply
     */
    function _getIssuePositionUnit(
        ISetToken _setToken,
        address _reserveAsset,
        ActionInfo memory _issueInfo
    )
        internal
        view
        returns (uint256)
    {
        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();
        uint256 totalReserve = existingUnit
            .preciseMul(_issueInfo.previousSetTokenSupply)
            .add(_issueInfo.netFlowQuantity);

        return totalReserve.preciseDiv(_issueInfo.newSetTokenSupply);
    }

    /**
     * The new position reserve asset unit is calculated as follows:
     * totalReserve = (oldUnit * oldSetTokenSupply) - reserveQuantityToSendOut
     * newUnit = totalReserve / newSetTokenSupply
     */
    function _getRedeemPositionUnit(
        ISetToken _setToken,
        address _reserveAsset,
        ActionInfo memory _redeemInfo
    )
        internal
        view
        returns (uint256)
    {
        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();
        uint256 totalExistingUnits = existingUnit.preciseMul(_redeemInfo.previousSetTokenSupply);

        uint256 outflow = _redeemInfo.netFlowQuantity.add(_redeemInfo.protocolFees).add(_redeemInfo.managerFee);

        // Require withdrawable quantity is greater than existing collateral
        require(totalExistingUnits >= outflow, "Must be greater than total available collateral");

        return totalExistingUnits.sub(outflow).preciseDiv(_redeemInfo.newSetTokenSupply);
    }

    /**
     * If a pre-issue hook has been configured, call the external-protocol contract. Pre-issue hook logic
     * can contain arbitrary logic including validations, external function calls, etc.
     */
    function _callPreIssueHooks(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity,
        address _caller,
        address _to
    )
        internal
    {
        INAVIssuanceHook preIssueHook = navIssuanceSettings[_setToken].managerIssuanceHook;
        if (address(preIssueHook) != address(0)) {
            preIssueHook.invokePreIssueHook(_setToken, _reserveAsset, _reserveAssetQuantity, _caller, _to);
        }
    }

    /**
     * If a pre-redeem hook has been configured, call the external-protocol contract.
     */
    function _callPreRedeemHooks(ISetToken _setToken, uint256 _setQuantity, address _caller, address _to) internal {
        INAVIssuanceHook preRedeemHook = navIssuanceSettings[_setToken].managerRedemptionHook;
        if (address(preRedeemHook) != address(0)) {
            preRedeemHook.invokePreRedeemHook(_setToken, _setQuantity, _caller, _to);
        }
    }
}.]

Given the user's task and the brainstorming ideas provided:
Task: "/*
    Copyright 2020 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";
import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";
import { SignedSafeMath } from "@openzeppelin/contracts/math/SignedSafeMath.sol";

import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";
import { IController } from "../../interfaces/IController.sol";
import { INAVIssuanceHook } from "../../interfaces/INAVIssuanceHook.sol";
import { Invoke } from "../lib/Invoke.sol";
import { ISetToken } from "../../interfaces/ISetToken.sol";
import { IWETH } from "../../interfaces/external/IWETH.sol";
import { ModuleBase } from "../lib/ModuleBase.sol";
import { Position } from "../lib/Position.sol";
import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";
import { ResourceIdentifier } from "../lib/ResourceIdentifier.sol";


/**
 * @title NavIssuanceModule
 * @author Set Protocol
 *
 * Module that enables issuance and redemption with any valid ERC20 token or ETH if allowed by the manager. Sender receives
 * a proportional amount of SetTokens on issuance or ERC20 token on redemption based on the calculated net asset value using
 * oracle prices. Manager is able to enforce a premium / discount on issuance / redemption to avoid arbitrage and front
 * running when relying on oracle prices. Managers can charge a fee (denominated in reserve asset).
 */
contract NavIssuanceModule is ModuleBase, ReentrancyGuard {
    using AddressArrayUtils for address[];
    using Invoke for ISetToken;
    using Position for ISetToken;
    using PreciseUnitMath for uint256;
    using PreciseUnitMath for int256;
    using ResourceIdentifier for IController;
    using SafeMath for uint256;
    using SafeCast for int256;
    using SafeCast for uint256;
    using SignedSafeMath for int256;

    /* ============ Events ============ */

    event SetTokenNAVIssued(
        ISetToken indexed _setToken,
        address _issuer,
        address _to,
        address _reserveAsset,
        address _hookContract,
        uint256 _setTokenQuantity,
        uint256 _managerFee,
        uint256 _premium
    );

    event SetTokenNAVRedeemed(
        ISetToken indexed _setToken,
        address _redeemer,
        address _to,
        address _reserveAsset,
        address _hookContract,
        uint256 _setTokenQuantity,
        uint256 _managerFee,
        uint256 _premium
    );

    event ReserveAssetAdded(
        ISetToken indexed _setToken,
        address _newReserveAsset
    );

    event ReserveAssetRemoved(
        ISetToken indexed _setToken,
        address _removedReserveAsset
    );

    event PremiumEdited(
        ISetToken indexed _setToken,
        uint256 _newPremium
    );

    event ManagerFeeEdited(
        ISetToken indexed _setToken,
        uint256 _newManagerFee,
        uint256 _index
    );

    event FeeRecipientEdited(
        ISetToken indexed _setToken,
        address _feeRecipient
    );

    /* ============ Structs ============ */

    struct NAVIssuanceSettings {
        INAVIssuanceHook managerIssuanceHook;      // Issuance hook configurations
        INAVIssuanceHook managerRedemptionHook;    // Redemption hook configurations
        address[] reserveAssets;                       // Allowed reserve assets - Must have a price enabled with the price oracle
        address feeRecipient;                          // Manager fee recipient
        uint256[2] managerFees;                        // Manager fees. 0 index is issue and 1 index is redeem fee (0.01% = 1e14, 1% = 1e16)
        uint256 maxManagerFee;                         // Maximum fee manager is allowed to set for issue and redeem
        uint256 premiumPercentage;                     // Premium percentage (0.01% = 1e14, 1% = 1e16). This premium is a buffer around oracle
                                                       // prices paid by user to the SetToken, which prevents arbitrage and oracle front running
        uint256 maxPremiumPercentage;                  // Maximum premium percentage manager is allowed to set (configured by manager)
        uint256 minSetTokenSupply;                     // Minimum SetToken supply required for issuance and redemption
                                                       // to prevent dramatic inflationary changes to the SetToken's position multiplier
    }

    struct ActionInfo {
        uint256 preFeeReserveQuantity;                 // Reserve value before fees; During issuance, represents raw quantity
                                                       // During redeem, represents post-premium value
        uint256 protocolFees;                          // Total protocol fees (direct + manager revenue share)
        uint256 managerFee;                            // Total manager fee paid in reserve asset
        uint256 netFlowQuantity;                       // When issuing, quantity of reserve asset sent to SetToken
                                                       // When redeeming, quantity of reserve asset sent to redeemer
        uint256 setTokenQuantity;                      // When issuing, quantity of SetTokens minted to mintee
                                                       // When redeeming, quantity of SetToken redeemed
        uint256 previousSetTokenSupply;                // SetToken supply prior to issue/redeem action
        uint256 newSetTokenSupply;                     // SetToken supply after issue/redeem action
        int256 newPositionMultiplier;                  // SetToken position multiplier after issue/redeem
        uint256 newReservePositionUnit;                // SetToken reserve asset position unit after issue/redeem
    }

    /* ============ State Variables ============ */

    // Wrapped ETH address
    IWETH public immutable weth;

    // Mapping of SetToken to NAV issuance settings struct
    mapping(ISetToken => NAVIssuanceSettings) public navIssuanceSettings;

    // Mapping to efficiently check a SetToken's reserve asset validity
    // SetToken => reserveAsset => isReserveAsset
    mapping(ISetToken => mapping(address => bool)) public isReserveAsset;

    /* ============ Constants ============ */

    // 0 index stores the manager fee in managerFees array, percentage charged on issue (denominated in reserve asset)
    uint256 constant internal MANAGER_ISSUE_FEE_INDEX = 0;

    // 1 index stores the manager fee percentage in managerFees array, charged on redeem
    uint256 constant internal MANAGER_REDEEM_FEE_INDEX = 1;

    // 0 index stores the manager revenue share protocol fee % on the controller, charged in the issuance function
    uint256 constant internal PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX = 0;

    // 1 index stores the manager revenue share protocol fee % on the controller, charged in the redeem function
    uint256 constant internal PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX = 1;

    // 2 index stores the direct protocol fee % on the controller, charged in the issuance function
    uint256 constant internal PROTOCOL_ISSUE_DIRECT_FEE_INDEX = 2;

    // 3 index stores the direct protocol fee % on the controller, charged in the redeem function
    uint256 constant internal PROTOCOL_REDEEM_DIRECT_FEE_INDEX = 3;

    /* ============ Constructor ============ */

    /**
     * @param _controller               Address of controller contract
     * @param _weth                     Address of wrapped eth
     */
    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {
        weth = _weth;
    }

    /* ============ External Functions ============ */

    /**
     * Deposits the allowed reserve asset into the SetToken and mints the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _reserveAsset                 Address of the reserve asset to issue with
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance
     * @param _to                           Address to mint SetToken to
     */
    function issue(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity,
        uint256 _minSetTokenReceiveQuantity,
        address _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, _reserveAsset, _reserveAssetQuantity);

        _callPreIssueHooks(_setToken, _reserveAsset, _reserveAssetQuantity, msg.sender, _to);

        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, _reserveAsset, _reserveAssetQuantity);

        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);

        _transferCollateralAndHandleFees(_setToken, IERC20(_reserveAsset), issueInfo);

        _handleIssueStateUpdates(_setToken, _reserveAsset, _to, issueInfo);
    }

    /**
     * Wraps ETH and deposits WETH if allowed into the SetToken and mints the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance
     * @param _to                           Address to mint SetToken to
     */
    function issueWithEther(
        ISetToken _setToken,
        uint256 _minSetTokenReceiveQuantity,
        address _to
    )
        external
        payable
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        weth.deposit{ value: msg.value }();

        _validateCommon(_setToken, address(weth), msg.value);

        _callPreIssueHooks(_setToken, address(weth), msg.value, msg.sender, _to);

        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, address(weth), msg.value);

        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);

        _transferWETHAndHandleFees(_setToken, issueInfo);

        _handleIssueStateUpdates(_setToken, address(weth), _to, issueInfo);
    }

    /**
     * Redeems a SetToken into a valid reserve asset representing the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address. Only valid if there are available reserve units on the SetToken.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _reserveAsset                 Address of the reserve asset to redeem with
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive
     * @param _to                           Address to redeem reserve asset to
     */
    function redeem(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity,
        uint256 _minReserveReceiveQuantity,
        address _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, _reserveAsset, _setTokenQuantity);

        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);

        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, _reserveAsset, _setTokenQuantity);

        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);

        _setToken.burn(msg.sender, _setTokenQuantity);

        // Instruct the SetToken to transfer the reserve asset back to the user
        _setToken.strictInvokeTransfer(
            _reserveAsset,
            _to,
            redeemInfo.netFlowQuantity
        );

        _handleRedemptionFees(_setToken, _reserveAsset, redeemInfo);

        _handleRedeemStateUpdates(_setToken, _reserveAsset, _to, redeemInfo);
    }

    /**
     * Redeems a SetToken into Ether (if WETH is valid) representing the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address. Only valid if there are available WETH units on the SetToken.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive
     * @param _to                           Address to redeem reserve asset to
     */
    function redeemIntoEther(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        uint256 _minReserveReceiveQuantity,
        address payable _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, address(weth), _setTokenQuantity);

        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);

        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, address(weth), _setTokenQuantity);

        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);

        _setToken.burn(msg.sender, _setTokenQuantity);

        // Instruct the SetToken to transfer WETH from SetToken to module
        _setToken.strictInvokeTransfer(
            address(weth),
            address(this),
            redeemInfo.netFlowQuantity
        );

        weth.withdraw(redeemInfo.netFlowQuantity);

        _to.transfer(redeemInfo.netFlowQuantity);

        _handleRedemptionFees(_setToken, address(weth), redeemInfo);

        _handleRedeemStateUpdates(_setToken, address(weth), _to, redeemInfo);
    }

    /**
     * SET MANAGER ONLY. Add an allowed reserve asset
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset to add
     */
    function addReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {
        require(!isReserveAsset[_setToken][_reserveAsset], "Reserve asset already exists");

        navIssuanceSettings[_setToken].reserveAssets.push(_reserveAsset);
        isReserveAsset[_setToken][_reserveAsset] = true;

        emit ReserveAssetAdded(_setToken, _reserveAsset);
    }

    /**
     * SET MANAGER ONLY. Remove a reserve asset
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset to remove
     */
    function removeReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {
        require(isReserveAsset[_setToken][_reserveAsset], "Reserve asset does not exist");

        navIssuanceSettings[_setToken].reserveAssets = navIssuanceSettings[_setToken].reserveAssets.remove(_reserveAsset);
        delete isReserveAsset[_setToken][_reserveAsset];

        emit ReserveAssetRemoved(_setToken, _reserveAsset);
    }

    /**
     * SET MANAGER ONLY. Edit the premium percentage
     *
     * @param _setToken                     Instance of the SetToken
     * @param _premiumPercentage            Premium percentage in 10e16 (e.g. 10e16 = 1%)
     */
    function editPremium(ISetToken _setToken, uint256 _premiumPercentage) external onlyManagerAndValidSet(_setToken) {
        require(_premiumPercentage <= navIssuanceSettings[_setToken].maxPremiumPercentage, "Premium must be less than maximum allowed");

        navIssuanceSettings[_setToken].premiumPercentage = _premiumPercentage;

        emit PremiumEdited(_setToken, _premiumPercentage);
    }

    /**
     * SET MANAGER ONLY. Edit manager fee
     *
     * @param _setToken                     Instance of the SetToken
     * @param _managerFeePercentage         Manager fee percentage in 10e16 (e.g. 10e16 = 1%)
     * @param _managerFeeIndex              Manager fee index. 0 index is issue fee, 1 index is redeem fee
     */
    function editManagerFee(
        ISetToken _setToken,
        uint256 _managerFeePercentage,
        uint256 _managerFeeIndex
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        require(_managerFeePercentage <= navIssuanceSettings[_setToken].maxManagerFee, "Manager fee must be less than maximum allowed");

        navIssuanceSettings[_setToken].managerFees[_managerFeeIndex] = _managerFeePercentage;

        emit ManagerFeeEdited(_setToken, _managerFeePercentage, _managerFeeIndex);
    }

    /**
     * SET MANAGER ONLY. Edit the manager fee recipient
     *
     * @param _setToken                     Instance of the SetToken
     * @param _managerFeeRecipient          Manager fee recipient
     */
    function editFeeRecipient(ISetToken _setToken, address _managerFeeRecipient) external onlyManagerAndValidSet(_setToken) {
        require(_managerFeeRecipient != address(0), "Fee recipient must not be 0 address");

        navIssuanceSettings[_setToken].feeRecipient = _managerFeeRecipient;

        emit FeeRecipientEdited(_setToken, _managerFeeRecipient);
    }

    /**
     * SET MANAGER ONLY. Initializes this module to the SetToken with hooks, allowed reserve assets,
     * fees and issuance premium. Only callable by the SetToken's manager. Hook addresses are optional.
     * Address(0) means that no hook will be called.
     *
     * @param _setToken                     Instance of the SetToken to issue
     * @param _navIssuanceSettings          NAVIssuanceSettings struct defining parameters
     */
    function initialize(
        ISetToken _setToken,
        NAVIssuanceSettings memory _navIssuanceSettings
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        require(_navIssuanceSettings.reserveAssets.length > 0, "Reserve assets must be greater than 0");
        require(_navIssuanceSettings.maxManagerFee < PreciseUnitMath.preciseUnit(), "Max manager fee must be less than 100%");
        require(_navIssuanceSettings.maxPremiumPercentage < PreciseUnitMath.preciseUnit(), "Max premium percentage must be less than 100%");
        require(_navIssuanceSettings.managerFees[0] <= _navIssuanceSettings.maxManagerFee, "Manager issue fee must be less than max");
        require(_navIssuanceSettings.managerFees[1] <= _navIssuanceSettings.maxManagerFee, "Manager redeem fee must be less than max");
        require(_navIssuanceSettings.premiumPercentage <= _navIssuanceSettings.maxPremiumPercentage, "Premium must be less than max");
        require(_navIssuanceSettings.feeRecipient != address(0), "Fee Recipient must be non-zero address.");
        // Initial mint of Set cannot use NAVIssuance since minSetTokenSupply must be > 0
        require(_navIssuanceSettings.minSetTokenSupply > 0, "Min SetToken supply must be greater than 0");

        for (uint256 i = 0; i < _navIssuanceSettings.reserveAssets.length; i++) {
            require(!isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]], "Reserve assets must be unique");
            isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]] = true;
        }

        navIssuanceSettings[_setToken] = _navIssuanceSettings;

        _setToken.initializeModule();
    }

    /**
     * Removes this module from the SetToken, via call by the SetToken. Issuance settings and
     * reserve asset states are deleted.
     */
    function removeModule() external override {
        ISetToken setToken = ISetToken(msg.sender);
        for (uint256 i = 0; i < navIssuanceSettings[setToken].reserveAssets.length; i++) {
            delete isReserveAsset[setToken][navIssuanceSettings[setToken].reserveAssets[i]];
        }

        delete navIssuanceSettings[setToken];
    }

    receive() external payable {}

    /* ============ External Getter Functions ============ */

    function getReserveAssets(ISetToken _setToken) external view returns (address[] memory) {
        return navIssuanceSettings[_setToken].reserveAssets;
    }

    function getIssuePremium(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (uint256)
    {
        return _getIssuePremium(_setToken, _reserveAsset, _reserveAssetQuantity);
    }

    function getRedeemPremium(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (uint256)
    {
        return _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);
    }

    function getManagerFee(ISetToken _setToken, uint256 _managerFeeIndex) external view returns (uint256) {
        return navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];
    }

    /**
     * Get the expected SetTokens minted to recipient on issuance
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     *
     * @return  uint256                     Expected SetTokens to be minted to recipient
     */
    function getExpectedSetTokenIssueQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (uint256)
    {
        (,, uint256 netReserveFlow) = _getFees(
            _setToken,
            _reserveAssetQuantity,
            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,
            MANAGER_ISSUE_FEE_INDEX
        );

        uint256 setTotalSupply = _setToken.totalSupply();

        return _getSetTokenMintQuantity(
            _setToken,
            _reserveAsset,
            netReserveFlow,
            setTotalSupply
        );
    }

    /**
     * Get the expected reserve asset to be redeemed
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     *
     * @return  uint256                     Expected reserve asset quantity redeemed
     */
    function getExpectedReserveRedeemQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (uint256)
    {
        uint256 preFeeReserveQuantity = _getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

        (,, uint256 netReserveFlows) = _getFees(
            _setToken,
            preFeeReserveQuantity,
            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
            MANAGER_REDEEM_FEE_INDEX
        );

        return netReserveFlows;
    }

    /**
     * Checks if issue is valid
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     *
     * @return  bool                        Returns true if issue is valid
     */
    function isIssueValid(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (bool)
    {
        uint256 setTotalSupply = _setToken.totalSupply();

    return _reserveAssetQuantity != 0
            && isReserveAsset[_setToken][_reserveAsset]
            && setTotalSupply >= navIssuanceSettings[_setToken].minSetTokenSupply;
    }

    /**
     * Checks if redeem is valid
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     *
     * @return  bool                        Returns true if redeem is valid
     */
    function isRedeemValid(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (bool)
    {
        uint256 setTotalSupply = _setToken.totalSupply();

        if (
            _setTokenQuantity == 0
            || !isReserveAsset[_setToken][_reserveAsset]
            || setTotalSupply < navIssuanceSettings[_setToken].minSetTokenSupply.add(_setTokenQuantity)
        ) {
            return false;
        } else {
            uint256 totalRedeemValue =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

            (,, uint256 expectedRedeemQuantity) = _getFees(
                _setToken,
                totalRedeemValue,
                PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
                PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
                MANAGER_REDEEM_FEE_INDEX
            );

            uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();

            return existingUnit.preciseMul(setTotalSupply) >= expectedRedeemQuantity;
        }
    }

    /* ============ Internal Functions ============ */

    function _validateCommon(ISetToken _setToken, address _reserveAsset, uint256 _quantity) internal view {
        require(_quantity > 0, "Quantity must be > 0");
        require(isReserveAsset[_setToken][_reserveAsset], "Must be valid reserve asset");
    }

    function _validateIssuanceInfo(ISetToken _setToken, uint256 _minSetTokenReceiveQuantity, ActionInfo memory _issueInfo) internal view {
        // Check that total supply is greater than min supply needed for issuance
        // Note: A min supply amount is needed to avoid division by 0 when SetToken supply is 0
        require(
            _issueInfo.previousSetTokenSupply >= navIssuanceSettings[_setToken].minSetTokenSupply,
            "Supply must be greater than minimum to enable issuance"
        );

        require(_issueInfo.setTokenQuantity >= _minSetTokenReceiveQuantity, "Must be greater than min SetToken");
    }

    function _validateRedemptionInfo(
        ISetToken _setToken,
        uint256 _minReserveReceiveQuantity,
        ActionInfo memory _redeemInfo
    )
        internal
        view
    {
        // Check that new supply is more than min supply needed for redemption
        // Note: A min supply amount is needed to avoid division by 0 when redeeming SetToken to 0
        require(
            _redeemInfo.newSetTokenSupply >= navIssuanceSettings[_setToken].minSetTokenSupply,
            "Supply must be greater than minimum to enable redemption"
        );

        require(_redeemInfo.netFlowQuantity >= _minReserveReceiveQuantity, "Must be greater than min receive reserve quantity");
    }

    function _createIssuanceInfo(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        internal
        view
        returns (ActionInfo memory)
    {
        ActionInfo memory issueInfo;

        issueInfo.previousSetTokenSupply = _setToken.totalSupply();

        issueInfo.preFeeReserveQuantity = _reserveAssetQuantity;

        (issueInfo.protocolFees, issueInfo.managerFee, issueInfo.netFlowQuantity) = _getFees(
            _setToken,
            issueInfo.preFeeReserveQuantity,
            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,
            MANAGER_ISSUE_FEE_INDEX
        );

        issueInfo.setTokenQuantity = _getSetTokenMintQuantity(
            _setToken,
            _reserveAsset,
            issueInfo.netFlowQuantity,
            issueInfo.previousSetTokenSupply
        );

        (issueInfo.newSetTokenSupply, issueInfo.newPositionMultiplier) = _getIssuePositionMultiplier(_setToken, issueInfo);

        issueInfo.newReservePositionUnit = _getIssuePositionUnit(_setToken, _reserveAsset, issueInfo);

        return issueInfo;
    }

    function _createRedemptionInfo(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        internal
        view
        returns (ActionInfo memory)
    {
        ActionInfo memory redeemInfo;

        redeemInfo.setTokenQuantity = _setTokenQuantity;

        redeemInfo.preFeeReserveQuantity =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

        (redeemInfo.protocolFees, redeemInfo.managerFee, redeemInfo.netFlowQuantity) = _getFees(
            _setToken,
            redeemInfo.preFeeReserveQuantity,
            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
            MANAGER_REDEEM_FEE_INDEX
        );

        redeemInfo.previousSetTokenSupply = _setToken.totalSupply();

        (redeemInfo.newSetTokenSupply, redeemInfo.newPositionMultiplier) = _getRedeemPositionMultiplier(_setToken, _setTokenQuantity, redeemInfo);

        redeemInfo.newReservePositionUnit = _getRedeemPositionUnit(_setToken, _reserveAsset, redeemInfo);

        return redeemInfo;
    }

    /**
     * Transfer reserve asset from user to SetToken and fees from user to appropriate fee recipients
     */
    function _transferCollateralAndHandleFees(ISetToken _setToken, IERC20 _reserveAsset, ActionInfo memory _issueInfo) internal {
        transferFrom(_reserveAsset, msg.sender, address(_setToken), _issueInfo.netFlowQuantity);

        if (_issueInfo.protocolFees > 0) {
            transferFrom(_reserveAsset, msg.sender, controller.feeRecipient(), _issueInfo.protocolFees);
        }

        if (_issueInfo.managerFee > 0) {
            transferFrom(_reserveAsset, msg.sender, navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);
        }
    }


    /**
      * Transfer WETH from module to SetToken and fees from module to appropriate fee recipients
     */
    function _transferWETHAndHandleFees(ISetToken _setToken, ActionInfo memory _issueInfo) internal {
        weth.transfer(address(_setToken), _issueInfo.netFlowQuantity);

        if (_issueInfo.protocolFees > 0) {
            weth.transfer(controller.feeRecipient(), _issueInfo.protocolFees);
        }

        if (_issueInfo.managerFee > 0) {
            weth.transfer(navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);
        }
    }

    function _handleIssueStateUpdates(
        ISetToken _setToken,
        address _reserveAsset,
        address _to,
        ActionInfo memory _issueInfo
    )
        internal
    {
        _setToken.editPositionMultiplier(_issueInfo.newPositionMultiplier);

        _setToken.editDefaultPosition(_reserveAsset, _issueInfo.newReservePositionUnit);

        _setToken.mint(_to, _issueInfo.setTokenQuantity);

        emit SetTokenNAVIssued(
            _setToken,
            msg.sender,
            _to,
            _reserveAsset,
            address(navIssuanceSettings[_setToken].managerIssuanceHook),
            _issueInfo.setTokenQuantity,
            _issueInfo.managerFee,
            _issueInfo.protocolFees
        );
    }

    function _handleRedeemStateUpdates(
        ISetToken _setToken,
        address _reserveAsset,
        address _to,
        ActionInfo memory _redeemInfo
    )
        internal
    {
        _setToken.editPositionMultiplier(_redeemInfo.newPositionMultiplier);

        _setToken.editDefaultPosition(_reserveAsset, _redeemInfo.newReservePositionUnit);

        emit SetTokenNAVRedeemed(
            _setToken,
            msg.sender,
            _to,
            _reserveAsset,
            address(navIssuanceSettings[_setToken].managerRedemptionHook),
            _redeemInfo.setTokenQuantity,
            _redeemInfo.managerFee,
            _redeemInfo.protocolFees
        );
    }

    function _handleRedemptionFees(ISetToken _setToken, address _reserveAsset, ActionInfo memory _redeemInfo) internal {
        // Instruct the SetToken to transfer protocol fee to fee recipient if there is a fee
        payProtocolFeeFromSetToken(_setToken, _reserveAsset, _redeemInfo.protocolFees);

        // Instruct the SetToken to transfer manager fee to manager fee recipient if there is a fee
        if (_redeemInfo.managerFee > 0) {
            _setToken.strictInvokeTransfer(
                _reserveAsset,
                navIssuanceSettings[_setToken].feeRecipient,
                _redeemInfo.managerFee
            );
        }
    }

    /**
     * Returns the issue premium percentage. Virtual function that can be overridden in future versions of the module
     * and can contain arbitrary logic to calculate the issuance premium.
     */
    function _getIssuePremium(
        ISetToken _setToken,
        address /* _reserveAsset */,
        uint256 /* _reserveAssetQuantity */
    )
        virtual
        internal
        view
        returns (uint256)
    {
        return navIssuanceSettings[_setToken].premiumPercentage;
    }

    /**
     * Returns the redeem premium percentage. Virtual function that can be overridden in future versions of the module
     * and can contain arbitrary logic to calculate the redemption premium.
     */
    function _getRedeemPremium(
        ISetToken _setToken,
        address /* _reserveAsset */,
        uint256 /* _setTokenQuantity */
    )
        virtual
        internal
        view
        returns (uint256)
    {
        return navIssuanceSettings[_setToken].premiumPercentage;
    }

    /**
     * Returns the fees attributed to the manager and the protocol. The fees are calculated as follows:
     *
     * ManagerFee = (manager fee % - % to protocol) * reserveAssetQuantity
     * Protocol Fee = (% manager fee share + direct fee %) * reserveAssetQuantity
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAssetQuantity         Quantity of reserve asset to calculate fees from
     * @param _protocolManagerFeeIndex      Index to pull rev share NAV Issuance fee from the Controller
     * @param _protocolDirectFeeIndex       Index to pull direct NAV issuance fee from the Controller
     * @param _managerFeeIndex              Index from NAVIssuanceSettings (0 = issue fee, 1 = redeem fee)
     *
     * @return  uint256                     Fees paid to the protocol in reserve asset
     * @return  uint256                     Fees paid to the manager in reserve asset
     * @return  uint256                     Net reserve to user net of fees
     */
    function _getFees(
        ISetToken _setToken,
        uint256 _reserveAssetQuantity,
        uint256 _protocolManagerFeeIndex,
        uint256 _protocolDirectFeeIndex,
        uint256 _managerFeeIndex
    )
        internal
        view
        returns (uint256, uint256, uint256)
    {
        (uint256 protocolFeePercentage, uint256 managerFeePercentage) = _getProtocolAndManagerFeePercentages(
            _setToken,
            _protocolManagerFeeIndex,
            _protocolDirectFeeIndex,
            _managerFeeIndex
        );

        // Calculate total notional fees
        uint256 protocolFees = protocolFeePercentage.preciseMul(_reserveAssetQuantity);
        uint256 managerFee = managerFeePercentage.preciseMul(_reserveAssetQuantity);

        uint256 netReserveFlow = _reserveAssetQuantity.sub(protocolFees).sub(managerFee);

        return (protocolFees, managerFee, netReserveFlow);
    }

    function _getProtocolAndManagerFeePercentages(
        ISetToken _setToken,
        uint256 _protocolManagerFeeIndex,
        uint256 _protocolDirectFeeIndex,
        uint256 _managerFeeIndex
    )
        internal
        view
        returns(uint256, uint256)
    {
        // Get protocol fee percentages
        uint256 protocolDirectFeePercent = controller.getModuleFee(address(this), _protocolDirectFeeIndex);
        uint256 protocolManagerShareFeePercent = controller.getModuleFee(address(this), _protocolManagerFeeIndex);
        uint256 managerFeePercent = navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];

        // Calculate revenue share split percentage
        uint256 protocolRevenueSharePercentage = protocolManagerShareFeePercent.preciseMul(managerFeePercent);
        uint256 managerRevenueSharePercentage = managerFeePercent.sub(protocolRevenueSharePercentage);
        uint256 totalProtocolFeePercentage = protocolRevenueSharePercentage.add(protocolDirectFeePercent);

        return (totalProtocolFeePercentage, managerRevenueSharePercentage);
    }

    function _getSetTokenMintQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _netReserveFlows,            // Value of reserve asset net of fees
        uint256 _setTotalSupply
    )
        internal
        view
        returns (uint256)
    {
        uint256 premiumPercentage = _getIssuePremium(_setToken, _reserveAsset, _netReserveFlows);
        uint256 premiumValue = _netReserveFlows.preciseMul(premiumPercentage);

        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (1e18)
        // Reverts if price is not found
        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);

        // Get reserve asset decimals
        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();
        uint256 normalizedTotalReserveQuantityNetFees = _netReserveFlows.preciseDiv(10 ** reserveAssetDecimals);
        uint256 normalizedTotalReserveQuantityNetFeesAndPremium = _netReserveFlows.sub(premiumValue).preciseDiv(10 ** reserveAssetDecimals);

        // Calculate SetTokens to mint to issuer
        uint256 denominator = _setTotalSupply.preciseMul(setTokenValuation).add(normalizedTotalReserveQuantityNetFees).sub(normalizedTotalReserveQuantityNetFeesAndPremium);
        return normalizedTotalReserveQuantityNetFeesAndPremium.preciseMul(_setTotalSupply).preciseDiv(denominator);
    }

    function _getRedeemReserveQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        internal
        view
        returns (uint256)
    {
        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (10e18)
        // Reverts if price is not found
        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);

        uint256 totalRedeemValueInPreciseUnits = _setTokenQuantity.preciseMul(setTokenValuation);
        // Get reserve asset decimals
        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();
        uint256 prePremiumReserveQuantity = totalRedeemValueInPreciseUnits.preciseMul(10 ** reserveAssetDecimals);

        uint256 premiumPercentage = _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);
        uint256 premiumQuantity = prePremiumReserveQuantity.preciseMulCeil(premiumPercentage);

        return prePremiumReserveQuantity.sub(premiumQuantity);
    }

    /**
     * The new position multiplier is calculated as follows:
     * inflationPercentage = (newSupply - oldSupply) / newSupply
     * newMultiplier = (1 - inflationPercentage) * positionMultiplier
     */
    function _getIssuePositionMultiplier(
        ISetToken _setToken,
        ActionInfo memory _issueInfo
    )
        internal
        view
        returns (uint256, int256)
    {
        // Calculate inflation and new position multiplier. Note: Round inflation up in order to round position multiplier down
        uint256 newTotalSupply = _issueInfo.setTokenQuantity.add(_issueInfo.previousSetTokenSupply);
        int256 newPositionMultiplier = _setToken.positionMultiplier()
            .mul(_issueInfo.previousSetTokenSupply.toInt256())
            .div(newTotalSupply.toInt256());

        return (newTotalSupply, newPositionMultiplier);
    }

    /**
     * Calculate deflation and new position multiplier. Note: Round deflation down in order to round position multiplier down
     *
     * The new position multiplier is calculated as follows:
     * deflationPercentage = (oldSupply - newSupply) / newSupply
     * newMultiplier = (1 + deflationPercentage) * positionMultiplier
     */
    function _getRedeemPositionMultiplier(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        ActionInfo memory _redeemInfo
    )
        internal
        view
        returns (uint256, int256)
    {
        uint256 newTotalSupply = _redeemInfo.previousSetTokenSupply.sub(_setTokenQuantity);
        int256 newPositionMultiplier = _setToken.positionMultiplier()
            .mul(_redeemInfo.previousSetTokenSupply.toInt256())
            .div(newTotalSupply.toInt256());

        return (newTotalSupply, newPositionMultiplier);
    }

    /**
     * The new position reserve asset unit is calculated as follows:
     * totalReserve = (oldUnit * oldSetTokenSupply) + reserveQuantity
     * newUnit = totalReserve / newSetTokenSupply
     */
    function _getIssuePositionUnit(
        ISetToken _setToken,
        address _reserveAsset,
        ActionInfo memory _issueInfo
    )
        internal
        view
        returns (uint256)
    {
        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();
        uint256 totalReserve = existingUnit
            .preciseMul(_issueInfo.previousSetTokenSupply)
            .add(_issueInfo.netFlowQuantity);

        return totalReserve.preciseDiv(_issueInfo.newSetTokenSupply);
    }

    /**
     * The new position reserve asset unit is calculated as follows:
     * totalReserve = (oldUnit * oldSetTokenSupply) - reserveQuantityToSendOut
     * newUnit = totalReserve / newSetTokenSupply
     */
    function _getRedeemPositionUnit(
        ISetToken _setToken,
        address _reserveAsset,
        ActionInfo memory _redeemInfo
    )
        internal
        view
        returns (uint256)
    {
        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();
        uint256 totalExistingUnits = existingUnit.preciseMul(_redeemInfo.previousSetTokenSupply);

        uint256 outflow = _redeemInfo.netFlowQuantity.add(_redeemInfo.protocolFees).add(_redeemInfo.managerFee);

        // Require withdrawable quantity is greater than existing collateral
        require(totalExistingUnits >= outflow, "Must be greater than total available collateral");

        return totalExistingUnits.sub(outflow).preciseDiv(_redeemInfo.newSetTokenSupply);
    }

    /**
     * If a pre-issue hook has been configured, call the external-protocol contract. Pre-issue hook logic
     * can contain arbitrary logic including validations, external function calls, etc.
     */
    function _callPreIssueHooks(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity,
        address _caller,
        address _to
    )
        internal
    {
        INAVIssuanceHook preIssueHook = navIssuanceSettings[_setToken].managerIssuanceHook;
        if (address(preIssueHook) != address(0)) {
            preIssueHook.invokePreIssueHook(_setToken, _reserveAsset, _reserveAssetQuantity, _caller, _to);
        }
    }

    /**
     * If a pre-redeem hook has been configured, call the external-protocol contract.
     */
    function _callPreRedeemHooks(ISetToken _setToken, uint256 _setQuantity, address _caller, address _to) internal {
        INAVIssuanceHook preRedeemHook = navIssuanceSettings[_setToken].managerRedemptionHook;
        if (address(preRedeemHook) != address(0)) {
            preRedeemHook.invokePreRedeemHook(_setToken, _setQuantity, _caller, _to);
        }
    }
}".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-01-09 05:31:46 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 05:31:46 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 19903
completion_tokens: 1
total_tokens: 19904
cost: $-1.000000


[2024-01-09 05:31:46 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: /*
    Copyright 2020 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";
import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";
import { SignedSafeMath } from "@openzeppelin/contracts/math/SignedSafeMath.sol";

import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";
import { IController } from "../../interfaces/IController.sol";
import { INAVIssuanceHook } from "../../interfaces/INAVIssuanceHook.sol";
import { Invoke } from "../lib/Invoke.sol";
import { ISetToken } from "../../interfaces/ISetToken.sol";
import { IWETH } from "../../interfaces/external/IWETH.sol";
import { ModuleBase } from "../lib/ModuleBase.sol";
import { Position } from "../lib/Position.sol";
import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";
import { ResourceIdentifier } from "../lib/ResourceIdentifier.sol";


/**
 * @title NavIssuanceModule
 * @author Set Protocol
 *
 * Module that enables issuance and redemption with any valid ERC20 token or ETH if allowed by the manager. Sender receives
 * a proportional amount of SetTokens on issuance or ERC20 token on redemption based on the calculated net asset value using
 * oracle prices. Manager is able to enforce a premium / discount on issuance / redemption to avoid arbitrage and front
 * running when relying on oracle prices. Managers can charge a fee (denominated in reserve asset).
 */
contract NavIssuanceModule is ModuleBase, ReentrancyGuard {
    using AddressArrayUtils for address[];
    using Invoke for ISetToken;
    using Position for ISetToken;
    using PreciseUnitMath for uint256;
    using PreciseUnitMath for int256;
    using ResourceIdentifier for IController;
    using SafeMath for uint256;
    using SafeCast for int256;
    using SafeCast for uint256;
    using SignedSafeMath for int256;

    /* ============ Events ============ */

    event SetTokenNAVIssued(
        ISetToken indexed _setToken,
        address _issuer,
        address _to,
        address _reserveAsset,
        address _hookContract,
        uint256 _setTokenQuantity,
        uint256 _managerFee,
        uint256 _premium
    );

    event SetTokenNAVRedeemed(
        ISetToken indexed _setToken,
        address _redeemer,
        address _to,
        address _reserveAsset,
        address _hookContract,
        uint256 _setTokenQuantity,
        uint256 _managerFee,
        uint256 _premium
    );

    event ReserveAssetAdded(
        ISetToken indexed _setToken,
        address _newReserveAsset
    );

    event ReserveAssetRemoved(
        ISetToken indexed _setToken,
        address _removedReserveAsset
    );

    event PremiumEdited(
        ISetToken indexed _setToken,
        uint256 _newPremium
    );

    event ManagerFeeEdited(
        ISetToken indexed _setToken,
        uint256 _newManagerFee,
        uint256 _index
    );

    event FeeRecipientEdited(
        ISetToken indexed _setToken,
        address _feeRecipient
    );

    /* ============ Structs ============ */

    struct NAVIssuanceSettings {
        INAVIssuanceHook managerIssuanceHook;      // Issuance hook configurations
        INAVIssuanceHook managerRedemptionHook;    // Redemption hook configurations
        address[] reserveAssets;                       // Allowed reserve assets - Must have a price enabled with the price oracle
        address feeRecipient;                          // Manager fee recipient
        uint256[2] managerFees;                        // Manager fees. 0 index is issue and 1 index is redeem fee (0.01% = 1e14, 1% = 1e16)
        uint256 maxManagerFee;                         // Maximum fee manager is allowed to set for issue and redeem
        uint256 premiumPercentage;                     // Premium percentage (0.01% = 1e14, 1% = 1e16). This premium is a buffer around oracle
                                                       // prices paid by user to the SetToken, which prevents arbitrage and oracle front running
        uint256 maxPremiumPercentage;                  // Maximum premium percentage manager is allowed to set (configured by manager)
        uint256 minSetTokenSupply;                     // Minimum SetToken supply required for issuance and redemption
                                                       // to prevent dramatic inflationary changes to the SetToken's position multiplier
    }

    struct ActionInfo {
        uint256 preFeeReserveQuantity;                 // Reserve value before fees; During issuance, represents raw quantity
                                                       // During redeem, represents post-premium value
        uint256 protocolFees;                          // Total protocol fees (direct + manager revenue share)
        uint256 managerFee;                            // Total manager fee paid in reserve asset
        uint256 netFlowQuantity;                       // When issuing, quantity of reserve asset sent to SetToken
                                                       // When redeeming, quantity of reserve asset sent to redeemer
        uint256 setTokenQuantity;                      // When issuing, quantity of SetTokens minted to mintee
                                                       // When redeeming, quantity of SetToken redeemed
        uint256 previousSetTokenSupply;                // SetToken supply prior to issue/redeem action
        uint256 newSetTokenSupply;                     // SetToken supply after issue/redeem action
        int256 newPositionMultiplier;                  // SetToken position multiplier after issue/redeem
        uint256 newReservePositionUnit;                // SetToken reserve asset position unit after issue/redeem
    }

    /* ============ State Variables ============ */

    // Wrapped ETH address
    IWETH public immutable weth;

    // Mapping of SetToken to NAV issuance settings struct
    mapping(ISetToken => NAVIssuanceSettings) public navIssuanceSettings;

    // Mapping to efficiently check a SetToken's reserve asset validity
    // SetToken => reserveAsset => isReserveAsset
    mapping(ISetToken => mapping(address => bool)) public isReserveAsset;

    /* ============ Constants ============ */

    // 0 index stores the manager fee in managerFees array, percentage charged on issue (denominated in reserve asset)
    uint256 constant internal MANAGER_ISSUE_FEE_INDEX = 0;

    // 1 index stores the manager fee percentage in managerFees array, charged on redeem
    uint256 constant internal MANAGER_REDEEM_FEE_INDEX = 1;

    // 0 index stores the manager revenue share protocol fee % on the controller, charged in the issuance function
    uint256 constant internal PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX = 0;

    // 1 index stores the manager revenue share protocol fee % on the controller, charged in the redeem function
    uint256 constant internal PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX = 1;

    // 2 index stores the direct protocol fee % on the controller, charged in the issuance function
    uint256 constant internal PROTOCOL_ISSUE_DIRECT_FEE_INDEX = 2;

    // 3 index stores the direct protocol fee % on the controller, charged in the redeem function
    uint256 constant internal PROTOCOL_REDEEM_DIRECT_FEE_INDEX = 3;

    /* ============ Constructor ============ */

    /**
     * @param _controller               Address of controller contract
     * @param _weth                     Address of wrapped eth
     */
    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {
        weth = _weth;
    }

    /* ============ External Functions ============ */

    /**
     * Deposits the allowed reserve asset into the SetToken and mints the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _reserveAsset                 Address of the reserve asset to issue with
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance
     * @param _to                           Address to mint SetToken to
     */
    function issue(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity,
        uint256 _minSetTokenReceiveQuantity,
        address _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, _reserveAsset, _reserveAssetQuantity);

        _callPreIssueHooks(_setToken, _reserveAsset, _reserveAssetQuantity, msg.sender, _to);

        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, _reserveAsset, _reserveAssetQuantity);

        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);

        _transferCollateralAndHandleFees(_setToken, IERC20(_reserveAsset), issueInfo);

        _handleIssueStateUpdates(_setToken, _reserveAsset, _to, issueInfo);
    }

    /**
     * Wraps ETH and deposits WETH if allowed into the SetToken and mints the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance
     * @param _to                           Address to mint SetToken to
     */
    function issueWithEther(
        ISetToken _setToken,
        uint256 _minSetTokenReceiveQuantity,
        address _to
    )
        external
        payable
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        weth.deposit{ value: msg.value }();

        _validateCommon(_setToken, address(weth), msg.value);

        _callPreIssueHooks(_setToken, address(weth), msg.value, msg.sender, _to);

        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, address(weth), msg.value);

        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);

        _transferWETHAndHandleFees(_setToken, issueInfo);

        _handleIssueStateUpdates(_setToken, address(weth), _to, issueInfo);
    }

    /**
     * Redeems a SetToken into a valid reserve asset representing the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address. Only valid if there are available reserve units on the SetToken.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _reserveAsset                 Address of the reserve asset to redeem with
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive
     * @param _to                           Address to redeem reserve asset to
     */
    function redeem(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity,
        uint256 _minReserveReceiveQuantity,
        address _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, _reserveAsset, _setTokenQuantity);

        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);

        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, _reserveAsset, _setTokenQuantity);

        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);

        _setToken.burn(msg.sender, _setTokenQuantity);

        // Instruct the SetToken to transfer the reserve asset back to the user
        _setToken.strictInvokeTransfer(
            _reserveAsset,
            _to,
            redeemInfo.netFlowQuantity
        );

        _handleRedemptionFees(_setToken, _reserveAsset, redeemInfo);

        _handleRedeemStateUpdates(_setToken, _reserveAsset, _to, redeemInfo);
    }

    /**
     * Redeems a SetToken into Ether (if WETH is valid) representing the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address. Only valid if there are available WETH units on the SetToken.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive
     * @param _to                           Address to redeem reserve asset to
     */
    function redeemIntoEther(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        uint256 _minReserveReceiveQuantity,
        address payable _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, address(weth), _setTokenQuantity);

        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);

        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, address(weth), _setTokenQuantity);

        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);

        _setToken.burn(msg.sender, _setTokenQuantity);

        // Instruct the SetToken to transfer WETH from SetToken to module
        _setToken.strictInvokeTransfer(
            address(weth),
            address(this),
            redeemInfo.netFlowQuantity
        );

        weth.withdraw(redeemInfo.netFlowQuantity);

        _to.transfer(redeemInfo.netFlowQuantity);

        _handleRedemptionFees(_setToken, address(weth), redeemInfo);

        _handleRedeemStateUpdates(_setToken, address(weth), _to, redeemInfo);
    }

    /**
     * SET MANAGER ONLY. Add an allowed reserve asset
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset to add
     */
    function addReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {
        require(!isReserveAsset[_setToken][_reserveAsset], "Reserve asset already exists");

        navIssuanceSettings[_setToken].reserveAssets.push(_reserveAsset);
        isReserveAsset[_setToken][_reserveAsset] = true;

        emit ReserveAssetAdded(_setToken, _reserveAsset);
    }

    /**
     * SET MANAGER ONLY. Remove a reserve asset
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset to remove
     */
    function removeReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {
        require(isReserveAsset[_setToken][_reserveAsset], "Reserve asset does not exist");

        navIssuanceSettings[_setToken].reserveAssets = navIssuanceSettings[_setToken].reserveAssets.remove(_reserveAsset);
        delete isReserveAsset[_setToken][_reserveAsset];

        emit ReserveAssetRemoved(_setToken, _reserveAsset);
    }

    /**
     * SET MANAGER ONLY. Edit the premium percentage
     *
     * @param _setToken                     Instance of the SetToken
     * @param _premiumPercentage            Premium percentage in 10e16 (e.g. 10e16 = 1%)
     */
    function editPremium(ISetToken _setToken, uint256 _premiumPercentage) external onlyManagerAndValidSet(_setToken) {
        require(_premiumPercentage <= navIssuanceSettings[_setToken].maxPremiumPercentage, "Premium must be less than maximum allowed");

        navIssuanceSettings[_setToken].premiumPercentage = _premiumPercentage;

        emit PremiumEdited(_setToken, _premiumPercentage);
    }

    /**
     * SET MANAGER ONLY. Edit manager fee
     *
     * @param _setToken                     Instance of the SetToken
     * @param _managerFeePercentage         Manager fee percentage in 10e16 (e.g. 10e16 = 1%)
     * @param _managerFeeIndex              Manager fee index. 0 index is issue fee, 1 index is redeem fee
     */
    function editManagerFee(
        ISetToken _setToken,
        uint256 _managerFeePercentage,
        uint256 _managerFeeIndex
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        require(_managerFeePercentage <= navIssuanceSettings[_setToken].maxManagerFee, "Manager fee must be less than maximum allowed");

        navIssuanceSettings[_setToken].managerFees[_managerFeeIndex] = _managerFeePercentage;

        emit ManagerFeeEdited(_setToken, _managerFeePercentage, _managerFeeIndex);
    }

    /**
     * SET MANAGER ONLY. Edit the manager fee recipient
     *
     * @param _setToken                     Instance of the SetToken
     * @param _managerFeeRecipient          Manager fee recipient
     */
    function editFeeRecipient(ISetToken _setToken, address _managerFeeRecipient) external onlyManagerAndValidSet(_setToken) {
        require(_managerFeeRecipient != address(0), "Fee recipient must not be 0 address");

        navIssuanceSettings[_setToken].feeRecipient = _managerFeeRecipient;

        emit FeeRecipientEdited(_setToken, _managerFeeRecipient);
    }

    /**
     * SET MANAGER ONLY. Initializes this module to the SetToken with hooks, allowed reserve assets,
     * fees and issuance premium. Only callable by the SetToken's manager. Hook addresses are optional.
     * Address(0) means that no hook will be called.
     *
     * @param _setToken                     Instance of the SetToken to issue
     * @param _navIssuanceSettings          NAVIssuanceSettings struct defining parameters
     */
    function initialize(
        ISetToken _setToken,
        NAVIssuanceSettings memory _navIssuanceSettings
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        require(_navIssuanceSettings.reserveAssets.length > 0, "Reserve assets must be greater than 0");
        require(_navIssuanceSettings.maxManagerFee < PreciseUnitMath.preciseUnit(), "Max manager fee must be less than 100%");
        require(_navIssuanceSettings.maxPremiumPercentage < PreciseUnitMath.preciseUnit(), "Max premium percentage must be less than 100%");
        require(_navIssuanceSettings.managerFees[0] <= _navIssuanceSettings.maxManagerFee, "Manager issue fee must be less than max");
        require(_navIssuanceSettings.managerFees[1] <= _navIssuanceSettings.maxManagerFee, "Manager redeem fee must be less than max");
        require(_navIssuanceSettings.premiumPercentage <= _navIssuanceSettings.maxPremiumPercentage, "Premium must be less than max");
        require(_navIssuanceSettings.feeRecipient != address(0), "Fee Recipient must be non-zero address.");
        // Initial mint of Set cannot use NAVIssuance since minSetTokenSupply must be > 0
        require(_navIssuanceSettings.minSetTokenSupply > 0, "Min SetToken supply must be greater than 0");

        for (uint256 i = 0; i < _navIssuanceSettings.reserveAssets.length; i++) {
            require(!isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]], "Reserve assets must be unique");
            isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]] = true;
        }

        navIssuanceSettings[_setToken] = _navIssuanceSettings;

        _setToken.initializeModule();
    }

    /**
     * Removes this module from the SetToken, via call by the SetToken. Issuance settings and
     * reserve asset states are deleted.
     */
    function removeModule() external override {
        ISetToken setToken = ISetToken(msg.sender);
        for (uint256 i = 0; i < navIssuanceSettings[setToken].reserveAssets.length; i++) {
            delete isReserveAsset[setToken][navIssuanceSettings[setToken].reserveAssets[i]];
        }

        delete navIssuanceSettings[setToken];
    }

    receive() external payable {}

    /* ============ External Getter Functions ============ */

    function getReserveAssets(ISetToken _setToken) external view returns (address[] memory) {
        return navIssuanceSettings[_setToken].reserveAssets;
    }

    function getIssuePremium(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (uint256)
    {
        return _getIssuePremium(_setToken, _reserveAsset, _reserveAssetQuantity);
    }

    function getRedeemPremium(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (uint256)
    {
        return _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);
    }

    function getManagerFee(ISetToken _setToken, uint256 _managerFeeIndex) external view returns (uint256) {
        return navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];
    }

    /**
     * Get the expected SetTokens minted to recipient on issuance
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     *
     * @return  uint256                     Expected SetTokens to be minted to recipient
     */
    function getExpectedSetTokenIssueQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (uint256)
    {
        (,, uint256 netReserveFlow) = _getFees(
            _setToken,
            _reserveAssetQuantity,
            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,
            MANAGER_ISSUE_FEE_INDEX
        );

        uint256 setTotalSupply = _setToken.totalSupply();

        return _getSetTokenMintQuantity(
            _setToken,
            _reserveAsset,
            netReserveFlow,
            setTotalSupply
        );
    }

    /**
     * Get the expected reserve asset to be redeemed
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     *
     * @return  uint256                     Expected reserve asset quantity redeemed
     */
    function getExpectedReserveRedeemQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (uint256)
    {
        uint256 preFeeReserveQuantity = _getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

        (,, uint256 netReserveFlows) = _getFees(
            _setToken,
            preFeeReserveQuantity,
            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
            MANAGER_REDEEM_FEE_INDEX
        );

        return netReserveFlows;
    }

    /**
     * Checks if issue is valid
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     *
     * @return  bool                        Returns true if issue is valid
     */
    function isIssueValid(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (bool)
    {
        uint256 setTotalSupply = _setToken.totalSupply();

    return _reserveAssetQuantity != 0
            && isReserveAsset[_setToken][_reserveAsset]
            && setTotalSupply >= navIssuanceSettings[_setToken].minSetTokenSupply;
    }

    /**
     * Checks if redeem is valid
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     *
     * @return  bool                        Returns true if redeem is valid
     */
    function isRedeemValid(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (bool)
    {
        uint256 setTotalSupply = _setToken.totalSupply();

        if (
            _setTokenQuantity == 0
            || !isReserveAsset[_setToken][_reserveAsset]
            || setTotalSupply < navIssuanceSettings[_setToken].minSetTokenSupply.add(_setTokenQuantity)
        ) {
            return false;
        } else {
            uint256 totalRedeemValue =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

            (,, uint256 expectedRedeemQuantity) = _getFees(
                _setToken,
                totalRedeemValue,
                PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
                PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
                MANAGER_REDEEM_FEE_INDEX
            );

            uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();

            return existingUnit.preciseMul(setTotalSupply) >= expectedRedeemQuantity;
        }
    }

    /* ============ Internal Functions ============ */

    function _validateCommon(ISetToken _setToken, address _reserveAsset, uint256 _quantity) internal view {
        require(_quantity > 0, "Quantity must be > 0");
        require(isReserveAsset[_setToken][_reserveAsset], "Must be valid reserve asset");
    }

    function _validateIssuanceInfo(ISetToken _setToken, uint256 _minSetTokenReceiveQuantity, ActionInfo memory _issueInfo) internal view {
        // Check that total supply is greater than min supply needed for issuance
        // Note: A min supply amount is needed to avoid division by 0 when SetToken supply is 0
        require(
            _issueInfo.previousSetTokenSupply >= navIssuanceSettings[_setToken].minSetTokenSupply,
            "Supply must be greater than minimum to enable issuance"
        );

        require(_issueInfo.setTokenQuantity >= _minSetTokenReceiveQuantity, "Must be greater than min SetToken");
    }

    function _validateRedemptionInfo(
        ISetToken _setToken,
        uint256 _minReserveReceiveQuantity,
        ActionInfo memory _redeemInfo
    )
        internal
        view
    {
        // Check that new supply is more than min supply needed for redemption
        // Note: A min supply amount is needed to avoid division by 0 when redeeming SetToken to 0
        require(
            _redeemInfo.newSetTokenSupply >= navIssuanceSettings[_setToken].minSetTokenSupply,
            "Supply must be greater than minimum to enable redemption"
        );

        require(_redeemInfo.netFlowQuantity >= _minReserveReceiveQuantity, "Must be greater than min receive reserve quantity");
    }

    function _createIssuanceInfo(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        internal
        view
        returns (ActionInfo memory)
    {
        ActionInfo memory issueInfo;

        issueInfo.previousSetTokenSupply = _setToken.totalSupply();

        issueInfo.preFeeReserveQuantity = _reserveAssetQuantity;

        (issueInfo.protocolFees, issueInfo.managerFee, issueInfo.netFlowQuantity) = _getFees(
            _setToken,
            issueInfo.preFeeReserveQuantity,
            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,
            MANAGER_ISSUE_FEE_INDEX
        );

        issueInfo.setTokenQuantity = _getSetTokenMintQuantity(
            _setToken,
            _reserveAsset,
            issueInfo.netFlowQuantity,
            issueInfo.previousSetTokenSupply
        );

        (issueInfo.newSetTokenSupply, issueInfo.newPositionMultiplier) = _getIssuePositionMultiplier(_setToken, issueInfo);

        issueInfo.newReservePositionUnit = _getIssuePositionUnit(_setToken, _reserveAsset, issueInfo);

        return issueInfo;
    }

    function _createRedemptionInfo(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        internal
        view
        returns (ActionInfo memory)
    {
        ActionInfo memory redeemInfo;

        redeemInfo.setTokenQuantity = _setTokenQuantity;

        redeemInfo.preFeeReserveQuantity =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

        (redeemInfo.protocolFees, redeemInfo.managerFee, redeemInfo.netFlowQuantity) = _getFees(
            _setToken,
            redeemInfo.preFeeReserveQuantity,
            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
            MANAGER_REDEEM_FEE_INDEX
        );

        redeemInfo.previousSetTokenSupply = _setToken.totalSupply();

        (redeemInfo.newSetTokenSupply, redeemInfo.newPositionMultiplier) = _getRedeemPositionMultiplier(_setToken, _setTokenQuantity, redeemInfo);

        redeemInfo.newReservePositionUnit = _getRedeemPositionUnit(_setToken, _reserveAsset, redeemInfo);

        return redeemInfo;
    }

    /**
     * Transfer reserve asset from user to SetToken and fees from user to appropriate fee recipients
     */
    function _transferCollateralAndHandleFees(ISetToken _setToken, IERC20 _reserveAsset, ActionInfo memory _issueInfo) internal {
        transferFrom(_reserveAsset, msg.sender, address(_setToken), _issueInfo.netFlowQuantity);

        if (_issueInfo.protocolFees > 0) {
            transferFrom(_reserveAsset, msg.sender, controller.feeRecipient(), _issueInfo.protocolFees);
        }

        if (_issueInfo.managerFee > 0) {
            transferFrom(_reserveAsset, msg.sender, navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);
        }
    }


    /**
      * Transfer WETH from module to SetToken and fees from module to appropriate fee recipients
     */
    function _transferWETHAndHandleFees(ISetToken _setToken, ActionInfo memory _issueInfo) internal {
        weth.transfer(address(_setToken), _issueInfo.netFlowQuantity);

        if (_issueInfo.protocolFees > 0) {
            weth.transfer(controller.feeRecipient(), _issueInfo.protocolFees);
        }

        if (_issueInfo.managerFee > 0) {
            weth.transfer(navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);
        }
    }

    function _handleIssueStateUpdates(
        ISetToken _setToken,
        address _reserveAsset,
        address _to,
        ActionInfo memory _issueInfo
    )
        internal
    {
        _setToken.editPositionMultiplier(_issueInfo.newPositionMultiplier);

        _setToken.editDefaultPosition(_reserveAsset, _issueInfo.newReservePositionUnit);

        _setToken.mint(_to, _issueInfo.setTokenQuantity);

        emit SetTokenNAVIssued(
            _setToken,
            msg.sender,
            _to,
            _reserveAsset,
            address(navIssuanceSettings[_setToken].managerIssuanceHook),
            _issueInfo.setTokenQuantity,
            _issueInfo.managerFee,
            _issueInfo.protocolFees
        );
    }

    function _handleRedeemStateUpdates(
        ISetToken _setToken,
        address _reserveAsset,
        address _to,
        ActionInfo memory _redeemInfo
    )
        internal
    {
        _setToken.editPositionMultiplier(_redeemInfo.newPositionMultiplier);

        _setToken.editDefaultPosition(_reserveAsset, _redeemInfo.newReservePositionUnit);

        emit SetTokenNAVRedeemed(
            _setToken,
            msg.sender,
            _to,
            _reserveAsset,
            address(navIssuanceSettings[_setToken].managerRedemptionHook),
            _redeemInfo.setTokenQuantity,
            _redeemInfo.managerFee,
            _redeemInfo.protocolFees
        );
    }

    function _handleRedemptionFees(ISetToken _setToken, address _reserveAsset, ActionInfo memory _redeemInfo) internal {
        // Instruct the SetToken to transfer protocol fee to fee recipient if there is a fee
        payProtocolFeeFromSetToken(_setToken, _reserveAsset, _redeemInfo.protocolFees);

        // Instruct the SetToken to transfer manager fee to manager fee recipient if there is a fee
        if (_redeemInfo.managerFee > 0) {
            _setToken.strictInvokeTransfer(
                _reserveAsset,
                navIssuanceSettings[_setToken].feeRecipient,
                _redeemInfo.managerFee
            );
        }
    }

    /**
     * Returns the issue premium percentage. Virtual function that can be overridden in future versions of the module
     * and can contain arbitrary logic to calculate the issuance premium.
     */
    function _getIssuePremium(
        ISetToken _setToken,
        address /* _reserveAsset */,
        uint256 /* _reserveAssetQuantity */
    )
        virtual
        internal
        view
        returns (uint256)
    {
        return navIssuanceSettings[_setToken].premiumPercentage;
    }

    /**
     * Returns the redeem premium percentage. Virtual function that can be overridden in future versions of the module
     * and can contain arbitrary logic to calculate the redemption premium.
     */
    function _getRedeemPremium(
        ISetToken _setToken,
        address /* _reserveAsset */,
        uint256 /* _setTokenQuantity */
    )
        virtual
        internal
        view
        returns (uint256)
    {
        return navIssuanceSettings[_setToken].premiumPercentage;
    }

    /**
     * Returns the fees attributed to the manager and the protocol. The fees are calculated as follows:
     *
     * ManagerFee = (manager fee % - % to protocol) * reserveAssetQuantity
     * Protocol Fee = (% manager fee share + direct fee %) * reserveAssetQuantity
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAssetQuantity         Quantity of reserve asset to calculate fees from
     * @param _protocolManagerFeeIndex      Index to pull rev share NAV Issuance fee from the Controller
     * @param _protocolDirectFeeIndex       Index to pull direct NAV issuance fee from the Controller
     * @param _managerFeeIndex              Index from NAVIssuanceSettings (0 = issue fee, 1 = redeem fee)
     *
     * @return  uint256                     Fees paid to the protocol in reserve asset
     * @return  uint256                     Fees paid to the manager in reserve asset
     * @return  uint256                     Net reserve to user net of fees
     */
    function _getFees(
        ISetToken _setToken,
        uint256 _reserveAssetQuantity,
        uint256 _protocolManagerFeeIndex,
        uint256 _protocolDirectFeeIndex,
        uint256 _managerFeeIndex
    )
        internal
        view
        returns (uint256, uint256, uint256)
    {
        (uint256 protocolFeePercentage, uint256 managerFeePercentage) = _getProtocolAndManagerFeePercentages(
            _setToken,
            _protocolManagerFeeIndex,
            _protocolDirectFeeIndex,
            _managerFeeIndex
        );

        // Calculate total notional fees
        uint256 protocolFees = protocolFeePercentage.preciseMul(_reserveAssetQuantity);
        uint256 managerFee = managerFeePercentage.preciseMul(_reserveAssetQuantity);

        uint256 netReserveFlow = _reserveAssetQuantity.sub(protocolFees).sub(managerFee);

        return (protocolFees, managerFee, netReserveFlow);
    }

    function _getProtocolAndManagerFeePercentages(
        ISetToken _setToken,
        uint256 _protocolManagerFeeIndex,
        uint256 _protocolDirectFeeIndex,
        uint256 _managerFeeIndex
    )
        internal
        view
        returns(uint256, uint256)
    {
        // Get protocol fee percentages
        uint256 protocolDirectFeePercent = controller.getModuleFee(address(this), _protocolDirectFeeIndex);
        uint256 protocolManagerShareFeePercent = controller.getModuleFee(address(this), _protocolManagerFeeIndex);
        uint256 managerFeePercent = navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];

        // Calculate revenue share split percentage
        uint256 protocolRevenueSharePercentage = protocolManagerShareFeePercent.preciseMul(managerFeePercent);
        uint256 managerRevenueSharePercentage = managerFeePercent.sub(protocolRevenueSharePercentage);
        uint256 totalProtocolFeePercentage = protocolRevenueSharePercentage.add(protocolDirectFeePercent);

        return (totalProtocolFeePercentage, managerRevenueSharePercentage);
    }

    function _getSetTokenMintQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _netReserveFlows,            // Value of reserve asset net of fees
        uint256 _setTotalSupply
    )
        internal
        view
        returns (uint256)
    {
        uint256 premiumPercentage = _getIssuePremium(_setToken, _reserveAsset, _netReserveFlows);
        uint256 premiumValue = _netReserveFlows.preciseMul(premiumPercentage);

        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (1e18)
        // Reverts if price is not found
        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);

        // Get reserve asset decimals
        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();
        uint256 normalizedTotalReserveQuantityNetFees = _netReserveFlows.preciseDiv(10 ** reserveAssetDecimals);
        uint256 normalizedTotalReserveQuantityNetFeesAndPremium = _netReserveFlows.sub(premiumValue).preciseDiv(10 ** reserveAssetDecimals);

        // Calculate SetTokens to mint to issuer
        uint256 denominator = _setTotalSupply.preciseMul(setTokenValuation).add(normalizedTotalReserveQuantityNetFees).sub(normalizedTotalReserveQuantityNetFeesAndPremium);
        return normalizedTotalReserveQuantityNetFeesAndPremium.preciseMul(_setTotalSupply).preciseDiv(denominator);
    }

    function _getRedeemReserveQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        internal
        view
        returns (uint256)
    {
        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (10e18)
        // Reverts if price is not found
        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);

        uint256 totalRedeemValueInPreciseUnits = _setTokenQuantity.preciseMul(setTokenValuation);
        // Get reserve asset decimals
        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();
        uint256 prePremiumReserveQuantity = totalRedeemValueInPreciseUnits.preciseMul(10 ** reserveAssetDecimals);

        uint256 premiumPercentage = _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);
        uint256 premiumQuantity = prePremiumReserveQuantity.preciseMulCeil(premiumPercentage);

        return prePremiumReserveQuantity.sub(premiumQuantity);
    }

    /**
     * The new position multiplier is calculated as follows:
     * inflationPercentage = (newSupply - oldSupply) / newSupply
     * newMultiplier = (1 - inflationPercentage) * positionMultiplier
     */
    function _getIssuePositionMultiplier(
        ISetToken _setToken,
        ActionInfo memory _issueInfo
    )
        internal
        view
        returns (uint256, int256)
    {
        // Calculate inflation and new position multiplier. Note: Round inflation up in order to round position multiplier down
        uint256 newTotalSupply = _issueInfo.setTokenQuantity.add(_issueInfo.previousSetTokenSupply);
        int256 newPositionMultiplier = _setToken.positionMultiplier()
            .mul(_issueInfo.previousSetTokenSupply.toInt256())
            .div(newTotalSupply.toInt256());

        return (newTotalSupply, newPositionMultiplier);
    }

    /**
     * Calculate deflation and new position multiplier. Note: Round deflation down in order to round position multiplier down
     *
     * The new position multiplier is calculated as follows:
     * deflationPercentage = (oldSupply - newSupply) / newSupply
     * newMultiplier = (1 + deflationPercentage) * positionMultiplier
     */
    function _getRedeemPositionMultiplier(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        ActionInfo memory _redeemInfo
    )
        internal
        view
        returns (uint256, int256)
    {
        uint256 newTotalSupply = _redeemInfo.previousSetTokenSupply.sub(_setTokenQuantity);
        int256 newPositionMultiplier = _setToken.positionMultiplier()
            .mul(_redeemInfo.previousSetTokenSupply.toInt256())
            .div(newTotalSupply.toInt256());

        return (newTotalSupply, newPositionMultiplier);
    }

    /**
     * The new position reserve asset unit is calculated as follows:
     * totalReserve = (oldUnit * oldSetTokenSupply) + reserveQuantity
     * newUnit = totalReserve / newSetTokenSupply
     */
    function _getIssuePositionUnit(
        ISetToken _setToken,
        address _reserveAsset,
        ActionInfo memory _issueInfo
    )
        internal
        view
        returns (uint256)
    {
        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();
        uint256 totalReserve = existingUnit
            .preciseMul(_issueInfo.previousSetTokenSupply)
            .add(_issueInfo.netFlowQuantity);

        return totalReserve.preciseDiv(_issueInfo.newSetTokenSupply);
    }

    /**
     * The new position reserve asset unit is calculated as follows:
     * totalReserve = (oldUnit * oldSetTokenSupply) - reserveQuantityToSendOut
     * newUnit = totalReserve / newSetTokenSupply
     */
    function _getRedeemPositionUnit(
        ISetToken _setToken,
        address _reserveAsset,
        ActionInfo memory _redeemInfo
    )
        internal
        view
        returns (uint256)
    {
        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();
        uint256 totalExistingUnits = existingUnit.preciseMul(_redeemInfo.previousSetTokenSupply);

        uint256 outflow = _redeemInfo.netFlowQuantity.add(_redeemInfo.protocolFees).add(_redeemInfo.managerFee);

        // Require withdrawable quantity is greater than existing collateral
        require(totalExistingUnits >= outflow, "Must be greater than total available collateral");

        return totalExistingUnits.sub(outflow).preciseDiv(_redeemInfo.newSetTokenSupply);
    }

    /**
     * If a pre-issue hook has been configured, call the external-protocol contract. Pre-issue hook logic
     * can contain arbitrary logic including validations, external function calls, etc.
     */
    function _callPreIssueHooks(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity,
        address _caller,
        address _to
    )
        internal
    {
        INAVIssuanceHook preIssueHook = navIssuanceSettings[_setToken].managerIssuanceHook;
        if (address(preIssueHook) != address(0)) {
            preIssueHook.invokePreIssueHook(_setToken, _reserveAsset, _reserveAssetQuantity, _caller, _to);
        }
    }

    /**
     * If a pre-redeem hook has been configured, call the external-protocol contract.
     */
    function _callPreRedeemHooks(ISetToken _setToken, uint256 _setQuantity, address _caller, address _to) internal {
        INAVIssuanceHook preRedeemHook = navIssuanceSettings[_setToken].managerRedemptionHook;
        if (address(preRedeemHook) != address(0)) {
            preRedeemHook.invokePreRedeemHook(_setToken, _setQuantity, _caller, _to);
        }
    }
}.]

###

[2024-01-09 05:31:46 INFO] **[Seminar Conclusion]**:

 ###

[2024-01-09 05:31:46 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 3

[2024-01-09 05:31:46 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /*     Copyright 2020 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol"; import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol"; import { SignedSafeMath } from "@openzeppelin/contracts/math/SignedSafeMath.sol"; import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol"; import { IController } from "../../interfaces/IController.sol"; import { INAVIssuanceHook } from "../../interfaces/INAVIssuanceHook.sol"; import { Invoke } from "../lib/Invoke.sol"; import { ISetToken } from "../../interfaces/ISetToken.sol"; import { IWETH } from "../../interfaces/external/IWETH.sol"; import { ModuleBase } from "../lib/ModuleBase.sol"; import { Position } from "../lib/Position.sol"; import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol"; import { ResourceIdentifier } from "../lib/ResourceIdentifier.sol"; /*  * @title NavIssuanceModule  * @author Set Protocol  *  * Module that enables issuance and redemption with any valid ERC20 token or ETH if allowed by the manager. Sender receives  * a proportional amount of SetTokens on issuance or ERC20 token on redemption based on the calculated net asset value using  * oracle prices. Manager is able to enforce a premium / discount on issuance / redemption to avoid arbitrage and front  * running when relying on oracle prices. Managers can charge a fee (denominated in reserve asset).  / contract NavIssuanceModule is ModuleBase, ReentrancyGuard {     using AddressArrayUtils for address[];     using Invoke for ISetToken;     using Position for ISetToken;     using PreciseUnitMath for uint256;     using PreciseUnitMath for int256;     using ResourceIdentifier for IController;     using SafeMath for uint256;     using SafeCast for int256;     using SafeCast for uint256;     using SignedSafeMath for int256; /* ============ Events ============ */  event SetTokenNAVIssued(     ISetToken indexed _setToken,     address _issuer,     address _to,     address _reserveAsset,     address _hookContract,     uint256 _setTokenQuantity,     uint256 _managerFee,     uint256 _premium );  event SetTokenNAVRedeemed(     ISetToken indexed _setToken,     address _redeemer,     address _to,     address _reserveAsset,     address _hookContract,     uint256 _setTokenQuantity,     uint256 _managerFee,     uint256 _premium );  event ReserveAssetAdded(     ISetToken indexed _setToken,     address _newReserveAsset );  event ReserveAssetRemoved(     ISetToken indexed _setToken,     address _removedReserveAsset );  event PremiumEdited(     ISetToken indexed _setToken,     uint256 _newPremium );  event ManagerFeeEdited(     ISetToken indexed _setToken,     uint256 _newManagerFee,     uint256 _index );  event FeeRecipientEdited(     ISetToken indexed _setToken,     address _feeRecipient );  /* ============ Structs ============ */  struct NAVIssuanceSettings {     INAVIssuanceHook managerIssuanceHook;      // Issuance hook configurations     INAVIssuanceHook managerRedemptionHook;    // Redemption hook configurations     address[] reserveAssets;                       // Allowed reserve assets - Must have a price enabled with the price oracle     address feeRecipient;                          // Manager fee recipient     uint256[2] managerFees;                        // Manager fees. 0 index is issue and 1 index is redeem fee (0.01% = 1e14, 1% = 1e16)     uint256 maxManagerFee;                         // Maximum fee manager is allowed to set for issue and redeem     uint256 premiumPercentage;                     // Premium percentage (0.01% = 1e14, 1% = 1e16). This premium is a buffer around oracle                                                    // prices paid by user to the SetToken, which prevents arbitrage and oracle front running     uint256 maxPremiumPercentage;                  // Maximum premium percentage manager is allowed to set (configured by manager)     uint256 minSetTokenSupply;                     // Minimum SetToken supply required for issuance and redemption                                                    // to prevent dramatic inflationary changes to the SetToken's position multiplier }  struct ActionInfo {     uint256 preFeeReserveQuantity;                 // Reserve value before fees; During issuance, represents raw quantity                                                    // During redeem, represents post-premium value     uint256 protocolFees;                          // Total protocol fees (direct + manager revenue share)     uint256 managerFee;                            // Total manager fee paid in reserve asset     uint256 netFlowQuantity;                       // When issuing, quantity of reserve asset sent to SetToken                                                    // When redeeming, quantity of reserve asset sent to redeemer     uint256 setTokenQuantity;                      // When issuing, quantity of SetTokens minted to mintee                                                    // When redeeming, quantity of SetToken redeemed     uint256 previousSetTokenSupply;                // SetToken supply prior to issue/redeem action     uint256 newSetTokenSupply;                     // SetToken supply after issue/redeem action     int256 newPositionMultiplier;                  // SetToken position multiplier after issue/redeem     uint256 newReservePositionUnit;                // SetToken reserve asset position unit after issue/redeem }  /* ============ State Variables ============ */  // Wrapped ETH address IWETH public immutable weth;  // Mapping of SetToken to NAV issuance settings struct mapping(ISetToken =&gt; NAVIssuanceSettings) public navIssuanceSettings;  // Mapping to efficiently check a SetToken's reserve asset validity // SetToken =&gt; reserveAsset =&gt; isReserveAsset mapping(ISetToken =&gt; mapping(address =&gt; bool)) public isReserveAsset;  /* ============ Constants ============ */  // 0 index stores the manager fee in managerFees array, percentage charged on issue (denominated in reserve asset) uint256 constant internal MANAGER_ISSUE_FEE_INDEX = 0;  // 1 index stores the manager fee percentage in managerFees array, charged on redeem uint256 constant internal MANAGER_REDEEM_FEE_INDEX = 1;  // 0 index stores the manager revenue share protocol fee % on the controller, charged in the issuance function uint256 constant internal PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX = 0;  // 1 index stores the manager revenue share protocol fee % on the controller, charged in the redeem function uint256 constant internal PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX = 1;  // 2 index stores the direct protocol fee % on the controller, charged in the issuance function uint256 constant internal PROTOCOL_ISSUE_DIRECT_FEE_INDEX = 2;  // 3 index stores the direct protocol fee % on the controller, charged in the redeem function uint256 constant internal PROTOCOL_REDEEM_DIRECT_FEE_INDEX = 3;  /* ============ Constructor ============ */  /**  * @param _controller               Address of controller contract  * @param _weth                     Address of wrapped eth  */ constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {     weth = _weth; }  /* ============ External Functions ============ */  /**  * Deposits the allowed reserve asset into the SetToken and mints the appropriate % of Net Asset Value of the SetToken  * to the specified _to address.  *  * @param _setToken                     Instance of the SetToken contract  * @param _reserveAsset                 Address of the reserve asset to issue with  * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with  * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance  * @param _to                           Address to mint SetToken to  */ function issue(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity,     uint256 _minSetTokenReceiveQuantity,     address _to )     external     nonReentrant     onlyValidAndInitializedSet(_setToken) {     _validateCommon(_setToken, _reserveAsset, _reserveAssetQuantity);      _callPreIssueHooks(_setToken, _reserveAsset, _reserveAssetQuantity, msg.sender, _to);      ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, _reserveAsset, _reserveAssetQuantity);      _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);      _transferCollateralAndHandleFees(_setToken, IERC20(_reserveAsset), issueInfo);      _handleIssueStateUpdates(_setToken, _reserveAsset, _to, issueInfo); }  /**  * Wraps ETH and deposits WETH if allowed into the SetToken and mints the appropriate % of Net Asset Value of the SetToken  * to the specified _to address.  *  * @param _setToken                     Instance of the SetToken contract  * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance  * @param _to                           Address to mint SetToken to  */ function issueWithEther(     ISetToken _setToken,     uint256 _minSetTokenReceiveQuantity,     address _to )     external     payable     nonReentrant     onlyValidAndInitializedSet(_setToken) {     weth.deposit{ value: msg.value }();      _validateCommon(_setToken, address(weth), msg.value);      _callPreIssueHooks(_setToken, address(weth), msg.value, msg.sender, _to);      ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, address(weth), msg.value);      _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);      _transferWETHAndHandleFees(_setToken, issueInfo);      _handleIssueStateUpdates(_setToken, address(weth), _to, issueInfo); }  /**  * Redeems a SetToken into a valid reserve asset representing the appropriate % of Net Asset Value of the SetToken  * to the specified _to address. Only valid if there are available reserve units on the SetToken.  *  * @param _setToken                     Instance of the SetToken contract  * @param _reserveAsset                 Address of the reserve asset to redeem with  * @param _setTokenQuantity             Quantity of SetTokens to redeem  * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive  * @param _to                           Address to redeem reserve asset to  */ function redeem(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity,     uint256 _minReserveReceiveQuantity,     address _to )     external     nonReentrant     onlyValidAndInitializedSet(_setToken) {     _validateCommon(_setToken, _reserveAsset, _setTokenQuantity);      _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);      ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, _reserveAsset, _setTokenQuantity);      _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);      _setToken.burn(msg.sender, _setTokenQuantity);      // Instruct the SetToken to transfer the reserve asset back to the user     _setToken.strictInvokeTransfer(         _reserveAsset,         _to,         redeemInfo.netFlowQuantity     );      _handleRedemptionFees(_setToken, _reserveAsset, redeemInfo);      _handleRedeemStateUpdates(_setToken, _reserveAsset, _to, redeemInfo); }  /**  * Redeems a SetToken into Ether (if WETH is valid) representing the appropriate % of Net Asset Value of the SetToken  * to the specified _to address. Only valid if there are available WETH units on the SetToken.  *  * @param _setToken                     Instance of the SetToken contract  * @param _setTokenQuantity             Quantity of SetTokens to redeem  * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive  * @param _to                           Address to redeem reserve asset to  */ function redeemIntoEther(     ISetToken _setToken,     uint256 _setTokenQuantity,     uint256 _minReserveReceiveQuantity,     address payable _to )     external     nonReentrant     onlyValidAndInitializedSet(_setToken) {     _validateCommon(_setToken, address(weth), _setTokenQuantity);      _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);      ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, address(weth), _setTokenQuantity);      _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);      _setToken.burn(msg.sender, _setTokenQuantity);      // Instruct the SetToken to transfer WETH from SetToken to module     _setToken.strictInvokeTransfer(         address(weth),         address(this),         redeemInfo.netFlowQuantity     );      weth.withdraw(redeemInfo.netFlowQuantity);      _to.transfer(redeemInfo.netFlowQuantity);      _handleRedemptionFees(_setToken, address(weth), redeemInfo);      _handleRedeemStateUpdates(_setToken, address(weth), _to, redeemInfo); }  /**  * SET MANAGER ONLY. Add an allowed reserve asset  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset to add  */ function addReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {     require(!isReserveAsset[_setToken][_reserveAsset], "Reserve asset already exists");      navIssuanceSettings[_setToken].reserveAssets.push(_reserveAsset);     isReserveAsset[_setToken][_reserveAsset] = true;      emit ReserveAssetAdded(_setToken, _reserveAsset); }  /**  * SET MANAGER ONLY. Remove a reserve asset  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset to remove  */ function removeReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {     require(isReserveAsset[_setToken][_reserveAsset], "Reserve asset does not exist");      navIssuanceSettings[_setToken].reserveAssets = navIssuanceSettings[_setToken].reserveAssets.remove(_reserveAsset);     delete isReserveAsset[_setToken][_reserveAsset];      emit ReserveAssetRemoved(_setToken, _reserveAsset); }  /**  * SET MANAGER ONLY. Edit the premium percentage  *  * @param _setToken                     Instance of the SetToken  * @param _premiumPercentage            Premium percentage in 10e16 (e.g. 10e16 = 1%)  */ function editPremium(ISetToken _setToken, uint256 _premiumPercentage) external onlyManagerAndValidSet(_setToken) {     require(_premiumPercentage &lt;= navIssuanceSettings[_setToken].maxPremiumPercentage, "Premium must be less than maximum allowed");      navIssuanceSettings[_setToken].premiumPercentage = _premiumPercentage;      emit PremiumEdited(_setToken, _premiumPercentage); }  /**  * SET MANAGER ONLY. Edit manager fee  *  * @param _setToken                     Instance of the SetToken  * @param _managerFeePercentage         Manager fee percentage in 10e16 (e.g. 10e16 = 1%)  * @param _managerFeeIndex              Manager fee index. 0 index is issue fee, 1 index is redeem fee  */ function editManagerFee(     ISetToken _setToken,     uint256 _managerFeePercentage,     uint256 _managerFeeIndex )     external     onlyManagerAndValidSet(_setToken) {     require(_managerFeePercentage &lt;= navIssuanceSettings[_setToken].maxManagerFee, "Manager fee must be less than maximum allowed");      navIssuanceSettings[_setToken].managerFees[_managerFeeIndex] = _managerFeePercentage;      emit ManagerFeeEdited(_setToken, _managerFeePercentage, _managerFeeIndex); }  /**  * SET MANAGER ONLY. Edit the manager fee recipient  *  * @param _setToken                     Instance of the SetToken  * @param _managerFeeRecipient          Manager fee recipient  */ function editFeeRecipient(ISetToken _setToken, address _managerFeeRecipient) external onlyManagerAndValidSet(_setToken) {     require(_managerFeeRecipient != address(0), "Fee recipient must not be 0 address");      navIssuanceSettings[_setToken].feeRecipient = _managerFeeRecipient;      emit FeeRecipientEdited(_setToken, _managerFeeRecipient); }  /**  * SET MANAGER ONLY. Initializes this module to the SetToken with hooks, allowed reserve assets,  * fees and issuance premium. Only callable by the SetToken's manager. Hook addresses are optional.  * Address(0) means that no hook will be called.  *  * @param _setToken                     Instance of the SetToken to issue  * @param _navIssuanceSettings          NAVIssuanceSettings struct defining parameters  */ function initialize(     ISetToken _setToken,     NAVIssuanceSettings memory _navIssuanceSettings )     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     require(_navIssuanceSettings.reserveAssets.length &gt; 0, "Reserve assets must be greater than 0");     require(_navIssuanceSettings.maxManagerFee &lt; PreciseUnitMath.preciseUnit(), "Max manager fee must be less than 100%");     require(_navIssuanceSettings.maxPremiumPercentage &lt; PreciseUnitMath.preciseUnit(), "Max premium percentage must be less than 100%");     require(_navIssuanceSettings.managerFees[0] &lt;= _navIssuanceSettings.maxManagerFee, "Manager issue fee must be less than max");     require(_navIssuanceSettings.managerFees[1] &lt;= _navIssuanceSettings.maxManagerFee, "Manager redeem fee must be less than max");     require(_navIssuanceSettings.premiumPercentage &lt;= _navIssuanceSettings.maxPremiumPercentage, "Premium must be less than max");     require(_navIssuanceSettings.feeRecipient != address(0), "Fee Recipient must be non-zero address.");     // Initial mint of Set cannot use NAVIssuance since minSetTokenSupply must be &gt; 0     require(_navIssuanceSettings.minSetTokenSupply &gt; 0, "Min SetToken supply must be greater than 0");      for (uint256 i = 0; i &lt; _navIssuanceSettings.reserveAssets.length; i++) {         require(!isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]], "Reserve assets must be unique");         isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]] = true;     }      navIssuanceSettings[_setToken] = _navIssuanceSettings;      _setToken.initializeModule(); }  /**  * Removes this module from the SetToken, via call by the SetToken. Issuance settings and  * reserve asset states are deleted.  */ function removeModule() external override {     ISetToken setToken = ISetToken(msg.sender);     for (uint256 i = 0; i &lt; navIssuanceSettings[setToken].reserveAssets.length; i++) {         delete isReserveAsset[setToken][navIssuanceSettings[setToken].reserveAssets[i]];     }      delete navIssuanceSettings[setToken]; }  receive() external payable {}  /* ============ External Getter Functions ============ */  function getReserveAssets(ISetToken _setToken) external view returns (address[] memory) {     return navIssuanceSettings[_setToken].reserveAssets; }  function getIssuePremium(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     external     view     returns (uint256) {     return _getIssuePremium(_setToken, _reserveAsset, _reserveAssetQuantity); }  function getRedeemPremium(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     external     view     returns (uint256) {     return _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity); }  function getManagerFee(ISetToken _setToken, uint256 _managerFeeIndex) external view returns (uint256) {     return navIssuanceSettings[_setToken].managerFees[_managerFeeIndex]; }  /**  * Get the expected SetTokens minted to recipient on issuance  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with  *  * @return  uint256                     Expected SetTokens to be minted to recipient  */ function getExpectedSetTokenIssueQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     external     view     returns (uint256) {     (,, uint256 netReserveFlow) = _getFees(         _setToken,         _reserveAssetQuantity,         PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_ISSUE_DIRECT_FEE_INDEX,         MANAGER_ISSUE_FEE_INDEX     );      uint256 setTotalSupply = _setToken.totalSupply();      return _getSetTokenMintQuantity(         _setToken,         _reserveAsset,         netReserveFlow,         setTotalSupply     ); }  /**  * Get the expected reserve asset to be redeemed  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _setTokenQuantity             Quantity of SetTokens to redeem  *  * @return  uint256                     Expected reserve asset quantity redeemed  */ function getExpectedReserveRedeemQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     external     view     returns (uint256) {     uint256 preFeeReserveQuantity = _getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);      (,, uint256 netReserveFlows) = _getFees(         _setToken,         preFeeReserveQuantity,         PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_REDEEM_DIRECT_FEE_INDEX,         MANAGER_REDEEM_FEE_INDEX     );      return netReserveFlows; }  /**  * Checks if issue is valid  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with  *  * @return  bool                        Returns true if issue is valid  */ function isIssueValid(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     external     view     returns (bool) {     uint256 setTotalSupply = _setToken.totalSupply();  return _reserveAssetQuantity != 0         &amp;&amp; isReserveAsset[_setToken][_reserveAsset]         &amp;&amp; setTotalSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply; }  /**  * Checks if redeem is valid  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _setTokenQuantity             Quantity of SetTokens to redeem  *  * @return  bool                        Returns true if redeem is valid  */ function isRedeemValid(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     external     view     returns (bool) {     uint256 setTotalSupply = _setToken.totalSupply();      if (         _setTokenQuantity == 0         || !isReserveAsset[_setToken][_reserveAsset]         || setTotalSupply &lt; navIssuanceSettings[_setToken].minSetTokenSupply.add(_setTokenQuantity)     ) {         return false;     } else {         uint256 totalRedeemValue =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);          (,, uint256 expectedRedeemQuantity) = _getFees(             _setToken,             totalRedeemValue,             PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,             PROTOCOL_REDEEM_DIRECT_FEE_INDEX,             MANAGER_REDEEM_FEE_INDEX         );          uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();          return existingUnit.preciseMul(setTotalSupply) &gt;= expectedRedeemQuantity;     } }  /* ============ Internal Functions ============ */  function _validateCommon(ISetToken _setToken, address _reserveAsset, uint256 _quantity) internal view {     require(_quantity &gt; 0, "Quantity must be &gt; 0");     require(isReserveAsset[_setToken][_reserveAsset], "Must be valid reserve asset"); }  function _validateIssuanceInfo(ISetToken _setToken, uint256 _minSetTokenReceiveQuantity, ActionInfo memory _issueInfo) internal view {     // Check that total supply is greater than min supply needed for issuance     // Note: A min supply amount is needed to avoid division by 0 when SetToken supply is 0     require(         _issueInfo.previousSetTokenSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply,         "Supply must be greater than minimum to enable issuance"     );      require(_issueInfo.setTokenQuantity &gt;= _minSetTokenReceiveQuantity, "Must be greater than min SetToken"); }  function _validateRedemptionInfo(     ISetToken _setToken,     uint256 _minReserveReceiveQuantity,     ActionInfo memory _redeemInfo )     internal     view {     // Check that new supply is more than min supply needed for redemption     // Note: A min supply amount is needed to avoid division by 0 when redeeming SetToken to 0     require(         _redeemInfo.newSetTokenSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply,         "Supply must be greater than minimum to enable redemption"     );      require(_redeemInfo.netFlowQuantity &gt;= _minReserveReceiveQuantity, "Must be greater than min receive reserve quantity"); }  function _createIssuanceInfo(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     internal     view     returns (ActionInfo memory) {     ActionInfo memory issueInfo;      issueInfo.previousSetTokenSupply = _setToken.totalSupply();      issueInfo.preFeeReserveQuantity = _reserveAssetQuantity;      (issueInfo.protocolFees, issueInfo.managerFee, issueInfo.netFlowQuantity) = _getFees(         _setToken,         issueInfo.preFeeReserveQuantity,         PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_ISSUE_DIRECT_FEE_INDEX,         MANAGER_ISSUE_FEE_INDEX     );      issueInfo.setTokenQuantity = _getSetTokenMintQuantity(         _setToken,         _reserveAsset,         issueInfo.netFlowQuantity,         issueInfo.previousSetTokenSupply     );      (issueInfo.newSetTokenSupply, issueInfo.newPositionMultiplier) = _getIssuePositionMultiplier(_setToken, issueInfo);      issueInfo.newReservePositionUnit = _getIssuePositionUnit(_setToken, _reserveAsset, issueInfo);      return issueInfo; }  function _createRedemptionInfo(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     internal     view     returns (ActionInfo memory) {     ActionInfo memory redeemInfo;      redeemInfo.setTokenQuantity = _setTokenQuantity;      redeemInfo.preFeeReserveQuantity =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);      (redeemInfo.protocolFees, redeemInfo.managerFee, redeemInfo.netFlowQuantity) = _getFees(         _setToken,         redeemInfo.preFeeReserveQuantity,         PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_REDEEM_DIRECT_FEE_INDEX,         MANAGER_REDEEM_FEE_INDEX     );      redeemInfo.previousSetTokenSupply = _setToken.totalSupply();      (redeemInfo.newSetTokenSupply, redeemInfo.newPositionMultiplier) = _getRedeemPositionMultiplier(_setToken, _setTokenQuantity, redeemInfo);      redeemInfo.newReservePositionUnit = _getRedeemPositionUnit(_setToken, _reserveAsset, redeemInfo);      return redeemInfo; }  /**  * Transfer reserve asset from user to SetToken and fees from user to appropriate fee recipients  */ function _transferCollateralAndHandleFees(ISetToken _setToken, IERC20 _reserveAsset, ActionInfo memory _issueInfo) internal {     transferFrom(_reserveAsset, msg.sender, address(_setToken), _issueInfo.netFlowQuantity);      if (_issueInfo.protocolFees &gt; 0) {         transferFrom(_reserveAsset, msg.sender, controller.feeRecipient(), _issueInfo.protocolFees);     }      if (_issueInfo.managerFee &gt; 0) {         transferFrom(_reserveAsset, msg.sender, navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);     } }   /**   * Transfer WETH from module to SetToken and fees from module to appropriate fee recipients  */ function _transferWETHAndHandleFees(ISetToken _setToken, ActionInfo memory _issueInfo) internal {     weth.transfer(address(_setToken), _issueInfo.netFlowQuantity);      if (_issueInfo.protocolFees &gt; 0) {         weth.transfer(controller.feeRecipient(), _issueInfo.protocolFees);     }      if (_issueInfo.managerFee &gt; 0) {         weth.transfer(navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);     } }  function _handleIssueStateUpdates(     ISetToken _setToken,     address _reserveAsset,     address _to,     ActionInfo memory _issueInfo )     internal {     _setToken.editPositionMultiplier(_issueInfo.newPositionMultiplier);      _setToken.editDefaultPosition(_reserveAsset, _issueInfo.newReservePositionUnit);      _setToken.mint(_to, _issueInfo.setTokenQuantity);      emit SetTokenNAVIssued(         _setToken,         msg.sender,         _to,         _reserveAsset,         address(navIssuanceSettings[_setToken].managerIssuanceHook),         _issueInfo.setTokenQuantity,         _issueInfo.managerFee,         _issueInfo.protocolFees     ); }  function _handleRedeemStateUpdates(     ISetToken _setToken,     address _reserveAsset,     address _to,     ActionInfo memory _redeemInfo )     internal {     _setToken.editPositionMultiplier(_redeemInfo.newPositionMultiplier);      _setToken.editDefaultPosition(_reserveAsset, _redeemInfo.newReservePositionUnit);      emit SetTokenNAVRedeemed(         _setToken,         msg.sender,         _to,         _reserveAsset,         address(navIssuanceSettings[_setToken].managerRedemptionHook),         _redeemInfo.setTokenQuantity,         _redeemInfo.managerFee,         _redeemInfo.protocolFees     ); }  function _handleRedemptionFees(ISetToken _setToken, address _reserveAsset, ActionInfo memory _redeemInfo) internal {     // Instruct the SetToken to transfer protocol fee to fee recipient if there is a fee     payProtocolFeeFromSetToken(_setToken, _reserveAsset, _redeemInfo.protocolFees);      // Instruct the SetToken to transfer manager fee to manager fee recipient if there is a fee     if (_redeemInfo.managerFee &gt; 0) {         _setToken.strictInvokeTransfer(             _reserveAsset,             navIssuanceSettings[_setToken].feeRecipient,             _redeemInfo.managerFee         );     } }  /**  * Returns the issue premium percentage. Virtual function that can be overridden in future versions of the module  * and can contain arbitrary logic to calculate the issuance premium.  */ function _getIssuePremium(     ISetToken _setToken,     address /* _reserveAsset */,     uint256 /* _reserveAssetQuantity */ )     virtual     internal     view     returns (uint256) {     return navIssuanceSettings[_setToken].premiumPercentage; }  /**  * Returns the redeem premium percentage. Virtual function that can be overridden in future versions of the module  * and can contain arbitrary logic to calculate the redemption premium.  */ function _getRedeemPremium(     ISetToken _setToken,     address /* _reserveAsset */,     uint256 /* _setTokenQuantity */ )     virtual     internal     view     returns (uint256) {     return navIssuanceSettings[_setToken].premiumPercentage; }  /**  * Returns the fees attributed to the manager and the protocol. The fees are calculated as follows:  *  * ManagerFee = (manager fee % - % to protocol) * reserveAssetQuantity  * Protocol Fee = (% manager fee share + direct fee %) * reserveAssetQuantity  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAssetQuantity         Quantity of reserve asset to calculate fees from  * @param _protocolManagerFeeIndex      Index to pull rev share NAV Issuance fee from the Controller  * @param _protocolDirectFeeIndex       Index to pull direct NAV issuance fee from the Controller  * @param _managerFeeIndex              Index from NAVIssuanceSettings (0 = issue fee, 1 = redeem fee)  *  * @return  uint256                     Fees paid to the protocol in reserve asset  * @return  uint256                     Fees paid to the manager in reserve asset  * @return  uint256                     Net reserve to user net of fees  */ function _getFees(     ISetToken _setToken,     uint256 _reserveAssetQuantity,     uint256 _protocolManagerFeeIndex,     uint256 _protocolDirectFeeIndex,     uint256 _managerFeeIndex )     internal     view     returns (uint256, uint256, uint256) {     (uint256 protocolFeePercentage, uint256 managerFeePercentage) = _getProtocolAndManagerFeePercentages(         _setToken,         _protocolManagerFeeIndex,         _protocolDirectFeeIndex,         _managerFeeIndex     );      // Calculate total notional fees     uint256 protocolFees = protocolFeePercentage.preciseMul(_reserveAssetQuantity);     uint256 managerFee = managerFeePercentage.preciseMul(_reserveAssetQuantity);      uint256 netReserveFlow = _reserveAssetQuantity.sub(protocolFees).sub(managerFee);      return (protocolFees, managerFee, netReserveFlow); }  function _getProtocolAndManagerFeePercentages(     ISetToken _setToken,     uint256 _protocolManagerFeeIndex,     uint256 _protocolDirectFeeIndex,     uint256 _managerFeeIndex )     internal     view     returns(uint256, uint256) {     // Get protocol fee percentages     uint256 protocolDirectFeePercent = controller.getModuleFee(address(this), _protocolDirectFeeIndex);     uint256 protocolManagerShareFeePercent = controller.getModuleFee(address(this), _protocolManagerFeeIndex);     uint256 managerFeePercent = navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];      // Calculate revenue share split percentage     uint256 protocolRevenueSharePercentage = protocolManagerShareFeePercent.preciseMul(managerFeePercent);     uint256 managerRevenueSharePercentage = managerFeePercent.sub(protocolRevenueSharePercentage);     uint256 totalProtocolFeePercentage = protocolRevenueSharePercentage.add(protocolDirectFeePercent);      return (totalProtocolFeePercentage, managerRevenueSharePercentage); }  function _getSetTokenMintQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _netReserveFlows,            // Value of reserve asset net of fees     uint256 _setTotalSupply )     internal     view     returns (uint256) {     uint256 premiumPercentage = _getIssuePremium(_setToken, _reserveAsset, _netReserveFlows);     uint256 premiumValue = _netReserveFlows.preciseMul(premiumPercentage);      // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (1e18)     // Reverts if price is not found     uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);      // Get reserve asset decimals     uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();     uint256 normalizedTotalReserveQuantityNetFees = _netReserveFlows.preciseDiv(10 ** reserveAssetDecimals);     uint256 normalizedTotalReserveQuantityNetFeesAndPremium = _netReserveFlows.sub(premiumValue).preciseDiv(10 ** reserveAssetDecimals);      // Calculate SetTokens to mint to issuer     uint256 denominator = _setTotalSupply.preciseMul(setTokenValuation).add(normalizedTotalReserveQuantityNetFees).sub(normalizedTotalReserveQuantityNetFeesAndPremium);     return normalizedTotalReserveQuantityNetFeesAndPremium.preciseMul(_setTotalSupply).preciseDiv(denominator); }  function _getRedeemReserveQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     internal     view     returns (uint256) {     // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (10e18)     // Reverts if price is not found     uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);      uint256 totalRedeemValueInPreciseUnits = _setTokenQuantity.preciseMul(setTokenValuation);     // Get reserve asset decimals     uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();     uint256 prePremiumReserveQuantity = totalRedeemValueInPreciseUnits.preciseMul(10 ** reserveAssetDecimals);      uint256 premiumPercentage = _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);     uint256 premiumQuantity = prePremiumReserveQuantity.preciseMulCeil(premiumPercentage);      return prePremiumReserveQuantity.sub(premiumQuantity); }  /**  * The new position multiplier is calculated as follows:  * inflationPercentage = (newSupply - oldSupply) / newSupply  * newMultiplier = (1 - inflationPercentage) * positionMultiplier  */ function _getIssuePositionMultiplier(     ISetToken _setToken,     ActionInfo memory _issueInfo )     internal     view     returns (uint256, int256) {     // Calculate inflation and new position multiplier. Note: Round inflation up in order to round position multiplier down     uint256 newTotalSupply = _issueInfo.setTokenQuantity.add(_issueInfo.previousSetTokenSupply);     int256 newPositionMultiplier = _setToken.positionMultiplier()         .mul(_issueInfo.previousSetTokenSupply.toInt256())         .div(newTotalSupply.toInt256());      return (newTotalSupply, newPositionMultiplier); }  /**  * Calculate deflation and new position multiplier. Note: Round deflation down in order to round position multiplier down  *  * The new position multiplier is calculated as follows:  * deflationPercentage = (oldSupply - newSupply) / newSupply  * newMultiplier = (1 + deflationPercentage) * positionMultiplier  */ function _getRedeemPositionMultiplier(     ISetToken _setToken,     uint256 _setTokenQuantity,     ActionInfo memory _redeemInfo )     internal     view     returns (uint256, int256) {     uint256 newTotalSupply = _redeemInfo.previousSetTokenSupply.sub(_setTokenQuantity);     int256 newPositionMultiplier = _setToken.positionMultiplier()         .mul(_redeemInfo.previousSetTokenSupply.toInt256())         .div(newTotalSupply.toInt256());      return (newTotalSupply, newPositionMultiplier); }  /**  * The new position reserve asset unit is calculated as follows:  * totalReserve = (oldUnit * oldSetTokenSupply) + reserveQuantity  * newUnit = totalReserve / newSetTokenSupply  */ function _getIssuePositionUnit(     ISetToken _setToken,     address _reserveAsset,     ActionInfo memory _issueInfo )     internal     view     returns (uint256) {     uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();     uint256 totalReserve = existingUnit         .preciseMul(_issueInfo.previousSetTokenSupply)         .add(_issueInfo.netFlowQuantity);      return totalReserve.preciseDiv(_issueInfo.newSetTokenSupply); }  /**  * The new position reserve asset unit is calculated as follows:  * totalReserve = (oldUnit * oldSetTokenSupply) - reserveQuantityToSendOut  * newUnit = totalReserve / newSetTokenSupply  */ function _getRedeemPositionUnit(     ISetToken _setToken,     address _reserveAsset,     ActionInfo memory _redeemInfo )     internal     view     returns (uint256) {     uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();     uint256 totalExistingUnits = existingUnit.preciseMul(_redeemInfo.previousSetTokenSupply);      uint256 outflow = _redeemInfo.netFlowQuantity.add(_redeemInfo.protocolFees).add(_redeemInfo.managerFee);      // Require withdrawable quantity is greater than existing collateral     require(totalExistingUnits &gt;= outflow, "Must be greater than total available collateral");      return totalExistingUnits.sub(outflow).preciseDiv(_redeemInfo.newSetTokenSupply); }  /**  * If a pre-issue hook has been configured, call the external-protocol contract. Pre-issue hook logic  * can contain arbitrary logic including validations, external function calls, etc.  */ function _callPreIssueHooks(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity,     address _caller,     address _to )     internal {     INAVIssuanceHook preIssueHook = navIssuanceSettings[_setToken].managerIssuanceHook;     if (address(preIssueHook) != address(0)) {         preIssueHook.invokePreIssueHook(_setToken, _reserveAsset, _reserveAssetQuantity, _caller, _to);     } }  /**  * If a pre-redeem hook has been configured, call the external-protocol contract.  */ function _callPreRedeemHooks(ISetToken _setToken, uint256 _setQuantity, address _caller, address _to) internal {     INAVIssuanceHook preRedeemHook = navIssuanceSettings[_setToken].managerRedemptionHook;     if (address(preRedeemHook) != address(0)) {         preRedeemHook.invokePreRedeemHook(_setToken, _setQuantity, _caller, _to);     } }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 05:31:46 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | /*     Copyright 2020 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol"; import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol"; import { SignedSafeMath } from "@openzeppelin/contracts/math/SignedSafeMath.sol"; import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol"; import { IController } from "../../interfaces/IController.sol"; import { INAVIssuanceHook } from "../../interfaces/INAVIssuanceHook.sol"; import { Invoke } from "../lib/Invoke.sol"; import { ISetToken } from "../../interfaces/ISetToken.sol"; import { IWETH } from "../../interfaces/external/IWETH.sol"; import { ModuleBase } from "../lib/ModuleBase.sol"; import { Position } from "../lib/Position.sol"; import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol"; import { ResourceIdentifier } from "../lib/ResourceIdentifier.sol"; /*  * @title NavIssuanceModule  * @author Set Protocol  *  * Module that enables issuance and redemption with any valid ERC20 token or ETH if allowed by the manager. Sender receives  * a proportional amount of SetTokens on issuance or ERC20 token on redemption based on the calculated net asset value using  * oracle prices. Manager is able to enforce a premium / discount on issuance / redemption to avoid arbitrage and front  * running when relying on oracle prices. Managers can charge a fee (denominated in reserve asset).  / contract NavIssuanceModule is ModuleBase, ReentrancyGuard {     using AddressArrayUtils for address[];     using Invoke for ISetToken;     using Position for ISetToken;     using PreciseUnitMath for uint256;     using PreciseUnitMath for int256;     using ResourceIdentifier for IController;     using SafeMath for uint256;     using SafeCast for int256;     using SafeCast for uint256;     using SignedSafeMath for int256; /* ============ Events ============ */  event SetTokenNAVIssued(     ISetToken indexed _setToken,     address _issuer,     address _to,     address _reserveAsset,     address _hookContract,     uint256 _setTokenQuantity,     uint256 _managerFee,     uint256 _premium );  event SetTokenNAVRedeemed(     ISetToken indexed _setToken,     address _redeemer,     address _to,     address _reserveAsset,     address _hookContract,     uint256 _setTokenQuantity,     uint256 _managerFee,     uint256 _premium );  event ReserveAssetAdded(     ISetToken indexed _setToken,     address _newReserveAsset );  event ReserveAssetRemoved(     ISetToken indexed _setToken,     address _removedReserveAsset );  event PremiumEdited(     ISetToken indexed _setToken,     uint256 _newPremium );  event ManagerFeeEdited(     ISetToken indexed _setToken,     uint256 _newManagerFee,     uint256 _index );  event FeeRecipientEdited(     ISetToken indexed _setToken,     address _feeRecipient );  /* ============ Structs ============ */  struct NAVIssuanceSettings {     INAVIssuanceHook managerIssuanceHook;      // Issuance hook configurations     INAVIssuanceHook managerRedemptionHook;    // Redemption hook configurations     address[] reserveAssets;                       // Allowed reserve assets - Must have a price enabled with the price oracle     address feeRecipient;                          // Manager fee recipient     uint256[2] managerFees;                        // Manager fees. 0 index is issue and 1 index is redeem fee (0.01% = 1e14, 1% = 1e16)     uint256 maxManagerFee;                         // Maximum fee manager is allowed to set for issue and redeem     uint256 premiumPercentage;                     // Premium percentage (0.01% = 1e14, 1% = 1e16). This premium is a buffer around oracle                                                    // prices paid by user to the SetToken, which prevents arbitrage and oracle front running     uint256 maxPremiumPercentage;                  // Maximum premium percentage manager is allowed to set (configured by manager)     uint256 minSetTokenSupply;                     // Minimum SetToken supply required for issuance and redemption                                                    // to prevent dramatic inflationary changes to the SetToken's position multiplier }  struct ActionInfo {     uint256 preFeeReserveQuantity;                 // Reserve value before fees; During issuance, represents raw quantity                                                    // During redeem, represents post-premium value     uint256 protocolFees;                          // Total protocol fees (direct + manager revenue share)     uint256 managerFee;                            // Total manager fee paid in reserve asset     uint256 netFlowQuantity;                       // When issuing, quantity of reserve asset sent to SetToken                                                    // When redeeming, quantity of reserve asset sent to redeemer     uint256 setTokenQuantity;                      // When issuing, quantity of SetTokens minted to mintee                                                    // When redeeming, quantity of SetToken redeemed     uint256 previousSetTokenSupply;                // SetToken supply prior to issue/redeem action     uint256 newSetTokenSupply;                     // SetToken supply after issue/redeem action     int256 newPositionMultiplier;                  // SetToken position multiplier after issue/redeem     uint256 newReservePositionUnit;                // SetToken reserve asset position unit after issue/redeem }  /* ============ State Variables ============ */  // Wrapped ETH address IWETH public immutable weth;  // Mapping of SetToken to NAV issuance settings struct mapping(ISetToken =&gt; NAVIssuanceSettings) public navIssuanceSettings;  // Mapping to efficiently check a SetToken's reserve asset validity // SetToken =&gt; reserveAsset =&gt; isReserveAsset mapping(ISetToken =&gt; mapping(address =&gt; bool)) public isReserveAsset;  /* ============ Constants ============ */  // 0 index stores the manager fee in managerFees array, percentage charged on issue (denominated in reserve asset) uint256 constant internal MANAGER_ISSUE_FEE_INDEX = 0;  // 1 index stores the manager fee percentage in managerFees array, charged on redeem uint256 constant internal MANAGER_REDEEM_FEE_INDEX = 1;  // 0 index stores the manager revenue share protocol fee % on the controller, charged in the issuance function uint256 constant internal PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX = 0;  // 1 index stores the manager revenue share protocol fee % on the controller, charged in the redeem function uint256 constant internal PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX = 1;  // 2 index stores the direct protocol fee % on the controller, charged in the issuance function uint256 constant internal PROTOCOL_ISSUE_DIRECT_FEE_INDEX = 2;  // 3 index stores the direct protocol fee % on the controller, charged in the redeem function uint256 constant internal PROTOCOL_REDEEM_DIRECT_FEE_INDEX = 3;  /* ============ Constructor ============ */  /**  * @param _controller               Address of controller contract  * @param _weth                     Address of wrapped eth  */ constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {     weth = _weth; }  /* ============ External Functions ============ */  /**  * Deposits the allowed reserve asset into the SetToken and mints the appropriate % of Net Asset Value of the SetToken  * to the specified _to address.  *  * @param _setToken                     Instance of the SetToken contract  * @param _reserveAsset                 Address of the reserve asset to issue with  * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with  * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance  * @param _to                           Address to mint SetToken to  */ function issue(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity,     uint256 _minSetTokenReceiveQuantity,     address _to )     external     nonReentrant     onlyValidAndInitializedSet(_setToken) {     _validateCommon(_setToken, _reserveAsset, _reserveAssetQuantity);      _callPreIssueHooks(_setToken, _reserveAsset, _reserveAssetQuantity, msg.sender, _to);      ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, _reserveAsset, _reserveAssetQuantity);      _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);      _transferCollateralAndHandleFees(_setToken, IERC20(_reserveAsset), issueInfo);      _handleIssueStateUpdates(_setToken, _reserveAsset, _to, issueInfo); }  /**  * Wraps ETH and deposits WETH if allowed into the SetToken and mints the appropriate % of Net Asset Value of the SetToken  * to the specified _to address.  *  * @param _setToken                     Instance of the SetToken contract  * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance  * @param _to                           Address to mint SetToken to  */ function issueWithEther(     ISetToken _setToken,     uint256 _minSetTokenReceiveQuantity,     address _to )     external     payable     nonReentrant     onlyValidAndInitializedSet(_setToken) {     weth.deposit{ value: msg.value }();      _validateCommon(_setToken, address(weth), msg.value);      _callPreIssueHooks(_setToken, address(weth), msg.value, msg.sender, _to);      ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, address(weth), msg.value);      _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);      _transferWETHAndHandleFees(_setToken, issueInfo);      _handleIssueStateUpdates(_setToken, address(weth), _to, issueInfo); }  /**  * Redeems a SetToken into a valid reserve asset representing the appropriate % of Net Asset Value of the SetToken  * to the specified _to address. Only valid if there are available reserve units on the SetToken.  *  * @param _setToken                     Instance of the SetToken contract  * @param _reserveAsset                 Address of the reserve asset to redeem with  * @param _setTokenQuantity             Quantity of SetTokens to redeem  * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive  * @param _to                           Address to redeem reserve asset to  */ function redeem(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity,     uint256 _minReserveReceiveQuantity,     address _to )     external     nonReentrant     onlyValidAndInitializedSet(_setToken) {     _validateCommon(_setToken, _reserveAsset, _setTokenQuantity);      _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);      ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, _reserveAsset, _setTokenQuantity);      _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);      _setToken.burn(msg.sender, _setTokenQuantity);      // Instruct the SetToken to transfer the reserve asset back to the user     _setToken.strictInvokeTransfer(         _reserveAsset,         _to,         redeemInfo.netFlowQuantity     );      _handleRedemptionFees(_setToken, _reserveAsset, redeemInfo);      _handleRedeemStateUpdates(_setToken, _reserveAsset, _to, redeemInfo); }  /**  * Redeems a SetToken into Ether (if WETH is valid) representing the appropriate % of Net Asset Value of the SetToken  * to the specified _to address. Only valid if there are available WETH units on the SetToken.  *  * @param _setToken                     Instance of the SetToken contract  * @param _setTokenQuantity             Quantity of SetTokens to redeem  * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive  * @param _to                           Address to redeem reserve asset to  */ function redeemIntoEther(     ISetToken _setToken,     uint256 _setTokenQuantity,     uint256 _minReserveReceiveQuantity,     address payable _to )     external     nonReentrant     onlyValidAndInitializedSet(_setToken) {     _validateCommon(_setToken, address(weth), _setTokenQuantity);      _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);      ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, address(weth), _setTokenQuantity);      _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);      _setToken.burn(msg.sender, _setTokenQuantity);      // Instruct the SetToken to transfer WETH from SetToken to module     _setToken.strictInvokeTransfer(         address(weth),         address(this),         redeemInfo.netFlowQuantity     );      weth.withdraw(redeemInfo.netFlowQuantity);      _to.transfer(redeemInfo.netFlowQuantity);      _handleRedemptionFees(_setToken, address(weth), redeemInfo);      _handleRedeemStateUpdates(_setToken, address(weth), _to, redeemInfo); }  /**  * SET MANAGER ONLY. Add an allowed reserve asset  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset to add  */ function addReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {     require(!isReserveAsset[_setToken][_reserveAsset], "Reserve asset already exists");      navIssuanceSettings[_setToken].reserveAssets.push(_reserveAsset);     isReserveAsset[_setToken][_reserveAsset] = true;      emit ReserveAssetAdded(_setToken, _reserveAsset); }  /**  * SET MANAGER ONLY. Remove a reserve asset  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset to remove  */ function removeReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {     require(isReserveAsset[_setToken][_reserveAsset], "Reserve asset does not exist");      navIssuanceSettings[_setToken].reserveAssets = navIssuanceSettings[_setToken].reserveAssets.remove(_reserveAsset);     delete isReserveAsset[_setToken][_reserveAsset];      emit ReserveAssetRemoved(_setToken, _reserveAsset); }  /**  * SET MANAGER ONLY. Edit the premium percentage  *  * @param _setToken                     Instance of the SetToken  * @param _premiumPercentage            Premium percentage in 10e16 (e.g. 10e16 = 1%)  */ function editPremium(ISetToken _setToken, uint256 _premiumPercentage) external onlyManagerAndValidSet(_setToken) {     require(_premiumPercentage &lt;= navIssuanceSettings[_setToken].maxPremiumPercentage, "Premium must be less than maximum allowed");      navIssuanceSettings[_setToken].premiumPercentage = _premiumPercentage;      emit PremiumEdited(_setToken, _premiumPercentage); }  /**  * SET MANAGER ONLY. Edit manager fee  *  * @param _setToken                     Instance of the SetToken  * @param _managerFeePercentage         Manager fee percentage in 10e16 (e.g. 10e16 = 1%)  * @param _managerFeeIndex              Manager fee index. 0 index is issue fee, 1 index is redeem fee  */ function editManagerFee(     ISetToken _setToken,     uint256 _managerFeePercentage,     uint256 _managerFeeIndex )     external     onlyManagerAndValidSet(_setToken) {     require(_managerFeePercentage &lt;= navIssuanceSettings[_setToken].maxManagerFee, "Manager fee must be less than maximum allowed");      navIssuanceSettings[_setToken].managerFees[_managerFeeIndex] = _managerFeePercentage;      emit ManagerFeeEdited(_setToken, _managerFeePercentage, _managerFeeIndex); }  /**  * SET MANAGER ONLY. Edit the manager fee recipient  *  * @param _setToken                     Instance of the SetToken  * @param _managerFeeRecipient          Manager fee recipient  */ function editFeeRecipient(ISetToken _setToken, address _managerFeeRecipient) external onlyManagerAndValidSet(_setToken) {     require(_managerFeeRecipient != address(0), "Fee recipient must not be 0 address");      navIssuanceSettings[_setToken].feeRecipient = _managerFeeRecipient;      emit FeeRecipientEdited(_setToken, _managerFeeRecipient); }  /**  * SET MANAGER ONLY. Initializes this module to the SetToken with hooks, allowed reserve assets,  * fees and issuance premium. Only callable by the SetToken's manager. Hook addresses are optional.  * Address(0) means that no hook will be called.  *  * @param _setToken                     Instance of the SetToken to issue  * @param _navIssuanceSettings          NAVIssuanceSettings struct defining parameters  */ function initialize(     ISetToken _setToken,     NAVIssuanceSettings memory _navIssuanceSettings )     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     require(_navIssuanceSettings.reserveAssets.length &gt; 0, "Reserve assets must be greater than 0");     require(_navIssuanceSettings.maxManagerFee &lt; PreciseUnitMath.preciseUnit(), "Max manager fee must be less than 100%");     require(_navIssuanceSettings.maxPremiumPercentage &lt; PreciseUnitMath.preciseUnit(), "Max premium percentage must be less than 100%");     require(_navIssuanceSettings.managerFees[0] &lt;= _navIssuanceSettings.maxManagerFee, "Manager issue fee must be less than max");     require(_navIssuanceSettings.managerFees[1] &lt;= _navIssuanceSettings.maxManagerFee, "Manager redeem fee must be less than max");     require(_navIssuanceSettings.premiumPercentage &lt;= _navIssuanceSettings.maxPremiumPercentage, "Premium must be less than max");     require(_navIssuanceSettings.feeRecipient != address(0), "Fee Recipient must be non-zero address.");     // Initial mint of Set cannot use NAVIssuance since minSetTokenSupply must be &gt; 0     require(_navIssuanceSettings.minSetTokenSupply &gt; 0, "Min SetToken supply must be greater than 0");      for (uint256 i = 0; i &lt; _navIssuanceSettings.reserveAssets.length; i++) {         require(!isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]], "Reserve assets must be unique");         isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]] = true;     }      navIssuanceSettings[_setToken] = _navIssuanceSettings;      _setToken.initializeModule(); }  /**  * Removes this module from the SetToken, via call by the SetToken. Issuance settings and  * reserve asset states are deleted.  */ function removeModule() external override {     ISetToken setToken = ISetToken(msg.sender);     for (uint256 i = 0; i &lt; navIssuanceSettings[setToken].reserveAssets.length; i++) {         delete isReserveAsset[setToken][navIssuanceSettings[setToken].reserveAssets[i]];     }      delete navIssuanceSettings[setToken]; }  receive() external payable {}  /* ============ External Getter Functions ============ */  function getReserveAssets(ISetToken _setToken) external view returns (address[] memory) {     return navIssuanceSettings[_setToken].reserveAssets; }  function getIssuePremium(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     external     view     returns (uint256) {     return _getIssuePremium(_setToken, _reserveAsset, _reserveAssetQuantity); }  function getRedeemPremium(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     external     view     returns (uint256) {     return _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity); }  function getManagerFee(ISetToken _setToken, uint256 _managerFeeIndex) external view returns (uint256) {     return navIssuanceSettings[_setToken].managerFees[_managerFeeIndex]; }  /**  * Get the expected SetTokens minted to recipient on issuance  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with  *  * @return  uint256                     Expected SetTokens to be minted to recipient  */ function getExpectedSetTokenIssueQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     external     view     returns (uint256) {     (,, uint256 netReserveFlow) = _getFees(         _setToken,         _reserveAssetQuantity,         PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_ISSUE_DIRECT_FEE_INDEX,         MANAGER_ISSUE_FEE_INDEX     );      uint256 setTotalSupply = _setToken.totalSupply();      return _getSetTokenMintQuantity(         _setToken,         _reserveAsset,         netReserveFlow,         setTotalSupply     ); }  /**  * Get the expected reserve asset to be redeemed  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _setTokenQuantity             Quantity of SetTokens to redeem  *  * @return  uint256                     Expected reserve asset quantity redeemed  */ function getExpectedReserveRedeemQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     external     view     returns (uint256) {     uint256 preFeeReserveQuantity = _getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);      (,, uint256 netReserveFlows) = _getFees(         _setToken,         preFeeReserveQuantity,         PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_REDEEM_DIRECT_FEE_INDEX,         MANAGER_REDEEM_FEE_INDEX     );      return netReserveFlows; }  /**  * Checks if issue is valid  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with  *  * @return  bool                        Returns true if issue is valid  */ function isIssueValid(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     external     view     returns (bool) {     uint256 setTotalSupply = _setToken.totalSupply();  return _reserveAssetQuantity != 0         &amp;&amp; isReserveAsset[_setToken][_reserveAsset]         &amp;&amp; setTotalSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply; }  /**  * Checks if redeem is valid  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _setTokenQuantity             Quantity of SetTokens to redeem  *  * @return  bool                        Returns true if redeem is valid  */ function isRedeemValid(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     external     view     returns (bool) {     uint256 setTotalSupply = _setToken.totalSupply();      if (         _setTokenQuantity == 0         || !isReserveAsset[_setToken][_reserveAsset]         || setTotalSupply &lt; navIssuanceSettings[_setToken].minSetTokenSupply.add(_setTokenQuantity)     ) {         return false;     } else {         uint256 totalRedeemValue =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);          (,, uint256 expectedRedeemQuantity) = _getFees(             _setToken,             totalRedeemValue,             PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,             PROTOCOL_REDEEM_DIRECT_FEE_INDEX,             MANAGER_REDEEM_FEE_INDEX         );          uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();          return existingUnit.preciseMul(setTotalSupply) &gt;= expectedRedeemQuantity;     } }  /* ============ Internal Functions ============ */  function _validateCommon(ISetToken _setToken, address _reserveAsset, uint256 _quantity) internal view {     require(_quantity &gt; 0, "Quantity must be &gt; 0");     require(isReserveAsset[_setToken][_reserveAsset], "Must be valid reserve asset"); }  function _validateIssuanceInfo(ISetToken _setToken, uint256 _minSetTokenReceiveQuantity, ActionInfo memory _issueInfo) internal view {     // Check that total supply is greater than min supply needed for issuance     // Note: A min supply amount is needed to avoid division by 0 when SetToken supply is 0     require(         _issueInfo.previousSetTokenSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply,         "Supply must be greater than minimum to enable issuance"     );      require(_issueInfo.setTokenQuantity &gt;= _minSetTokenReceiveQuantity, "Must be greater than min SetToken"); }  function _validateRedemptionInfo(     ISetToken _setToken,     uint256 _minReserveReceiveQuantity,     ActionInfo memory _redeemInfo )     internal     view {     // Check that new supply is more than min supply needed for redemption     // Note: A min supply amount is needed to avoid division by 0 when redeeming SetToken to 0     require(         _redeemInfo.newSetTokenSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply,         "Supply must be greater than minimum to enable redemption"     );      require(_redeemInfo.netFlowQuantity &gt;= _minReserveReceiveQuantity, "Must be greater than min receive reserve quantity"); }  function _createIssuanceInfo(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     internal     view     returns (ActionInfo memory) {     ActionInfo memory issueInfo;      issueInfo.previousSetTokenSupply = _setToken.totalSupply();      issueInfo.preFeeReserveQuantity = _reserveAssetQuantity;      (issueInfo.protocolFees, issueInfo.managerFee, issueInfo.netFlowQuantity) = _getFees(         _setToken,         issueInfo.preFeeReserveQuantity,         PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_ISSUE_DIRECT_FEE_INDEX,         MANAGER_ISSUE_FEE_INDEX     );      issueInfo.setTokenQuantity = _getSetTokenMintQuantity(         _setToken,         _reserveAsset,         issueInfo.netFlowQuantity,         issueInfo.previousSetTokenSupply     );      (issueInfo.newSetTokenSupply, issueInfo.newPositionMultiplier) = _getIssuePositionMultiplier(_setToken, issueInfo);      issueInfo.newReservePositionUnit = _getIssuePositionUnit(_setToken, _reserveAsset, issueInfo);      return issueInfo; }  function _createRedemptionInfo(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     internal     view     returns (ActionInfo memory) {     ActionInfo memory redeemInfo;      redeemInfo.setTokenQuantity = _setTokenQuantity;      redeemInfo.preFeeReserveQuantity =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);      (redeemInfo.protocolFees, redeemInfo.managerFee, redeemInfo.netFlowQuantity) = _getFees(         _setToken,         redeemInfo.preFeeReserveQuantity,         PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_REDEEM_DIRECT_FEE_INDEX,         MANAGER_REDEEM_FEE_INDEX     );      redeemInfo.previousSetTokenSupply = _setToken.totalSupply();      (redeemInfo.newSetTokenSupply, redeemInfo.newPositionMultiplier) = _getRedeemPositionMultiplier(_setToken, _setTokenQuantity, redeemInfo);      redeemInfo.newReservePositionUnit = _getRedeemPositionUnit(_setToken, _reserveAsset, redeemInfo);      return redeemInfo; }  /**  * Transfer reserve asset from user to SetToken and fees from user to appropriate fee recipients  */ function _transferCollateralAndHandleFees(ISetToken _setToken, IERC20 _reserveAsset, ActionInfo memory _issueInfo) internal {     transferFrom(_reserveAsset, msg.sender, address(_setToken), _issueInfo.netFlowQuantity);      if (_issueInfo.protocolFees &gt; 0) {         transferFrom(_reserveAsset, msg.sender, controller.feeRecipient(), _issueInfo.protocolFees);     }      if (_issueInfo.managerFee &gt; 0) {         transferFrom(_reserveAsset, msg.sender, navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);     } }   /**   * Transfer WETH from module to SetToken and fees from module to appropriate fee recipients  */ function _transferWETHAndHandleFees(ISetToken _setToken, ActionInfo memory _issueInfo) internal {     weth.transfer(address(_setToken), _issueInfo.netFlowQuantity);      if (_issueInfo.protocolFees &gt; 0) {         weth.transfer(controller.feeRecipient(), _issueInfo.protocolFees);     }      if (_issueInfo.managerFee &gt; 0) {         weth.transfer(navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);     } }  function _handleIssueStateUpdates(     ISetToken _setToken,     address _reserveAsset,     address _to,     ActionInfo memory _issueInfo )     internal {     _setToken.editPositionMultiplier(_issueInfo.newPositionMultiplier);      _setToken.editDefaultPosition(_reserveAsset, _issueInfo.newReservePositionUnit);      _setToken.mint(_to, _issueInfo.setTokenQuantity);      emit SetTokenNAVIssued(         _setToken,         msg.sender,         _to,         _reserveAsset,         address(navIssuanceSettings[_setToken].managerIssuanceHook),         _issueInfo.setTokenQuantity,         _issueInfo.managerFee,         _issueInfo.protocolFees     ); }  function _handleRedeemStateUpdates(     ISetToken _setToken,     address _reserveAsset,     address _to,     ActionInfo memory _redeemInfo )     internal {     _setToken.editPositionMultiplier(_redeemInfo.newPositionMultiplier);      _setToken.editDefaultPosition(_reserveAsset, _redeemInfo.newReservePositionUnit);      emit SetTokenNAVRedeemed(         _setToken,         msg.sender,         _to,         _reserveAsset,         address(navIssuanceSettings[_setToken].managerRedemptionHook),         _redeemInfo.setTokenQuantity,         _redeemInfo.managerFee,         _redeemInfo.protocolFees     ); }  function _handleRedemptionFees(ISetToken _setToken, address _reserveAsset, ActionInfo memory _redeemInfo) internal {     // Instruct the SetToken to transfer protocol fee to fee recipient if there is a fee     payProtocolFeeFromSetToken(_setToken, _reserveAsset, _redeemInfo.protocolFees);      // Instruct the SetToken to transfer manager fee to manager fee recipient if there is a fee     if (_redeemInfo.managerFee &gt; 0) {         _setToken.strictInvokeTransfer(             _reserveAsset,             navIssuanceSettings[_setToken].feeRecipient,             _redeemInfo.managerFee         );     } }  /**  * Returns the issue premium percentage. Virtual function that can be overridden in future versions of the module  * and can contain arbitrary logic to calculate the issuance premium.  */ function _getIssuePremium(     ISetToken _setToken,     address /* _reserveAsset */,     uint256 /* _reserveAssetQuantity */ )     virtual     internal     view     returns (uint256) {     return navIssuanceSettings[_setToken].premiumPercentage; }  /**  * Returns the redeem premium percentage. Virtual function that can be overridden in future versions of the module  * and can contain arbitrary logic to calculate the redemption premium.  */ function _getRedeemPremium(     ISetToken _setToken,     address /* _reserveAsset */,     uint256 /* _setTokenQuantity */ )     virtual     internal     view     returns (uint256) {     return navIssuanceSettings[_setToken].premiumPercentage; }  /**  * Returns the fees attributed to the manager and the protocol. The fees are calculated as follows:  *  * ManagerFee = (manager fee % - % to protocol) * reserveAssetQuantity  * Protocol Fee = (% manager fee share + direct fee %) * reserveAssetQuantity  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAssetQuantity         Quantity of reserve asset to calculate fees from  * @param _protocolManagerFeeIndex      Index to pull rev share NAV Issuance fee from the Controller  * @param _protocolDirectFeeIndex       Index to pull direct NAV issuance fee from the Controller  * @param _managerFeeIndex              Index from NAVIssuanceSettings (0 = issue fee, 1 = redeem fee)  *  * @return  uint256                     Fees paid to the protocol in reserve asset  * @return  uint256                     Fees paid to the manager in reserve asset  * @return  uint256                     Net reserve to user net of fees  */ function _getFees(     ISetToken _setToken,     uint256 _reserveAssetQuantity,     uint256 _protocolManagerFeeIndex,     uint256 _protocolDirectFeeIndex,     uint256 _managerFeeIndex )     internal     view     returns (uint256, uint256, uint256) {     (uint256 protocolFeePercentage, uint256 managerFeePercentage) = _getProtocolAndManagerFeePercentages(         _setToken,         _protocolManagerFeeIndex,         _protocolDirectFeeIndex,         _managerFeeIndex     );      // Calculate total notional fees     uint256 protocolFees = protocolFeePercentage.preciseMul(_reserveAssetQuantity);     uint256 managerFee = managerFeePercentage.preciseMul(_reserveAssetQuantity);      uint256 netReserveFlow = _reserveAssetQuantity.sub(protocolFees).sub(managerFee);      return (protocolFees, managerFee, netReserveFlow); }  function _getProtocolAndManagerFeePercentages(     ISetToken _setToken,     uint256 _protocolManagerFeeIndex,     uint256 _protocolDirectFeeIndex,     uint256 _managerFeeIndex )     internal     view     returns(uint256, uint256) {     // Get protocol fee percentages     uint256 protocolDirectFeePercent = controller.getModuleFee(address(this), _protocolDirectFeeIndex);     uint256 protocolManagerShareFeePercent = controller.getModuleFee(address(this), _protocolManagerFeeIndex);     uint256 managerFeePercent = navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];      // Calculate revenue share split percentage     uint256 protocolRevenueSharePercentage = protocolManagerShareFeePercent.preciseMul(managerFeePercent);     uint256 managerRevenueSharePercentage = managerFeePercent.sub(protocolRevenueSharePercentage);     uint256 totalProtocolFeePercentage = protocolRevenueSharePercentage.add(protocolDirectFeePercent);      return (totalProtocolFeePercentage, managerRevenueSharePercentage); }  function _getSetTokenMintQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _netReserveFlows,            // Value of reserve asset net of fees     uint256 _setTotalSupply )     internal     view     returns (uint256) {     uint256 premiumPercentage = _getIssuePremium(_setToken, _reserveAsset, _netReserveFlows);     uint256 premiumValue = _netReserveFlows.preciseMul(premiumPercentage);      // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (1e18)     // Reverts if price is not found     uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);      // Get reserve asset decimals     uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();     uint256 normalizedTotalReserveQuantityNetFees = _netReserveFlows.preciseDiv(10 ** reserveAssetDecimals);     uint256 normalizedTotalReserveQuantityNetFeesAndPremium = _netReserveFlows.sub(premiumValue).preciseDiv(10 ** reserveAssetDecimals);      // Calculate SetTokens to mint to issuer     uint256 denominator = _setTotalSupply.preciseMul(setTokenValuation).add(normalizedTotalReserveQuantityNetFees).sub(normalizedTotalReserveQuantityNetFeesAndPremium);     return normalizedTotalReserveQuantityNetFeesAndPremium.preciseMul(_setTotalSupply).preciseDiv(denominator); }  function _getRedeemReserveQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     internal     view     returns (uint256) {     // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (10e18)     // Reverts if price is not found     uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);      uint256 totalRedeemValueInPreciseUnits = _setTokenQuantity.preciseMul(setTokenValuation);     // Get reserve asset decimals     uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();     uint256 prePremiumReserveQuantity = totalRedeemValueInPreciseUnits.preciseMul(10 ** reserveAssetDecimals);      uint256 premiumPercentage = _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);     uint256 premiumQuantity = prePremiumReserveQuantity.preciseMulCeil(premiumPercentage);      return prePremiumReserveQuantity.sub(premiumQuantity); }  /**  * The new position multiplier is calculated as follows:  * inflationPercentage = (newSupply - oldSupply) / newSupply  * newMultiplier = (1 - inflationPercentage) * positionMultiplier  */ function _getIssuePositionMultiplier(     ISetToken _setToken,     ActionInfo memory _issueInfo )     internal     view     returns (uint256, int256) {     // Calculate inflation and new position multiplier. Note: Round inflation up in order to round position multiplier down     uint256 newTotalSupply = _issueInfo.setTokenQuantity.add(_issueInfo.previousSetTokenSupply);     int256 newPositionMultiplier = _setToken.positionMultiplier()         .mul(_issueInfo.previousSetTokenSupply.toInt256())         .div(newTotalSupply.toInt256());      return (newTotalSupply, newPositionMultiplier); }  /**  * Calculate deflation and new position multiplier. Note: Round deflation down in order to round position multiplier down  *  * The new position multiplier is calculated as follows:  * deflationPercentage = (oldSupply - newSupply) / newSupply  * newMultiplier = (1 + deflationPercentage) * positionMultiplier  */ function _getRedeemPositionMultiplier(     ISetToken _setToken,     uint256 _setTokenQuantity,     ActionInfo memory _redeemInfo )     internal     view     returns (uint256, int256) {     uint256 newTotalSupply = _redeemInfo.previousSetTokenSupply.sub(_setTokenQuantity);     int256 newPositionMultiplier = _setToken.positionMultiplier()         .mul(_redeemInfo.previousSetTokenSupply.toInt256())         .div(newTotalSupply.toInt256());      return (newTotalSupply, newPositionMultiplier); }  /**  * The new position reserve asset unit is calculated as follows:  * totalReserve = (oldUnit * oldSetTokenSupply) + reserveQuantity  * newUnit = totalReserve / newSetTokenSupply  */ function _getIssuePositionUnit(     ISetToken _setToken,     address _reserveAsset,     ActionInfo memory _issueInfo )     internal     view     returns (uint256) {     uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();     uint256 totalReserve = existingUnit         .preciseMul(_issueInfo.previousSetTokenSupply)         .add(_issueInfo.netFlowQuantity);      return totalReserve.preciseDiv(_issueInfo.newSetTokenSupply); }  /**  * The new position reserve asset unit is calculated as follows:  * totalReserve = (oldUnit * oldSetTokenSupply) - reserveQuantityToSendOut  * newUnit = totalReserve / newSetTokenSupply  */ function _getRedeemPositionUnit(     ISetToken _setToken,     address _reserveAsset,     ActionInfo memory _redeemInfo )     internal     view     returns (uint256) {     uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();     uint256 totalExistingUnits = existingUnit.preciseMul(_redeemInfo.previousSetTokenSupply);      uint256 outflow = _redeemInfo.netFlowQuantity.add(_redeemInfo.protocolFees).add(_redeemInfo.managerFee);      // Require withdrawable quantity is greater than existing collateral     require(totalExistingUnits &gt;= outflow, "Must be greater than total available collateral");      return totalExistingUnits.sub(outflow).preciseDiv(_redeemInfo.newSetTokenSupply); }  /**  * If a pre-issue hook has been configured, call the external-protocol contract. Pre-issue hook logic  * can contain arbitrary logic including validations, external function calls, etc.  */ function _callPreIssueHooks(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity,     address _caller,     address _to )     internal {     INAVIssuanceHook preIssueHook = navIssuanceSettings[_setToken].managerIssuanceHook;     if (address(preIssueHook) != address(0)) {         preIssueHook.invokePreIssueHook(_setToken, _reserveAsset, _reserveAssetQuantity, _caller, _to);     } }  /**  * If a pre-redeem hook has been configured, call the external-protocol contract.  */ function _callPreRedeemHooks(ISetToken _setToken, uint256 _setQuantity, address _caller, address _to) internal {     INAVIssuanceHook preRedeemHook = navIssuanceSettings[_setToken].managerRedemptionHook;     if (address(preRedeemHook) != address(0)) {         preRedeemHook.invokePreRedeemHook(_setToken, _setQuantity, _caller, _to);     } }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 05:31:46 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: /*
    Copyright 2020 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";
import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";
import { SignedSafeMath } from "@openzeppelin/contracts/math/SignedSafeMath.sol";

import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";
import { IController } from "../../interfaces/IController.sol";
import { INAVIssuanceHook } from "../../interfaces/INAVIssuanceHook.sol";
import { Invoke } from "../lib/Invoke.sol";
import { ISetToken } from "../../interfaces/ISetToken.sol";
import { IWETH } from "../../interfaces/external/IWETH.sol";
import { ModuleBase } from "../lib/ModuleBase.sol";
import { Position } from "../lib/Position.sol";
import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";
import { ResourceIdentifier } from "../lib/ResourceIdentifier.sol";


/**
 * @title NavIssuanceModule
 * @author Set Protocol
 *
 * Module that enables issuance and redemption with any valid ERC20 token or ETH if allowed by the manager. Sender receives
 * a proportional amount of SetTokens on issuance or ERC20 token on redemption based on the calculated net asset value using
 * oracle prices. Manager is able to enforce a premium / discount on issuance / redemption to avoid arbitrage and front
 * running when relying on oracle prices. Managers can charge a fee (denominated in reserve asset).
 */
contract NavIssuanceModule is ModuleBase, ReentrancyGuard {
    using AddressArrayUtils for address[];
    using Invoke for ISetToken;
    using Position for ISetToken;
    using PreciseUnitMath for uint256;
    using PreciseUnitMath for int256;
    using ResourceIdentifier for IController;
    using SafeMath for uint256;
    using SafeCast for int256;
    using SafeCast for uint256;
    using SignedSafeMath for int256;

    /* ============ Events ============ */

    event SetTokenNAVIssued(
        ISetToken indexed _setToken,
        address _issuer,
        address _to,
        address _reserveAsset,
        address _hookContract,
        uint256 _setTokenQuantity,
        uint256 _managerFee,
        uint256 _premium
    );

    event SetTokenNAVRedeemed(
        ISetToken indexed _setToken,
        address _redeemer,
        address _to,
        address _reserveAsset,
        address _hookContract,
        uint256 _setTokenQuantity,
        uint256 _managerFee,
        uint256 _premium
    );

    event ReserveAssetAdded(
        ISetToken indexed _setToken,
        address _newReserveAsset
    );

    event ReserveAssetRemoved(
        ISetToken indexed _setToken,
        address _removedReserveAsset
    );

    event PremiumEdited(
        ISetToken indexed _setToken,
        uint256 _newPremium
    );

    event ManagerFeeEdited(
        ISetToken indexed _setToken,
        uint256 _newManagerFee,
        uint256 _index
    );

    event FeeRecipientEdited(
        ISetToken indexed _setToken,
        address _feeRecipient
    );

    /* ============ Structs ============ */

    struct NAVIssuanceSettings {
        INAVIssuanceHook managerIssuanceHook;      // Issuance hook configurations
        INAVIssuanceHook managerRedemptionHook;    // Redemption hook configurations
        address[] reserveAssets;                       // Allowed reserve assets - Must have a price enabled with the price oracle
        address feeRecipient;                          // Manager fee recipient
        uint256[2] managerFees;                        // Manager fees. 0 index is issue and 1 index is redeem fee (0.01% = 1e14, 1% = 1e16)
        uint256 maxManagerFee;                         // Maximum fee manager is allowed to set for issue and redeem
        uint256 premiumPercentage;                     // Premium percentage (0.01% = 1e14, 1% = 1e16). This premium is a buffer around oracle
                                                       // prices paid by user to the SetToken, which prevents arbitrage and oracle front running
        uint256 maxPremiumPercentage;                  // Maximum premium percentage manager is allowed to set (configured by manager)
        uint256 minSetTokenSupply;                     // Minimum SetToken supply required for issuance and redemption
                                                       // to prevent dramatic inflationary changes to the SetToken's position multiplier
    }

    struct ActionInfo {
        uint256 preFeeReserveQuantity;                 // Reserve value before fees; During issuance, represents raw quantity
                                                       // During redeem, represents post-premium value
        uint256 protocolFees;                          // Total protocol fees (direct + manager revenue share)
        uint256 managerFee;                            // Total manager fee paid in reserve asset
        uint256 netFlowQuantity;                       // When issuing, quantity of reserve asset sent to SetToken
                                                       // When redeeming, quantity of reserve asset sent to redeemer
        uint256 setTokenQuantity;                      // When issuing, quantity of SetTokens minted to mintee
                                                       // When redeeming, quantity of SetToken redeemed
        uint256 previousSetTokenSupply;                // SetToken supply prior to issue/redeem action
        uint256 newSetTokenSupply;                     // SetToken supply after issue/redeem action
        int256 newPositionMultiplier;                  // SetToken position multiplier after issue/redeem
        uint256 newReservePositionUnit;                // SetToken reserve asset position unit after issue/redeem
    }

    /* ============ State Variables ============ */

    // Wrapped ETH address
    IWETH public immutable weth;

    // Mapping of SetToken to NAV issuance settings struct
    mapping(ISetToken => NAVIssuanceSettings) public navIssuanceSettings;

    // Mapping to efficiently check a SetToken's reserve asset validity
    // SetToken => reserveAsset => isReserveAsset
    mapping(ISetToken => mapping(address => bool)) public isReserveAsset;

    /* ============ Constants ============ */

    // 0 index stores the manager fee in managerFees array, percentage charged on issue (denominated in reserve asset)
    uint256 constant internal MANAGER_ISSUE_FEE_INDEX = 0;

    // 1 index stores the manager fee percentage in managerFees array, charged on redeem
    uint256 constant internal MANAGER_REDEEM_FEE_INDEX = 1;

    // 0 index stores the manager revenue share protocol fee % on the controller, charged in the issuance function
    uint256 constant internal PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX = 0;

    // 1 index stores the manager revenue share protocol fee % on the controller, charged in the redeem function
    uint256 constant internal PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX = 1;

    // 2 index stores the direct protocol fee % on the controller, charged in the issuance function
    uint256 constant internal PROTOCOL_ISSUE_DIRECT_FEE_INDEX = 2;

    // 3 index stores the direct protocol fee % on the controller, charged in the redeem function
    uint256 constant internal PROTOCOL_REDEEM_DIRECT_FEE_INDEX = 3;

    /* ============ Constructor ============ */

    /**
     * @param _controller               Address of controller contract
     * @param _weth                     Address of wrapped eth
     */
    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {
        weth = _weth;
    }

    /* ============ External Functions ============ */

    /**
     * Deposits the allowed reserve asset into the SetToken and mints the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _reserveAsset                 Address of the reserve asset to issue with
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance
     * @param _to                           Address to mint SetToken to
     */
    function issue(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity,
        uint256 _minSetTokenReceiveQuantity,
        address _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, _reserveAsset, _reserveAssetQuantity);

        _callPreIssueHooks(_setToken, _reserveAsset, _reserveAssetQuantity, msg.sender, _to);

        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, _reserveAsset, _reserveAssetQuantity);

        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);

        _transferCollateralAndHandleFees(_setToken, IERC20(_reserveAsset), issueInfo);

        _handleIssueStateUpdates(_setToken, _reserveAsset, _to, issueInfo);
    }

    /**
     * Wraps ETH and deposits WETH if allowed into the SetToken and mints the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance
     * @param _to                           Address to mint SetToken to
     */
    function issueWithEther(
        ISetToken _setToken,
        uint256 _minSetTokenReceiveQuantity,
        address _to
    )
        external
        payable
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        weth.deposit{ value: msg.value }();

        _validateCommon(_setToken, address(weth), msg.value);

        _callPreIssueHooks(_setToken, address(weth), msg.value, msg.sender, _to);

        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, address(weth), msg.value);

        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);

        _transferWETHAndHandleFees(_setToken, issueInfo);

        _handleIssueStateUpdates(_setToken, address(weth), _to, issueInfo);
    }

    /**
     * Redeems a SetToken into a valid reserve asset representing the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address. Only valid if there are available reserve units on the SetToken.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _reserveAsset                 Address of the reserve asset to redeem with
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive
     * @param _to                           Address to redeem reserve asset to
     */
    function redeem(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity,
        uint256 _minReserveReceiveQuantity,
        address _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, _reserveAsset, _setTokenQuantity);

        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);

        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, _reserveAsset, _setTokenQuantity);

        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);

        _setToken.burn(msg.sender, _setTokenQuantity);

        // Instruct the SetToken to transfer the reserve asset back to the user
        _setToken.strictInvokeTransfer(
            _reserveAsset,
            _to,
            redeemInfo.netFlowQuantity
        );

        _handleRedemptionFees(_setToken, _reserveAsset, redeemInfo);

        _handleRedeemStateUpdates(_setToken, _reserveAsset, _to, redeemInfo);
    }

    /**
     * Redeems a SetToken into Ether (if WETH is valid) representing the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address. Only valid if there are available WETH units on the SetToken.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive
     * @param _to                           Address to redeem reserve asset to
     */
    function redeemIntoEther(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        uint256 _minReserveReceiveQuantity,
        address payable _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, address(weth), _setTokenQuantity);

        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);

        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, address(weth), _setTokenQuantity);

        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);

        _setToken.burn(msg.sender, _setTokenQuantity);

        // Instruct the SetToken to transfer WETH from SetToken to module
        _setToken.strictInvokeTransfer(
            address(weth),
            address(this),
            redeemInfo.netFlowQuantity
        );

        weth.withdraw(redeemInfo.netFlowQuantity);

        _to.transfer(redeemInfo.netFlowQuantity);

        _handleRedemptionFees(_setToken, address(weth), redeemInfo);

        _handleRedeemStateUpdates(_setToken, address(weth), _to, redeemInfo);
    }

    /**
     * SET MANAGER ONLY. Add an allowed reserve asset
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset to add
     */
    function addReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {
        require(!isReserveAsset[_setToken][_reserveAsset], "Reserve asset already exists");

        navIssuanceSettings[_setToken].reserveAssets.push(_reserveAsset);
        isReserveAsset[_setToken][_reserveAsset] = true;

        emit ReserveAssetAdded(_setToken, _reserveAsset);
    }

    /**
     * SET MANAGER ONLY. Remove a reserve asset
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset to remove
     */
    function removeReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {
        require(isReserveAsset[_setToken][_reserveAsset], "Reserve asset does not exist");

        navIssuanceSettings[_setToken].reserveAssets = navIssuanceSettings[_setToken].reserveAssets.remove(_reserveAsset);
        delete isReserveAsset[_setToken][_reserveAsset];

        emit ReserveAssetRemoved(_setToken, _reserveAsset);
    }

    /**
     * SET MANAGER ONLY. Edit the premium percentage
     *
     * @param _setToken                     Instance of the SetToken
     * @param _premiumPercentage            Premium percentage in 10e16 (e.g. 10e16 = 1%)
     */
    function editPremium(ISetToken _setToken, uint256 _premiumPercentage) external onlyManagerAndValidSet(_setToken) {
        require(_premiumPercentage <= navIssuanceSettings[_setToken].maxPremiumPercentage, "Premium must be less than maximum allowed");

        navIssuanceSettings[_setToken].premiumPercentage = _premiumPercentage;

        emit PremiumEdited(_setToken, _premiumPercentage);
    }

    /**
     * SET MANAGER ONLY. Edit manager fee
     *
     * @param _setToken                     Instance of the SetToken
     * @param _managerFeePercentage         Manager fee percentage in 10e16 (e.g. 10e16 = 1%)
     * @param _managerFeeIndex              Manager fee index. 0 index is issue fee, 1 index is redeem fee
     */
    function editManagerFee(
        ISetToken _setToken,
        uint256 _managerFeePercentage,
        uint256 _managerFeeIndex
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        require(_managerFeePercentage <= navIssuanceSettings[_setToken].maxManagerFee, "Manager fee must be less than maximum allowed");

        navIssuanceSettings[_setToken].managerFees[_managerFeeIndex] = _managerFeePercentage;

        emit ManagerFeeEdited(_setToken, _managerFeePercentage, _managerFeeIndex);
    }

    /**
     * SET MANAGER ONLY. Edit the manager fee recipient
     *
     * @param _setToken                     Instance of the SetToken
     * @param _managerFeeRecipient          Manager fee recipient
     */
    function editFeeRecipient(ISetToken _setToken, address _managerFeeRecipient) external onlyManagerAndValidSet(_setToken) {
        require(_managerFeeRecipient != address(0), "Fee recipient must not be 0 address");

        navIssuanceSettings[_setToken].feeRecipient = _managerFeeRecipient;

        emit FeeRecipientEdited(_setToken, _managerFeeRecipient);
    }

    /**
     * SET MANAGER ONLY. Initializes this module to the SetToken with hooks, allowed reserve assets,
     * fees and issuance premium. Only callable by the SetToken's manager. Hook addresses are optional.
     * Address(0) means that no hook will be called.
     *
     * @param _setToken                     Instance of the SetToken to issue
     * @param _navIssuanceSettings          NAVIssuanceSettings struct defining parameters
     */
    function initialize(
        ISetToken _setToken,
        NAVIssuanceSettings memory _navIssuanceSettings
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        require(_navIssuanceSettings.reserveAssets.length > 0, "Reserve assets must be greater than 0");
        require(_navIssuanceSettings.maxManagerFee < PreciseUnitMath.preciseUnit(), "Max manager fee must be less than 100%");
        require(_navIssuanceSettings.maxPremiumPercentage < PreciseUnitMath.preciseUnit(), "Max premium percentage must be less than 100%");
        require(_navIssuanceSettings.managerFees[0] <= _navIssuanceSettings.maxManagerFee, "Manager issue fee must be less than max");
        require(_navIssuanceSettings.managerFees[1] <= _navIssuanceSettings.maxManagerFee, "Manager redeem fee must be less than max");
        require(_navIssuanceSettings.premiumPercentage <= _navIssuanceSettings.maxPremiumPercentage, "Premium must be less than max");
        require(_navIssuanceSettings.feeRecipient != address(0), "Fee Recipient must be non-zero address.");
        // Initial mint of Set cannot use NAVIssuance since minSetTokenSupply must be > 0
        require(_navIssuanceSettings.minSetTokenSupply > 0, "Min SetToken supply must be greater than 0");

        for (uint256 i = 0; i < _navIssuanceSettings.reserveAssets.length; i++) {
            require(!isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]], "Reserve assets must be unique");
            isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]] = true;
        }

        navIssuanceSettings[_setToken] = _navIssuanceSettings;

        _setToken.initializeModule();
    }

    /**
     * Removes this module from the SetToken, via call by the SetToken. Issuance settings and
     * reserve asset states are deleted.
     */
    function removeModule() external override {
        ISetToken setToken = ISetToken(msg.sender);
        for (uint256 i = 0; i < navIssuanceSettings[setToken].reserveAssets.length; i++) {
            delete isReserveAsset[setToken][navIssuanceSettings[setToken].reserveAssets[i]];
        }

        delete navIssuanceSettings[setToken];
    }

    receive() external payable {}

    /* ============ External Getter Functions ============ */

    function getReserveAssets(ISetToken _setToken) external view returns (address[] memory) {
        return navIssuanceSettings[_setToken].reserveAssets;
    }

    function getIssuePremium(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (uint256)
    {
        return _getIssuePremium(_setToken, _reserveAsset, _reserveAssetQuantity);
    }

    function getRedeemPremium(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (uint256)
    {
        return _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);
    }

    function getManagerFee(ISetToken _setToken, uint256 _managerFeeIndex) external view returns (uint256) {
        return navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];
    }

    /**
     * Get the expected SetTokens minted to recipient on issuance
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     *
     * @return  uint256                     Expected SetTokens to be minted to recipient
     */
    function getExpectedSetTokenIssueQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (uint256)
    {
        (,, uint256 netReserveFlow) = _getFees(
            _setToken,
            _reserveAssetQuantity,
            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,
            MANAGER_ISSUE_FEE_INDEX
        );

        uint256 setTotalSupply = _setToken.totalSupply();

        return _getSetTokenMintQuantity(
            _setToken,
            _reserveAsset,
            netReserveFlow,
            setTotalSupply
        );
    }

    /**
     * Get the expected reserve asset to be redeemed
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     *
     * @return  uint256                     Expected reserve asset quantity redeemed
     */
    function getExpectedReserveRedeemQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (uint256)
    {
        uint256 preFeeReserveQuantity = _getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

        (,, uint256 netReserveFlows) = _getFees(
            _setToken,
            preFeeReserveQuantity,
            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
            MANAGER_REDEEM_FEE_INDEX
        );

        return netReserveFlows;
    }

    /**
     * Checks if issue is valid
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     *
     * @return  bool                        Returns true if issue is valid
     */
    function isIssueValid(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (bool)
    {
        uint256 setTotalSupply = _setToken.totalSupply();

    return _reserveAssetQuantity != 0
            && isReserveAsset[_setToken][_reserveAsset]
            && setTotalSupply >= navIssuanceSettings[_setToken].minSetTokenSupply;
    }

    /**
     * Checks if redeem is valid
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     *
     * @return  bool                        Returns true if redeem is valid
     */
    function isRedeemValid(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (bool)
    {
        uint256 setTotalSupply = _setToken.totalSupply();

        if (
            _setTokenQuantity == 0
            || !isReserveAsset[_setToken][_reserveAsset]
            || setTotalSupply < navIssuanceSettings[_setToken].minSetTokenSupply.add(_setTokenQuantity)
        ) {
            return false;
        } else {
            uint256 totalRedeemValue =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

            (,, uint256 expectedRedeemQuantity) = _getFees(
                _setToken,
                totalRedeemValue,
                PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
                PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
                MANAGER_REDEEM_FEE_INDEX
            );

            uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();

            return existingUnit.preciseMul(setTotalSupply) >= expectedRedeemQuantity;
        }
    }

    /* ============ Internal Functions ============ */

    function _validateCommon(ISetToken _setToken, address _reserveAsset, uint256 _quantity) internal view {
        require(_quantity > 0, "Quantity must be > 0");
        require(isReserveAsset[_setToken][_reserveAsset], "Must be valid reserve asset");
    }

    function _validateIssuanceInfo(ISetToken _setToken, uint256 _minSetTokenReceiveQuantity, ActionInfo memory _issueInfo) internal view {
        // Check that total supply is greater than min supply needed for issuance
        // Note: A min supply amount is needed to avoid division by 0 when SetToken supply is 0
        require(
            _issueInfo.previousSetTokenSupply >= navIssuanceSettings[_setToken].minSetTokenSupply,
            "Supply must be greater than minimum to enable issuance"
        );

        require(_issueInfo.setTokenQuantity >= _minSetTokenReceiveQuantity, "Must be greater than min SetToken");
    }

    function _validateRedemptionInfo(
        ISetToken _setToken,
        uint256 _minReserveReceiveQuantity,
        ActionInfo memory _redeemInfo
    )
        internal
        view
    {
        // Check that new supply is more than min supply needed for redemption
        // Note: A min supply amount is needed to avoid division by 0 when redeeming SetToken to 0
        require(
            _redeemInfo.newSetTokenSupply >= navIssuanceSettings[_setToken].minSetTokenSupply,
            "Supply must be greater than minimum to enable redemption"
        );

        require(_redeemInfo.netFlowQuantity >= _minReserveReceiveQuantity, "Must be greater than min receive reserve quantity");
    }

    function _createIssuanceInfo(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        internal
        view
        returns (ActionInfo memory)
    {
        ActionInfo memory issueInfo;

        issueInfo.previousSetTokenSupply = _setToken.totalSupply();

        issueInfo.preFeeReserveQuantity = _reserveAssetQuantity;

        (issueInfo.protocolFees, issueInfo.managerFee, issueInfo.netFlowQuantity) = _getFees(
            _setToken,
            issueInfo.preFeeReserveQuantity,
            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,
            MANAGER_ISSUE_FEE_INDEX
        );

        issueInfo.setTokenQuantity = _getSetTokenMintQuantity(
            _setToken,
            _reserveAsset,
            issueInfo.netFlowQuantity,
            issueInfo.previousSetTokenSupply
        );

        (issueInfo.newSetTokenSupply, issueInfo.newPositionMultiplier) = _getIssuePositionMultiplier(_setToken, issueInfo);

        issueInfo.newReservePositionUnit = _getIssuePositionUnit(_setToken, _reserveAsset, issueInfo);

        return issueInfo;
    }

    function _createRedemptionInfo(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        internal
        view
        returns (ActionInfo memory)
    {
        ActionInfo memory redeemInfo;

        redeemInfo.setTokenQuantity = _setTokenQuantity;

        redeemInfo.preFeeReserveQuantity =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

        (redeemInfo.protocolFees, redeemInfo.managerFee, redeemInfo.netFlowQuantity) = _getFees(
            _setToken,
            redeemInfo.preFeeReserveQuantity,
            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
            MANAGER_REDEEM_FEE_INDEX
        );

        redeemInfo.previousSetTokenSupply = _setToken.totalSupply();

        (redeemInfo.newSetTokenSupply, redeemInfo.newPositionMultiplier) = _getRedeemPositionMultiplier(_setToken, _setTokenQuantity, redeemInfo);

        redeemInfo.newReservePositionUnit = _getRedeemPositionUnit(_setToken, _reserveAsset, redeemInfo);

        return redeemInfo;
    }

    /**
     * Transfer reserve asset from user to SetToken and fees from user to appropriate fee recipients
     */
    function _transferCollateralAndHandleFees(ISetToken _setToken, IERC20 _reserveAsset, ActionInfo memory _issueInfo) internal {
        transferFrom(_reserveAsset, msg.sender, address(_setToken), _issueInfo.netFlowQuantity);

        if (_issueInfo.protocolFees > 0) {
            transferFrom(_reserveAsset, msg.sender, controller.feeRecipient(), _issueInfo.protocolFees);
        }

        if (_issueInfo.managerFee > 0) {
            transferFrom(_reserveAsset, msg.sender, navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);
        }
    }


    /**
      * Transfer WETH from module to SetToken and fees from module to appropriate fee recipients
     */
    function _transferWETHAndHandleFees(ISetToken _setToken, ActionInfo memory _issueInfo) internal {
        weth.transfer(address(_setToken), _issueInfo.netFlowQuantity);

        if (_issueInfo.protocolFees > 0) {
            weth.transfer(controller.feeRecipient(), _issueInfo.protocolFees);
        }

        if (_issueInfo.managerFee > 0) {
            weth.transfer(navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);
        }
    }

    function _handleIssueStateUpdates(
        ISetToken _setToken,
        address _reserveAsset,
        address _to,
        ActionInfo memory _issueInfo
    )
        internal
    {
        _setToken.editPositionMultiplier(_issueInfo.newPositionMultiplier);

        _setToken.editDefaultPosition(_reserveAsset, _issueInfo.newReservePositionUnit);

        _setToken.mint(_to, _issueInfo.setTokenQuantity);

        emit SetTokenNAVIssued(
            _setToken,
            msg.sender,
            _to,
            _reserveAsset,
            address(navIssuanceSettings[_setToken].managerIssuanceHook),
            _issueInfo.setTokenQuantity,
            _issueInfo.managerFee,
            _issueInfo.protocolFees
        );
    }

    function _handleRedeemStateUpdates(
        ISetToken _setToken,
        address _reserveAsset,
        address _to,
        ActionInfo memory _redeemInfo
    )
        internal
    {
        _setToken.editPositionMultiplier(_redeemInfo.newPositionMultiplier);

        _setToken.editDefaultPosition(_reserveAsset, _redeemInfo.newReservePositionUnit);

        emit SetTokenNAVRedeemed(
            _setToken,
            msg.sender,
            _to,
            _reserveAsset,
            address(navIssuanceSettings[_setToken].managerRedemptionHook),
            _redeemInfo.setTokenQuantity,
            _redeemInfo.managerFee,
            _redeemInfo.protocolFees
        );
    }

    function _handleRedemptionFees(ISetToken _setToken, address _reserveAsset, ActionInfo memory _redeemInfo) internal {
        // Instruct the SetToken to transfer protocol fee to fee recipient if there is a fee
        payProtocolFeeFromSetToken(_setToken, _reserveAsset, _redeemInfo.protocolFees);

        // Instruct the SetToken to transfer manager fee to manager fee recipient if there is a fee
        if (_redeemInfo.managerFee > 0) {
            _setToken.strictInvokeTransfer(
                _reserveAsset,
                navIssuanceSettings[_setToken].feeRecipient,
                _redeemInfo.managerFee
            );
        }
    }

    /**
     * Returns the issue premium percentage. Virtual function that can be overridden in future versions of the module
     * and can contain arbitrary logic to calculate the issuance premium.
     */
    function _getIssuePremium(
        ISetToken _setToken,
        address /* _reserveAsset */,
        uint256 /* _reserveAssetQuantity */
    )
        virtual
        internal
        view
        returns (uint256)
    {
        return navIssuanceSettings[_setToken].premiumPercentage;
    }

    /**
     * Returns the redeem premium percentage. Virtual function that can be overridden in future versions of the module
     * and can contain arbitrary logic to calculate the redemption premium.
     */
    function _getRedeemPremium(
        ISetToken _setToken,
        address /* _reserveAsset */,
        uint256 /* _setTokenQuantity */
    )
        virtual
        internal
        view
        returns (uint256)
    {
        return navIssuanceSettings[_setToken].premiumPercentage;
    }

    /**
     * Returns the fees attributed to the manager and the protocol. The fees are calculated as follows:
     *
     * ManagerFee = (manager fee % - % to protocol) * reserveAssetQuantity
     * Protocol Fee = (% manager fee share + direct fee %) * reserveAssetQuantity
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAssetQuantity         Quantity of reserve asset to calculate fees from
     * @param _protocolManagerFeeIndex      Index to pull rev share NAV Issuance fee from the Controller
     * @param _protocolDirectFeeIndex       Index to pull direct NAV issuance fee from the Controller
     * @param _managerFeeIndex              Index from NAVIssuanceSettings (0 = issue fee, 1 = redeem fee)
     *
     * @return  uint256                     Fees paid to the protocol in reserve asset
     * @return  uint256                     Fees paid to the manager in reserve asset
     * @return  uint256                     Net reserve to user net of fees
     */
    function _getFees(
        ISetToken _setToken,
        uint256 _reserveAssetQuantity,
        uint256 _protocolManagerFeeIndex,
        uint256 _protocolDirectFeeIndex,
        uint256 _managerFeeIndex
    )
        internal
        view
        returns (uint256, uint256, uint256)
    {
        (uint256 protocolFeePercentage, uint256 managerFeePercentage) = _getProtocolAndManagerFeePercentages(
            _setToken,
            _protocolManagerFeeIndex,
            _protocolDirectFeeIndex,
            _managerFeeIndex
        );

        // Calculate total notional fees
        uint256 protocolFees = protocolFeePercentage.preciseMul(_reserveAssetQuantity);
        uint256 managerFee = managerFeePercentage.preciseMul(_reserveAssetQuantity);

        uint256 netReserveFlow = _reserveAssetQuantity.sub(protocolFees).sub(managerFee);

        return (protocolFees, managerFee, netReserveFlow);
    }

    function _getProtocolAndManagerFeePercentages(
        ISetToken _setToken,
        uint256 _protocolManagerFeeIndex,
        uint256 _protocolDirectFeeIndex,
        uint256 _managerFeeIndex
    )
        internal
        view
        returns(uint256, uint256)
    {
        // Get protocol fee percentages
        uint256 protocolDirectFeePercent = controller.getModuleFee(address(this), _protocolDirectFeeIndex);
        uint256 protocolManagerShareFeePercent = controller.getModuleFee(address(this), _protocolManagerFeeIndex);
        uint256 managerFeePercent = navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];

        // Calculate revenue share split percentage
        uint256 protocolRevenueSharePercentage = protocolManagerShareFeePercent.preciseMul(managerFeePercent);
        uint256 managerRevenueSharePercentage = managerFeePercent.sub(protocolRevenueSharePercentage);
        uint256 totalProtocolFeePercentage = protocolRevenueSharePercentage.add(protocolDirectFeePercent);

        return (totalProtocolFeePercentage, managerRevenueSharePercentage);
    }

    function _getSetTokenMintQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _netReserveFlows,            // Value of reserve asset net of fees
        uint256 _setTotalSupply
    )
        internal
        view
        returns (uint256)
    {
        uint256 premiumPercentage = _getIssuePremium(_setToken, _reserveAsset, _netReserveFlows);
        uint256 premiumValue = _netReserveFlows.preciseMul(premiumPercentage);

        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (1e18)
        // Reverts if price is not found
        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);

        // Get reserve asset decimals
        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();
        uint256 normalizedTotalReserveQuantityNetFees = _netReserveFlows.preciseDiv(10 ** reserveAssetDecimals);
        uint256 normalizedTotalReserveQuantityNetFeesAndPremium = _netReserveFlows.sub(premiumValue).preciseDiv(10 ** reserveAssetDecimals);

        // Calculate SetTokens to mint to issuer
        uint256 denominator = _setTotalSupply.preciseMul(setTokenValuation).add(normalizedTotalReserveQuantityNetFees).sub(normalizedTotalReserveQuantityNetFeesAndPremium);
        return normalizedTotalReserveQuantityNetFeesAndPremium.preciseMul(_setTotalSupply).preciseDiv(denominator);
    }

    function _getRedeemReserveQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        internal
        view
        returns (uint256)
    {
        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (10e18)
        // Reverts if price is not found
        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);

        uint256 totalRedeemValueInPreciseUnits = _setTokenQuantity.preciseMul(setTokenValuation);
        // Get reserve asset decimals
        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();
        uint256 prePremiumReserveQuantity = totalRedeemValueInPreciseUnits.preciseMul(10 ** reserveAssetDecimals);

        uint256 premiumPercentage = _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);
        uint256 premiumQuantity = prePremiumReserveQuantity.preciseMulCeil(premiumPercentage);

        return prePremiumReserveQuantity.sub(premiumQuantity);
    }

    /**
     * The new position multiplier is calculated as follows:
     * inflationPercentage = (newSupply - oldSupply) / newSupply
     * newMultiplier = (1 - inflationPercentage) * positionMultiplier
     */
    function _getIssuePositionMultiplier(
        ISetToken _setToken,
        ActionInfo memory _issueInfo
    )
        internal
        view
        returns (uint256, int256)
    {
        // Calculate inflation and new position multiplier. Note: Round inflation up in order to round position multiplier down
        uint256 newTotalSupply = _issueInfo.setTokenQuantity.add(_issueInfo.previousSetTokenSupply);
        int256 newPositionMultiplier = _setToken.positionMultiplier()
            .mul(_issueInfo.previousSetTokenSupply.toInt256())
            .div(newTotalSupply.toInt256());

        return (newTotalSupply, newPositionMultiplier);
    }

    /**
     * Calculate deflation and new position multiplier. Note: Round deflation down in order to round position multiplier down
     *
     * The new position multiplier is calculated as follows:
     * deflationPercentage = (oldSupply - newSupply) / newSupply
     * newMultiplier = (1 + deflationPercentage) * positionMultiplier
     */
    function _getRedeemPositionMultiplier(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        ActionInfo memory _redeemInfo
    )
        internal
        view
        returns (uint256, int256)
    {
        uint256 newTotalSupply = _redeemInfo.previousSetTokenSupply.sub(_setTokenQuantity);
        int256 newPositionMultiplier = _setToken.positionMultiplier()
            .mul(_redeemInfo.previousSetTokenSupply.toInt256())
            .div(newTotalSupply.toInt256());

        return (newTotalSupply, newPositionMultiplier);
    }

    /**
     * The new position reserve asset unit is calculated as follows:
     * totalReserve = (oldUnit * oldSetTokenSupply) + reserveQuantity
     * newUnit = totalReserve / newSetTokenSupply
     */
    function _getIssuePositionUnit(
        ISetToken _setToken,
        address _reserveAsset,
        ActionInfo memory _issueInfo
    )
        internal
        view
        returns (uint256)
    {
        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();
        uint256 totalReserve = existingUnit
            .preciseMul(_issueInfo.previousSetTokenSupply)
            .add(_issueInfo.netFlowQuantity);

        return totalReserve.preciseDiv(_issueInfo.newSetTokenSupply);
    }

    /**
     * The new position reserve asset unit is calculated as follows:
     * totalReserve = (oldUnit * oldSetTokenSupply) - reserveQuantityToSendOut
     * newUnit = totalReserve / newSetTokenSupply
     */
    function _getRedeemPositionUnit(
        ISetToken _setToken,
        address _reserveAsset,
        ActionInfo memory _redeemInfo
    )
        internal
        view
        returns (uint256)
    {
        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();
        uint256 totalExistingUnits = existingUnit.preciseMul(_redeemInfo.previousSetTokenSupply);

        uint256 outflow = _redeemInfo.netFlowQuantity.add(_redeemInfo.protocolFees).add(_redeemInfo.managerFee);

        // Require withdrawable quantity is greater than existing collateral
        require(totalExistingUnits >= outflow, "Must be greater than total available collateral");

        return totalExistingUnits.sub(outflow).preciseDiv(_redeemInfo.newSetTokenSupply);
    }

    /**
     * If a pre-issue hook has been configured, call the external-protocol contract. Pre-issue hook logic
     * can contain arbitrary logic including validations, external function calls, etc.
     */
    function _callPreIssueHooks(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity,
        address _caller,
        address _to
    )
        internal
    {
        INAVIssuanceHook preIssueHook = navIssuanceSettings[_setToken].managerIssuanceHook;
        if (address(preIssueHook) != address(0)) {
            preIssueHook.invokePreIssueHook(_setToken, _reserveAsset, _reserveAssetQuantity, _caller, _to);
        }
    }

    /**
     * If a pre-redeem hook has been configured, call the external-protocol contract.
     */
    function _callPreRedeemHooks(ISetToken _setToken, uint256 _setQuantity, address _caller, address _to) internal {
        INAVIssuanceHook preRedeemHook = navIssuanceSettings[_setToken].managerRedemptionHook;
        if (address(preRedeemHook) != address(0)) {
            preRedeemHook.invokePreRedeemHook(_setToken, _setQuantity, _caller, _to);
        }
    }
}.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-01-09 05:31:57 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 05:31:57 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 10010
completion_tokens: 867
total_tokens: 10877
cost: $-1.000000


[2024-01-09 05:31:57 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: /*
    Copyright 2020 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";
import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";
import { SignedSafeMath } from "@openzeppelin/contracts/math/SignedSafeMath.sol";

import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";
import { IController } from "../../interfaces/IController.sol";
import { INAVIssuanceHook } from "../../interfaces/INAVIssuanceHook.sol";
import { Invoke } from "../lib/Invoke.sol";
import { ISetToken } from "../../interfaces/ISetToken.sol";
import { IWETH } from "../../interfaces/external/IWETH.sol";
import { ModuleBase } from "../lib/ModuleBase.sol";
import { Position } from "../lib/Position.sol";
import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";
import { ResourceIdentifier } from "../lib/ResourceIdentifier.sol";


/**
 * @title NavIssuanceModule
 * @author Set Protocol
 *
 * Module that enables issuance and redemption with any valid ERC20 token or ETH if allowed by the manager. Sender receives
 * a proportional amount of SetTokens on issuance or ERC20 token on redemption based on the calculated net asset value using
 * oracle prices. Manager is able to enforce a premium / discount on issuance / redemption to avoid arbitrage and front
 * running when relying on oracle prices. Managers can charge a fee (denominated in reserve asset).
 */
contract NavIssuanceModule is ModuleBase, ReentrancyGuard {
    using AddressArrayUtils for address[];
    using Invoke for ISetToken;
    using Position for ISetToken;
    using PreciseUnitMath for uint256;
    using PreciseUnitMath for int256;
    using ResourceIdentifier for IController;
    using SafeMath for uint256;
    using SafeCast for int256;
    using SafeCast for uint256;
    using SignedSafeMath for int256;

    /* ============ Events ============ */

    event SetTokenNAVIssued(
        ISetToken indexed _setToken,
        address _issuer,
        address _to,
        address _reserveAsset,
        address _hookContract,
        uint256 _setTokenQuantity,
        uint256 _managerFee,
        uint256 _premium
    );

    event SetTokenNAVRedeemed(
        ISetToken indexed _setToken,
        address _redeemer,
        address _to,
        address _reserveAsset,
        address _hookContract,
        uint256 _setTokenQuantity,
        uint256 _managerFee,
        uint256 _premium
    );

    event ReserveAssetAdded(
        ISetToken indexed _setToken,
        address _newReserveAsset
    );

    event ReserveAssetRemoved(
        ISetToken indexed _setToken,
        address _removedReserveAsset
    );

    event PremiumEdited(
        ISetToken indexed _setToken,
        uint256 _newPremium
    );

    event ManagerFeeEdited(
        ISetToken indexed _setToken,
        uint256 _newManagerFee,
        uint256 _index
    );

    event FeeRecipientEdited(
        ISetToken indexed _setToken,
        address _feeRecipient
    );

    /* ============ Structs ============ */

    struct NAVIssuanceSettings {
        INAVIssuanceHook managerIssuanceHook;      // Issuance hook configurations
        INAVIssuanceHook managerRedemptionHook;    // Redemption hook configurations
        address[] reserveAssets;                       // Allowed reserve assets - Must have a price enabled with the price oracle
        address feeRecipient;                          // Manager fee recipient
        uint256[2] managerFees;                        // Manager fees. 0 index is issue and 1 index is redeem fee (0.01% = 1e14, 1% = 1e16)
        uint256 maxManagerFee;                         // Maximum fee manager is allowed to set for issue and redeem
        uint256 premiumPercentage;                     // Premium percentage (0.01% = 1e14, 1% = 1e16). This premium is a buffer around oracle
                                                       // prices paid by user to the SetToken, which prevents arbitrage and oracle front running
        uint256 maxPremiumPercentage;                  // Maximum premium percentage manager is allowed to set (configured by manager)
        uint256 minSetTokenSupply;                     // Minimum SetToken supply required for issuance and redemption
                                                       // to prevent dramatic inflationary changes to the SetToken's position multiplier
    }

    struct ActionInfo {
        uint256 preFeeReserveQuantity;                 // Reserve value before fees; During issuance, represents raw quantity
                                                       // During redeem, represents post-premium value
        uint256 protocolFees;                          // Total protocol fees (direct + manager revenue share)
        uint256 managerFee;                            // Total manager fee paid in reserve asset
        uint256 netFlowQuantity;                       // When issuing, quantity of reserve asset sent to SetToken
                                                       // When redeeming, quantity of reserve asset sent to redeemer
        uint256 setTokenQuantity;                      // When issuing, quantity of SetTokens minted to mintee
                                                       // When redeeming, quantity of SetToken redeemed
        uint256 previousSetTokenSupply;                // SetToken supply prior to issue/redeem action
        uint256 newSetTokenSupply;                     // SetToken supply after issue/redeem action
        int256 newPositionMultiplier;                  // SetToken position multiplier after issue/redeem
        uint256 newReservePositionUnit;                // SetToken reserve asset position unit after issue/redeem
    }

    /* ============ State Variables ============ */

    // Wrapped ETH address
    IWETH public immutable weth;

    // Mapping of SetToken to NAV issuance settings struct
    mapping(ISetToken => NAVIssuanceSettings) public navIssuanceSettings;

    // Mapping to efficiently check a SetToken's reserve asset validity
    // SetToken => reserveAsset => isReserveAsset
    mapping(ISetToken => mapping(address => bool)) public isReserveAsset;

    /* ============ Constants ============ */

    // 0 index stores the manager fee in managerFees array, percentage charged on issue (denominated in reserve asset)
    uint256 constant internal MANAGER_ISSUE_FEE_INDEX = 0;

    // 1 index stores the manager fee percentage in managerFees array, charged on redeem
    uint256 constant internal MANAGER_REDEEM_FEE_INDEX = 1;

    // 0 index stores the manager revenue share protocol fee % on the controller, charged in the issuance function
    uint256 constant internal PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX = 0;

    // 1 index stores the manager revenue share protocol fee % on the controller, charged in the redeem function
    uint256 constant internal PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX = 1;

    // 2 index stores the direct protocol fee % on the controller, charged in the issuance function
    uint256 constant internal PROTOCOL_ISSUE_DIRECT_FEE_INDEX = 2;

    // 3 index stores the direct protocol fee % on the controller, charged in the redeem function
    uint256 constant internal PROTOCOL_REDEEM_DIRECT_FEE_INDEX = 3;

    /* ============ Constructor ============ */

    /**
     * @param _controller               Address of controller contract
     * @param _weth                     Address of wrapped eth
     */
    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {
        weth = _weth;
    }

    /* ============ External Functions ============ */

    /**
     * Deposits the allowed reserve asset into the SetToken and mints the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _reserveAsset                 Address of the reserve asset to issue with
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance
     * @param _to                           Address to mint SetToken to
     */
    function issue(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity,
        uint256 _minSetTokenReceiveQuantity,
        address _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, _reserveAsset, _reserveAssetQuantity);

        _callPreIssueHooks(_setToken, _reserveAsset, _reserveAssetQuantity, msg.sender, _to);

        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, _reserveAsset, _reserveAssetQuantity);

        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);

        _transferCollateralAndHandleFees(_setToken, IERC20(_reserveAsset), issueInfo);

        _handleIssueStateUpdates(_setToken, _reserveAsset, _to, issueInfo);
    }

    /**
     * Wraps ETH and deposits WETH if allowed into the SetToken and mints the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance
     * @param _to                           Address to mint SetToken to
     */
    function issueWithEther(
        ISetToken _setToken,
        uint256 _minSetTokenReceiveQuantity,
        address _to
    )
        external
        payable
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        weth.deposit{ value: msg.value }();

        _validateCommon(_setToken, address(weth), msg.value);

        _callPreIssueHooks(_setToken, address(weth), msg.value, msg.sender, _to);

        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, address(weth), msg.value);

        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);

        _transferWETHAndHandleFees(_setToken, issueInfo);

        _handleIssueStateUpdates(_setToken, address(weth), _to, issueInfo);
    }

    /**
     * Redeems a SetToken into a valid reserve asset representing the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address. Only valid if there are available reserve units on the SetToken.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _reserveAsset                 Address of the reserve asset to redeem with
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive
     * @param _to                           Address to redeem reserve asset to
     */
    function redeem(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity,
        uint256 _minReserveReceiveQuantity,
        address _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, _reserveAsset, _setTokenQuantity);

        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);

        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, _reserveAsset, _setTokenQuantity);

        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);

        _setToken.burn(msg.sender, _setTokenQuantity);

        // Instruct the SetToken to transfer the reserve asset back to the user
        _setToken.strictInvokeTransfer(
            _reserveAsset,
            _to,
            redeemInfo.netFlowQuantity
        );

        _handleRedemptionFees(_setToken, _reserveAsset, redeemInfo);

        _handleRedeemStateUpdates(_setToken, _reserveAsset, _to, redeemInfo);
    }

    /**
     * Redeems a SetToken into Ether (if WETH is valid) representing the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address. Only valid if there are available WETH units on the SetToken.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive
     * @param _to                           Address to redeem reserve asset to
     */
    function redeemIntoEther(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        uint256 _minReserveReceiveQuantity,
        address payable _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, address(weth), _setTokenQuantity);

        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);

        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, address(weth), _setTokenQuantity);

        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);

        _setToken.burn(msg.sender, _setTokenQuantity);

        // Instruct the SetToken to transfer WETH from SetToken to module
        _setToken.strictInvokeTransfer(
            address(weth),
            address(this),
            redeemInfo.netFlowQuantity
        );

        weth.withdraw(redeemInfo.netFlowQuantity);

        _to.transfer(redeemInfo.netFlowQuantity);

        _handleRedemptionFees(_setToken, address(weth), redeemInfo);

        _handleRedeemStateUpdates(_setToken, address(weth), _to, redeemInfo);
    }

    /**
     * SET MANAGER ONLY. Add an allowed reserve asset
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset to add
     */
    function addReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {
        require(!isReserveAsset[_setToken][_reserveAsset], "Reserve asset already exists");

        navIssuanceSettings[_setToken].reserveAssets.push(_reserveAsset);
        isReserveAsset[_setToken][_reserveAsset] = true;

        emit ReserveAssetAdded(_setToken, _reserveAsset);
    }

    /**
     * SET MANAGER ONLY. Remove a reserve asset
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset to remove
     */
    function removeReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {
        require(isReserveAsset[_setToken][_reserveAsset], "Reserve asset does not exist");

        navIssuanceSettings[_setToken].reserveAssets = navIssuanceSettings[_setToken].reserveAssets.remove(_reserveAsset);
        delete isReserveAsset[_setToken][_reserveAsset];

        emit ReserveAssetRemoved(_setToken, _reserveAsset);
    }

    /**
     * SET MANAGER ONLY. Edit the premium percentage
     *
     * @param _setToken                     Instance of the SetToken
     * @param _premiumPercentage            Premium percentage in 10e16 (e.g. 10e16 = 1%)
     */
    function editPremium(ISetToken _setToken, uint256 _premiumPercentage) external onlyManagerAndValidSet(_setToken) {
        require(_premiumPercentage <= navIssuanceSettings[_setToken].maxPremiumPercentage, "Premium must be less than maximum allowed");

        navIssuanceSettings[_setToken].premiumPercentage = _premiumPercentage;

        emit PremiumEdited(_setToken, _premiumPercentage);
    }

    /**
     * SET MANAGER ONLY. Edit manager fee
     *
     * @param _setToken                     Instance of the SetToken
     * @param _managerFeePercentage         Manager fee percentage in 10e16 (e.g. 10e16 = 1%)
     * @param _managerFeeIndex              Manager fee index. 0 index is issue fee, 1 index is redeem fee
     */
    function editManagerFee(
        ISetToken _setToken,
        uint256 _managerFeePercentage,
        uint256 _managerFeeIndex
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        require(_managerFeePercentage <= navIssuanceSettings[_setToken].maxManagerFee, "Manager fee must be less than maximum allowed");

        navIssuanceSettings[_setToken].managerFees[_managerFeeIndex] = _managerFeePercentage;

        emit ManagerFeeEdited(_setToken, _managerFeePercentage, _managerFeeIndex);
    }

    /**
     * SET MANAGER ONLY. Edit the manager fee recipient
     *
     * @param _setToken                     Instance of the SetToken
     * @param _managerFeeRecipient          Manager fee recipient
     */
    function editFeeRecipient(ISetToken _setToken, address _managerFeeRecipient) external onlyManagerAndValidSet(_setToken) {
        require(_managerFeeRecipient != address(0), "Fee recipient must not be 0 address");

        navIssuanceSettings[_setToken].feeRecipient = _managerFeeRecipient;

        emit FeeRecipientEdited(_setToken, _managerFeeRecipient);
    }

    /**
     * SET MANAGER ONLY. Initializes this module to the SetToken with hooks, allowed reserve assets,
     * fees and issuance premium. Only callable by the SetToken's manager. Hook addresses are optional.
     * Address(0) means that no hook will be called.
     *
     * @param _setToken                     Instance of the SetToken to issue
     * @param _navIssuanceSettings          NAVIssuanceSettings struct defining parameters
     */
    function initialize(
        ISetToken _setToken,
        NAVIssuanceSettings memory _navIssuanceSettings
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        require(_navIssuanceSettings.reserveAssets.length > 0, "Reserve assets must be greater than 0");
        require(_navIssuanceSettings.maxManagerFee < PreciseUnitMath.preciseUnit(), "Max manager fee must be less than 100%");
        require(_navIssuanceSettings.maxPremiumPercentage < PreciseUnitMath.preciseUnit(), "Max premium percentage must be less than 100%");
        require(_navIssuanceSettings.managerFees[0] <= _navIssuanceSettings.maxManagerFee, "Manager issue fee must be less than max");
        require(_navIssuanceSettings.managerFees[1] <= _navIssuanceSettings.maxManagerFee, "Manager redeem fee must be less than max");
        require(_navIssuanceSettings.premiumPercentage <= _navIssuanceSettings.maxPremiumPercentage, "Premium must be less than max");
        require(_navIssuanceSettings.feeRecipient != address(0), "Fee Recipient must be non-zero address.");
        // Initial mint of Set cannot use NAVIssuance since minSetTokenSupply must be > 0
        require(_navIssuanceSettings.minSetTokenSupply > 0, "Min SetToken supply must be greater than 0");

        for (uint256 i = 0; i < _navIssuanceSettings.reserveAssets.length; i++) {
            require(!isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]], "Reserve assets must be unique");
            isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]] = true;
        }

        navIssuanceSettings[_setToken] = _navIssuanceSettings;

        _setToken.initializeModule();
    }

    /**
     * Removes this module from the SetToken, via call by the SetToken. Issuance settings and
     * reserve asset states are deleted.
     */
    function removeModule() external override {
        ISetToken setToken = ISetToken(msg.sender);
        for (uint256 i = 0; i < navIssuanceSettings[setToken].reserveAssets.length; i++) {
            delete isReserveAsset[setToken][navIssuanceSettings[setToken].reserveAssets[i]];
        }

        delete navIssuanceSettings[setToken];
    }

    receive() external payable {}

    /* ============ External Getter Functions ============ */

    function getReserveAssets(ISetToken _setToken) external view returns (address[] memory) {
        return navIssuanceSettings[_setToken].reserveAssets;
    }

    function getIssuePremium(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (uint256)
    {
        return _getIssuePremium(_setToken, _reserveAsset, _reserveAssetQuantity);
    }

    function getRedeemPremium(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (uint256)
    {
        return _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);
    }

    function getManagerFee(ISetToken _setToken, uint256 _managerFeeIndex) external view returns (uint256) {
        return navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];
    }

    /**
     * Get the expected SetTokens minted to recipient on issuance
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     *
     * @return  uint256                     Expected SetTokens to be minted to recipient
     */
    function getExpectedSetTokenIssueQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (uint256)
    {
        (,, uint256 netReserveFlow) = _getFees(
            _setToken,
            _reserveAssetQuantity,
            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,
            MANAGER_ISSUE_FEE_INDEX
        );

        uint256 setTotalSupply = _setToken.totalSupply();

        return _getSetTokenMintQuantity(
            _setToken,
            _reserveAsset,
            netReserveFlow,
            setTotalSupply
        );
    }

    /**
     * Get the expected reserve asset to be redeemed
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     *
     * @return  uint256                     Expected reserve asset quantity redeemed
     */
    function getExpectedReserveRedeemQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (uint256)
    {
        uint256 preFeeReserveQuantity = _getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

        (,, uint256 netReserveFlows) = _getFees(
            _setToken,
            preFeeReserveQuantity,
            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
            MANAGER_REDEEM_FEE_INDEX
        );

        return netReserveFlows;
    }

    /**
     * Checks if issue is valid
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     *
     * @return  bool                        Returns true if issue is valid
     */
    function isIssueValid(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (bool)
    {
        uint256 setTotalSupply = _setToken.totalSupply();

    return _reserveAssetQuantity != 0
            && isReserveAsset[_setToken][_reserveAsset]
            && setTotalSupply >= navIssuanceSettings[_setToken].minSetTokenSupply;
    }

    /**
     * Checks if redeem is valid
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     *
     * @return  bool                        Returns true if redeem is valid
     */
    function isRedeemValid(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (bool)
    {
        uint256 setTotalSupply = _setToken.totalSupply();

        if (
            _setTokenQuantity == 0
            || !isReserveAsset[_setToken][_reserveAsset]
            || setTotalSupply < navIssuanceSettings[_setToken].minSetTokenSupply.add(_setTokenQuantity)
        ) {
            return false;
        } else {
            uint256 totalRedeemValue =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

            (,, uint256 expectedRedeemQuantity) = _getFees(
                _setToken,
                totalRedeemValue,
                PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
                PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
                MANAGER_REDEEM_FEE_INDEX
            );

            uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();

            return existingUnit.preciseMul(setTotalSupply) >= expectedRedeemQuantity;
        }
    }

    /* ============ Internal Functions ============ */

    function _validateCommon(ISetToken _setToken, address _reserveAsset, uint256 _quantity) internal view {
        require(_quantity > 0, "Quantity must be > 0");
        require(isReserveAsset[_setToken][_reserveAsset], "Must be valid reserve asset");
    }

    function _validateIssuanceInfo(ISetToken _setToken, uint256 _minSetTokenReceiveQuantity, ActionInfo memory _issueInfo) internal view {
        // Check that total supply is greater than min supply needed for issuance
        // Note: A min supply amount is needed to avoid division by 0 when SetToken supply is 0
        require(
            _issueInfo.previousSetTokenSupply >= navIssuanceSettings[_setToken].minSetTokenSupply,
            "Supply must be greater than minimum to enable issuance"
        );

        require(_issueInfo.setTokenQuantity >= _minSetTokenReceiveQuantity, "Must be greater than min SetToken");
    }

    function _validateRedemptionInfo(
        ISetToken _setToken,
        uint256 _minReserveReceiveQuantity,
        ActionInfo memory _redeemInfo
    )
        internal
        view
    {
        // Check that new supply is more than min supply needed for redemption
        // Note: A min supply amount is needed to avoid division by 0 when redeeming SetToken to 0
        require(
            _redeemInfo.newSetTokenSupply >= navIssuanceSettings[_setToken].minSetTokenSupply,
            "Supply must be greater than minimum to enable redemption"
        );

        require(_redeemInfo.netFlowQuantity >= _minReserveReceiveQuantity, "Must be greater than min receive reserve quantity");
    }

    function _createIssuanceInfo(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        internal
        view
        returns (ActionInfo memory)
    {
        ActionInfo memory issueInfo;

        issueInfo.previousSetTokenSupply = _setToken.totalSupply();

        issueInfo.preFeeReserveQuantity = _reserveAssetQuantity;

        (issueInfo.protocolFees, issueInfo.managerFee, issueInfo.netFlowQuantity) = _getFees(
            _setToken,
            issueInfo.preFeeReserveQuantity,
            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,
            MANAGER_ISSUE_FEE_INDEX
        );

        issueInfo.setTokenQuantity = _getSetTokenMintQuantity(
            _setToken,
            _reserveAsset,
            issueInfo.netFlowQuantity,
            issueInfo.previousSetTokenSupply
        );

        (issueInfo.newSetTokenSupply, issueInfo.newPositionMultiplier) = _getIssuePositionMultiplier(_setToken, issueInfo);

        issueInfo.newReservePositionUnit = _getIssuePositionUnit(_setToken, _reserveAsset, issueInfo);

        return issueInfo;
    }

    function _createRedemptionInfo(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        internal
        view
        returns (ActionInfo memory)
    {
        ActionInfo memory redeemInfo;

        redeemInfo.setTokenQuantity = _setTokenQuantity;

        redeemInfo.preFeeReserveQuantity =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

        (redeemInfo.protocolFees, redeemInfo.managerFee, redeemInfo.netFlowQuantity) = _getFees(
            _setToken,
            redeemInfo.preFeeReserveQuantity,
            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
            MANAGER_REDEEM_FEE_INDEX
        );

        redeemInfo.previousSetTokenSupply = _setToken.totalSupply();

        (redeemInfo.newSetTokenSupply, redeemInfo.newPositionMultiplier) = _getRedeemPositionMultiplier(_setToken, _setTokenQuantity, redeemInfo);

        redeemInfo.newReservePositionUnit = _getRedeemPositionUnit(_setToken, _reserveAsset, redeemInfo);

        return redeemInfo;
    }

    /**
     * Transfer reserve asset from user to SetToken and fees from user to appropriate fee recipients
     */
    function _transferCollateralAndHandleFees(ISetToken _setToken, IERC20 _reserveAsset, ActionInfo memory _issueInfo) internal {
        transferFrom(_reserveAsset, msg.sender, address(_setToken), _issueInfo.netFlowQuantity);

        if (_issueInfo.protocolFees > 0) {
            transferFrom(_reserveAsset, msg.sender, controller.feeRecipient(), _issueInfo.protocolFees);
        }

        if (_issueInfo.managerFee > 0) {
            transferFrom(_reserveAsset, msg.sender, navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);
        }
    }


    /**
      * Transfer WETH from module to SetToken and fees from module to appropriate fee recipients
     */
    function _transferWETHAndHandleFees(ISetToken _setToken, ActionInfo memory _issueInfo) internal {
        weth.transfer(address(_setToken), _issueInfo.netFlowQuantity);

        if (_issueInfo.protocolFees > 0) {
            weth.transfer(controller.feeRecipient(), _issueInfo.protocolFees);
        }

        if (_issueInfo.managerFee > 0) {
            weth.transfer(navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);
        }
    }

    function _handleIssueStateUpdates(
        ISetToken _setToken,
        address _reserveAsset,
        address _to,
        ActionInfo memory _issueInfo
    )
        internal
    {
        _setToken.editPositionMultiplier(_issueInfo.newPositionMultiplier);

        _setToken.editDefaultPosition(_reserveAsset, _issueInfo.newReservePositionUnit);

        _setToken.mint(_to, _issueInfo.setTokenQuantity);

        emit SetTokenNAVIssued(
            _setToken,
            msg.sender,
            _to,
            _reserveAsset,
            address(navIssuanceSettings[_setToken].managerIssuanceHook),
            _issueInfo.setTokenQuantity,
            _issueInfo.managerFee,
            _issueInfo.protocolFees
        );
    }

    function _handleRedeemStateUpdates(
        ISetToken _setToken,
        address _reserveAsset,
        address _to,
        ActionInfo memory _redeemInfo
    )
        internal
    {
        _setToken.editPositionMultiplier(_redeemInfo.newPositionMultiplier);

        _setToken.editDefaultPosition(_reserveAsset, _redeemInfo.newReservePositionUnit);

        emit SetTokenNAVRedeemed(
            _setToken,
            msg.sender,
            _to,
            _reserveAsset,
            address(navIssuanceSettings[_setToken].managerRedemptionHook),
            _redeemInfo.setTokenQuantity,
            _redeemInfo.managerFee,
            _redeemInfo.protocolFees
        );
    }

    function _handleRedemptionFees(ISetToken _setToken, address _reserveAsset, ActionInfo memory _redeemInfo) internal {
        // Instruct the SetToken to transfer protocol fee to fee recipient if there is a fee
        payProtocolFeeFromSetToken(_setToken, _reserveAsset, _redeemInfo.protocolFees);

        // Instruct the SetToken to transfer manager fee to manager fee recipient if there is a fee
        if (_redeemInfo.managerFee > 0) {
            _setToken.strictInvokeTransfer(
                _reserveAsset,
                navIssuanceSettings[_setToken].feeRecipient,
                _redeemInfo.managerFee
            );
        }
    }

    /**
     * Returns the issue premium percentage. Virtual function that can be overridden in future versions of the module
     * and can contain arbitrary logic to calculate the issuance premium.
     */
    function _getIssuePremium(
        ISetToken _setToken,
        address /* _reserveAsset */,
        uint256 /* _reserveAssetQuantity */
    )
        virtual
        internal
        view
        returns (uint256)
    {
        return navIssuanceSettings[_setToken].premiumPercentage;
    }

    /**
     * Returns the redeem premium percentage. Virtual function that can be overridden in future versions of the module
     * and can contain arbitrary logic to calculate the redemption premium.
     */
    function _getRedeemPremium(
        ISetToken _setToken,
        address /* _reserveAsset */,
        uint256 /* _setTokenQuantity */
    )
        virtual
        internal
        view
        returns (uint256)
    {
        return navIssuanceSettings[_setToken].premiumPercentage;
    }

    /**
     * Returns the fees attributed to the manager and the protocol. The fees are calculated as follows:
     *
     * ManagerFee = (manager fee % - % to protocol) * reserveAssetQuantity
     * Protocol Fee = (% manager fee share + direct fee %) * reserveAssetQuantity
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAssetQuantity         Quantity of reserve asset to calculate fees from
     * @param _protocolManagerFeeIndex      Index to pull rev share NAV Issuance fee from the Controller
     * @param _protocolDirectFeeIndex       Index to pull direct NAV issuance fee from the Controller
     * @param _managerFeeIndex              Index from NAVIssuanceSettings (0 = issue fee, 1 = redeem fee)
     *
     * @return  uint256                     Fees paid to the protocol in reserve asset
     * @return  uint256                     Fees paid to the manager in reserve asset
     * @return  uint256                     Net reserve to user net of fees
     */
    function _getFees(
        ISetToken _setToken,
        uint256 _reserveAssetQuantity,
        uint256 _protocolManagerFeeIndex,
        uint256 _protocolDirectFeeIndex,
        uint256 _managerFeeIndex
    )
        internal
        view
        returns (uint256, uint256, uint256)
    {
        (uint256 protocolFeePercentage, uint256 managerFeePercentage) = _getProtocolAndManagerFeePercentages(
            _setToken,
            _protocolManagerFeeIndex,
            _protocolDirectFeeIndex,
            _managerFeeIndex
        );

        // Calculate total notional fees
        uint256 protocolFees = protocolFeePercentage.preciseMul(_reserveAssetQuantity);
        uint256 managerFee = managerFeePercentage.preciseMul(_reserveAssetQuantity);

        uint256 netReserveFlow = _reserveAssetQuantity.sub(protocolFees).sub(managerFee);

        return (protocolFees, managerFee, netReserveFlow);
    }

    function _getProtocolAndManagerFeePercentages(
        ISetToken _setToken,
        uint256 _protocolManagerFeeIndex,
        uint256 _protocolDirectFeeIndex,
        uint256 _managerFeeIndex
    )
        internal
        view
        returns(uint256, uint256)
    {
        // Get protocol fee percentages
        uint256 protocolDirectFeePercent = controller.getModuleFee(address(this), _protocolDirectFeeIndex);
        uint256 protocolManagerShareFeePercent = controller.getModuleFee(address(this), _protocolManagerFeeIndex);
        uint256 managerFeePercent = navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];

        // Calculate revenue share split percentage
        uint256 protocolRevenueSharePercentage = protocolManagerShareFeePercent.preciseMul(managerFeePercent);
        uint256 managerRevenueSharePercentage = managerFeePercent.sub(protocolRevenueSharePercentage);
        uint256 totalProtocolFeePercentage = protocolRevenueSharePercentage.add(protocolDirectFeePercent);

        return (totalProtocolFeePercentage, managerRevenueSharePercentage);
    }

    function _getSetTokenMintQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _netReserveFlows,            // Value of reserve asset net of fees
        uint256 _setTotalSupply
    )
        internal
        view
        returns (uint256)
    {
        uint256 premiumPercentage = _getIssuePremium(_setToken, _reserveAsset, _netReserveFlows);
        uint256 premiumValue = _netReserveFlows.preciseMul(premiumPercentage);

        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (1e18)
        // Reverts if price is not found
        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);

        // Get reserve asset decimals
        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();
        uint256 normalizedTotalReserveQuantityNetFees = _netReserveFlows.preciseDiv(10 ** reserveAssetDecimals);
        uint256 normalizedTotalReserveQuantityNetFeesAndPremium = _netReserveFlows.sub(premiumValue).preciseDiv(10 ** reserveAssetDecimals);

        // Calculate SetTokens to mint to issuer
        uint256 denominator = _setTotalSupply.preciseMul(setTokenValuation).add(normalizedTotalReserveQuantityNetFees).sub(normalizedTotalReserveQuantityNetFeesAndPremium);
        return normalizedTotalReserveQuantityNetFeesAndPremium.preciseMul(_setTotalSupply).preciseDiv(denominator);
    }

    function _getRedeemReserveQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        internal
        view
        returns (uint256)
    {
        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (10e18)
        // Reverts if price is not found
        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);

        uint256 totalRedeemValueInPreciseUnits = _setTokenQuantity.preciseMul(setTokenValuation);
        // Get reserve asset decimals
        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();
        uint256 prePremiumReserveQuantity = totalRedeemValueInPreciseUnits.preciseMul(10 ** reserveAssetDecimals);

        uint256 premiumPercentage = _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);
        uint256 premiumQuantity = prePremiumReserveQuantity.preciseMulCeil(premiumPercentage);

        return prePremiumReserveQuantity.sub(premiumQuantity);
    }

    /**
     * The new position multiplier is calculated as follows:
     * inflationPercentage = (newSupply - oldSupply) / newSupply
     * newMultiplier = (1 - inflationPercentage) * positionMultiplier
     */
    function _getIssuePositionMultiplier(
        ISetToken _setToken,
        ActionInfo memory _issueInfo
    )
        internal
        view
        returns (uint256, int256)
    {
        // Calculate inflation and new position multiplier. Note: Round inflation up in order to round position multiplier down
        uint256 newTotalSupply = _issueInfo.setTokenQuantity.add(_issueInfo.previousSetTokenSupply);
        int256 newPositionMultiplier = _setToken.positionMultiplier()
            .mul(_issueInfo.previousSetTokenSupply.toInt256())
            .div(newTotalSupply.toInt256());

        return (newTotalSupply, newPositionMultiplier);
    }

    /**
     * Calculate deflation and new position multiplier. Note: Round deflation down in order to round position multiplier down
     *
     * The new position multiplier is calculated as follows:
     * deflationPercentage = (oldSupply - newSupply) / newSupply
     * newMultiplier = (1 + deflationPercentage) * positionMultiplier
     */
    function _getRedeemPositionMultiplier(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        ActionInfo memory _redeemInfo
    )
        internal
        view
        returns (uint256, int256)
    {
        uint256 newTotalSupply = _redeemInfo.previousSetTokenSupply.sub(_setTokenQuantity);
        int256 newPositionMultiplier = _setToken.positionMultiplier()
            .mul(_redeemInfo.previousSetTokenSupply.toInt256())
            .div(newTotalSupply.toInt256());

        return (newTotalSupply, newPositionMultiplier);
    }

    /**
     * The new position reserve asset unit is calculated as follows:
     * totalReserve = (oldUnit * oldSetTokenSupply) + reserveQuantity
     * newUnit = totalReserve / newSetTokenSupply
     */
    function _getIssuePositionUnit(
        ISetToken _setToken,
        address _reserveAsset,
        ActionInfo memory _issueInfo
    )
        internal
        view
        returns (uint256)
    {
        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();
        uint256 totalReserve = existingUnit
            .preciseMul(_issueInfo.previousSetTokenSupply)
            .add(_issueInfo.netFlowQuantity);

        return totalReserve.preciseDiv(_issueInfo.newSetTokenSupply);
    }

    /**
     * The new position reserve asset unit is calculated as follows:
     * totalReserve = (oldUnit * oldSetTokenSupply) - reserveQuantityToSendOut
     * newUnit = totalReserve / newSetTokenSupply
     */
    function _getRedeemPositionUnit(
        ISetToken _setToken,
        address _reserveAsset,
        ActionInfo memory _redeemInfo
    )
        internal
        view
        returns (uint256)
    {
        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();
        uint256 totalExistingUnits = existingUnit.preciseMul(_redeemInfo.previousSetTokenSupply);

        uint256 outflow = _redeemInfo.netFlowQuantity.add(_redeemInfo.protocolFees).add(_redeemInfo.managerFee);

        // Require withdrawable quantity is greater than existing collateral
        require(totalExistingUnits >= outflow, "Must be greater than total available collateral");

        return totalExistingUnits.sub(outflow).preciseDiv(_redeemInfo.newSetTokenSupply);
    }

    /**
     * If a pre-issue hook has been configured, call the external-protocol contract. Pre-issue hook logic
     * can contain arbitrary logic including validations, external function calls, etc.
     */
    function _callPreIssueHooks(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity,
        address _caller,
        address _to
    )
        internal
    {
        INAVIssuanceHook preIssueHook = navIssuanceSettings[_setToken].managerIssuanceHook;
        if (address(preIssueHook) != address(0)) {
            preIssueHook.invokePreIssueHook(_setToken, _reserveAsset, _reserveAssetQuantity, _caller, _to);
        }
    }

    /**
     * If a pre-redeem hook has been configured, call the external-protocol contract.
     */
    function _callPreRedeemHooks(ISetToken _setToken, uint256 _setQuantity, address _caller, address _to) internal {
        INAVIssuanceHook preRedeemHook = navIssuanceSettings[_setToken].managerRedemptionHook;
        if (address(preRedeemHook) != address(0)) {
            preRedeemHook.invokePreRedeemHook(_setToken, _setQuantity, _caller, _to);
        }
    }
}.]

### Summary of Security Vulnerabilities in the NavIssuanceModule Contract

1. **Reentrancy Vulnerability**:
   - Although the contract uses `ReentrancyGuard`, there are multiple external calls (e.g., `_setToken.strictInvokeTransfer`, `weth.transfer`) that could potentially lead to reentrancy attacks if not properly managed. Care should be taken to ensure that state changes occur before external calls.

2. **Lack of Input Validation**:
   - Functions like `addReserveAsset` and `removeReserveAsset` do not sufficiently validate the reserve asset addresses. There should be checks to ensure that the address is a valid ERC20 token and not a zero address.

3. **Potential for Integer Overflow/Underflow**:
   - While the contract uses SafeMath, it is crucial to ensure that all arithmetic operations are properly handled. The use of `SafeMath` is good practice, but developers should remain vigilant about any manual arithmetic that might bypass these protections.

4. **Access Control Issues**:
   - The contract relies on modifiers like `onlyManagerAndValidSet` and `onlySetManager`, but there could be scenarios where unauthorized users might gain access to sensitive functions if the access control logic is not thoroughly tested.

5. **Gas Limit Issues**:
   - The `initialize` function contains a loop that checks for unique reserve assets. If the number of reserve assets is large, this could lead to exceeding the gas limit, causing the transaction to fail.

6. **Event Emission**:
   - While the contract emits events for significant actions, there may be cases where events are not emitted for all state-changing operations, which could hinder tracking and auditing of contract activity.

7. **Potential for Price Manipulation**:
   - The reliance on external price oracles for valuation could expose the contract to price manipulation attacks if the oracle is not secure or if the price feeds can be manipulated.

8. **Lack of Fallback Function Security**:
   - The contract has a `receive()` function but does not implement any checks or restrictions on the amount of Ether that can be sent to it. This could lead to unexpected behavior if large amounts of Ether are sent inadvertently.

### Comprehensive Analysis Report

The `NavIssuanceModule` contract is a complex smart contract that facilitates the issuance and redemption of SetTokens using various reserve assets. While it incorporates several best practices, including the use of SafeMath and ReentrancyGuard, there are notable security vulnerabilities that need to be addressed to ensure the integrity and security of the contract.

1. **Reentrancy Protection**: The use of `ReentrancyGuard` is a positive aspect; however, developers must ensure that all state changes occur before any external calls to mitigate the risk of reentrancy attacks effectively.

2. **Input Validation**: Enhanced input validation is necessary to prevent invalid addresses from being added as reserve assets. Implementing checks for valid ERC20 tokens and ensuring that addresses are not zero will strengthen the contract's security.

3. **Arithmetic Operations**: Although SafeMath is employed, developers should remain vigilant about potential overflow/underflow issues, especially in complex calculations.

4. **Access Control**: The access control mechanisms should be rigorously tested to prevent unauthorized access to critical functions. Implementing role-based access control could further enhance security.

5. **Gas Limit Considerations**: The design of functions that involve loops should consider the potential for exceeding gas limits, especially in scenarios with numerous reserve assets.

6. **Event Emission**: Comprehensive event logging for all state changes will improve transparency and facilitate better tracking of contract interactions.

7. **Oracle Dependency**: The reliance on external price oracles introduces a risk of manipulation. It is crucial to ensure that the oracles used are secure and resistant to attacks.

8. **Fallback Function Security**: Implementing restrictions on the `receive()` function will prevent unexpected behavior from large Ether transfers.

In conclusion, while the `NavIssuanceModule` contract demonstrates a solid foundation for managing SetToken issuance and redemption, addressing the identified vulnerabilities is essential for enhancing its security posture. A thorough audit and testing process, along with the implementation of best practices, will help mitigate risks and ensure the contract operates securely in a production environment.

[2024-01-09 05:31:57 INFO] **[Seminar Conclusion]**:

 ### Summary of Security Vulnerabilities in the NavIssuanceModule Contract

1. **Reentrancy Vulnerability**:
   - Although the contract uses `ReentrancyGuard`, there are multiple external calls (e.g., `_setToken.strictInvokeTransfer`, `weth.transfer`) that could potentially lead to reentrancy attacks if not properly managed. Care should be taken to ensure that state changes occur before external calls.

2. **Lack of Input Validation**:
   - Functions like `addReserveAsset` and `removeReserveAsset` do not sufficiently validate the reserve asset addresses. There should be checks to ensure that the address is a valid ERC20 token and not a zero address.

3. **Potential for Integer Overflow/Underflow**:
   - While the contract uses SafeMath, it is crucial to ensure that all arithmetic operations are properly handled. The use of `SafeMath` is good practice, but developers should remain vigilant about any manual arithmetic that might bypass these protections.

4. **Access Control Issues**:
   - The contract relies on modifiers like `onlyManagerAndValidSet` and `onlySetManager`, but there could be scenarios where unauthorized users might gain access to sensitive functions if the access control logic is not thoroughly tested.

5. **Gas Limit Issues**:
   - The `initialize` function contains a loop that checks for unique reserve assets. If the number of reserve assets is large, this could lead to exceeding the gas limit, causing the transaction to fail.

6. **Event Emission**:
   - While the contract emits events for significant actions, there may be cases where events are not emitted for all state-changing operations, which could hinder tracking and auditing of contract activity.

7. **Potential for Price Manipulation**:
   - The reliance on external price oracles for valuation could expose the contract to price manipulation attacks if the oracle is not secure or if the price feeds can be manipulated.

8. **Lack of Fallback Function Security**:
   - The contract has a `receive()` function but does not implement any checks or restrictions on the amount of Ether that can be sent to it. This could lead to unexpected behavior if large amounts of Ether are sent inadvertently.

### Comprehensive Analysis Report

The `NavIssuanceModule` contract is a complex smart contract that facilitates the issuance and redemption of SetTokens using various reserve assets. While it incorporates several best practices, including the use of SafeMath and ReentrancyGuard, there are notable security vulnerabilities that need to be addressed to ensure the integrity and security of the contract.

1. **Reentrancy Protection**: The use of `ReentrancyGuard` is a positive aspect; however, developers must ensure that all state changes occur before any external calls to mitigate the risk of reentrancy attacks effectively.

2. **Input Validation**: Enhanced input validation is necessary to prevent invalid addresses from being added as reserve assets. Implementing checks for valid ERC20 tokens and ensuring that addresses are not zero will strengthen the contract's security.

3. **Arithmetic Operations**: Although SafeMath is employed, developers should remain vigilant about potential overflow/underflow issues, especially in complex calculations.

4. **Access Control**: The access control mechanisms should be rigorously tested to prevent unauthorized access to critical functions. Implementing role-based access control could further enhance security.

5. **Gas Limit Considerations**: The design of functions that involve loops should consider the potential for exceeding gas limits, especially in scenarios with numerous reserve assets.

6. **Event Emission**: Comprehensive event logging for all state changes will improve transparency and facilitate better tracking of contract interactions.

7. **Oracle Dependency**: The reliance on external price oracles introduces a risk of manipulation. It is crucial to ensure that the oracles used are secure and resistant to attacks.

8. **Fallback Function Security**: Implementing restrictions on the `receive()` function will prevent unexpected behavior from large Ether transfers.

In conclusion, while the `NavIssuanceModule` contract demonstrates a solid foundation for managing SetToken issuance and redemption, addressing the identified vulnerabilities is essential for enhancing its security posture. A thorough audit and testing process, along with the implementation of best practices, will help mitigate risks and ensure the contract operates securely in a production environment.

[2024-01-09 05:32:00 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /*     Copyright 2020 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol"; import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol"; import { SignedSafeMath } from "@openzeppelin/contracts/math/SignedSafeMath.sol"; import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol"; import { IController } from "../../interfaces/IController.sol"; import { INAVIssuanceHook } from "../../interfaces/INAVIssuanceHook.sol"; import { Invoke } from "../lib/Invoke.sol"; import { ISetToken } from "../../interfaces/ISetToken.sol"; import { IWETH } from "../../interfaces/external/IWETH.sol"; import { ModuleBase } from "../lib/ModuleBase.sol"; import { Position } from "../lib/Position.sol"; import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol"; import { ResourceIdentifier } from "../lib/ResourceIdentifier.sol"; /*  * @title NavIssuanceModule  * @author Set Protocol  *  * Module that enables issuance and redemption with any valid ERC20 token or ETH if allowed by the manager. Sender receives  * a proportional amount of SetTokens on issuance or ERC20 token on redemption based on the calculated net asset value using  * oracle prices. Manager is able to enforce a premium / discount on issuance / redemption to avoid arbitrage and front  * running when relying on oracle prices. Managers can charge a fee (denominated in reserve asset).  / contract NavIssuanceModule is ModuleBase, ReentrancyGuard {     using AddressArrayUtils for address[];     using Invoke for ISetToken;     using Position for ISetToken;     using PreciseUnitMath for uint256;     using PreciseUnitMath for int256;     using ResourceIdentifier for IController;     using SafeMath for uint256;     using SafeCast for int256;     using SafeCast for uint256;     using SignedSafeMath for int256; /* ============ Events ============ */  event SetTokenNAVIssued(     ISetToken indexed _setToken,     address _issuer,     address _to,     address _reserveAsset,     address _hookContract,     uint256 _setTokenQuantity,     uint256 _managerFee,     uint256 _premium );  event SetTokenNAVRedeemed(     ISetToken indexed _setToken,     address _redeemer,     address _to,     address _reserveAsset,     address _hookContract,     uint256 _setTokenQuantity,     uint256 _managerFee,     uint256 _premium );  event ReserveAssetAdded(     ISetToken indexed _setToken,     address _newReserveAsset );  event ReserveAssetRemoved(     ISetToken indexed _setToken,     address _removedReserveAsset );  event PremiumEdited(     ISetToken indexed _setToken,     uint256 _newPremium );  event ManagerFeeEdited(     ISetToken indexed _setToken,     uint256 _newManagerFee,     uint256 _index );  event FeeRecipientEdited(     ISetToken indexed _setToken,     address _feeRecipient );  /* ============ Structs ============ */  struct NAVIssuanceSettings {     INAVIssuanceHook managerIssuanceHook;      // Issuance hook configurations     INAVIssuanceHook managerRedemptionHook;    // Redemption hook configurations     address[] reserveAssets;                       // Allowed reserve assets - Must have a price enabled with the price oracle     address feeRecipient;                          // Manager fee recipient     uint256[2] managerFees;                        // Manager fees. 0 index is issue and 1 index is redeem fee (0.01% = 1e14, 1% = 1e16)     uint256 maxManagerFee;                         // Maximum fee manager is allowed to set for issue and redeem     uint256 premiumPercentage;                     // Premium percentage (0.01% = 1e14, 1% = 1e16). This premium is a buffer around oracle                                                    // prices paid by user to the SetToken, which prevents arbitrage and oracle front running     uint256 maxPremiumPercentage;                  // Maximum premium percentage manager is allowed to set (configured by manager)     uint256 minSetTokenSupply;                     // Minimum SetToken supply required for issuance and redemption                                                    // to prevent dramatic inflationary changes to the SetToken's position multiplier }  struct ActionInfo {     uint256 preFeeReserveQuantity;                 // Reserve value before fees; During issuance, represents raw quantity                                                    // During redeem, represents post-premium value     uint256 protocolFees;                          // Total protocol fees (direct + manager revenue share)     uint256 managerFee;                            // Total manager fee paid in reserve asset     uint256 netFlowQuantity;                       // When issuing, quantity of reserve asset sent to SetToken                                                    // When redeeming, quantity of reserve asset sent to redeemer     uint256 setTokenQuantity;                      // When issuing, quantity of SetTokens minted to mintee                                                    // When redeeming, quantity of SetToken redeemed     uint256 previousSetTokenSupply;                // SetToken supply prior to issue/redeem action     uint256 newSetTokenSupply;                     // SetToken supply after issue/redeem action     int256 newPositionMultiplier;                  // SetToken position multiplier after issue/redeem     uint256 newReservePositionUnit;                // SetToken reserve asset position unit after issue/redeem }  /* ============ State Variables ============ */  // Wrapped ETH address IWETH public immutable weth;  // Mapping of SetToken to NAV issuance settings struct mapping(ISetToken =&gt; NAVIssuanceSettings) public navIssuanceSettings;  // Mapping to efficiently check a SetToken's reserve asset validity // SetToken =&gt; reserveAsset =&gt; isReserveAsset mapping(ISetToken =&gt; mapping(address =&gt; bool)) public isReserveAsset;  /* ============ Constants ============ */  // 0 index stores the manager fee in managerFees array, percentage charged on issue (denominated in reserve asset) uint256 constant internal MANAGER_ISSUE_FEE_INDEX = 0;  // 1 index stores the manager fee percentage in managerFees array, charged on redeem uint256 constant internal MANAGER_REDEEM_FEE_INDEX = 1;  // 0 index stores the manager revenue share protocol fee % on the controller, charged in the issuance function uint256 constant internal PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX = 0;  // 1 index stores the manager revenue share protocol fee % on the controller, charged in the redeem function uint256 constant internal PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX = 1;  // 2 index stores the direct protocol fee % on the controller, charged in the issuance function uint256 constant internal PROTOCOL_ISSUE_DIRECT_FEE_INDEX = 2;  // 3 index stores the direct protocol fee % on the controller, charged in the redeem function uint256 constant internal PROTOCOL_REDEEM_DIRECT_FEE_INDEX = 3;  /* ============ Constructor ============ */  /**  * @param _controller               Address of controller contract  * @param _weth                     Address of wrapped eth  */ constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {     weth = _weth; }  /* ============ External Functions ============ */  /**  * Deposits the allowed reserve asset into the SetToken and mints the appropriate % of Net Asset Value of the SetToken  * to the specified _to address.  *  * @param _setToken                     Instance of the SetToken contract  * @param _reserveAsset                 Address of the reserve asset to issue with  * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with  * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance  * @param _to                           Address to mint SetToken to  */ function issue(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity,     uint256 _minSetTokenReceiveQuantity,     address _to )     external     nonReentrant     onlyValidAndInitializedSet(_setToken) {     _validateCommon(_setToken, _reserveAsset, _reserveAssetQuantity);      _callPreIssueHooks(_setToken, _reserveAsset, _reserveAssetQuantity, msg.sender, _to);      ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, _reserveAsset, _reserveAssetQuantity);      _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);      _transferCollateralAndHandleFees(_setToken, IERC20(_reserveAsset), issueInfo);      _handleIssueStateUpdates(_setToken, _reserveAsset, _to, issueInfo); }  /**  * Wraps ETH and deposits WETH if allowed into the SetToken and mints the appropriate % of Net Asset Value of the SetToken  * to the specified _to address.  *  * @param _setToken                     Instance of the SetToken contract  * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance  * @param _to                           Address to mint SetToken to  */ function issueWithEther(     ISetToken _setToken,     uint256 _minSetTokenReceiveQuantity,     address _to )     external     payable     nonReentrant     onlyValidAndInitializedSet(_setToken) {     weth.deposit{ value: msg.value }();      _validateCommon(_setToken, address(weth), msg.value);      _callPreIssueHooks(_setToken, address(weth), msg.value, msg.sender, _to);      ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, address(weth), msg.value);      _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);      _transferWETHAndHandleFees(_setToken, issueInfo);      _handleIssueStateUpdates(_setToken, address(weth), _to, issueInfo); }  /**  * Redeems a SetToken into a valid reserve asset representing the appropriate % of Net Asset Value of the SetToken  * to the specified _to address. Only valid if there are available reserve units on the SetToken.  *  * @param _setToken                     Instance of the SetToken contract  * @param _reserveAsset                 Address of the reserve asset to redeem with  * @param _setTokenQuantity             Quantity of SetTokens to redeem  * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive  * @param _to                           Address to redeem reserve asset to  */ function redeem(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity,     uint256 _minReserveReceiveQuantity,     address _to )     external     nonReentrant     onlyValidAndInitializedSet(_setToken) {     _validateCommon(_setToken, _reserveAsset, _setTokenQuantity);      _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);      ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, _reserveAsset, _setTokenQuantity);      _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);      _setToken.burn(msg.sender, _setTokenQuantity);      // Instruct the SetToken to transfer the reserve asset back to the user     _setToken.strictInvokeTransfer(         _reserveAsset,         _to,         redeemInfo.netFlowQuantity     );      _handleRedemptionFees(_setToken, _reserveAsset, redeemInfo);      _handleRedeemStateUpdates(_setToken, _reserveAsset, _to, redeemInfo); }  /**  * Redeems a SetToken into Ether (if WETH is valid) representing the appropriate % of Net Asset Value of the SetToken  * to the specified _to address. Only valid if there are available WETH units on the SetToken.  *  * @param _setToken                     Instance of the SetToken contract  * @param _setTokenQuantity             Quantity of SetTokens to redeem  * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive  * @param _to                           Address to redeem reserve asset to  */ function redeemIntoEther(     ISetToken _setToken,     uint256 _setTokenQuantity,     uint256 _minReserveReceiveQuantity,     address payable _to )     external     nonReentrant     onlyValidAndInitializedSet(_setToken) {     _validateCommon(_setToken, address(weth), _setTokenQuantity);      _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);      ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, address(weth), _setTokenQuantity);      _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);      _setToken.burn(msg.sender, _setTokenQuantity);      // Instruct the SetToken to transfer WETH from SetToken to module     _setToken.strictInvokeTransfer(         address(weth),         address(this),         redeemInfo.netFlowQuantity     );      weth.withdraw(redeemInfo.netFlowQuantity);      _to.transfer(redeemInfo.netFlowQuantity);      _handleRedemptionFees(_setToken, address(weth), redeemInfo);      _handleRedeemStateUpdates(_setToken, address(weth), _to, redeemInfo); }  /**  * SET MANAGER ONLY. Add an allowed reserve asset  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset to add  */ function addReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {     require(!isReserveAsset[_setToken][_reserveAsset], "Reserve asset already exists");      navIssuanceSettings[_setToken].reserveAssets.push(_reserveAsset);     isReserveAsset[_setToken][_reserveAsset] = true;      emit ReserveAssetAdded(_setToken, _reserveAsset); }  /**  * SET MANAGER ONLY. Remove a reserve asset  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset to remove  */ function removeReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {     require(isReserveAsset[_setToken][_reserveAsset], "Reserve asset does not exist");      navIssuanceSettings[_setToken].reserveAssets = navIssuanceSettings[_setToken].reserveAssets.remove(_reserveAsset);     delete isReserveAsset[_setToken][_reserveAsset];      emit ReserveAssetRemoved(_setToken, _reserveAsset); }  /**  * SET MANAGER ONLY. Edit the premium percentage  *  * @param _setToken                     Instance of the SetToken  * @param _premiumPercentage            Premium percentage in 10e16 (e.g. 10e16 = 1%)  */ function editPremium(ISetToken _setToken, uint256 _premiumPercentage) external onlyManagerAndValidSet(_setToken) {     require(_premiumPercentage &lt;= navIssuanceSettings[_setToken].maxPremiumPercentage, "Premium must be less than maximum allowed");      navIssuanceSettings[_setToken].premiumPercentage = _premiumPercentage;      emit PremiumEdited(_setToken, _premiumPercentage); }  /**  * SET MANAGER ONLY. Edit manager fee  *  * @param _setToken                     Instance of the SetToken  * @param _managerFeePercentage         Manager fee percentage in 10e16 (e.g. 10e16 = 1%)  * @param _managerFeeIndex              Manager fee index. 0 index is issue fee, 1 index is redeem fee  */ function editManagerFee(     ISetToken _setToken,     uint256 _managerFeePercentage,     uint256 _managerFeeIndex )     external     onlyManagerAndValidSet(_setToken) {     require(_managerFeePercentage &lt;= navIssuanceSettings[_setToken].maxManagerFee, "Manager fee must be less than maximum allowed");      navIssuanceSettings[_setToken].managerFees[_managerFeeIndex] = _managerFeePercentage;      emit ManagerFeeEdited(_setToken, _managerFeePercentage, _managerFeeIndex); }  /**  * SET MANAGER ONLY. Edit the manager fee recipient  *  * @param _setToken                     Instance of the SetToken  * @param _managerFeeRecipient          Manager fee recipient  */ function editFeeRecipient(ISetToken _setToken, address _managerFeeRecipient) external onlyManagerAndValidSet(_setToken) {     require(_managerFeeRecipient != address(0), "Fee recipient must not be 0 address");      navIssuanceSettings[_setToken].feeRecipient = _managerFeeRecipient;      emit FeeRecipientEdited(_setToken, _managerFeeRecipient); }  /**  * SET MANAGER ONLY. Initializes this module to the SetToken with hooks, allowed reserve assets,  * fees and issuance premium. Only callable by the SetToken's manager. Hook addresses are optional.  * Address(0) means that no hook will be called.  *  * @param _setToken                     Instance of the SetToken to issue  * @param _navIssuanceSettings          NAVIssuanceSettings struct defining parameters  */ function initialize(     ISetToken _setToken,     NAVIssuanceSettings memory _navIssuanceSettings )     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     require(_navIssuanceSettings.reserveAssets.length &gt; 0, "Reserve assets must be greater than 0");     require(_navIssuanceSettings.maxManagerFee &lt; PreciseUnitMath.preciseUnit(), "Max manager fee must be less than 100%");     require(_navIssuanceSettings.maxPremiumPercentage &lt; PreciseUnitMath.preciseUnit(), "Max premium percentage must be less than 100%");     require(_navIssuanceSettings.managerFees[0] &lt;= _navIssuanceSettings.maxManagerFee, "Manager issue fee must be less than max");     require(_navIssuanceSettings.managerFees[1] &lt;= _navIssuanceSettings.maxManagerFee, "Manager redeem fee must be less than max");     require(_navIssuanceSettings.premiumPercentage &lt;= _navIssuanceSettings.maxPremiumPercentage, "Premium must be less than max");     require(_navIssuanceSettings.feeRecipient != address(0), "Fee Recipient must be non-zero address.");     // Initial mint of Set cannot use NAVIssuance since minSetTokenSupply must be &gt; 0     require(_navIssuanceSettings.minSetTokenSupply &gt; 0, "Min SetToken supply must be greater than 0");      for (uint256 i = 0; i &lt; _navIssuanceSettings.reserveAssets.length; i++) {         require(!isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]], "Reserve assets must be unique");         isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]] = true;     }      navIssuanceSettings[_setToken] = _navIssuanceSettings;      _setToken.initializeModule(); }  /**  * Removes this module from the SetToken, via call by the SetToken. Issuance settings and  * reserve asset states are deleted.  */ function removeModule() external override {     ISetToken setToken = ISetToken(msg.sender);     for (uint256 i = 0; i &lt; navIssuanceSettings[setToken].reserveAssets.length; i++) {         delete isReserveAsset[setToken][navIssuanceSettings[setToken].reserveAssets[i]];     }      delete navIssuanceSettings[setToken]; }  receive() external payable {}  /* ============ External Getter Functions ============ */  function getReserveAssets(ISetToken _setToken) external view returns (address[] memory) {     return navIssuanceSettings[_setToken].reserveAssets; }  function getIssuePremium(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     external     view     returns (uint256) {     return _getIssuePremium(_setToken, _reserveAsset, _reserveAssetQuantity); }  function getRedeemPremium(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     external     view     returns (uint256) {     return _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity); }  function getManagerFee(ISetToken _setToken, uint256 _managerFeeIndex) external view returns (uint256) {     return navIssuanceSettings[_setToken].managerFees[_managerFeeIndex]; }  /**  * Get the expected SetTokens minted to recipient on issuance  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with  *  * @return  uint256                     Expected SetTokens to be minted to recipient  */ function getExpectedSetTokenIssueQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     external     view     returns (uint256) {     (,, uint256 netReserveFlow) = _getFees(         _setToken,         _reserveAssetQuantity,         PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_ISSUE_DIRECT_FEE_INDEX,         MANAGER_ISSUE_FEE_INDEX     );      uint256 setTotalSupply = _setToken.totalSupply();      return _getSetTokenMintQuantity(         _setToken,         _reserveAsset,         netReserveFlow,         setTotalSupply     ); }  /**  * Get the expected reserve asset to be redeemed  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _setTokenQuantity             Quantity of SetTokens to redeem  *  * @return  uint256                     Expected reserve asset quantity redeemed  */ function getExpectedReserveRedeemQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     external     view     returns (uint256) {     uint256 preFeeReserveQuantity = _getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);      (,, uint256 netReserveFlows) = _getFees(         _setToken,         preFeeReserveQuantity,         PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_REDEEM_DIRECT_FEE_INDEX,         MANAGER_REDEEM_FEE_INDEX     );      return netReserveFlows; }  /**  * Checks if issue is valid  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with  *  * @return  bool                        Returns true if issue is valid  */ function isIssueValid(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     external     view     returns (bool) {     uint256 setTotalSupply = _setToken.totalSupply();  return _reserveAssetQuantity != 0         &amp;&amp; isReserveAsset[_setToken][_reserveAsset]         &amp;&amp; setTotalSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply; }  /**  * Checks if redeem is valid  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _setTokenQuantity             Quantity of SetTokens to redeem  *  * @return  bool                        Returns true if redeem is valid  */ function isRedeemValid(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     external     view     returns (bool) {     uint256 setTotalSupply = _setToken.totalSupply();      if (         _setTokenQuantity == 0         || !isReserveAsset[_setToken][_reserveAsset]         || setTotalSupply &lt; navIssuanceSettings[_setToken].minSetTokenSupply.add(_setTokenQuantity)     ) {         return false;     } else {         uint256 totalRedeemValue =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);          (,, uint256 expectedRedeemQuantity) = _getFees(             _setToken,             totalRedeemValue,             PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,             PROTOCOL_REDEEM_DIRECT_FEE_INDEX,             MANAGER_REDEEM_FEE_INDEX         );          uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();          return existingUnit.preciseMul(setTotalSupply) &gt;= expectedRedeemQuantity;     } }  /* ============ Internal Functions ============ */  function _validateCommon(ISetToken _setToken, address _reserveAsset, uint256 _quantity) internal view {     require(_quantity &gt; 0, "Quantity must be &gt; 0");     require(isReserveAsset[_setToken][_reserveAsset], "Must be valid reserve asset"); }  function _validateIssuanceInfo(ISetToken _setToken, uint256 _minSetTokenReceiveQuantity, ActionInfo memory _issueInfo) internal view {     // Check that total supply is greater than min supply needed for issuance     // Note: A min supply amount is needed to avoid division by 0 when SetToken supply is 0     require(         _issueInfo.previousSetTokenSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply,         "Supply must be greater than minimum to enable issuance"     );      require(_issueInfo.setTokenQuantity &gt;= _minSetTokenReceiveQuantity, "Must be greater than min SetToken"); }  function _validateRedemptionInfo(     ISetToken _setToken,     uint256 _minReserveReceiveQuantity,     ActionInfo memory _redeemInfo )     internal     view {     // Check that new supply is more than min supply needed for redemption     // Note: A min supply amount is needed to avoid division by 0 when redeeming SetToken to 0     require(         _redeemInfo.newSetTokenSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply,         "Supply must be greater than minimum to enable redemption"     );      require(_redeemInfo.netFlowQuantity &gt;= _minReserveReceiveQuantity, "Must be greater than min receive reserve quantity"); }  function _createIssuanceInfo(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     internal     view     returns (ActionInfo memory) {     ActionInfo memory issueInfo;      issueInfo.previousSetTokenSupply = _setToken.totalSupply();      issueInfo.preFeeReserveQuantity = _reserveAssetQuantity;      (issueInfo.protocolFees, issueInfo.managerFee, issueInfo.netFlowQuantity) = _getFees(         _setToken,         issueInfo.preFeeReserveQuantity,         PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_ISSUE_DIRECT_FEE_INDEX,         MANAGER_ISSUE_FEE_INDEX     );      issueInfo.setTokenQuantity = _getSetTokenMintQuantity(         _setToken,         _reserveAsset,         issueInfo.netFlowQuantity,         issueInfo.previousSetTokenSupply     );      (issueInfo.newSetTokenSupply, issueInfo.newPositionMultiplier) = _getIssuePositionMultiplier(_setToken, issueInfo);      issueInfo.newReservePositionUnit = _getIssuePositionUnit(_setToken, _reserveAsset, issueInfo);      return issueInfo; }  function _createRedemptionInfo(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     internal     view     returns (ActionInfo memory) {     ActionInfo memory redeemInfo;      redeemInfo.setTokenQuantity = _setTokenQuantity;      redeemInfo.preFeeReserveQuantity =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);      (redeemInfo.protocolFees, redeemInfo.managerFee, redeemInfo.netFlowQuantity) = _getFees(         _setToken,         redeemInfo.preFeeReserveQuantity,         PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_REDEEM_DIRECT_FEE_INDEX,         MANAGER_REDEEM_FEE_INDEX     );      redeemInfo.previousSetTokenSupply = _setToken.totalSupply();      (redeemInfo.newSetTokenSupply, redeemInfo.newPositionMultiplier) = _getRedeemPositionMultiplier(_setToken, _setTokenQuantity, redeemInfo);      redeemInfo.newReservePositionUnit = _getRedeemPositionUnit(_setToken, _reserveAsset, redeemInfo);      return redeemInfo; }  /**  * Transfer reserve asset from user to SetToken and fees from user to appropriate fee recipients  */ function _transferCollateralAndHandleFees(ISetToken _setToken, IERC20 _reserveAsset, ActionInfo memory _issueInfo) internal {     transferFrom(_reserveAsset, msg.sender, address(_setToken), _issueInfo.netFlowQuantity);      if (_issueInfo.protocolFees &gt; 0) {         transferFrom(_reserveAsset, msg.sender, controller.feeRecipient(), _issueInfo.protocolFees);     }      if (_issueInfo.managerFee &gt; 0) {         transferFrom(_reserveAsset, msg.sender, navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);     } }   /**   * Transfer WETH from module to SetToken and fees from module to appropriate fee recipients  */ function _transferWETHAndHandleFees(ISetToken _setToken, ActionInfo memory _issueInfo) internal {     weth.transfer(address(_setToken), _issueInfo.netFlowQuantity);      if (_issueInfo.protocolFees &gt; 0) {         weth.transfer(controller.feeRecipient(), _issueInfo.protocolFees);     }      if (_issueInfo.managerFee &gt; 0) {         weth.transfer(navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);     } }  function _handleIssueStateUpdates(     ISetToken _setToken,     address _reserveAsset,     address _to,     ActionInfo memory _issueInfo )     internal {     _setToken.editPositionMultiplier(_issueInfo.newPositionMultiplier);      _setToken.editDefaultPosition(_reserveAsset, _issueInfo.newReservePositionUnit);      _setToken.mint(_to, _issueInfo.setTokenQuantity);      emit SetTokenNAVIssued(         _setToken,         msg.sender,         _to,         _reserveAsset,         address(navIssuanceSettings[_setToken].managerIssuanceHook),         _issueInfo.setTokenQuantity,         _issueInfo.managerFee,         _issueInfo.protocolFees     ); }  function _handleRedeemStateUpdates(     ISetToken _setToken,     address _reserveAsset,     address _to,     ActionInfo memory _redeemInfo )     internal {     _setToken.editPositionMultiplier(_redeemInfo.newPositionMultiplier);      _setToken.editDefaultPosition(_reserveAsset, _redeemInfo.newReservePositionUnit);      emit SetTokenNAVRedeemed(         _setToken,         msg.sender,         _to,         _reserveAsset,         address(navIssuanceSettings[_setToken].managerRedemptionHook),         _redeemInfo.setTokenQuantity,         _redeemInfo.managerFee,         _redeemInfo.protocolFees     ); }  function _handleRedemptionFees(ISetToken _setToken, address _reserveAsset, ActionInfo memory _redeemInfo) internal {     // Instruct the SetToken to transfer protocol fee to fee recipient if there is a fee     payProtocolFeeFromSetToken(_setToken, _reserveAsset, _redeemInfo.protocolFees);      // Instruct the SetToken to transfer manager fee to manager fee recipient if there is a fee     if (_redeemInfo.managerFee &gt; 0) {         _setToken.strictInvokeTransfer(             _reserveAsset,             navIssuanceSettings[_setToken].feeRecipient,             _redeemInfo.managerFee         );     } }  /**  * Returns the issue premium percentage. Virtual function that can be overridden in future versions of the module  * and can contain arbitrary logic to calculate the issuance premium.  */ function _getIssuePremium(     ISetToken _setToken,     address /* _reserveAsset */,     uint256 /* _reserveAssetQuantity */ )     virtual     internal     view     returns (uint256) {     return navIssuanceSettings[_setToken].premiumPercentage; }  /**  * Returns the redeem premium percentage. Virtual function that can be overridden in future versions of the module  * and can contain arbitrary logic to calculate the redemption premium.  */ function _getRedeemPremium(     ISetToken _setToken,     address /* _reserveAsset */,     uint256 /* _setTokenQuantity */ )     virtual     internal     view     returns (uint256) {     return navIssuanceSettings[_setToken].premiumPercentage; }  /**  * Returns the fees attributed to the manager and the protocol. The fees are calculated as follows:  *  * ManagerFee = (manager fee % - % to protocol) * reserveAssetQuantity  * Protocol Fee = (% manager fee share + direct fee %) * reserveAssetQuantity  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAssetQuantity         Quantity of reserve asset to calculate fees from  * @param _protocolManagerFeeIndex      Index to pull rev share NAV Issuance fee from the Controller  * @param _protocolDirectFeeIndex       Index to pull direct NAV issuance fee from the Controller  * @param _managerFeeIndex              Index from NAVIssuanceSettings (0 = issue fee, 1 = redeem fee)  *  * @return  uint256                     Fees paid to the protocol in reserve asset  * @return  uint256                     Fees paid to the manager in reserve asset  * @return  uint256                     Net reserve to user net of fees  */ function _getFees(     ISetToken _setToken,     uint256 _reserveAssetQuantity,     uint256 _protocolManagerFeeIndex,     uint256 _protocolDirectFeeIndex,     uint256 _managerFeeIndex )     internal     view     returns (uint256, uint256, uint256) {     (uint256 protocolFeePercentage, uint256 managerFeePercentage) = _getProtocolAndManagerFeePercentages(         _setToken,         _protocolManagerFeeIndex,         _protocolDirectFeeIndex,         _managerFeeIndex     );      // Calculate total notional fees     uint256 protocolFees = protocolFeePercentage.preciseMul(_reserveAssetQuantity);     uint256 managerFee = managerFeePercentage.preciseMul(_reserveAssetQuantity);      uint256 netReserveFlow = _reserveAssetQuantity.sub(protocolFees).sub(managerFee);      return (protocolFees, managerFee, netReserveFlow); }  function _getProtocolAndManagerFeePercentages(     ISetToken _setToken,     uint256 _protocolManagerFeeIndex,     uint256 _protocolDirectFeeIndex,     uint256 _managerFeeIndex )     internal     view     returns(uint256, uint256) {     // Get protocol fee percentages     uint256 protocolDirectFeePercent = controller.getModuleFee(address(this), _protocolDirectFeeIndex);     uint256 protocolManagerShareFeePercent = controller.getModuleFee(address(this), _protocolManagerFeeIndex);     uint256 managerFeePercent = navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];      // Calculate revenue share split percentage     uint256 protocolRevenueSharePercentage = protocolManagerShareFeePercent.preciseMul(managerFeePercent);     uint256 managerRevenueSharePercentage = managerFeePercent.sub(protocolRevenueSharePercentage);     uint256 totalProtocolFeePercentage = protocolRevenueSharePercentage.add(protocolDirectFeePercent);      return (totalProtocolFeePercentage, managerRevenueSharePercentage); }  function _getSetTokenMintQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _netReserveFlows,            // Value of reserve asset net of fees     uint256 _setTotalSupply )     internal     view     returns (uint256) {     uint256 premiumPercentage = _getIssuePremium(_setToken, _reserveAsset, _netReserveFlows);     uint256 premiumValue = _netReserveFlows.preciseMul(premiumPercentage);      // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (1e18)     // Reverts if price is not found     uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);      // Get reserve asset decimals     uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();     uint256 normalizedTotalReserveQuantityNetFees = _netReserveFlows.preciseDiv(10 ** reserveAssetDecimals);     uint256 normalizedTotalReserveQuantityNetFeesAndPremium = _netReserveFlows.sub(premiumValue).preciseDiv(10 ** reserveAssetDecimals);      // Calculate SetTokens to mint to issuer     uint256 denominator = _setTotalSupply.preciseMul(setTokenValuation).add(normalizedTotalReserveQuantityNetFees).sub(normalizedTotalReserveQuantityNetFeesAndPremium);     return normalizedTotalReserveQuantityNetFeesAndPremium.preciseMul(_setTotalSupply).preciseDiv(denominator); }  function _getRedeemReserveQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     internal     view     returns (uint256) {     // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (10e18)     // Reverts if price is not found     uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);      uint256 totalRedeemValueInPreciseUnits = _setTokenQuantity.preciseMul(setTokenValuation);     // Get reserve asset decimals     uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();     uint256 prePremiumReserveQuantity = totalRedeemValueInPreciseUnits.preciseMul(10 ** reserveAssetDecimals);      uint256 premiumPercentage = _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);     uint256 premiumQuantity = prePremiumReserveQuantity.preciseMulCeil(premiumPercentage);      return prePremiumReserveQuantity.sub(premiumQuantity); }  /**  * The new position multiplier is calculated as follows:  * inflationPercentage = (newSupply - oldSupply) / newSupply  * newMultiplier = (1 - inflationPercentage) * positionMultiplier  */ function _getIssuePositionMultiplier(     ISetToken _setToken,     ActionInfo memory _issueInfo )     internal     view     returns (uint256, int256) {     // Calculate inflation and new position multiplier. Note: Round inflation up in order to round position multiplier down     uint256 newTotalSupply = _issueInfo.setTokenQuantity.add(_issueInfo.previousSetTokenSupply);     int256 newPositionMultiplier = _setToken.positionMultiplier()         .mul(_issueInfo.previousSetTokenSupply.toInt256())         .div(newTotalSupply.toInt256());      return (newTotalSupply, newPositionMultiplier); }  /**  * Calculate deflation and new position multiplier. Note: Round deflation down in order to round position multiplier down  *  * The new position multiplier is calculated as follows:  * deflationPercentage = (oldSupply - newSupply) / newSupply  * newMultiplier = (1 + deflationPercentage) * positionMultiplier  */ function _getRedeemPositionMultiplier(     ISetToken _setToken,     uint256 _setTokenQuantity,     ActionInfo memory _redeemInfo )     internal     view     returns (uint256, int256) {     uint256 newTotalSupply = _redeemInfo.previousSetTokenSupply.sub(_setTokenQuantity);     int256 newPositionMultiplier = _setToken.positionMultiplier()         .mul(_redeemInfo.previousSetTokenSupply.toInt256())         .div(newTotalSupply.toInt256());      return (newTotalSupply, newPositionMultiplier); }  /**  * The new position reserve asset unit is calculated as follows:  * totalReserve = (oldUnit * oldSetTokenSupply) + reserveQuantity  * newUnit = totalReserve / newSetTokenSupply  */ function _getIssuePositionUnit(     ISetToken _setToken,     address _reserveAsset,     ActionInfo memory _issueInfo )     internal     view     returns (uint256) {     uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();     uint256 totalReserve = existingUnit         .preciseMul(_issueInfo.previousSetTokenSupply)         .add(_issueInfo.netFlowQuantity);      return totalReserve.preciseDiv(_issueInfo.newSetTokenSupply); }  /**  * The new position reserve asset unit is calculated as follows:  * totalReserve = (oldUnit * oldSetTokenSupply) - reserveQuantityToSendOut  * newUnit = totalReserve / newSetTokenSupply  */ function _getRedeemPositionUnit(     ISetToken _setToken,     address _reserveAsset,     ActionInfo memory _redeemInfo )     internal     view     returns (uint256) {     uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();     uint256 totalExistingUnits = existingUnit.preciseMul(_redeemInfo.previousSetTokenSupply);      uint256 outflow = _redeemInfo.netFlowQuantity.add(_redeemInfo.protocolFees).add(_redeemInfo.managerFee);      // Require withdrawable quantity is greater than existing collateral     require(totalExistingUnits &gt;= outflow, "Must be greater than total available collateral");      return totalExistingUnits.sub(outflow).preciseDiv(_redeemInfo.newSetTokenSupply); }  /**  * If a pre-issue hook has been configured, call the external-protocol contract. Pre-issue hook logic  * can contain arbitrary logic including validations, external function calls, etc.  */ function _callPreIssueHooks(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity,     address _caller,     address _to )     internal {     INAVIssuanceHook preIssueHook = navIssuanceSettings[_setToken].managerIssuanceHook;     if (address(preIssueHook) != address(0)) {         preIssueHook.invokePreIssueHook(_setToken, _reserveAsset, _reserveAssetQuantity, _caller, _to);     } }  /**  * If a pre-redeem hook has been configured, call the external-protocol contract.  */ function _callPreRedeemHooks(ISetToken _setToken, uint256 _setQuantity, address _caller, address _to) internal {     INAVIssuanceHook preRedeemHook = navIssuanceSettings[_setToken].managerRedemptionHook;     if (address(preRedeemHook) != address(0)) {         preRedeemHook.invokePreRedeemHook(_setToken, _setQuantity, _caller, _to);     } }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Below are the details of our target smart contract codes and their associated test reports: Task: "{task}". Existing Test Reports: "{test_reports}" Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings. |
| **phase_name** | TestBugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': '/\n    Copyright 2020 Set Labs Inc.\n\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n/\n\npragma solidity 0.6.10;\npragma experimental "ABIEncoderV2";\n\nimport { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";\nimport { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";\nimport { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";\nimport { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";\nimport { SignedSafeMath } from "@openzeppelin/contracts/math/SignedSafeMath.sol";\n\nimport { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";\nimport { IController } from "../../interfaces/IController.sol";\nimport { INAVIssuanceHook } from "../../interfaces/INAVIssuanceHook.sol";\nimport { Invoke } from "../lib/Invoke.sol";\nimport { ISetToken } from "../../interfaces/ISetToken.sol";\nimport { IWETH } from "../../interfaces/external/IWETH.sol";\nimport { ModuleBase } from "../lib/ModuleBase.sol";\nimport { Position } from "../lib/Position.sol";\nimport { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";\nimport { ResourceIdentifier } from "../lib/ResourceIdentifier.sol";\n\n\n/\n * @title NavIssuanceModule\n * @author Set Protocol\n \n * Module that enables issuance and redemption with any valid ERC20 token or ETH if allowed by the manager. Sender receives\n * a proportional amount of SetTokens on issuance or ERC20 token on redemption based on the calculated net asset value using\n * oracle prices. Manager is able to enforce a premium / discount on issuance / redemption to avoid arbitrage and front\n * running when relying on oracle prices. Managers can charge a fee (denominated in reserve asset).\n /\ncontract NavIssuanceModule is ModuleBase, ReentrancyGuard {\n    using AddressArrayUtils for address[];\n    using Invoke for ISetToken;\n    using Position for ISetToken;\n    using PreciseUnitMath for uint256;\n    using PreciseUnitMath for int256;\n    using ResourceIdentifier for IController;\n    using SafeMath for uint256;\n    using SafeCast for int256;\n    using SafeCast for uint256;\n    using SignedSafeMath for int256;\n\n    / ============ Events ============ /\n\n    event SetTokenNAVIssued(\n        ISetToken indexed _setToken,\n        address _issuer,\n        address _to,\n        address _reserveAsset,\n        address _hookContract,\n        uint256 _setTokenQuantity,\n        uint256 _managerFee,\n        uint256 _premium\n    );\n\n    event SetTokenNAVRedeemed(\n        ISetToken indexed _setToken,\n        address _redeemer,\n        address _to,\n        address _reserveAsset,\n        address _hookContract,\n        uint256 _setTokenQuantity,\n        uint256 _managerFee,\n        uint256 _premium\n    );\n\n    event ReserveAssetAdded(\n        ISetToken indexed _setToken,\n        address _newReserveAsset\n    );\n\n    event ReserveAssetRemoved(\n        ISetToken indexed _setToken,\n        address _removedReserveAsset\n    );\n\n    event PremiumEdited(\n        ISetToken indexed _setToken,\n        uint256 _newPremium\n    );\n\n    event ManagerFeeEdited(\n        ISetToken indexed _setToken,\n        uint256 _newManagerFee,\n        uint256 _index\n    );\n\n    event FeeRecipientEdited(\n        ISetToken indexed _setToken,\n        address _feeRecipient\n    );\n\n    / ============ Structs ============ /\n\n    struct NAVIssuanceSettings {\n        INAVIssuanceHook managerIssuanceHook;      // Issuance hook configurations\n        INAVIssuanceHook managerRedemptionHook;    // Redemption hook configurations\n        address[] reserveAssets;                       // Allowed reserve assets - Must have a price enabled with the price oracle\n        address feeRecipient;                          // Manager fee recipient\n        uint256[2] managerFees;                        // Manager fees. 0 index is issue and 1 index is redeem fee (0.01% = 1e14, 1% = 1e16)\n        uint256 maxManagerFee;                         // Maximum fee manager is allowed to set for issue and redeem\n        uint256 premiumPercentage;                     // Premium percentage (0.01% = 1e14, 1% = 1e16). This premium is a buffer around oracle\n                                                       // prices paid by user to the SetToken, which prevents arbitrage and oracle front running\n        uint256 maxPremiumPercentage;                  // Maximum premium percentage manager is allowed to set (configured by manager)\n        uint256 minSetTokenSupply;                     // Minimum SetToken supply required for issuance and redemption\n                                                       // to prevent dramatic inflationary changes to the SetToken\'s position multiplier\n    }\n\n    struct ActionInfo {\n        uint256 preFeeReserveQuantity;                 // Reserve value before fees; During issuance, represents raw quantity\n                                                       // During redeem, represents post-premium value\n        uint256 protocolFees;                          // Total protocol fees (direct + manager revenue share)\n        uint256 managerFee;                            // Total manager fee paid in reserve asset\n        uint256 netFlowQuantity;                       // When issuing, quantity of reserve asset sent to SetToken\n                                                       // When redeeming, quantity of reserve asset sent to redeemer\n        uint256 setTokenQuantity;                      // When issuing, quantity of SetTokens minted to mintee\n                                                       // When redeeming, quantity of SetToken redeemed\n        uint256 previousSetTokenSupply;                // SetToken supply prior to issue/redeem action\n        uint256 newSetTokenSupply;                     // SetToken supply after issue/redeem action\n        int256 newPositionMultiplier;                  // SetToken position multiplier after issue/redeem\n        uint256 newReservePositionUnit;                // SetToken reserve asset position unit after issue/redeem\n    }\n\n    / ============ State Variables ============ /\n\n    // Wrapped ETH address\n    IWETH public immutable weth;\n\n    // Mapping of SetToken to NAV issuance settings struct\n    mapping(ISetToken =&gt; NAVIssuanceSettings) public navIssuanceSettings;\n\n    // Mapping to efficiently check a SetToken\'s reserve asset validity\n    // SetToken =&gt; reserveAsset =&gt; isReserveAsset\n    mapping(ISetToken =&gt; mapping(address =&gt; bool)) public isReserveAsset;\n\n    / ============ Constants ============ /\n\n    // 0 index stores the manager fee in managerFees array, percentage charged on issue (denominated in reserve asset)\n    uint256 constant internal MANAGER_ISSUE_FEE_INDEX = 0;\n\n    // 1 index stores the manager fee percentage in managerFees array, charged on redeem\n    uint256 constant internal MANAGER_REDEEM_FEE_INDEX = 1;\n\n    // 0 index stores the manager revenue share protocol fee % on the controller, charged in the issuance function\n    uint256 constant internal PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX = 0;\n\n    // 1 index stores the manager revenue share protocol fee % on the controller, charged in the redeem function\n    uint256 constant internal PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX = 1;\n\n    // 2 index stores the direct protocol fee % on the controller, charged in the issuance function\n    uint256 constant internal PROTOCOL_ISSUE_DIRECT_FEE_INDEX = 2;\n\n    // 3 index stores the direct protocol fee % on the controller, charged in the redeem function\n    uint256 constant internal PROTOCOL_REDEEM_DIRECT_FEE_INDEX = 3;\n\n    / ============ Constructor ============ /\n\n    /\n     * @param _controller               Address of controller contract\n     * @param _weth                     Address of wrapped eth\n     /\n    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {\n        weth = _weth;\n    }\n\n    / ============ External Functions ============ /\n\n    /\n     * Deposits the allowed reserve asset into the SetToken and mints the appropriate % of Net Asset Value of the SetToken\n     * to the specified _to address.\n     \n     * @param _setToken                     Instance of the SetToken contract\n     * @param _reserveAsset                 Address of the reserve asset to issue with\n     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with\n     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance\n     * @param _to                           Address to mint SetToken to\n     /\n    function issue(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _reserveAssetQuantity,\n        uint256 _minSetTokenReceiveQuantity,\n        address _to\n    )\n        external\n        nonReentrant\n        onlyValidAndInitializedSet(_setToken)\n    {\n        _validateCommon(_setToken, _reserveAsset, _reserveAssetQuantity);\n\n        _callPreIssueHooks(_setToken, _reserveAsset, _reserveAssetQuantity, msg.sender, _to);\n\n        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, _reserveAsset, _reserveAssetQuantity);\n\n        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);\n\n        _transferCollateralAndHandleFees(_setToken, IERC20(_reserveAsset), issueInfo);\n\n        _handleIssueStateUpdates(_setToken, _reserveAsset, _to, issueInfo);\n    }\n\n    /\n     * Wraps ETH and deposits WETH if allowed into the SetToken and mints the appropriate % of Net Asset Value of the SetToken\n     * to the specified _to address.\n     \n     * @param _setToken                     Instance of the SetToken contract\n     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance\n     * @param _to                           Address to mint SetToken to\n     /\n    function issueWithEther(\n        ISetToken _setToken,\n        uint256 _minSetTokenReceiveQuantity,\n        address _to\n    )\n        external\n        payable\n        nonReentrant\n        onlyValidAndInitializedSet(_setToken)\n    {\n        weth.deposit{ value: msg.value }();\n\n        _validateCommon(_setToken, address(weth), msg.value);\n\n        _callPreIssueHooks(_setToken, address(weth), msg.value, msg.sender, _to);\n\n        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, address(weth), msg.value);\n\n        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);\n\n        _transferWETHAndHandleFees(_setToken, issueInfo);\n\n        _handleIssueStateUpdates(_setToken, address(weth), _to, issueInfo);\n    }\n\n    /\n     * Redeems a SetToken into a valid reserve asset representing the appropriate % of Net Asset Value of the SetToken\n     * to the specified _to address. Only valid if there are available reserve units on the SetToken.\n     \n     * @param _setToken                     Instance of the SetToken contract\n     * @param _reserveAsset                 Address of the reserve asset to redeem with\n     * @param _setTokenQuantity             Quantity of SetTokens to redeem\n     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive\n     * @param _to                           Address to redeem reserve asset to\n     /\n    function redeem(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _setTokenQuantity,\n        uint256 _minReserveReceiveQuantity,\n        address _to\n    )\n        external\n        nonReentrant\n        onlyValidAndInitializedSet(_setToken)\n    {\n        _validateCommon(_setToken, _reserveAsset, _setTokenQuantity);\n\n        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);\n\n        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, _reserveAsset, _setTokenQuantity);\n\n        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);\n\n        _setToken.burn(msg.sender, _setTokenQuantity);\n\n        // Instruct the SetToken to transfer the reserve asset back to the user\n        _setToken.strictInvokeTransfer(\n            _reserveAsset,\n            _to,\n            redeemInfo.netFlowQuantity\n        );\n\n        _handleRedemptionFees(_setToken, _reserveAsset, redeemInfo);\n\n        _handleRedeemStateUpdates(_setToken, _reserveAsset, _to, redeemInfo);\n    }\n\n    /\n     * Redeems a SetToken into Ether (if WETH is valid) representing the appropriate % of Net Asset Value of the SetToken\n     * to the specified _to address. Only valid if there are available WETH units on the SetToken.\n     \n     * @param _setToken                     Instance of the SetToken contract\n     * @param _setTokenQuantity             Quantity of SetTokens to redeem\n     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive\n     * @param _to                           Address to redeem reserve asset to\n     /\n    function redeemIntoEther(\n        ISetToken _setToken,\n        uint256 _setTokenQuantity,\n        uint256 _minReserveReceiveQuantity,\n        address payable _to\n    )\n        external\n        nonReentrant\n        onlyValidAndInitializedSet(_setToken)\n    {\n        _validateCommon(_setToken, address(weth), _setTokenQuantity);\n\n        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);\n\n        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, address(weth), _setTokenQuantity);\n\n        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);\n\n        _setToken.burn(msg.sender, _setTokenQuantity);\n\n        // Instruct the SetToken to transfer WETH from SetToken to module\n        _setToken.strictInvokeTransfer(\n            address(weth),\n            address(this),\n            redeemInfo.netFlowQuantity\n        );\n\n        weth.withdraw(redeemInfo.netFlowQuantity);\n\n        _to.transfer(redeemInfo.netFlowQuantity);\n\n        _handleRedemptionFees(_setToken, address(weth), redeemInfo);\n\n        _handleRedeemStateUpdates(_setToken, address(weth), _to, redeemInfo);\n    }\n\n    /\n     * SET MANAGER ONLY. Add an allowed reserve asset\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _reserveAsset                 Address of the reserve asset to add\n     /\n    function addReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {\n        require(!isReserveAsset[_setToken][_reserveAsset], "Reserve asset already exists");\n\n        navIssuanceSettings[_setToken].reserveAssets.push(_reserveAsset);\n        isReserveAsset[_setToken][_reserveAsset] = true;\n\n        emit ReserveAssetAdded(_setToken, _reserveAsset);\n    }\n\n    /\n     * SET MANAGER ONLY. Remove a reserve asset\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _reserveAsset                 Address of the reserve asset to remove\n     /\n    function removeReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {\n        require(isReserveAsset[_setToken][_reserveAsset], "Reserve asset does not exist");\n\n        navIssuanceSettings[_setToken].reserveAssets = navIssuanceSettings[_setToken].reserveAssets.remove(_reserveAsset);\n        delete isReserveAsset[_setToken][_reserveAsset];\n\n        emit ReserveAssetRemoved(_setToken, _reserveAsset);\n    }\n\n    /\n     * SET MANAGER ONLY. Edit the premium percentage\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _premiumPercentage            Premium percentage in 10e16 (e.g. 10e16 = 1%)\n     /\n    function editPremium(ISetToken _setToken, uint256 _premiumPercentage) external onlyManagerAndValidSet(_setToken) {\n        require(_premiumPercentage &lt;= navIssuanceSettings[_setToken].maxPremiumPercentage, "Premium must be less than maximum allowed");\n\n        navIssuanceSettings[_setToken].premiumPercentage = _premiumPercentage;\n\n        emit PremiumEdited(_setToken, _premiumPercentage);\n    }\n\n    /\n     * SET MANAGER ONLY. Edit manager fee\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _managerFeePercentage         Manager fee percentage in 10e16 (e.g. 10e16 = 1%)\n     * @param _managerFeeIndex              Manager fee index. 0 index is issue fee, 1 index is redeem fee\n     /\n    function editManagerFee(\n        ISetToken _setToken,\n        uint256 _managerFeePercentage,\n        uint256 _managerFeeIndex\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        require(_managerFeePercentage &lt;= navIssuanceSettings[_setToken].maxManagerFee, "Manager fee must be less than maximum allowed");\n\n        navIssuanceSettings[_setToken].managerFees[_managerFeeIndex] = _managerFeePercentage;\n\n        emit ManagerFeeEdited(_setToken, _managerFeePercentage, _managerFeeIndex);\n    }\n\n    /\n     * SET MANAGER ONLY. Edit the manager fee recipient\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _managerFeeRecipient          Manager fee recipient\n     /\n    function editFeeRecipient(ISetToken _setToken, address _managerFeeRecipient) external onlyManagerAndValidSet(_setToken) {\n        require(_managerFeeRecipient != address(0), "Fee recipient must not be 0 address");\n\n        navIssuanceSettings[_setToken].feeRecipient = _managerFeeRecipient;\n\n        emit FeeRecipientEdited(_setToken, _managerFeeRecipient);\n    }\n\n    /\n     * SET MANAGER ONLY. Initializes this module to the SetToken with hooks, allowed reserve assets,\n     * fees and issuance premium. Only callable by the SetToken\'s manager. Hook addresses are optional.\n     * Address(0) means that no hook will be called.\n     \n     * @param _setToken                     Instance of the SetToken to issue\n     * @param _navIssuanceSettings          NAVIssuanceSettings struct defining parameters\n     /\n    function initialize(\n        ISetToken _setToken,\n        NAVIssuanceSettings memory _navIssuanceSettings\n    )\n        external\n        onlySetManager(_setToken, msg.sender)\n        onlyValidAndPendingSet(_setToken)\n    {\n        require(_navIssuanceSettings.reserveAssets.length &gt; 0, "Reserve assets must be greater than 0");\n        require(_navIssuanceSettings.maxManagerFee &lt; PreciseUnitMath.preciseUnit(), "Max manager fee must be less than 100%");\n        require(_navIssuanceSettings.maxPremiumPercentage &lt; PreciseUnitMath.preciseUnit(), "Max premium percentage must be less than 100%");\n        require(_navIssuanceSettings.managerFees[0] &lt;= _navIssuanceSettings.maxManagerFee, "Manager issue fee must be less than max");\n        require(_navIssuanceSettings.managerFees[1] &lt;= _navIssuanceSettings.maxManagerFee, "Manager redeem fee must be less than max");\n        require(_navIssuanceSettings.premiumPercentage &lt;= _navIssuanceSettings.maxPremiumPercentage, "Premium must be less than max");\n        require(_navIssuanceSettings.feeRecipient != address(0), "Fee Recipient must be non-zero address.");\n        // Initial mint of Set cannot use NAVIssuance since minSetTokenSupply must be &gt; 0\n        require(_navIssuanceSettings.minSetTokenSupply &gt; 0, "Min SetToken supply must be greater than 0");\n\n        for (uint256 i = 0; i &lt; _navIssuanceSettings.reserveAssets.length; i++) {\n            require(!isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]], "Reserve assets must be unique");\n            isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]] = true;\n        }\n\n        navIssuanceSettings[_setToken] = _navIssuanceSettings;\n\n        _setToken.initializeModule();\n    }\n\n    /\n     * Removes this module from the SetToken, via call by the SetToken. Issuance settings and\n     * reserve asset states are deleted.\n     /\n    function removeModule() external override {\n        ISetToken setToken = ISetToken(msg.sender);\n        for (uint256 i = 0; i &lt; navIssuanceSettings[setToken].reserveAssets.length; i++) {\n            delete isReserveAsset[setToken][navIssuanceSettings[setToken].reserveAssets[i]];\n        }\n\n        delete navIssuanceSettings[setToken];\n    }\n\n    receive() external payable {}\n\n    / ============ External Getter Functions ============ /\n\n    function getReserveAssets(ISetToken _setToken) external view returns (address[] memory) {\n        return navIssuanceSettings[_setToken].reserveAssets;\n    }\n\n    function getIssuePremium(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _reserveAssetQuantity\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getIssuePremium(_setToken, _reserveAsset, _reserveAssetQuantity);\n    }\n\n    function getRedeemPremium(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _setTokenQuantity\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);\n    }\n\n    function getManagerFee(ISetToken _setToken, uint256 _managerFeeIndex) external view returns (uint256) {\n        return navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];\n    }\n\n    /\n     * Get the expected SetTokens minted to recipient on issuance\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _reserveAsset                 Address of the reserve asset\n     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with\n     \n     * @return  uint256                     Expected SetTokens to be minted to recipient\n     */\n    function getExpectedSetTokenIssueQuantity(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _reserveAssetQuantity\n    )\n        external\n        view\n        returns (uint256)\n    {\n        (,, uint256 netReserveFlow) = _getFees(\n            _setToken,\n            _reserveAssetQuantity,\n            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,\n            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,\n            MANAGER_ISSUE_FEE_INDEX\n        );\n\n        uint256 setTotalSupply = _setToken.totalSupply();\n\n        return _getSetTokenMintQuantity(\n            _setToken,\n            _reserveAsset,\n            netReserveFlow,\n            setTotalSupply\n        );\n    }\n\n    /\n     * Get the expected reserve asset to be redeemed\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _reserveAsset                 Address of the reserve asset\n     * @param _setTokenQuantity             Quantity of SetTokens to redeem\n     \n     * @return  uint256                     Expected reserve asset quantity redeemed\n     /\n    function getExpectedReserveRedeemQuantity(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _setTokenQuantity\n    )\n        external\n        view\n        returns (uint256)\n    {\n        uint256 preFeeReserveQuantity = _getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);\n\n        (,, uint256 netReserveFlows) = _getFees(\n            _setToken,\n            preFeeReserveQuantity,\n            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,\n            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,\n            MANAGER_REDEEM_FEE_INDEX\n        );\n\n        return netReserveFlows;\n    }\n\n    /\n     * Checks if issue is valid\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _reserveAsset                 Address of the reserve asset\n     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with\n     \n     * @return  bool                        Returns true if issue is valid\n     /\n    function isIssueValid(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _reserveAssetQuantity\n    )\n        external\n        view\n        returns (bool)\n    {\n        uint256 setTotalSupply = _setToken.totalSupply();\n\n    return _reserveAssetQuantity != 0\n            &amp;&amp; isReserveAsset[_setToken][_reserveAsset]\n            &amp;&amp; setTotalSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply;\n    }\n\n    /\n     * Checks if redeem is valid\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _reserveAsset                 Address of the reserve asset\n     * @param _setTokenQuantity             Quantity of SetTokens to redeem\n     \n     * @return  bool                        Returns true if redeem is valid\n     /\n    function isRedeemValid(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _setTokenQuantity\n    )\n        external\n        view\n        returns (bool)\n    {\n        uint256 setTotalSupply = _setToken.totalSupply();\n\n        if (\n            _setTokenQuantity == 0\n            || !isReserveAsset[_setToken][_reserveAsset]\n            || setTotalSupply &lt; navIssuanceSettings[_setToken].minSetTokenSupply.add(_setTokenQuantity)\n        ) {\n            return false;\n        } else {\n            uint256 totalRedeemValue =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);\n\n            (,, uint256 expectedRedeemQuantity) = _getFees(\n                _setToken,\n                totalRedeemValue,\n                PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,\n                PROTOCOL_REDEEM_DIRECT_FEE_INDEX,\n                MANAGER_REDEEM_FEE_INDEX\n            );\n\n            uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();\n\n            return existingUnit.preciseMul(setTotalSupply) &gt;= expectedRedeemQuantity;\n        }\n    }\n\n    / ============ Internal Functions ============ */\n\n    function _validateCommon(ISetToken _setToken, address _reserveAsset, uint256 _quantity) internal view {\n        require(_quantity &gt; 0, "Quantity must be &gt; 0");\n        require(isReserveAsset[_setToken][_reserveAsset], "Must be valid reserve asset");\n    }\n\n    function _validateIssuanceInfo(ISetToken _setToken, uint256 _minSetTokenReceiveQuantity, ActionInfo memory _issueInfo) internal view {\n        // Check that total supply is greater than min supply needed for issuance\n        // Note: A min supply amount is needed to avoid division by 0 when SetToken supply is 0\n        require(\n            _issueInfo.previousSetTokenSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply,\n            "Supply must be greater than minimum to enable issuance"\n        );\n\n        require(_issueInfo.setTokenQuantity &gt;= _minSetTokenReceiveQuantity, "Must be greater than min SetToken");\n    }\n\n    function _validateRedemptionInfo(\n        ISetToken _setToken,\n        uint256 _minReserveReceiveQuantity,\n        ActionInfo memory _redeemInfo\n    )\n        internal\n        view\n    {\n        // Check that new supply is more than min supply needed for redemption\n        // Note: A min supply amount is needed to avoid division by 0 when redeeming SetToken to 0\n        require(\n            _redeemInfo.newSetTokenSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply,\n            "Supply must be greater than minimum to enable redemption"\n        );\n\n        require(_redeemInfo.netFlowQuantity &gt;= _minReserveReceiveQuantity, "Must be greater than min receive reserve quantity");\n    }\n\n    function _createIssuanceInfo(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _reserveAssetQuantity\n    )\n        internal\n        view\n        returns (ActionInfo memory)\n    {\n        ActionInfo memory issueInfo;\n\n        issueInfo.previousSetTokenSupply = _setToken.totalSupply();\n\n        issueInfo.preFeeReserveQuantity = _reserveAssetQuantity;\n\n        (issueInfo.protocolFees, issueInfo.managerFee, issueInfo.netFlowQuantity) = _getFees(\n            _setToken,\n            issueInfo.preFeeReserveQuantity,\n            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,\n            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,\n            MANAGER_ISSUE_FEE_INDEX\n        );\n\n        issueInfo.setTokenQuantity = _getSetTokenMintQuantity(\n            _setToken,\n            _reserveAsset,\n            issueInfo.netFlowQuantity,\n            issueInfo.previousSetTokenSupply\n        );\n\n        (issueInfo.newSetTokenSupply, issueInfo.newPositionMultiplier) = _getIssuePositionMultiplier(_setToken, issueInfo);\n\n        issueInfo.newReservePositionUnit = _getIssuePositionUnit(_setToken, _reserveAsset, issueInfo);\n\n        return issueInfo;\n    }\n\n    function _createRedemptionInfo(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _setTokenQuantity\n    )\n        internal\n        view\n        returns (ActionInfo memory)\n    {\n        ActionInfo memory redeemInfo;\n\n        redeemInfo.setTokenQuantity = _setTokenQuantity;\n\n        redeemInfo.preFeeReserveQuantity =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);\n\n        (redeemInfo.protocolFees, redeemInfo.managerFee, redeemInfo.netFlowQuantity) = _getFees(\n            _setToken,\n            redeemInfo.preFeeReserveQuantity,\n            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,\n            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,\n            MANAGER_REDEEM_FEE_INDEX\n        );\n\n        redeemInfo.previousSetTokenSupply = _setToken.totalSupply();\n\n        (redeemInfo.newSetTokenSupply, redeemInfo.newPositionMultiplier) = _getRedeemPositionMultiplier(_setToken, _setTokenQuantity, redeemInfo);\n\n        redeemInfo.newReservePositionUnit = _getRedeemPositionUnit(_setToken, _reserveAsset, redeemInfo);\n\n        return redeemInfo;\n    }\n\n    /\n     * Transfer reserve asset from user to SetToken and fees from user to appropriate fee recipients\n     /\n    function _transferCollateralAndHandleFees(ISetToken _setToken, IERC20 _reserveAsset, ActionInfo memory _issueInfo) internal {\n        transferFrom(_reserveAsset, msg.sender, address(_setToken), _issueInfo.netFlowQuantity);\n\n        if (_issueInfo.protocolFees &gt; 0) {\n            transferFrom(_reserveAsset, msg.sender, controller.feeRecipient(), _issueInfo.protocolFees);\n        }\n\n        if (_issueInfo.managerFee &gt; 0) {\n            transferFrom(_reserveAsset, msg.sender, navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);\n        }\n    }\n\n\n    /\n      * Transfer WETH from module to SetToken and fees from module to appropriate fee recipients\n     /\n    function _transferWETHAndHandleFees(ISetToken _setToken, ActionInfo memory _issueInfo) internal {\n        weth.transfer(address(_setToken), _issueInfo.netFlowQuantity);\n\n        if (_issueInfo.protocolFees &gt; 0) {\n            weth.transfer(controller.feeRecipient(), _issueInfo.protocolFees);\n        }\n\n        if (_issueInfo.managerFee &gt; 0) {\n            weth.transfer(navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);\n        }\n    }\n\n    function _handleIssueStateUpdates(\n        ISetToken _setToken,\n        address _reserveAsset,\n        address _to,\n        ActionInfo memory _issueInfo\n    )\n        internal\n    {\n        _setToken.editPositionMultiplier(_issueInfo.newPositionMultiplier);\n\n        _setToken.editDefaultPosition(_reserveAsset, _issueInfo.newReservePositionUnit);\n\n        _setToken.mint(_to, _issueInfo.setTokenQuantity);\n\n        emit SetTokenNAVIssued(\n            _setToken,\n            msg.sender,\n            _to,\n            _reserveAsset,\n            address(navIssuanceSettings[_setToken].managerIssuanceHook),\n            _issueInfo.setTokenQuantity,\n            _issueInfo.managerFee,\n            _issueInfo.protocolFees\n        );\n    }\n\n    function _handleRedeemStateUpdates(\n        ISetToken _setToken,\n        address _reserveAsset,\n        address _to,\n        ActionInfo memory _redeemInfo\n    )\n        internal\n    {\n        _setToken.editPositionMultiplier(_redeemInfo.newPositionMultiplier);\n\n        _setToken.editDefaultPosition(_reserveAsset, _redeemInfo.newReservePositionUnit);\n\n        emit SetTokenNAVRedeemed(\n            _setToken,\n            msg.sender,\n            _to,\n            _reserveAsset,\n            address(navIssuanceSettings[_setToken].managerRedemptionHook),\n            _redeemInfo.setTokenQuantity,\n            _redeemInfo.managerFee,\n            _redeemInfo.protocolFees\n        );\n    }\n\n    function _handleRedemptionFees(ISetToken _setToken, address _reserveAsset, ActionInfo memory _redeemInfo) internal {\n        // Instruct the SetToken to transfer protocol fee to fee recipient if there is a fee\n        payProtocolFeeFromSetToken(_setToken, _reserveAsset, _redeemInfo.protocolFees);\n\n        // Instruct the SetToken to transfer manager fee to manager fee recipient if there is a fee\n        if (_redeemInfo.managerFee &gt; 0) {\n            _setToken.strictInvokeTransfer(\n                _reserveAsset,\n                navIssuanceSettings[_setToken].feeRecipient,\n                _redeemInfo.managerFee\n            );\n        }\n    }\n\n    /\n     * Returns the issue premium percentage. Virtual function that can be overridden in future versions of the module\n     * and can contain arbitrary logic to calculate the issuance premium.\n     /\n    function _getIssuePremium(\n        ISetToken _setToken,\n        address / _reserveAsset /,\n        uint256 / _reserveAssetQuantity */\n    )\n        virtual\n        internal\n        view\n        returns (uint256)\n    {\n        return navIssuanceSettings[_setToken].premiumPercentage;\n    }\n\n    /\n     * Returns the redeem premium percentage. Virtual function that can be overridden in future versions of the module\n     * and can contain arbitrary logic to calculate the redemption premium.\n     /\n    function _getRedeemPremium(\n        ISetToken _setToken,\n        address / _reserveAsset /,\n        uint256 / _setTokenQuantity /\n    )\n        virtual\n        internal\n        view\n        returns (uint256)\n    {\n        return navIssuanceSettings[_setToken].premiumPercentage;\n    }\n\n    /\n     * Returns the fees attributed to the manager and the protocol. The fees are calculated as follows:\n     \n     * ManagerFee = (manager fee % - % to protocol) * reserveAssetQuantity\n     * Protocol Fee = (% manager fee share + direct fee %) * reserveAssetQuantity\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _reserveAssetQuantity         Quantity of reserve asset to calculate fees from\n     * @param _protocolManagerFeeIndex      Index to pull rev share NAV Issuance fee from the Controller\n     * @param _protocolDirectFeeIndex       Index to pull direct NAV issuance fee from the Controller\n     * @param _managerFeeIndex              Index from NAVIssuanceSettings (0 = issue fee, 1 = redeem fee)\n     \n     * @return  uint256                     Fees paid to the protocol in reserve asset\n     * @return  uint256                     Fees paid to the manager in reserve asset\n     * @return  uint256                     Net reserve to user net of fees\n     /\n    function _getFees(\n        ISetToken _setToken,\n        uint256 _reserveAssetQuantity,\n        uint256 _protocolManagerFeeIndex,\n        uint256 _protocolDirectFeeIndex,\n        uint256 _managerFeeIndex\n    )\n        internal\n        view\n        returns (uint256, uint256, uint256)\n    {\n        (uint256 protocolFeePercentage, uint256 managerFeePercentage) = _getProtocolAndManagerFeePercentages(\n            _setToken,\n            _protocolManagerFeeIndex,\n            _protocolDirectFeeIndex,\n            _managerFeeIndex\n        );\n\n        // Calculate total notional fees\n        uint256 protocolFees = protocolFeePercentage.preciseMul(_reserveAssetQuantity);\n        uint256 managerFee = managerFeePercentage.preciseMul(_reserveAssetQuantity);\n\n        uint256 netReserveFlow = _reserveAssetQuantity.sub(protocolFees).sub(managerFee);\n\n        return (protocolFees, managerFee, netReserveFlow);\n    }\n\n    function _getProtocolAndManagerFeePercentages(\n        ISetToken _setToken,\n        uint256 _protocolManagerFeeIndex,\n        uint256 _protocolDirectFeeIndex,\n        uint256 _managerFeeIndex\n    )\n        internal\n        view\n        returns(uint256, uint256)\n    {\n        // Get protocol fee percentages\n        uint256 protocolDirectFeePercent = controller.getModuleFee(address(this), _protocolDirectFeeIndex);\n        uint256 protocolManagerShareFeePercent = controller.getModuleFee(address(this), _protocolManagerFeeIndex);\n        uint256 managerFeePercent = navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];\n\n        // Calculate revenue share split percentage\n        uint256 protocolRevenueSharePercentage = protocolManagerShareFeePercent.preciseMul(managerFeePercent);\n        uint256 managerRevenueSharePercentage = managerFeePercent.sub(protocolRevenueSharePercentage);\n        uint256 totalProtocolFeePercentage = protocolRevenueSharePercentage.add(protocolDirectFeePercent);\n\n        return (totalProtocolFeePercentage, managerRevenueSharePercentage);\n    }\n\n    function _getSetTokenMintQuantity(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _netReserveFlows,            // Value of reserve asset net of fees\n        uint256 _setTotalSupply\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 premiumPercentage = _getIssuePremium(_setToken, _reserveAsset, _netReserveFlows);\n        uint256 premiumValue = _netReserveFlows.preciseMul(premiumPercentage);\n\n        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (1e18)\n        // Reverts if price is not found\n        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);\n\n        // Get reserve asset decimals\n        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();\n        uint256 normalizedTotalReserveQuantityNetFees = _netReserveFlows.preciseDiv(10 ** reserveAssetDecimals);\n        uint256 normalizedTotalReserveQuantityNetFeesAndPremium = _netReserveFlows.sub(premiumValue).preciseDiv(10 ** reserveAssetDecimals);\n\n        // Calculate SetTokens to mint to issuer\n        uint256 denominator = _setTotalSupply.preciseMul(setTokenValuation).add(normalizedTotalReserveQuantityNetFees).sub(normalizedTotalReserveQuantityNetFeesAndPremium);\n        return normalizedTotalReserveQuantityNetFeesAndPremium.preciseMul(_setTotalSupply).preciseDiv(denominator);\n    }\n\n    function _getRedeemReserveQuantity(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _setTokenQuantity\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (10e18)\n        // Reverts if price is not found\n        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);\n\n        uint256 totalRedeemValueInPreciseUnits = _setTokenQuantity.preciseMul(setTokenValuation);\n        // Get reserve asset decimals\n        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();\n        uint256 prePremiumReserveQuantity = totalRedeemValueInPreciseUnits.preciseMul(10 ** reserveAssetDecimals);\n\n        uint256 premiumPercentage = _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);\n        uint256 premiumQuantity = prePremiumReserveQuantity.preciseMulCeil(premiumPercentage);\n\n        return prePremiumReserveQuantity.sub(premiumQuantity);\n    }\n\n    /\n     * The new position multiplier is calculated as follows:\n     * inflationPercentage = (newSupply - oldSupply) / newSupply\n     * newMultiplier = (1 - inflationPercentage) * positionMultiplier\n     /\n    function _getIssuePositionMultiplier(\n        ISetToken _setToken,\n        ActionInfo memory _issueInfo\n    )\n        internal\n        view\n        returns (uint256, int256)\n    {\n        // Calculate inflation and new position multiplier. Note: Round inflation up in order to round position multiplier down\n        uint256 newTotalSupply = _issueInfo.setTokenQuantity.add(_issueInfo.previousSetTokenSupply);\n        int256 newPositionMultiplier = _setToken.positionMultiplier()\n            .mul(_issueInfo.previousSetTokenSupply.toInt256())\n            .div(newTotalSupply.toInt256());\n\n        return (newTotalSupply, newPositionMultiplier);\n    }\n\n    /\n     * Calculate deflation and new position multiplier. Note: Round deflation down in order to round position multiplier down\n     \n     * The new position multiplier is calculated as follows:\n     * deflationPercentage = (oldSupply - newSupply) / newSupply\n     * newMultiplier = (1 + deflationPercentage) * positionMultiplier\n     /\n    function _getRedeemPositionMultiplier(\n        ISetToken _setToken,\n        uint256 _setTokenQuantity,\n        ActionInfo memory _redeemInfo\n    )\n        internal\n        view\n        returns (uint256, int256)\n    {\n        uint256 newTotalSupply = _redeemInfo.previousSetTokenSupply.sub(_setTokenQuantity);\n        int256 newPositionMultiplier = _setToken.positionMultiplier()\n            .mul(_redeemInfo.previousSetTokenSupply.toInt256())\n            .div(newTotalSupply.toInt256());\n\n        return (newTotalSupply, newPositionMultiplier);\n    }\n\n    /\n     * The new position reserve asset unit is calculated as follows:\n     * totalReserve = (oldUnit * oldSetTokenSupply) + reserveQuantity\n     * newUnit = totalReserve / newSetTokenSupply\n     /\n    function _getIssuePositionUnit(\n        ISetToken _setToken,\n        address _reserveAsset,\n        ActionInfo memory _issueInfo\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();\n        uint256 totalReserve = existingUnit\n            .preciseMul(_issueInfo.previousSetTokenSupply)\n            .add(_issueInfo.netFlowQuantity);\n\n        return totalReserve.preciseDiv(_issueInfo.newSetTokenSupply);\n    }\n\n    /\n     * The new position reserve asset unit is calculated as follows:\n     * totalReserve = (oldUnit * oldSetTokenSupply) - reserveQuantityToSendOut\n     * newUnit = totalReserve / newSetTokenSupply\n     /\n    function _getRedeemPositionUnit(\n        ISetToken _setToken,\n        address _reserveAsset,\n        ActionInfo memory _redeemInfo\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();\n        uint256 totalExistingUnits = existingUnit.preciseMul(_redeemInfo.previousSetTokenSupply);\n\n        uint256 outflow = _redeemInfo.netFlowQuantity.add(_redeemInfo.protocolFees).add(_redeemInfo.managerFee);\n\n        // Require withdrawable quantity is greater than existing collateral\n        require(totalExistingUnits &gt;= outflow, "Must be greater than total available collateral");\n\n        return totalExistingUnits.sub(outflow).preciseDiv(_redeemInfo.newSetTokenSupply);\n    }\n\n    /\n     * If a pre-issue hook has been configured, call the external-protocol contract. Pre-issue hook logic\n     * can contain arbitrary logic including validations, external function calls, etc.\n     */\n    function _callPreIssueHooks(\n        ISetToken _setToken,\n        address _reserveAsset,\n        uint256 _reserveAssetQuantity,\n        address _caller,\n        address _to\n    )\n        internal\n    {\n        INAVIssuanceHook preIssueHook = navIssuanceSettings[_setToken].managerIssuanceHook;\n        if (address(preIssueHook) != address(0)) {\n            preIssueHook.invokePreIssueHook(_setToken, _reserveAsset, _reserveAssetQuantity, _caller, _to);\n        }\n    }\n\n    /\n     * If a pre-redeem hook has been configured, call the external-protocol contract.\n     */\n    function _callPreRedeemHooks(ISetToken _setToken, uint256 _setQuantity, address _caller, address _to) internal {\n        INAVIssuanceHook preRedeemHook = navIssuanceSettings[_setToken].managerRedemptionHook;\n        if (address(preRedeemHook) != address(0)) {\n            preRedeemHook.invokePreRedeemHook(_setToken, _setQuantity, _caller, _to);\n        }\n    }\n}', 'ideas': ' Security', 'test_reports': 'The software run successfully without errors.', 'exist_bugs_flag': False} |

[2024-01-09 05:32:00 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | /*     Copyright 2020 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol"; import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol"; import { SignedSafeMath } from "@openzeppelin/contracts/math/SignedSafeMath.sol"; import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol"; import { IController } from "../../interfaces/IController.sol"; import { INAVIssuanceHook } from "../../interfaces/INAVIssuanceHook.sol"; import { Invoke } from "../lib/Invoke.sol"; import { ISetToken } from "../../interfaces/ISetToken.sol"; import { IWETH } from "../../interfaces/external/IWETH.sol"; import { ModuleBase } from "../lib/ModuleBase.sol"; import { Position } from "../lib/Position.sol"; import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol"; import { ResourceIdentifier } from "../lib/ResourceIdentifier.sol"; /*  * @title NavIssuanceModule  * @author Set Protocol  *  * Module that enables issuance and redemption with any valid ERC20 token or ETH if allowed by the manager. Sender receives  * a proportional amount of SetTokens on issuance or ERC20 token on redemption based on the calculated net asset value using  * oracle prices. Manager is able to enforce a premium / discount on issuance / redemption to avoid arbitrage and front  * running when relying on oracle prices. Managers can charge a fee (denominated in reserve asset).  / contract NavIssuanceModule is ModuleBase, ReentrancyGuard {     using AddressArrayUtils for address[];     using Invoke for ISetToken;     using Position for ISetToken;     using PreciseUnitMath for uint256;     using PreciseUnitMath for int256;     using ResourceIdentifier for IController;     using SafeMath for uint256;     using SafeCast for int256;     using SafeCast for uint256;     using SignedSafeMath for int256; /* ============ Events ============ */  event SetTokenNAVIssued(     ISetToken indexed _setToken,     address _issuer,     address _to,     address _reserveAsset,     address _hookContract,     uint256 _setTokenQuantity,     uint256 _managerFee,     uint256 _premium );  event SetTokenNAVRedeemed(     ISetToken indexed _setToken,     address _redeemer,     address _to,     address _reserveAsset,     address _hookContract,     uint256 _setTokenQuantity,     uint256 _managerFee,     uint256 _premium );  event ReserveAssetAdded(     ISetToken indexed _setToken,     address _newReserveAsset );  event ReserveAssetRemoved(     ISetToken indexed _setToken,     address _removedReserveAsset );  event PremiumEdited(     ISetToken indexed _setToken,     uint256 _newPremium );  event ManagerFeeEdited(     ISetToken indexed _setToken,     uint256 _newManagerFee,     uint256 _index );  event FeeRecipientEdited(     ISetToken indexed _setToken,     address _feeRecipient );  /* ============ Structs ============ */  struct NAVIssuanceSettings {     INAVIssuanceHook managerIssuanceHook;      // Issuance hook configurations     INAVIssuanceHook managerRedemptionHook;    // Redemption hook configurations     address[] reserveAssets;                       // Allowed reserve assets - Must have a price enabled with the price oracle     address feeRecipient;                          // Manager fee recipient     uint256[2] managerFees;                        // Manager fees. 0 index is issue and 1 index is redeem fee (0.01% = 1e14, 1% = 1e16)     uint256 maxManagerFee;                         // Maximum fee manager is allowed to set for issue and redeem     uint256 premiumPercentage;                     // Premium percentage (0.01% = 1e14, 1% = 1e16). This premium is a buffer around oracle                                                    // prices paid by user to the SetToken, which prevents arbitrage and oracle front running     uint256 maxPremiumPercentage;                  // Maximum premium percentage manager is allowed to set (configured by manager)     uint256 minSetTokenSupply;                     // Minimum SetToken supply required for issuance and redemption                                                    // to prevent dramatic inflationary changes to the SetToken's position multiplier }  struct ActionInfo {     uint256 preFeeReserveQuantity;                 // Reserve value before fees; During issuance, represents raw quantity                                                    // During redeem, represents post-premium value     uint256 protocolFees;                          // Total protocol fees (direct + manager revenue share)     uint256 managerFee;                            // Total manager fee paid in reserve asset     uint256 netFlowQuantity;                       // When issuing, quantity of reserve asset sent to SetToken                                                    // When redeeming, quantity of reserve asset sent to redeemer     uint256 setTokenQuantity;                      // When issuing, quantity of SetTokens minted to mintee                                                    // When redeeming, quantity of SetToken redeemed     uint256 previousSetTokenSupply;                // SetToken supply prior to issue/redeem action     uint256 newSetTokenSupply;                     // SetToken supply after issue/redeem action     int256 newPositionMultiplier;                  // SetToken position multiplier after issue/redeem     uint256 newReservePositionUnit;                // SetToken reserve asset position unit after issue/redeem }  /* ============ State Variables ============ */  // Wrapped ETH address IWETH public immutable weth;  // Mapping of SetToken to NAV issuance settings struct mapping(ISetToken =&gt; NAVIssuanceSettings) public navIssuanceSettings;  // Mapping to efficiently check a SetToken's reserve asset validity // SetToken =&gt; reserveAsset =&gt; isReserveAsset mapping(ISetToken =&gt; mapping(address =&gt; bool)) public isReserveAsset;  /* ============ Constants ============ */  // 0 index stores the manager fee in managerFees array, percentage charged on issue (denominated in reserve asset) uint256 constant internal MANAGER_ISSUE_FEE_INDEX = 0;  // 1 index stores the manager fee percentage in managerFees array, charged on redeem uint256 constant internal MANAGER_REDEEM_FEE_INDEX = 1;  // 0 index stores the manager revenue share protocol fee % on the controller, charged in the issuance function uint256 constant internal PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX = 0;  // 1 index stores the manager revenue share protocol fee % on the controller, charged in the redeem function uint256 constant internal PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX = 1;  // 2 index stores the direct protocol fee % on the controller, charged in the issuance function uint256 constant internal PROTOCOL_ISSUE_DIRECT_FEE_INDEX = 2;  // 3 index stores the direct protocol fee % on the controller, charged in the redeem function uint256 constant internal PROTOCOL_REDEEM_DIRECT_FEE_INDEX = 3;  /* ============ Constructor ============ */  /**  * @param _controller               Address of controller contract  * @param _weth                     Address of wrapped eth  */ constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {     weth = _weth; }  /* ============ External Functions ============ */  /**  * Deposits the allowed reserve asset into the SetToken and mints the appropriate % of Net Asset Value of the SetToken  * to the specified _to address.  *  * @param _setToken                     Instance of the SetToken contract  * @param _reserveAsset                 Address of the reserve asset to issue with  * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with  * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance  * @param _to                           Address to mint SetToken to  */ function issue(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity,     uint256 _minSetTokenReceiveQuantity,     address _to )     external     nonReentrant     onlyValidAndInitializedSet(_setToken) {     _validateCommon(_setToken, _reserveAsset, _reserveAssetQuantity);      _callPreIssueHooks(_setToken, _reserveAsset, _reserveAssetQuantity, msg.sender, _to);      ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, _reserveAsset, _reserveAssetQuantity);      _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);      _transferCollateralAndHandleFees(_setToken, IERC20(_reserveAsset), issueInfo);      _handleIssueStateUpdates(_setToken, _reserveAsset, _to, issueInfo); }  /**  * Wraps ETH and deposits WETH if allowed into the SetToken and mints the appropriate % of Net Asset Value of the SetToken  * to the specified _to address.  *  * @param _setToken                     Instance of the SetToken contract  * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance  * @param _to                           Address to mint SetToken to  */ function issueWithEther(     ISetToken _setToken,     uint256 _minSetTokenReceiveQuantity,     address _to )     external     payable     nonReentrant     onlyValidAndInitializedSet(_setToken) {     weth.deposit{ value: msg.value }();      _validateCommon(_setToken, address(weth), msg.value);      _callPreIssueHooks(_setToken, address(weth), msg.value, msg.sender, _to);      ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, address(weth), msg.value);      _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);      _transferWETHAndHandleFees(_setToken, issueInfo);      _handleIssueStateUpdates(_setToken, address(weth), _to, issueInfo); }  /**  * Redeems a SetToken into a valid reserve asset representing the appropriate % of Net Asset Value of the SetToken  * to the specified _to address. Only valid if there are available reserve units on the SetToken.  *  * @param _setToken                     Instance of the SetToken contract  * @param _reserveAsset                 Address of the reserve asset to redeem with  * @param _setTokenQuantity             Quantity of SetTokens to redeem  * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive  * @param _to                           Address to redeem reserve asset to  */ function redeem(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity,     uint256 _minReserveReceiveQuantity,     address _to )     external     nonReentrant     onlyValidAndInitializedSet(_setToken) {     _validateCommon(_setToken, _reserveAsset, _setTokenQuantity);      _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);      ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, _reserveAsset, _setTokenQuantity);      _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);      _setToken.burn(msg.sender, _setTokenQuantity);      // Instruct the SetToken to transfer the reserve asset back to the user     _setToken.strictInvokeTransfer(         _reserveAsset,         _to,         redeemInfo.netFlowQuantity     );      _handleRedemptionFees(_setToken, _reserveAsset, redeemInfo);      _handleRedeemStateUpdates(_setToken, _reserveAsset, _to, redeemInfo); }  /**  * Redeems a SetToken into Ether (if WETH is valid) representing the appropriate % of Net Asset Value of the SetToken  * to the specified _to address. Only valid if there are available WETH units on the SetToken.  *  * @param _setToken                     Instance of the SetToken contract  * @param _setTokenQuantity             Quantity of SetTokens to redeem  * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive  * @param _to                           Address to redeem reserve asset to  */ function redeemIntoEther(     ISetToken _setToken,     uint256 _setTokenQuantity,     uint256 _minReserveReceiveQuantity,     address payable _to )     external     nonReentrant     onlyValidAndInitializedSet(_setToken) {     _validateCommon(_setToken, address(weth), _setTokenQuantity);      _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);      ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, address(weth), _setTokenQuantity);      _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);      _setToken.burn(msg.sender, _setTokenQuantity);      // Instruct the SetToken to transfer WETH from SetToken to module     _setToken.strictInvokeTransfer(         address(weth),         address(this),         redeemInfo.netFlowQuantity     );      weth.withdraw(redeemInfo.netFlowQuantity);      _to.transfer(redeemInfo.netFlowQuantity);      _handleRedemptionFees(_setToken, address(weth), redeemInfo);      _handleRedeemStateUpdates(_setToken, address(weth), _to, redeemInfo); }  /**  * SET MANAGER ONLY. Add an allowed reserve asset  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset to add  */ function addReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {     require(!isReserveAsset[_setToken][_reserveAsset], "Reserve asset already exists");      navIssuanceSettings[_setToken].reserveAssets.push(_reserveAsset);     isReserveAsset[_setToken][_reserveAsset] = true;      emit ReserveAssetAdded(_setToken, _reserveAsset); }  /**  * SET MANAGER ONLY. Remove a reserve asset  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset to remove  */ function removeReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {     require(isReserveAsset[_setToken][_reserveAsset], "Reserve asset does not exist");      navIssuanceSettings[_setToken].reserveAssets = navIssuanceSettings[_setToken].reserveAssets.remove(_reserveAsset);     delete isReserveAsset[_setToken][_reserveAsset];      emit ReserveAssetRemoved(_setToken, _reserveAsset); }  /**  * SET MANAGER ONLY. Edit the premium percentage  *  * @param _setToken                     Instance of the SetToken  * @param _premiumPercentage            Premium percentage in 10e16 (e.g. 10e16 = 1%)  */ function editPremium(ISetToken _setToken, uint256 _premiumPercentage) external onlyManagerAndValidSet(_setToken) {     require(_premiumPercentage &lt;= navIssuanceSettings[_setToken].maxPremiumPercentage, "Premium must be less than maximum allowed");      navIssuanceSettings[_setToken].premiumPercentage = _premiumPercentage;      emit PremiumEdited(_setToken, _premiumPercentage); }  /**  * SET MANAGER ONLY. Edit manager fee  *  * @param _setToken                     Instance of the SetToken  * @param _managerFeePercentage         Manager fee percentage in 10e16 (e.g. 10e16 = 1%)  * @param _managerFeeIndex              Manager fee index. 0 index is issue fee, 1 index is redeem fee  */ function editManagerFee(     ISetToken _setToken,     uint256 _managerFeePercentage,     uint256 _managerFeeIndex )     external     onlyManagerAndValidSet(_setToken) {     require(_managerFeePercentage &lt;= navIssuanceSettings[_setToken].maxManagerFee, "Manager fee must be less than maximum allowed");      navIssuanceSettings[_setToken].managerFees[_managerFeeIndex] = _managerFeePercentage;      emit ManagerFeeEdited(_setToken, _managerFeePercentage, _managerFeeIndex); }  /**  * SET MANAGER ONLY. Edit the manager fee recipient  *  * @param _setToken                     Instance of the SetToken  * @param _managerFeeRecipient          Manager fee recipient  */ function editFeeRecipient(ISetToken _setToken, address _managerFeeRecipient) external onlyManagerAndValidSet(_setToken) {     require(_managerFeeRecipient != address(0), "Fee recipient must not be 0 address");      navIssuanceSettings[_setToken].feeRecipient = _managerFeeRecipient;      emit FeeRecipientEdited(_setToken, _managerFeeRecipient); }  /**  * SET MANAGER ONLY. Initializes this module to the SetToken with hooks, allowed reserve assets,  * fees and issuance premium. Only callable by the SetToken's manager. Hook addresses are optional.  * Address(0) means that no hook will be called.  *  * @param _setToken                     Instance of the SetToken to issue  * @param _navIssuanceSettings          NAVIssuanceSettings struct defining parameters  */ function initialize(     ISetToken _setToken,     NAVIssuanceSettings memory _navIssuanceSettings )     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     require(_navIssuanceSettings.reserveAssets.length &gt; 0, "Reserve assets must be greater than 0");     require(_navIssuanceSettings.maxManagerFee &lt; PreciseUnitMath.preciseUnit(), "Max manager fee must be less than 100%");     require(_navIssuanceSettings.maxPremiumPercentage &lt; PreciseUnitMath.preciseUnit(), "Max premium percentage must be less than 100%");     require(_navIssuanceSettings.managerFees[0] &lt;= _navIssuanceSettings.maxManagerFee, "Manager issue fee must be less than max");     require(_navIssuanceSettings.managerFees[1] &lt;= _navIssuanceSettings.maxManagerFee, "Manager redeem fee must be less than max");     require(_navIssuanceSettings.premiumPercentage &lt;= _navIssuanceSettings.maxPremiumPercentage, "Premium must be less than max");     require(_navIssuanceSettings.feeRecipient != address(0), "Fee Recipient must be non-zero address.");     // Initial mint of Set cannot use NAVIssuance since minSetTokenSupply must be &gt; 0     require(_navIssuanceSettings.minSetTokenSupply &gt; 0, "Min SetToken supply must be greater than 0");      for (uint256 i = 0; i &lt; _navIssuanceSettings.reserveAssets.length; i++) {         require(!isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]], "Reserve assets must be unique");         isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]] = true;     }      navIssuanceSettings[_setToken] = _navIssuanceSettings;      _setToken.initializeModule(); }  /**  * Removes this module from the SetToken, via call by the SetToken. Issuance settings and  * reserve asset states are deleted.  */ function removeModule() external override {     ISetToken setToken = ISetToken(msg.sender);     for (uint256 i = 0; i &lt; navIssuanceSettings[setToken].reserveAssets.length; i++) {         delete isReserveAsset[setToken][navIssuanceSettings[setToken].reserveAssets[i]];     }      delete navIssuanceSettings[setToken]; }  receive() external payable {}  /* ============ External Getter Functions ============ */  function getReserveAssets(ISetToken _setToken) external view returns (address[] memory) {     return navIssuanceSettings[_setToken].reserveAssets; }  function getIssuePremium(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     external     view     returns (uint256) {     return _getIssuePremium(_setToken, _reserveAsset, _reserveAssetQuantity); }  function getRedeemPremium(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     external     view     returns (uint256) {     return _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity); }  function getManagerFee(ISetToken _setToken, uint256 _managerFeeIndex) external view returns (uint256) {     return navIssuanceSettings[_setToken].managerFees[_managerFeeIndex]; }  /**  * Get the expected SetTokens minted to recipient on issuance  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with  *  * @return  uint256                     Expected SetTokens to be minted to recipient  */ function getExpectedSetTokenIssueQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     external     view     returns (uint256) {     (,, uint256 netReserveFlow) = _getFees(         _setToken,         _reserveAssetQuantity,         PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_ISSUE_DIRECT_FEE_INDEX,         MANAGER_ISSUE_FEE_INDEX     );      uint256 setTotalSupply = _setToken.totalSupply();      return _getSetTokenMintQuantity(         _setToken,         _reserveAsset,         netReserveFlow,         setTotalSupply     ); }  /**  * Get the expected reserve asset to be redeemed  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _setTokenQuantity             Quantity of SetTokens to redeem  *  * @return  uint256                     Expected reserve asset quantity redeemed  */ function getExpectedReserveRedeemQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     external     view     returns (uint256) {     uint256 preFeeReserveQuantity = _getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);      (,, uint256 netReserveFlows) = _getFees(         _setToken,         preFeeReserveQuantity,         PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_REDEEM_DIRECT_FEE_INDEX,         MANAGER_REDEEM_FEE_INDEX     );      return netReserveFlows; }  /**  * Checks if issue is valid  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with  *  * @return  bool                        Returns true if issue is valid  */ function isIssueValid(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     external     view     returns (bool) {     uint256 setTotalSupply = _setToken.totalSupply();  return _reserveAssetQuantity != 0         &amp;&amp; isReserveAsset[_setToken][_reserveAsset]         &amp;&amp; setTotalSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply; }  /**  * Checks if redeem is valid  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAsset                 Address of the reserve asset  * @param _setTokenQuantity             Quantity of SetTokens to redeem  *  * @return  bool                        Returns true if redeem is valid  */ function isRedeemValid(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     external     view     returns (bool) {     uint256 setTotalSupply = _setToken.totalSupply();      if (         _setTokenQuantity == 0         || !isReserveAsset[_setToken][_reserveAsset]         || setTotalSupply &lt; navIssuanceSettings[_setToken].minSetTokenSupply.add(_setTokenQuantity)     ) {         return false;     } else {         uint256 totalRedeemValue =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);          (,, uint256 expectedRedeemQuantity) = _getFees(             _setToken,             totalRedeemValue,             PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,             PROTOCOL_REDEEM_DIRECT_FEE_INDEX,             MANAGER_REDEEM_FEE_INDEX         );          uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();          return existingUnit.preciseMul(setTotalSupply) &gt;= expectedRedeemQuantity;     } }  /* ============ Internal Functions ============ */  function _validateCommon(ISetToken _setToken, address _reserveAsset, uint256 _quantity) internal view {     require(_quantity &gt; 0, "Quantity must be &gt; 0");     require(isReserveAsset[_setToken][_reserveAsset], "Must be valid reserve asset"); }  function _validateIssuanceInfo(ISetToken _setToken, uint256 _minSetTokenReceiveQuantity, ActionInfo memory _issueInfo) internal view {     // Check that total supply is greater than min supply needed for issuance     // Note: A min supply amount is needed to avoid division by 0 when SetToken supply is 0     require(         _issueInfo.previousSetTokenSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply,         "Supply must be greater than minimum to enable issuance"     );      require(_issueInfo.setTokenQuantity &gt;= _minSetTokenReceiveQuantity, "Must be greater than min SetToken"); }  function _validateRedemptionInfo(     ISetToken _setToken,     uint256 _minReserveReceiveQuantity,     ActionInfo memory _redeemInfo )     internal     view {     // Check that new supply is more than min supply needed for redemption     // Note: A min supply amount is needed to avoid division by 0 when redeeming SetToken to 0     require(         _redeemInfo.newSetTokenSupply &gt;= navIssuanceSettings[_setToken].minSetTokenSupply,         "Supply must be greater than minimum to enable redemption"     );      require(_redeemInfo.netFlowQuantity &gt;= _minReserveReceiveQuantity, "Must be greater than min receive reserve quantity"); }  function _createIssuanceInfo(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity )     internal     view     returns (ActionInfo memory) {     ActionInfo memory issueInfo;      issueInfo.previousSetTokenSupply = _setToken.totalSupply();      issueInfo.preFeeReserveQuantity = _reserveAssetQuantity;      (issueInfo.protocolFees, issueInfo.managerFee, issueInfo.netFlowQuantity) = _getFees(         _setToken,         issueInfo.preFeeReserveQuantity,         PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_ISSUE_DIRECT_FEE_INDEX,         MANAGER_ISSUE_FEE_INDEX     );      issueInfo.setTokenQuantity = _getSetTokenMintQuantity(         _setToken,         _reserveAsset,         issueInfo.netFlowQuantity,         issueInfo.previousSetTokenSupply     );      (issueInfo.newSetTokenSupply, issueInfo.newPositionMultiplier) = _getIssuePositionMultiplier(_setToken, issueInfo);      issueInfo.newReservePositionUnit = _getIssuePositionUnit(_setToken, _reserveAsset, issueInfo);      return issueInfo; }  function _createRedemptionInfo(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     internal     view     returns (ActionInfo memory) {     ActionInfo memory redeemInfo;      redeemInfo.setTokenQuantity = _setTokenQuantity;      redeemInfo.preFeeReserveQuantity =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);      (redeemInfo.protocolFees, redeemInfo.managerFee, redeemInfo.netFlowQuantity) = _getFees(         _setToken,         redeemInfo.preFeeReserveQuantity,         PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,         PROTOCOL_REDEEM_DIRECT_FEE_INDEX,         MANAGER_REDEEM_FEE_INDEX     );      redeemInfo.previousSetTokenSupply = _setToken.totalSupply();      (redeemInfo.newSetTokenSupply, redeemInfo.newPositionMultiplier) = _getRedeemPositionMultiplier(_setToken, _setTokenQuantity, redeemInfo);      redeemInfo.newReservePositionUnit = _getRedeemPositionUnit(_setToken, _reserveAsset, redeemInfo);      return redeemInfo; }  /**  * Transfer reserve asset from user to SetToken and fees from user to appropriate fee recipients  */ function _transferCollateralAndHandleFees(ISetToken _setToken, IERC20 _reserveAsset, ActionInfo memory _issueInfo) internal {     transferFrom(_reserveAsset, msg.sender, address(_setToken), _issueInfo.netFlowQuantity);      if (_issueInfo.protocolFees &gt; 0) {         transferFrom(_reserveAsset, msg.sender, controller.feeRecipient(), _issueInfo.protocolFees);     }      if (_issueInfo.managerFee &gt; 0) {         transferFrom(_reserveAsset, msg.sender, navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);     } }   /**   * Transfer WETH from module to SetToken and fees from module to appropriate fee recipients  */ function _transferWETHAndHandleFees(ISetToken _setToken, ActionInfo memory _issueInfo) internal {     weth.transfer(address(_setToken), _issueInfo.netFlowQuantity);      if (_issueInfo.protocolFees &gt; 0) {         weth.transfer(controller.feeRecipient(), _issueInfo.protocolFees);     }      if (_issueInfo.managerFee &gt; 0) {         weth.transfer(navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);     } }  function _handleIssueStateUpdates(     ISetToken _setToken,     address _reserveAsset,     address _to,     ActionInfo memory _issueInfo )     internal {     _setToken.editPositionMultiplier(_issueInfo.newPositionMultiplier);      _setToken.editDefaultPosition(_reserveAsset, _issueInfo.newReservePositionUnit);      _setToken.mint(_to, _issueInfo.setTokenQuantity);      emit SetTokenNAVIssued(         _setToken,         msg.sender,         _to,         _reserveAsset,         address(navIssuanceSettings[_setToken].managerIssuanceHook),         _issueInfo.setTokenQuantity,         _issueInfo.managerFee,         _issueInfo.protocolFees     ); }  function _handleRedeemStateUpdates(     ISetToken _setToken,     address _reserveAsset,     address _to,     ActionInfo memory _redeemInfo )     internal {     _setToken.editPositionMultiplier(_redeemInfo.newPositionMultiplier);      _setToken.editDefaultPosition(_reserveAsset, _redeemInfo.newReservePositionUnit);      emit SetTokenNAVRedeemed(         _setToken,         msg.sender,         _to,         _reserveAsset,         address(navIssuanceSettings[_setToken].managerRedemptionHook),         _redeemInfo.setTokenQuantity,         _redeemInfo.managerFee,         _redeemInfo.protocolFees     ); }  function _handleRedemptionFees(ISetToken _setToken, address _reserveAsset, ActionInfo memory _redeemInfo) internal {     // Instruct the SetToken to transfer protocol fee to fee recipient if there is a fee     payProtocolFeeFromSetToken(_setToken, _reserveAsset, _redeemInfo.protocolFees);      // Instruct the SetToken to transfer manager fee to manager fee recipient if there is a fee     if (_redeemInfo.managerFee &gt; 0) {         _setToken.strictInvokeTransfer(             _reserveAsset,             navIssuanceSettings[_setToken].feeRecipient,             _redeemInfo.managerFee         );     } }  /**  * Returns the issue premium percentage. Virtual function that can be overridden in future versions of the module  * and can contain arbitrary logic to calculate the issuance premium.  */ function _getIssuePremium(     ISetToken _setToken,     address /* _reserveAsset */,     uint256 /* _reserveAssetQuantity */ )     virtual     internal     view     returns (uint256) {     return navIssuanceSettings[_setToken].premiumPercentage; }  /**  * Returns the redeem premium percentage. Virtual function that can be overridden in future versions of the module  * and can contain arbitrary logic to calculate the redemption premium.  */ function _getRedeemPremium(     ISetToken _setToken,     address /* _reserveAsset */,     uint256 /* _setTokenQuantity */ )     virtual     internal     view     returns (uint256) {     return navIssuanceSettings[_setToken].premiumPercentage; }  /**  * Returns the fees attributed to the manager and the protocol. The fees are calculated as follows:  *  * ManagerFee = (manager fee % - % to protocol) * reserveAssetQuantity  * Protocol Fee = (% manager fee share + direct fee %) * reserveAssetQuantity  *  * @param _setToken                     Instance of the SetToken  * @param _reserveAssetQuantity         Quantity of reserve asset to calculate fees from  * @param _protocolManagerFeeIndex      Index to pull rev share NAV Issuance fee from the Controller  * @param _protocolDirectFeeIndex       Index to pull direct NAV issuance fee from the Controller  * @param _managerFeeIndex              Index from NAVIssuanceSettings (0 = issue fee, 1 = redeem fee)  *  * @return  uint256                     Fees paid to the protocol in reserve asset  * @return  uint256                     Fees paid to the manager in reserve asset  * @return  uint256                     Net reserve to user net of fees  */ function _getFees(     ISetToken _setToken,     uint256 _reserveAssetQuantity,     uint256 _protocolManagerFeeIndex,     uint256 _protocolDirectFeeIndex,     uint256 _managerFeeIndex )     internal     view     returns (uint256, uint256, uint256) {     (uint256 protocolFeePercentage, uint256 managerFeePercentage) = _getProtocolAndManagerFeePercentages(         _setToken,         _protocolManagerFeeIndex,         _protocolDirectFeeIndex,         _managerFeeIndex     );      // Calculate total notional fees     uint256 protocolFees = protocolFeePercentage.preciseMul(_reserveAssetQuantity);     uint256 managerFee = managerFeePercentage.preciseMul(_reserveAssetQuantity);      uint256 netReserveFlow = _reserveAssetQuantity.sub(protocolFees).sub(managerFee);      return (protocolFees, managerFee, netReserveFlow); }  function _getProtocolAndManagerFeePercentages(     ISetToken _setToken,     uint256 _protocolManagerFeeIndex,     uint256 _protocolDirectFeeIndex,     uint256 _managerFeeIndex )     internal     view     returns(uint256, uint256) {     // Get protocol fee percentages     uint256 protocolDirectFeePercent = controller.getModuleFee(address(this), _protocolDirectFeeIndex);     uint256 protocolManagerShareFeePercent = controller.getModuleFee(address(this), _protocolManagerFeeIndex);     uint256 managerFeePercent = navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];      // Calculate revenue share split percentage     uint256 protocolRevenueSharePercentage = protocolManagerShareFeePercent.preciseMul(managerFeePercent);     uint256 managerRevenueSharePercentage = managerFeePercent.sub(protocolRevenueSharePercentage);     uint256 totalProtocolFeePercentage = protocolRevenueSharePercentage.add(protocolDirectFeePercent);      return (totalProtocolFeePercentage, managerRevenueSharePercentage); }  function _getSetTokenMintQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _netReserveFlows,            // Value of reserve asset net of fees     uint256 _setTotalSupply )     internal     view     returns (uint256) {     uint256 premiumPercentage = _getIssuePremium(_setToken, _reserveAsset, _netReserveFlows);     uint256 premiumValue = _netReserveFlows.preciseMul(premiumPercentage);      // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (1e18)     // Reverts if price is not found     uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);      // Get reserve asset decimals     uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();     uint256 normalizedTotalReserveQuantityNetFees = _netReserveFlows.preciseDiv(10 ** reserveAssetDecimals);     uint256 normalizedTotalReserveQuantityNetFeesAndPremium = _netReserveFlows.sub(premiumValue).preciseDiv(10 ** reserveAssetDecimals);      // Calculate SetTokens to mint to issuer     uint256 denominator = _setTotalSupply.preciseMul(setTokenValuation).add(normalizedTotalReserveQuantityNetFees).sub(normalizedTotalReserveQuantityNetFeesAndPremium);     return normalizedTotalReserveQuantityNetFeesAndPremium.preciseMul(_setTotalSupply).preciseDiv(denominator); }  function _getRedeemReserveQuantity(     ISetToken _setToken,     address _reserveAsset,     uint256 _setTokenQuantity )     internal     view     returns (uint256) {     // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (10e18)     // Reverts if price is not found     uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);      uint256 totalRedeemValueInPreciseUnits = _setTokenQuantity.preciseMul(setTokenValuation);     // Get reserve asset decimals     uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();     uint256 prePremiumReserveQuantity = totalRedeemValueInPreciseUnits.preciseMul(10 ** reserveAssetDecimals);      uint256 premiumPercentage = _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);     uint256 premiumQuantity = prePremiumReserveQuantity.preciseMulCeil(premiumPercentage);      return prePremiumReserveQuantity.sub(premiumQuantity); }  /**  * The new position multiplier is calculated as follows:  * inflationPercentage = (newSupply - oldSupply) / newSupply  * newMultiplier = (1 - inflationPercentage) * positionMultiplier  */ function _getIssuePositionMultiplier(     ISetToken _setToken,     ActionInfo memory _issueInfo )     internal     view     returns (uint256, int256) {     // Calculate inflation and new position multiplier. Note: Round inflation up in order to round position multiplier down     uint256 newTotalSupply = _issueInfo.setTokenQuantity.add(_issueInfo.previousSetTokenSupply);     int256 newPositionMultiplier = _setToken.positionMultiplier()         .mul(_issueInfo.previousSetTokenSupply.toInt256())         .div(newTotalSupply.toInt256());      return (newTotalSupply, newPositionMultiplier); }  /**  * Calculate deflation and new position multiplier. Note: Round deflation down in order to round position multiplier down  *  * The new position multiplier is calculated as follows:  * deflationPercentage = (oldSupply - newSupply) / newSupply  * newMultiplier = (1 + deflationPercentage) * positionMultiplier  */ function _getRedeemPositionMultiplier(     ISetToken _setToken,     uint256 _setTokenQuantity,     ActionInfo memory _redeemInfo )     internal     view     returns (uint256, int256) {     uint256 newTotalSupply = _redeemInfo.previousSetTokenSupply.sub(_setTokenQuantity);     int256 newPositionMultiplier = _setToken.positionMultiplier()         .mul(_redeemInfo.previousSetTokenSupply.toInt256())         .div(newTotalSupply.toInt256());      return (newTotalSupply, newPositionMultiplier); }  /**  * The new position reserve asset unit is calculated as follows:  * totalReserve = (oldUnit * oldSetTokenSupply) + reserveQuantity  * newUnit = totalReserve / newSetTokenSupply  */ function _getIssuePositionUnit(     ISetToken _setToken,     address _reserveAsset,     ActionInfo memory _issueInfo )     internal     view     returns (uint256) {     uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();     uint256 totalReserve = existingUnit         .preciseMul(_issueInfo.previousSetTokenSupply)         .add(_issueInfo.netFlowQuantity);      return totalReserve.preciseDiv(_issueInfo.newSetTokenSupply); }  /**  * The new position reserve asset unit is calculated as follows:  * totalReserve = (oldUnit * oldSetTokenSupply) - reserveQuantityToSendOut  * newUnit = totalReserve / newSetTokenSupply  */ function _getRedeemPositionUnit(     ISetToken _setToken,     address _reserveAsset,     ActionInfo memory _redeemInfo )     internal     view     returns (uint256) {     uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();     uint256 totalExistingUnits = existingUnit.preciseMul(_redeemInfo.previousSetTokenSupply);      uint256 outflow = _redeemInfo.netFlowQuantity.add(_redeemInfo.protocolFees).add(_redeemInfo.managerFee);      // Require withdrawable quantity is greater than existing collateral     require(totalExistingUnits &gt;= outflow, "Must be greater than total available collateral");      return totalExistingUnits.sub(outflow).preciseDiv(_redeemInfo.newSetTokenSupply); }  /**  * If a pre-issue hook has been configured, call the external-protocol contract. Pre-issue hook logic  * can contain arbitrary logic including validations, external function calls, etc.  */ function _callPreIssueHooks(     ISetToken _setToken,     address _reserveAsset,     uint256 _reserveAssetQuantity,     address _caller,     address _to )     internal {     INAVIssuanceHook preIssueHook = navIssuanceSettings[_setToken].managerIssuanceHook;     if (address(preIssueHook) != address(0)) {         preIssueHook.invokePreIssueHook(_setToken, _reserveAsset, _reserveAssetQuantity, _caller, _to);     } }  /**  * If a pre-redeem hook has been configured, call the external-protocol contract.  */ function _callPreRedeemHooks(ISetToken _setToken, uint256 _setQuantity, address _caller, address _to) internal {     INAVIssuanceHook preRedeemHook = navIssuanceSettings[_setToken].managerRedemptionHook;     if (address(preRedeemHook) != address(0)) {         preRedeemHook.invokePreRedeemHook(_setToken, _setQuantity, _caller, _to);     } }  } |
| **with_task_specify** | False |
| **memory** | None |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 05:32:00 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures
Here is a new customer's task: /*
    Copyright 2020 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";
import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";
import { SignedSafeMath } from "@openzeppelin/contracts/math/SignedSafeMath.sol";

import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";
import { IController } from "../../interfaces/IController.sol";
import { INAVIssuanceHook } from "../../interfaces/INAVIssuanceHook.sol";
import { Invoke } from "../lib/Invoke.sol";
import { ISetToken } from "../../interfaces/ISetToken.sol";
import { IWETH } from "../../interfaces/external/IWETH.sol";
import { ModuleBase } from "../lib/ModuleBase.sol";
import { Position } from "../lib/Position.sol";
import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";
import { ResourceIdentifier } from "../lib/ResourceIdentifier.sol";


/**
 * @title NavIssuanceModule
 * @author Set Protocol
 *
 * Module that enables issuance and redemption with any valid ERC20 token or ETH if allowed by the manager. Sender receives
 * a proportional amount of SetTokens on issuance or ERC20 token on redemption based on the calculated net asset value using
 * oracle prices. Manager is able to enforce a premium / discount on issuance / redemption to avoid arbitrage and front
 * running when relying on oracle prices. Managers can charge a fee (denominated in reserve asset).
 */
contract NavIssuanceModule is ModuleBase, ReentrancyGuard {
    using AddressArrayUtils for address[];
    using Invoke for ISetToken;
    using Position for ISetToken;
    using PreciseUnitMath for uint256;
    using PreciseUnitMath for int256;
    using ResourceIdentifier for IController;
    using SafeMath for uint256;
    using SafeCast for int256;
    using SafeCast for uint256;
    using SignedSafeMath for int256;

    /* ============ Events ============ */

    event SetTokenNAVIssued(
        ISetToken indexed _setToken,
        address _issuer,
        address _to,
        address _reserveAsset,
        address _hookContract,
        uint256 _setTokenQuantity,
        uint256 _managerFee,
        uint256 _premium
    );

    event SetTokenNAVRedeemed(
        ISetToken indexed _setToken,
        address _redeemer,
        address _to,
        address _reserveAsset,
        address _hookContract,
        uint256 _setTokenQuantity,
        uint256 _managerFee,
        uint256 _premium
    );

    event ReserveAssetAdded(
        ISetToken indexed _setToken,
        address _newReserveAsset
    );

    event ReserveAssetRemoved(
        ISetToken indexed _setToken,
        address _removedReserveAsset
    );

    event PremiumEdited(
        ISetToken indexed _setToken,
        uint256 _newPremium
    );

    event ManagerFeeEdited(
        ISetToken indexed _setToken,
        uint256 _newManagerFee,
        uint256 _index
    );

    event FeeRecipientEdited(
        ISetToken indexed _setToken,
        address _feeRecipient
    );

    /* ============ Structs ============ */

    struct NAVIssuanceSettings {
        INAVIssuanceHook managerIssuanceHook;      // Issuance hook configurations
        INAVIssuanceHook managerRedemptionHook;    // Redemption hook configurations
        address[] reserveAssets;                       // Allowed reserve assets - Must have a price enabled with the price oracle
        address feeRecipient;                          // Manager fee recipient
        uint256[2] managerFees;                        // Manager fees. 0 index is issue and 1 index is redeem fee (0.01% = 1e14, 1% = 1e16)
        uint256 maxManagerFee;                         // Maximum fee manager is allowed to set for issue and redeem
        uint256 premiumPercentage;                     // Premium percentage (0.01% = 1e14, 1% = 1e16). This premium is a buffer around oracle
                                                       // prices paid by user to the SetToken, which prevents arbitrage and oracle front running
        uint256 maxPremiumPercentage;                  // Maximum premium percentage manager is allowed to set (configured by manager)
        uint256 minSetTokenSupply;                     // Minimum SetToken supply required for issuance and redemption
                                                       // to prevent dramatic inflationary changes to the SetToken's position multiplier
    }

    struct ActionInfo {
        uint256 preFeeReserveQuantity;                 // Reserve value before fees; During issuance, represents raw quantity
                                                       // During redeem, represents post-premium value
        uint256 protocolFees;                          // Total protocol fees (direct + manager revenue share)
        uint256 managerFee;                            // Total manager fee paid in reserve asset
        uint256 netFlowQuantity;                       // When issuing, quantity of reserve asset sent to SetToken
                                                       // When redeeming, quantity of reserve asset sent to redeemer
        uint256 setTokenQuantity;                      // When issuing, quantity of SetTokens minted to mintee
                                                       // When redeeming, quantity of SetToken redeemed
        uint256 previousSetTokenSupply;                // SetToken supply prior to issue/redeem action
        uint256 newSetTokenSupply;                     // SetToken supply after issue/redeem action
        int256 newPositionMultiplier;                  // SetToken position multiplier after issue/redeem
        uint256 newReservePositionUnit;                // SetToken reserve asset position unit after issue/redeem
    }

    /* ============ State Variables ============ */

    // Wrapped ETH address
    IWETH public immutable weth;

    // Mapping of SetToken to NAV issuance settings struct
    mapping(ISetToken => NAVIssuanceSettings) public navIssuanceSettings;

    // Mapping to efficiently check a SetToken's reserve asset validity
    // SetToken => reserveAsset => isReserveAsset
    mapping(ISetToken => mapping(address => bool)) public isReserveAsset;

    /* ============ Constants ============ */

    // 0 index stores the manager fee in managerFees array, percentage charged on issue (denominated in reserve asset)
    uint256 constant internal MANAGER_ISSUE_FEE_INDEX = 0;

    // 1 index stores the manager fee percentage in managerFees array, charged on redeem
    uint256 constant internal MANAGER_REDEEM_FEE_INDEX = 1;

    // 0 index stores the manager revenue share protocol fee % on the controller, charged in the issuance function
    uint256 constant internal PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX = 0;

    // 1 index stores the manager revenue share protocol fee % on the controller, charged in the redeem function
    uint256 constant internal PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX = 1;

    // 2 index stores the direct protocol fee % on the controller, charged in the issuance function
    uint256 constant internal PROTOCOL_ISSUE_DIRECT_FEE_INDEX = 2;

    // 3 index stores the direct protocol fee % on the controller, charged in the redeem function
    uint256 constant internal PROTOCOL_REDEEM_DIRECT_FEE_INDEX = 3;

    /* ============ Constructor ============ */

    /**
     * @param _controller               Address of controller contract
     * @param _weth                     Address of wrapped eth
     */
    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {
        weth = _weth;
    }

    /* ============ External Functions ============ */

    /**
     * Deposits the allowed reserve asset into the SetToken and mints the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _reserveAsset                 Address of the reserve asset to issue with
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance
     * @param _to                           Address to mint SetToken to
     */
    function issue(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity,
        uint256 _minSetTokenReceiveQuantity,
        address _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, _reserveAsset, _reserveAssetQuantity);

        _callPreIssueHooks(_setToken, _reserveAsset, _reserveAssetQuantity, msg.sender, _to);

        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, _reserveAsset, _reserveAssetQuantity);

        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);

        _transferCollateralAndHandleFees(_setToken, IERC20(_reserveAsset), issueInfo);

        _handleIssueStateUpdates(_setToken, _reserveAsset, _to, issueInfo);
    }

    /**
     * Wraps ETH and deposits WETH if allowed into the SetToken and mints the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance
     * @param _to                           Address to mint SetToken to
     */
    function issueWithEther(
        ISetToken _setToken,
        uint256 _minSetTokenReceiveQuantity,
        address _to
    )
        external
        payable
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        weth.deposit{ value: msg.value }();

        _validateCommon(_setToken, address(weth), msg.value);

        _callPreIssueHooks(_setToken, address(weth), msg.value, msg.sender, _to);

        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, address(weth), msg.value);

        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);

        _transferWETHAndHandleFees(_setToken, issueInfo);

        _handleIssueStateUpdates(_setToken, address(weth), _to, issueInfo);
    }

    /**
     * Redeems a SetToken into a valid reserve asset representing the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address. Only valid if there are available reserve units on the SetToken.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _reserveAsset                 Address of the reserve asset to redeem with
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive
     * @param _to                           Address to redeem reserve asset to
     */
    function redeem(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity,
        uint256 _minReserveReceiveQuantity,
        address _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, _reserveAsset, _setTokenQuantity);

        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);

        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, _reserveAsset, _setTokenQuantity);

        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);

        _setToken.burn(msg.sender, _setTokenQuantity);

        // Instruct the SetToken to transfer the reserve asset back to the user
        _setToken.strictInvokeTransfer(
            _reserveAsset,
            _to,
            redeemInfo.netFlowQuantity
        );

        _handleRedemptionFees(_setToken, _reserveAsset, redeemInfo);

        _handleRedeemStateUpdates(_setToken, _reserveAsset, _to, redeemInfo);
    }

    /**
     * Redeems a SetToken into Ether (if WETH is valid) representing the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address. Only valid if there are available WETH units on the SetToken.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive
     * @param _to                           Address to redeem reserve asset to
     */
    function redeemIntoEther(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        uint256 _minReserveReceiveQuantity,
        address payable _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, address(weth), _setTokenQuantity);

        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);

        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, address(weth), _setTokenQuantity);

        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);

        _setToken.burn(msg.sender, _setTokenQuantity);

        // Instruct the SetToken to transfer WETH from SetToken to module
        _setToken.strictInvokeTransfer(
            address(weth),
            address(this),
            redeemInfo.netFlowQuantity
        );

        weth.withdraw(redeemInfo.netFlowQuantity);

        _to.transfer(redeemInfo.netFlowQuantity);

        _handleRedemptionFees(_setToken, address(weth), redeemInfo);

        _handleRedeemStateUpdates(_setToken, address(weth), _to, redeemInfo);
    }

    /**
     * SET MANAGER ONLY. Add an allowed reserve asset
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset to add
     */
    function addReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {
        require(!isReserveAsset[_setToken][_reserveAsset], "Reserve asset already exists");

        navIssuanceSettings[_setToken].reserveAssets.push(_reserveAsset);
        isReserveAsset[_setToken][_reserveAsset] = true;

        emit ReserveAssetAdded(_setToken, _reserveAsset);
    }

    /**
     * SET MANAGER ONLY. Remove a reserve asset
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset to remove
     */
    function removeReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {
        require(isReserveAsset[_setToken][_reserveAsset], "Reserve asset does not exist");

        navIssuanceSettings[_setToken].reserveAssets = navIssuanceSettings[_setToken].reserveAssets.remove(_reserveAsset);
        delete isReserveAsset[_setToken][_reserveAsset];

        emit ReserveAssetRemoved(_setToken, _reserveAsset);
    }

    /**
     * SET MANAGER ONLY. Edit the premium percentage
     *
     * @param _setToken                     Instance of the SetToken
     * @param _premiumPercentage            Premium percentage in 10e16 (e.g. 10e16 = 1%)
     */
    function editPremium(ISetToken _setToken, uint256 _premiumPercentage) external onlyManagerAndValidSet(_setToken) {
        require(_premiumPercentage <= navIssuanceSettings[_setToken].maxPremiumPercentage, "Premium must be less than maximum allowed");

        navIssuanceSettings[_setToken].premiumPercentage = _premiumPercentage;

        emit PremiumEdited(_setToken, _premiumPercentage);
    }

    /**
     * SET MANAGER ONLY. Edit manager fee
     *
     * @param _setToken                     Instance of the SetToken
     * @param _managerFeePercentage         Manager fee percentage in 10e16 (e.g. 10e16 = 1%)
     * @param _managerFeeIndex              Manager fee index. 0 index is issue fee, 1 index is redeem fee
     */
    function editManagerFee(
        ISetToken _setToken,
        uint256 _managerFeePercentage,
        uint256 _managerFeeIndex
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        require(_managerFeePercentage <= navIssuanceSettings[_setToken].maxManagerFee, "Manager fee must be less than maximum allowed");

        navIssuanceSettings[_setToken].managerFees[_managerFeeIndex] = _managerFeePercentage;

        emit ManagerFeeEdited(_setToken, _managerFeePercentage, _managerFeeIndex);
    }

    /**
     * SET MANAGER ONLY. Edit the manager fee recipient
     *
     * @param _setToken                     Instance of the SetToken
     * @param _managerFeeRecipient          Manager fee recipient
     */
    function editFeeRecipient(ISetToken _setToken, address _managerFeeRecipient) external onlyManagerAndValidSet(_setToken) {
        require(_managerFeeRecipient != address(0), "Fee recipient must not be 0 address");

        navIssuanceSettings[_setToken].feeRecipient = _managerFeeRecipient;

        emit FeeRecipientEdited(_setToken, _managerFeeRecipient);
    }

    /**
     * SET MANAGER ONLY. Initializes this module to the SetToken with hooks, allowed reserve assets,
     * fees and issuance premium. Only callable by the SetToken's manager. Hook addresses are optional.
     * Address(0) means that no hook will be called.
     *
     * @param _setToken                     Instance of the SetToken to issue
     * @param _navIssuanceSettings          NAVIssuanceSettings struct defining parameters
     */
    function initialize(
        ISetToken _setToken,
        NAVIssuanceSettings memory _navIssuanceSettings
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        require(_navIssuanceSettings.reserveAssets.length > 0, "Reserve assets must be greater than 0");
        require(_navIssuanceSettings.maxManagerFee < PreciseUnitMath.preciseUnit(), "Max manager fee must be less than 100%");
        require(_navIssuanceSettings.maxPremiumPercentage < PreciseUnitMath.preciseUnit(), "Max premium percentage must be less than 100%");
        require(_navIssuanceSettings.managerFees[0] <= _navIssuanceSettings.maxManagerFee, "Manager issue fee must be less than max");
        require(_navIssuanceSettings.managerFees[1] <= _navIssuanceSettings.maxManagerFee, "Manager redeem fee must be less than max");
        require(_navIssuanceSettings.premiumPercentage <= _navIssuanceSettings.maxPremiumPercentage, "Premium must be less than max");
        require(_navIssuanceSettings.feeRecipient != address(0), "Fee Recipient must be non-zero address.");
        // Initial mint of Set cannot use NAVIssuance since minSetTokenSupply must be > 0
        require(_navIssuanceSettings.minSetTokenSupply > 0, "Min SetToken supply must be greater than 0");

        for (uint256 i = 0; i < _navIssuanceSettings.reserveAssets.length; i++) {
            require(!isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]], "Reserve assets must be unique");
            isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]] = true;
        }

        navIssuanceSettings[_setToken] = _navIssuanceSettings;

        _setToken.initializeModule();
    }

    /**
     * Removes this module from the SetToken, via call by the SetToken. Issuance settings and
     * reserve asset states are deleted.
     */
    function removeModule() external override {
        ISetToken setToken = ISetToken(msg.sender);
        for (uint256 i = 0; i < navIssuanceSettings[setToken].reserveAssets.length; i++) {
            delete isReserveAsset[setToken][navIssuanceSettings[setToken].reserveAssets[i]];
        }

        delete navIssuanceSettings[setToken];
    }

    receive() external payable {}

    /* ============ External Getter Functions ============ */

    function getReserveAssets(ISetToken _setToken) external view returns (address[] memory) {
        return navIssuanceSettings[_setToken].reserveAssets;
    }

    function getIssuePremium(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (uint256)
    {
        return _getIssuePremium(_setToken, _reserveAsset, _reserveAssetQuantity);
    }

    function getRedeemPremium(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (uint256)
    {
        return _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);
    }

    function getManagerFee(ISetToken _setToken, uint256 _managerFeeIndex) external view returns (uint256) {
        return navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];
    }

    /**
     * Get the expected SetTokens minted to recipient on issuance
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     *
     * @return  uint256                     Expected SetTokens to be minted to recipient
     */
    function getExpectedSetTokenIssueQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (uint256)
    {
        (,, uint256 netReserveFlow) = _getFees(
            _setToken,
            _reserveAssetQuantity,
            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,
            MANAGER_ISSUE_FEE_INDEX
        );

        uint256 setTotalSupply = _setToken.totalSupply();

        return _getSetTokenMintQuantity(
            _setToken,
            _reserveAsset,
            netReserveFlow,
            setTotalSupply
        );
    }

    /**
     * Get the expected reserve asset to be redeemed
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     *
     * @return  uint256                     Expected reserve asset quantity redeemed
     */
    function getExpectedReserveRedeemQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (uint256)
    {
        uint256 preFeeReserveQuantity = _getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

        (,, uint256 netReserveFlows) = _getFees(
            _setToken,
            preFeeReserveQuantity,
            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
            MANAGER_REDEEM_FEE_INDEX
        );

        return netReserveFlows;
    }

    /**
     * Checks if issue is valid
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     *
     * @return  bool                        Returns true if issue is valid
     */
    function isIssueValid(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (bool)
    {
        uint256 setTotalSupply = _setToken.totalSupply();

    return _reserveAssetQuantity != 0
            && isReserveAsset[_setToken][_reserveAsset]
            && setTotalSupply >= navIssuanceSettings[_setToken].minSetTokenSupply;
    }

    /**
     * Checks if redeem is valid
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     *
     * @return  bool                        Returns true if redeem is valid
     */
    function isRedeemValid(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (bool)
    {
        uint256 setTotalSupply = _setToken.totalSupply();

        if (
            _setTokenQuantity == 0
            || !isReserveAsset[_setToken][_reserveAsset]
            || setTotalSupply < navIssuanceSettings[_setToken].minSetTokenSupply.add(_setTokenQuantity)
        ) {
            return false;
        } else {
            uint256 totalRedeemValue =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

            (,, uint256 expectedRedeemQuantity) = _getFees(
                _setToken,
                totalRedeemValue,
                PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
                PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
                MANAGER_REDEEM_FEE_INDEX
            );

            uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();

            return existingUnit.preciseMul(setTotalSupply) >= expectedRedeemQuantity;
        }
    }

    /* ============ Internal Functions ============ */

    function _validateCommon(ISetToken _setToken, address _reserveAsset, uint256 _quantity) internal view {
        require(_quantity > 0, "Quantity must be > 0");
        require(isReserveAsset[_setToken][_reserveAsset], "Must be valid reserve asset");
    }

    function _validateIssuanceInfo(ISetToken _setToken, uint256 _minSetTokenReceiveQuantity, ActionInfo memory _issueInfo) internal view {
        // Check that total supply is greater than min supply needed for issuance
        // Note: A min supply amount is needed to avoid division by 0 when SetToken supply is 0
        require(
            _issueInfo.previousSetTokenSupply >= navIssuanceSettings[_setToken].minSetTokenSupply,
            "Supply must be greater than minimum to enable issuance"
        );

        require(_issueInfo.setTokenQuantity >= _minSetTokenReceiveQuantity, "Must be greater than min SetToken");
    }

    function _validateRedemptionInfo(
        ISetToken _setToken,
        uint256 _minReserveReceiveQuantity,
        ActionInfo memory _redeemInfo
    )
        internal
        view
    {
        // Check that new supply is more than min supply needed for redemption
        // Note: A min supply amount is needed to avoid division by 0 when redeeming SetToken to 0
        require(
            _redeemInfo.newSetTokenSupply >= navIssuanceSettings[_setToken].minSetTokenSupply,
            "Supply must be greater than minimum to enable redemption"
        );

        require(_redeemInfo.netFlowQuantity >= _minReserveReceiveQuantity, "Must be greater than min receive reserve quantity");
    }

    function _createIssuanceInfo(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        internal
        view
        returns (ActionInfo memory)
    {
        ActionInfo memory issueInfo;

        issueInfo.previousSetTokenSupply = _setToken.totalSupply();

        issueInfo.preFeeReserveQuantity = _reserveAssetQuantity;

        (issueInfo.protocolFees, issueInfo.managerFee, issueInfo.netFlowQuantity) = _getFees(
            _setToken,
            issueInfo.preFeeReserveQuantity,
            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,
            MANAGER_ISSUE_FEE_INDEX
        );

        issueInfo.setTokenQuantity = _getSetTokenMintQuantity(
            _setToken,
            _reserveAsset,
            issueInfo.netFlowQuantity,
            issueInfo.previousSetTokenSupply
        );

        (issueInfo.newSetTokenSupply, issueInfo.newPositionMultiplier) = _getIssuePositionMultiplier(_setToken, issueInfo);

        issueInfo.newReservePositionUnit = _getIssuePositionUnit(_setToken, _reserveAsset, issueInfo);

        return issueInfo;
    }

    function _createRedemptionInfo(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        internal
        view
        returns (ActionInfo memory)
    {
        ActionInfo memory redeemInfo;

        redeemInfo.setTokenQuantity = _setTokenQuantity;

        redeemInfo.preFeeReserveQuantity =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

        (redeemInfo.protocolFees, redeemInfo.managerFee, redeemInfo.netFlowQuantity) = _getFees(
            _setToken,
            redeemInfo.preFeeReserveQuantity,
            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
            MANAGER_REDEEM_FEE_INDEX
        );

        redeemInfo.previousSetTokenSupply = _setToken.totalSupply();

        (redeemInfo.newSetTokenSupply, redeemInfo.newPositionMultiplier) = _getRedeemPositionMultiplier(_setToken, _setTokenQuantity, redeemInfo);

        redeemInfo.newReservePositionUnit = _getRedeemPositionUnit(_setToken, _reserveAsset, redeemInfo);

        return redeemInfo;
    }

    /**
     * Transfer reserve asset from user to SetToken and fees from user to appropriate fee recipients
     */
    function _transferCollateralAndHandleFees(ISetToken _setToken, IERC20 _reserveAsset, ActionInfo memory _issueInfo) internal {
        transferFrom(_reserveAsset, msg.sender, address(_setToken), _issueInfo.netFlowQuantity);

        if (_issueInfo.protocolFees > 0) {
            transferFrom(_reserveAsset, msg.sender, controller.feeRecipient(), _issueInfo.protocolFees);
        }

        if (_issueInfo.managerFee > 0) {
            transferFrom(_reserveAsset, msg.sender, navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);
        }
    }


    /**
      * Transfer WETH from module to SetToken and fees from module to appropriate fee recipients
     */
    function _transferWETHAndHandleFees(ISetToken _setToken, ActionInfo memory _issueInfo) internal {
        weth.transfer(address(_setToken), _issueInfo.netFlowQuantity);

        if (_issueInfo.protocolFees > 0) {
            weth.transfer(controller.feeRecipient(), _issueInfo.protocolFees);
        }

        if (_issueInfo.managerFee > 0) {
            weth.transfer(navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);
        }
    }

    function _handleIssueStateUpdates(
        ISetToken _setToken,
        address _reserveAsset,
        address _to,
        ActionInfo memory _issueInfo
    )
        internal
    {
        _setToken.editPositionMultiplier(_issueInfo.newPositionMultiplier);

        _setToken.editDefaultPosition(_reserveAsset, _issueInfo.newReservePositionUnit);

        _setToken.mint(_to, _issueInfo.setTokenQuantity);

        emit SetTokenNAVIssued(
            _setToken,
            msg.sender,
            _to,
            _reserveAsset,
            address(navIssuanceSettings[_setToken].managerIssuanceHook),
            _issueInfo.setTokenQuantity,
            _issueInfo.managerFee,
            _issueInfo.protocolFees
        );
    }

    function _handleRedeemStateUpdates(
        ISetToken _setToken,
        address _reserveAsset,
        address _to,
        ActionInfo memory _redeemInfo
    )
        internal
    {
        _setToken.editPositionMultiplier(_redeemInfo.newPositionMultiplier);

        _setToken.editDefaultPosition(_reserveAsset, _redeemInfo.newReservePositionUnit);

        emit SetTokenNAVRedeemed(
            _setToken,
            msg.sender,
            _to,
            _reserveAsset,
            address(navIssuanceSettings[_setToken].managerRedemptionHook),
            _redeemInfo.setTokenQuantity,
            _redeemInfo.managerFee,
            _redeemInfo.protocolFees
        );
    }

    function _handleRedemptionFees(ISetToken _setToken, address _reserveAsset, ActionInfo memory _redeemInfo) internal {
        // Instruct the SetToken to transfer protocol fee to fee recipient if there is a fee
        payProtocolFeeFromSetToken(_setToken, _reserveAsset, _redeemInfo.protocolFees);

        // Instruct the SetToken to transfer manager fee to manager fee recipient if there is a fee
        if (_redeemInfo.managerFee > 0) {
            _setToken.strictInvokeTransfer(
                _reserveAsset,
                navIssuanceSettings[_setToken].feeRecipient,
                _redeemInfo.managerFee
            );
        }
    }

    /**
     * Returns the issue premium percentage. Virtual function that can be overridden in future versions of the module
     * and can contain arbitrary logic to calculate the issuance premium.
     */
    function _getIssuePremium(
        ISetToken _setToken,
        address /* _reserveAsset */,
        uint256 /* _reserveAssetQuantity */
    )
        virtual
        internal
        view
        returns (uint256)
    {
        return navIssuanceSettings[_setToken].premiumPercentage;
    }

    /**
     * Returns the redeem premium percentage. Virtual function that can be overridden in future versions of the module
     * and can contain arbitrary logic to calculate the redemption premium.
     */
    function _getRedeemPremium(
        ISetToken _setToken,
        address /* _reserveAsset */,
        uint256 /* _setTokenQuantity */
    )
        virtual
        internal
        view
        returns (uint256)
    {
        return navIssuanceSettings[_setToken].premiumPercentage;
    }

    /**
     * Returns the fees attributed to the manager and the protocol. The fees are calculated as follows:
     *
     * ManagerFee = (manager fee % - % to protocol) * reserveAssetQuantity
     * Protocol Fee = (% manager fee share + direct fee %) * reserveAssetQuantity
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAssetQuantity         Quantity of reserve asset to calculate fees from
     * @param _protocolManagerFeeIndex      Index to pull rev share NAV Issuance fee from the Controller
     * @param _protocolDirectFeeIndex       Index to pull direct NAV issuance fee from the Controller
     * @param _managerFeeIndex              Index from NAVIssuanceSettings (0 = issue fee, 1 = redeem fee)
     *
     * @return  uint256                     Fees paid to the protocol in reserve asset
     * @return  uint256                     Fees paid to the manager in reserve asset
     * @return  uint256                     Net reserve to user net of fees
     */
    function _getFees(
        ISetToken _setToken,
        uint256 _reserveAssetQuantity,
        uint256 _protocolManagerFeeIndex,
        uint256 _protocolDirectFeeIndex,
        uint256 _managerFeeIndex
    )
        internal
        view
        returns (uint256, uint256, uint256)
    {
        (uint256 protocolFeePercentage, uint256 managerFeePercentage) = _getProtocolAndManagerFeePercentages(
            _setToken,
            _protocolManagerFeeIndex,
            _protocolDirectFeeIndex,
            _managerFeeIndex
        );

        // Calculate total notional fees
        uint256 protocolFees = protocolFeePercentage.preciseMul(_reserveAssetQuantity);
        uint256 managerFee = managerFeePercentage.preciseMul(_reserveAssetQuantity);

        uint256 netReserveFlow = _reserveAssetQuantity.sub(protocolFees).sub(managerFee);

        return (protocolFees, managerFee, netReserveFlow);
    }

    function _getProtocolAndManagerFeePercentages(
        ISetToken _setToken,
        uint256 _protocolManagerFeeIndex,
        uint256 _protocolDirectFeeIndex,
        uint256 _managerFeeIndex
    )
        internal
        view
        returns(uint256, uint256)
    {
        // Get protocol fee percentages
        uint256 protocolDirectFeePercent = controller.getModuleFee(address(this), _protocolDirectFeeIndex);
        uint256 protocolManagerShareFeePercent = controller.getModuleFee(address(this), _protocolManagerFeeIndex);
        uint256 managerFeePercent = navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];

        // Calculate revenue share split percentage
        uint256 protocolRevenueSharePercentage = protocolManagerShareFeePercent.preciseMul(managerFeePercent);
        uint256 managerRevenueSharePercentage = managerFeePercent.sub(protocolRevenueSharePercentage);
        uint256 totalProtocolFeePercentage = protocolRevenueSharePercentage.add(protocolDirectFeePercent);

        return (totalProtocolFeePercentage, managerRevenueSharePercentage);
    }

    function _getSetTokenMintQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _netReserveFlows,            // Value of reserve asset net of fees
        uint256 _setTotalSupply
    )
        internal
        view
        returns (uint256)
    {
        uint256 premiumPercentage = _getIssuePremium(_setToken, _reserveAsset, _netReserveFlows);
        uint256 premiumValue = _netReserveFlows.preciseMul(premiumPercentage);

        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (1e18)
        // Reverts if price is not found
        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);

        // Get reserve asset decimals
        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();
        uint256 normalizedTotalReserveQuantityNetFees = _netReserveFlows.preciseDiv(10 ** reserveAssetDecimals);
        uint256 normalizedTotalReserveQuantityNetFeesAndPremium = _netReserveFlows.sub(premiumValue).preciseDiv(10 ** reserveAssetDecimals);

        // Calculate SetTokens to mint to issuer
        uint256 denominator = _setTotalSupply.preciseMul(setTokenValuation).add(normalizedTotalReserveQuantityNetFees).sub(normalizedTotalReserveQuantityNetFeesAndPremium);
        return normalizedTotalReserveQuantityNetFeesAndPremium.preciseMul(_setTotalSupply).preciseDiv(denominator);
    }

    function _getRedeemReserveQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        internal
        view
        returns (uint256)
    {
        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (10e18)
        // Reverts if price is not found
        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);

        uint256 totalRedeemValueInPreciseUnits = _setTokenQuantity.preciseMul(setTokenValuation);
        // Get reserve asset decimals
        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();
        uint256 prePremiumReserveQuantity = totalRedeemValueInPreciseUnits.preciseMul(10 ** reserveAssetDecimals);

        uint256 premiumPercentage = _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);
        uint256 premiumQuantity = prePremiumReserveQuantity.preciseMulCeil(premiumPercentage);

        return prePremiumReserveQuantity.sub(premiumQuantity);
    }

    /**
     * The new position multiplier is calculated as follows:
     * inflationPercentage = (newSupply - oldSupply) / newSupply
     * newMultiplier = (1 - inflationPercentage) * positionMultiplier
     */
    function _getIssuePositionMultiplier(
        ISetToken _setToken,
        ActionInfo memory _issueInfo
    )
        internal
        view
        returns (uint256, int256)
    {
        // Calculate inflation and new position multiplier. Note: Round inflation up in order to round position multiplier down
        uint256 newTotalSupply = _issueInfo.setTokenQuantity.add(_issueInfo.previousSetTokenSupply);
        int256 newPositionMultiplier = _setToken.positionMultiplier()
            .mul(_issueInfo.previousSetTokenSupply.toInt256())
            .div(newTotalSupply.toInt256());

        return (newTotalSupply, newPositionMultiplier);
    }

    /**
     * Calculate deflation and new position multiplier. Note: Round deflation down in order to round position multiplier down
     *
     * The new position multiplier is calculated as follows:
     * deflationPercentage = (oldSupply - newSupply) / newSupply
     * newMultiplier = (1 + deflationPercentage) * positionMultiplier
     */
    function _getRedeemPositionMultiplier(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        ActionInfo memory _redeemInfo
    )
        internal
        view
        returns (uint256, int256)
    {
        uint256 newTotalSupply = _redeemInfo.previousSetTokenSupply.sub(_setTokenQuantity);
        int256 newPositionMultiplier = _setToken.positionMultiplier()
            .mul(_redeemInfo.previousSetTokenSupply.toInt256())
            .div(newTotalSupply.toInt256());

        return (newTotalSupply, newPositionMultiplier);
    }

    /**
     * The new position reserve asset unit is calculated as follows:
     * totalReserve = (oldUnit * oldSetTokenSupply) + reserveQuantity
     * newUnit = totalReserve / newSetTokenSupply
     */
    function _getIssuePositionUnit(
        ISetToken _setToken,
        address _reserveAsset,
        ActionInfo memory _issueInfo
    )
        internal
        view
        returns (uint256)
    {
        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();
        uint256 totalReserve = existingUnit
            .preciseMul(_issueInfo.previousSetTokenSupply)
            .add(_issueInfo.netFlowQuantity);

        return totalReserve.preciseDiv(_issueInfo.newSetTokenSupply);
    }

    /**
     * The new position reserve asset unit is calculated as follows:
     * totalReserve = (oldUnit * oldSetTokenSupply) - reserveQuantityToSendOut
     * newUnit = totalReserve / newSetTokenSupply
     */
    function _getRedeemPositionUnit(
        ISetToken _setToken,
        address _reserveAsset,
        ActionInfo memory _redeemInfo
    )
        internal
        view
        returns (uint256)
    {
        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();
        uint256 totalExistingUnits = existingUnit.preciseMul(_redeemInfo.previousSetTokenSupply);

        uint256 outflow = _redeemInfo.netFlowQuantity.add(_redeemInfo.protocolFees).add(_redeemInfo.managerFee);

        // Require withdrawable quantity is greater than existing collateral
        require(totalExistingUnits >= outflow, "Must be greater than total available collateral");

        return totalExistingUnits.sub(outflow).preciseDiv(_redeemInfo.newSetTokenSupply);
    }

    /**
     * If a pre-issue hook has been configured, call the external-protocol contract. Pre-issue hook logic
     * can contain arbitrary logic including validations, external function calls, etc.
     */
    function _callPreIssueHooks(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity,
        address _caller,
        address _to
    )
        internal
    {
        INAVIssuanceHook preIssueHook = navIssuanceSettings[_setToken].managerIssuanceHook;
        if (address(preIssueHook) != address(0)) {
            preIssueHook.invokePreIssueHook(_setToken, _reserveAsset, _reserveAssetQuantity, _caller, _to);
        }
    }

    /**
     * If a pre-redeem hook has been configured, call the external-protocol contract.
     */
    function _callPreRedeemHooks(ISetToken _setToken, uint256 _setQuantity, address _caller, address _to) internal {
        INAVIssuanceHook preRedeemHook = navIssuanceSettings[_setToken].managerRedemptionHook;
        if (address(preRedeemHook) != address(0)) {
            preRedeemHook.invokePreRedeemHook(_setToken, _setQuantity, _caller, _to);
        }
    }
}.]

Below are the details of our target smart contract codes and their associated test reports:

Task: "/*
    Copyright 2020 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";
import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";
import { SignedSafeMath } from "@openzeppelin/contracts/math/SignedSafeMath.sol";

import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";
import { IController } from "../../interfaces/IController.sol";
import { INAVIssuanceHook } from "../../interfaces/INAVIssuanceHook.sol";
import { Invoke } from "../lib/Invoke.sol";
import { ISetToken } from "../../interfaces/ISetToken.sol";
import { IWETH } from "../../interfaces/external/IWETH.sol";
import { ModuleBase } from "../lib/ModuleBase.sol";
import { Position } from "../lib/Position.sol";
import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";
import { ResourceIdentifier } from "../lib/ResourceIdentifier.sol";


/**
 * @title NavIssuanceModule
 * @author Set Protocol
 *
 * Module that enables issuance and redemption with any valid ERC20 token or ETH if allowed by the manager. Sender receives
 * a proportional amount of SetTokens on issuance or ERC20 token on redemption based on the calculated net asset value using
 * oracle prices. Manager is able to enforce a premium / discount on issuance / redemption to avoid arbitrage and front
 * running when relying on oracle prices. Managers can charge a fee (denominated in reserve asset).
 */
contract NavIssuanceModule is ModuleBase, ReentrancyGuard {
    using AddressArrayUtils for address[];
    using Invoke for ISetToken;
    using Position for ISetToken;
    using PreciseUnitMath for uint256;
    using PreciseUnitMath for int256;
    using ResourceIdentifier for IController;
    using SafeMath for uint256;
    using SafeCast for int256;
    using SafeCast for uint256;
    using SignedSafeMath for int256;

    /* ============ Events ============ */

    event SetTokenNAVIssued(
        ISetToken indexed _setToken,
        address _issuer,
        address _to,
        address _reserveAsset,
        address _hookContract,
        uint256 _setTokenQuantity,
        uint256 _managerFee,
        uint256 _premium
    );

    event SetTokenNAVRedeemed(
        ISetToken indexed _setToken,
        address _redeemer,
        address _to,
        address _reserveAsset,
        address _hookContract,
        uint256 _setTokenQuantity,
        uint256 _managerFee,
        uint256 _premium
    );

    event ReserveAssetAdded(
        ISetToken indexed _setToken,
        address _newReserveAsset
    );

    event ReserveAssetRemoved(
        ISetToken indexed _setToken,
        address _removedReserveAsset
    );

    event PremiumEdited(
        ISetToken indexed _setToken,
        uint256 _newPremium
    );

    event ManagerFeeEdited(
        ISetToken indexed _setToken,
        uint256 _newManagerFee,
        uint256 _index
    );

    event FeeRecipientEdited(
        ISetToken indexed _setToken,
        address _feeRecipient
    );

    /* ============ Structs ============ */

    struct NAVIssuanceSettings {
        INAVIssuanceHook managerIssuanceHook;      // Issuance hook configurations
        INAVIssuanceHook managerRedemptionHook;    // Redemption hook configurations
        address[] reserveAssets;                       // Allowed reserve assets - Must have a price enabled with the price oracle
        address feeRecipient;                          // Manager fee recipient
        uint256[2] managerFees;                        // Manager fees. 0 index is issue and 1 index is redeem fee (0.01% = 1e14, 1% = 1e16)
        uint256 maxManagerFee;                         // Maximum fee manager is allowed to set for issue and redeem
        uint256 premiumPercentage;                     // Premium percentage (0.01% = 1e14, 1% = 1e16). This premium is a buffer around oracle
                                                       // prices paid by user to the SetToken, which prevents arbitrage and oracle front running
        uint256 maxPremiumPercentage;                  // Maximum premium percentage manager is allowed to set (configured by manager)
        uint256 minSetTokenSupply;                     // Minimum SetToken supply required for issuance and redemption
                                                       // to prevent dramatic inflationary changes to the SetToken's position multiplier
    }

    struct ActionInfo {
        uint256 preFeeReserveQuantity;                 // Reserve value before fees; During issuance, represents raw quantity
                                                       // During redeem, represents post-premium value
        uint256 protocolFees;                          // Total protocol fees (direct + manager revenue share)
        uint256 managerFee;                            // Total manager fee paid in reserve asset
        uint256 netFlowQuantity;                       // When issuing, quantity of reserve asset sent to SetToken
                                                       // When redeeming, quantity of reserve asset sent to redeemer
        uint256 setTokenQuantity;                      // When issuing, quantity of SetTokens minted to mintee
                                                       // When redeeming, quantity of SetToken redeemed
        uint256 previousSetTokenSupply;                // SetToken supply prior to issue/redeem action
        uint256 newSetTokenSupply;                     // SetToken supply after issue/redeem action
        int256 newPositionMultiplier;                  // SetToken position multiplier after issue/redeem
        uint256 newReservePositionUnit;                // SetToken reserve asset position unit after issue/redeem
    }

    /* ============ State Variables ============ */

    // Wrapped ETH address
    IWETH public immutable weth;

    // Mapping of SetToken to NAV issuance settings struct
    mapping(ISetToken => NAVIssuanceSettings) public navIssuanceSettings;

    // Mapping to efficiently check a SetToken's reserve asset validity
    // SetToken => reserveAsset => isReserveAsset
    mapping(ISetToken => mapping(address => bool)) public isReserveAsset;

    /* ============ Constants ============ */

    // 0 index stores the manager fee in managerFees array, percentage charged on issue (denominated in reserve asset)
    uint256 constant internal MANAGER_ISSUE_FEE_INDEX = 0;

    // 1 index stores the manager fee percentage in managerFees array, charged on redeem
    uint256 constant internal MANAGER_REDEEM_FEE_INDEX = 1;

    // 0 index stores the manager revenue share protocol fee % on the controller, charged in the issuance function
    uint256 constant internal PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX = 0;

    // 1 index stores the manager revenue share protocol fee % on the controller, charged in the redeem function
    uint256 constant internal PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX = 1;

    // 2 index stores the direct protocol fee % on the controller, charged in the issuance function
    uint256 constant internal PROTOCOL_ISSUE_DIRECT_FEE_INDEX = 2;

    // 3 index stores the direct protocol fee % on the controller, charged in the redeem function
    uint256 constant internal PROTOCOL_REDEEM_DIRECT_FEE_INDEX = 3;

    /* ============ Constructor ============ */

    /**
     * @param _controller               Address of controller contract
     * @param _weth                     Address of wrapped eth
     */
    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {
        weth = _weth;
    }

    /* ============ External Functions ============ */

    /**
     * Deposits the allowed reserve asset into the SetToken and mints the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _reserveAsset                 Address of the reserve asset to issue with
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance
     * @param _to                           Address to mint SetToken to
     */
    function issue(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity,
        uint256 _minSetTokenReceiveQuantity,
        address _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, _reserveAsset, _reserveAssetQuantity);

        _callPreIssueHooks(_setToken, _reserveAsset, _reserveAssetQuantity, msg.sender, _to);

        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, _reserveAsset, _reserveAssetQuantity);

        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);

        _transferCollateralAndHandleFees(_setToken, IERC20(_reserveAsset), issueInfo);

        _handleIssueStateUpdates(_setToken, _reserveAsset, _to, issueInfo);
    }

    /**
     * Wraps ETH and deposits WETH if allowed into the SetToken and mints the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _minSetTokenReceiveQuantity   Min quantity of SetToken to receive after issuance
     * @param _to                           Address to mint SetToken to
     */
    function issueWithEther(
        ISetToken _setToken,
        uint256 _minSetTokenReceiveQuantity,
        address _to
    )
        external
        payable
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        weth.deposit{ value: msg.value }();

        _validateCommon(_setToken, address(weth), msg.value);

        _callPreIssueHooks(_setToken, address(weth), msg.value, msg.sender, _to);

        ActionInfo memory issueInfo = _createIssuanceInfo(_setToken, address(weth), msg.value);

        _validateIssuanceInfo(_setToken, _minSetTokenReceiveQuantity, issueInfo);

        _transferWETHAndHandleFees(_setToken, issueInfo);

        _handleIssueStateUpdates(_setToken, address(weth), _to, issueInfo);
    }

    /**
     * Redeems a SetToken into a valid reserve asset representing the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address. Only valid if there are available reserve units on the SetToken.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _reserveAsset                 Address of the reserve asset to redeem with
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive
     * @param _to                           Address to redeem reserve asset to
     */
    function redeem(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity,
        uint256 _minReserveReceiveQuantity,
        address _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, _reserveAsset, _setTokenQuantity);

        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);

        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, _reserveAsset, _setTokenQuantity);

        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);

        _setToken.burn(msg.sender, _setTokenQuantity);

        // Instruct the SetToken to transfer the reserve asset back to the user
        _setToken.strictInvokeTransfer(
            _reserveAsset,
            _to,
            redeemInfo.netFlowQuantity
        );

        _handleRedemptionFees(_setToken, _reserveAsset, redeemInfo);

        _handleRedeemStateUpdates(_setToken, _reserveAsset, _to, redeemInfo);
    }

    /**
     * Redeems a SetToken into Ether (if WETH is valid) representing the appropriate % of Net Asset Value of the SetToken
     * to the specified _to address. Only valid if there are available WETH units on the SetToken.
     *
     * @param _setToken                     Instance of the SetToken contract
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     * @param _minReserveReceiveQuantity    Min quantity of reserve asset to receive
     * @param _to                           Address to redeem reserve asset to
     */
    function redeemIntoEther(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        uint256 _minReserveReceiveQuantity,
        address payable _to
    )
        external
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        _validateCommon(_setToken, address(weth), _setTokenQuantity);

        _callPreRedeemHooks(_setToken, _setTokenQuantity, msg.sender, _to);

        ActionInfo memory redeemInfo = _createRedemptionInfo(_setToken, address(weth), _setTokenQuantity);

        _validateRedemptionInfo(_setToken, _minReserveReceiveQuantity, redeemInfo);

        _setToken.burn(msg.sender, _setTokenQuantity);

        // Instruct the SetToken to transfer WETH from SetToken to module
        _setToken.strictInvokeTransfer(
            address(weth),
            address(this),
            redeemInfo.netFlowQuantity
        );

        weth.withdraw(redeemInfo.netFlowQuantity);

        _to.transfer(redeemInfo.netFlowQuantity);

        _handleRedemptionFees(_setToken, address(weth), redeemInfo);

        _handleRedeemStateUpdates(_setToken, address(weth), _to, redeemInfo);
    }

    /**
     * SET MANAGER ONLY. Add an allowed reserve asset
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset to add
     */
    function addReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {
        require(!isReserveAsset[_setToken][_reserveAsset], "Reserve asset already exists");

        navIssuanceSettings[_setToken].reserveAssets.push(_reserveAsset);
        isReserveAsset[_setToken][_reserveAsset] = true;

        emit ReserveAssetAdded(_setToken, _reserveAsset);
    }

    /**
     * SET MANAGER ONLY. Remove a reserve asset
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset to remove
     */
    function removeReserveAsset(ISetToken _setToken, address _reserveAsset) external onlyManagerAndValidSet(_setToken) {
        require(isReserveAsset[_setToken][_reserveAsset], "Reserve asset does not exist");

        navIssuanceSettings[_setToken].reserveAssets = navIssuanceSettings[_setToken].reserveAssets.remove(_reserveAsset);
        delete isReserveAsset[_setToken][_reserveAsset];

        emit ReserveAssetRemoved(_setToken, _reserveAsset);
    }

    /**
     * SET MANAGER ONLY. Edit the premium percentage
     *
     * @param _setToken                     Instance of the SetToken
     * @param _premiumPercentage            Premium percentage in 10e16 (e.g. 10e16 = 1%)
     */
    function editPremium(ISetToken _setToken, uint256 _premiumPercentage) external onlyManagerAndValidSet(_setToken) {
        require(_premiumPercentage <= navIssuanceSettings[_setToken].maxPremiumPercentage, "Premium must be less than maximum allowed");

        navIssuanceSettings[_setToken].premiumPercentage = _premiumPercentage;

        emit PremiumEdited(_setToken, _premiumPercentage);
    }

    /**
     * SET MANAGER ONLY. Edit manager fee
     *
     * @param _setToken                     Instance of the SetToken
     * @param _managerFeePercentage         Manager fee percentage in 10e16 (e.g. 10e16 = 1%)
     * @param _managerFeeIndex              Manager fee index. 0 index is issue fee, 1 index is redeem fee
     */
    function editManagerFee(
        ISetToken _setToken,
        uint256 _managerFeePercentage,
        uint256 _managerFeeIndex
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        require(_managerFeePercentage <= navIssuanceSettings[_setToken].maxManagerFee, "Manager fee must be less than maximum allowed");

        navIssuanceSettings[_setToken].managerFees[_managerFeeIndex] = _managerFeePercentage;

        emit ManagerFeeEdited(_setToken, _managerFeePercentage, _managerFeeIndex);
    }

    /**
     * SET MANAGER ONLY. Edit the manager fee recipient
     *
     * @param _setToken                     Instance of the SetToken
     * @param _managerFeeRecipient          Manager fee recipient
     */
    function editFeeRecipient(ISetToken _setToken, address _managerFeeRecipient) external onlyManagerAndValidSet(_setToken) {
        require(_managerFeeRecipient != address(0), "Fee recipient must not be 0 address");

        navIssuanceSettings[_setToken].feeRecipient = _managerFeeRecipient;

        emit FeeRecipientEdited(_setToken, _managerFeeRecipient);
    }

    /**
     * SET MANAGER ONLY. Initializes this module to the SetToken with hooks, allowed reserve assets,
     * fees and issuance premium. Only callable by the SetToken's manager. Hook addresses are optional.
     * Address(0) means that no hook will be called.
     *
     * @param _setToken                     Instance of the SetToken to issue
     * @param _navIssuanceSettings          NAVIssuanceSettings struct defining parameters
     */
    function initialize(
        ISetToken _setToken,
        NAVIssuanceSettings memory _navIssuanceSettings
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        require(_navIssuanceSettings.reserveAssets.length > 0, "Reserve assets must be greater than 0");
        require(_navIssuanceSettings.maxManagerFee < PreciseUnitMath.preciseUnit(), "Max manager fee must be less than 100%");
        require(_navIssuanceSettings.maxPremiumPercentage < PreciseUnitMath.preciseUnit(), "Max premium percentage must be less than 100%");
        require(_navIssuanceSettings.managerFees[0] <= _navIssuanceSettings.maxManagerFee, "Manager issue fee must be less than max");
        require(_navIssuanceSettings.managerFees[1] <= _navIssuanceSettings.maxManagerFee, "Manager redeem fee must be less than max");
        require(_navIssuanceSettings.premiumPercentage <= _navIssuanceSettings.maxPremiumPercentage, "Premium must be less than max");
        require(_navIssuanceSettings.feeRecipient != address(0), "Fee Recipient must be non-zero address.");
        // Initial mint of Set cannot use NAVIssuance since minSetTokenSupply must be > 0
        require(_navIssuanceSettings.minSetTokenSupply > 0, "Min SetToken supply must be greater than 0");

        for (uint256 i = 0; i < _navIssuanceSettings.reserveAssets.length; i++) {
            require(!isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]], "Reserve assets must be unique");
            isReserveAsset[_setToken][_navIssuanceSettings.reserveAssets[i]] = true;
        }

        navIssuanceSettings[_setToken] = _navIssuanceSettings;

        _setToken.initializeModule();
    }

    /**
     * Removes this module from the SetToken, via call by the SetToken. Issuance settings and
     * reserve asset states are deleted.
     */
    function removeModule() external override {
        ISetToken setToken = ISetToken(msg.sender);
        for (uint256 i = 0; i < navIssuanceSettings[setToken].reserveAssets.length; i++) {
            delete isReserveAsset[setToken][navIssuanceSettings[setToken].reserveAssets[i]];
        }

        delete navIssuanceSettings[setToken];
    }

    receive() external payable {}

    /* ============ External Getter Functions ============ */

    function getReserveAssets(ISetToken _setToken) external view returns (address[] memory) {
        return navIssuanceSettings[_setToken].reserveAssets;
    }

    function getIssuePremium(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (uint256)
    {
        return _getIssuePremium(_setToken, _reserveAsset, _reserveAssetQuantity);
    }

    function getRedeemPremium(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (uint256)
    {
        return _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);
    }

    function getManagerFee(ISetToken _setToken, uint256 _managerFeeIndex) external view returns (uint256) {
        return navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];
    }

    /**
     * Get the expected SetTokens minted to recipient on issuance
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     *
     * @return  uint256                     Expected SetTokens to be minted to recipient
     */
    function getExpectedSetTokenIssueQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (uint256)
    {
        (,, uint256 netReserveFlow) = _getFees(
            _setToken,
            _reserveAssetQuantity,
            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,
            MANAGER_ISSUE_FEE_INDEX
        );

        uint256 setTotalSupply = _setToken.totalSupply();

        return _getSetTokenMintQuantity(
            _setToken,
            _reserveAsset,
            netReserveFlow,
            setTotalSupply
        );
    }

    /**
     * Get the expected reserve asset to be redeemed
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     *
     * @return  uint256                     Expected reserve asset quantity redeemed
     */
    function getExpectedReserveRedeemQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (uint256)
    {
        uint256 preFeeReserveQuantity = _getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

        (,, uint256 netReserveFlows) = _getFees(
            _setToken,
            preFeeReserveQuantity,
            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
            MANAGER_REDEEM_FEE_INDEX
        );

        return netReserveFlows;
    }

    /**
     * Checks if issue is valid
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _reserveAssetQuantity         Quantity of the reserve asset to issue with
     *
     * @return  bool                        Returns true if issue is valid
     */
    function isIssueValid(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        external
        view
        returns (bool)
    {
        uint256 setTotalSupply = _setToken.totalSupply();

    return _reserveAssetQuantity != 0
            && isReserveAsset[_setToken][_reserveAsset]
            && setTotalSupply >= navIssuanceSettings[_setToken].minSetTokenSupply;
    }

    /**
     * Checks if redeem is valid
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAsset                 Address of the reserve asset
     * @param _setTokenQuantity             Quantity of SetTokens to redeem
     *
     * @return  bool                        Returns true if redeem is valid
     */
    function isRedeemValid(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        external
        view
        returns (bool)
    {
        uint256 setTotalSupply = _setToken.totalSupply();

        if (
            _setTokenQuantity == 0
            || !isReserveAsset[_setToken][_reserveAsset]
            || setTotalSupply < navIssuanceSettings[_setToken].minSetTokenSupply.add(_setTokenQuantity)
        ) {
            return false;
        } else {
            uint256 totalRedeemValue =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

            (,, uint256 expectedRedeemQuantity) = _getFees(
                _setToken,
                totalRedeemValue,
                PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
                PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
                MANAGER_REDEEM_FEE_INDEX
            );

            uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();

            return existingUnit.preciseMul(setTotalSupply) >= expectedRedeemQuantity;
        }
    }

    /* ============ Internal Functions ============ */

    function _validateCommon(ISetToken _setToken, address _reserveAsset, uint256 _quantity) internal view {
        require(_quantity > 0, "Quantity must be > 0");
        require(isReserveAsset[_setToken][_reserveAsset], "Must be valid reserve asset");
    }

    function _validateIssuanceInfo(ISetToken _setToken, uint256 _minSetTokenReceiveQuantity, ActionInfo memory _issueInfo) internal view {
        // Check that total supply is greater than min supply needed for issuance
        // Note: A min supply amount is needed to avoid division by 0 when SetToken supply is 0
        require(
            _issueInfo.previousSetTokenSupply >= navIssuanceSettings[_setToken].minSetTokenSupply,
            "Supply must be greater than minimum to enable issuance"
        );

        require(_issueInfo.setTokenQuantity >= _minSetTokenReceiveQuantity, "Must be greater than min SetToken");
    }

    function _validateRedemptionInfo(
        ISetToken _setToken,
        uint256 _minReserveReceiveQuantity,
        ActionInfo memory _redeemInfo
    )
        internal
        view
    {
        // Check that new supply is more than min supply needed for redemption
        // Note: A min supply amount is needed to avoid division by 0 when redeeming SetToken to 0
        require(
            _redeemInfo.newSetTokenSupply >= navIssuanceSettings[_setToken].minSetTokenSupply,
            "Supply must be greater than minimum to enable redemption"
        );

        require(_redeemInfo.netFlowQuantity >= _minReserveReceiveQuantity, "Must be greater than min receive reserve quantity");
    }

    function _createIssuanceInfo(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity
    )
        internal
        view
        returns (ActionInfo memory)
    {
        ActionInfo memory issueInfo;

        issueInfo.previousSetTokenSupply = _setToken.totalSupply();

        issueInfo.preFeeReserveQuantity = _reserveAssetQuantity;

        (issueInfo.protocolFees, issueInfo.managerFee, issueInfo.netFlowQuantity) = _getFees(
            _setToken,
            issueInfo.preFeeReserveQuantity,
            PROTOCOL_ISSUE_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_ISSUE_DIRECT_FEE_INDEX,
            MANAGER_ISSUE_FEE_INDEX
        );

        issueInfo.setTokenQuantity = _getSetTokenMintQuantity(
            _setToken,
            _reserveAsset,
            issueInfo.netFlowQuantity,
            issueInfo.previousSetTokenSupply
        );

        (issueInfo.newSetTokenSupply, issueInfo.newPositionMultiplier) = _getIssuePositionMultiplier(_setToken, issueInfo);

        issueInfo.newReservePositionUnit = _getIssuePositionUnit(_setToken, _reserveAsset, issueInfo);

        return issueInfo;
    }

    function _createRedemptionInfo(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        internal
        view
        returns (ActionInfo memory)
    {
        ActionInfo memory redeemInfo;

        redeemInfo.setTokenQuantity = _setTokenQuantity;

        redeemInfo.preFeeReserveQuantity =_getRedeemReserveQuantity(_setToken, _reserveAsset, _setTokenQuantity);

        (redeemInfo.protocolFees, redeemInfo.managerFee, redeemInfo.netFlowQuantity) = _getFees(
            _setToken,
            redeemInfo.preFeeReserveQuantity,
            PROTOCOL_REDEEM_MANAGER_REVENUE_SHARE_FEE_INDEX,
            PROTOCOL_REDEEM_DIRECT_FEE_INDEX,
            MANAGER_REDEEM_FEE_INDEX
        );

        redeemInfo.previousSetTokenSupply = _setToken.totalSupply();

        (redeemInfo.newSetTokenSupply, redeemInfo.newPositionMultiplier) = _getRedeemPositionMultiplier(_setToken, _setTokenQuantity, redeemInfo);

        redeemInfo.newReservePositionUnit = _getRedeemPositionUnit(_setToken, _reserveAsset, redeemInfo);

        return redeemInfo;
    }

    /**
     * Transfer reserve asset from user to SetToken and fees from user to appropriate fee recipients
     */
    function _transferCollateralAndHandleFees(ISetToken _setToken, IERC20 _reserveAsset, ActionInfo memory _issueInfo) internal {
        transferFrom(_reserveAsset, msg.sender, address(_setToken), _issueInfo.netFlowQuantity);

        if (_issueInfo.protocolFees > 0) {
            transferFrom(_reserveAsset, msg.sender, controller.feeRecipient(), _issueInfo.protocolFees);
        }

        if (_issueInfo.managerFee > 0) {
            transferFrom(_reserveAsset, msg.sender, navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);
        }
    }


    /**
      * Transfer WETH from module to SetToken and fees from module to appropriate fee recipients
     */
    function _transferWETHAndHandleFees(ISetToken _setToken, ActionInfo memory _issueInfo) internal {
        weth.transfer(address(_setToken), _issueInfo.netFlowQuantity);

        if (_issueInfo.protocolFees > 0) {
            weth.transfer(controller.feeRecipient(), _issueInfo.protocolFees);
        }

        if (_issueInfo.managerFee > 0) {
            weth.transfer(navIssuanceSettings[_setToken].feeRecipient, _issueInfo.managerFee);
        }
    }

    function _handleIssueStateUpdates(
        ISetToken _setToken,
        address _reserveAsset,
        address _to,
        ActionInfo memory _issueInfo
    )
        internal
    {
        _setToken.editPositionMultiplier(_issueInfo.newPositionMultiplier);

        _setToken.editDefaultPosition(_reserveAsset, _issueInfo.newReservePositionUnit);

        _setToken.mint(_to, _issueInfo.setTokenQuantity);

        emit SetTokenNAVIssued(
            _setToken,
            msg.sender,
            _to,
            _reserveAsset,
            address(navIssuanceSettings[_setToken].managerIssuanceHook),
            _issueInfo.setTokenQuantity,
            _issueInfo.managerFee,
            _issueInfo.protocolFees
        );
    }

    function _handleRedeemStateUpdates(
        ISetToken _setToken,
        address _reserveAsset,
        address _to,
        ActionInfo memory _redeemInfo
    )
        internal
    {
        _setToken.editPositionMultiplier(_redeemInfo.newPositionMultiplier);

        _setToken.editDefaultPosition(_reserveAsset, _redeemInfo.newReservePositionUnit);

        emit SetTokenNAVRedeemed(
            _setToken,
            msg.sender,
            _to,
            _reserveAsset,
            address(navIssuanceSettings[_setToken].managerRedemptionHook),
            _redeemInfo.setTokenQuantity,
            _redeemInfo.managerFee,
            _redeemInfo.protocolFees
        );
    }

    function _handleRedemptionFees(ISetToken _setToken, address _reserveAsset, ActionInfo memory _redeemInfo) internal {
        // Instruct the SetToken to transfer protocol fee to fee recipient if there is a fee
        payProtocolFeeFromSetToken(_setToken, _reserveAsset, _redeemInfo.protocolFees);

        // Instruct the SetToken to transfer manager fee to manager fee recipient if there is a fee
        if (_redeemInfo.managerFee > 0) {
            _setToken.strictInvokeTransfer(
                _reserveAsset,
                navIssuanceSettings[_setToken].feeRecipient,
                _redeemInfo.managerFee
            );
        }
    }

    /**
     * Returns the issue premium percentage. Virtual function that can be overridden in future versions of the module
     * and can contain arbitrary logic to calculate the issuance premium.
     */
    function _getIssuePremium(
        ISetToken _setToken,
        address /* _reserveAsset */,
        uint256 /* _reserveAssetQuantity */
    )
        virtual
        internal
        view
        returns (uint256)
    {
        return navIssuanceSettings[_setToken].premiumPercentage;
    }

    /**
     * Returns the redeem premium percentage. Virtual function that can be overridden in future versions of the module
     * and can contain arbitrary logic to calculate the redemption premium.
     */
    function _getRedeemPremium(
        ISetToken _setToken,
        address /* _reserveAsset */,
        uint256 /* _setTokenQuantity */
    )
        virtual
        internal
        view
        returns (uint256)
    {
        return navIssuanceSettings[_setToken].premiumPercentage;
    }

    /**
     * Returns the fees attributed to the manager and the protocol. The fees are calculated as follows:
     *
     * ManagerFee = (manager fee % - % to protocol) * reserveAssetQuantity
     * Protocol Fee = (% manager fee share + direct fee %) * reserveAssetQuantity
     *
     * @param _setToken                     Instance of the SetToken
     * @param _reserveAssetQuantity         Quantity of reserve asset to calculate fees from
     * @param _protocolManagerFeeIndex      Index to pull rev share NAV Issuance fee from the Controller
     * @param _protocolDirectFeeIndex       Index to pull direct NAV issuance fee from the Controller
     * @param _managerFeeIndex              Index from NAVIssuanceSettings (0 = issue fee, 1 = redeem fee)
     *
     * @return  uint256                     Fees paid to the protocol in reserve asset
     * @return  uint256                     Fees paid to the manager in reserve asset
     * @return  uint256                     Net reserve to user net of fees
     */
    function _getFees(
        ISetToken _setToken,
        uint256 _reserveAssetQuantity,
        uint256 _protocolManagerFeeIndex,
        uint256 _protocolDirectFeeIndex,
        uint256 _managerFeeIndex
    )
        internal
        view
        returns (uint256, uint256, uint256)
    {
        (uint256 protocolFeePercentage, uint256 managerFeePercentage) = _getProtocolAndManagerFeePercentages(
            _setToken,
            _protocolManagerFeeIndex,
            _protocolDirectFeeIndex,
            _managerFeeIndex
        );

        // Calculate total notional fees
        uint256 protocolFees = protocolFeePercentage.preciseMul(_reserveAssetQuantity);
        uint256 managerFee = managerFeePercentage.preciseMul(_reserveAssetQuantity);

        uint256 netReserveFlow = _reserveAssetQuantity.sub(protocolFees).sub(managerFee);

        return (protocolFees, managerFee, netReserveFlow);
    }

    function _getProtocolAndManagerFeePercentages(
        ISetToken _setToken,
        uint256 _protocolManagerFeeIndex,
        uint256 _protocolDirectFeeIndex,
        uint256 _managerFeeIndex
    )
        internal
        view
        returns(uint256, uint256)
    {
        // Get protocol fee percentages
        uint256 protocolDirectFeePercent = controller.getModuleFee(address(this), _protocolDirectFeeIndex);
        uint256 protocolManagerShareFeePercent = controller.getModuleFee(address(this), _protocolManagerFeeIndex);
        uint256 managerFeePercent = navIssuanceSettings[_setToken].managerFees[_managerFeeIndex];

        // Calculate revenue share split percentage
        uint256 protocolRevenueSharePercentage = protocolManagerShareFeePercent.preciseMul(managerFeePercent);
        uint256 managerRevenueSharePercentage = managerFeePercent.sub(protocolRevenueSharePercentage);
        uint256 totalProtocolFeePercentage = protocolRevenueSharePercentage.add(protocolDirectFeePercent);

        return (totalProtocolFeePercentage, managerRevenueSharePercentage);
    }

    function _getSetTokenMintQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _netReserveFlows,            // Value of reserve asset net of fees
        uint256 _setTotalSupply
    )
        internal
        view
        returns (uint256)
    {
        uint256 premiumPercentage = _getIssuePremium(_setToken, _reserveAsset, _netReserveFlows);
        uint256 premiumValue = _netReserveFlows.preciseMul(premiumPercentage);

        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (1e18)
        // Reverts if price is not found
        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);

        // Get reserve asset decimals
        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();
        uint256 normalizedTotalReserveQuantityNetFees = _netReserveFlows.preciseDiv(10 ** reserveAssetDecimals);
        uint256 normalizedTotalReserveQuantityNetFeesAndPremium = _netReserveFlows.sub(premiumValue).preciseDiv(10 ** reserveAssetDecimals);

        // Calculate SetTokens to mint to issuer
        uint256 denominator = _setTotalSupply.preciseMul(setTokenValuation).add(normalizedTotalReserveQuantityNetFees).sub(normalizedTotalReserveQuantityNetFeesAndPremium);
        return normalizedTotalReserveQuantityNetFeesAndPremium.preciseMul(_setTotalSupply).preciseDiv(denominator);
    }

    function _getRedeemReserveQuantity(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _setTokenQuantity
    )
        internal
        view
        returns (uint256)
    {
        // Get valuation of the SetToken with the quote asset as the reserve asset. Returns value in precise units (10e18)
        // Reverts if price is not found
        uint256 setTokenValuation = controller.getSetValuer().calculateSetTokenValuation(_setToken, _reserveAsset);

        uint256 totalRedeemValueInPreciseUnits = _setTokenQuantity.preciseMul(setTokenValuation);
        // Get reserve asset decimals
        uint256 reserveAssetDecimals = ERC20(_reserveAsset).decimals();
        uint256 prePremiumReserveQuantity = totalRedeemValueInPreciseUnits.preciseMul(10 ** reserveAssetDecimals);

        uint256 premiumPercentage = _getRedeemPremium(_setToken, _reserveAsset, _setTokenQuantity);
        uint256 premiumQuantity = prePremiumReserveQuantity.preciseMulCeil(premiumPercentage);

        return prePremiumReserveQuantity.sub(premiumQuantity);
    }

    /**
     * The new position multiplier is calculated as follows:
     * inflationPercentage = (newSupply - oldSupply) / newSupply
     * newMultiplier = (1 - inflationPercentage) * positionMultiplier
     */
    function _getIssuePositionMultiplier(
        ISetToken _setToken,
        ActionInfo memory _issueInfo
    )
        internal
        view
        returns (uint256, int256)
    {
        // Calculate inflation and new position multiplier. Note: Round inflation up in order to round position multiplier down
        uint256 newTotalSupply = _issueInfo.setTokenQuantity.add(_issueInfo.previousSetTokenSupply);
        int256 newPositionMultiplier = _setToken.positionMultiplier()
            .mul(_issueInfo.previousSetTokenSupply.toInt256())
            .div(newTotalSupply.toInt256());

        return (newTotalSupply, newPositionMultiplier);
    }

    /**
     * Calculate deflation and new position multiplier. Note: Round deflation down in order to round position multiplier down
     *
     * The new position multiplier is calculated as follows:
     * deflationPercentage = (oldSupply - newSupply) / newSupply
     * newMultiplier = (1 + deflationPercentage) * positionMultiplier
     */
    function _getRedeemPositionMultiplier(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        ActionInfo memory _redeemInfo
    )
        internal
        view
        returns (uint256, int256)
    {
        uint256 newTotalSupply = _redeemInfo.previousSetTokenSupply.sub(_setTokenQuantity);
        int256 newPositionMultiplier = _setToken.positionMultiplier()
            .mul(_redeemInfo.previousSetTokenSupply.toInt256())
            .div(newTotalSupply.toInt256());

        return (newTotalSupply, newPositionMultiplier);
    }

    /**
     * The new position reserve asset unit is calculated as follows:
     * totalReserve = (oldUnit * oldSetTokenSupply) + reserveQuantity
     * newUnit = totalReserve / newSetTokenSupply
     */
    function _getIssuePositionUnit(
        ISetToken _setToken,
        address _reserveAsset,
        ActionInfo memory _issueInfo
    )
        internal
        view
        returns (uint256)
    {
        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();
        uint256 totalReserve = existingUnit
            .preciseMul(_issueInfo.previousSetTokenSupply)
            .add(_issueInfo.netFlowQuantity);

        return totalReserve.preciseDiv(_issueInfo.newSetTokenSupply);
    }

    /**
     * The new position reserve asset unit is calculated as follows:
     * totalReserve = (oldUnit * oldSetTokenSupply) - reserveQuantityToSendOut
     * newUnit = totalReserve / newSetTokenSupply
     */
    function _getRedeemPositionUnit(
        ISetToken _setToken,
        address _reserveAsset,
        ActionInfo memory _redeemInfo
    )
        internal
        view
        returns (uint256)
    {
        uint256 existingUnit = _setToken.getDefaultPositionRealUnit(_reserveAsset).toUint256();
        uint256 totalExistingUnits = existingUnit.preciseMul(_redeemInfo.previousSetTokenSupply);

        uint256 outflow = _redeemInfo.netFlowQuantity.add(_redeemInfo.protocolFees).add(_redeemInfo.managerFee);

        // Require withdrawable quantity is greater than existing collateral
        require(totalExistingUnits >= outflow, "Must be greater than total available collateral");

        return totalExistingUnits.sub(outflow).preciseDiv(_redeemInfo.newSetTokenSupply);
    }

    /**
     * If a pre-issue hook has been configured, call the external-protocol contract. Pre-issue hook logic
     * can contain arbitrary logic including validations, external function calls, etc.
     */
    function _callPreIssueHooks(
        ISetToken _setToken,
        address _reserveAsset,
        uint256 _reserveAssetQuantity,
        address _caller,
        address _to
    )
        internal
    {
        INAVIssuanceHook preIssueHook = navIssuanceSettings[_setToken].managerIssuanceHook;
        if (address(preIssueHook) != address(0)) {
            preIssueHook.invokePreIssueHook(_setToken, _reserveAsset, _reserveAssetQuantity, _caller, _to);
        }
    }

    /**
     * If a pre-redeem hook has been configured, call the external-protocol contract.
     */
    function _callPreRedeemHooks(ISetToken _setToken, uint256 _setQuantity, address _caller, address _to) internal {
        INAVIssuanceHook preRedeemHook = navIssuanceSettings[_setToken].managerRedemptionHook;
        if (address(preRedeemHook) != address(0)) {
            preRedeemHook.invokePreRedeemHook(_setToken, _setQuantity, _caller, _to);
        }
    }
}".

Existing Test Reports:

"The software run successfully without errors."

Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings.

